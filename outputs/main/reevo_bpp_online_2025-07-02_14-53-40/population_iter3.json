[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired approach:\n    # Prioritize bins that can accommodate the item and have the least remaining capacity *after* placing the item\n    # to simulate filling them up quickly. Bins that cannot fit get a -inf priority.\n    remaining_capacities_after_insertion = bins_remain_cap - item\n    cannot_fit = remaining_capacities_after_insertion < 0\n    priorities = -remaining_capacities_after_insertion\n    priorities[cannot_fit] = -np.inf\n\n\n    # Add a small bonus to bins that are close to being full even before adding the item\n    # This encourages using bins that are already somewhat filled\n    almost_full_bonus = np.where(bins_remain_cap > 0, np.exp(-bins_remain_cap * 10), 0) # sigmoid-like bonus. Increased the impact of remaining cap on bonus\n    priorities += almost_full_bonus\n\n    # Add a tiny noise, it helps with exploration when all priorities are same\n    noise = np.random.normal(0, 0.0001, size=bins_remain_cap.shape)\n    priorities += noise\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Smaller remaining capacity gets higher priority if feasible\n    remaining_capacity_priority = bins_remain_cap[feasible_bins]\n    \n    # 3. Try to fill up bins which are already not empty\n    non_empty_bins = bins_remain_cap < 1.0 #assuming bin capacity is 1.0\n    \n    # 4. Combination Strategy:\n    priorities[feasible_bins] = 1/(remaining_capacity_priority + 1e-6) # avoid division by zero\n    \n    #Boost priority of bins which are already not empty\n    priorities[non_empty_bins] = priorities[non_empty_bins] * 2\n\n    # Perfect Fit Bonus\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] += 10  # Significantly boost priority for perfect fits\n\n    # Near Fit Bonus (but not too small)\n    near_fit = (bins_remain_cap - item) <= 0.1  # within 10%\n    near_fit = near_fit & (bins_remain_cap > item) #only when fits\n    priorities[near_fit] += 5  # Moderate boost\n\n    #Penalty for almost empty bins if item fits\n    almost_empty = (bins_remain_cap > item) & (bins_remain_cap > 0.9) #Bins that are almost empty\n    priorities[almost_empty] -= 1\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Highest priority for perfect fits\n    perfect_fit = np.isclose(item, bins_remain_cap)\n    priorities[perfect_fit] = 10000.0\n\n    # Consider bins where the item fits\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        waste = bins_remain_cap[fits] - item\n        # Prioritize bins with minimal waste, normalized by item size\n        priorities[fits] = item / (waste + 0.0001)  # Avoid division by zero\n        \n        # Very high priority for near-perfect fits\n        near_perfect = np.isclose(waste, 0, atol=0.01)\n        priorities[fits][near_perfect] = 5000.0\n\n\n    # Large negative priority for bins where the item doesn't fit\n    priorities[~fits] = -1000.0\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            priorities[i] = (item / cap) / (waste / cap + 0.0001) if cap > 0 else 0 # Favor smaller waste relative to capacity and avoid division by zero.  Normalize waste by cap\n        else:\n            priorities[i] = -1  # Negative priority if item doesn't fit\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999992429991835 seconds"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Penalize bins where item doesn't fit by setting priority to -inf.\n    fit_mask = remaining_after_add >= 0\n    priorities[~fit_mask] = -np.inf\n\n    # Give high priority to bins where the item fits and leaves the least amount of wasted space\n    if np.any(fit_mask):\n        # Prioritize based on inverse of remaining space, but avoid extreme values\n        priorities[fit_mask] = 1.0 / (remaining_after_add[fit_mask] + 0.01)  # Adding a small constant to avoid division by zero/very large values\n\n        # Boost bins that are nearly full after adding the item, encouraging full packing.\n        nearly_full_mask = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n        priorities[nearly_full_mask] += 10\n\n    # Handle bins that exactly fit the item - highest priority\n    exact_fit_mask = remaining_after_add == 0\n    priorities[exact_fit_mask] = np.inf  # Highest priority\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Smaller remaining capacity gets higher priority if feasible\n    remaining_capacity_priority = bins_remain_cap[feasible_bins]\n    \n    # 3. Try to fill up bins which are already not empty\n    non_empty_bins = bins_remain_cap < 1.0 #assuming bin capacity is 1.0\n    \n    # 4. Combination Strategy:\n    priorities[feasible_bins] = 1/(remaining_capacity_priority + 1e-6) # avoid division by zero\n    \n    #Boost priority of bins which are already not empty\n    priorities[non_empty_bins] = priorities[non_empty_bins] * 1.5\n\n    #Prioritize bins with smallest remaining capacity even further if item is large\n    large_item = item > 0.5\n    if large_item:\n      priorities[feasible_bins] = priorities[feasible_bins] * (1 + (1 - remaining_capacity_priority))\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item fits.\n    fits = bins_remain_cap >= item\n    priorities[fits] += 1\n\n    # Heuristic 2: Prefer bins with less remaining capacity (First-Fit Decreasing variant). Closer to full is better, but only when the item fits\n    remaining_percentage = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Normalize remaining capacity\n    remaining_percentage[~fits] = 1.0  # Set to 1 if it doesn't fit to avoid negative contribution\n\n    priorities[fits] += (1 - remaining_percentage[fits])\n\n    # Heuristic 3: Give a larger priority boost for bins that will be filled almost exactly\n    close_to_full = np.abs(bins_remain_cap - item) < 0.1  # Small threshold\n\n    priorities[close_to_full] += 2  # higher weightage\n\n    # Heuristic 4: Penalize bins that lead to significant remaining capacity without fitting\n    doesnt_fit = bins_remain_cap < item\n    priorities[doesnt_fit] -= 0.5 * (item - bins_remain_cap[doesnt_fit])  # Penalize by wasted space\n\n    # Heuristic 5: Moderate preference to bins with capacity close to the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    priorities[fits] += np.exp(-capacity_diff[fits] * 5) / 2  # Gaussian-like boost for near matches when it fits, sharper peak\n\n    # Heuristic 6: Slight preference to bins with larger remaining capacity if multiple bins fit.\n    # Avoids over-filling bins if not strictly necessary.\n    priorities[fits] += bins_remain_cap[fits] / (20 * np.max(bins_remain_cap)) # Smaller weight\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Perfect Fit: Highest Priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000\n\n    # 2. Wasted Space Minimization: Prefer bins that minimize wasted space after placing the item.\n    can_fit = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    #A: Moderate wasted space: High Priority\n    moderate_waste = (remaining_space > 0.05) & (remaining_space < 0.3) # Adjust thresholds based on bin size characteristics.\n    priorities[can_fit & moderate_waste] += 500 - 100 * remaining_space[can_fit & moderate_waste] #Decreasing priority based on remaining space\n    \n    #B: Small wasted space: Medium Priority\n    small_waste = (remaining_space >= 0.001) & (remaining_space <= 0.05)\n    priorities[can_fit & small_waste] += 400 #Slightly lower than moderate waste to give preference for more optimal fit.\n\n    # 3. Avoid Fragmentation: Penalize bins that leave very small remaining space.\n    near_full = (bins_remain_cap > item) & (remaining_space < 0.001) # If remaining capacity is near zero\n    priorities[near_full] -= 750  # High penalty - significant deterrent\n\n    # 4. Balance Bin Utilization: Encourage filling bins that are not too full and not too empty.\n    medium_full = (bins_remain_cap > 0.4) & (bins_remain_cap <= 0.75)  # Adjust thresholds based on the bin size and item sizes\n    priorities[medium_full] += 300\n\n    # 5. Penalize Large Wasted Space: Avoid using bins that will result in significant wasted space\n    large_waste = (remaining_space > 0.3) & can_fit\n    priorities[large_waste] -= 50 * remaining_space[large_waste] #Linear penalty.\n\n    # 6. Absolute Infeasibility: Ensure item DOES NOT go into bins that cannot accommodate it.\n    priorities[bins_remain_cap < item] = -10000 # Very large negative number.\n    \n    # 7. Desperation Move: If no bin can fit the item, put it in the bin with the least negative impact.\n    if np.all(bins_remain_cap < item):\n        priorities = -np.abs(bins_remain_cap - item)  # Prioritize bins closest in size, but still smaller.\n        priorities += 1 #Small positive bias so that we don't end up with priority of 0\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and leaves the least amount of wasted space\n    fit_mask = remaining_after_add >= 0\n    if np.any(fit_mask):\n        # Prioritize tight fits using inverse remaining capacity, adding a small constant to avoid division by zero.\n        priorities[fit_mask] = 1 / (remaining_after_add[fit_mask] + 1e-9)\n\n        # Reward bins that are nearly full after adding the item, encouraging full packing.\n        nearly_full_mask = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)  # Adjust threshold as needed\n        priorities[nearly_full_mask] += 10\n\n    # Penalize bins where item doesn't fit by setting priority to -inf. We shouldn't consider these bins.\n    priorities[~fit_mask] = -np.inf\n    \n    # Handle bins that exactly fit the item, giving them the highest priority.\n    exact_fit_mask = remaining_after_add == 0\n    priorities[exact_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Can the item fit in the bin?\n    can_fit = bins_remain_cap >= item\n\n    # Prioritize bins that can fit the item\n    if not np.any(can_fit):\n      # If no bin can fit, prioritize the bin with max remaining cap\n      priorities = bins_remain_cap\n      return priorities\n\n    priorities[can_fit] = 1.0\n\n    # Tighter fit gets higher priority (lower remaining space)\n    remaining_space = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += 1.0 / (remaining_space + 1e-6) # Adding small constant to avoid division by zero\n\n\n    # Consider current occupancy: give higher priority to bins that are already partially full\n    # but not too full (avoid almost full bins)\n    already_occupied = (bins_remain_cap < 0.95) & (bins_remain_cap > item) #being less than 0.95 avoids putting items in almost full bins\n    priorities[already_occupied] *= 2.0 #boost existing priorities\n\n    # If it doesn't fit, assign negative priority so it doesn't get chosen unless no bin can fit it\n    priorities[~can_fit] = -100.0\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = bins_remain_cap[0] + item if np.any(bins_remain_cap + item > bins_remain_cap) else 1.0 #Avoids div by zero in initial case. Assumes all bins of same size, for online alg\n    # Tight-fit prioritization (inverse remaining capacity)\n    remaining_space_normalized = bins_remain_cap / bin_capacity  # Normalize\n    priorities = (1 - remaining_space_normalized)  # Higher priority for tighter fits\n\n    # Heavily penalize infeasibility\n    priorities[bins_remain_cap < item] = -1e9  # Very low priority\n    \n    # Scale priority based on inverse of wasted space relative to item and bin size\n    waste = bins_remain_cap - item\n    waste_normalized = waste / (item + bin_capacity) #Waste relative to both item size and initial bin size\n    \n    fits = bins_remain_cap >= item\n    priorities[fits] += (1 - waste_normalized[fits]) * 100 #Scale to make sure it is significant\n\n    # Occupancy awareness (Avoid bins being too empty, favoring near full)\n    occupancy = 1 - remaining_space_normalized\n    priorities += occupancy * 50\n    \n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0 # Assuming bin capacity is 1. Can be parameterized\n\n    # Infeasibility penalty\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -1e9  # Huge penalty for infeasibility\n\n    # Tight-fit prioritization (inverse remaining capacity), only if feasible\n    feasible = bins_remain_cap >= item\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible]\n        inverse_remaining = 1 / (remaining_capacity + 1e-6)  # Avoid division by zero\n        priorities[feasible] += inverse_remaining\n\n        # Occupancy awareness: Favor bins that are already relatively full\n        occupancy = (bin_capacity - remaining_capacity) / bin_capacity\n        priorities[feasible] += occupancy * 100 #Scale occupancy boost\n\n        # Normalize waste relative to item size and bin capacity\n        waste = remaining_capacity - item\n        normalized_waste = waste / (item + bin_capacity)\n        priorities[feasible] -= normalized_waste * 50 # Scale waste penalty.  Subtract waste\n\n\n    # Dynamic penalty adjustment (example: reduce penalty early on)\n    # packing_stage = current_item_index / total_items  # Assuming access to this info\n    # if packing_stage < 0.2:\n    #     priorities[infeasible] *= 0.1  # Reduce infeasibility penalty early\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bins have capacity 1.0. Adjust if needed\n\n    # Infeasibility penalty: Heavily penalize bins that cannot accommodate the item.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -1e9  # Very large negative priority\n\n    # Feasible bins: Calculate priorities based on remaining capacity and item size.\n    feasible = ~infeasible\n    if np.any(feasible):\n        remaining_cap = bins_remain_cap[feasible]\n        \n        # Tight-fit prioritization: Inverse of remaining capacity after placing the item.\n        # Normalize by item size and bin capacity.\n        remaining_after_fit = remaining_cap - item\n        normalized_waste = remaining_after_fit / (item * bin_capacity)\n        \n        priorities[feasible] = 1.0 / (normalized_waste + 0.00001) #Adding small number to avoid division by zero errors\n\n        # Occupancy awareness: Encourage packing into bins that are already relatively full.\n        # Base priority on the current occupancy level.\n        occupancy_level = (bin_capacity - remaining_cap) / bin_capacity\n        priorities[feasible] += occupancy_level * 100  # Scale occupancy bonus.\n\n    #Packing stage: Reduce best-fit eagerness in the late stage. Not implemented\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) #Assume all bins have the same capacity\n\n    # Infeasibility penalty\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -1e9  # Very strong penalty\n\n    # Tight-fit prioritization (inverse of remaining capacity, normalized)\n    feasible = bins_remain_cap >= item\n    if np.any(feasible):\n        remaining_capacity = bins_remain_cap[feasible] - item\n        normalized_waste = remaining_capacity / bin_capacity #Normalize waste\n        priorities[feasible] = 1 - normalized_waste # Higher priority for tighter fits\n\n        # Boost near-exact fits\n        near_exact = np.isclose(bins_remain_cap[feasible], item, rtol=0, atol=0.01*bin_capacity)\n        priorities[feasible][near_exact] += 0.5  # Significant boost\n    \n    #Occupancy Awareness: Prefer bins that are already reasonably full\n    occupancy = 1 - (bins_remain_cap / bin_capacity)\n    priorities += occupancy * 0.2  # Add a small preference for occupied bins\n    \n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = bins_remain_cap.max() # Assuming all bins have the same capacity\n\n    # 1. Infeasibility Penalty: Heavily penalize bins where the item doesn't fit.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Huge penalty\n\n    # 2. Tight-Fit Prioritization:\n    #   - Inverse of remaining capacity after packing.\n    #   - Normalized by item size and bin capacity to make it relative.\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        remaining_capacity = bins_remain_cap[feasible_bins] - item\n        normalized_waste = remaining_capacity / (item + 1e-6)  # Avoid division by zero\n        tight_fit_priority = 1 / (normalized_waste + 1e-6)   # Avoid division by zero\n\n        # Incorporate remaining bin capacity into tight-fit score\n        occupancy_ratio = (bin_capacity - bins_remain_cap[feasible_bins]) / bin_capacity\n        #Weight the tight-fit priority by how full the bin is to favor those that are more full.\n        weighted_tight_fit = tight_fit_priority * (1 + occupancy_ratio)\n\n        priorities[feasible_bins] = weighted_tight_fit\n\n        #Perfect fit handling. This should have highest priority\n        perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n        priorities[feasible_bins][perfect_fit] = 1e9 #Maximum priority\n\n    # 3. Occupancy Awareness: Encourage filling partially filled bins.\n    # This is already incorporated in \"weighted_tight_fit\"\n\n    # 4. Dynamic Penalty Adjustment (Simplified - based on average fill level):\n    #   - Could be extended to consider the stage of packing.\n    average_fill = (bin_capacity - np.mean(bins_remain_cap)) / bin_capacity\n    if average_fill > 0.75: # Penalize when bins are relatively full to avoid over-packing.\n        priorities[feasible_bins] *= 0.5\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]