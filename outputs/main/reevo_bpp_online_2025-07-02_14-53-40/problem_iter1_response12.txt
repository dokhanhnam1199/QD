```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Assign 0 priority to bins that cannot fit the item.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf  # Mark infeasible bins with negative infinity

    # 2. Remaining Capacity Consideration:  Prioritize bins with tighter fit after placing the item (Minimize wasted space).  Avoid bins with extremely high remaining capacities as it's less efficient.

    # Calculate the remaining capacity *after* adding the item. Only for bins that can fit.
    feasible_bins = ~infeasible_bins
    remaining_after_fit = bins_remain_cap[feasible_bins] - item

    # Give priority to those who minimize remaining_after_fit, but penalize really small remaining
    priorities[feasible_bins] = -np.abs(remaining_after_fit)
    
    # 3. Bonus for Perfect Fit: Reward bins where the item fits perfectly (reduces fragmentation).
    perfect_fit = remaining_after_fit == 0
    priorities[feasible_bins][perfect_fit] = np.inf
   
    # 4. Prioritize bins that are already partially filled over empty bins

    empty_bins = bins_remain_cap == np.max(bins_remain_cap) #assuming bins are of same size initially.

    if np.any(~empty_bins & feasible_bins): #only boost the score if there is a non-empty feasible bin
        priorities[~empty_bins & feasible_bins] += 1  # Slightly boost priority of bins which are already filled. This might need to be tweaked, since this boost is independent from item size and bin capacities

    return priorities
```
