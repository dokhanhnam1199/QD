[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired approach:\n    # Prioritize bins that can accommodate the item and have the least remaining capacity *after* placing the item\n    # to simulate filling them up quickly. Bins that cannot fit get a -inf priority.\n    remaining_capacities_after_insertion = bins_remain_cap - item\n    cannot_fit = remaining_capacities_after_insertion < 0\n    priorities = -remaining_capacities_after_insertion\n    priorities[cannot_fit] = -np.inf\n\n\n    # Add a small bonus to bins that are close to being full even before adding the item\n    # This encourages using bins that are already somewhat filled\n    almost_full_bonus = np.where(bins_remain_cap > 0, np.exp(-bins_remain_cap * 10), 0) # sigmoid-like bonus. Increased the impact of remaining cap on bonus\n    priorities += almost_full_bonus\n\n    # Add a tiny noise, it helps with exploration when all priorities are same\n    noise = np.random.normal(0, 0.0001, size=bins_remain_cap.shape)\n    priorities += noise\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Smaller remaining capacity gets higher priority if feasible\n    remaining_capacity_priority = bins_remain_cap[feasible_bins]\n    \n    # 3. Try to fill up bins which are already not empty\n    non_empty_bins = bins_remain_cap < 1.0 #assuming bin capacity is 1.0\n    \n    # 4. Combination Strategy:\n    priorities[feasible_bins] = 1/(remaining_capacity_priority + 1e-6) # avoid division by zero\n    \n    #Boost priority of bins which are already not empty\n    priorities[non_empty_bins] = priorities[non_empty_bins] * 2\n\n    # Perfect Fit Bonus\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] += 10  # Significantly boost priority for perfect fits\n\n    # Near Fit Bonus (but not too small)\n    near_fit = (bins_remain_cap - item) <= 0.1  # within 10%\n    near_fit = near_fit & (bins_remain_cap > item) #only when fits\n    priorities[near_fit] += 5  # Moderate boost\n\n    #Penalty for almost empty bins if item fits\n    almost_empty = (bins_remain_cap > item) & (bins_remain_cap > 0.9) #Bins that are almost empty\n    priorities[almost_empty] -= 1\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Highest priority for perfect fits\n    perfect_fit = np.isclose(item, bins_remain_cap)\n    priorities[perfect_fit] = 10000.0\n\n    # Consider bins where the item fits\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        waste = bins_remain_cap[fits] - item\n        # Prioritize bins with minimal waste, normalized by item size\n        priorities[fits] = item / (waste + 0.0001)  # Avoid division by zero\n        \n        # Very high priority for near-perfect fits\n        near_perfect = np.isclose(waste, 0, atol=0.01)\n        priorities[fits][near_perfect] = 5000.0\n\n\n    # Large negative priority for bins where the item doesn't fit\n    priorities[~fits] = -1000.0\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            priorities[i] = (item / cap) / (waste / cap + 0.0001) if cap > 0 else 0 # Favor smaller waste relative to capacity and avoid division by zero.  Normalize waste by cap\n        else:\n            priorities[i] = -1  # Negative priority if item doesn't fit\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999992429991835 seconds"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Penalize bins where item doesn't fit by setting priority to -inf.\n    fit_mask = remaining_after_add >= 0\n    priorities[~fit_mask] = -np.inf\n\n    # Give high priority to bins where the item fits and leaves the least amount of wasted space\n    if np.any(fit_mask):\n        # Prioritize based on inverse of remaining space, but avoid extreme values\n        priorities[fit_mask] = 1.0 / (remaining_after_add[fit_mask] + 0.01)  # Adding a small constant to avoid division by zero/very large values\n\n        # Boost bins that are nearly full after adding the item, encouraging full packing.\n        nearly_full_mask = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)\n        priorities[nearly_full_mask] += 10\n\n    # Handle bins that exactly fit the item - highest priority\n    exact_fit_mask = remaining_after_add == 0\n    priorities[exact_fit_mask] = np.inf  # Highest priority\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Smaller remaining capacity gets higher priority if feasible\n    remaining_capacity_priority = bins_remain_cap[feasible_bins]\n    \n    # 3. Try to fill up bins which are already not empty\n    non_empty_bins = bins_remain_cap < 1.0 #assuming bin capacity is 1.0\n    \n    # 4. Combination Strategy:\n    priorities[feasible_bins] = 1/(remaining_capacity_priority + 1e-6) # avoid division by zero\n    \n    #Boost priority of bins which are already not empty\n    priorities[non_empty_bins] = priorities[non_empty_bins] * 1.5\n\n    #Prioritize bins with smallest remaining capacity even further if item is large\n    large_item = item > 0.5\n    if large_item:\n      priorities[feasible_bins] = priorities[feasible_bins] * (1 + (1 - remaining_capacity_priority))\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item fits.\n    fits = bins_remain_cap >= item\n    priorities[fits] += 1\n\n    # Heuristic 2: Prefer bins with less remaining capacity (First-Fit Decreasing variant). Closer to full is better, but only when the item fits\n    remaining_percentage = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Normalize remaining capacity\n    remaining_percentage[~fits] = 1.0  # Set to 1 if it doesn't fit to avoid negative contribution\n\n    priorities[fits] += (1 - remaining_percentage[fits])\n\n    # Heuristic 3: Give a larger priority boost for bins that will be filled almost exactly\n    close_to_full = np.abs(bins_remain_cap - item) < 0.1  # Small threshold\n\n    priorities[close_to_full] += 2  # higher weightage\n\n    # Heuristic 4: Penalize bins that lead to significant remaining capacity without fitting\n    doesnt_fit = bins_remain_cap < item\n    priorities[doesnt_fit] -= 0.5 * (item - bins_remain_cap[doesnt_fit])  # Penalize by wasted space\n\n    # Heuristic 5: Moderate preference to bins with capacity close to the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    priorities[fits] += np.exp(-capacity_diff[fits] * 5) / 2  # Gaussian-like boost for near matches when it fits, sharper peak\n\n    # Heuristic 6: Slight preference to bins with larger remaining capacity if multiple bins fit.\n    # Avoids over-filling bins if not strictly necessary.\n    priorities[fits] += bins_remain_cap[fits] / (20 * np.max(bins_remain_cap)) # Smaller weight\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Perfect Fit: Highest Priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000\n\n    # 2. Wasted Space Minimization: Prefer bins that minimize wasted space after placing the item.\n    can_fit = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    \n    #A: Moderate wasted space: High Priority\n    moderate_waste = (remaining_space > 0.05) & (remaining_space < 0.3) # Adjust thresholds based on bin size characteristics.\n    priorities[can_fit & moderate_waste] += 500 - 100 * remaining_space[can_fit & moderate_waste] #Decreasing priority based on remaining space\n    \n    #B: Small wasted space: Medium Priority\n    small_waste = (remaining_space >= 0.001) & (remaining_space <= 0.05)\n    priorities[can_fit & small_waste] += 400 #Slightly lower than moderate waste to give preference for more optimal fit.\n\n    # 3. Avoid Fragmentation: Penalize bins that leave very small remaining space.\n    near_full = (bins_remain_cap > item) & (remaining_space < 0.001) # If remaining capacity is near zero\n    priorities[near_full] -= 750  # High penalty - significant deterrent\n\n    # 4. Balance Bin Utilization: Encourage filling bins that are not too full and not too empty.\n    medium_full = (bins_remain_cap > 0.4) & (bins_remain_cap <= 0.75)  # Adjust thresholds based on the bin size and item sizes\n    priorities[medium_full] += 300\n\n    # 5. Penalize Large Wasted Space: Avoid using bins that will result in significant wasted space\n    large_waste = (remaining_space > 0.3) & can_fit\n    priorities[large_waste] -= 50 * remaining_space[large_waste] #Linear penalty.\n\n    # 6. Absolute Infeasibility: Ensure item DOES NOT go into bins that cannot accommodate it.\n    priorities[bins_remain_cap < item] = -10000 # Very large negative number.\n    \n    # 7. Desperation Move: If no bin can fit the item, put it in the bin with the least negative impact.\n    if np.all(bins_remain_cap < item):\n        priorities = -np.abs(bins_remain_cap - item)  # Prioritize bins closest in size, but still smaller.\n        priorities += 1 #Small positive bias so that we don't end up with priority of 0\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and leaves the least amount of wasted space\n    fit_mask = remaining_after_add >= 0\n    if np.any(fit_mask):\n        # Prioritize tight fits using inverse remaining capacity, adding a small constant to avoid division by zero.\n        priorities[fit_mask] = 1 / (remaining_after_add[fit_mask] + 1e-9)\n\n        # Reward bins that are nearly full after adding the item, encouraging full packing.\n        nearly_full_mask = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)  # Adjust threshold as needed\n        priorities[nearly_full_mask] += 10\n\n    # Penalize bins where item doesn't fit by setting priority to -inf. We shouldn't consider these bins.\n    priorities[~fit_mask] = -np.inf\n    \n    # Handle bins that exactly fit the item, giving them the highest priority.\n    exact_fit_mask = remaining_after_add == 0\n    priorities[exact_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility: Can the item fit in the bin?\n    can_fit = bins_remain_cap >= item\n\n    # Prioritize bins that can fit the item\n    if not np.any(can_fit):\n      # If no bin can fit, prioritize the bin with max remaining cap\n      priorities = bins_remain_cap\n      return priorities\n\n    priorities[can_fit] = 1.0\n\n    # Tighter fit gets higher priority (lower remaining space)\n    remaining_space = bins_remain_cap[can_fit] - item\n    priorities[can_fit] += 1.0 / (remaining_space + 1e-6) # Adding small constant to avoid division by zero\n\n\n    # Consider current occupancy: give higher priority to bins that are already partially full\n    # but not too full (avoid almost full bins)\n    already_occupied = (bins_remain_cap < 0.95) & (bins_remain_cap > item) #being less than 0.95 avoids putting items in almost full bins\n    priorities[already_occupied] *= 2.0 #boost existing priorities\n\n    # If it doesn't fit, assign negative priority so it doesn't get chosen unless no bin can fit it\n    priorities[~can_fit] = -100.0\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]