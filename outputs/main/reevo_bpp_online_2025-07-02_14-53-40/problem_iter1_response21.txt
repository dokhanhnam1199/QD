```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Prioritize bins that can fit the item
    can_fit = bins_remain_cap >= item
    priorities[can_fit] += 1

    # Give higher priority to bins with tighter fit, but not too tight
    fit_ratios = np.zeros_like(bins_remain_cap, dtype=float)
    fit_ratios[can_fit] = item / bins_remain_cap[can_fit]

    # Boost the priority based on fit ratio, but penalize bins that will have very small remain cap
    small_cap = bins_remain_cap - item < 0.1  # if less than 0.1 capacity after packing, penalize
    fit_boost = (fit_ratios * (1-small_cap))[can_fit]  #only compute values if the items fits in the can. Also multiply with 1 - small_cap, so as to penalise packing in almost full bins

    priorities[can_fit] += fit_boost

    #If it doesn't fit, assign negative priority so it doesn't get chosen unless no bin can fit it
    priorities[~can_fit] = -100 #large negative number

    return priorities
```
