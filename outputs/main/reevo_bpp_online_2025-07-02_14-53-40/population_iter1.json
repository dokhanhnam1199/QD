[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Immediate Fit: High priority for bins where the item fits exactly.\n    immediate_fit = np.isclose(bins_remain_cap, item)\n    priorities[immediate_fit] = 1000  # Very high priority\n    \n    # Best Fit: Higher priority for bins where the remaining capacity after placing the item is smallest, but still positive.\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        best_fit_idx = np.argmin(remaining_after_fit)\n        #Find index of the best fit bin in original bins_remain_cap array\n        original_best_fit_idx = np.where(fits)[0][best_fit_idx]\n        priorities[original_best_fit_idx] = 500 + (1 / (remaining_after_fit[best_fit_idx] + 0.00001)) #Avoid division by zero\n    \n    # Penalize bins where item doesn't fit.\n    priorities[bins_remain_cap < item] = -1000 # Very low priority\n\n    #Remaining space affects priority. More remaining space = lower priority, so we don't fill up one bin and leave other nearly empty\n    #Only apply if item fits, if not, the bins will have already been penalised by above rule.\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        priorities[fits] += (bins_remain_cap[fits] - item) * -1 #Add negative remaining so larger remainder results in more negative adjustment to priority (lower)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit Decreasing heuristic adaptation: prioritize bins that can accommodate the item with minimal waste\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities[fit_mask] = 1 / (waste[fit_mask] + 0.0001) # Avoid division by zero\n\n    # Prioritize bins with higher remaining capacity to avoid creating many nearly-full bins early on.\n    # Only applied to bins which the item can fit.\n\n    priorities[fit_mask] += bins_remain_cap[fit_mask] / np.max(bins_remain_cap) #Normalize the remaining capacity\n\n    # Give a slight bonus for bins that are almost full after adding the item, promoting efficiency\n    almost_full_mask = (waste > 0) & (waste < 0.1 * np.max(bins_remain_cap)) & fit_mask\n    priorities[almost_full_mask] += 2\n\n    # Penalize bins where the item doesn't fit (set to a very low priority)\n    priorities[bins_remain_cap < item] = -1e9 # Effectively blocks placement.  Very important for correctness.\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 23, in priority_v2\n    elif space_waste < 0.25:\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing variant\n            space_waste = cap - item\n            priorities[i] = 1 / (space_waste + 1e-9)  # Avoid division by zero\n\n            # Modified First Fit: Try to fill bins more completely.\n            if space_waste < 0.1:\n                priorities[i] += 10  # High priority if almost perfect fit\n            elif space_waste < 0.25:\n                priorities[i] += 5 # Moderate bonus\n\n        else:\n            priorities[i] = -1e9  # Very low priority if it doesn't fit\n\n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998261099972 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Prefer bins that can accommodate the item.\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] += 1\n\n    # Rule 2: Among valid bins, prefer bins with less remaining capacity after packing.\n    remaining_after_pack = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] += 1 / (remaining_after_pack + 0.0001) # Adding a small constant to avoid division by zero.\n\n    # Rule 3: Discourage bins that are too full (high item/capacity ratio).\n    ratios = item / bins_remain_cap\n    priorities -= 2 * ratios # Weighing this higher than rule 1 to discourage very small bins.\n    \n    # Rule 4: Favor bins that are close to being half-full or 3/4 full when the item is added, because such bins\n    # are likely to be good candidates to add another item of similar size.\n    expected_capacity = bins_remain_cap - item\n    half_full_diff = np.abs(expected_capacity - bins_remain_cap / 2)\n    three_quarter_full_diff = np.abs(expected_capacity - bins_remain_cap * 0.25)\n\n    priorities -= half_full_diff / bins_remain_cap\n    priorities -= three_quarter_full_diff / bins_remain_cap\n\n    return priorities",
    "response_id": 3,
    "obj": 20.692062225767852,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired approach:\n    # Prioritize bins that can accommodate the item and have the least remaining capacity *after* placing the item\n    # to simulate filling them up quickly.  Bins that cannot fit get a -inf priority.\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = - (cap - item) # Lower remaining capacity after insertion -> higher priority\n        else:\n            priorities[i] = -np.inf\n\n    # Add a small bonus to bins that are close to being full even before adding the item\n    # This encourages using bins that are already somewhat filled\n    almost_full_bonus = np.where(bins_remain_cap > 0, np.exp(-bins_remain_cap), 0) # sigmoid-like bonus\n    priorities += almost_full_bonus\n\n    #Add a tiny noise, it helps with exploration when all priorities are same\n    noise = np.random.normal(0, 0.0001, size=bins_remain_cap.shape)\n    priorities += noise\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired: Prefer bins that can accommodate the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Give a base priority for being able to fit.\n\n    # Give higher priority to bins with less remaining capacity after placing the item\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[remaining_after_fit < 0] = np.inf # Ignore bins that cant fit.\n\n    priorities[can_fit] += 1.0 / (1e-6 + remaining_after_fit[can_fit]) # Prioritize lower remaining after fit\n\n    # Prefer bins that are not too full\n    priorities += np.clip(bins_remain_cap / np.max(bins_remain_cap), 0, 1)\n\n    return priorities",
    "response_id": 5,
    "obj": 84.7726366174711,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item fits.\n    fits = bins_remain_cap >= item\n    priorities[fits] += 1\n\n    # Heuristic 2: Prefer bins with less remaining capacity (First-Fit Decreasing variant). Closer to full is better, but only when the item fits\n    remaining_percentage = (bins_remain_cap - item) / np.max(bins_remain_cap)  # Normalize remaining capacity\n\n    priorities[fits] += (1 - remaining_percentage[fits])\n\n    # Heuristic 3: Give a larger priority boost for bins that will be filled almost exactly\n    close_to_full = np.abs(bins_remain_cap - item) < 0.1  # Small threshold\n\n    priorities[close_to_full] += 2 # higher weightage\n\n    #Heuristic 4: Penalize bins that lead to significant remaining capacity without fitting\n    doesnt_fit = bins_remain_cap < item\n    priorities[doesnt_fit] -= 0.5 * (item - bins_remain_cap[doesnt_fit]) # Penalize by wasted space\n    \n    #Heuristic 5: Moderate preference to bins with capacity close to the item size\n    capacity_diff = np.abs(bins_remain_cap - item)\n    priorities[fits] += np.exp(-capacity_diff[fits]) / 2  # Gaussian-like boost for near matches when it fits\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority if the item fits perfectly (or nearly perfectly)\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # Arbitrarily high value\n\n    # High priority if item fits and fills a good portion of bin\n    fits = bins_remain_cap >= item\n    fill_ratio = item / bins_remain_cap\n    priorities[fits] = fill_ratio[fits] * 500 # Scale to control its effect\n    \n    # Prioritize bins that are nearly full if item doesn't perfectly fit,\n    # avoid creating too many almost empty bins\n    near_full = (bins_remain_cap > item) & (bins_remain_cap < 2*item) #Avoid filling bins with just a small remaining capacity that's not useful\n\n    priorities[near_full] += 200 - 50*(bins_remain_cap[near_full]/item) #Higher priority for lower remain cap\n        \n    # Penalize bins that are too big (avoid fragmenting)\n    too_big = (bins_remain_cap > item*2) & fits #Added too_big\n    priorities[too_big] -= (bins_remain_cap[too_big]-item) *0.1 # Penalty proportional to wasted space\n\n    # Give negative priority to bins where the item doesn't fit.\n    priorities[bins_remain_cap < item] = -100  # Very Low priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.756681292381337,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large Negative Priority if item doesn't fit\n    priorities[item > bins_remain_cap] = -np.inf\n    \n    # Higher priority for bins that can accommodate the item but have little space left afterwards (almost full)\n    remaining_space = bins_remain_cap - item\n    \n    # Normalize remaining space to [0, 1]\n    normalized_remaining_space = remaining_space / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(remaining_space)\n    \n    # Give bins with smaller remaining normalized space higher priority, but not extremely high\n    priorities[item <= bins_remain_cap] = 1 - normalized_remaining_space[item <= bins_remain_cap]\n\n    #If two bins both are capable, we also prefer bin with largest space left if the bin is reasonably empty\n    reasonable_empty = bins_remain_cap > 0.75 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities[reasonable_empty] = priorities[reasonable_empty] + 0.1*bins_remain_cap[reasonable_empty]/np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else priorities[reasonable_empty]\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Reward bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Give higher priority to bins with smaller remaining capacity AFTER fitting item\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~can_fit] = np.inf  # Penalize bins that cannot fit\n\n    priorities[can_fit] += np.max(bins_remain_cap) - remaining_after_fit[can_fit] # Reward smaller remaining\n\n    # Consider the wasted space if the item is placed in a bin.\n    wasted_space = bins_remain_cap - item\n    wasted_space[~can_fit] = np.inf  # Infinite waste if it doesn't fit\n    priorities[can_fit] += np.max(wasted_space[can_fit]) - wasted_space[can_fit] # Smaller waste is good\n\n    # Penalize almost full bins with large item, high chance of future items not fitting\n    almost_full = (bins_remain_cap > item) & (bins_remain_cap < 2 * item) #Bins will have leftover less than item\n    priorities[almost_full] -= 0.5\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority if item fits perfectly.\n    perfect_fit = np.isclose(item, bins_remain_cap)\n    priorities[perfect_fit] = 1000  # A very high priority value\n\n    # Higher priority if the item fits and leaves the least waste.\n    fits = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    \n    if np.any(fits):\n        min_waste = np.min(waste[fits])\n        priorities[fits] = 1 / (waste[fits] + 0.001) #Avoid division by zero. higher inverse waste is better\n\n        # Normalize waste based on item size for better selection\n        priorities[fits] += item / (waste[fits] + 0.001) #Higher item size for lower waste\n        \n        #If there exists close to zero waste bins give higher priority\n        close_to_zero = np.isclose(waste, 0, atol = 0.01) & fits\n        priorities[close_to_zero] = 200\n\n    # Negative priority if the item does not fit.\n    priorities[~fits] = -100 \n\n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate the wasted space if the item is placed in the bin\n            wasted_space = cap - item\n            \n            # Give a higher priority to bins where the wasted space is smaller\n            # and the remaining capacity is larger. This encourages filling bins\n            # as much as possible while leaving bigger spaces for future items.\n            \n            # Handle the case where cap is 0 to avoid division by zero\n            if cap > 0:\n                priorities[i] = (1 / (wasted_space + 1e-6)) * cap\n            else:\n                priorities[i] = -np.inf  # Very low priority if capacity is 0\n        else:\n            priorities[i] = -np.inf  # Negative infinity for bins that can't fit the item\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Assign 0 priority to bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf  # Mark infeasible bins with negative infinity\n\n    # 2. Remaining Capacity Consideration:  Prioritize bins with tighter fit after placing the item (Minimize wasted space).  Avoid bins with extremely high remaining capacities as it's less efficient.\n\n    # Calculate the remaining capacity *after* adding the item. Only for bins that can fit.\n    feasible_bins = ~infeasible_bins\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Give priority to those who minimize remaining_after_fit, but penalize really small remaining\n    priorities[feasible_bins] = -np.abs(remaining_after_fit)\n    \n    # 3. Bonus for Perfect Fit: Reward bins where the item fits perfectly (reduces fragmentation).\n    perfect_fit = remaining_after_fit == 0\n    priorities[feasible_bins][perfect_fit] = np.inf\n   \n    # 4. Prioritize bins that are already partially filled over empty bins\n\n    empty_bins = bins_remain_cap == np.max(bins_remain_cap) #assuming bins are of same size initially.\n\n    if np.any(~empty_bins & feasible_bins): #only boost the score if there is a non-empty feasible bin\n        priorities[~empty_bins & feasible_bins] += 1  # Slightly boost priority of bins which are already filled. This might need to be tweaked, since this boost is independent from item size and bin capacities\n\n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic inspiration\n    # High priority to bins that can accommodate the item with minimal wasted space.\n\n    # Consider only bins that can actually fit the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Calculate wasted space for valid bins\n        wasted_space = bins_remain_cap[valid_bins] - item\n        \n        # Assign priority based on inverse of wasted space (smaller waste = higher priority)\n        priorities[valid_bins] = 1 / (wasted_space + 1e-9)  # Adding a small constant to avoid division by zero\n        \n        # Optionally, scale priorities to be between 0 and 1\n        priorities[valid_bins] /= np.max(priorities[valid_bins])\n\n    #If item does not fit in any bin, select the one with the highest capacity, but with very low priority.\n    else:\n      priorities = bins_remain_cap / np.max(bins_remain_cap)\n      priorities = priorities * 0.01\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Initialize impossibly large number for bins that can't hold item\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Define some helper variables\n    almost_full_threshold = 0.95  # Bins filled beyond this are very valuable\n\n    # Calculate the fill ratio after placing the item in the bin.\n    fill_ratios = (bins_remain_cap - item) / np.max(bins_remain_cap)\n\n    # Prioritize bins that the item can fit in\n    can_fit = bins_remain_cap >= item\n\n    # Prioritize based on remaining capacity after insertion\n    priorities[can_fit] = (bins_remain_cap[can_fit] - item)\n\n    # If a bin is almost full after insertion, strongly favor it.\n    almost_full_bins = (fill_ratios > almost_full_threshold) & can_fit\n    priorities[almost_full_bins] += 1000  # Huge bonus for almost full\n\n    # Add a bonus if the item fits perfectly\n    perfect_fit_bins = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit_bins] += 500\n\n    # Avoid bins that will become almost empty after insertion\n    almost_empty_threshold = 0.1\n    almost_empty_bins = (fill_ratios < almost_empty_threshold) & can_fit\n    priorities[almost_empty_bins] -= 200\n\n    return priorities",
    "response_id": 14,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins that can fit the item.\n\n            # First Fit Decreasing (FFD) inspired: prioritize bins with smallest remaining capacity that can still fit the item.\n            # This tries to fill bins as much as possible before opening new ones.\n            priorities[i] = 1.0 / (cap + 1e-9) #Avoid division by zero and the lowest remaining capacity has higher priority\n            # Alternatively, prioritize bins where the item fills a significant portion.\n\n            fill_ratio = item / cap\n            priorities[i] *= (fill_ratio**2) #emphasize higher filling ratios\n\n            # Bonus for bins almost full (but can still take the item) to reduce fragmentation\n            if (cap - item) < 0.1:  # Tune threshold 0.1\n                priorities[i] *= 2 #tune bonus coefficient\n        else:\n            # Give negative priority to bins that can't fit the item.\n            priorities[i] = -1e9 #very low priority.\n\n    return priorities",
    "response_id": 15,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998990999302 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and leaves the least amount of wasted space\n    fit_mask = remaining_after_add >= 0\n    if np.any(fit_mask):\n        priorities[fit_mask] = 1 / (remaining_after_add[fit_mask] + 1e-6)  # Avoid division by zero. The smaller the remaining capacity, the higher the priority.\n\n        # Boost bins that are nearly full after adding the item, encouraging full packing.\n        nearly_full_mask = (remaining_after_add >= 0) & (remaining_after_add <= 0.1)  #Bins with capacity less than 0.1 after addition\n        priorities[nearly_full_mask] += 10 #Boost\n\n    # Penalize bins where item doesn't fit by setting priority to -inf. We shouldn't consider these bins.\n    priorities[~fit_mask] = -np.inf\n    \n    #Handle bins that exactly fit the item\n    exact_fit_mask = remaining_after_add == 0\n    priorities[exact_fit_mask] = np.inf #Highest priority\n\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = (cap - item) / np.sum(bins_remain_cap - item, where=bins_remain_cap >= item) if np.any(bins_remain_cap >= item) else 1e-6  # Prioritize bins that fit item well, normalized by total remaining space\n\n            priorities[i] += 1/(1 + (item/cap -0.5)**2) # Prioritize if the item fills the bin close to half\n\n            if cap == item:\n                priorities[i] += 1.0  # Perfect fit bonus\n            elif cap > item * 1.2:\n                priorities[i] -= 0.2 # Penalize if item is too small compared to bin\n        else:\n            priorities[i] = -1e9  # Very low priority for bins that don't fit\n\n    return priorities",
    "response_id": 17,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998249000055 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            priorities[i] = (item / cap) * (1 / (waste + 0.0001))  # Favor smaller waste relative to capacity\n        else:\n            priorities[i] = -1  # Negative priority if item doesn't fit\n\n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign -inf to bins that cannot accommodate the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit: Prioritize bins with smallest remaining capacity *after* placing the item\n    # Only consider feasible bins\n    feasible_mask = ~infeasible_mask\n    remaining_after_fit = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -np.abs(remaining_after_fit) # Smaller remaining capacity = higher priority\n    \n    # 3. Fill Rate: Also consider how much of the bin's original capacity will be used. This biases towards fuller bins\n    fill_rate = item / (bins_remain_cap[feasible_mask] + item) if np.any(feasible_mask) else np.array([])  # Avoid div by zero. Add small constant if needed.\n    if np.any(feasible_mask):\n        priorities[feasible_mask] += fill_rate * 0.5  # Scale the fill rate (arbitrary value)\n\n    #4. Avoid waste: if an item can fit perfectly, prioritise this bin highly.\n\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = np.inf\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Higher priority for bins that can accommodate the item\n            priority = (cap - item) / cap  # Remaining capacity ratio after adding the item\n            priorities[i] = priority\n        else:\n            # Very low priority if the bin cannot fit the item\n            priorities[i] = -1e9  # A very small number representing negative infinity\n    return priorities",
    "response_id": 20,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Give higher priority to bins with tighter fit, but not too tight\n    fit_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    fit_ratios[can_fit] = item / bins_remain_cap[can_fit]\n\n    # Boost the priority based on fit ratio, but penalize bins that will have very small remain cap\n    small_cap = bins_remain_cap - item < 0.1  # if less than 0.1 capacity after packing, penalize\n    fit_boost = (fit_ratios * (1-small_cap))[can_fit]  #only compute values if the items fits in the can. Also multiply with 1 - small_cap, so as to penalise packing in almost full bins\n\n    priorities[can_fit] += fit_boost\n\n    #If it doesn't fit, assign negative priority so it doesn't get chosen unless no bin can fit it\n    priorities[~can_fit] = -100 #large negative number\n\n    return priorities",
    "response_id": 21,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Large bins get a base priority proportional to remaining capacity.  Helps with \"almost full\" bins being chosen later\n    priorities = bins_remain_cap\n\n    # Give bins that can fit the item a bonus proportional to how *close* the fit is\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += (bins_remain_cap[fit_mask] - item) / np.max(bins_remain_cap[fit_mask] - item + 1e-9) # Normalize\n\n    # Greatly penalize bins that can't fit the item\n    priorities[~fit_mask] = -1e9  # Or any sufficiently low value. Force no fit.\n\n    #Prioritize more full bins, but only if item fits.\n    #fill_ratios = (1 - bins_remain_cap / np.max(bins_remain_cap + 1e-9))\n    #priorities[fit_mask] += fill_ratios[fit_mask] * 0.1  #Scale this appropriately.  Want fit close-ness to be more important\n\n\n    return priorities",
    "response_id": 22,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 20, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing variant.\n            # Favor bins that can accommodate the item with smallest remaining capacity.\n            remaining = cap - item\n            priorities[i] = 1 / (remaining + 0.00001)  # Avoid division by zero\n\n            # # Alternative heuristic - Balance packing between bins to reduce bin utilization\n            # # Favor bins that can accommodate item without making bin near full.\n            # remaining = cap - item\n            # priorities[i] = cap # Favor bigger bins\n        else:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing inspired: prefer bins that can accommodate the item with minimal wasted space.\n    # But, modified to handle online nature (can't pre-sort).\n\n    # Give high priority to bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Prioritize bins where remaining space after packing the item is small but not too small (avoid tiny wasted space)\n    remaining_space = bins_remain_cap - item\n    valid_remaining = (remaining_space >= 0.01) & (remaining_space <= 0.2)  # Avoid near-full and too empty bins. Adjust thresholds as needed.\n    priorities[can_fit & valid_remaining] += 2 # higher than basic fit\n\n    # Penalize bins with very little space left\n    near_full = (bins_remain_cap > item) & (remaining_space < 0.01)\n    priorities[near_full] -= 0.5 # Slightly penalize using these\n\n    # Severely Penalize bins that are already full. Should be redundant given first filter but ensures it.\n    priorities[bins_remain_cap < item] = -1000 # Extreme negative penalty if the item won't fit.\n\n    # Encourage filling bins that are somewhat empty, but not completely empty.\n    # This helps balance utilization across bins.\n    medium_full = (bins_remain_cap > 0.3) & (bins_remain_cap <= 0.7)  # adjust based on the bin size\n    priorities[medium_full] += 0.7\n\n    # If no bin can fit, try to find the least incompatible one (least negative score)\n    if np.all(bins_remain_cap < item):\n        priorities = -np.abs(bins_remain_cap - item) # Prefer smallest difference\n\n    return priorities",
    "response_id": 24,
    "obj": 4.487435181491823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic\n    # Give preference to bins that can fit the item reasonably well,\n    # but avoid bins where the item fills it almost completely (waste).\n\n    # High priority if the remaining capacity is slightly bigger than item\n    fit_ratios = item / bins_remain_cap\n    valid_bins = bins_remain_cap >= item\n\n    # Normalize ratios such that better fits receive higher scores.\n\n    priorities = np.where(valid_bins, (1 - np.abs(fit_ratios - 0.75)), -1) # Prefer bins to be 75% filled.\n\n    # Bonus for almost full bins which the items fit into\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap < item * 1.1)\n    priorities[almost_full] = 0.9\n\n\n    # Penalize bins where item cannot fit. This helps prevent assigning negative values when item is larger than bin cap.\n    priorities[~valid_bins] = -100  #Very low priority\n\n    return priorities",
    "response_id": 25,
    "obj": 6.890706023135235,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired:\n    # Give high priority to bins that can fit the item with least wasted space\n    # or the bins that are almost full.\n\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap - item\n        waste[~valid_bins] = np.inf # Ignore invalid bins\n\n        min_waste = np.min(waste)\n        best_bins = waste == min_waste\n\n        priorities[best_bins] += 100  # High priority for bins with min waste\n\n        # Increase priority based on how full bin would be.\n        fill_ratio = item / bins_remain_cap\n        priorities[valid_bins] += (1 - fill_ratio[valid_bins]) * 50 # small waste -> high priority\n\n    # If the item doesn't fit into any bin, try to put into the least full bin:\n    else:\n        priorities = bins_remain_cap / np.max(bins_remain_cap) * -10\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary criterion: Prefer bins that can fit the item\n            priorities[i] += 1.0\n\n            # Secondary criterion: Minimize wasted space (closeness to full)\n            priorities[i] += (item / cap)\n\n            # Tertiary criterion: Penalize near-full bins to reduce fragmentation\n            remaining = cap - item\n            if 0 < remaining <= 0.1:  #if remaining capacity is very low (upto 10%)\n                priorities[i] -= 0.5 #reduce chance of near full bin\n\n        else:\n            # Item doesn't fit\n            priorities[i] = -1e9  # Very low priority\n\n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Smaller remaining capacity gets higher priority if feasible\n    remaining_capacity_priority = bins_remain_cap[feasible_bins]\n    \n    # 3. Try to fill up bins which are already not empty\n    non_empty_bins = bins_remain_cap < 1.0 #assuming bin capacity is 1.0\n    \n    # 4. Combination Strategy:\n    priorities[feasible_bins] = 1/(remaining_capacity_priority + 1e-6) # avoid division by zero\n    \n    #Boost priority of bins which are already not empty\n    priorities[non_empty_bins] = priorities[non_empty_bins] * 2\n\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing inspired prioritization\n    # Favor bins that can fit the item closely without excessive waste\n    \n    fit_mask = bins_remain_cap >= item\n    \n    if np.any(fit_mask):\n        waste = bins_remain_cap[fit_mask] - item\n        # Prioritize bins with smaller waste. Use a negative exponential to emphasize small waste\n        priorities[fit_mask] = np.exp(-waste) \n    else:\n        # If no bin can fit, strongly penalize existing bins, this encourages the creation of new bins, i.e., prevents excessive waste in any existing bin\n        priorities = np.full_like(bins_remain_cap, -1.0) # or a large negative number\n        \n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]