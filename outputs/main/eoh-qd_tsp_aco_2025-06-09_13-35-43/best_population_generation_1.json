{
     "algorithm": "This algorithm estimates edge inclusion probabilities for TSP by sampling near-optimal solutions using a nearest neighbor heuristic with restarts and accumulating edge frequencies.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge inclusion probabilities for TSP by sampling near-optimal solutions using a nearest neighbor heuristic with restarts and accumulating edge frequencies.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited = set(range(n))\n        unvisited.remove(current_node)\n        path = [current_node]\n        path_length = 0\n\n        while unvisited:\n            nearest_neighbor = -1\n            min_distance = np.inf\n            for neighbor in unvisited:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n\n            path.append(nearest_neighbor)\n            path_length += min_distance\n            unvisited.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        path.append(start_node)\n        path_length += distance_matrix[current_node, start_node]\n\n        # Accumulate edge frequencies for this sample\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
     "objective": 6.20794,
     "other_inf": null,
     "SLOC": 17.0,
     "cyclomatic_complexity": 4.0,
     "halstead": 183.9358278562653
}