import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours, selecting and recombining tours based on their fitness (tour length) to create a heuristic matrix representing edge frequency in elite tours.}"""
    n = distance_matrix.shape[0]
    population_size = 100
    num_generations = 50
    mutation_rate = 0.01

    # Initialize population with random tours
    population = [np.random.permutation(n) for _ in range(population_size)]

    def calculate_fitness(tour):
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]
        return tour_length

    for generation in range(num_generations):
        # Evaluate fitness of each tour
        fitness_scores = [calculate_fitness(tour) for tour in population]

        # Select parents based on fitness (lower fitness is better)
        probabilities = np.array(fitness_scores)
        probabilities = np.max(probabilities) - probabilities  + 1e-6  # Shift and ensure positive values
        probabilities = probabilities / np.sum(probabilities)

        selected_indices = np.random.choice(population_size, size=population_size, replace=True, p=probabilities)
        selected_parents = [population[i] for i in selected_indices]

        # Create new population through crossover and mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_parents[i]
            parent2 = selected_parents[(i + 1) % population_size]

            # Crossover (e.g., order crossover)
            start = np.random.randint(n)
            length = np.random.randint(1, n - 1)
            child1 = np.zeros(n, dtype=int) - 1
            child2 = np.zeros(n, dtype=int) - 1

            child1[start:(start + length) % n] = parent1[start:(start + length) % n]
            child2[start:(start + length) % n] = parent2[start:(start + length) % n]

            remaining1 = [node for node in parent2 if node not in child1]
            remaining2 = [node for node in parent1 if node not in child2]

            j1 = 0
            j2 = 0
            for k in range(n):
                if child1[k] == -1:
                    child1[k] = remaining1[j1]
                    j1 += 1
                if child2[k] == -1:
                    child2[k] = remaining2[j2]
                    j2 += 1
                    
            # Mutation (swap two random cities)
            for tour in [child1, child2]:
                if np.random.rand() < mutation_rate:
                    i = np.random.randint(n)
                    j = np.random.randint(n)
                    tour[i], tour[j] = tour[j], tour[i]

            new_population.extend([child1, child2])
        
        population = new_population

    # Evaluate fitness of final population
    fitness_scores = [calculate_fitness(tour) for tour in population]
    best_tour_index = np.argmin(fitness_scores)
    best_tour = population[best_tour_index]

    # Create heuristics matrix based on the best tour(s)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_elite = 10
    elite_indices = np.argsort(fitness_scores)[:num_elite]
    
    for tour_index in elite_indices:
        tour = population[tour_index]
        for i in range(n):
            u = tour[i]
            v = tour[(i + 1) % n]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
