import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random tours, and for each edge, it counts how often it appears in the shortest tours among the samples, using an exponential function of the negative tour lengths as probabilities.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    sampled_tours = []
    tour_lengths = []

    for _ in range(num_samples):
        tour = np.random.permutation(n)
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]
        sampled_tours.append(tour)
        tour_lengths.append(tour_length)

    tour_lengths = np.array(tour_lengths)
    probabilities = np.exp(-tour_lengths / tour_lengths.std())  # Use exponential of negative tour lengths as probabilities
    probabilities /= probabilities.sum() # Normalize

    heuristics_matrix = np.zeros((n, n))
    
    for i, tour in enumerate(sampled_tours):
        probability = probabilities[i]
        for j in range(n):
            u = tour[j]
            v = tour[(j + 1) % n]
            heuristics_matrix[u, v] += probability
            heuristics_matrix[v, u] += probability # Symmetric

    return heuristics_matrix
