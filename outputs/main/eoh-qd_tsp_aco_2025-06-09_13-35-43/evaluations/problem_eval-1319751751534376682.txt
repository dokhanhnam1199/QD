import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm adaptively adjusts edge probabilities based on the frequency with which edges appear in elite solutions generated using a combination of shortest edge selection and a guided exploration strategy that balances diversification and intensification.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    
    # Initialize heuristics with inverse distance
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            heuristics_matrix[i, j] = heuristics_matrix[j, i] = 1 / (distance + 1e-9)
            
    # Parameters
    num_iterations = 10
    num_samples = 50
    elite_fraction = 0.2

    for iteration in range(num_iterations):
        solutions = []
        costs = []

        for sample in range(num_samples):
            current_node = np.random.randint(n)
            tour = [current_node]
            unvisited = set(range(n))
            unvisited.remove(current_node)
            
            while unvisited:
                # Guided exploration: combine shortest edge and heuristic probability
                shortest_edge_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
                
                heuristic_probs = heuristics_matrix[current_node, :].copy()
                heuristic_probs = np.array([heuristic_probs[i] if i in unvisited else 0 for i in range(n)])

                if np.sum(heuristic_probs) == 0:
                      next_node = shortest_edge_node
                else:
                    heuristic_probs /= np.sum(heuristic_probs)
                    
                    # Balance exploration and exploitation (adjust temperature parameter if needed)
                    exploration_prob = 0.5 
                    if np.random.rand() < exploration_prob:
                        next_node = shortest_edge_node
                    else:
                        next_node = np.random.choice(n, p=heuristic_probs)
                        while next_node not in unvisited:
                            heuristic_probs[next_node] = 0
                            if np.sum(heuristic_probs) == 0:
                                next_node = shortest_edge_node
                                break
                            heuristic_probs /= np.sum(heuristic_probs)
                            next_node = np.random.choice(n, p=heuristic_probs)
                

                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            tour.append(tour[0])
            cost = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))
            solutions.append(tour)
            costs.append(cost)

        # Identify elite solutions
        num_elite = int(num_samples * elite_fraction)
        elite_indices = np.argsort(costs)[:num_elite]
        
        # Update heuristics based on elite solutions
        edge_counts = np.zeros((n, n))
        for idx in elite_indices:
            tour = solutions[idx]
            for i in range(n):
                node1 = tour[i]
                node2 = tour[i+1]
                edge_counts[node1, node2] += 1
                edge_counts[node2, node1] += 1
                
        #Adaptive adjustment: stronger edges get higher probability boost
        for i in range(n):
            for j in range(i + 1, n):
                heuristics_matrix[i, j] += edge_counts[i, j] * (1 + 1/(distance_matrix[i,j] + 1e-9))
                heuristics_matrix[j, i] = heuristics_matrix[i, j]
                
        # Normalize probabilities
        for i in range(n):
            row_sum = np.sum(heuristics_matrix[i, :])
            if row_sum > 0:
                heuristics_matrix[i, :] /= row_sum

    return heuristics_matrix
