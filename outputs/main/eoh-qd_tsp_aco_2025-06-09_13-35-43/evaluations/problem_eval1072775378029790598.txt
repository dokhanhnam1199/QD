import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm initializes edge probabilities based on distance, then iteratively refines them by simulating tour construction, rewarding edges that lead to shorter partial tours and penalizing those that lead to dead ends.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))

    # Initial heuristic: inverse distance
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            heuristics_matrix[i, j] = heuristics_matrix[j, i] = 1 / (distance + 1e-9)

    # Normalize to probabilities
    for i in range(n):
        row_sum = np.sum(heuristics_matrix[i, :])
        if row_sum > 0:
            heuristics_matrix[i, :] /= row_sum

    # Iterative refinement
    num_iterations = 10
    num_samples = 50

    for _ in range(num_iterations):
        for _ in range(num_samples):
            start_node = np.random.randint(n)
            current_tour = [start_node]
            unvisited = set(range(n))
            unvisited.remove(start_node)
            current_node = start_node
            tour_length = 0
            
            while unvisited:
                probabilities = heuristics_matrix[current_node, :]
                probabilities = np.array([probabilities[i] if i in unvisited else 0 for i in range(n)])
                
                if np.sum(probabilities) == 0:
                    next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
                    reward = -1 #Penalize dead ends
                else:
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(n, p=probabilities)
                    while next_node not in unvisited:
                        probabilities[next_node] = 0
                        if np.sum(probabilities) == 0:
                            next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
                            reward = -1 #Penalize dead ends
                            break
                        probabilities /= np.sum(probabilities)
                        next_node = np.random.choice(n, p=probabilities)
                    reward = -distance_matrix[current_node, next_node] #Reward shorter edges
                
                tour_length += distance_matrix[current_node, next_node]
                
                # Update heuristics
                heuristics_matrix[current_node, next_node] += reward * 0.1
                heuristics_matrix[next_node, current_node] += reward * 0.1
                

                current_tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            #Normalize
            for i in range(n):
                row_sum = np.sum(heuristics_matrix[i, :])
                if row_sum > 0:
                    heuristics_matrix[i, :] /= row_sum
    return heuristics_matrix
