import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples many random tours, and for each edge, calculates the inverse of the average tour length including that edge, scaled by the frequency of the edge's appearance in sampled tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros((n, n))
    edge_counts = np.zeros((n, n))
    total_tour_lengths = np.zeros((n, n))

    for _ in range(num_samples):
        tour = np.random.permutation(n)
        tour_length = 0
        for i in range(n):
            j = (i + 1) % n
            u, v = tour[i], tour[j]
            tour_length += distance_matrix[u, v]

        for i in range(n):
            j = (i + 1) % n
            u, v = tour[i], tour[j]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1  # Assuming symmetric distance matrix
            total_tour_lengths[u, v] += tour_length
            total_tour_lengths[v, u] += tour_length

    for i in range(n):
        for j in range(n):
            if i != j and edge_counts[i, j] > 0:
                heuristics_matrix[i, j] = (edge_counts[i, j] / num_samples) / (total_tour_lengths[i, j] / edge_counts[i, j])
            else:
                heuristics_matrix[i, j] = 0

    return heuristics_matrix
