import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm refines edge heuristic values by iteratively sampling solutions, updating edge weights based on solution quality using both cost and rank-based selection pressures.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.ones_like(distance_matrix)
  num_iterations = 100
  num_samples = 50
  
  for _ in range(num_iterations):
    solutions = []
    costs = []
    for _ in range(num_samples):
      permutation = np.random.permutation(n)
      cost = 0
      for i in range(n - 1):
        cost += distance_matrix[permutation[i], permutation[i+1]]
      cost += distance_matrix[-1], permutation[0]] if i == n - 2 else 0
      cost += distance_matrix[permutation[-1], permutation[0]] if i == n-1 else 0
      solutions.append(permutation)
      costs.append(cost)
    
    costs = np.array(costs)
    
    # Rank-based selection: calculate ranks
    ranks = np.argsort(costs)

    #Update heuristics based on all solutions, weighted by rank
    scaling_factor = 0.1 

    for rank, solution_index in enumerate(ranks):
      solution = solutions[solution_index]
      weight = 1 - (rank / num_samples)  # Higher rank (better solution) gets higher weight

      for i in range(n - 1):
        heuristics_matrix[solution[i], solution[i+1]] += scaling_factor * weight * (1 - costs[solution_index]/costs.max()) if costs.max() != 0 else 1
        heuristics_matrix[solution[i+1], solution[i]] = heuristics_matrix[solution[i], solution[i+1]]

      heuristics_matrix[solution[-1], solution[0]] += scaling_factor * weight * (1 - costs[solution_index]/costs.max()) if costs.max() != 0 else 1
      heuristics_matrix[solution[0], solution[-1]] = heuristics_matrix[solution[-1], solution[0]]
  return heuristics_matrix
