import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines edge weights based on the reduction in tour length achieved by swapping edges to include the target edge.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    samples_per_iteration = 10

    # Initialize edge weights randomly
    edge_weights = np.random.rand(n, n)
    edge_weights = (edge_weights + edge_weights.T) / 2  # Ensure symmetry
    np.fill_diagonal(edge_weights, 0)

    for _ in range(num_iterations):
        for _ in range(samples_per_iteration):
            # Select a random tour
            tour = np.random.permutation(n)
            original_tour_length = 0
            for i in range(n - 1):
                original_tour_length += distance_matrix[tour[i], tour[i+1]]
            original_tour_length += distance_matrix[tour[-1], tour[0]]

            # Select a random edge (u, v) to consider swapping in
            u = np.random.randint(0, n)
            v = np.random.randint(0, n)
            if u == v:
                continue

            # Find an edge (x, y) in the current tour to swap with (u, v)
            best_improvement = 0
            best_x = -1
            best_y = -1
            for i in range(n - 1):
                x, y = tour[i], tour[i+1]
                improvement = (distance_matrix[x, y] + distance_matrix[u, v]) - (distance_matrix[x, u] + distance_matrix[y, v])
                if improvement > best_improvement:
                    best_improvement = improvement
                    best_x = x
                    best_y = y
            x, y = tour[-1], tour[0]
            improvement = (distance_matrix[x, y] + distance_matrix[u, v]) - (distance_matrix[x, u] + distance_matrix[y, v])
            if improvement > best_improvement:
                best_improvement = improvement
                best_x = x
                best_y = y
            
            # Update edge weights based on improvement
            if best_improvement > 0 and best_x != -1:
                heuristics_matrix[u, v] += best_improvement
                heuristics_matrix[v, u] += best_improvement
    
    # Normalize the heuristics matrix
    max_heuristic = np.max(heuristics_matrix)
    if max_heuristic > 0:
        heuristics_matrix /= max_heuristic

    return heuristics_matrix
