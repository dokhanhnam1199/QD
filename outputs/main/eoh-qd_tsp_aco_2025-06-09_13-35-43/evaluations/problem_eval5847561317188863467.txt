import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by sampling solutions using a greedy approach guided by shortest edge selection and stochastic node prioritization, then aggregating the edge frequencies across sampled solutions.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        start_node = np.random.randint(n)
        unvisited = set(range(n))
        unvisited.remove(start_node)
        current_node = start_node
        path = [start_node]

        while unvisited:
            # Create a priority list of unvisited nodes based on shortest distance
            priority_nodes = sorted(unvisited, key=lambda node: distance_matrix[current_node, node])
            
            # Introduce stochasticity by prioritizing a random subset of the closest nodes
            k = min(3, len(priority_nodes))
            
            # Randomly select a subset of size k
            subset = np.random.choice(len(priority_nodes), size=k, replace=False)
            
            # The available nodes are the selected subset
            available_nodes = [priority_nodes[i] for i in subset]
            
            # If there are no available nodes in the subset, select the closest node
            if not available_nodes:
                 available_nodes = [priority_nodes[0]] if priority_nodes else []
            
            
            # Greedily select from the available nodes
            next_node = min(available_nodes, key=lambda node: distance_matrix[current_node, node], default=None)
            
            
            if next_node is None:
                break # handle disconnected graph
            
            path.append(next_node)
            unvisited.remove(next_node)

            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1
            
            current_node = next_node

        if path:
            heuristics_matrix[current_node, start_node] += 1
            heuristics_matrix[start_node, current_node] += 1

    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
