import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines edge probabilities by sampling tours, evaluating their lengths, and updating edge probabilities based on a combination of tour length and edge frequency, with a focus on intensifying probabilities along short routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) / n  # Initialize with uniform probabilities
    num_iterations = 50
    num_samples = 50

    for _ in range(num_iterations):
        tours = []
        tour_lengths = []
        for _ in range(num_samples):
            # Sample a tour based on current edge probabilities (biased random walk)
            current_node = np.random.randint(n)
            unvisited = set(range(n))
            unvisited.remove(current_node)
            tour = [current_node]

            while unvisited:
                probabilities = heuristics_matrix[current_node, :]
                
                # Consider only unvisited nodes
                valid_probabilities = np.array([probabilities[node] if node in unvisited else 0 for node in range(n)])
                
                if np.sum(valid_probabilities) == 0:
                    next_node = np.random.choice(list(unvisited))
                else:
                    valid_probabilities = valid_probabilities / np.sum(valid_probabilities) # Normalize

                    next_node = np.random.choice(n, p=valid_probabilities)
                    while next_node not in unvisited:
                        next_node = np.random.choice(n, p=valid_probabilities)


                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            tour_length = 0
            for i in range(n - 1):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            tour_length += distance_matrix[tour[-1], tour[0]]
            tours.append(tour)
            tour_lengths.append(tour_length)

        # Update edge probabilities based on tour lengths
        min_length = min(tour_lengths)
        for i, tour in enumerate(tours):
            # Reward edges in shorter tours more strongly
            reward = np.exp(-(tour_lengths[i] - min_length)) # Exponential reward
            
            for j in range(n - 1):
                u = tour[j]
                v = tour[j+1]
                heuristics_matrix[u, v] = (1 - 0.1) * heuristics_matrix[u, v] + 0.1 * reward
                heuristics_matrix[v, u] = (1 - 0.1) * heuristics_matrix[v, u] + 0.1 * reward # Ensure symmetry
            heuristics_matrix[tour[-1], tour[0]] = (1 - 0.1) * heuristics_matrix[tour[-1], tour[0]] + 0.1 * reward
            heuristics_matrix[tour[0], tour[-1]] = (1 - 0.1) * heuristics_matrix[tour[0], tour[-1]] + 0.1 * reward # Ensure symmetry
        # Normalize each row to make them probabilities again
        for i in range(n):
          row_sum = np.sum(heuristics_matrix[i,:])
          heuristics_matrix[i,:] = heuristics_matrix[i,:] / row_sum
            
    return heuristics_matrix
