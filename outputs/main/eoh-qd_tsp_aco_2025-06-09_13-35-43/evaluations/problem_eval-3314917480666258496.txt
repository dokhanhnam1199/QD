import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively improving tours using 2-opt swaps and recording edge frequencies in the best tours found.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000
    num_best_tours = 10

    best_tours = []
    best_tour_lengths = []

    for _ in range(num_iterations):
        # 1. Generate an initial random tour
        tour = np.random.permutation(n)
        tour_length = calculate_tour_length(tour, distance_matrix)

        # 2. Improve the tour using 2-opt swaps
        improved_tour, improved_tour_length = two_opt_swap(tour, tour_length, distance_matrix)

        # 3. Update the best tours found so far
        if len(best_tours) < num_best_tours:
            best_tours.append(improved_tour)
            best_tour_lengths.append(improved_tour_length)
        else:
            max_len_index = np.argmax(best_tour_lengths)
            if improved_tour_length < best_tour_lengths[max_len_index]:
                best_tours[max_len_index] = improved_tour
                best_tour_lengths[max_len_index] = improved_tour_length

    # 4. Update the heuristic matrix based on the best tours
    for tour in best_tours:
        for i in range(n):
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1

    return heuristics_matrix

def calculate_tour_length(tour, distance_matrix):
    """Calculates the total length of a tour."""
    n = len(tour)
    tour_length = 0
    for i in range(n - 1):
        tour_length += distance_matrix[tour[i], tour[i+1]]
    tour_length += distance_matrix[tour[-1], tour[0]]
    return tour_length

def two_opt_swap(tour, tour_length, distance_matrix):
    """Applies 2-opt swaps to improve a tour."""
    n = len(tour)
    improved_tour = tour[:]
    improved_tour_length = tour_length
    
    for i in range(n):
        for j in range(i + 2, n):
            # Create a new tour by reversing the segment between i+1 and j
            new_tour = tour[:i+1] + tour[i+1:j+1][::-1] + tour[j+1:]

            # Calculate the length of the new tour
            new_tour_length = calculate_tour_length(new_tour, distance_matrix)
            
            # If the new tour is shorter, update the improved tour
            if new_tour_length < improved_tour_length:
                improved_tour = new_tour
                improved_tour_length = new_tour_length
                
    return heuristics_matrix
