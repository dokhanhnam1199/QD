import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of TSP solutions, using crossover and mutation operations to improve the solutions over generations, and then uses the edge frequencies in the best solutions to construct the heuristic matrix.}"""
    n = len(distance_matrix)
    population_size = 50
    generations = 100
    mutation_rate = 0.05
    
    # Initialize population
    population = []
    for _ in range(population_size):
        path = np.random.permutation(n)
        population.append(path)
    
    def calculate_fitness(path):
        fitness = 0
        for i in range(n - 1):
            fitness += distance_matrix[path[i], path[i+1]]
        fitness += distance_matrix[path[-1], path[0]]
        return fitness
    
    def crossover(parent1, parent2):
        start = np.random.randint(n)
        length = np.random.randint(1, n // 2)
        child = np.zeros(n, dtype=int) - 1
        
        # Copy a segment from parent1
        for i in range(length):
            idx = (start + i) % n
            child[idx] = parent1[idx]
        
        # Fill the rest from parent2
        current_idx = 0
        for gene in parent2:
            if gene not in child:
                while child[current_idx] != -1:
                    current_idx = (current_idx + 1) % n
                child[current_idx] = gene
        
        return child

    def mutate(path):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(n, 2, replace=False)
            path[i], path[j] = path[j], path[i]
        return path
    
    # Evolve population
    for _ in range(generations):
        # Calculate fitness for each individual
        fitness_scores = [calculate_fitness(path) for path in population]
        
        # Selection (tournament selection)
        selected_indices = np.random.choice(population_size, size=population_size, replace=True)
        selected_population = [population[i] for i in selected_indices]
        
        # Create new population
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i+1) % population_size]
            
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
        
        population = new_population
    
    # Find the best solution
    fitness_scores = [calculate_fitness(path) for path in population]
    best_index = np.argmin(fitness_scores)
    best_path = population[best_index]
    
    # Create heuristic matrix
    heuristics_matrix = np.zeros((n, n))
    for i in range(n - 1):
        heuristics_matrix[best_path[i], best_path[i+1]] = 1
        heuristics_matrix[best_path[i+1], best_path[i]] = 1
    heuristics_matrix[best_path[-1], best_path[0]] = 1
    heuristics_matrix[best_path[0], best_path[-1]] = 1

    return heuristics_matrix
