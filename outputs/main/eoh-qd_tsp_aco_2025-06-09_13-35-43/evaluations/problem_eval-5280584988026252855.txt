import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach to construct initial solutions, refines them with 2-opt swaps, and employs a weighted average of edge frequencies in refined solutions, prioritizing solutions with lower costs to generate heuristics.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    iterations = 50
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    solution_costs = []
    solutions = []

    for _ in range(num_samples):
        # Generate initial solution using greedy nearest neighbor
        start_node = np.random.randint(n)
        unvisited_nodes = list(range(n))
        unvisited_nodes.remove(start_node)
        solution = [start_node]
        current_node = start_node

        while unvisited_nodes:
            nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])
            solution.append(nearest_node)
            unvisited_nodes.remove(nearest_node)
            current_node = nearest_node

        solution = np.append(solution, solution[0])
        cost = calculate_cost_v2(solution, distance_matrix)

        # Iteratively refine the solution with 2-opt swaps
        for _ in range(iterations):
            improved = False
            for i in range(1, n - 1):
                for j in range(i + 1, n):
                    new_solution = solution.copy()
                    new_solution[i:j+1] = new_solution[i:j+1][::-1]
                    new_cost = calculate_cost_v2(new_solution, distance_matrix)
                    if new_cost < cost:
                        solution = new_solution
                        cost = new_cost
                        improved = True
            if not improved:
                break

        solutions.append(solution)
        solution_costs.append(cost)
    
    #Calculate weights based on solution costs (higher weight for lower cost)
    max_cost = max(solution_costs)
    weights = [(max_cost - cost + 1e-9) for cost in solution_costs] #Add small value to avoid zero division
    sum_weights = sum(weights)
    normalized_weights = [w / sum_weights for w in weights]

    # Calculate heuristics based on weighted edge frequency
    for idx, solution in enumerate(solutions):
        weight = normalized_weights[idx]
        for i in range(n):
            node1 = solution[i]
            node2 = solution[i+1]
            heuristics_matrix[node1, node2] += weight
            heuristics_matrix[node2, node1] += weight  # Symmetric

    return heuristics_matrix

def calculate_cost_v2(solution, distance_matrix):
    cost = 0
    for i in range(len(solution) - 1):
        cost += distance_matrix[solution[i], solution[i+1]]
    return heuristics_matrix
