import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours using a greedy approach with a probabilistic element, favoring shorter edges and previously selected edges, and updates the edge selection probability based on the tour's quality.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    edge_usage = np.zeros((n, n))
    num_iterations = 1000
    alpha = 0.1  # Influence of edge usage

    for _ in range(num_iterations):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        path = [current_node]

        while unvisited_nodes:
            probabilities = np.zeros(n)
            for neighbor in unvisited_nodes:
                probabilities[neighbor] = (1 / (distance_matrix[current_node, neighbor] + 1e-9)) + alpha * edge_usage[current_node, neighbor]

            probabilities = probabilities / np.sum(probabilities)

            next_node = np.random.choice(n, p=probabilities)

            path.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node
        
        path.append(path[0])
        tour_length = 0
        for i in range(len(path) - 1):
            tour_length += distance_matrix[path[i], path[i+1]]

        # Update edge usage based on tour quality
        for i in range(len(path) - 1):
            edge_usage[path[i], path[i+1]] += 1 / tour_length
            edge_usage[path[i+1], path[i]] += 1 / tour_length

    heuristics_matrix = edge_usage
    return heuristics_matrix
