import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by prioritizing edges that connect nodes with high centrality, modulated by the inverse of their distance, using PageRank centrality to guide edge selection.}"""
    num_nodes = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate PageRank centrality
    transition_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(num_nodes):
        row_sum = np.sum(1 / (distance_matrix[i, :] + 1e-6))
        transition_matrix[i, :] = (1 / (distance_matrix[i, :] + 1e-6)) / row_sum

    damping_factor = 0.85
    personalization_vector = np.ones(num_nodes) / num_nodes  # Uniform prior
    
    # Power iteration for PageRank
    pagerank = np.ones(num_nodes) / num_nodes
    for _ in range(100):  # Iterate until convergence
        pagerank = (1 - damping_factor) * personalization_vector + damping_factor * np.dot(transition_matrix.T, pagerank)
    
    # Create the heuristics matrix based on PageRank and distance
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i != j:
                heuristics_matrix[i, j] = (pagerank[i] + pagerank[j]) / (distance_matrix[i, j] + 1e-6)

    return heuristics_matrix
