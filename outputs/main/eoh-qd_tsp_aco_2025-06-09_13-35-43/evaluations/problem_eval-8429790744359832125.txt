import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses simulated annealing to generate multiple TSP solutions and uses the edge frequencies across the samples as the heuristic matrix.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 50
    temperature = 100
    cooling_rate = 0.95
    
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Initialize a random path
        path = list(np.random.permutation(num_nodes))
        path.append(path[0])  # Return to start

        # Simulated Annealing
        current_cost = calculate_cost(path, distance_matrix)

        while temperature > 0.01:
            # Generate a neighbor by swapping two cities
            i, j = np.random.choice(range(1, num_nodes), 2, replace=False)
            neighbor_path = path[:]
            neighbor_path[i], neighbor_path[j] = neighbor_path[j], neighbor_path[i]
            neighbor_cost = calculate_cost(neighbor_path, distance_matrix)

            # Accept the neighbor if it's better or with a probability
            if neighbor_cost < current_cost or np.random.rand() < np.exp((current_cost - neighbor_cost) / temperature):
                path = neighbor_path
                current_cost = neighbor_cost

            temperature *= cooling_rate

        # Update heuristics matrix
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1  # Symmetric

    heuristics_matrix /= num_samples  # Normalize to frequency

    return heuristics_matrix

def calculate_cost(path, distance_matrix):
    cost = 0
    for i in range(len(path) - 1):
        cost += distance_matrix[path[i], path[i+1]]
    return heuristics_matrix
