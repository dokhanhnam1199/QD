import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random solutions, iteratively refines them by swapping edges, and uses the frequency of each edge's appearance in the best solutions as a heuristic indicator of its importance.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    iterations = 50
    best_solutions = []
    best_costs = []
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random solution
        solution = np.random.permutation(n)
        solution = np.append(solution, solution[0])  # Return to starting node
        
        cost = calculate_cost(solution, distance_matrix)

        # Iteratively refine the solution with 2-opt swaps
        for _ in range(iterations):
            improved = False
            for i in range(1, n - 1):
                for j in range(i + 1, n):
                    new_solution = solution.copy()
                    new_solution[i:j+1] = new_solution[i:j+1][::-1]
                    new_cost = calculate_cost(new_solution, distance_matrix)
                    if new_cost < cost:
                        solution = new_solution
                        cost = new_cost
                        improved = True
            if not improved:
                break
        
        # Keep track of the best solutions
        if len(best_costs) < 10:
            best_solutions.append(solution)
            best_costs.append(cost)
        elif cost < max(best_costs):
            max_index = best_costs.index(max(best_costs))
            best_solutions[max_index] = solution
            best_costs[max_index] = cost

    # Calculate heuristics based on edge frequency in the best solutions
    for solution in best_solutions:
        for i in range(n):
            node1 = solution[i]
            node2 = solution[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1  # Symmetric
    
    heuristics_matrix = heuristics_matrix / len(best_solutions) # Normalize by number of best solutions

    return heuristics_matrix

def calculate_cost(solution, distance_matrix):
    cost = 0
    for i in range(len(solution) - 1):
        cost += distance_matrix[solution[i], solution[i+1]]
    return heuristics_matrix
