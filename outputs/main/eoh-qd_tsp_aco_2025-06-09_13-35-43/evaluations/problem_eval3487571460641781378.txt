import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random solutions, iteratively refines them using a greedy nearest neighbor approach and 2-opt swaps, then combines the edge frequencies and inverse ranks of solutions to generate the heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    iterations = 50
    best_solutions = []
    best_costs = []
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a solution using Nearest Neighbor
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        unvisited.remove(start_node)
        solution = [start_node]
        current_node = start_node
        
        while unvisited:
            nearest_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            solution.append(nearest_node)
            unvisited.remove(nearest_node)
            current_node = nearest_node
        solution = np.append(solution, solution[0])  # Return to starting node
        cost = calculate_cost(solution, distance_matrix)

        # Iteratively refine the solution with 2-opt swaps
        for _ in range(iterations):
            improved = False
            for i in range(1, n - 1):
                for j in range(i + 1, n):
                    new_solution = solution.copy()
                    new_solution[i:j+1] = new_solution[i:j+1][::-1]
                    new_cost = calculate_cost(new_solution, distance_matrix)
                    if new_cost < cost:
                        solution = new_solution
                        cost = new_cost
                        improved = True
            if not improved:
                break
        
        # Keep track of the best solutions and their costs
        best_solutions.append(solution)
        best_costs.append(cost)

    # Rank the solutions based on cost
    ranked_indices = np.argsort(best_costs)

    # Calculate heuristics based on edge frequency and rank in the best solutions
    for rank, index in enumerate(ranked_indices):
        solution = best_solutions[index]
        weight = 1 / (rank + 1)  # Inverse rank weighting
        for i in range(n):
            node1 = solution[i]
            node2 = solution[i+1]
            heuristics_matrix[node1, node2] += weight
            heuristics_matrix[node2, node1] += weight  # Symmetric
    
    heuristics_matrix = heuristics_matrix / num_samples # Normalize by number of samples

    return heuristics_matrix

def calculate_cost(solution, distance_matrix):
    cost = 0
    for i in range(len(solution) - 1):
        cost += distance_matrix[solution[i], solution[i+1]]
    return heuristics_matrix
