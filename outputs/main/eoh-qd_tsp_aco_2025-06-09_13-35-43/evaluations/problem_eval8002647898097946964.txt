import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines edge-frequency analysis from short tours with a penalty for edges connecting nodes that are far apart, resulting in a heuristic matrix that favors frequent edges between closer nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    edge_counts = np.zeros_like(distance_matrix, dtype=int)
    tour_lengths = []
    tours = []

    for _ in range(num_samples):
        tour = np.random.permutation(n)
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]

        tour_lengths.append(tour_length)
        tours.append(tour)

    # Identify short tours (e.g., top 20%)
    threshold = np.percentile(tour_lengths, 20)
    short_tours = [tour for i, tour in enumerate(tours) if tour_lengths[i] <= threshold]

    # Count edge occurrences in short tours
    for tour in short_tours:
        for i in range(n - 1):
            u = tour[i]
            v = tour[i + 1]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1
        edge_counts[tour[-1], tour[0]] += 1
        edge_counts[tour[0], tour[-1]] += 1

    # Combine edge frequency with distance penalty
    max_edge_count = np.max(edge_counts) if np.max(edge_counts) > 0 else 1
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (edge_counts[i, j] / max_edge_count) / (distance_matrix[i, j] + 1e-9) # Avoid division by zero
    return heuristics_matrix
