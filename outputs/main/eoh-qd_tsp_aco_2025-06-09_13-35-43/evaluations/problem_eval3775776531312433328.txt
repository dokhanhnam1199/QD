import numpy as np

def calculate_cost(solution, distance_matrix):
    cost = 0
    for i in range(len(solution) - 1):
        cost += distance_matrix[solution[i], solution[i+1]]
    return cost

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random solutions, iteratively refines them by swapping edges, and uses the inverse rank of each edge's appearance in the best solutions as a heuristic indicator of its importance.}"""
    n = distance_matrix.shape[0]
    num_samples = 50  # Reduced number of samples
    iterations = 25   # Reduced number of iterations
    best_solutions = []
    best_costs = []
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random solution
        solution = np.random.permutation(n)
        solution = np.append(solution, solution[0])  # Return to starting node
        
        cost = calculate_cost(solution, distance_matrix)

        # Iteratively refine the solution with 2-opt swaps
        for _ in range(iterations):
            improved = False
            for i in range(1, n - 1):
                for j in range(i + 1, n):
                    new_solution = solution.copy()
                    new_solution[i:j+1] = new_solution[i:j+1][::-1]
                    new_cost = calculate_cost(new_solution, distance_matrix)
                    if new_cost < cost:
                        solution = new_solution
                        cost = new_cost
                        improved = True
            if not improved:
                break
        
        # Keep track of the best solutions
        if len(best_costs) < 5: # Reduced number of best solutions
            best_solutions.append(solution)
            best_costs.append(cost)
        elif cost < max(best_costs):
            max_index = best_costs.index(max(best_costs))
            best_solutions[max_index] = solution
            best_costs[max_index] = cost

    # Calculate heuristics based on edge frequency in the best solutions
    edge_counts = np.zeros_like(distance_matrix, dtype=int)
    for solution in best_solutions:
        for i in range(n):
            node1 = solution[i]
            node2 = solution[i+1]
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1  # Symmetric

    # Rank the edges based on frequency and use inverse rank as heuristic
    ranked_edges = np.zeros_like(distance_matrix, dtype=float)
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            edges.append((i, j, edge_counts[i, j]))
    
    edges.sort(key=lambda x: x[2], reverse=True) # Sort by frequency

    for rank, (node1, node2, count) in enumerate(edges):
        ranked_edges[node1, node2] = 1.0 / (rank + 1) # Inverse rank
        ranked_edges[node2, node1] = 1.0 / (rank + 1) # Symmetric
    
    return heuristics_matrix
