import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a heuristic matrix by sampling tours biased by the current heuristic, and updating the heuristic based on the tour lengths and edge frequencies, akin to reinforcement learning.}"""
    n = distance_matrix.shape[0]
    num_samples = 500
    learning_rate = 0.1
    heuristics_matrix = np.ones((n, n)) / n  # Initialize with uniform probability

    for iteration in range(10):  # Iterate to refine the heuristic
        edge_counts = np.zeros((n, n))
        total_tour_lengths = np.zeros((n, n))

        for _ in range(num_samples):
            # Sample a tour based on the current heuristics
            current_node = np.random.randint(n)
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(current_node)
            tour = [current_node]

            while unvisited_nodes:
                probabilities = np.array([heuristics_matrix[current_node, neighbor] for neighbor in range(n)])
                probabilities[list(unvisited_nodes)] /= np.sum(probabilities[list(unvisited_nodes)])
                
                next_node = np.random.choice(n, p=probabilities)

                if next_node not in unvisited_nodes:
                     possible_next_nodes = list(unvisited_nodes)
                     if not possible_next_nodes:
                         break
                     next_node = possible_next_nodes[0]
                
                tour.append(next_node)
                unvisited_nodes.remove(next_node)
                current_node = next_node

            tour.append(tour[0])  # Return to start

            # Calculate tour length
            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]

            # Update edge counts and tour lengths
            for i in range(n):
                u, v = tour[i], tour[i+1]
                edge_counts[u, v] += 1
                edge_counts[v, u] += 1
                total_tour_lengths[u, v] += tour_length
                total_tour_lengths[v, u] += tour_length
        
        # Update the heuristics matrix
        for i in range(n):
            for j in range(n):
                if i != j and edge_counts[i, j] > 0:
                     average_tour_length = total_tour_lengths[i, j] / edge_counts[i, j]
                     edge_frequency = edge_counts[i, j] / num_samples
                     reward = edge_frequency / average_tour_length # Higher frequency, shorter tour is better
                     heuristics_matrix[i, j] = (1 - learning_rate) * heuristics_matrix[i, j] + learning_rate * reward
                else:
                     heuristics_matrix[i, j] *= (1 - learning_rate)

        # Normalize heuristics to maintain probabilities for sampling
        for i in range(n):
            row_sum = np.sum(heuristics_matrix[i, :])
            if row_sum > 0:
                heuristics_matrix[i, :] /= row_sum

    return heuristics_matrix
