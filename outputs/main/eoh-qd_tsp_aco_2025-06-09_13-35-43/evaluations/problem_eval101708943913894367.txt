import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm uses ant colony optimization (ACO) principles to iteratively construct solutions, update pheromone trails based on solution quality, and return a matrix representing the pheromone levels on each edge.}"""
  n = distance_matrix.shape[0]
  pheromone_matrix = np.ones_like(distance_matrix)
  alpha = 1  # Pheromone influence
  beta = 2   # Distance influence
  rho = 0.5  # Evaporation rate
  Q = 100   # Pheromone deposit constant
  num_ants = n
  num_iterations = 100

  for _ in range(num_iterations):
    ant_paths = []
    ant_costs = []

    for ant in range(num_ants):
      unvisited = list(range(n))
      start_node = np.random.choice(unvisited)
      current_node = start_node
      unvisited.remove(current_node)
      path = [current_node]
      cost = 0

      while unvisited:
        probabilities = []
        for next_node in unvisited:
          pheromone = pheromone_matrix[current_node, next_node]
          distance = distance_matrix[current_node, next_node]
          probabilities.append((pheromone**alpha) / (distance**beta))

        probabilities = np.array(probabilities)
        probabilities /= probabilities.sum()

        next_node = np.random.choice(unvisited, p=probabilities)
        cost += distance_matrix[current_node, next_node]
        current_node = next_node
        path.append(current_node)
        unvisited.remove(current_node)

      cost += distance_matrix[current_node, start_node]
      path.append(start_node)  # Return to start
      ant_paths.append(path)
      ant_costs.append(cost)

    # Update pheromones
    pheromone_matrix *= (1 - rho)  # Evaporation
    for i in range(num_ants):
      path = ant_paths[i]
      cost = ant_costs[i]
      for j in range(n):
        pheromone_matrix[path[j], path[j+1]] += Q / cost
        pheromone_matrix[path[j+1], path[j]] = pheromone_matrix[path[j], path[j+1]] #Symmetric

  return heuristics_matrix
