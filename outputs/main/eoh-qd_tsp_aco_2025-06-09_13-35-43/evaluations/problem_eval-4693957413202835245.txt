import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm uses ant colony optimization principles to construct a heuristic matrix by simulating ant pheromone trails on promising edges.}"""
  n = distance_matrix.shape[0]
  pheromone_matrix = np.ones((n, n))
  heuristics_matrix = np.zeros((n, n))
  alpha = 1
  beta = 2
  rho = 0.5
  Q = 100

  num_ants = n
  num_iterations = 100

  for iteration in range(num_iterations):
    ant_paths = []
    ant_costs = []

    for ant in range(num_ants):
      unvisited = set(range(n))
      start_node = ant % n
      current_node = start_node
      unvisited.remove(current_node)
      path = [current_node]
      path_cost = 0

      while unvisited:
        probabilities = np.zeros(n)
        for next_node in range(n):
          if next_node in unvisited:
            probabilities[next_node] = (pheromone_matrix[current_node, next_node]**alpha) * ((1/distance_matrix[current_node, next_node])**beta)
        
        probabilities /= np.sum(probabilities)
        
        next_node = np.random.choice(n, p=probabilities)
        if next_node not in unvisited:
          available_nodes = list(unvisited)
          next_node = available_nodes[np.argmin([distance_matrix[current_node,node] for node in available_nodes])]
        
        path.append(next_node)
        path_cost += distance_matrix[current_node, next_node]
        unvisited.remove(next_node)
        current_node = next_node

      path.append(start_node)
      path_cost += distance_matrix[current_node, start_node]
      ant_paths.append(path)
      ant_costs.append(path_cost)

    # Update pheromone trails
    delta_pheromone = np.zeros((n, n))
    for ant in range(num_ants):
      cost = ant_costs[ant]
      path = ant_paths[ant]
      for i in range(n):
        delta_pheromone[path[i], path[(i + 1) % n]] += Q / cost

    pheromone_matrix = (1 - rho) * pheromone_matrix + delta_pheromone

  heuristics_matrix = pheromone_matrix
  return heuristics_matrix
