import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively builds tours by probabilistically adding the shortest edges that don't create subtours, favoring edges that connect to nodes with high degree in previously generated tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros((n, n))

    for _ in range(num_samples):
        tour = []
        unvisited = set(range(n))
        
        # Start with a random node
        start_node = np.random.choice(list(unvisited))
        tour.append(start_node)
        unvisited.remove(start_node)
        
        while unvisited:
            current_node = tour[-1]
            
            # Calculate distances to unvisited nodes
            distances = {node: distance_matrix[current_node, node] for node in unvisited}
            
            # Weight distances by degree of the unvisited node in previous tours
            weighted_distances = {}
            for node, dist in distances.items():
                degree = np.sum(heuristics_matrix[node, :]) + np.sum(heuristics_matrix[:, node])
                weighted_distances[node] = dist / (1 + degree) # Favor nodes with high degree
            
            # Select the next node based on weighted distances (probabilistically)
            probabilities = np.array(list(weighted_distances.values()))
            probabilities = np.exp(-probabilities)  # Convert to probabilities
            probabilities /= np.sum(probabilities)  # Normalize
            
            next_node = np.random.choice(list(weighted_distances.keys()), p=probabilities)

            tour.append(next_node)
            unvisited.remove(next_node)

        tour.append(tour[0]) # Return to start

        # Update heuristic matrix
        for i in range(n):
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1

    return heuristics_matrix
