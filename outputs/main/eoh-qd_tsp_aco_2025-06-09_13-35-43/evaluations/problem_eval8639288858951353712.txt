import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a probability distribution over edges by sampling solutions using a weighted random walk based on edge probabilities and updating the probabilities according to the edges used in the sampled solution.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) / (n * (n - 1) / 2)  # Initialize with uniform probability
    
    for _ in range(num_samples):
        start_node = np.random.randint(n)
        unvisited = set(range(n))
        unvisited.remove(start_node)
        current_node = start_node
        path = [start_node]

        while unvisited:
            # Create a probability distribution for the next node based on the current heuristics
            probabilities = heuristics_matrix[current_node, :].copy()
            for node in range(n):
              if node not in unvisited:
                probabilities[node] = 0

            if np.sum(probabilities) == 0:
                next_node = np.random.choice(list(unvisited))
            else:
              probabilities /= np.sum(probabilities)
              next_node = np.random.choice(n, p=probabilities)

            path.append(next_node)
            unvisited.remove(next_node)

            current_node = next_node
            
        path.append(start_node)

        # Update heuristics matrix based on the path
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i+1]
            heuristics_matrix[node1, node2] = (heuristics_matrix[node1, node2] + 1) / 2
            heuristics_matrix[node2, node1] = heuristics_matrix[node1, node2]
            
    return heuristics_matrix
