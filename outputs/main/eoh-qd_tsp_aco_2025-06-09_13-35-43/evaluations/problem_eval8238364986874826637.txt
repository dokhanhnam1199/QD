import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path information with random edge selection, prioritizing edges on shortest paths but also exploring diverse edges.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))
    shortest_path_matrix = np.zeros((n, n))

    # Calculate shortest path between all pairs of nodes using Floyd-Warshall
    dist = np.copy(distance_matrix)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i, j] = min(dist[i, j], dist[i, k] + dist[k, j])

    shortest_path_matrix = dist

    # Normalize shortest path distances to be between 0 and 1, higher values indicate shorter paths
    max_dist = np.max(shortest_path_matrix)
    normalized_shortest_path = 1 - (shortest_path_matrix / max_dist)

    # Incorporate randomness to encourage exploration
    randomness_factor = 0.1
    random_matrix = np.random.rand(n, n) * randomness_factor

    # Combine shortest path information with randomness
    heuristics_matrix = normalized_shortest_path + random_matrix

    return heuristics_matrix
