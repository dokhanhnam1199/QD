import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples many random tours, and for each edge, records a score based on how much each edge contributes to reducing the tour length, giving higher scores to edges that lead to shorter tours when included.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    
    edge_scores = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_samples):
        permutation = np.random.permutation(n)
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[permutation[i], permutation[i+1]]
        tour_length += distance_matrix[permutation[-1], permutation[0]]
        
        # Update edge scores based on tour length
        for i in range(n - 1):
            u, v = permutation[i], permutation[i+1]
            edge_scores[u, v] += (1 / (1 + tour_length))
            edge_scores[v, u] += (1 / (1 + tour_length))
        u, v = permutation[-1], permutation[0]
        edge_scores[u, v] += (1 / (1 + tour_length))
        edge_scores[v, u] += (1 / (1 + tour_length))
            
    # Normalize edge scores
    max_score = np.max(edge_scores)
    if max_score > 0:
        heuristics_matrix = edge_scores / max_score
    else:
        heuristics_matrix = edge_scores

    return heuristics_matrix
