import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples tours, calculates edge frequencies, and weights these frequencies by a combination of edge distance and a measure of tour diversity.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    sampled_tours = []
    
    heuristics_matrix = np.zeros((n, n))
    edge_counts = np.zeros((n, n))
    tour_lengths = np.zeros(num_samples)
    
    for sample_index in range(num_samples):
        tour = np.random.permutation(n)
        sampled_tours.append(tour)
        tour_length = sum(distance_matrix[tour[i], tour[(i + 1) % n]] for i in range(n))
        tour_lengths[sample_index] = tour_length

        for i in range(n):
            u = tour[i]
            v = tour[(i + 1) % n]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1
            
    tour_lengths_mean = np.mean(tour_lengths)
    tour_lengths_std = np.std(tour_lengths)

    for i in range(n):
        for j in range(n):
            if i != j:
                edge_frequency = edge_counts[i, j] / num_samples
                edge_distance = distance_matrix[i, j]
                
                heuristics_matrix[i, j] = edge_frequency / (edge_distance * (1 + tour_lengths_std / tour_lengths_mean))

    return heuristics_matrix
