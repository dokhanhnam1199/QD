import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach to construct initial solutions, improves them with 2-opt swaps, and then combines edge frequencies from these improved solutions to create a heuristic matrix, emphasizing edges present in multiple good solutions.}"""
    n = distance_matrix.shape[0]
    num_samples = 100
    iterations = 50
    best_solutions = []
    best_costs = []
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate an initial solution using a greedy approach
        unvisited = list(range(n))
        start_node = np.random.choice(unvisited)
        solution = [start_node]
        unvisited.remove(start_node)

        while unvisited:
            current_node = solution[-1]
            nearest_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            solution.append(nearest_node)
            unvisited.remove(nearest_node)

        solution = np.append(solution, solution[0])
        cost = calculate_cost(solution, distance_matrix)

        # Iteratively refine the solution with 2-opt swaps
        for _ in range(iterations):
            improved = False
            for i in range(1, n - 1):
                for j in range(i + 1, n):
                    new_solution = solution.copy()
                    new_solution[i:j+1] = new_solution[i:j+1][::-1]
                    new_cost = calculate_cost(new_solution, distance_matrix)
                    if new_cost < cost:
                        solution = new_solution
                        cost = new_cost
                        improved = True
            if not improved:
                break
        
        # Keep track of the best solutions
        if len(best_costs) < 10:
            best_solutions.append(solution)
            best_costs.append(cost)
        elif cost < max(best_costs):
            max_index = best_costs.index(max(best_costs))
            best_solutions[max_index] = solution
            best_costs[max_index] = cost

    # Calculate heuristics based on edge frequency in the best solutions
    for solution in best_solutions:
        for i in range(n):
            node1 = solution[i]
            node2 = solution[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1  # Symmetric
    
    heuristics_matrix = heuristics_matrix / len(best_solutions) # Normalize by number of best solutions

    return heuristics_matrix

def calculate_cost(solution, distance_matrix):
    cost = 0
    for i in range(len(solution) - 1):
        cost += distance_matrix[solution[i], solution[i+1]]
    return heuristics_matrix
