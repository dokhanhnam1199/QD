import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm initializes edge probabilities based on distance, then iteratively refines these probabilities by biasing random walks towards shorter edges and updating probabilities based on the observed frequencies of edges in the resulting paths.}"""
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))

    # Initialize heuristics based on inverse distance
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            heuristics_matrix[i, j] = heuristics_matrix[j, i] = 1 / (distance + 1e-9)

    # Normalize to probabilities
    for i in range(n):
        row_sum = np.sum(heuristics_matrix[i, :])
        if row_sum > 0:
            heuristics_matrix[i, :] /= row_sum

    # Iterative refinement
    num_iterations = 10
    num_walks = 50

    edge_counts = np.zeros((n, n))

    for _ in range(num_iterations):
        for _ in range(num_walks):
            start_node = np.random.randint(n)
            current_node = start_node
            walk = [current_node]

            for _ in range(n - 1):
                probabilities = heuristics_matrix[current_node, :]
                next_node = np.random.choice(n, p=probabilities)
                while next_node in walk:
                    probabilities[next_node] = 0
                    if np.sum(probabilities) == 0:
                        remaining_nodes = list(set(range(n)) - set(walk))
                        if not remaining_nodes:
                            next_node = start_node #should not happen.
                            break
                        next_node = min(remaining_nodes, key=lambda x: distance_matrix[current_node, x])

                        break
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(n, p=probabilities)

                walk.append(next_node)
                edge_counts[current_node, next_node] += 1
                edge_counts[next_node, current_node] += 1
                current_node = next_node
        
        #Update heuristics based on edge counts
        for i in range(n):
            for j in range(i+1,n):
                heuristics_matrix[i,j] = heuristics_matrix[j,i] = edge_counts[i,j] + 1e-9

        # Normalize heuristics to probabilities
        for i in range(n):
            row_sum = np.sum(heuristics_matrix[i, :])
            if row_sum > 0:
                heuristics_matrix[i, :] /= row_sum
                
    return heuristics_matrix
