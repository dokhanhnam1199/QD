import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm iteratively generates random solutions, evaluates their quality based on distance and edge frequency, and updates edge weights to favor edges present in better solutions, finally returning a matrix representing the learned edge heuristic values.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.ones_like(distance_matrix)
  num_iterations = 100
  num_samples = 50
  
  for _ in range(num_iterations):
    solutions = []
    costs = []
    for _ in range(num_samples):
      permutation = np.random.permutation(n)
      cost = 0
      for i in range(n - 1):
        cost += distance_matrix[permutation[i], permutation[i+1]]
      cost += distance_matrix[permutation[-1], permutation[0]]
      solutions.append(permutation)
      costs.append(cost)
    
    costs = np.array(costs)
    best_solutions = solutions[np.argmin(costs)]
    
    # Update heuristics based on the best solutions
    scaling_factor = 0.1 # Adjust this scaling factor
    for i in range(n - 1):
      heuristics_matrix[best_solutions[i], best_solutions[i+1]] += scaling_factor * (1 - costs.min()/costs.max()) if costs.max() != 0 else 1
      heuristics_matrix[best_solutions[i+1], best_solutions[i]] = heuristics_matrix[best_solutions[i], best_solutions[i+1]] 
      
    heuristics_matrix[best_solutions[-1], best_solutions[0]] += scaling_factor * (1 - costs.min()/costs.max()) if costs.max() != 0 else 1
    heuristics_matrix[best_solutions[0], best_solutions[-1]] = heuristics_matrix[best_solutions[-1], best_solutions[0]]

  return heuristics_matrix
