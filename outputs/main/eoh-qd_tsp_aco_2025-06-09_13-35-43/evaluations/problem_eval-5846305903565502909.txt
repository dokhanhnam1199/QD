import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by simulating ant colony optimization without pheromone evaporation, focusing on edge reinforcement based on tour quality, and normalizing the results to represent edge selection probabilities.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_ants = n
    num_iterations = 50

    for iteration in range(num_iterations):
        all_tours = []
        all_tour_lengths = []

        for ant in range(num_ants):
            current_node = np.random.randint(n)
            tour = [current_node]
            unvisited = set(range(n))
            unvisited.remove(current_node)
            
            while unvisited:
                distances = distance_matrix[current_node, list(unvisited)]
                probabilities = 1.0 / (distances + 1e-9)  # Inverse distance heuristic
                probabilities /= np.sum(probabilities)
                
                next_node = list(unvisited)[np.random.choice(len(unvisited), p=probabilities)]
                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            tour.append(tour[0])
            all_tours.append(tour)

            tour_length = 0.0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            all_tour_lengths.append(tour_length)

        # Reinforce edges based on tour quality (without pheromone evaporation)
        for i in range(num_ants):
            tour = all_tours[i]
            tour_length = all_tour_lengths[i]
            
            reward = 1.0 / (tour_length + 1e-9) # Higher reward for shorter tours

            for j in range(n):
                node1 = tour[j]
                node2 = tour[j+1]
                heuristics_matrix[node1, node2] += reward
                heuristics_matrix[node2, node1] += reward
    
    # Normalize to probabilities
    for i in range(n):
        row_sum = np.sum(heuristics_matrix[i, :])
        if row_sum > 0:
            heuristics_matrix[i, :] /= row_sum
            
    return heuristics_matrix
