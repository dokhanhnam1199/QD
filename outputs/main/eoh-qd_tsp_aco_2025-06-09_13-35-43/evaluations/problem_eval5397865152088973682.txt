import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random solutions, refines them using a greedy nearest neighbor approach, and then uses the inverse of the average edge distance in the best solutions as a heuristic indicator.}"""
    n = distance_matrix.shape[0]
    num_samples = 50
    best_solutions = []
    best_costs = []
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a solution using nearest neighbor
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        solution = [start_node]
        unvisited.remove(start_node)
        
        while unvisited:
            last_node = solution[-1]
            nearest_node = min(unvisited, key=lambda x: distance_matrix[last_node, x])
            solution.append(nearest_node)
            unvisited.remove(nearest_node)

        solution = np.append(solution, solution[0])  # Return to starting node
        cost = calculate_cost(solution, distance_matrix)
        
        # Keep track of the best solutions
        if len(best_costs) < 10:
            best_solutions.append(solution)
            best_costs.append(cost)
        elif cost < max(best_costs):
            max_index = best_costs.index(max(best_costs))
            best_solutions[max_index] = solution
            best_costs[max_index] = cost

    # Calculate heuristics based on inverse average edge distance in best solutions
    edge_distances = np.zeros_like(distance_matrix, dtype=float)
    edge_counts = np.zeros_like(distance_matrix, dtype=int)

    for solution in best_solutions:
        for i in range(n):
            node1 = solution[i]
            node2 = solution[i+1]
            dist = distance_matrix[node1, node2]
            edge_distances[node1, node2] += dist
            edge_distances[node2, node1] += dist
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1

    #Calculate the average
    for i in range(n):
      for j in range(n):
          if edge_counts[i,j] > 0:
              edge_distances[i,j] /= edge_counts[i,j]
          else:
              edge_distances[i,j] = np.inf

    #Heuristics based on inverse
    for i in range(n):
        for j in range(n):
            if edge_distances[i,j] != 0 and edge_distances[i,j] != np.inf:
                heuristics_matrix[i,j] = 1 / edge_distances[i,j]
            else:
                heuristics_matrix[i,j] = 0 # Avoid division by zero
    
    return heuristics_matrix

def calculate_cost(solution, distance_matrix):
    cost = 0
    for i in range(len(solution) - 1):
        cost += distance_matrix[solution[i], solution[i+1]]
    return heuristics_matrix
