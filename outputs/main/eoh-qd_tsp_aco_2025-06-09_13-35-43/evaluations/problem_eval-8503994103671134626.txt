import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs solutions greedily based on edge proximity while incorporating a penalty for previously selected edges, favoring exploration of less-used connections.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 50

    for _ in range(num_iterations):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited = set(range(n))
        unvisited.remove(current_node)
        path = [current_node]
        
        edge_penalties = np.zeros((n, n))

        while unvisited:
            distances = distance_matrix[current_node, :]
            
            # Incorporate edge penalties into the distance
            adjusted_distances = distances + edge_penalties[current_node, :]
            
            # Make sure distances to visited nodes are very high
            adjusted_distances[list(path)] = np.inf 
            
            next_node = np.argmin(adjusted_distances)
            
            path.append(next_node)
            unvisited.remove(next_node)
            
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1
            
            # Penalize the selected edge
            edge_penalties[current_node, next_node] += 1
            edge_penalties[next_node, current_node] += 1

            current_node = next_node

        heuristics_matrix[current_node, start_node] += 1
        heuristics_matrix[start_node, current_node] += 1
        
    return heuristics_matrix
