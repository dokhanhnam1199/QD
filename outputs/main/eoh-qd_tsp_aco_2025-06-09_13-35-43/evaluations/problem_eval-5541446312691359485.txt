import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines a greedy nearest neighbor approach with simulated annealing to iteratively improve a tour, updating a heuristic matrix based on the frequency of edges in accepted solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    
    # Initialize with inverse distance
    for i in range(n):
        for j in range(i + 1, n):
            heuristics_matrix[i, j] = heuristics_matrix[j, i] = 1 / (distance_matrix[i, j] + 1e-9)
    
    # Nearest Neighbor starting tour
    def nearest_neighbor_tour(start_node):
        tour = [start_node]
        unvisited = set(range(n))
        unvisited.remove(start_node)
        current_node = start_node
        while unvisited:
            next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            tour.append(next_node)
            unvisited.remove(next_node)
            current_node = next_node
        tour.append(start_node)
        return tour

    # Calculate tour length
    def tour_length(tour):
        length = 0
        for i in range(len(tour) - 1):
            length += distance_matrix[tour[i], tour[i+1]]
        return length

    # Simulated Annealing
    def simulated_annealing(initial_tour, initial_temperature=100, cooling_rate=0.95, iterations=1000):
        current_tour = initial_tour
        current_cost = tour_length(current_tour)
        best_tour = current_tour[:]
        best_cost = current_cost

        for i in range(iterations):
            temperature = initial_temperature * (cooling_rate ** i)

            # Generate neighbor by swapping two cities
            idx1, idx2 = np.random.choice(range(1, n), 2, replace=False)  # Exclude the starting/ending city
            neighbor_tour = current_tour[:]
            neighbor_tour[idx1], neighbor_tour[idx2] = neighbor_tour[idx2], neighbor_tour[idx1]
            neighbor_cost = tour_length(neighbor_tour)

            # Acceptance probability
            delta = neighbor_cost - current_cost
            if delta < 0 or np.random.rand() < np.exp(-delta / temperature):
                current_tour = neighbor_tour
                current_cost = neighbor_cost

                if current_cost < best_cost:
                    best_tour = current_tour[:]
                    best_cost = current_cost
        return best_tour, best_cost

    # Iterative Improvement and Heuristic Update
    num_iterations = 10
    edge_counts = np.zeros((n, n))

    for _ in range(num_iterations):
        # Generate initial tour using nearest neighbor
        start_node = np.random.randint(n)
        initial_tour = nearest_neighbor_tour(start_node)

        # Improve tour with simulated annealing
        best_tour, best_cost = simulated_annealing(initial_tour)

        # Update edge counts based on best tour
        for i in range(n):
            u, v = best_tour[i], best_tour[i+1]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1

    # Update heuristics based on edge counts and initial heuristic
    for i in range(n):
        for j in range(i + 1, n):
            heuristics_matrix[i, j] = heuristics_matrix[j, i] = heuristics_matrix[i,j] * (edge_counts[i, j] + 1)

    # Normalize heuristics
    for i in range(n):
        row_sum = np.sum(heuristics_matrix[i, :])
        if row_sum > 0:
            heuristics_matrix[i, :] /= row_sum
    
    return heuristics_matrix
