import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm constructs a heuristic matrix by assigning higher probabilities to shorter edges and edges that connect nodes with fewer close neighbors, then refines these probabilities by iteratively sampling solutions and updating edge scores based on their frequency in good solutions, and introduces a temperature parameter to control the exploration-exploitation trade-off in edge selection during the iterative refinement phase.}
    """
    n = len(distance_matrix)
    heuristics_matrix = np.zeros((n, n))

    # Initial heuristic based on distance and node degree
    for i in range(n):
        for j in range(i + 1, n):
            distance = distance_matrix[i, j]
            
            # Calculate a score based on inverse distance
            heuristics_matrix[i, j] = heuristics_matrix[j, i] = 1 / (distance + 1e-9) 

    # Node degree adjustment - penalize nodes with many very close neighbors
    for i in range(n):
        close_neighbors = 0
        for j in range(n):
            if i != j and distance_matrix[i, j] < np.mean(distance_matrix):
                close_neighbors += 1
        
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] /= (close_neighbors + 1)
                heuristics_matrix[j, i] /= (close_neighbors + 1)
    
    # Normalize heuristics to probabilities (initially)
    for i in range(n):
        row_sum = np.sum(heuristics_matrix[i, :])
        if row_sum > 0:
            heuristics_matrix[i, :] /= row_sum

    # Iterative sampling and refinement
    num_iterations = 10
    num_samples = 50
    temperature = 0.1  # Introduce a temperature parameter

    
    edge_counts = np.zeros((n, n))

    for _ in range(num_iterations):
        solutions = []
        costs = []

        # Sample solutions using the current heuristics
        for _ in range(num_samples):
            current_node = np.random.randint(n)
            tour = [current_node]
            unvisited = set(range(n))
            unvisited.remove(current_node)

            while unvisited:
                probabilities = heuristics_matrix[current_node, :]
                probabilities = np.array([probabilities[i] if i in unvisited else 0 for i in range(n)])
                
                if np.sum(probabilities) == 0:
                    next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
                else:
                    probabilities /= np.sum(probabilities)
                    
                    # Apply temperature scaling to probabilities
                    probabilities = np.power(probabilities, 1/temperature)
                    probabilities /= np.sum(probabilities)


                    next_node = np.random.choice(n, p=probabilities)
                    while next_node not in unvisited:
                        probabilities[next_node] = 0
                        if np.sum(probabilities) == 0:
                            next_node = min(unvisited, key=lambda x: distance_matrix[current_node, x])
                            break
                        probabilities /= np.sum(probabilities)
                        
                        # Apply temperature scaling again to probabilities
                        probabilities = np.power(probabilities, 1/temperature)
                        probabilities /= np.sum(probabilities)

                        next_node = np.random.choice(n, p=probabilities)

                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node

            tour.append(tour[0])  # Return to start

            # Calculate cost
            cost = 0
            for i in range(n):
                cost += distance_matrix[tour[i], tour[i+1]]
            
            solutions.append(tour)
            costs.append(cost)

        # Update edge counts based on good solutions
        threshold = np.mean(costs)  # Consider solutions better than the average

        for i in range(num_samples):
            if costs[i] <= threshold:
                tour = solutions[i]
                for j in range(n):
                    node1 = tour[j]
                    node2 = tour[j+1]
                    edge_counts[node1, node2] += 1
                    edge_counts[node2, node1] += 1

        # Update heuristics based on edge counts
        for i in range(n):
            for j in range(i + 1, n):
                heuristics_matrix[i, j] = heuristics_matrix[j, i] = edge_counts[i, j] + 1e-9
        
        # Normalize heuristics to probabilities
        for i in range(n):
            row_sum = np.sum(heuristics_matrix[i, :])
            if row_sum > 0:
                heuristics_matrix[i, :] /= row_sum
                
    return heuristics_matrix
