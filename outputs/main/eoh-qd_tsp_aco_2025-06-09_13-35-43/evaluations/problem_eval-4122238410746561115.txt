import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple near-optimal TSP solutions using a combination of nearest neighbor and random swaps, then uses the frequency of each edge's appearance across these samples as an indicator of its likelihood of being in the optimal solution, weighting edges in shorter paths more heavily.}"""
    num_nodes = distance_matrix.shape[0]
    num_samples = 100

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Nearest Neighbor initialization
        current_node = np.random.randint(num_nodes)
        unvisited_nodes = set(range(num_nodes))
        unvisited_nodes.remove(current_node)
        path = [current_node]

        while unvisited_nodes:
            nearest_neighbor = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])
            path.append(nearest_neighbor)
            unvisited_nodes.remove(nearest_neighbor)
            current_node = nearest_neighbor

        path.append(path[0])  # Return to starting node

        # Random swaps to improve the solution
        for _ in range(num_nodes):
            i, j = np.random.choice(range(1, len(path) - 1), 2, replace=False)
            path[i], path[j] = path[j], path[i]

        # Calculate path length
        path_length = 0
        for i in range(len(path) - 1):
            path_length += distance_matrix[path[i], path[i+1]]

        # Update heuristics matrix, weighting by inverse of path length
        weight = 1.0 / path_length if path_length > 0 else 0  # Avoid division by zero
        for i in range(len(path) - 1):
            node1 = path[i]
            node2 = path[i+1]
            heuristics_matrix[node1, node2] += weight
            heuristics_matrix[node2, node1] += weight  # Symmetric

    heuristics_matrix /= num_samples  # Normalize to frequency

    return heuristics_matrix
