import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm generates multiple random tours using an insertion heuristic with stochasticity, and then calculates a heuristic matrix based on the frequency each edge appears in the sampled tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros((n, n))

    for _ in range(num_samples):
        # Initialize tour with two random nodes
        nodes = list(range(n))
        start_node = np.random.choice(nodes)
        nodes.remove(start_node)
        second_node = np.random.choice(nodes)
        nodes.remove(second_node)
        tour = [start_node, second_node]

        while nodes:
            # Choose a random node to insert
            node_to_insert = np.random.choice(nodes)
            nodes.remove(node_to_insert)

            # Find the best insertion point (stochastically)
            best_index = -1
            min_cost_increase = float('inf')
            
            # Add stochasticity: Consider a subset of insertion points
            num_insertions = min(5, len(tour)) #consider at most 5 insertions
            insertion_indices = np.random.choice(len(tour), size=num_insertions, replace=False)
            
            for i in insertion_indices:
                cost_increase = (
                    distance_matrix[tour[i], node_to_insert]
                    + distance_matrix[node_to_insert, tour[(i + 1) % len(tour)]]
                    - distance_matrix[tour[i], tour[(i + 1) % len(tour)]]
                )
                if cost_increase < min_cost_increase:
                    min_cost_increase = cost_increase
                    best_index = i

            tour.insert(best_index + 1, node_to_insert)

        tour.append(start_node)  # Return to starting node

        # Update heuristic matrix based on tour
        for i in range(n):
            heuristics_matrix[tour[i], tour[(i + 1) % n]] += 1
            heuristics_matrix[tour[(i + 1) % n], tour[i]] += 1

    return heuristics_matrix
