import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours using a nearest neighbor approach from multiple random starting nodes, then scores edges based on how often they appear in these locally optimized tours.}"""
    n = distance_matrix.shape[0]
    num_starts = 100
    edge_counts = np.zeros((n, n), dtype=int)

    for _ in range(num_starts):
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        current_node = start_node
        tour = [current_node]
        unvisited.remove(current_node)

        while unvisited:
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            tour.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            current_node = nearest_neighbor

        # Count edge occurrences
        for i in range(n - 1):
            u, v = tour[i], tour[i+1]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1
        u, v = tour[-1], tour[0]
        edge_counts[u, v] += 1
        edge_counts[v, u] += 1

    # Normalize to create heuristics matrix
    max_count = np.max(edge_counts)
    heuristics_matrix = edge_counts / max_count if max_count > 0 else edge_counts

    return heuristics_matrix
