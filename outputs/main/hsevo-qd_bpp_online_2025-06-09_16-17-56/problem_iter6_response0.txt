```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines FFD with adaptive scaling, almost full bin handling,
    a small remainder bonus, and bin diversity encouragement. Includes penalties for near misses
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    not_fit_penalty = -1e9
    almost_full_threshold = 0.9
    almost_full_boost = 0.7  # Increased boost
    small_item_threshold = 0.1 * np.max(bins_remain_cap)
    random_factor = 0.005 #Slightly reduced random factor
    near_miss_penalty = -0.5 #penalty if item almost fits

    # Adaptive scaling based on item size
    item_scale = min(1.0, item / np.max(bins_remain_cap))
    ffd_scale = 1.0 + item_scale  # Larger items get slightly more FFD importance


    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            wasted_space = cap - item
            priorities[i] = ffd_scale / (1.0 + wasted_space) # Scale FFD based on item size.
        else:
            priorities[i] = not_fit_penalty
            #Near-miss penalty
            if cap + 0.1 * np.max(bins_remain_cap) >= item:
                priorities[i] = near_miss_penalty


    is_almost_full = bins_remain_cap / np.max(bins_remain_cap) > almost_full_threshold
    for i, is_full in enumerate(is_almost_full):
        if is_full and bins_remain_cap[i] >= item:
            priorities[i] += almost_full_boost

    if item < small_item_threshold:
        for i, cap in enumerate(bins_remain_cap):
            remainder = cap - item
            if 0 < remainder < small_item_threshold:
                priorities[i] += 0.4 # increased bonus

    # Encourage diversity by favoring bins with different fill levels.
    bin_utilization = 1.0 - bins_remain_cap / np.max(bins_remain_cap)
    diversity_bonus = np.std(bin_utilization) * 0.1
    priorities += diversity_bonus

    priorities += np.random.rand(len(bins_remain_cap)) * random_factor
    return priorities
```
