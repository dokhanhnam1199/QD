```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins that can accommodate the item with minimal wasted space,
    but also considers the overall fullness of the bin to avoid overfilling certain bins too early.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Filter bins that can actually fit the item
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities  # No feasible bins, all priorities remain 0

    # Calculate wasted space if the item is placed in each bin
    wasted_space = bins_remain_cap - item

    # Prioritize bins with smaller wasted space, but only for feasible bins
    priorities[feasible_bins] = 1 / (1e-6 + wasted_space[feasible_bins]) #1e-6 avoids division by zero

    # Further prioritize bins that are relatively full
    fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize remaining capacity to [0, 1]

    priorities = priorities + 0.5*fullness # bias toward fuller bins

    # Adjust for near fit
    near_fit = (bins_remain_cap > item) & (bins_remain_cap <= (1.2 * item)) #near fit gives bonus

    priorities[near_fit] = priorities[near_fit] * 1.5
    return priorities
```
