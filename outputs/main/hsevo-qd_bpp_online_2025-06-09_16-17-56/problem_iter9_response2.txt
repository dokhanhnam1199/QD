```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """An enhanced priority function for online bin packing, combining multiple heuristics."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)

    # Heuristic 1: First Fit Decreasing (FFD) - Minimize wasted space.  Stronger than v1.
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            wasted_space = cap - item
            priorities[i] = 10.0 / (1.0 + wasted_space)  # Increased weight
        else:
            priorities[i] = -1e9

    # Heuristic 2: Fill Almost Full Bins - with dynamic threshold
    almost_full_threshold = 0.8 + 0.1 * (item / max_cap)  # Adaptive threshold
    if max_cap > 0:
        is_almost_full = bins_remain_cap / max_cap < (1 - almost_full_threshold)
    else:
        is_almost_full = np.zeros_like(bins_remain_cap, dtype=bool)
    for i, is_full in enumerate(is_almost_full):
        if is_full and bins_remain_cap[i] >= item:
            priorities[i] += 8.0  # Increased weight

    # Heuristic 3: Balanced Bins - Adaptive range based on item size
    balance_threshold_low = 0.2 + 0.1 * (item / max_cap)
    balance_threshold_high = 0.5 + 0.1 * (item / max_cap)
    if max_cap > 0:
        bin_fill_levels = (max_cap - bins_remain_cap) / max_cap
    else:
        bin_fill_levels = np.zeros_like(bins_remain_cap, dtype=float)
    is_balanced = (bin_fill_levels >= balance_threshold_low) & (bin_fill_levels <= balance_threshold_high)
    for i, is_bal in enumerate(is_balanced):
        if is_bal and bins_remain_cap[i] >= item:
            priorities[i] += 5.0

    # Heuristic 4: Small Item Preference - with cap consideration
    small_item_threshold_fraction = 0.25
    small_item_threshold = small_item_threshold_fraction * max_cap
    if item < small_item_threshold:
        for i, cap in enumerate(bins_remain_cap):
            remainder = cap - item
            if 0 < remainder < small_item_threshold:
                priorities[i] += 6.0 + 2.0 * (1 - (remainder / small_item_threshold))  # Weight based on how small remainder is

    # Heuristic 5: Large Item Handling - avoid creating almost empty bins
    large_item_threshold_fraction = 0.75
    large_item_threshold = large_item_threshold_fraction * max_cap
    if item > large_item_threshold:
        for i, cap in enumerate(bins_remain_cap):
            if cap == max_cap:  # Prefer using empty bins for large items
                priorities[i] += 4.0

    # Heuristic 6: Encourage using bins with similar fill levels to the item's relative size.
    item_relative_size = item / max_cap
    for i, cap in enumerate(bins_remain_cap):
      bin_fill_level = (max_cap - cap) / max_cap if max_cap > 0 else 0.0
      priority_boost = np.exp(-abs(bin_fill_level - item_relative_size) / 0.1)
      if bins_remain_cap[i] >= item:
          priorities[i] += priority_boost * 3.0

    # Heuristic 7: Random factor for tie-breaking, but adaptive to item size
    priorities += np.random.rand(len(bins_remain_cap)) * (0.005 + 0.005 * (item / max_cap))

    return priorities
```
