```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # 1. Feasibility: Can the item fit in the bin?
    feasible = bins_remain_cap >= item
    priorities[feasible] += 1 
    
    # 2. Remaining capacity after placement: Prefer bins that leave less space.
    remaining_after_placement = bins_remain_cap - item
    priorities[feasible] += 1 / (remaining_after_placement[feasible] + 1e-9)  # Avoid division by zero

    #3. Ratio of item size to bin capacity: Prefer bins where item fills a large proportion
    ratios = item / bins_remain_cap
    priorities[feasible] += ratios[feasible]
    
    # 4. Penalize near-full bins *before* adding the item to avoid tiny slivers left over
    near_full = (bins_remain_cap < 1.1 * item) & (bins_remain_cap >= item) #avoid excluding the bins where items fits. bins within 10% of items.
    priorities[near_full] += 0.5 # small boost but bigger than non-feasible bins.

    # set non-feasible bins priority to a negative number, ensure they are least priority
    priorities[~feasible] = -1e9
    

    return priorities
```
