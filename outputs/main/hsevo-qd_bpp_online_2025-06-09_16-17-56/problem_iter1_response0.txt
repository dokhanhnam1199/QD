```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Very large items that don't fit anywhere should have minimum negative priority.
    # If they can be placed, those locations should get a small boost
    can_fit = bins_remain_cap >= item
    if not np.any(can_fit):
      return np.full_like(bins_remain_cap, -np.inf)

    # Calculate wasted space if item is added to each bin.
    wasted_space = bins_remain_cap - item
    wasted_space[wasted_space < 0] = np.inf # Set waste to inf if item does not fit.

    # Give bins a high priority if they have minimal waste. Prefer those
    priorities = -wasted_space # Inverted, since we want *higher* values to mean high priority, *lower* means bad fit.
    priorities[wasted_space == np.inf] = -np.inf

    # Add a bonus for being close to fully packing the bins after the item is added.
    # A value closer to 0.9 means item has a higher probability of being in optimal state
    fill_ratios = (bins_remain_cap - wasted_space) / bins_remain_cap
    fill_ratios[wasted_space == np.inf] = 0  # Avoid division by zero errors

    # Prioritize if fulling ratio > 0.7 but less than 1, otherwise neutral.
    full_threshold = 0.7
    nearly_full_bonus = np.where((fill_ratios > full_threshold) & (fill_ratios <= 1.0), (fill_ratios - full_threshold) * 5, 0)

    priorities += nearly_full_bonus

    # Add a tie-breaking based on remaining capacity to encourage fitting big items early if can be done
    priorities += bins_remain_cap / np.max(bins_remain_cap) * 0.1  #Add capacity percentage to ensure no int overflow and a minimal impact

    return priorities
```
