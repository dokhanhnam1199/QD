```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines FFD-inspired, almost-full, balanced bin, small item, and large item heuristics,
    with adaptive weights and a bin-emptying incentive.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    bin_count = len(bins_remain_cap)
    bin_capacity = np.max(bins_remain_cap) # assume all bins have same max capacity.
    epsilon = 1e-9 # avoid division by zero errors

    # Heuristic 1: FFD - minimize wasted space (primary heuristic)
    wasted_space_priority = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            wasted_space = cap - item
            wasted_space_priority[i] = 1.0 / (1.0 + wasted_space)
        else:
            wasted_space_priority[i] = -1e9
    priorities += wasted_space_priority * 1.0  # High base weight


    # Heuristic 2: Fill almost full bins (aggressive filling)
    almost_full_threshold = 0.9
    is_almost_full = bins_remain_cap / (max_cap + epsilon) < (1 - almost_full_threshold)
    for i, is_full in enumerate(is_almost_full):
        if is_full and bins_remain_cap[i] >= item:
            priorities[i] += 0.75


    # Heuristic 3: Balanced bins (spreading load)
    balance_threshold_low = 0.25
    balance_threshold_high = 0.75
    bin_fill_levels = (max_cap - bins_remain_cap) / (max_cap + epsilon)
    is_balanced = (bin_fill_levels >= balance_threshold_low) & (bin_fill_levels <= balance_threshold_high)
    for i, is_bal in enumerate(is_balanced):
        if is_bal and bins_remain_cap[i] >= item:
            priorities[i] += 0.3

    # Heuristic 4: Small item prefers small remainder (packing efficiency)
    small_item_threshold_fraction = 0.2
    small_item_threshold = small_item_threshold_fraction * bin_capacity
    if item < small_item_threshold:
        for i, cap in enumerate(bins_remain_cap):
            remainder = cap - item
            if 0 < remainder < small_item_threshold:
                priorities[i] += 0.5

    # Heuristic 5: Large item handling (prevent fragmentation)
    large_item_threshold_fraction = 0.7
    large_item_threshold = large_item_threshold_fraction * bin_capacity
    if item > large_item_threshold:
        # Prefer bins with enough space to fit ONLY the item and minimal wasted space
        for i, cap in enumerate(bins_remain_cap):
            if cap >= item and cap < (item + small_item_threshold):  # Allow a little wiggle room
                priorities[i] += 0.6


    # Heuristic 6: Bin-emptying incentive (reduce bin count)
    empty_bin_bonus = 0.0
    for i, cap in enumerate(bins_remain_cap):
        if cap == item:  # If the item will completely fill the bin
            empty_bin_bonus = 0.9 #High reward to empty a bin.
            priorities[i] += empty_bin_bonus

    # Heuristic 7: Adaptive weight adjustment (based on bin fill level)
    # Reduce the weight of balanced bins when bins are already relatively full
    overall_fill_level = np.mean((max_cap - bins_remain_cap) / (max_cap + epsilon))
    if overall_fill_level > 0.6:
        for i, is_bal in enumerate(is_balanced):
            if is_bal and bins_remain_cap[i] >= item:
                priorities[i] -= 0.1  # Slightly discourage balanced bins

    # Heuristic 8: Random factor for tie-breaking (exploration)
    priorities += np.random.rand(len(bins_remain_cap)) * 0.01

    return priorities
```
