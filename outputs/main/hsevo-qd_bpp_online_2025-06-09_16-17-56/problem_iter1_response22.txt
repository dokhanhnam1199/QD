```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item with minimal wasted space
    and penalizes bins that are too full or too empty.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Create a priority array initialized to zero
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    fit_indices = np.where(bins_remain_cap >= item)[0]

    if len(fit_indices) > 0:
        # Calculate wasted space for bins that can fit the item
        wasted_space = bins_remain_cap[fit_indices] - item

        # Prioritize bins with less wasted space (using a reciprocal function)
        priorities[fit_indices] = 1.0 / (wasted_space + 0.00001) # avoid division by zero

        # Further boost priority for near-perfect fits
        near_perfect_fit_indices = fit_indices[np.where(wasted_space < 0.1)[0]]
        priorities[near_perfect_fit_indices] += 1.0 # Add a small constant

    # Penalize bins that cannot fit the item. Consider both remaining capacity
    # relative to item size and also overall emptiness.

    no_fit_indices = np.where(bins_remain_cap < item)[0]
    priorities[no_fit_indices] = - (item / (bins_remain_cap[no_fit_indices] + 0.00001)) - 0.1 # heavily penalize and avoid divide by 0

    return priorities
```
