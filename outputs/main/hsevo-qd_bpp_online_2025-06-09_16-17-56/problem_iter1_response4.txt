```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that can accommodate the item with minimal remaining capacity,
    but also incorporates a term to slightly favor bins that are already somewhat full to avoid
    creating many nearly-empty bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
      # Calculate remaining capacity AFTER placing the item (if placed).
      post_placement_remain_cap = bins_remain_cap[valid_bins] - item

      # Prioritize bins with smallest post-placement remaining capacity (First-Fit Decreasing principle)
      priorities[valid_bins] = -post_placement_remain_cap

      # Add a small bonus to bins that were already somewhat full to avoid creating a large number of almost empty bins.
      # This helps balance the bin usage.  The constant 0.1 is tunable.  It prevents oscillations.
      priorities[valid_bins] += 0.1 * (1 - bins_remain_cap[valid_bins] / np.max(bins_remain_cap)) # Use max cap to scale properly

      # Add a tiny bit of randomness to break ties and explore slightly different arrangements
      priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.001


    else:
        # If no bin can fit the item, assign a very low priority. Ideally, this situation shouldn't arise often if bin size is picked carefully.
        priorities[:] = -np.inf

    return priorities
```
