```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item.
    remaining_capacity = bins_remain_cap - item

    # Give a large negative priority to bins that cannot accommodate the item.
    priorities = np.where(remaining_capacity < 0, -np.inf, 0)

    # For bins that can accommodate the item, prioritize based on fill ratio and wasted space.
    # Prefer bins with higher fill ratios (closer to full) and smaller wasted space.

    # Fill ratio = item size / initial bin capacity. We don't have initial capacity directly.
    # Use current remaining capacity as a proxy for how much the bin has already been filled.
    # A smaller remaining capacity suggests a higher fill ratio (more filled bin).
    # And using an inverse scaling to item can help select based on fill ratio and remaining space

    valid_bins_idx = remaining_capacity >= 0

    if np.any(valid_bins_idx):

        fill_ratio_priority = -remaining_capacity[valid_bins_idx] / item # Favor smaller remaining

        waste_priority = -np.abs(remaining_capacity[valid_bins_idx]) # Penalize wasted capacity, even if slightly

        priorities[valid_bins_idx] = fill_ratio_priority + waste_priority

        #Further adjust preference for bins getting very full. Avoid leaving small slivers.
        almost_full_idx = (remaining_capacity > 0) & (remaining_capacity <= 0.1 * bins_remain_cap.max()) #within 10% of max bin

        if np.any(almost_full_idx):
            priorities[almost_full_idx] += 2 #Slight nudge to fill bins nearly full.

    return priorities
```
