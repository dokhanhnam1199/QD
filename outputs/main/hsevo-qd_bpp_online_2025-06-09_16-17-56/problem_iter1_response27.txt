```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by quantum mechanics: Consider each bin as a potential well.
    The item's "energy" is inversely proportional to the remaining capacity.
    We want to minimize the "potential energy" after placing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Avoid division by zero
    safe_bins_remain_cap = np.where(bins_remain_cap > 0, bins_remain_cap, 1e-9)

    # "Potential energy" if item is placed in the bin.
    potential_energies = (safe_bins_remain_cap - item)
    potential_energies = np.where(potential_energies > 0, potential_energies, -np.inf) # Don't choose if item doesn't fit

    # We want to *maximize* priority, so invert and shift
    min_potential = np.min(potential_energies[potential_energies != -np.inf]) # Ignore -inf when computing min

    if min_potential == np.inf:  # All are -inf, so no bin can hold item, return equal priorities for handling.
        return np.ones_like(bins_remain_cap)

    priorities =  -(potential_energies - min_potential)

    # Add a term that prefers bins that are already somewhat full.  This helps
    # reduce fragmentation.  Scaling ensures it's not the dominant term.
    priority_fragmentation_term = (1 - safe_bins_remain_cap) * 0.1 # Normalize remaining capacity

    priorities += priority_fragmentation_term

    # Encourage bins near filling, but with capacity large enough for item
    close_to_full = np.exp(-np.abs(potential_energies) / (item + 1e-9))
    priorities += close_to_full*0.5

    return priorities
```
