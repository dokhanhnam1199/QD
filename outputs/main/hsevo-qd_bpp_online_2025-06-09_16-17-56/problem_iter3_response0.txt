```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Heuristic 1: First Fit Decreasing (FFD) inspired - prefer bins with enough space, penalized by wasted space.
    # Bins that cannot fit the item get a very low priority.

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            wasted_space = cap - item
            priorities[i] = 1.0 / (1.0 + wasted_space)
        else:
            priorities[i] = -1e9

    # Heuristic 2: Address potential fragmentation by occasionally filling bins that are almost full.
    almost_full_threshold = 0.9
    is_almost_full = bins_remain_cap / np.max(bins_remain_cap) < (1 - almost_full_threshold)

    for i, is_full in enumerate(is_almost_full):
        if is_full and bins_remain_cap[i] >= item:
            priorities[i] += 0.5

    # Heuristic 3: Best Fit strategy - Prefer bins where the item fits best (smallest wasted space), but only consider "good" fits.
    # If the wasted space is too large, deprioritize that bin to avoid creating very empty bins.

    wasted_space = bins_remain_cap - item
    fit_indices = np.where(wasted_space >= 0)[0]  # Indices of bins where the item fits.

    if len(fit_indices) > 0:
        best_fit_index = fit_indices[np.argmin(wasted_space[fit_indices])]
        best_fit_wasted = wasted_space[best_fit_index]

        # Threshold on wasted space. Adjust this to control eagerness of best-fit.
        max_acceptable_wasted = 0.3 * np.max(bins_remain_cap)  # e.g., no more than 30% wasted space

        if best_fit_wasted <= max_acceptable_wasted:
             priorities[best_fit_index] += 0.75 # give priority bonus if it's actually a good fit

    # Heuristic 4: Introduce capacity-aware randomness. The emptier the bin, the higher the randomness.
    # Encourage exploring different bins, especially early on when bins are less full, by injecting randomness that scales with available capacity.
    capacity_fraction = bins_remain_cap / np.max(bins_remain_cap)
    randomness_factor = 0.05 * capacity_fraction #tuneable. Higher values cause more exploration.
    priorities += np.random.rand(len(bins_remain_cap)) * randomness_factor

    return priorities
```
