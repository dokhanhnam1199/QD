```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that are large enough to hold the item but
    penalizes bins that are much larger than the item (to avoid scattering
    items across too many bins). It also heavily penalizes bins that cannot
    contain the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First, identify bins that can hold the item. If none can, return low priority for all
    eligible_bins = bins_remain_cap >= item

    if not np.any(eligible_bins):
        return -np.inf * np.ones_like(bins_remain_cap, dtype=float)  # Give these bins lowest priority to ensure a new bin is created

    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            # Give higher priority to bins closer in size to the item
            priorities[i] = np.exp(-np.abs(bins_remain_cap[i] - 1.1*item) / item)  # Exponential decay
            #priorities[i] = 1.0 / (1.0 + np.abs(bins_remain_cap[i] - 1.1*item))  # inverse of distance
        else:
            priorities[i] = -np.inf # Very low priority if it doesn't fit.

    return priorities
```
