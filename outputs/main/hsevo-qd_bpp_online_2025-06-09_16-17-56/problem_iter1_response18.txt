```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits best (smallest waste) and
    avoids bins that are too full or too empty to efficiently accommodate the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Invalid bins get a very low priority
    invalid_bins = bins_remain_cap < item
    priorities[invalid_bins] = -np.inf

    # Calculate wasted space if item is placed in each bin
    wasted_space = bins_remain_cap - item
    wasted_space[invalid_bins] = np.inf  # Avoid assigning to invalid bins

    # Calculate how well the item fills the bin (ratio of item size to bin capacity)
    fill_ratio = item / bins_remain_cap
    fill_ratio[invalid_bins] = 0  # Avoid assigning to invalid bins


    # Give higher priority to bins with less wasted space
    priorities += -wasted_space

    # Give higher priority to bins with a good fill ratio. Gaussian-like distribution of fill ratio
    optimal_fill_ratio = 0.75 # empirically found
    fill_ratio_penalty = -((fill_ratio - optimal_fill_ratio)**2)
    priorities += fill_ratio_penalty


    # Add a small bonus to almost full bins to use them effectively.
    almost_full_threshold = 0.9 # Empirically found
    almost_full_mask = fill_ratio > almost_full_threshold
    priorities[almost_full_mask] += 1

    return priorities
```
