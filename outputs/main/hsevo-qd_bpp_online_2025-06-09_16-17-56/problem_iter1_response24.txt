```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Here, we consider the following heuristics:
    1. Largest Available Space: Prefer bins with the most remaining space. This encourages efficient space utilization.
    2. Avoidance of Small Fragments: Penalize bins where adding the item would leave a very small remaining fragment.
    3. Near-Perfect Fit: Reward bins where the item fits almost perfectly, leaving minimal wasted space.
    4. Empty Bin Preference: Prioritize empty bins (bins_remain_cap == 1) if the item's size is relatively close to the bin capacity, but not too close.
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin (assuming bin capacity = 1).

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # 1. Largest Available Space (Base Priority)
    priorities = bins_remain_cap.copy()

    # 2. Avoidance of Small Fragments (Penalize)
    fragment_size = bins_remain_cap - item
    small_fragment_penalty = np.where((fragment_size > 0) & (fragment_size < 0.1), -1, 0) #Penalize small fragments between 0 and 0.1

    priorities += small_fragment_penalty


    # 3. Near-Perfect Fit (Reward)
    near_perfect_fit_reward = np.where((fragment_size > 0) & (fragment_size <= 0.2), 0.5, 0) #Reward almost perfect fits between 0 and 0.2

    priorities += near_perfect_fit_reward
    # 4. Empty Bin Preference
    empty_bin_mask = bins_remain_cap == 1
    if np.any(empty_bin_mask):

      # Reward the empty bins if item can fit, and fits within reasonable bounds to avoid placing really tiny items in them.
      empty_bin_fit_check = (item <= 1) & (item > 0.5) # item must be smaller than bin size AND larger than 0.5 to avoid inefficiencies
      empty_bin_reward = np.where(empty_bin_mask & empty_bin_fit_check , 0.75, 0) # Significant reward to prioritize them

      priorities += empty_bin_reward


    # Handle cases where the item is larger than the remaining capacity.
    priorities = np.where(bins_remain_cap < item, -np.inf, priorities)
    #priorities = np.nan_to_num(priorities, nan=-np.inf)

    return priorities
```
