```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by gravitational force and energy considerations.
    The force of attraction (priority) is proportional to the product of the
    "masses" (item size and remaining capacity) and inversely proportional to
    the "distance" (difference between item size and remaining capacity).
    Additionally, consider the "potential energy" - the smaller the remaining
    space after placing the item, the higher the priority (lower wasted space).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero by adding a small constant.
    epsilon = 1e-9

    # Calculate force-like component: item * capacity / abs(capacity - item)
    force = (item * bins_remain_cap) / (np.abs(bins_remain_cap - item) + epsilon)

    # Calculate potential energy component: penalize bins where the item doesn't fit or waste a lot of space
    remaining_space = bins_remain_cap - item
    potential_energy = np.where(remaining_space >= 0, -remaining_space, -np.inf)  # Penalize bins where item doesn't fit

    # Combine force and potential energy to get the final priority.
    # A weighted sum could be used for fine-tuning. Here, a simple sum is used.
    priorities = force + potential_energy

    return priorities
```
