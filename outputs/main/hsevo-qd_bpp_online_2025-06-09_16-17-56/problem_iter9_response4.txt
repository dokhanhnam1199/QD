```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines FFD-inspired, almost-full, balanced bin, small item, and bin-usage heuristics with dynamic adjustments.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    num_bins = len(bins_remain_cap)

    # Heuristic 1: FFD - minimize wasted space
    wasted_space_penalty = 1.0
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            wasted_space = cap - item
            priorities[i] = wasted_space_penalty / (1.0 + wasted_space)
        else:
            priorities[i] = -1e9

    # Heuristic 2: Fill almost full bins (aggressively)
    almost_full_threshold = 0.9
    if max_cap > 0:
        is_almost_full = bins_remain_cap / max_cap < (1 - almost_full_threshold)
    else:
        is_almost_full = np.zeros_like(bins_remain_cap, dtype=bool)
    almost_full_bonus = 0.7  # Increased bonus
    for i, is_full in enumerate(is_almost_full):
        if is_full and bins_remain_cap[i] >= item:
            priorities[i] += almost_full_bonus

    # Heuristic 3: Balanced bins (stricter range)
    balance_threshold_low = 0.4
    balance_threshold_high = 0.6
    if max_cap > 0:
        bin_fill_levels = (max_cap - bins_remain_cap) / max_cap
    else:
        bin_fill_levels = np.zeros_like(bins_remain_cap, dtype=float)
    is_balanced = (bin_fill_levels >= balance_threshold_low) & (bin_fill_levels <= balance_threshold_high)
    balance_bonus = 0.4  # Adjusted bonus
    for i, is_bal in enumerate(is_balanced):
        if is_bal and bins_remain_cap[i] >= item:
            priorities[i] += balance_bonus

    # Heuristic 4: Small item prefers small remainder (more sensitive)
    small_item_threshold_fraction = 0.2
    small_item_threshold = small_item_threshold_fraction * max_cap
    small_remainder_bonus = 0.6  # Increased bonus
    if item < small_item_threshold:
        for i, cap in enumerate(bins_remain_cap):
            remainder = cap - item
            if 0 < remainder < small_item_threshold:
                priorities[i] += small_remainder_bonus

    # Heuristic 5: Bin Usage - Prefer bins that are already in use (adaptive)
    bin_usage_factor = 0.1
    used_bins = bins_remain_cap < max_cap
    for i, used in enumerate(used_bins):
        if used and bins_remain_cap[i] >= item:
            priorities[i] += bin_usage_factor

    # Heuristic 6: Large item placement strategy
    large_item_threshold_fraction = 0.7
    large_item_threshold = large_item_threshold_fraction * max_cap

    if item > large_item_threshold:
        # Prioritize empty or near-empty bins for large items to avoid fragmentation
        empty_bin_bonus = 0.8
        empty_threshold_fraction = 0.1
        empty_threshold = empty_threshold_fraction * max_cap

        for i, cap in enumerate(bins_remain_cap):
            if cap > max_cap - empty_threshold and cap >= item:
                priorities[i] += empty_bin_bonus

    # Heuristic 7: Penalize bins too small for item, but not severely
    small_penalty = -0.05
    for i, cap in enumerate(bins_remain_cap):
        if 0 < cap < item:
            priorities[i] += small_penalty

    # Heuristic 8: Random factor for tie-breaking (reduced)
    priorities += np.random.rand(len(bins_remain_cap)) * 0.005  # Reduced randomness

    return priorities
```
