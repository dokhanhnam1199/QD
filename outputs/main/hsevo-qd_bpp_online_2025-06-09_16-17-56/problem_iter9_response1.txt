```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines FFD-inspired, almost-full, balanced bin, small item, and worst-fit-inspired heuristics with dynamic weighting."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_cap = np.max(bins_remain_cap)
    bin_count = len(bins_remain_cap)

    # Heuristic 1: FFD - minimize wasted space (most important)
    wasted_space_priority = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            wasted_space = cap - item
            wasted_space_priority[i] = 1.0 / (1.0 + wasted_space)
        else:
            wasted_space_priority[i] = -1e9
    priorities += 0.6 * wasted_space_priority  # Higher weight

    # Heuristic 2: Fill almost full bins
    almost_full_threshold = 0.9
    almost_full_priority = np.zeros_like(bins_remain_cap, dtype=float)
    if max_cap > 0:  # prevent division by zero
        is_almost_full = bins_remain_cap / max_cap < (1 - almost_full_threshold)
    else:
        is_almost_full = np.zeros_like(bins_remain_cap, dtype=bool)
    for i, is_full in enumerate(is_almost_full):
        if is_full and bins_remain_cap[i] >= item:
            almost_full_priority[i] = 1.0
        else:
            almost_full_priority[i] = -1e9
    priorities += 0.2 * almost_full_priority

    # Heuristic 3: Balanced bins
    balance_threshold_low = 0.3
    balance_threshold_high = 0.6
    balanced_priority = np.zeros_like(bins_remain_cap, dtype=float)
    if max_cap > 0:  # prevent division by zero
        bin_fill_levels = (max_cap - bins_remain_cap) / max_cap
    else:
        bin_fill_levels = np.zeros_like(bins_remain_cap, dtype=float)
    is_balanced = (bin_fill_levels >= balance_threshold_low) & (bin_fill_levels <= balance_threshold_high)
    for i, is_bal in enumerate(is_balanced):
        if is_bal and bins_remain_cap[i] >= item:
            balanced_priority[i] = 1.0
        else:
             balanced_priority[i] = -1e9
    priorities += 0.1 * balanced_priority

    # Heuristic 4: Small item prefers small remainder
    small_item_threshold_fraction = 0.2
    small_item_threshold = small_item_threshold_fraction * max_cap
    small_item_priority = np.zeros_like(bins_remain_cap, dtype=float)
    if item < small_item_threshold:
        for i, cap in enumerate(bins_remain_cap):
            remainder = cap - item
            if 0 < remainder < small_item_threshold:
                small_item_priority[i] = 1.0
            else:
                small_item_priority[i] = -1e9
    priorities += 0.1 * small_item_priority

    # Heuristic 5: Worst Fit adjustment - Avoid bins that are *too* big relative to the item.
    worst_fit_penalty = np.zeros_like(bins_remain_cap, dtype=float)
    oversize_threshold = 2.0  # Bin must not be more than twice as big as item.
    for i, cap in enumerate(bins_remain_cap):
        if item > 0 and cap > oversize_threshold * item:
            worst_fit_penalty[i] = -0.05  # Small penalty, not disqualifying

    priorities += worst_fit_penalty

    # Heuristic 6: Open New Bin if no suitable bin exists.
    no_fit_threshold = 0.001
    if np.max(priorities) < -1e8 + no_fit_threshold and bin_count < 100: # limit new bins to avoid infinite loop
        priorities = np.zeros_like(bins_remain_cap, dtype=float)
        priorities = priorities + 0.0001 # open a new bin

    # Heuristic 7: Random factor for tie-breaking
    priorities += np.random.rand(len(bins_remain_cap)) * 0.001

    return priorities
```
