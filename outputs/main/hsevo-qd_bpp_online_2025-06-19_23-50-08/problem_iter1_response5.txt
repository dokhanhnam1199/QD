```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function incorporates several factors to balance fitting items well and avoiding excessive fragmentation:

    1.  Feasibility:  Prioritizes bins that can actually fit the item (essential).
    2.  Remaining Capacity Utilization:  Favors bins where the item fills a significant portion of the remaining space, but also avoids bins that are almost exactly full (to reduce wasted space from tiny gaps).  Uses a ratio between item size and remaining capacity.
    3.  Penalty for Near-Full Bins: Applies a penalty to bins where the remaining capacity is only slightly larger than the item. This encourages using emptier bins when available, even if other bins *could* fit the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Prioritize feasible bins (those with enough remaining capacity)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities  # All bins are full enough such that the item can't fit, no priorities.

    # Calculate the utilization ratio (item size / remaining capacity)
    utilization_ratios = np.where(feasible_bins, item / bins_remain_cap, 0)

    # Apply the priority score to feasible bins
    priorities[feasible_bins] = utilization_ratios[feasible_bins]

    # Apply a penalty for bins that are almost full, encouraging more even spread
    near_full_threshold = 1.1  # A factor to determine how close is considered near-full (e.g. remaining capacity is only 10% larger than the item)

    near_full_bins = feasible_bins & (bins_remain_cap < item * near_full_threshold)

    priorities[near_full_bins] *= 0.5  # Reduce priority for near-full bins

    # Add a small bonus for filling bins to close to 1, but not exactly 1
    fullness_score = np.where(feasible_bins & (utilization_ratios < 1.0), (1 - utilization_ratios[feasible_bins]), 0)
    priorities[feasible_bins] += fullness_score # encourage good fills

    return priorities
```
