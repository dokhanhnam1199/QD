```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on fill ratio, waste, remaining capacity, and bin utilization."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit = item <= bins_remain_cap
    waste = bins_remain_cap - item

    priorities[~fit] = -np.inf  # Infeasible bin

    # Fill ratio - primary objective
    fill_ratio = item / bins_remain_cap
    priorities[fit] += fill_ratio[fit]

    # Waste penalty - avoid excessive waste
    priorities[fit] -= np.exp(waste[fit] / (item + 1e-6))  # Scale waste by item size

    # Encourage bin utilization - reward bins that are already somewhat full
    bin_utilization = 1 - (bins_remain_cap / bins_remain_cap.max()) # normalized remaining capacity (0 is full)
    priorities[fit] += np.exp(-bin_utilization[fit] * 5)

    # Bonus for tight fit - find bins where remaining capacity is close to zero.
    priorities[fit] += np.exp(-waste[fit]**2 / (item**2 + 1e-6)) # Penalty if waste is large relative to item

    # Further exploration: prioritize bins that would be completely filled
    nearly_full = np.abs(waste) < 1e-6  # or some small tolerance based on the problem
    priorities[nearly_full & fit] += 5  # large bonus for nearly full bins

    return priorities
```
