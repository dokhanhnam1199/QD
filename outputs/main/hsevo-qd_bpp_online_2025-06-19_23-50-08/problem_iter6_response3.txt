```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on a multi-objective approach,
    considering fill ratio, waste, remaining capacity relative to item size,
    and a penalty for bins that are already significantly full.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit = item <= bins_remain_cap
    waste = bins_remain_cap - item

    priorities[~fit] = -np.inf  # Infeasible bin: hard constraint

    if np.any(fit):
        # Fill ratio: encourages efficient space utilization
        priorities[fit] += (item / bins_remain_cap[fit])

        # Waste penalty: discourages leaving excessive empty space
        priorities[fit] += np.exp(-waste[fit] * 0.75)  # Increased penalty

        # Reward for remaining capacity close to item size
        priorities[fit] += np.exp(-np.abs(waste[fit]) * 0.3)

        # Penalty for almost full bins (risk of future fragmentation)
        fullness = 1 - bins_remain_cap[fit]  # Fraction of bin that is full
        priorities[fit] -= (fullness ** 3) * 0.5 # Cubically increasing penalty


        # Adjust based on the number of available bins
        num_available_bins = np.sum(fit)
        if num_available_bins > 0:
            priorities[fit] /= np.sqrt(num_available_bins)  # Dampen priorities if many options exist

    return priorities
```
