```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have enough capacity but also tries
    to minimize wasted space. It also penalizes bins that don't have enough space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Assign a large negative priority if the bin doesn't have enough capacity
    no_fit_mask = bins_remain_cap < item
    priorities[no_fit_mask] = -np.inf

    # For bins that have enough capacity, calculate a score based on
    # how well the item fits.  We want to reward bins that are relatively full
    # after the item is added, but not so full that they are likely to
    # be unusable later.  We use a logistic function to smoothly transition
    # between rewarding and penalizing fullness.
    fit_mask = ~no_fit_mask
    remaining_after_fit = bins_remain_cap[fit_mask] - item

    # Scale remaining capacity to range [0, 1] using sigmoid
    scaled_remaining = 1 / (1 + np.exp(-5 * (remaining_after_fit / bins_remain_cap[fit_mask] - 0.5)))
    # Alternatively: use ratio of item size to remaining cap *if item fits*

    priorities[fit_mask] = scaled_remaining #np.exp(-remaining_after_fit / item)

    return priorities
```
