```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins considering fill rate, waste, and future fit potential."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    fit = item <= bins_remain_cap
    waste = bins_remain_cap - item

    priorities[~fit] = -np.inf  # Impossible to fit

    if not np.any(fit):
        return priorities

    # Fill ratio - encourages denser packing
    priorities[fit] = item / bins_remain_cap[fit]

    # Waste penalty - discourages large waste
    priorities[fit] -= np.exp(waste[fit] * 5)  # Penalize waste, higher penalty

    # Reward for bins with remaining capacity close to common item sizes to promote future fit
    # Use a more robust estimate of typical item size.
    typical_item_size = np.median(item)  # Median is less sensitive to outliers
    remaining_after_fit = bins_remain_cap[fit] - item
    priorities[fit] += np.exp(-np.abs(remaining_after_fit - typical_item_size) * 3)  # Increased sensitivity

    # Bonus for bins that are relatively empty (prioritize near empty bins to consolidate space)
    priorities[fit] += np.exp(-bins_remain_cap[fit] / np.mean(bins_remain_cap)) * 0.5 #Relatively empty

    # Slightly prioritize bins where remaining capacity is close to other item sizes in 'item'
    # This encourages creating bins that can accommodate similar-sized items.
    #NOTE: Assumes 'item' is a scalar representing one incoming item. It needs to be adjusted for batches

    return priorities
```
