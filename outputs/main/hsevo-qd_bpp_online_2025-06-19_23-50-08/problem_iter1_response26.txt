```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates several heuristics inspired by black hole physics
    and packing strategies.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Eliminate bins that cannot fit the item. This is the event horizon - nothing escapes if it doesn't fit.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf  # Mark infeasible bins with the lowest priority

    # 2. Remaining Capacity Influence (Gravitational Pull):  Bins with a capacity close to the item's size get a higher priority. A black hole's pull is stronger closer to its event horizon.
    #    Use a gaussian-like function centered around the item size.
    #    Scale the difference by bin_remain_cap to emphasize the 'pull'.
    #   This encourages filling bins efficiently, similar to first-fit decreasing or best-fit strategies.

    feasible_bins = ~infeasible_bins
    capacity_diff = bins_remain_cap[feasible_bins] - item
    gaussian_influence = np.exp(-capacity_diff**2 / (2 * (np.mean(bins_remain_cap) / 4)**2)) # Spread adjusts how sensitive we are. Division by 4 chosen empirically for reasonable performance.  Smaller value make this more sensitive to tight fits.
    priorities[feasible_bins] += gaussian_influence

    # 3.  Bin Utilization Factor (Accretion Disk Analogy): Encourage filling bins more fully rather than scattering items across bins. The closer to 1 (full), the higher the score.

    bin_utilization = (bins_remain_cap - item) / np.max(bins_remain_cap) if np.any(bins_remain_cap>0) else np.zeros_like(bins_remain_cap)  #Avoid divide by zero
    bin_utilization[infeasible_bins] = 0 #Reset to 0 for infeasible bins

    priorities[feasible_bins] += (1-bin_utilization[feasible_bins]) # Higher utilization gets higher score.

    # 4. Avoid fragmentation, add a small penalty for bins that are already fairly empty. This reduces long term waste (like hawking radiation minimizing over time).

    empty_ish = bins_remain_cap > (np.max(bins_remain_cap)*0.75) if np.any(bins_remain_cap>0) else np.zeros_like(bins_remain_cap, dtype=bool)  # If > 75% empty, consider relatively empty.
    priorities[empty_ish] -= 0.1 #Small penalty for empty bins (adjust value as needed)


    return priorities
```
