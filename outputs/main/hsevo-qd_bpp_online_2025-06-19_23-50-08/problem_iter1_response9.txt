```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits comfortably but doesn't waste too much space.
    It uses a combination of remaining capacity and how well the item "fills" the bin.
    Bins that are too small get a very low priority (negative infinity).
    Bins that are a good fit get a high priority, scaled by a "fullness" factor.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if item > cap:
            priorities[i] = -np.inf  # Impossible to fit
        else:
            # Fullness: How much of the bin will be used after adding the item
            fullness = item / cap

            # Priority: Combination of remaining capacity and fullness.  Add a small term
            #  to handle the case where item=cap=0 (which would result in nan).
            #  Smaller remaining capacity (when the item still fits!) is slightly preferred.
            priorities[i] = (1 - fullness) + (fullness * (1/(cap + 1e-9)) )  # Try remaining cap
            # priorities[i] = (1-fullness) + (np.log(1 + cap) + (np.exp(fullness)))   #Try remaining capacity + fullness



    return priorities
```
