```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal remaining capacity,
    avoiding excessive fragmentation. If no bin can fit the item, it prioritizes bins with the
    largest remaining capacity.  A small constant is added to prevent division by zero.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9  # Small constant to prevent division by zero and log of zero
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
        # Prioritize bins with smallest remaining capacity after placing item
        remaining_capacity_after_placement = bins_remain_cap[valid_bins] - item + epsilon  # Add epsilon
        priorities[valid_bins] = -remaining_capacity_after_placement  # Lower remaining, higher priority
        
        # Apply a sigmoid function to further prioritize bins close to full
        priorities[valid_bins] = 1 / (1 + np.exp(5 * remaining_capacity_after_placement)) # Sigmoid function

        # Add a bonus for near-perfect fit
        near_perfect_fit = np.abs(bins_remain_cap[valid_bins] - item) < 0.1  # Adjust threshold as needed
        priorities[valid_bins][near_perfect_fit] += 0.5  # Give extra priority boost for nearly perfect fit

    else:
        # If no bin can fit, prioritize bins with largest remaining capacity
        priorities = bins_remain_cap  # Larger remaining, higher priority

        # Apply a logarithm to slightly diminish the importance of very large empty bins
        priorities = np.log(priorities + epsilon) # Log scale
        
    return priorities
```
