```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Employing a heuristic based on the 'gravitational' attraction
    between the item and the available space in each bin.
    A larger remaining capacity offers a stronger attraction,
    but this attraction weakens non-linearly as the remaining capacity
    approaches the item's size (to avoid near-full bins for small items).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Avoid division by zero; penalize bins that cannot hold the item.
    valid_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(valid_bins):
        # Calculate "gravitational" attraction; higher capacity = higher attraction.
        # However, attraction plateaus as remaining space gets close to item size.
        # This is achieved using a logarithmic transformation. Also, add small number in denominator to prevent division by 0
        priorities[valid_bins] = np.log(bins_remain_cap[valid_bins] / (item+1e-6))

        # Additional heuristic:  Favor bins closer to full *after* adding the item, but not overly so.
        # The aim is to fill bins moderately efficiently, without creating many almost-full bins.
        remaining_space_after_add = bins_remain_cap[valid_bins] - item
        near_fullness_bonus = np.exp(-0.5 * (remaining_space_after_add**2)) # Gaussian-like bonus. Adjust std dev(0.5) as needed.
        priorities[valid_bins] += near_fullness_bonus

    # Highly penalize bins that cannot fit the item, ensuring they're a last resort.
    priorities[~valid_bins] = -np.inf  # Or some extremely negative value.

    return priorities
```
