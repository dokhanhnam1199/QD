```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the principles of resonance and minimizing wasted energy,
    this priority function considers both the fit of the item and the overall
    fill level of the bin. Bins closer to being filled resonate more strongly,
    attracting the item, while a perfect fit offers maximum resonance.
    It avoids using bins that cannot contain the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Filter out bins that are too small
    eligible_bins = bins_remain_cap >= item

    if not np.any(eligible_bins):
        return priorities # All bins too small, return zero priorities

    # Calculate fit score: proximity to perfect fit (higher is better)
    fit_score = np.zeros_like(bins_remain_cap, dtype=float)
    fit_score[eligible_bins] = np.exp(-np.abs(bins_remain_cap[eligible_bins] - item))

    # Calculate fill score: how full the bin would be (higher is better)
    fill_score = np.zeros_like(bins_remain_cap, dtype=float)
    fill_score[eligible_bins] = 1 - (bins_remain_cap[eligible_bins] - item) / np.max(bins_remain_cap) # Normalize by maximum capacity
    fill_score[fill_score < 0] = 0 #Handles cases where a bin is almost exactly filled to capacity.

    # Combine scores: emphasize perfect fit, but still favor higher fill
    priorities[eligible_bins] = (fit_score[eligible_bins] * 0.8) + (fill_score[eligible_bins] * 0.2)


    return priorities
```
