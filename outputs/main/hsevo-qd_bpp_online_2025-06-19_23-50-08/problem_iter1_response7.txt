```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Incorporates a "quantum" tunneling idea - sometimes we want to
    try less obvious bins to escape local minima.  Also, favors bins that
    are a good fit but avoids near-full bins unless they are a *really*
    good fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_cap in enumerate(bins_remain_cap):
        if remaining_cap >= item:
            # Good fit:  Higher priority if the item fills a good chunk of the bin
            fill_ratio = item / remaining_cap
            
            # Base priority:  How much of the bin does it fill?
            priorities[i] = fill_ratio

            # Bonus if it's close to full *after* packing, but not too close (avoiding almost-full bins initially)
            post_fill_ratio = item / remaining_cap
            if post_fill_ratio > 0.5 and post_fill_ratio < 0.999:  #tune thresholds?
                priorities[i] += 0.5 * (1 - abs(0.75 - post_fill_ratio))  # Peaked near 75% full
                #This addition gives higher score if bins are not so close to be filled up fully after addition.

            # "Tunneling" - a small chance to try bins that are not the best fit initially.  Adds some randomness
            priorities[i] += np.random.normal(0, 0.05) # Small noise
            
            # Penalize for bins that have high remaining capacity compared to item
            capacity_utilization = item / bins_remain_cap[i]
            if capacity_utilization < 0.1: #Penalizing bins whose items fill less than 10% capacity of the bins.
                priorities[i] -= 0.2 * (0.1 - capacity_utilization) #Penalty increases the less of the capacity is being filled up.
        else:
            # Cannot fit, very low priority (or negative, to ensure it's not chosen)
            priorities[i] = -1e9  # A very negative number

    return priorities
```
