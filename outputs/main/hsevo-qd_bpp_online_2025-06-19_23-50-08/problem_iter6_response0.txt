```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on fill ratio, waste, remaining capacity, and bin diversity."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit = item <= bins_remain_cap
    waste = bins_remain_cap - item

    priorities[~fit] = -np.inf  # Hard constraint: Infeasible bin gets negative infinity

    # Primary Objective: Maximize Fill Ratio
    fill_ratio = item / bins_remain_cap[fit]
    priorities[fit] += fill_ratio

    # Secondary Objective: Minimize Waste (with diminishing returns)
    priorities[fit] -= np.exp(waste[fit] * 0.3)  # Exponential penalty for larger waste

    # Tertiary Objective: Encourage Balanced Bin Utilization (bin diversity): Small Bonus for bins with cap near mean remaining capacity
    mean_remaining_capacity = np.mean(bins_remain_cap)
    capacity_difference = np.abs(bins_remain_cap[fit] - mean_remaining_capacity)
    priorities[fit] += np.exp(-capacity_difference * 0.1) # Small bonus for being close to mean

    # Reward Shaping: Soft constraint to discourage tiny remaining capacity
    tiny_waste_penalty = np.where(waste[fit] < (0.1 * np.mean(item)), -0.2, 0)  # Significant penalty for tiny waste compared to the avg item
    priorities[fit] += tiny_waste_penalty

    # Exploration Bonus: Encourage trying bins that are relatively empty
    priorities[fit] += bins_remain_cap[fit] / np.max(bins_remain_cap) * 0.05 # scale to make small
    return priorities
```
