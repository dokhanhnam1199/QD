```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on fill ratio, waste, remaining capacity,
    and a dynamic adjustment based on bin utilization.

    This version aims for better balancing of bin usage by incorporating
    a penalty for bins that are already highly utilized and a bonus for
    bins that are relatively empty but can still accommodate the item.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit = item <= bins_remain_cap
    waste = bins_remain_cap - item

    priorities[~fit] = -np.inf  # Infeasible bin

    # Fill ratio + waste penalty
    priorities[fit] = (item / bins_remain_cap[fit]) + np.exp(-waste[fit] * 0.5)

    # Bonus for remaining capacity near item size
    avg_item_size = np.mean(item)
    remaining_after_fit = bins_remain_cap[fit] - item
    priorities[fit] += np.exp(-np.abs(remaining_after_fit - avg_item_size) * 0.2)

    # Dynamic adjustment based on bin utilization
    total_capacity = 1.0  # Assuming bins have unit capacity. Adjust if different
    bin_utilization = (total_capacity - bins_remain_cap) / total_capacity

    # Penalty for highly utilized bins (discourages overfilling a nearly full bin)
    priorities[fit] -= bin_utilization[fit] * 0.3 # Tune this parameter (0.3)

    # Bonus for relatively empty bins that fit the item
    # (encourages starting new bins when appropriate)
    empty_bin_threshold = 0.2  # Tune this parameter
    priorities[fit] += (bins_remain_cap[fit] > empty_bin_threshold) * 0.1 # Tune this parameter

    return priorities
```
