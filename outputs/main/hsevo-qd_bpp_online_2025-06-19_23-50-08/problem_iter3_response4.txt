```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins considering fill rate, waste, and potential future fit."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = bins_remain_cap[0] + item #infer bin capacity, assume all bin capacity are same
    fit = item <= bins_remain_cap
    waste = bins_remain_cap - item

    priorities[~fit] = -np.inf  # Impossible to fit

    if np.any(fit):
        # Fill ratio: Favor bins that provide a good fill
        priorities[fit] += (item / bin_capacity)

        # Waste penalty: Penalize bins that leave too much or too little space
        priorities[fit] -= np.abs(waste[fit] - item/2) / bin_capacity # try to leave space around half of item size, this is crucial!

        # Bonus for bins that have a remaining capacity suitable for common item sizes
        # Introduce a decay factor based on the remaining capacity
        decay_factor = np.exp(-waste[fit] / (bin_capacity/4))
        priorities[fit] += decay_factor * (item/bin_capacity)

        # A small bonus for using almost all capacity in the bin
        priorities[fit] += (1 - (waste[fit] / bin_capacity))**2

    return priorities
```
