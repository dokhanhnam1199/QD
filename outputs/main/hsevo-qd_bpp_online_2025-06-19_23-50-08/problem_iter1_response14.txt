```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Tesla's Electrical Resonance Prioritization:
    # Favor bins where the item size closely "resonates" with the remaining capacity.
    # Specifically, we want the remaining capacity to be slightly larger than the item.

    # Initialize priorities to a low value for bins that can't hold the item
    priorities = np.zeros_like(bins_remain_cap, dtype=float) - np.inf  # very low score

    # Bins that can hold the item get a positive priority
    eligible_bins = bins_remain_cap >= item
    if not np.any(eligible_bins):
        return priorities  # Return the low-priority array if no bins fit

    priorities[eligible_bins] = 0.0

    # Calculate the "resonance" score (higher is better):
    # A balance between fullness and slack space. Avoids too full or too empty bins.
    # Use a Gaussian-like distribution centered around the item's size
    # divided by a small margin.  A smaller margin enforces a more strict condition.

    margin = 0.1  # Tune this to change the strictness of the matching. Smaller values are more strict
    difference = bins_remain_cap[eligible_bins] - item
    resonance = np.exp(-(difference**2) / (2 * (item*margin)**2)) #Gaussian with item*margin standard deviation
    priorities[eligible_bins] = resonance

    # Emphasize bins that are closer to full but can still fit the item without too much space to prevent waste
    #This rewards using nearly full bins
    fullness_score = (item / bins_remain_cap[eligible_bins])
    priorities[eligible_bins] = priorities[eligible_bins] * (1 + fullness_score*0.5)

    # Introduce small random noise to break ties and explore the space
    noise = np.random.normal(0, 0.001, size=priorities.shape)  # Very small noise
    priorities = priorities + noise

    return priorities
```
