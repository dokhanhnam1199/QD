[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Initialize priority scores with a very low value for bins that can't fit the item\n    priorities = np.where(remaining_after_addition >= 0, remaining_after_addition, -1e9)\n    \n    # Give higher priority to bins that have a remaining capacity closest to the item size\n    # This is achieved by giving a bonus to bins where the remaining capacity after addition is closest to zero\n    bonus = np.exp(-np.abs(remaining_after_addition))\n    \n    # Combine the priorities and the bonus\n    priorities = priorities + bonus\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remain_cap_after_add >= 0, remain_cap_after_add, -1e9)\n    \n    # For bins that can hold the item, prioritize the one with the least remaining capacity\n    priorities = np.where(remain_cap_after_add >= 0, -remain_cap_after_add / bins_remain_cap, priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # For bins that can fit the item, higher remaining capacity after addition gets lower priority\n    # For bins that cannot fit the item, lower remaining capacity gets higher priority (to avoid them)\n    priorities = np.where(can_fit, -remaining_after_addition, 1 / (1 + bins_remain_cap))\n    \n    # Normalize the priorities to avoid extreme values\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-8)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can't fit the item get a priority of -inf\n    priorities = np.where(remaining_after_addition >= 0, \n                          # Prioritize bins with less remaining capacity after addition\n                          -np.abs(remaining_after_addition - np.mean(remaining_after_addition[remaining_after_addition >= 0])), \n                          -np.inf)\n    return priorities",
    "response_id": 3,
    "obj": 60.62026326286399,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid assigning the same priority to all bins that can fit the item, \n    # we further differentiate them by considering the number of items they have held so far\n    # Here, we assume that the index of the bin represents the number of items it has held\n    # (i.e., older bins have lower indices)\n    priorities += np.where(can_fit, -bins_remain_cap.size + np.arange(bins_remain_cap.size), 0) * 1e-6\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that can't fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on how full they will be\n    priorities[valid_bins_mask] = remaining_after_addition[valid_bins_mask] / bins_remain_cap[valid_bins_mask]\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_capacities = bins_remain_cap - item\n    \n    # Bins that can accommodate the item should have higher priority\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate the priority score for valid bins based on the remaining capacity\n    # Bins with less remaining capacity after placing the item should have higher priority\n    priorities = np.where(valid_bins, -remaining_capacities, -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # No valid bins\n        priorities = np.zeros_like(priorities)\n    else:\n        priorities = priorities - max_priority\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can fit the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # Prioritize bins that have enough capacity and have the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(valid_bins_mask, -remaining_after_addition, -np.inf)\n    \n    # To avoid identical priorities for multiple bins, break ties by considering the original bin capacity\n    priorities += np.where(valid_bins_mask, bins_remain_cap * 1e-6, 0)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, prioritize those with the least remaining capacity after addition\n    can_fit = remaining_after_addition >= 0\n    priorities = np.where(can_fit, -remaining_after_addition, -np.inf)\n    \n    # Add a small noise to break ties and ensure randomness for bins with the same remaining capacity\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with a low value for bins that cannot fit the item\n    priorities = np.where(valid_bins_mask, remaining_after_addition, -np.inf)\n    \n    # To encourage using bins that are almost full, add a bonus to the priority\n    # based on how full the bin is after adding the item\n    bin_fullness_ratio = (bins_remain_cap - remaining_after_addition) / bins_remain_cap\n    priorities += np.where(valid_bins_mask, bin_fullness_ratio, 0)\n    \n    return priorities",
    "response_id": 10,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remain_cap_after_add >= 0\n    \n    # Initialize priorities with negative infinity for bins that cannot hold the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can hold the item, calculate priority based on remaining capacity\n    priorities[valid_bins_mask] = remain_cap_after_add[valid_bins_mask] / bins_remain_cap[valid_bins_mask]\n    \n    return priorities",
    "response_id": 11,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is based on the remaining capacity of the bin after adding the item.\n    Bins that will be filled to a high level (but not overflowed) are given higher priority.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that are too small for the item should have very low priority\n    priorities = np.where(remaining_after_addition < 0, -np.inf, bins_remain_cap - remaining_after_addition)\n    \n    # Normalize the priorities to be between 0 and 1\n    max_priority = np.max(bins_remain_cap)\n    priorities = priorities / max_priority\n    \n    return priorities",
    "response_id": 12,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can fit the item, prioritize those with less remaining capacity\n                          # to minimize waste and encourage packing more items into the same bin\n                          -np.abs(remaining_after_addition - item / 2), \n                          # For bins that cannot fit the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 13,
    "obj": 9.254088552054245,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Initialize priorities array with a default low priority for bins that cannot hold the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_remaining_capacity = np.min(remaining_capacities[valid_bins])\n        max_remaining_capacity = np.max(remaining_capacities[valid_bins])\n        if max_remaining_capacity != min_remaining_capacity:\n            priorities[valid_bins] = (remaining_capacities[valid_bins] - min_remaining_capacity) / (max_remaining_capacity - min_remaining_capacity)\n        else:\n            priorities[valid_bins] = 1.0\n    \n    return priorities",
    "response_id": 14,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition < 0, -np.inf, remaining_after_addition / bins_remain_cap)\n    \n    # Give higher priority to bins with more remaining capacity after addition relative to their original remaining capacity\n    priorities = np.where(remaining_after_addition == bins_remain_cap, 0, priorities)\n    \n    # Encourage packing items tightly by giving higher priority to bins with less remaining capacity\n    # But this is already achieved by the previous line, so we don't need to do anything extra\n    \n    return priorities",
    "response_id": 15,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot fit the item get a priority of -inf\n    priorities = np.where(remaining_after_addition >= 0, \n                          -np.abs(remaining_after_addition), \n                          -np.inf)\n    \n    # Normalize the priorities to avoid extremely large or small values\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  # Check if at least one bin can fit the item\n        priorities = np.where(priorities != -np.inf, priorities - max_priority, priorities)\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can fit the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on remaining capacity and item size ratio\n    priorities[valid_bins] = np.log(remaining_after_addition[valid_bins] + 1) / np.log(bins_remain_cap[valid_bins] + 1)\n    \n    # Give a bonus to the bin with the least remaining capacity that can still fit the item\n    if np.any(valid_bins):\n        min_remaining_idx = np.argmin(bins_remain_cap[valid_bins])\n        min_remaining_idx_global = np.where(valid_bins)[0][min_remaining_idx]\n        priorities[min_remaining_idx_global] += 1\n    \n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remain_cap_after_add >= 0, -remain_cap_after_add, -np.inf)\n    \n    # Normalize the priorities for bins that can hold the item\n    priorities = np.where(remain_cap_after_add >= 0, priorities / np.max(np.abs(priorities[remain_cap_after_add >= 0])), priorities)\n    \n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can fit the item\n    can_fit_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that can't fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on remaining capacity\n    priorities[can_fit_mask] = remaining_after_addition[can_fit_mask] / bins_remain_cap[can_fit_mask]\n    \n    # Add a small random noise to break ties\n    priorities[can_fit_mask] += np.random.uniform(0, 1e-6, size=np.sum(can_fit_mask))\n    \n    return priorities",
    "response_id": 19,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n5\n1\n50.718800023077\n77.08183317750407\n81\n"
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # For bins with enough capacity, the priority is the remaining capacity after addition\n    # This encourages packing items tightly\n    priorities = np.where(valid_bins, remaining_after_addition, -np.inf)\n    \n    # To differentiate between bins with the same remaining capacity after addition,\n    # we use the original remaining capacity as a secondary priority\n    priorities += np.where(valid_bins, bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    return priorities",
    "response_id": 20,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize based on remaining capacity\n                          -np.abs(remaining_after_addition - item / 2), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 21,
    "obj": 9.254088552054245,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, the priority is inversely proportional to the remaining capacity after addition\n    # This encourages packing items tightly\n    priorities = np.where(valid_bins, 1 / (1 + remaining_after_addition), -np.inf)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 0\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    priorities = np.where(valid_bins, (priorities - min_priority) / (max_priority - min_priority + 1e-8), -np.inf)\n    \n    return priorities",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # To further differentiate bins that can fit the item, we use a combination of \n    # the remaining capacity and the absolute difference between the remaining capacity and the item size\n    priorities = np.where(remaining_capacities >= 0, priorities + remaining_capacities / (1 + np.abs(remaining_capacities - item)), priorities)\n    \n    return priorities",
    "response_id": 23,
    "obj": 3.9589150378939015,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize the one with the least remaining capacity\n                          -remaining_after_addition / bins_remain_cap, \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remain_cap_after_add >= 0, remain_cap_after_add, -1e9)\n    \n    # Among the bins that can hold the item, prioritize the one with the least remaining capacity\n    # This is a \"First-Fit Decreasing\" like strategy, adapted for online bin packing\n    return priorities",
    "response_id": 25,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity\n                          -remaining_after_addition / bins_remain_cap, \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity after addition\n                          -np.abs(remaining_after_addition), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # If no bin can accommodate the item\n        return np.zeros_like(priorities)  # Return equal priorities for all bins\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(valid_bins, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid identical priorities for different bins, add a small noise\n    priorities += np.random.normal(scale=1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e10)\n    \n    # Give higher priority to bins that have a remaining capacity closest to 0 (i.e., most full)\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), priorities)\n    \n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.718800023077,
    "mi": 77.08183317750407,
    "token_count": 81.0,
    "exec_success": true
  }
]