[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacities: The capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Feature 1: Whether the bin can fit the item\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Feature 2: Remaining capacity after adding the item (normalized by bin capacity)\n    remaining_capacities = np.maximum(bins_remain_cap - item, 0) / bin_capacities\n    \n    # Feature 3: Fullness of the bin before adding the item (normalized)\n    bin_fullness = 1 - (bins_remain_cap / bin_capacities)\n    \n    # Feature 4: Absolute difference between the remaining capacity and the item size (normalized by remaining capacity)\n    diff = 1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + 1e-6)\n    diff = np.where(bins_remain_cap == 0, 0, diff)  # Handle division by zero\n    \n    # Combine features into a priority score with weights\n    priorities = can_fit * (0.3 * remaining_capacities + 0.3 * bin_fullness + 0.4 * diff)\n    \n    # Add controlled noise for exploration\n    noise = np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    priorities += noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.068607897885915,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 0.1, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise to be added for exploration.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set the random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Normalize priorities for valid bins to be within a comparable range\n    valid_bins = relative_remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = priorities[valid_bins].min(), priorities[valid_bins].max()\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    # Add controlled noise to priorities for exploration\n    noise = np.random.uniform(-noise_scale, noise_scale, size=len(bins_remain_cap))\n    noisy_priorities = priorities + noise\n    \n    # Clip noisy priorities to ensure they are within a reasonable range\n    noisy_priorities = np.clip(noisy_priorities, -1e6, 1)\n    \n    return noisy_priorities",
    "response_id": 1,
    "obj": 119.51535700039891,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -1e6)\n    \n    # Normalize the priorities for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + 1e-8)\n        # Add a small noise for exploration\n        priorities[valid_bins] += np.random.normal(0, 0.01, np.sum(valid_bins))\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.11846828879138,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The total capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, \n                          -np.abs(bins_remain_cap - item) / bin_capacity + remaining_capacities / bin_capacity, \n                          -1e6)\n    \n    # Normalize the priorities to be between 0 and 1 for bins that can fit the item\n    valid_bins = priorities != -1e6\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n138.3016990363956\n85.30591324653895\n154\n"
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: Array of total capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, \n                          # Use a combination of the remaining capacity and the \n                          # absolute difference between the remaining capacity and the item size\n                          -0.4 * np.abs(remaining_capacities - item / 2) / bin_capacities + \n                          0.3 * remaining_capacities / (1 + item) + \n                          0.3 * (1 - remaining_capacities / bin_capacities), \n                          -1e6)\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n11\n3\n138.3016990363956\n85.30591324653895\n154\n"
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Small value to avoid division by zero and control noise level.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    remaining_capacities = bins_remain_cap - item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        \n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n            noise = np.random.uniform(-0.05, 0.05, size=len(valid_priorities))\n            noisy_normalized_priorities = np.clip(normalized_priorities + noise, 0, 1)\n            priorities[valid_bins] = noisy_normalized_priorities\n        else:\n            priorities[valid_bins] = 1.0\n    \n    return priorities",
    "response_id": 5,
    "obj": 149.1224571200638,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    remaining_capacities = bins_remain_cap - item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    valid_indices = remaining_capacities >= 0\n    valid_priorities = priorities[valid_indices]\n    \n    if len(valid_priorities) > 0:\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        \n        if max_priority == min_priority:\n            normalized_priorities = np.ones_like(valid_priorities)\n        else:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n            noise = np.random.uniform(-0.05, 0.05, size=len(valid_priorities))\n            noisy_normalized_priorities = np.clip(normalized_priorities + noise, 0, 1)\n            priorities[valid_indices] = noisy_normalized_priorities\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.10251296370166,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Feature 1: Whether the bin can fit the item\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Feature 2: Normalized remaining capacity after adding the item\n    remaining_capacities = np.maximum(bins_remain_cap - item, 0) / bin_capacities\n    \n    # Feature 3: Normalized absolute difference between the remaining capacity and the item size\n    diff = 1 - np.abs(bins_remain_cap - item / 2) / (bin_capacities / 2)\n    diff = np.clip(diff, 0, 1)  # Ensure diff is within [0, 1]\n    \n    # Feature 4: Fill ratio of the bin\n    fill_ratio = 1 - bins_remain_cap / bin_capacities\n    \n    # Combine features into a priority score with weights\n    priorities = can_fit * (0.4 * remaining_capacities + 0.3 * diff + 0.3 * fill_ratio)\n    \n    # Add controlled noise for exploration\n    noise = np.random.normal(0, 0.05, size=len(bins_remain_cap))\n    priorities += noise\n    \n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - (remaining_capacities / bins_remain_cap), -1e6)\n    \n    # Add adaptive noise to the priorities\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n        \n        # Scale noise based on the item size relative to bin capacity, number of valid bins, and remaining capacity ratio\n        avg_bin_capacity = np.mean(bins_remain_cap[valid_bins])\n        remaining_ratio = np.mean(remaining_capacities[valid_bins] / bins_remain_cap[valid_bins])\n        scaling_factor = (item / avg_bin_capacity) * (1 / np.sqrt(np.sum(valid_bins))) * (1 - remaining_ratio)\n        valid_priorities += noise * scaling_factor\n        priorities[valid_bins] = valid_priorities\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - remaining_capacities / bins_remain_cap, -1e6)\n    \n    # Normalize priorities to [0, 1] range for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    # Add a small noise to the priorities for exploration\n    priorities += np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 138.3016990363956,
    "mi": 85.30591324653895,
    "token_count": 154.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - (item / (bins_remain_cap + 1e-6)), -1e6)\n    \n    # Normalize priorities to be between 0 and 1 for bins that can fit the item\n    valid_priorities = priorities[priorities > -1e5]\n    if len(valid_priorities) > 0:\n        priorities[priorities > -1e5] = (valid_priorities - np.min(valid_priorities)) / (np.max(valid_priorities) - np.min(valid_priorities) + 1e-6)\n    \n    # Add controlled noise to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(0, 0.01, size=len(priorities))\n    \n    return priorities",
    "response_id": 0,
    "obj": 148.3346629437575,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 213.9699375973561,
    "mi": 84.11335791611184,
    "token_count": 162.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - np.abs(remaining_capacities - item) / (item + 1e-6), -1e6)\n    \n    # Normalize priorities to be between 0 and 1 for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    if len(valid_priorities) > 0:\n        min_valid_priority = np.min(valid_priorities)\n        max_valid_priority = np.max(valid_priorities)\n        priorities[remaining_capacities >= 0] = (valid_priorities - min_valid_priority) / (max_valid_priority - min_valid_priority + 1e-6)\n    \n    # Add controlled noise to the priorities\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(loc=0, scale=0.01, size=len(priorities))\n    \n    return priorities",
    "response_id": 1,
    "obj": 31.67132030315119,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 213.9699375973561,
    "mi": 84.11335791611184,
    "token_count": 162.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - np.abs(bins_remain_cap - item) / (bins_remain_cap.max() + 1e-6), -1e6)\n    \n    # Normalize priorities to be within [0, 1] range for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = (priorities[valid_bins] - priorities[valid_bins].min()) / (priorities[valid_bins].max() - priorities[valid_bins].min() + 1e-6)\n    \n    # Add controlled noise to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.178300757877951,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 213.9699375973561,
    "mi": 84.11335791611184,
    "token_count": 162.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacity\n    max_remain_cap = np.max(bins_remain_cap)\n    normalized_remain_cap = bins_remain_cap / (max_remain_cap + 1e-6)\n    \n    # Calculate the fit criterion: how well the item fits into the bin\n    fit_criterion = 1 - np.abs(bins_remain_cap - item) / (np.maximum(bins_remain_cap, item) + 1e-6)\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, normalized_remain_cap + fit_criterion, -1e6)\n    \n    # Add some noise to the priorities to balance exploitation and exploration\n    priorities += np.random.normal(loc=0, scale=0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 3,
    "obj": 142.6007179896291,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 213.9699375973561,
    "mi": 84.11335791611184,
    "token_count": 162.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - (item / (bins_remain_cap + 1e-6)), -1e6)\n    \n    # Normalize priorities to be between 0 and 1 for bins that can fit the item\n    valid_priorities = priorities[priorities > -1e5]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        priorities[priorities > -1e5] = (valid_priorities - min_priority) / (max_priority - min_priority + 1e-6)\n    \n    # Add controlled noise to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(0, 0.01, size=len(priorities))\n    \n    return priorities",
    "response_id": 4,
    "obj": 148.3346629437575,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 213.9699375973561,
    "mi": 84.11335791611184,
    "token_count": 162.0,
    "exec_success": true
  }
]