[
  {
    "stdout_filepath": "problem_iter18_response0.txt_stdout.txt",
    "code_path": "problem_iter18_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float, seed: int) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise added for exploration.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Normalize priorities to ensure numerical stability\n    valid_priorities = priorities > -1e6\n    if np.any(valid_priorities):  \n        min_priority = np.min(priorities[valid_priorities])\n        max_priority = np.max(priorities[valid_priorities])\n        priorities[valid_priorities] = (priorities[valid_priorities] - min_priority) / (max_priority - min_priority)\n    else:\n        priorities = np.full_like(priorities, -1e6)\n    \n    # Add controlled noise for exploration\n    priorities += noise_scale * np.random.randn(*priorities.shape)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 2 required positional arguments: 'noise_scale' and 'seed'\n9\n1\n129.32351694048162\n78.72927536839988\n135\n"
  },
  {
    "stdout_filepath": "problem_iter18_response1.txt_stdout.txt",
    "code_path": "problem_iter18_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a very low priority to bins that cannot fit the item\n    # and a higher priority to bins with less remaining capacity after adding the item\n    priorities = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -1e6)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -1e6)\n    \n    # Normalize the priorities for valid bins and add controlled noise\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + epsilon)\n        priorities[valid_bins] += np.random.uniform(-epsilon, epsilon, np.sum(valid_bins))\n        priorities[valid_bins] = np.clip(priorities[valid_bins], 0, 1)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response3.txt_stdout.txt",
    "code_path": "problem_iter18_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a very low priority to bins that cannot fit the item\n    # and a higher priority to bins with less remaining capacity after adding the item\n    priorities = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1e6)\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -1e6)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response5.txt_stdout.txt",
    "code_path": "problem_iter18_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -1e6)\n    \n    # Normalize the priorities for valid bins and add noise\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        denominator = max_priority - min_priority if max_priority != min_priority else 1\n        normalized_priorities = (priorities[valid_bins] - min_priority) / denominator\n        noisy_priorities = normalized_priorities + np.random.uniform(-epsilon, epsilon, np.sum(valid_bins))\n        priorities[valid_bins] = np.clip(noisy_priorities, 0, 1)\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.068607897885915,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response6.txt_stdout.txt",
    "code_path": "problem_iter18_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response7.txt_stdout.txt",
    "code_path": "problem_iter18_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 0.01, seed: int = 42) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise added for exploration.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    # Normalize priorities to ensure numerical stability\n    valid_priorities = priorities[priorities != -1e6]\n    if len(valid_priorities) > 0:  \n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        priorities = np.where(priorities != -1e6, (priorities - min_priority) / (max_priority - min_priority + 1e-9), priorities)\n    \n    # Add controlled noise for exploration\n    priorities += noise_scale * np.random.rand(*priorities.shape)\n    \n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response8.txt_stdout.txt",
    "code_path": "problem_iter18_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a very low priority to bins that cannot fit the item\n    # and a higher priority to bins with less remaining capacity after adding the item\n    priorities = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -1e6)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 129.32351694048162,
    "mi": 78.72927536839988,
    "token_count": 135.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response9.txt_stdout.txt",
    "code_path": "problem_iter18_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float, seed: int) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise added for exploration.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Normalize priorities to ensure numerical stability\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority + 1e-6)\n    \n    # Add controlled noise for exploration\n    priorities += noise_scale * np.random.rand(*priorities.shape)\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 2 required positional arguments: 'noise_scale' and 'seed'\n9\n1\n129.32351694048162\n78.72927536839988\n135\n"
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of random noise to add for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - (item / (bins_remain_cap + epsilon)), -1e6)\n    \n    # Normalize priorities for valid bins to be within [0, 1]\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + epsilon)\n    \n    # Add controlled random noise for exploration-exploitation balance\n    priorities += noise_scale * np.random.rand(*priorities.shape)\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.70233280920246,
    "mi": 70.17112227614678,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response1.txt_stdout.txt",
    "code_path": "problem_iter19_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of random noise added to priorities.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Normalized priority for valid bins based on the remaining capacity after packing\n    priorities = np.where(valid_bins, remaining_capacities / (item + epsilon), -1e6)\n    \n    # Add a small controlled noise to the priorities for valid bins to balance exploration and exploitation\n    priorities = np.where(valid_bins, priorities + noise_scale * np.random.uniform(-1, 1, size=len(bins_remain_cap)), priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.70233280920246,
    "mi": 70.17112227614678,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response2.txt_stdout.txt",
    "code_path": "problem_iter19_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of random noise to add for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Normalize priorities for valid bins\n    priorities = np.where(valid_bins, -np.abs(bins_remain_cap - item) / (item + epsilon), -1e6)\n    \n    # Add a small noise to priorities for exploration\n    priorities = np.where(valid_bins, priorities + noise_scale * np.random.rand(*priorities.shape), priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.70233280920246,
    "mi": 70.17112227614678,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response3.txt_stdout.txt",
    "code_path": "problem_iter19_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with simplified and normalized priority, and controlled noise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of the noise to be added.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate priority for valid bins focusing on minimizing waste\n    priorities = np.where(valid_bins, -np.abs(bins_remain_cap - item) / (item + epsilon), -1e6)\n    \n    # Normalize priorities for valid bins to be within [0, 1]\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + epsilon)\n    \n    # Add controlled noise for exploration-exploitation balance\n    priorities[valid_bins] += noise_scale * np.random.rand(np.sum(valid_bins))\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.70233280920246,
    "mi": 70.17112227614678,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response4.txt_stdout.txt",
    "code_path": "problem_iter19_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.01) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of the random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Normalize priorities for valid bins\n    priorities = np.where(valid_bins, 1 - (item / (bins_remain_cap + epsilon)), -1e6)\n    \n    # Add controlled noise to the priorities for valid bins\n    priorities = np.where(valid_bins, priorities + noise_scale * np.random.rand(*priorities.shape), priorities)\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.2919824491424,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 97.70233280920246,
    "mi": 70.17112227614678,
    "token_count": 114.0,
    "exec_success": true
  }
]