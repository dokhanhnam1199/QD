[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    # Normalize priorities to be between 0 and 1 for bins that can fit the item\n    valid_indices = priorities > -1e5\n    if np.any(valid_indices):\n        min_priority, max_priority = np.min(priorities[valid_indices]), np.max(priorities[valid_indices])\n        priorities[valid_indices] = (priorities[valid_indices] - min_priority) / (max_priority - min_priority + 1e-6)\n    \n    # Add controlled noise to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.normal(0, 0.01, size=len(priorities))\n    noise *= (priorities > -1e5)  # Only add noise to valid bins\n    priorities += noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize priorities and add controlled noise\n    valid_bins = priorities > -1e5\n    if np.any(valid_bins):\n        priorities[valid_bins] = (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + 1e-6)\n        np.random.seed(0)  \n        priorities[valid_bins] += np.random.normal(0, 0.01, size=np.sum(valid_bins))\n    \n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-4, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n\n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - remaining_capacities, -1e6)\n\n    # Normalize priorities for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = priorities[valid_bins].min(), priorities[valid_bins].max()\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n\n    # Add adaptive noise to the priorities\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n\n        # Scale noise based on the item size relative to bin capacity and number of valid bins\n        avg_bin_capacity = np.mean(bins_remain_cap[valid_bins])\n        num_valid_bins = np.sum(valid_bins)\n        scaling_factor = (item / avg_bin_capacity) * (1 / np.sqrt(num_valid_bins))\n        valid_priorities += noise * scaling_factor\n        priorities[valid_bins] = valid_priorities\n\n    return priorities",
    "response_id": 2,
    "obj": 73.09533306741125,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -1e6)\n    \n    # Normalize the priorities for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-8)\n        # Add a small noise for exploration\n        priorities[valid_bins] += np.random.uniform(-0.01, 0.01, np.sum(valid_bins))\n        # Ensure priorities are within [0, 1] after adding noise\n        priorities[valid_bins] = np.clip(priorities[valid_bins], 0, 1)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.038691663342641,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, (bins_remain_cap - item) / bin_capacities, -1e6)\n    \n    # Normalize priorities to be between 0 and 1 for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    if len(valid_priorities) > 0:\n        min_valid_priority = np.min(valid_priorities)\n        max_valid_priority = np.max(valid_priorities)\n        priorities[remaining_capacities >= 0] = (valid_priorities - min_valid_priority) / (max_valid_priority - min_valid_priority + 1e-6)\n    else:\n        # If no bin can fit the item, open a new bin\n        priorities[np.argmin(bins_remain_cap)] = 1.0\n    \n    # Add controlled noise to the priorities\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(loc=0, scale=0.01, size=len(priorities))\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    # and a higher priority to bins with less remaining capacity after adding the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -1e6)\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01, seed: int = 0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities / bins_remain_cap, -1e6)\n    \n    # Add adaptive noise to the priorities\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n        \n        # Scale noise based on the item size relative to bin capacity and the number of valid bins\n        avg_bin_remaining_ratio = np.mean(remaining_capacities[valid_bins] / bins_remain_cap[valid_bins])\n        scaling_factor = (1 - avg_bin_remaining_ratio) * (1 / np.sqrt(np.sum(valid_bins)))\n        valid_priorities += noise * scaling_factor\n        priorities[valid_bins] = valid_priorities\n    \n    # Normalize priorities to be between 0 and 1 for bins that can fit the item\n    valid_priorities = priorities[priorities > -1e5]\n    if len(valid_priorities) > 0:\n        priorities[priorities > -1e5] = (valid_priorities - np.min(valid_priorities)) / (np.max(valid_priorities) - np.min(valid_priorities) + 1e-6)\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: The capacities of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Feature 1: Whether the bin can fit the item\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Feature 2: Normalized remaining capacity after adding the item\n    remaining_capacities = np.maximum(bins_remain_cap - item, 0) / bin_capacities\n    \n    # Feature 3: Normalized fullness of the bin before adding the item\n    bin_fullness = 1 - (bins_remain_cap / bin_capacities)\n    \n    # Feature 4: Normalized absolute difference between the remaining capacity and the item size\n    diff = 1 - np.abs(bins_remain_cap - item) / (np.maximum(bins_remain_cap, item) + 1e-6)\n    \n    # Combine features into a priority score with weights\n    priorities = can_fit * (0.25 * remaining_capacities + 0.25 * bin_fullness + 0.5 * diff)\n    \n    # Add controlled noise for exploration\n    noise = np.random.normal(0, 0.005, size=len(bins_remain_cap))\n    priorities += noise\n    \n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n5\n1\n50.18947501009619\n68.98309462869048\n91\n"
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 0.05, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise to be added for exploration.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    valid_bins = relative_remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-8)\n    \n    noise = np.random.uniform(-noise_scale, noise_scale, size=len(bins_remain_cap))\n    priorities = priorities + noise\n    \n    priorities = np.clip(priorities, -1e6, 1)\n    \n    return priorities",
    "response_id": 8,
    "obj": 136.57758276824893,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 50.18947501009619,
    "mi": 68.98309462869048,
    "token_count": 91.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Feature: Normalized remaining capacity after adding the item\n    remaining_capacities = np.maximum(bins_remain_cap - item, 0) / bin_capacities\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, remaining_capacities, -1e6)\n    \n    # Add controlled noise to balance exploitation and exploration\n    priorities += np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n5\n1\n50.18947501009619\n68.98309462869048\n91\n"
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Add some noise to the priorities for exploration-exploitation balance\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 0,
    "obj": 147.93577981651381,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 77.0173278345075,
    "token_count": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    mask = bins_remain_cap >= item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(mask, relative_remaining_capacities, -1e6)\n    \n    # Add controlled noise for exploration-exploitation balance\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 1,
    "obj": 147.93577981651381,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 77.0173278345075,
    "token_count": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Add controlled noise for exploration-exploitation balance\n    priorities += np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.1523733546071,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 77.0173278345075,
    "token_count": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Add a small random noise to the priorities for exploration-exploitation balance\n    priorities = priorities + np.random.normal(0, 0.01, size=len(priorities))\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.1822895891504,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 77.0173278345075,
    "token_count": 84.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Add a small random noise to the priorities for exploration-exploitation balance\n    priorities = priorities + np.random.normal(0, 0.01, size=len(priorities))\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.1723175109693,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 77.0173278345075,
    "token_count": 84.0,
    "exec_success": true
  }
]