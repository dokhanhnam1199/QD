[
  {
    "stdout_filepath": "problem_iter28_response0.txt_stdout.txt",
    "code_path": "problem_iter28_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bins_full_cap: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bins_full_cap: Full capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Normalize the valid priorities to be between 0 and 1, using the full capacity for normalization\n    priorities = np.where(valid_bins, 1 - (remaining_capacities / bins_full_cap), 0)\n    \n    # Add a small controlled noise to valid priorities for exploration-exploitation balance\n    # Using a truncated normal distribution to avoid negative priorities\n    noise = np.clip(np.random.normal(0, 0.01, size=len(priorities)), a_min=0, a_max=None)\n    priorities = np.where(valid_bins, priorities + noise, -1e6)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bins_full_cap'\n9\n1\n81.7492568250068\n75.24167703281081\n124\n"
  },
  {
    "stdout_filepath": "problem_iter28_response1.txt_stdout.txt",
    "code_path": "problem_iter28_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit for each bin\n    fit = bins_remain_cap - item\n    \n    # Assign priority based on the fit, with higher priority for tighter fits\n    priorities = np.where(fit >= 0, 1 - (fit / bins_remain_cap), -1e6)\n    \n    # Add a small random noise to valid bin priorities for exploration-exploitation balance\n    np.random.seed(0)  \n    valid_bins = priorities != -1e6\n    priorities[valid_bins] += 1e-6 * np.random.rand(np.sum(valid_bins))\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response2.txt_stdout.txt",
    "code_path": "problem_iter28_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The maximum capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Normalize priorities based on relative waste\n    priorities = np.where(valid_bins, 1 - ((bins_remain_cap - item) / bin_capacity), -1e6)\n    \n    # Adjust noise addition for valid bins, scaled by the priority itself for more exploration in higher priority bins\n    np.random.seed(0)  # For reproducibility\n    noise = 1e-6 * np.random.rand(*priorities.shape)\n    priorities = np.where(valid_bins, priorities + priorities * noise, priorities)\n    \n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n9\n1\n81.7492568250068\n75.24167703281081\n124\n"
  },
  {
    "stdout_filepath": "problem_iter28_response3.txt_stdout.txt",
    "code_path": "problem_iter28_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate the priority based on how well the item fills the bin\n    priorities = np.where(valid_bins, \n                          (bins_remain_cap - remaining_capacities) / bin_capacity + \n                          (1 - (remaining_capacities / bins_remain_cap)), \n                          -1e6)\n    \n    # Add a small controlled noise to valid priorities for exploration-exploitation balance\n    priorities = np.where(valid_bins, priorities + np.random.normal(0, 0.01, size=len(priorities)), priorities)\n    \n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n9\n1\n81.7492568250068\n75.24167703281081\n124\n"
  },
  {
    "stdout_filepath": "problem_iter28_response4.txt_stdout.txt",
    "code_path": "problem_iter28_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Identify bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate the priority for valid bins based on the proportion of remaining capacity\n    valid_priorities = 1 - (remaining_capacities[valid_bins] / bins_remain_cap[valid_bins])\n    \n    # Normalize valid priorities to have a mean of 0 and a standard deviation of 1\n    valid_priorities = (valid_priorities - np.mean(valid_priorities)) / (np.std(valid_priorities) + 1e-8)\n    \n    # Add a small controlled noise for exploration-exploitation balance\n    valid_priorities += np.random.normal(0, 0.01, size=len(valid_priorities))\n    \n    # Create the final priority array\n    priorities = np.full_like(bins_remain_cap, -1e6, dtype=float)\n    priorities[valid_bins] = valid_priorities\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response5.txt_stdout.txt",
    "code_path": "problem_iter28_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.1, seed: int = 0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of the noise to be added.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1e6)\n    \n    # Normalize priorities for valid bins to be within [0, 1] and invert to prioritize tighter fits\n    valid_bins = priorities != -1e6\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        if max_priority != min_priority:  # Check to avoid division by zero\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + epsilon)\n            priorities[valid_bins] = 1 - priorities[valid_bins]  # Invert to prioritize tighter fits\n            # Add controlled noise for exploration-exploitation balance\n            priorities[valid_bins] += noise_scale * np.random.rand(np.sum(valid_bins))\n            # Ensure priorities are within [0, 1] after adding noise\n            priorities[valid_bins] = np.clip(priorities[valid_bins], 0, 1)\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.248105305145606,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response6.txt_stdout.txt",
    "code_path": "problem_iter28_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n    item: Size of item to be added to the bin.\n    bins_remain_cap: Array of capacities for each bin.\n    noise_scale: Scale of noise to add for exploration.\n\n    Return:\n    Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate the normalized priorities for valid bins based on the relative remaining capacity\n    priorities = np.where(valid_bins, 1 - (np.abs(remaining_capacities) / bins_remain_cap), -1e6)\n    \n    # Ensure priorities are within a comparable range\n    priorities = np.clip(priorities, -1e6, 1)\n    \n    # Add controlled noise to valid bin priorities for exploration-exploitation balance\n    np.random.seed(0)  # For reproducibility\n    noise = noise_scale * np.random.rand(*priorities.shape)\n    priorities = np.where(valid_bins, priorities + noise, priorities)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response7.txt_stdout.txt",
    "code_path": "problem_iter28_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate priorities for valid bins\n    valid_priorities = 1 - (remaining_capacities[valid_bins] / bins_remain_cap[valid_bins])\n    \n    # Normalize valid bin priorities\n    if np.any(valid_bins):\n        valid_priorities = (valid_priorities - np.min(valid_priorities)) / (np.max(valid_priorities) - np.min(valid_priorities) + 1e-9)\n    \n    # Initialize priorities array\n    priorities = np.where(valid_bins, 0.0, -1e6)\n    \n    # Assign normalized priorities to valid bins\n    priorities[valid_bins] = valid_priorities\n    \n    # Add small, controlled noise for exploration-exploitation balance\n    np.random.seed(0)  # For reproducibility\n    priorities = np.where(valid_bins, priorities + 1e-6 * np.random.rand(*priorities.shape), priorities)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response8.txt_stdout.txt",
    "code_path": "problem_iter28_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n    item: Size of item to be added to the bin.\n    bins_remain_cap: Array of capacities for each bin.\n    noise_scale: Scale of noise to add for exploration.\n\n    Return:\n    Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate the priority score based on how well the item fits the bin\n    priorities = np.where(valid_bins, 1 - (np.abs(remaining_capacities) / bins_remain_cap), -1e6)\n    \n    # Normalize valid priorities to be between 0 and 1\n    valid_priorities = priorities[valid_bins]\n    if len(valid_priorities) > 0:\n        valid_priorities = (valid_priorities - np.min(valid_priorities)) / (np.max(valid_priorities) - np.min(valid_priorities) + 1e-6)\n    priorities[valid_bins] = valid_priorities\n    \n    # Add controlled noise to valid priorities for exploration-exploitation balance\n    np.random.seed(0)  # For reproducibility\n    priorities = np.where(valid_bins, priorities + noise_scale * np.random.uniform(-1, 1, size=len(priorities)), priorities)\n    \n    # Ensure numerical stability by clipping priorities to a reasonable range\n    priorities = np.clip(priorities, -1e6, 1)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter28_response9.txt_stdout.txt",
    "code_path": "problem_iter28_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float = 1.0, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacities: The maximum capacity of each bin.\n        epsilon: Small value for numerical stability and exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Identify valid bins that can accommodate the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Calculate the priority for valid bins based on how well the item fits\n    priorities = np.where(valid_bins, \n                          (bins_remain_cap - item) / bin_capacities,  # Best fit heuristic normalized by bin capacity\n                          -1e6)  # Very low priority for invalid bins\n    \n    # Add a small random noise for exploration-exploitation balance\n    np.random.seed(0)  # For reproducibility\n    priorities = np.where(valid_bins, priorities + epsilon * np.random.rand(*priorities.shape), priorities)\n    \n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 81.7492568250068,
    "mi": 75.24167703281081,
    "token_count": 124.0,
    "exec_success": true
  }
]