[
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_max_cap: float, epsilon: float = 1e-6, noise_scale: float = 0.01) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_max_cap: Maximum capacity of a bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of random noise to add for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities and item size\n    normalized_bins_remain_cap = bins_remain_cap / bin_max_cap\n    normalized_item = item / bin_max_cap\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    # Use a scoring function that prefers bins with remaining capacity closest to the item size\n    priorities = np.where(remaining_capacities >= 0, \n                          -(normalized_bins_remain_cap - normalized_item) ** 2, \n                          -1e6)\n    \n    # Introduce a controlled noise to the priorities to balance exploration-exploitation\n    noise = np.random.normal(loc=0, scale=noise_scale, size=len(bins_remain_cap))\n    priorities = np.where(remaining_capacities >= 0, priorities + noise, priorities)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_max_cap'\n11\n3\n177.87213211613133\n81.35607298643771\n184\n"
  },
  {
    "stdout_filepath": "problem_iter22_response1.txt_stdout.txt",
    "code_path": "problem_iter22_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_max_cap: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_max_cap: Maximum capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities\n    normalized_bins_remain_cap = bins_remain_cap / bin_max_cap\n    \n    # Calculate the normalized remaining capacity after adding the item\n    remaining_capacities = normalized_bins_remain_cap - item / bin_max_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Introduce controlled noise for exploration\n    noise = np.random.normal(0, 0.01, size=len(bins_remain_cap))\n    priorities = np.where(remaining_capacities >= 0, priorities + noise, priorities)\n    \n    # Ensure numerical stability\n    priorities = np.clip(priorities, -1e6, 1e6)\n    \n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_max_cap'\n11\n3\n177.87213211613133\n81.35607298643771\n184\n"
  },
  {
    "stdout_filepath": "problem_iter22_response2.txt_stdout.txt",
    "code_path": "problem_iter22_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Directly optimize the objective by prioritizing bins that fit the item with the least remaining capacity\n    priorities = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -1e6)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response3.txt_stdout.txt",
    "code_path": "problem_iter22_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities and item size by the maximum capacity\n    max_cap = np.max(bins_remain_cap)\n    normalized_bins_remain_cap = bins_remain_cap / max_cap\n    normalized_item = item / max_cap\n    \n    # Calculate the priority based on the difference between the remaining capacity and the item size\n    priorities = np.where(normalized_bins_remain_cap >= normalized_item, \n                          -(normalized_bins_remain_cap - normalized_item), \n                          -1e6)\n    \n    # Introduce a controlled noise to valid bins for exploration-exploitation balance\n    valid_bins = priorities != -1e6\n    noise = np.random.uniform(-0.01, 0.01, size=len(bins_remain_cap))\n    priorities = np.where(valid_bins, priorities + noise, priorities)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.008775428799367,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response4.txt_stdout.txt",
    "code_path": "problem_iter22_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a very low priority to bins that cannot fit the item\n    # For bins that can fit the item, prioritize the one with the least remaining capacity after adding the item\n    priorities = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -1e6)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response5.txt_stdout.txt",
    "code_path": "problem_iter22_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_range: float = 0.01) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_range: Range of uniform noise for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    valid_bins = remaining_capacities >= 0\n    priorities = np.where(valid_bins, remaining_capacities, -1e6)\n    \n    # Normalize the priorities for valid bins and add noise\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        denominator = max_priority - min_priority if max_priority != min_priority else 1\n        normalized_priorities = 1 - (priorities[valid_bins] - min_priority) / denominator\n        noisy_priorities = normalized_priorities + np.random.uniform(-noise_range, noise_range, np.sum(valid_bins))\n        priorities[valid_bins] = np.clip(noisy_priorities, 0, 1)\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.038691663342641,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response6.txt_stdout.txt",
    "code_path": "problem_iter22_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response7.txt_stdout.txt",
    "code_path": "problem_iter22_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        capacity: Maximum capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities to ensure numerical stability\n    normalized_bins_remain_cap = bins_remain_cap / capacity\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, \n                          -np.abs(normalized_bins_remain_cap - item / capacity), -1e6)\n    \n    # Introduce a controlled noise to balance exploration-exploitation\n    noise = np.random.uniform(-0.01, 0.01, size=len(bins_remain_cap))\n    priorities = np.where(bins_remain_cap >= item, priorities + noise, priorities)\n    \n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'capacity'\n11\n3\n177.87213211613133\n81.35607298643771\n184\n"
  },
  {
    "stdout_filepath": "problem_iter22_response8.txt_stdout.txt",
    "code_path": "problem_iter22_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.1, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of the noise to be added.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1e6)\n    \n    # Normalize priorities for valid bins to be within [0, 1]\n    valid_bins = priorities != -1e6\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + epsilon)\n        # Invert the priority so that bins with less remaining capacity have higher priority\n        priorities[valid_bins] = 1 - priorities[valid_bins]\n        # Add controlled noise for exploration-exploitation balance\n        priorities[valid_bins] += noise_scale * np.random.rand(np.sum(valid_bins))\n        # Ensure priorities are within [0, 1] after adding noise\n        priorities[valid_bins] = np.clip(priorities[valid_bins], 0, 1)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.238133226964499,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response9.txt_stdout.txt",
    "code_path": "problem_iter22_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-8, noise_scale: float = 0.01, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin with simplified and normalized priority, and controlled noise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of the noise to be added.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize priorities for valid bins to be within [0, 1]\n    valid_bins = priorities != -1e6\n    if np.any(valid_bins):\n        min_priority, max_priority = np.min(priorities[valid_bins]), np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + epsilon)\n        # Add controlled noise for exploration-exploitation balance\n        priorities[valid_bins] += noise_scale * np.random.rand(np.sum(valid_bins))\n    \n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 177.87213211613133,
    "mi": 81.35607298643771,
    "token_count": 184.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise to be added for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the bins_remain_cap to ensure numerical stability\n    max_cap = np.max(bins_remain_cap)\n    if max_cap == 0:\n        return np.zeros_like(bins_remain_cap)\n    \n    normalized_bins_remain_cap = bins_remain_cap / max_cap\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = normalized_bins_remain_cap - item / max_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(normalized_bins_remain_cap - item / max_cap), -1e6)\n    \n    # To further differentiate bins that can fit the item, we use the remaining capacity\n    priorities = np.where(remaining_capacities >= 0, priorities + remaining_capacities, priorities)\n    \n    # Introduce controlled noise to balance exploration-exploitation\n    noise = np.random.normal(0, noise_scale, size=len(bins_remain_cap))\n    priorities = priorities + noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 74.46150777822099,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.99896988958,
    "mi": 80.23116636549993,
    "token_count": 150.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to prevent division by zero.\n        noise_scale: Scale of the noise to be added for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the bins_remain_cap to ensure numerical stability\n    max_cap = np.max(bins_remain_cap)\n    normalized_bins_remain_cap = bins_remain_cap / (max_cap + epsilon)\n    \n    # Calculate the normalized remaining capacity after adding the item\n    normalized_item = item / (max_cap + epsilon)\n    remaining_capacities = normalized_bins_remain_cap - normalized_item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(normalized_bins_remain_cap - normalized_item), -1e6)\n    \n    # To further differentiate bins that can fit the item, use the normalized remaining capacity\n    priorities = np.where(remaining_capacities >= 0, priorities + remaining_capacities / (epsilon + np.abs(remaining_capacities)), priorities)\n    \n    # Add controlled noise to balance exploration-exploitation\n    priorities += noise_scale * np.random.randn(*priorities.shape)\n    \n    return priorities",
    "response_id": 1,
    "obj": 6.0331072995612285,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.99896988958,
    "mi": 80.23116636549993,
    "token_count": 150.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        noise_scale: Scale of noise to add for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize bins_remain_cap to ensure numerical stability\n    max_cap = np.max(bins_remain_cap)\n    normalized_bins_remain_cap = bins_remain_cap / (max_cap + epsilon)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = normalized_bins_remain_cap - item / (max_cap + epsilon)\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(normalized_bins_remain_cap - item / (max_cap + epsilon)), -1e6)\n    \n    # Use a simpler priority function that directly correlates with the objective (minimize waste)\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, priorities)\n    \n    # Add controlled noise for exploration-exploitation balance\n    priorities += noise_scale * np.random.randn(*priorities.shape)\n    \n    return priorities",
    "response_id": 2,
    "obj": 147.83605903470288,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.99896988958,
    "mi": 80.23116636549993,
    "token_count": 150.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        noise_scale: Scale of the noise to be added for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the bins_remain_cap to ensure numerical stability\n    max_cap = np.max(bins_remain_cap)\n    normalized_bins_remain_cap = bins_remain_cap / (max_cap + epsilon)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(normalized_bins_remain_cap - item / (max_cap + epsilon)), -1e6)\n    \n    # Introduce controlled noise for exploration-exploitation balance\n    priorities += noise_scale * np.random.randn(*priorities.shape)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.906262465097731,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.99896988958,
    "mi": 80.23116636549993,
    "token_count": 150.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        noise_scale: Scale of the noise to be added for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize bins_remain_cap to ensure numerical stability\n    max_cap = np.max(bins_remain_cap)\n    norm_bins_remain_cap = bins_remain_cap / (max_cap + epsilon)\n    \n    # Calculate the normalized remaining capacity after adding the item\n    norm_item = item / (max_cap + epsilon)\n    remaining_capacities = norm_bins_remain_cap - norm_item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(norm_bins_remain_cap - norm_item), -1e6)\n    \n    # To further differentiate bins that can fit the item, use the normalized remaining capacity\n    priorities = np.where(remaining_capacities >= 0, priorities + norm_bins_remain_cap, priorities)\n    \n    # Add controlled noise for exploration-exploitation balance\n    noise = noise_scale * np.random.randn(*priorities.shape)\n    priorities += noise\n    \n    return priorities",
    "response_id": 4,
    "obj": 73.64379736737136,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 164.99896988958,
    "mi": 80.23116636549993,
    "token_count": 150.0,
    "exec_success": true
  }
]