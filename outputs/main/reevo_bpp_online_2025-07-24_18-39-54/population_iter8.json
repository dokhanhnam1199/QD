[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-9, seed: int = 0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        \n        # Add controlled randomness to the normalized priorities\n        noisy_priorities = normalized_priorities + np.random.uniform(-0.01, 0.01, size=normalized_priorities.shape)\n        noisy_priorities = np.clip(noisy_priorities, 0, 1)  # Ensure priorities are within [0, 1]\n        \n        # Update priorities for bins that can fit the item with noisy priorities\n        priorities[valid_bins] = noisy_priorities\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n\n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n\n    # Check if there are bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        \n        # Normalize priorities for bins that can fit the item\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        \n        # Check if all valid priorities are the same to avoid division by zero\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            \n            # Add controlled randomness to the normalized priorities\n            noise = np.random.uniform(-1, 1, size=len(valid_priorities))\n            scaled_noise = 0.1 * noise  # Scaled noise in the range [-0.1, 0.1]\n            noisy_normalized_priorities = normalized_priorities + scaled_noise\n            \n            # Ensure noisy priorities are within [0, 1] range\n            noisy_normalized_priorities = np.clip(noisy_normalized_priorities, 0, 1)\n            \n            # Update priorities for bins that can fit the item with noisy normalized priorities\n            priorities[valid_bins] = noisy_normalized_priorities\n        else:\n            # If all valid priorities are the same, assign a constant priority (e.g., 1) and add some noise\n            priorities[valid_bins] = 1 + 0.1 * np.random.uniform(-1, 1, size=np.sum(valid_bins))\n\n    return priorities",
    "response_id": 1,
    "obj": 147.69644994016755,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    remaining_capacities = bins_remain_cap - item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities, -1e6)\n    \n    valid_priorities = priorities[remaining_capacities >= 0]\n    min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n    \n    if max_priority == min_priority:\n        normalized_priorities = np.ones_like(valid_priorities)\n    else:\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n        noise = np.random.uniform(-0.05, 0.05, size=len(valid_priorities))\n        noisy_normalized_priorities = np.clip(normalized_priorities + noise, 0, 1)\n        priorities[remaining_capacities >= 0] = -noisy_normalized_priorities\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.11248504188274,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-8, seed: int = 0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Small value to avoid division by zero and control noise level.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    if len(valid_priorities) > 0:\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            # Add controlled randomness to the normalized priorities\n            noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n            normalized_priorities += noise\n            priorities[remaining_capacities >= 0] = normalized_priorities\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = 0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        \n        # Add controlled randomness to the normalized priorities\n        noisy_priorities = normalized_priorities + np.random.uniform(-0.01, 0.01, size=normalized_priorities.shape)\n        noisy_priorities = np.clip(noisy_priorities, 0, 1)  # Ensure priorities are within [0, 1]\n        \n        # Update priorities for bins that can fit the item with noisy priorities\n        priorities[valid_bins] = noisy_priorities\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-8, seed: int = 0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            # Add adaptive noise to the normalized priorities\n            noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n            scaling_factor = 1 + np.abs(max_priority - min_priority)\n            normalized_priorities += noise * scaling_factor\n            priorities[valid_bins] = normalized_priorities\n        else:\n            priorities[valid_bins] = 1.0\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value for numerical stability.\n        seed: Seed for random number generator.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    remaining_capacities = bins_remain_cap - item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n\n    valid_indices = remaining_capacities >= 0\n    valid_priorities = priorities[valid_indices]\n\n    if len(valid_priorities) > 0:\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        else:\n            normalized_priorities = np.ones_like(valid_priorities)\n        \n        noisy_priorities = normalized_priorities + np.random.uniform(-0.1, 0.1, size=normalized_priorities.shape)\n        noisy_priorities = np.clip(noisy_priorities, 0, 1)\n        \n        priorities[valid_indices] = noisy_priorities\n\n    return priorities",
    "response_id": 7,
    "obj": 4.437574790586359,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-9, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        else:\n            normalized_priorities = np.ones_like(valid_priorities)\n        \n        # Add controlled randomness to the normalized priorities and clip\n        noisy_priorities = np.clip(normalized_priorities + np.random.uniform(-0.01, 0.01, size=normalized_priorities.shape), 0, 1)\n        \n        # Update priorities for bins that can fit the item with noisy priorities\n        priorities[valid_bins] = noisy_priorities\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = 0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n    normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n    \n    # Add moderate noise to the normalized priorities to break ties\n    noisy_priorities = normalized_priorities + np.random.uniform(-0.05, 0.05, size=normalized_priorities.shape)\n    noisy_priorities = np.clip(noisy_priorities, 0, 1)  \n    \n    # Update priorities for bins that can fit the item with noisy priorities\n    priorities[remaining_capacities >= 0] = -noisy_priorities  # Negate to maintain the original order\n    \n    return priorities",
    "response_id": 9,
    "obj": 149.1723175109693,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 176.46653521143952,
    "mi": 77.97960104820656,
    "token_count": 192.0,
    "exec_success": true
  }
]