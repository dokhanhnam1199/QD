[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, noise_scale: float = 0.01, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        noise_scale: Scale of the noise to be added to priorities.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    # Add controlled randomness to the priorities\n    noise = np.random.uniform(-noise_scale, noise_scale, size=len(bins_remain_cap))\n    noisy_priorities = priorities + noise\n    \n    return noisy_priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, noise_scale: float = 0.05, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        noise_scale: Scale of the noise to be added for exploration.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set the random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_capacities = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(relative_remaining_capacities >= 0, relative_remaining_capacities, -1e6)\n    \n    # Normalize priorities for valid bins to be within a comparable range\n    valid_bins = relative_remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority, max_priority = priorities[valid_bins].min(), priorities[valid_bins].max()\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    # Add controlled noise to priorities for exploration\n    noise = np.random.uniform(-noise_scale, noise_scale, size=len(bins_remain_cap))\n    noisy_priorities = priorities + noise\n    \n    # Clip noisy priorities to ensure they are within a reasonable range\n    noisy_priorities = np.clip(noisy_priorities, -1e6, 1)\n    \n    return noisy_priorities",
    "response_id": 1,
    "obj": 136.43797367371363,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = 0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Small value to control noise level.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    # Add controlled noise to the priorities\n    noise = np.random.uniform(-epsilon, epsilon, size=len(bins_remain_cap))\n    priorities += noise\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.01, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to control the level of randomness.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, 1 - (remaining_capacities / bins_remain_cap), -1e6)\n    \n    # Add adaptive noise to the priorities\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n        # Scale noise based on the item size relative to bin capacity and number of valid bins\n        avg_bin_capacity = np.mean(bins_remain_cap[valid_bins])\n        scaling_factor = (item / avg_bin_capacity) * (1 / np.sqrt(np.sum(valid_bins)))\n        valid_priorities += noise * scaling_factor\n        priorities[valid_bins] = valid_priorities\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Small value to avoid division by zero and control noise level.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    # Add controlled randomness to the priorities for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        noise = np.random.uniform(-epsilon, epsilon, size=np.sum(valid_bins))\n        priorities[valid_bins] += noise\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, \n                          # Use a combination of the remaining capacity and the \n                          # absolute difference between the remaining capacity and the item size\n                          -np.abs(remaining_capacities - item / 2) + remaining_capacities / (1 + item), \n                          -1e6)\n    \n    # To further differentiate bins, we use a combination of the bin utilization \n    # after adding the item and the remaining capacity\n    bin_utilization = (bins_remain_cap - remaining_capacities) / bins_remain_cap\n    priorities = np.where(remaining_capacities >= 0, \n                          priorities + 0.5 * bin_utilization + 0.2 * (1 - remaining_capacities / bins_remain_cap), \n                          priorities)\n    \n    return priorities",
    "response_id": 5,
    "obj": 9.493418428400483,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1e6)\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        valid_priorities = priorities[valid_bins]\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        normalized_priorities = np.clip(normalized_priorities, 0, 1)\n        \n        # Add controlled randomness to the normalized priorities\n        noise = np.random.uniform(-0.01, 0.01, size=len(valid_priorities))\n        noisy_normalized_priorities = np.clip(normalized_priorities + noise, 0, 1)\n        \n        # Update priorities for bins that can fit the item with noisy priorities\n        priorities[valid_bins] = -noisy_normalized_priorities\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    remaining_capacities = bins_remain_cap - item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e6)\n    \n    valid_priorities = priorities[remaining_capacities >= 0]\n    min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n    \n    if max_priority == min_priority:\n        normalized_priorities = np.ones_like(valid_priorities)\n    else:\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        noise = np.random.uniform(-0.05, 0.05, size=len(valid_priorities))\n        noisy_normalized_priorities = np.clip(normalized_priorities + noise, 0, 1)\n        priorities[remaining_capacities >= 0] = noisy_normalized_priorities\n    \n    return priorities",
    "response_id": 9,
    "obj": 149.10251296370166,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 169.6436125266828,
    "mi": 86.94124909639925,
    "token_count": 193.0,
    "exec_success": true
  }
]