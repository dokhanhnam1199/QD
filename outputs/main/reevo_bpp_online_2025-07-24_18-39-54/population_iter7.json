[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = 0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value for numerical stability.\n        seed: Seed for random number generator.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize priorities globally\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority + epsilon)\n    \n    # Introduce controlled randomness to break ties\n    np.random.seed(seed)  \n    priorities += np.random.uniform(0, epsilon, size=len(priorities))\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities for bins that can fit the item to be between 0 and 1\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n        # Introduce a small random noise to break ties among valid bins\n        priorities[valid_bins] += np.random.uniform(0, 1e-6, size=np.sum(valid_bins))\n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, random_state: int = 0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        random_state: Seed for the random number generator.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities for bins that can fit the item to be between 0 and 1\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + 1e-9)\n    \n    # Introduce controlled randomness to break ties\n    rng = np.random.default_rng(random_state)\n    priorities += rng.uniform(0, 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities for bins that can fit the item to be between 0 and 1\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness to break ties, scaled according to the normalized priority range\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, (np.max(priorities) - np.min(priorities)) * 0.01, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities across all bins\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    if max_priority == min_priority:  # Handle the case where all priorities are the same\n        priorities = np.ones_like(priorities)\n    else:\n        priorities = (priorities - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness to break ties\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))  # Reduced the upper bound of the random noise\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities for bins that can fit the item to be between 0 and 1\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority > min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    # Introduce a small random noise to break ties while maintaining reproducibility\n    rng = np.random.default_rng(0)\n    priorities += rng.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities across all bins\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority + 1e-6)\n    \n    # Introduce controlled randomness to break ties\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-5, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin, normalized to be between 0 and 1.\n        bins_remain_cap: Array of remaining capacities for each bin, normalized to be between 0 and 1.\n        bin_capacities: The capacity of each bin, default is 1.0.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Scale the priorities using a non-linear function (e.g., sigmoid) to emphasize the differences between high priorities\n    priorities = np.where(remaining_capacities >= 0, 1 / (1 + np.exp(-(priorities * 10 - 5))), priorities)\n    \n    # Introduce controlled randomness to break ties\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-4, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 7,
    "obj": 12.415237335460711,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities for bins that can fit the item to be between 0 and 1\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness to break ties\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-4, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 8,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Normalize the priorities for bins that can fit the item to be between 0 and 1\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[valid_bins] = 1.0\n    \n    # Introduce controlled randomness to break ties\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-4, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 120.92782504182705,
    "mi": 86.85066654163134,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n    normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon) if max_priority != min_priority else np.ones_like(valid_priorities)\n    \n    # Add controlled randomness to the normalized priorities\n    noise = np.random.uniform(-1, 1, size=len(valid_priorities))\n    noisy_normalized_priorities = normalized_priorities + 0.1 * (max_priority - min_priority) * noise  # Scale noise according to the normalized priority range\n    \n    # Update priorities for bins that can fit the item with noisy normalized priorities\n    priorities[remaining_capacities >= 0] = noisy_normalized_priorities\n    \n    return priorities",
    "response_id": 0,
    "obj": 6.571599521340257,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 252.66401182973067,
    "mi": 81.13623555779273,
    "token_count": 206.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response1.txt_stdout.txt",
    "code_path": "problem_iter7_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n    normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon) if max_priority != min_priority else np.ones_like(valid_priorities)\n    \n    # Add controlled randomness to the normalized priorities\n    noisy_priorities = normalized_priorities + np.random.uniform(-0.1, 0.1, size=normalized_priorities.shape)\n    noisy_priorities = np.clip(noisy_priorities, 0, 1)  # Ensure priorities are within [0, 1]\n    \n    # Update priorities for bins that can fit the item with noisy priorities\n    priorities[remaining_capacities >= 0] = noisy_priorities * (max_priority - min_priority + epsilon) + min_priority\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.407658556043084,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 252.66401182973067,
    "mi": 81.13623555779273,
    "token_count": 206.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n    normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon) if max_priority != min_priority else np.ones_like(valid_priorities)\n    \n    # Add controlled randomness to the normalized priorities\n    noise = np.random.uniform(-1, 1, size=len(valid_priorities))\n    scaled_noise = noise * (max_priority - min_priority) * 0.1  # Scale noise according to the priority range\n    normalized_priorities += scaled_noise\n    \n    # Update priorities with the normalized and noisy values\n    priorities[remaining_capacities >= 0] = normalized_priorities\n    \n    return priorities",
    "response_id": 2,
    "obj": 6.70123653769446,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 252.66401182973067,
    "mi": 81.13623555779273,
    "token_count": 206.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    if len(valid_priorities) > 0:\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            # Add controlled randomness to the normalized priorities\n            noise = np.random.uniform(-epsilon, epsilon, size=len(valid_priorities))\n            normalized_priorities += noise * (1 + np.abs(max_priority - min_priority))\n            priorities[remaining_capacities >= 0] = normalized_priorities\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 252.66401182973067,
    "mi": 81.13623555779273,
    "token_count": 206.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6, seed: int = None) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        seed: Random seed for reproducibility.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Set random seed for reproducibility\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Normalize priorities for bins that can fit the item\n    valid_priorities = priorities[remaining_capacities >= 0]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority + epsilon)\n        \n        # Add controlled randomness to the normalized priorities\n        noise = np.random.uniform(-1, 1, size=len(valid_priorities))\n        scaled_noise = noise * (max_priority - min_priority) * 0.1  # Scale noise according to the priority range\n        normalized_priorities += scaled_noise\n        \n        # Update priorities for bins that can fit the item\n        priorities[remaining_capacities >= 0] = normalized_priorities\n    \n    return priorities",
    "response_id": 4,
    "obj": 6.5416832867969825,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 252.66401182973067,
    "mi": 81.13623555779273,
    "token_count": 206.0,
    "exec_success": true
  }
]