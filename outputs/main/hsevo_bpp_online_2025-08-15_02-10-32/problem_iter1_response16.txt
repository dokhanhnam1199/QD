```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using sigmoid fit score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We want to prioritize bins that are "almost full" but can still fit the item.
    # This encourages using existing bins efficiently before opening new ones.

    # Calculate the "goodness" of fit for each bin. A higher value means a better fit.
    # We consider bins where the remaining capacity is just enough or slightly more than the item.
    # This is a subjective measure to encourage tighter packing.

    # Create a measure of how "tight" the fit is.
    # We want capacity_remaining - item_size to be close to zero.
    tightness = bins_remain_cap - item

    # Filter out bins that cannot fit the item. Their priority should be zero (or very low).
    fit_mask = bins_remain_cap >= item
    valid_tightness = tightness[fit_mask]

    # Normalize the tightness to a range where sigmoid can work well.
    # If there are no valid bins, this step will be skipped and an all-zero array will be returned.
    priorities = np.zeros_like(bins_remain_cap)

    if valid_tightness.size > 0:
        # A simple normalization: scale such that the range of valid tightness is somewhat centered around 0.
        # This is heuristic and can be tuned. We want positive values for good fits.
        # A smaller max_tightness means we are more sensitive to "almost full" bins.
        max_tightness = np.max(valid_tightness)
        min_tightness = np.min(valid_tightness)

        # Avoid division by zero if all valid bins have the same tightness
        if max_tightness == min_tightness:
            normalized_tightness = np.zeros_like(valid_tightness)
        else:
            # Scale so that the range of valid_tightness is mapped to roughly [-2, 2] or similar,
            # allowing sigmoid to capture differences.
            # We want to map the smallest valid tightness (most space left) to a lower sigmoid value,
            # and the largest valid tightness (tightest fit) to a higher sigmoid value.
            # So, invert the range for scaling: max_tightness becomes -1, min_tightness becomes 1.
            # Using -valid_tightness here because we want smaller remaining space (larger negative)
            # to result in a higher sigmoid value.
            scaled_tightness = -2 * (valid_tightness - min_tightness) / (max_tightness - min_tightness)

            # Apply sigmoid function.
            # Sigmoid(x) = 1 / (1 + exp(-x))
            # This will map scaled_tightness to values between 0 and 1.
            # We want higher values for tighter fits, so we will scale and shift if needed.
            # A common approach is to use a scaled and shifted sigmoid.
            # Let's map tightest fit (min_tightness) to 1 and loosest fit (max_tightness) to 0.
            # This means we want a higher score when valid_tightness is smaller.
            # Let's use a shifted and scaled sigmoid.
            # f(x) = 1 / (1 + exp(-(k * (tightness_max - x))))
            # where k is a steepness parameter and x is the remaining capacity after fitting.

            # Parameter to control steepness of sigmoid. Higher k means more emphasis on tighter fits.
            steepness_param = 2.0

            # Calculate the value we pass to sigmoid. We want a larger value for smaller remaining capacity.
            # So we use -(bins_remain_cap[fit_mask] - item) which means a smaller remaining capacity gives a larger positive value.
            sigmoid_input = steepness_param * (item - bins_remain_cap[fit_mask])

            # Apply sigmoid. The output will be between 0 and 1.
            # Higher values for bins that are almost full (but can fit the item).
            sigmoid_scores = 1 / (1 + np.exp(-sigmoid_input))

            # Map these scores back to the original priority array
            priorities[fit_mask] = sigmoid_scores

    return priorities
```
