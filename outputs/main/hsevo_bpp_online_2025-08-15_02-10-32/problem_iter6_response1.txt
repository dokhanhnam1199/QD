```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and Worst Fit principles with a dynamic "gap" penalty.
    Prioritizes bins that minimize remaining capacity (Best Fit), but also considers
    bins that have a larger capacity that could accommodate future larger items,
    but penalizes a large "gap" between item size and bin capacity to avoid fragmentation.
    The "gap" penalty is adaptive based on the item's size.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Mask for bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # --- Component 1: Best Fit ---
    # Prioritize bins with minimal remaining capacity after packing.
    # This is a negative log of the remaining capacity after packing to maximize.
    # Add epsilon for numerical stability when remaining_cap == item.
    best_fit_score = -np.log(suitable_bins_remain_cap - item + 1e-9)
    
    # --- Component 2: Worst Fit (modified) ---
    # Consider bins that have more excess capacity, potentially for larger future items.
    # We want to give a *slight* preference to bins with more "room" but not too much.
    # We can represent this as a score related to the excess capacity, but we want to
    # avoid extremely large remaining capacities which might lead to fragmentation.
    # Let's use a score that increases with excess capacity but saturates.
    # A simple approach is a linear or logarithmic increase in the excess capacity itself.
    # Let's use the excess capacity directly, scaled.
    # `excess_capacity = suitable_bins_remain_cap - item`
    # We want to favor bins where `excess_capacity` is moderate.
    # A simple score could be `excess_capacity / (item + epsilon)`. High ratio means large excess relative to item.
    # We want to favor lower excess *relative* to item size.
    
    # --- Component 3: Dynamic Gap Penalty ---
    # Penalize bins where the difference (gap) between bin capacity and item size is large.
    # This gap represents wasted space. The penalty should be stronger for larger gaps.
    # The penalty should also be 'dynamic' in the sense that a gap of 5 units might be small
    # for an item of size 100, but large for an item of size 5.
    # So, the penalty should be related to `gap / item_size`.
    
    gap = suitable_bins_remain_cap - item
    
    # Penalty score: we want to penalize large `gap / item`.
    # So, a good penalty multiplier would be `1 / (gap / item + C)` or `item / (gap + C)`.
    # This multiplier should be applied to a score we want to maximize.
    # A higher multiplier means a better bin (smaller relative gap).
    
    # Let's combine Best Fit and a modified Worst Fit idea.
    # We want to maximize `best_fit_score`.
    # For the "room" aspect, we can consider `gap`.
    # If `gap` is very small, it's good for Best Fit.
    # If `gap` is moderate, it might be good for accommodating future items.
    # If `gap` is very large, it's bad (fragmentation).
    
    # Let's try to maximize:
    # 1. `best_fit_score` (higher is better)
    # 2. A term that favors moderate gaps over very large gaps.
    #    Consider `gap_score = 1.0 / (gap / item + epsilon)` -- this favors smaller gaps.
    #    This is similar to the penalty in v1.
    
    # Let's refine the interaction:
    # We want to maximize the "goodness" of a fit.
    # Goodness = (Score from Best Fit) * (Score from Gap Management)
    
    # Best Fit score: `-np.log(remaining_after_packing)` as before.
    # Gap Management Score: We want to penalize large gaps relative to item size.
    # So, a score that decreases as `gap/item` increases.
    # Let's use `1 / (1 + (gap / (item + 1e-9)))`.
    # This score is 1 for a perfect fit (gap=0) and decreases as the relative gap increases.
    gap_management_score = 1.0 / (1.0 + (gap / (item + 1e-9)))
    
    # Final priority: Product of Best Fit and Gap Management Score.
    # This encourages bins that are "tight" (high best_fit_score) while also
    # not having excessively large relative gaps.
    priorities[suitable_bins_mask] = best_fit_score * gap_management_score
    
    return priorities
```
