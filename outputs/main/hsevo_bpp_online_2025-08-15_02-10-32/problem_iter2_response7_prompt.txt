{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities[suitable_bins_mask] = 1.0 / (bins_remain_cap[suitable_bins_mask] - item + 1e-9)\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    suitable_bins_capacities = bins_remain_cap[suitable_bins_mask]\n    if suitable_bins_capacities.size > 0:\n        relative_capacities = suitable_bins_capacities - item\n        exp_priorities = np.exp(relative_capacities)\n        priorities[suitable_bins_mask] = exp_priorities / np.sum(exp_priorities)\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 (Exact Fit First) and Heuristic 2 (Best Fit): Heuristic 1 prioritizes exact fits and then falls back to First Fit, while Heuristic 2 strictly implements Best Fit. Heuristic 1's explicit handling of exact fits and fallback logic seems more robust for certain scenarios than a pure Best Fit.\n\nComparing Heuristic 1 and Heuristic 6 (Inverse of Remaining Capacity): Heuristic 1 offers a more sophisticated priority system with distinct cases (exact fit, then first fit). Heuristic 6 simply uses `1 / (remaining_capacity - item)`, which is a form of Best Fit but lacks the specific exact-fit advantage of Heuristic 1.\n\nComparing Heuristic 2 (Best Fit) and Heuristic 8 (Loop-based Best Fit): Heuristic 2 uses vectorized NumPy operations for efficiency, while Heuristic 8 uses a Python loop. Vectorization is generally preferred for performance in numerical computations. The logic is similar.\n\nComparing Heuristic 6 and Heuristic 11 (Identical): Heuristics 6 and 11 are identical. Both implement Best Fit by prioritizing bins with the least remaining capacity using the inverse of `(remaining_capacity - item)`.\n\nComparing Heuristic 7 and Heuristic 10 (Identical): Heuristics 7 and 10 are identical. They use an exponential decay based on the mean relative capacity, aiming to balance fits but potentially being sensitive to outliers.\n\nComparing Heuristic 5 (Sigmoid Fit Score) and Heuristic 12 (Scaled Sigmoid): Heuristic 12 uses a more carefully tuned sigmoid function with scaling parameters based on the range of valid fits. Heuristic 5's sigmoid scaling is fixed, making Heuristic 12 likely more adaptable to different data distributions.\n\nComparing Heuristic 16 (Remaining Capacity) and Heuristic 18 (Identical): Heuristics 16 and 18 simply return the remaining capacity if the item fits, otherwise -1. This is a very basic heuristic and doesn't actively try to optimize packing beyond identifying bins that can fit.\n\nComparing Heuristic 13 (Relative Capacity) and Heuristic 17 (Normalized Exponential Relative Capacity): Heuristic 13 uses a simple ratio `(remaining - item) / remaining`. Heuristic 17 uses an exponential of the relative capacity, normalized across fitting bins. Heuristic 17's approach seems to give stronger preference to tighter fits via exponentiation.\n\nOverall: Heuristics that combine explicit strategies like exact fits with fallback mechanisms (e.g., Heuristic 1) or use well-tuned mathematical transformations (e.g., Heuristic 12's scaled sigmoid) appear more robust. Simple implementations of Best Fit (e.g., Heuristic 6, 11) are effective but less nuanced. Heuristics with simple negative remaining capacity or fixed scaling (e.g., 16, 18, 5) are less sophisticated.\n- \nHere's a refined approach to self-reflection for heuristic design:\n\n*   **Keywords:** Precision, Adaptability, Explainability, Performance.\n*   **Advice:** Focus on mechanisms that allow heuristics to adapt to varying data distributions and problem complexities. Document the reasoning behind each heuristic component for maintainability and debugging.\n*   **Avoid:** \"Black box\" logic or overly rigid rules that don't account for edge cases or evolving data. Avoid introducing complexity without a clear performance or accuracy benefit.\n*   **Explanation:** True self-reflection in heuristic design means understanding *why* a strategy works, its limitations, and how it can be improved. It's about building intelligent, interpretable, and robust solutions, not just fast ones.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}