```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for excessive remaining capacity and
    rewards for bins that are already substantially filled.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    suitable_bin_indices = np.where(suitable_bins_mask)[0]

    # Best Fit Score: Prioritize bins that leave the smallest remaining capacity after fitting the item.
    # Higher score for smaller (remaining_capacity - item).
    best_fit_score = 1.0 / (suitable_bins_remain_cap - item + 1e-9)

    # Fill Ratio: Reward bins where the item occupies a larger portion of the *available* space.
    # Higher score for larger item / suitable_bins_remain_cap.
    fill_ratio = item / (suitable_bins_remain_cap + 1e-9)

    # Combined Score: Multiply best_fit_score and fill_ratio. This favors bins that are
    # both a tight fit and where the item significantly utilizes the remaining capacity.
    # This implicitly penalizes bins with large absolute remaining capacity.
    combined_score = best_fit_score * fill_ratio

    # Additional Bonus for "Almost Full" bins:
    # Explicitly reward bins that are already substantially filled (small remaining capacity).
    # This uses a penalty inversely proportional to the remaining capacity.
    # A small `suitable_bins_remain_cap` (but still >= item) gets a higher bonus.
    # We add a small constant to the denominator to avoid division by zero for full bins.
    # We use `item + epsilon` as a reference to avoid issues if a bin is exactly filled by the item.
    almost_full_bonus = 1.0 / (suitable_bins_remain_cap + 1e-9)

    # Final Priority: Combine the efficiency score with the almost-full bonus.
    # The `combined_score` (efficiency) already captures tightness and fill ratio.
    # The `almost_full_bonus` further boosts bins that are simply close to being full.
    # A simple sum gives a weighted effect, where `combined_score` is the primary driver
    # and `almost_full_bonus` acts as a secondary preference for already-full bins.
    # We can tune the weight of the bonus if needed, but a simple sum is a good starting point.
    final_priorities = combined_score + 0.5 * almost_full_bonus # Tunable weight for bonus

    priorities[suitable_bin_indices] = final_priorities

    return priorities
```
