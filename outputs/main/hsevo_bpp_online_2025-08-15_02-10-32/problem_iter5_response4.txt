```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit preference with a score inversely proportional to
    remaining capacity for non-exact fits, prioritizing bins that leave
    minimal waste after placement.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    # Assign very high priority to bins that provide an exact fit
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 1e9  # High score for exact fits
    
    # For bins that are not an exact fit but can still accommodate the item
    non_exact_suitable_mask = suitable_bins_mask & ~exact_fit_mask
    
    if np.any(non_exact_suitable_mask):
        # Calculate the remaining capacity *after* placing the item
        remaining_after_fit = bins_remain_cap[non_exact_suitable_mask] - item
        
        # Prioritize bins with less remaining capacity (i.e., tighter fits)
        # Add a small epsilon to avoid division by zero
        priorities[non_exact_suitable_mask] = 1.0 / (remaining_after_fit + 1e-9)
        
        # Normalize the priorities of non-exact fits to ensure they don't
        # unfairly dominate due to large inverse values. This makes the
        # "best fit" scores relative among themselves.
        non_exact_priorities = priorities[non_exact_suitable_mask]
        if np.sum(non_exact_priorities) > 0:
            priorities[non_exact_suitable_mask] = non_exact_priorities / np.sum(non_exact_priorities)
            
    return priorities
```
