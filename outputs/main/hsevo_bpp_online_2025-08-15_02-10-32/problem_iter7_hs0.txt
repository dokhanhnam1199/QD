import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.00037539337339874483, gap_penalty_factor: float = 2.3417098164597374) -> np.ndarray:
    """
    Combines Best Fit and Worst Fit principles with a dynamic "gap" penalty.
    Prioritizes bins that minimize remaining capacity (Best Fit), but also considers
    bins that have a larger capacity that could accommodate future larger items,
    but penalizes a large "gap" between item size and bin capacity to avoid fragmentation.
    The "gap" penalty is adaptive based on the item's size.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): A numpy array representing the remaining capacity of each bin.
        epsilon (float): A small value to prevent division by zero or log of zero.
        gap_penalty_factor (float): A multiplier for the gap penalty component.

    Returns:
        np.ndarray: A numpy array of priority scores for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Mask for bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # --- Component 1: Best Fit ---
    # Prioritize bins with minimal remaining capacity after packing.
    # This is a negative log of the remaining capacity after packing to maximize.
    best_fit_score = -np.log(suitable_bins_remain_cap - item + epsilon)
    
    # --- Component 2: Dynamic Gap Penalty ---
    # Penalize bins where the difference (gap) between bin capacity and item size is large.
    # The penalty should be related to `gap / item_size`.
    
    gap = suitable_bins_remain_cap - item
    
    # Gap management score: we want to penalize large `gap / item`.
    # Score decreases as `gap/item` increases.
    # A score of 1 for a perfect fit (gap=0) and decreases as the relative gap increases.
    gap_management_score = 1.0 / (1.0 + gap_penalty_factor * (gap / (item + epsilon)))
    
    # Final priority: Product of Best Fit and Gap Management Score.
    priorities[suitable_bins_mask] = best_fit_score * gap_management_score
    
    return priorities
