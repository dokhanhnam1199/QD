```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a dynamic penalty based on the item's size relative
    to the bin's remaining capacity. It prioritizes bins that offer a tight fit
    while also considering the overall distribution of remaining capacities to
    avoid creating excessive "dead space" across the entire bin set.

    This heuristic aims for better adaptability by:
    1. Emphasizing bins that are closer to fitting the item (Best Fit).
    2. Introducing a penalty for bins with a large remaining capacity *relative*
       to the item being packed. This encourages filling bins more completely.
    3. Using a smooth, non-linear penalty function that is less sensitive to
       minor variations in large capacities compared to a simple inverse.
    4. Handling cases where no bins are suitable.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    # If no bins are suitable, return all zeros
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # --- Core "Best Fit" component ---
    # Higher score for smaller remaining capacity (tighter fit)
    # Adding epsilon to avoid division by zero when remaining_cap == item
    best_fit_score = 1.0 / (suitable_bins_remain_cap - item + 1e-6)
    
    # --- Adaptive Penalty component ---
    # Penalize bins with large excess capacity relative to the item.
    # We want to penalize bins where `remaining_capacity - item` is large.
    # Using a function that grows slower for larger excesses, and faster for smaller excesses.
    # A logarithmic-like penalty can achieve this: log(1 + excess)
    # This penalizes bins with large gaps, but not excessively so for slightly larger gaps.
    # Adding 1 to the excess ensures the log is always defined and the penalty is always positive.
    # We also normalize the excess capacity by the *average* remaining capacity of suitable bins
    # to make the penalty relative to the current state of the bins, making it more adaptive.
    
    avg_suitable_remain_cap = np.mean(suitable_bins_remain_cap)
    excess_capacity_relative = (suitable_bins_remain_cap - item) / (avg_suitable_remain_cap + 1e-6)
    
    # Use a capped logarithmic penalty.
    # Capping at a certain value prevents extreme penalties for very large excesses.
    # The `np.clip` ensures the argument to log is at least 1.0, avoiding log(0) or negative.
    # We subtract 1 to make the penalty zero for zero excess.
    penalty_score = np.log1p(np.clip(excess_capacity_relative, 0, 5)) # Cap excess_capacity_relative at 5

    # --- Combination ---
    # We want to maximize the best_fit_score (tighter fit) and minimize the penalty_score (less excess).
    # A multiplicative combination works well: higher best_fit_score is good, lower penalty_score is good.
    # To make lower penalty_score good, we can invert it (1 / penalty_score) or subtract it.
    # Subtracting is often more stable. We aim to maximize `best_fit_score - penalty_score`.
    
    # A more sophisticated combination could be:
    # Prioritize tight fits (high best_fit_score)
    # But heavily penalize bins that are NOT tight fits if there are other tight fits available.
    # Let's use a ratio where a lower penalty term increases the score.
    # We want to maximize `best_fit_score / (1 + penalty_score)` or similar.
    # Or, subtract the penalty: `best_fit_score - lambda * penalty_score`.
    # Let's try a balanced approach: multiply best_fit by an inverse penalty factor.
    # The penalty_score is `log(1 + normalized_excess)`. We want to *reduce* the priority for higher penalty.
    # So, we can use `1 / (1 + penalty_score)`. This gives a value between (0, 1].
    
    # Let's refine the combination:
    # We want to favor tighter fits (higher best_fit_score).
    # We want to penalize large excess capacities.
    # A weighted sum approach: `w1 * best_fit_score - w2 * penalty_score`
    # Or a multiplicative approach: `best_fit_score * (1 - penalty_contribution)`
    #
    # Let's use a multiplicative approach where the penalty term reduces the best-fit score.
    # The penalty_score ranges from 0 upwards. We want to reduce the score as penalty_score increases.
    # A simple reduction factor could be `1 / (1 + penalty_score * weight)`.
    # Let's scale the penalty so it has a noticeable impact.
    
    # Let's combine best_fit with a term that increases for tighter fits (lower excess).
    # The 'penalty_score' is higher for more excess. We want to *reward* less excess.
    # So we want `best_fit_score * (something that increases with less excess)`.
    # The 'excess_capacity_relative' is what we want to minimize.
    # We can transform `excess_capacity_relative` into a score where lower is better.
    # For example, `1.0 / (1.0 + excess_capacity_relative)`.
    
    # Re-thinking: High `best_fit_score` is good. Low `excess_capacity_relative` is good.
    # We want to maximize `best_fit_score` and `1.0 / (1.0 + excess_capacity_relative)`.
    # A simple product: `best_fit_score * (1.0 / (1.0 + excess_capacity_relative))`
    # This rewards bins that are both a good fit and don't have too much excess capacity relative to others.
    
    # Let's try this product.
    # `excess_capacity_relative` is already calculated.
    # Higher `excess_capacity_relative` means worse fit in terms of "dead space".
    # So, `1.0 / (1.0 + excess_capacity_relative)` is a good term that's high for low excess.
    
    fitting_preference = 1.0 / (1.0 + excess_capacity_relative)
    
    # Combine: Reward good best-fit AND good fitting preference (low excess).
    # We want to maximize `best_fit_score * fitting_preference`.
    # This prioritizes bins that are tight fits AND have minimal relative excess capacity.
    final_priorities = best_fit_score * fitting_preference
    
    # Apply priorities to the original array
    priorities[suitable_bins_mask] = final_priorities
    
    return priorities
```
