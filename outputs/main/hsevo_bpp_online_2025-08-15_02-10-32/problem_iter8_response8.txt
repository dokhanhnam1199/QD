```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a penalty for large remaining capacity.
    Prioritizes bins where the item fits snugly and penalizes bins with
    significant excess capacity, promoting efficient bin usage.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    suitable_bin_indices = np.where(suitable_bins_mask)[0]

    # Metric 1: Tightness of fit (similar to Best Fit)
    # High score for small `remaining_capacity - item`.
    # Uses `1.0 / (slack + epsilon)`
    slack = suitable_bins_remain_cap - item
    tightness_score = 1.0 / (slack + 1e-9)

    # Metric 2: Fill ratio of remaining space
    # High score for `item / suitable_bins_remain_cap`.
    # This implicitly penalizes bins with large `suitable_bins_remain_cap`.
    fill_ratio = item / (suitable_bins_remain_cap + 1e-9)
    
    # Combine metrics multiplicatively: Prioritize bins that are both a tight fit
    # AND where the item occupies a significant portion of the remaining capacity.
    # This combination naturally penalizes bins with large `suitable_bins_remain_cap`
    # because `fill_ratio` will be small. The `tightness_score` ensures that among
    # bins with similar fill ratios, the one with less slack is preferred.
    combined_score = tightness_score * fill_ratio

    priorities[suitable_bin_indices] = combined_score

    return priorities
```
