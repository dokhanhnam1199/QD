```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for bins with too much excess capacity.
    Prioritizes bins that are a tight fit, penalizing those with large gaps.
    This aims for better space utilization by avoiding overly large remaining spaces.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Calculate inverse of remaining capacity (similar to Best Fit)
    # Adding a small epsilon to avoid division by zero if remaining_cap == item
    inverse_remaining = 1.0 / (suitable_bins_remain_cap - item + 1e-9)
    
    # Calculate a penalty for bins with a large gap (excess capacity)
    # Using a sigmoid-like function to penalize larger gaps more significantly
    # Normalize remaining capacity to a 0-1 scale for the penalty function
    max_suitable_cap = np.max(suitable_bins_remain_cap)
    min_suitable_cap = np.min(suitable_bins_remain_cap)
    
    # Avoid division by zero if all suitable bins have the same capacity
    if max_suitable_cap == min_suitable_cap:
        normalized_excess = np.zeros_like(suitable_bins_remain_cap)
    else:
        # Capacity of the bin relative to the range of suitable capacities
        # We want to penalize bins with capacity much larger than the item
        # Focus on the gap: suitable_bins_remain_cap - item
        excess_capacity = suitable_bins_remain_cap - item
        normalized_excess = excess_capacity / (max_suitable_cap - item + 1e-9) # Normalize by max possible excess
        
    # Apply a penalty: higher penalty for larger normalized excess
    # A simple inverse of the normalized excess can work as a penalty,
    # or a more aggressive function like exp(-k * normalized_excess)
    # Let's use a simple inverse for now, penalizing bins with larger excess
    # Add a small constant to avoid division by zero for bins that are exact fits after normalization
    penalty = 1.0 / (normalized_excess + 0.1) 
    
    # Combine the "Best Fit" score with the penalty
    # We want to favor smaller remaining capacities (high inverse_remaining)
    # and penalize larger excess capacities (low penalty value, as penalty is 1/(normalized_excess+c))
    # So, we want to maximize inverse_remaining and minimize penalty
    # A simple combination: inverse_remaining / penalty (effectively inverse_remaining * (normalized_excess + c))
    # This gives higher scores to bins that are tight fits AND don't have excessive space after fitting.
    priorities[suitable_bins_mask] = inverse_remaining * penalty
    
    return priorities
```
