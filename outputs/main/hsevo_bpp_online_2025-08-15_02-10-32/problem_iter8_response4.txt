```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with exponential decay on slack and a fullness bonus.
    Prioritizes tight fits and bins that are already well-utilized.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Component 1: Best Fit score (log scale for better discrimination of small slacks)
    # Smaller remaining capacity after fit (slack) is better.
    # Using -log(slack + epsilon) to maximize this.
    slack = suitable_bins_remain_cap - item
    best_fit_score = -np.log(slack + 1e-9)
    
    # Component 2: Tightness score with exponential decay
    # Penalize bins that have large slack relative to their capacity.
    # A bin with small slack relative to the item size is preferred.
    # We want to reward small slack. Using exp(-k * slack) or similar.
    # Let's use a normalized slack and apply exponential decay.
    # Normalize slack by the item size to make it relative.
    # relative_slack = slack / (item + 1e-9)
    # Using a simpler slack_decay: exp(-slack / avg_capacity_of_suitable_bins)
    
    # Calculate a factor that decreases exponentially with slack.
    # Higher values for smaller slack.
    if slack.size > 0:
        # Normalize slack by the maximum possible slack among suitable bins for better scaling.
        # Or, simply use a heuristic decay factor.
        # Let's use a factor that is high for small slack and decays.
        # A simple approach: 1.0 / (1.0 + slack) or exp(-slack) or exp(-slack/C)
        # A good decay: exp(-slack / average_slack_or_item_size)
        avg_suitable_cap = np.mean(suitable_bins_remain_cap)
        decay_factor = np.exp(-slack / (avg_suitable_cap + 1e-9))
    else:
        decay_factor = np.zeros_like(slack)

    # Component 3: Fullness bonus (inverse of remaining capacity before packing)
    # Prefer bins that are already more full (less remaining capacity).
    # This is 1 / (initial_remaining_cap + epsilon).
    fullness_score = 1.0 / (suitable_bins_remain_cap + 1e-9)
    
    # Combine scores multiplicatively:
    # Maximize best_fit_score, maximize decay_factor (prefer small slack), maximize fullness_score.
    # The product naturally encourages bins that satisfy all conditions.
    combined_scores = best_fit_score * decay_factor * fullness_score
    
    priorities[suitable_bins_mask] = combined_scores
    
    return priorities
```
