```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using First Fit strategy.
    Bins that can fit the item are prioritized higher. Among fitting bins,
    those with smaller remaining capacity after fitting the item are preferred (to minimize waste).
    Unfitting bins are given a low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf) # Initialize with very low priority

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate priority
    # Priority is inversely proportional to the remaining capacity AFTER fitting the item.
    # This means bins that are almost full after fitting will have higher priority.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_remain_cap - item

    # Avoid division by zero if remaining_after_fit is 0, assign a very high priority
    # For others, prioritize smaller remaining_after_fit by using 1 / (1 + remaining_after_fit)
    # Adding 1 ensures we don't divide by zero and that smaller remaining capacity gets higher score.
    priorities[can_fit_mask] = 1 / (1 + remaining_after_fit)

    # Optionally, you could add a bonus for fitting into bins that are exactly the right size
    # For instance, if remaining_after_fit is 0, assign an even higher score
    # priorities[can_fit_mask][remaining_after_fit == 0] = 1.0 # Or some other high value

    return priorities
```
