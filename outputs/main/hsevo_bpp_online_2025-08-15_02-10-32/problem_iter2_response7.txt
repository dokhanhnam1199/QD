```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins that are an exact fit, then uses an inverse remaining capacity
    approach for other suitable bins, balancing precision and general effectiveness.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    # Exact fit priority (highest)
    exact_fit_mask = np.isclose(bins_remain_cap, item)
    priorities[exact_fit_mask] = 1e9 # Assign a very high priority for exact fits
    
    # Best fit for non-exact fits
    non_exact_suitable_mask = suitable_bins_mask & ~exact_fit_mask
    
    if np.any(non_exact_suitable_mask):
        remaining_capacities_for_non_exact = bins_remain_cap[non_exact_suitable_mask] - item
        # Using inverse remaining capacity as a measure of "best fit"
        priorities[non_exact_suitable_mask] = 1.0 / (remaining_capacities_for_non_exact + 1e-9)
        
    # Normalize priorities for non-exact fits to avoid overpowering exact fits
    # and to make the best-fit values relative among themselves.
    # We don't normalize the exact fit priorities as they are intended to be dominant.
    if np.any(non_exact_suitable_mask):
        non_exact_priorities = priorities[non_exact_suitable_mask]
        if np.sum(non_exact_priorities) > 0:
            priorities[non_exact_suitable_mask] = non_exact_priorities / np.sum(non_exact_priorities)

    # If no bins are suitable, all priorities remain 0.
    
    return priorities
```
