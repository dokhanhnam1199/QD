```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with a Sigmoid for nuanced bin prioritization.

    Prioritizes bins that offer a tighter fit using a sigmoid function,
    favoring bins where the remaining capacity is closer to the item size.
    """
    eligible_bins_mask = bins_remain_cap >= item
    eligible_bins_cap = bins_remain_cap[eligible_bins_mask]

    if eligible_bins_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Calculate the "tightness" of the fit for eligible bins.
    # A smaller difference means a tighter fit.
    differences = eligible_bins_cap - item

    # Use a sigmoid function to map the differences to a priority score.
    # A smaller difference (tighter fit) should result in a higher priority.
    # We want to invert the difference so smaller differences are "better".
    # The sigmoid function will then map these inverted differences to [0, 1].
    # Scaling factor to control the steepness of the sigmoid.
    scale_factor = 5.0
    # Add a small epsilon to avoid division by zero if difference is 0.
    inverted_differences = 1.0 / (differences + 1e-9)
    
    # Shift the scores so that a perfect fit (difference of 0) gets a high score.
    # Since inverted_differences will be large for small differences,
    # we can directly apply sigmoid or shift if needed.
    # Here, a larger inverted_differences (meaning smaller original difference)
    # should lead to higher priority.
    
    # Sigmoid function: 1 / (1 + exp(-x))
    # We want higher priority for smaller differences.
    # Let's use exp(-difference) as a base for priority.
    # A larger value for exp(-difference) means a smaller difference.
    # Then apply sigmoid to these values.
    
    # Option 1: Directly use exp(-difference) and sigmoid
    # shifted_inverted_differences = -differences * scale_factor
    # priorities = 1 / (1 + np.exp(-shifted_inverted_differences))
    
    # Option 2: Use 1/(difference + epsilon) and sigmoid
    # The 'fit_scores' from v1 can be interpreted as how much "room" is left relative to the item.
    # A score of 1 means exact fit. We want scores close to 1 to have high priority.
    # Let's revisit v1 logic for better interpretation:
    # fit_scores = valid_bins_cap / (valid_bins_cap - item + 1e-9)
    # A higher fit_score means the bin is less full relative to the item size.
    # This is NOT what we want for "tight fit". We want small (valid_bins_cap - item).
    
    # Let's go back to prioritizing smaller differences.
    # We can directly use the negative difference, scaled, within the sigmoid.
    # A smaller difference means a more desirable fit.
    # We want the sigmoid output to be higher for smaller `differences`.
    # `1 / (1 + exp(-k * difference))` will achieve this: as `difference` decreases, `-k * difference` increases, and sigmoid output increases.
    
    scaled_differences = differences * scale_factor
    priorities = 1 / (1 + np.exp(-scaled_differences))

    # Map priorities back to the original bins_remain_cap array
    original_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    original_priorities[eligible_bins_mask] = priorities
    
    return original_priorities
```
