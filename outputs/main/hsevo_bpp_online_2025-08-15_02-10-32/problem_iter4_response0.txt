import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 9.785388546599676e-09, penalty_offset: float = 0.47364999550092823) -> np.ndarray:
    """
    Combines Best Fit with a dynamic penalty based on the item size relative to bin capacity.
    Prioritizes bins that offer a "near-perfect" fit without excessive leftover space,
    dynamically adjusting the penalty based on how "tight" the fit is.
    This aims for better space utilization by being more sensitive to the actual item size.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        epsilon: A small constant to prevent division by zero or log of zero.
        penalty_offset: A constant added to the denominator in the penalty calculation to avoid issues with very tight fits and control penalty aggressiveness.

    Returns:
        A numpy array representing the priority score for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # "Best Fit" component: Prioritize bins with minimum remaining capacity after packing.
    # We use the negative of the remaining capacity to transform minimization into maximization.
    # Add a small epsilon to ensure no division by zero or log(0) if remaining_cap == item.
    # Using log to compress the range and emphasize smaller differences.
    best_fit_score = -np.log(suitable_bins_remain_cap - item + epsilon)
    
    # Dynamic Penalty component: Penalize bins with significantly more capacity than needed.
    # The penalty is higher when the "excess capacity" (remaining_cap - item) is large
    # relative to the item's size. This makes the penalty scale with the item's magnitude.
    
    # Calculate excess ratio: (remaining_cap - item) / item.
    # A bin with exact fit has excess_ratio = 0. A bin with large excess has large excess_ratio.
    # We want to penalize large excess_ratio. So, a good penalty multiplier would be 1 / (excess_ratio + C).
    # The smaller the `1 / (excess_ratio + C)`, the worse the bin.
    # So, we want to maximize `best_fit_score` and maximize `1 / (excess_ratio + C)`.
    # Thus, we can multiply them.
    
    excess_ratio = (suitable_bins_remain_cap - item) / (item + epsilon)
    
    # Add penalty_offset to ensure it's not too aggressive and to avoid division by zero.
    penalty_multiplier = 1.0 / (excess_ratio + penalty_offset)
    
    # Final priority is the product of the best-fit score proxy and the penalty multiplier.
    # Higher best_fit_score is good. Higher penalty_multiplier is good (means low excess ratio).
    priorities[suitable_bins_mask] = best_fit_score * penalty_multiplier
    
    return priorities
