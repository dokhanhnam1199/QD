```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines tightest fit with preference for less empty bins.

    Prioritizes bins that leave minimal remaining capacity after packing (Best Fit),
    while also favoring bins that are already closer to being full (smaller initial remaining capacity).
    """
    epsilon_small = 1e-9
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can fit the item
    fitting_indices = np.where(bins_remain_cap >= item)[0]

    if fitting_indices.size > 0:
        # Calculate remaining capacity after fitting the item
        remaining_after_fit = bins_remain_cap[fitting_indices] - item

        # Strategy:
        # 1. Prioritize bins that are already "almost full" (low initial `bins_remain_cap`).
        #    This is captured by `1.0 / (bins_remain_cap[fitting_indices] + epsilon_small)`.
        #    Bins with smaller remaining capacity get a higher score here.
        # 2. Among those, pick the one that results in the tightest fit (Best Fit).
        #    This is captured by `(-remaining_after_fit)`. Smaller remaining space gets a higher score.

        # Combine these two preferences. A weighted sum is a common approach.
        # Let's use a weight of 1.0 for the "almost full" preference and 0.7 for the "tightest fit" preference.
        # This means we slightly favor bins that are already less empty, and then refine with best fit.
        weight_almost_full = 1.0
        weight_tight_fit = 0.7

        score_almost_full = weight_almost_full * (1.0 / (bins_remain_cap[fitting_indices] + epsilon_small))
        score_tight_fit = weight_tight_fit * (-remaining_after_fit)

        combined_priority = score_almost_full + score_tight_fit
        priorities[fitting_indices] = combined_priority

    return priorities
```
