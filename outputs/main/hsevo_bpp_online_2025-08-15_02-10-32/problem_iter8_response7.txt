```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a dynamic penalty for large relative slack,
    prioritizing bins that are tightly fitting and not excessively empty.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # --- Component 1: Best Fit Score (logarithmic) ---
    # Encourages bins with minimal remaining capacity after packing.
    # Add epsilon for numerical stability when remaining_cap == item.
    best_fit_score = -np.log(suitable_bins_remain_cap - item + 1e-9)
    
    # --- Component 2: Dynamic Gap (Slack) Management Score ---
    # Penalizes bins where the difference (slack) between bin's remaining capacity 
    # and item size is large, relative to the item size itself.
    # Score is 1 for perfect fit (slack=0) and decreases as relative slack increases.
    slack = suitable_bins_remain_cap - item
    gap_management_score = 1.0 / (1.0 + (slack / (item + 1e-9)))
    
    # Combine scores multiplicatively: prioritize bins that are both tightly fitting 
    # and do not have an excessively large relative slack.
    priorities[suitable_bins_mask] = best_fit_score * gap_management_score
    
    return priorities
```
