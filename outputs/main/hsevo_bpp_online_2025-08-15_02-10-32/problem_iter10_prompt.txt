{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes exact fits, then uses a weighted sum of 'most full' and 'tightest fit'.\n\n    This heuristic aims for efficient packing by strongly favoring exact fits,\n    and otherwise balancing the preference for bins that are already nearly full\n    with the preference for minimizing leftover space after packing.\n    \"\"\"\n    epsilon = 1e-9\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item\n    fitting_indices = np.where(bins_remain_cap >= item - epsilon)[0]\n\n    if fitting_indices.size == 0:\n        return priorities # No bin can fit the item\n\n    suitable_bins_remain_cap = bins_remain_cap[fitting_indices]\n\n    # --- Heuristic Design Principles ---\n    # 1. Exact Fit: Give a very high priority to bins that fit the item perfectly\n    #    to avoid any waste in that specific bin. This is crucial for overall efficiency.\n    # 2. Most Full (Preference for less empty bins): Favor bins that are already\n    #    closer to capacity. This can help consolidate items and potentially open\n    #    fewer new bins. Modeled as 1 / (initial remaining capacity + epsilon).\n    # 3. Tightest Fit (Best Fit): After considering fullness, prioritize bins that\n    #    leave minimal remaining capacity after the item is packed. This minimizes\n    #    immediate waste. Modeled as - (remaining capacity - item).\n    # 4. Weighted Combination: Combine 'Most Full' and 'Tightest Fit' preferences\n    #    using weights to balance their contributions. A slightly higher weight\n    #    for 'Most Full' encourages denser packing across bins, while 'Tightest Fit'\n    #    ensures efficient use of the chosen bin.\n\n    # Calculate priorities for fitting bins\n    remaining_after_fit = suitable_bins_remain_cap - item\n\n    # Score for exact fits (very high positive value)\n    exact_fit_mask = np.abs(remaining_after_fit) < epsilon\n    exact_fit_priorities = np.full(fitting_indices.size, 1e9, dtype=float) # High score for exact fits\n\n    # Scores for non-exact fits\n    non_exact_indices_in_subset = np.where(~exact_fit_mask)[0]\n    if non_exact_indices_in_subset.size > 0:\n        non_exact_suitable_bins_remain_cap = suitable_bins_remain_cap[non_exact_indices_in_subset]\n        non_exact_remaining_after_fit = remaining_after_fit[non_exact_indices_in_subset]\n\n        # Preference for bins that are already \"most full\" (lower initial remaining capacity)\n        # Higher score for bins with less remaining capacity. Add epsilon for stability.\n        most_full_score = 1.0 / (non_exact_suitable_bins_remain_cap + epsilon)\n\n        # Preference for \"tightest fit\" (minimal remaining capacity after packing)\n        # Higher score for smaller remaining capacity after item is placed.\n        tightest_fit_score = -non_exact_remaining_after_fit\n\n        # Combine preferences: A weighted sum.\n        # Weight for 'most_full' (e.g., 0.7) encourages using bins that are already somewhat full.\n        # Weight for 'tightest_fit' (e.g., 0.3) refines the choice among those.\n        # These weights can be tuned. A higher weight on 'most_full' leans towards filling up bins.\n        weight_most_full = 0.7\n        weight_tightest_fit = 0.3\n\n        combined_non_exact_priorities = (weight_most_full * most_full_score) + \\\n                                        (weight_tightest_fit * tightest_fit_score)\n\n        # Assign priorities to the fitting bins\n        priorities[fitting_indices[exact_fit_mask]] = exact_fit_priorities[exact_fit_mask]\n        priorities[fitting_indices[non_exact_indices_in_subset]] = combined_non_exact_priorities\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}