```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive fill ratio, favoring tight fits and
    bins where the item significantly utilizes remaining capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    suitable_bin_indices = np.where(suitable_bins_mask)[0]

    # Best Fit Score: Prioritize bins that leave the smallest remaining capacity.
    # Inverse of remaining capacity after fitting the item. Higher is better.
    best_fit_score = 1.0 / (suitable_bins_remain_cap - item + 1e-9)

    # Adaptive Fill Ratio: Rewards bins where the item fills a larger portion of *available* space.
    # This is dynamic, influenced by the capacity of the suitable bin.
    # Higher score for item / suitable_bins_remain_cap.
    fill_ratio = item / (suitable_bins_remain_cap + 1e-9)

    # Combined Score: Multiplies Best Fit and Fill Ratio.
    # This prioritizes bins that are a tight fit AND where the item represents a
    # significant portion of the bin's available capacity, implicitly penalizing
    # bins with large absolute remaining capacity that are still "tight" relative to the item.
    combined_score = best_fit_score * fill_ratio

    # Applying a small constant to ensure scores are positive, as `combined_score` could be very small.
    # This also helps in cases where one component might approach zero.
    final_priorities = combined_score + 1e-6

    priorities[suitable_bin_indices] = final_priorities

    return priorities
```
