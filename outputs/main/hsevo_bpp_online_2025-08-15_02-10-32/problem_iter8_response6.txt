```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (log-scaled) with a dynamic penalty for large excess capacity,
    prioritizing near-perfect fits and efficient bin utilization.
    """
    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Component 1: Best Fit (log-scaled)
    # Prioritize bins that leave minimal remaining capacity after packing.
    # Using log to compress the range and emphasize smaller differences.
    best_fit_score = -np.log(suitable_bins_remain_cap - item + epsilon)
    
    # Component 2: Dynamic Penalty (Excess Capacity Ratio)
    # Penalize bins where the excess capacity (remaining_cap - item) is large
    # relative to the item's size. This encourages using bins that are already
    # somewhat filled rather than very empty ones for smaller items.
    # We want to maximize this component, so we use its inverse.
    excess_capacity_ratio = (suitable_bins_remain_cap - item) / (item + epsilon)
    # A higher ratio (more excess) means a lower score here.
    # Adding 0.2 to the denominator to prevent overly aggressive penalties for small excesses.
    fill_efficiency_score = 1.0 / (excess_capacity_ratio + 0.2) 
    
    # Combine scores multiplicatively: Maximize both Best Fit and Fill Efficiency.
    # A bin is preferred if it offers a good fit AND if the remaining space
    # isn't excessively large compared to the item.
    combined_score = best_fit_score * fill_efficiency_score
    
    priorities[suitable_bins_mask] = combined_score
    
    return priorities
```
