```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a sigmoid-like preference for tighter fits.
    Prioritizes bins that leave minimal remaining capacity after packing,
    but uses a scaled exponential to amplify this preference.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if not np.any(can_fit_mask):
        return priorities # No bin can fit the item
        
    # Calculate remaining capacity after fitting the item
    remaining_capacities = fitting_bins_remain_cap - item
    
    # Use a scaled exponential to prioritize tighter fits (similar to Heuristic 17 but simpler)
    # This amplifies the preference for bins with smaller remaining_capacities
    # Add a small epsilon to avoid division by zero if all remaining capacities are the same
    epsilon = 1e-8
    scaled_preference = np.exp(remaining_capacities)
    
    # Normalize the preference scores so they sum to 1 for the fitting bins
    sum_scaled_preference = np.sum(scaled_preference)
    if sum_scaled_preference > 0:
        normalized_preference = scaled_preference / sum_scaled_preference
    else:
        # If all scaled preferences are zero (e.g., due to very large negative exponents if we used them)
        # assign equal probability to all fitting bins.
        normalized_preference = np.ones_like(fitting_bins_remain_cap) / len(fitting_bins_remain_cap)

    priorities[can_fit_mask] = normalized_preference
    
    return priorities
```
