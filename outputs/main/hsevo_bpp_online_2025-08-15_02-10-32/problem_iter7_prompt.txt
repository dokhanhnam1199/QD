{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and Worst Fit principles with a dynamic \"gap\" penalty.\n    Prioritizes bins that minimize remaining capacity (Best Fit), but also considers\n    bins that have a larger capacity that could accommodate future larger items,\n    but penalizes a large \"gap\" between item size and bin capacity to avoid fragmentation.\n    The \"gap\" penalty is adaptive based on the item's size.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Mask for bins that can accommodate the item\n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    # --- Component 1: Best Fit ---\n    # Prioritize bins with minimal remaining capacity after packing.\n    # This is a negative log of the remaining capacity after packing to maximize.\n    # Add epsilon for numerical stability when remaining_cap == item.\n    best_fit_score = -np.log(suitable_bins_remain_cap - item + 1e-9)\n    \n    # --- Component 2: Worst Fit (modified) ---\n    # Consider bins that have more excess capacity, potentially for larger future items.\n    # We want to give a *slight* preference to bins with more \"room\" but not too much.\n    # We can represent this as a score related to the excess capacity, but we want to\n    # avoid extremely large remaining capacities which might lead to fragmentation.\n    # Let's use a score that increases with excess capacity but saturates.\n    # A simple approach is a linear or logarithmic increase in the excess capacity itself.\n    # Let's use the excess capacity directly, scaled.\n    # `excess_capacity = suitable_bins_remain_cap - item`\n    # We want to favor bins where `excess_capacity` is moderate.\n    # A simple score could be `excess_capacity / (item + epsilon)`. High ratio means large excess relative to item.\n    # We want to favor lower excess *relative* to item size.\n    \n    # --- Component 3: Dynamic Gap Penalty ---\n    # Penalize bins where the difference (gap) between bin capacity and item size is large.\n    # This gap represents wasted space. The penalty should be stronger for larger gaps.\n    # The penalty should also be 'dynamic' in the sense that a gap of 5 units might be small\n    # for an item of size 100, but large for an item of size 5.\n    # So, the penalty should be related to `gap / item_size`.\n    \n    gap = suitable_bins_remain_cap - item\n    \n    # Penalty score: we want to penalize large `gap / item`.\n    # So, a good penalty multiplier would be `1 / (gap / item + C)` or `item / (gap + C)`.\n    # This multiplier should be applied to a score we want to maximize.\n    # A higher multiplier means a better bin (smaller relative gap).\n    \n    # Let's combine Best Fit and a modified Worst Fit idea.\n    # We want to maximize `best_fit_score`.\n    # For the \"room\" aspect, we can consider `gap`.\n    # If `gap` is very small, it's good for Best Fit.\n    # If `gap` is moderate, it might be good for accommodating future items.\n    # If `gap` is very large, it's bad (fragmentation).\n    \n    # Let's try to maximize:\n    # 1. `best_fit_score` (higher is better)\n    # 2. A term that favors moderate gaps over very large gaps.\n    #    Consider `gap_score = 1.0 / (gap / item + epsilon)` -- this favors smaller gaps.\n    #    This is similar to the penalty in v1.\n    \n    # Let's refine the interaction:\n    # We want to maximize the \"goodness\" of a fit.\n    # Goodness = (Score from Best Fit) * (Score from Gap Management)\n    \n    # Best Fit score: `-np.log(remaining_after_packing)` as before.\n    # Gap Management Score: We want to penalize large gaps relative to item size.\n    # So, a score that decreases as `gap/item` increases.\n    # Let's use `1 / (1 + (gap / (item + 1e-9)))`.\n    # This score is 1 for a perfect fit (gap=0) and decreases as the relative gap increases.\n    gap_management_score = 1.0 / (1.0 + (gap / (item + 1e-9)))\n    \n    # Final priority: Product of Best Fit and Gap Management Score.\n    # This encourages bins that are \"tight\" (high best_fit_score) while also\n    # not having excessively large relative gaps.\n    priorities[suitable_bins_mask] = best_fit_score * gap_management_score\n    \n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}