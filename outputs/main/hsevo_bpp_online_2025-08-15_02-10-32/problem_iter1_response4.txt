```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Exact Fit First strategy: prioritize bins that can fit the item perfectly,
    and among those, prefer bins that have less remaining capacity (to fill them up).
    If no bin can fit the item exactly, fall back to First Fit logic (preferring
    the first bin that can accommodate the item).
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Exact Fit: Prioritize bins where item fits perfectly
    exact_fit_indices = np.where(bins_remain_cap == item)[0]
    if len(exact_fit_indices) > 0:
        # Assign a high priority to exact fits, with higher priority for less remaining capacity
        # (although for exact fit, remaining capacity is 0)
        # We use negative of capacity to make higher remaining capacity have lower priority
        priorities[exact_fit_indices] = 1000 - bins_remain_cap[exact_fit_indices]
        return priorities
    
    # First Fit if no exact fit found
    first_fit_indices = np.where(bins_remain_cap >= item)[0]
    if len(first_fit_indices) > 0:
        # Assign priority based on how "tight" the fit is.
        # Bins with less remaining capacity are preferred.
        # Add a small constant to differentiate from exact fits, and use negative capacity.
        priorities[first_fit_indices] = 500 - bins_remain_cap[first_fit_indices]
    
    return priorities
```
