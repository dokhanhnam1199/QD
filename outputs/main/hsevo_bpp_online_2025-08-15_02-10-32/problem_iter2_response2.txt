```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Exact Fit First with a scaled Best Fit using exponential decay.
    Prioritizes exact fits, then bins with the tightest fit, scaled for
    better discrimination among close fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Exact Fit: Highest priority
    exact_fit_indices = np.where(bins_remain_cap == item)[0]
    if len(exact_fit_indices) > 0:
        priorities[exact_fit_indices] = 1e9  # Very high priority
        # Optional: Add a slight preference for lower capacity if multiple exact fits exist
        # priorities[exact_fit_indices] += 1000 - bins_remain_cap[exact_fit_indices] 
        return priorities
    
    # Best Fit with exponential scaling for remaining candidates
    suitable_bins_mask = bins_remain_cap > item
    suitable_bins_capacities = bins_remain_cap[suitable_bins_mask]
    
    if suitable_bins_capacities.size > 0:
        relative_capacities = suitable_bins_capacities - item
        # Use exponential decay to strongly prefer tighter fits
        # Add a small constant to avoid division by zero or extremely large values if relative_capacities are close to 0
        # Scaling factor to prevent overflow and control the steepness of the decay
        scale_factor = np.mean(relative_capacities) if np.mean(relative_capacities) > 0 else 1.0
        exp_priorities = np.exp(-relative_capacities / scale_factor)
        
        # Normalize priorities to be between 0 and 1 for the suitable bins
        sum_exp_priorities = np.sum(exp_priorities)
        if sum_exp_priorities > 0:
            priorities[suitable_bins_mask] = exp_priorities / sum_exp_priorities
        else: # Handle case where all relative capacities are extremely large, leading to exp_priorities being 0
            priorities[suitable_bins_mask] = 1.0 / len(suitable_bins_capacities)

    return priorities
```
