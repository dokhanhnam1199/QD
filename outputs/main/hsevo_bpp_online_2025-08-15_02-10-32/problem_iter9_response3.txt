```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a "Tightest Fit with Capacity Bias" heuristic.
    Prioritizes bins that minimize leftover capacity after packing (tightest fit),
    but adds a bias towards bins that have more remaining capacity overall,
    to prevent prematurely filling up potentially useful larger bins.
    This aims for a balance between immediate tightness and future flexibility.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]

    # 1. Tightest Fit Component (minimizing leftover space)
    # We want to maximize the negative of the leftover space.
    # Higher values are better (less leftover).
    leftover_space = suitable_bins_remain_cap - item
    # Using a small epsilon to avoid log(0) if leftover_space is 0.
    # The log compresses the range, making differences more granular.
    tightest_fit_score = -np.log(leftover_space + 1e-9)

    # 2. Capacity Bias Component (preferring bins with more capacity)
    # We want to give a boost to bins that have significantly more capacity,
    # even if they aren't the absolute tightest fit. This prevents scenarios
    # where we fill up slightly larger bins first, leaving only very small
    # bins for larger items later.
    # This score should be higher for bins with larger remaining capacity.
    # Using a scaled inverse of remaining capacity to create a "bias bonus".
    # A linear scaling is simpler and less prone to issues than logarithmic.
    # We want to boost larger capacities. A simple linear increase is good.
    # However, to avoid large absolute values dominating, we can scale it.
    # A simple approach is to add a fraction of the bin's remaining capacity.
    # The "+1" is to ensure non-zero values and prevent issues when remaining capacity is small.
    capacity_bias_score = suitable_bins_remain_cap

    # Combine the scores:
    # We want to maximize both tightest_fit_score and capacity_bias_score.
    # A simple additive combination can work.
    # To balance them, we can scale the capacity bias.
    # Let's assume a reasonable scaling factor for the bias, e.g., 0.1.
    # This means a unit of leftover capacity reduction is 10x more important than a unit of bin capacity.
    # The exact scaling factor can be a hyperparameter.
    scaling_factor = 0.1
    combined_score = tightest_fit_score + scaling_factor * capacity_bias_score

    priorities[suitable_bins_mask] = combined_score

    return priorities
```
