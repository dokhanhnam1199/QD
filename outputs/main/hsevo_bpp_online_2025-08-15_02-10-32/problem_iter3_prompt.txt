{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit with a penalty for bins with too much excess capacity.\n    Prioritizes bins that are a tight fit, penalizing those with large gaps.\n    This aims for better space utilization by avoiding overly large remaining spaces.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(suitable_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]\n    \n    # Calculate inverse of remaining capacity (similar to Best Fit)\n    # Adding a small epsilon to avoid division by zero if remaining_cap == item\n    inverse_remaining = 1.0 / (suitable_bins_remain_cap - item + 1e-9)\n    \n    # Calculate a penalty for bins with a large gap (excess capacity)\n    # Using a sigmoid-like function to penalize larger gaps more significantly\n    # Normalize remaining capacity to a 0-1 scale for the penalty function\n    max_suitable_cap = np.max(suitable_bins_remain_cap)\n    min_suitable_cap = np.min(suitable_bins_remain_cap)\n    \n    # Avoid division by zero if all suitable bins have the same capacity\n    if max_suitable_cap == min_suitable_cap:\n        normalized_excess = np.zeros_like(suitable_bins_remain_cap)\n    else:\n        # Capacity of the bin relative to the range of suitable capacities\n        # We want to penalize bins with capacity much larger than the item\n        # Focus on the gap: suitable_bins_remain_cap - item\n        excess_capacity = suitable_bins_remain_cap - item\n        normalized_excess = excess_capacity / (max_suitable_cap - item + 1e-9) # Normalize by max possible excess\n        \n    # Apply a penalty: higher penalty for larger normalized excess\n    # A simple inverse of the normalized excess can work as a penalty,\n    # or a more aggressive function like exp(-k * normalized_excess)\n    # Let's use a simple inverse for now, penalizing bins with larger excess\n    # Add a small constant to avoid division by zero for bins that are exact fits after normalization\n    penalty = 1.0 / (normalized_excess + 0.1) \n    \n    # Combine the \"Best Fit\" score with the penalty\n    # We want to favor smaller remaining capacities (high inverse_remaining)\n    # and penalize larger excess capacities (low penalty value, as penalty is 1/(normalized_excess+c))\n    # So, we want to maximize inverse_remaining and minimize penalty\n    # A simple combination: inverse_remaining / penalty (effectively inverse_remaining * (normalized_excess + c))\n    # This gives higher scores to bins that are tight fits AND don't have excessive space after fitting.\n    priorities[suitable_bins_mask] = inverse_remaining * penalty\n    \n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nHere's a refined approach to self-reflection for heuristic design:\n\n*   **Keywords:** Precision, Adaptability, Explainability, Performance.\n*   **Advice:** Focus on mechanisms that allow heuristics to adapt to varying data distributions and problem complexities. Document the reasoning behind each heuristic component for maintainability and debugging.\n*   **Avoid:** \"Black box\" logic or overly rigid rules that don't account for edge cases or evolving data. Avoid introducing complexity without a clear performance or accuracy benefit.\n*   **Explanation:** True self-reflection in heuristic design means understanding *why* a strategy works, its limitations, and how it can be improved. It's about building intelligent, interpretable, and robust solutions, not just fast ones.\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}