```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a preference for bins that utilize remaining capacity well.
    Penalizes bins with excessive remaining capacity after fitting.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    suitable_bin_indices = np.where(suitable_bins_mask)[0]

    # Metric 1: Tightness of fit (Best Fit heuristic component)
    # Prioritizes bins where remaining capacity is closest to item size.
    # Add epsilon to avoid division by zero for exact fits.
    tightness_score = 1.0 / (suitable_bins_remain_cap - item + 1e-9)

    # Metric 2: Fill Ratio of remaining capacity
    # Prioritizes bins where the item occupies a larger portion of the current remaining space.
    # This helps in packing more densely.
    fill_ratio_score = item / (suitable_bins_remain_cap + 1e-9)

    # Combine metrics multiplicatively:
    # We want both a tight fit AND a good fill ratio of the current remaining capacity.
    # This multiplicative approach naturally penalizes bins with very large remaining capacities
    # because the fill_ratio_score will be small for them, even if the tightness_score is high.
    # It also favors bins where the item itself is large relative to the remaining space.
    combined_score = tightness_score * fill_ratio_score

    # Assign the calculated scores to the appropriate bins
    priorities[suitable_bin_indices] = combined_score

    return priorities
```
