```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item
    
    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Component 1: Best Fit (minimizing waste)
    # Prioritize bins where remaining capacity after packing is minimized.
    # This directly targets reducing wasted space in the chosen bin.
    # Using negative to convert minimization to maximization.
    # Adding a small epsilon to prevent log(0) for perfect fits.
    best_fit_score = -np.log(suitable_bins_remain_cap - item + 1e-9)
    
    # Component 2: Adaptability to Item Size (Dynamic Prioritization)
    # If the item is very large, we might be more forgiving of slightly larger remaining capacity
    # if it means fitting the item at all. Conversely, for small items, we want a very tight fit.
    # This component aims to adjust priority based on the "difficulty" of fitting the current item.
    # A simple way to capture this is to consider the ratio of item size to bin capacity.
    # However, we are already considering the remaining capacity.
    # A better approach: penalize bins that have *excessively* more capacity than the item,
    # especially when the item itself is small.
    
    # Calculate the ratio of available capacity to item size.
    # Higher ratio means more "slack" or less "tightness".
    # We want to penalize bins with high slack, especially for smaller items.
    # We want to favor bins where suitable_bins_remain_cap is close to item.
    
    # Let's use a penalty based on the remaining capacity *relative to the item size*.
    # If `remaining_cap - item` is large compared to `item`, it's a bad fit.
    # We want to maximize `1 / ( (remaining_cap - item) / item + C )`
    # Where C is a small constant to avoid division by zero and control sensitivity.
    
    # Calculate the "slack ratio": (remaining_cap_after_packing) / item_size
    # We want to penalize high slack ratios.
    slack_ratio = (suitable_bins_remain_cap - item) / (item + 1e-9)
    
    # A penalty that decreases as slack_ratio increases.
    # `1 / (slack_ratio + C)` ensures that bins with low slack (good fits) get higher multipliers.
    # Adding a base value to `slack_ratio` ensures that even perfect fits (slack_ratio=0) don't yield infinity.
    # A small constant `C` (e.g., 0.1) provides a baseline level of preference for tighter fits.
    adaptability_multiplier = 1.0 / (slack_ratio + 0.1)
    
    # Component 3: Robustness against "almost full" bins
    # Sometimes, a bin that is almost full but can still fit the item is preferable
    # to a bin that has a lot of space but is also a "best fit" in terms of minimal waste.
    # This can help consolidate items more effectively, preventing a situation where
    # many bins are left with small residual capacities.
    # We can add a bonus to bins that are closer to being full (but can still fit the item).
    # This can be represented by the ratio of item size to the bin's remaining capacity *before* packing.
    # Higher ratio means the item takes up a larger proportion of the bin's current available space.
    
    # Ratio of item size to bin's remaining capacity (before packing)
    # Higher value means item is a "significant" portion of what's left.
    # We want to boost scores for bins where this ratio is high.
    fill_ratio_bonus_factor = item / (bins_remain_cap[suitable_bins_mask] + 1e-9)
    
    # Apply a transformation to make this a bonus (e.g., add directly, or use as multiplier).
    # Adding a scaled version seems more robust than multiplying, as it complements the best-fit score.
    # The scaling factor (e.g., 0.5) can be tuned.
    fill_bonus = 0.5 * fill_ratio_bonus_factor

    # Combine the scores:
    # We want to maximize `best_fit_score`.
    # We want to maximize `adaptability_multiplier` (which favors tighter fits).
    # We want to add `fill_bonus` to encourage using bins that are already somewhat full.
    # A simple additive combination with appropriate scaling is often effective.
    # Alternatively, a multiplicative approach can balance the factors.
    # Let's try a combined approach:
    # Base score is best_fit_score.
    # Adjust it with adaptability_multiplier.
    # Add fill_bonus.

    # The `best_fit_score` is already a log. The `adaptability_multiplier` is a ratio.
    # Multiplying them might scale too aggressively.
    # Let's try a weighted sum or a combination where the adaptability is a multiplier
    # on the best-fit and the fill_bonus is an additive boost.
    
    # Prioritize bins that are close to the item size, and add a bonus if they are
    # already somewhat utilized.
    
    # Revisit: the goal is to select *one* bin. The priority score should reflect
    # the desirability of that bin.
    # 1. Best Fit: Minimize `remaining_cap - item`.
    # 2. Adaptability: Favor tighter fits, penalize large gaps relative to item size.
    # 3. Fill Ratio Bonus: Favor bins that are already somewhat full.

    # Let's combine Best Fit and Adaptability using multiplication as before,
    # but refine the adaptability component.
    # The `adaptability_multiplier` `1.0 / (slack_ratio + 0.1)` is good.
    
    # Let's integrate the "fill ratio bonus" more directly into the main score.
    # Consider the remaining capacity *after* packing `R = suitable_bins_remain_cap - item`.
    # We want to minimize `R`.
    # We also want to minimize `R / item`.
    # And we want to maximize `item / suitable_bins_remain_cap` (if `suitable_bins_remain_cap` is the capacity before packing).

    # Let's use a combined score that aims to maximize:
    # `(-log(R + eps)) * (1 / (R / item + eps)) + C * (item / suitable_bins_remain_cap)`
    # This is becoming complex. Let's aim for clarity and robustness.

    # Simplified approach:
    # Score = (Best Fit component) * (Adaptability component) + (Fill Bonus component)

    # Best Fit component: `1 / (remaining_cap_after_packing + epsilon)`
    # This is an inverse relationship, higher value for smaller waste.
    # Using inverse instead of log for simpler combination.
    best_fit_component = 1.0 / (suitable_bins_remain_cap - item + 1e-9)

    # Adaptability component: `item / (remaining_cap_after_packing + epsilon)`
    # This rewards fits where the item takes up a larger fraction of the *remaining* space.
    # Essentially, how "full" the bin gets *after* packing.
    adaptability_component = item / (suitable_bins_remain_cap - item + 1e-9)

    # Fill Bonus component: `item / (original_bin_capacity + epsilon)`
    # This rewards bins that were already more full before this item.
    # We need original capacities, which are not directly passed. We can use the `bins_remain_cap`
    # before filtering suitable bins, but this requires re-indexing.
    # A proxy could be the `suitable_bins_remain_cap` themselves (representing their state *before* packing this item).
    # So, `fill_bonus_component` ~ `item / suitable_bins_remain_cap`.
    # However, `suitable_bins_remain_cap` are already filtered.
    # Let's focus on making `priority_v1` better.

    # Re-evaluating `priority_v1`:
    # `best_fit_score = -np.log(suitable_bins_remain_cap - item + 1e-9)`: Good, favors minimal waste.
    # `excess_ratio = (suitable_bins_remain_cap - item) / (item + 1e-9)`: Measures excess capacity relative to item size.
    # `penalty_multiplier = 1.0 / (excess_ratio + 0.2)`: Higher multiplier for lower excess ratio (tighter fit).
    # `priorities[suitable_bins_mask] = best_fit_score * penalty_multiplier`: Combines minimal waste with tight fit preference.

    # Improvement idea: Make the `penalty_multiplier` more sensitive to the *absolute* amount of waste,
    # not just relative to the item size. A large absolute waste is bad regardless of item size.
    # Also, consider the "quality" of the best fit itself. A bin with very little waste might be prioritized higher.

    # New components for v2:
    # 1. Fit Quality (similar to Best Fit): Emphasize bins with minimal `waste = remaining_cap - item`.
    #    Use `1 / (waste + epsilon)` for direct maximization of quality.
    # 2. Fit Tightness (Adaptability): Emphasize bins where the item fills a larger proportion of the *remaining* space.
    #    Use `item / (remaining_cap + epsilon)` where `remaining_cap` is `suitable_bins_remain_cap`.
    # 3. Global Bin Utilization (Fill Bonus): Prefer bins that are already more full. This is tricky without original capacity.
    #    We can proxy this by looking at `suitable_bins_remain_cap`. A smaller `suitable_bins_remain_cap`
    #    (before packing) means the bin was more utilized.
    #    So, we want to boost bins with smaller `suitable_bins_remain_cap`.
    #    Let's use `1 / suitable_bins_remain_cap` as a bonus, but scaled.

    # Component 1: Fit Quality
    # Higher value for smaller waste.
    waste = suitable_bins_remain_cap - item
    fit_quality = 1.0 / (waste + 1e-9)

    # Component 2: Fit Tightness (relative to remaining space)
    # Higher value if item occupies a larger fraction of the available space.
    fit_tightness = item / (suitable_bins_remain_cap + 1e-9)

    # Component 3: Bin Utilization Bonus (proxy: smaller remaining capacity before packing)
    # Higher value for bins that were more utilized (smaller `suitable_bins_remain_cap`).
    # Add a small constant to the denominator to avoid division by zero and control sensitivity.
    # Let's scale this bonus to avoid dominating other components.
    utilization_bonus = 0.5 * (1.0 / (suitable_bins_remain_cap + 1e-9)) # Scaled bonus

    # Combine components:
    # A common heuristic combination is multiplicative for related scores and additive for bonuses.
    # Let's multiply Fit Quality and Fit Tightness, then add the Utilization Bonus.
    # This means we want bins that are both good fits (low waste) AND tight fits (item fills space well).
    # The bonus then adds a preference for bins that were generally more full.

    combined_score = (fit_quality * fit_tightness) + utilization_bonus

    # Assign scores to the original priority array
    priorities[suitable_bins_mask] = combined_score

    return priorities
```
