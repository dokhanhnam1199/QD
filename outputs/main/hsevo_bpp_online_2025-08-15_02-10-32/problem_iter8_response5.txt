```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines exact fit prioritization with a weighted score favoring tight fits
    and bins that are already relatively full.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    fitting_indices = np.where(can_fit_mask)[0]
    
    if not np.any(fitting_indices):
        return priorities

    fitting_bins_caps = bins_remain_cap[fitting_indices]
    
    # --- Component 1: Exact Fit Priority ---
    # Assign a very high score to bins that provide an exact fit.
    exact_fit_mask = fitting_bins_caps == item
    priorities[fitting_indices[exact_fit_mask]] = 1e10
    
    # --- Component 2: Tight Fit (Best Fit) for Non-Exact Fits ---
    # Calculate remaining capacity after placing the item in non-exact fitting bins.
    non_exact_fitting_indices_in_fitting = np.where(~exact_fit_mask)[0]
    non_exact_fitting_bins_caps = fitting_bins_caps[~exact_fit_mask]
    
    if non_exact_fitting_bins_caps.size > 0:
        remaining_after_fit = non_exact_fitting_bins_caps - item
        
        # Score based on how little is left over. Higher score for smaller remaining capacity.
        # Adding epsilon to avoid division by zero if remaining_after_fit is 0 (though handled by exact_fit).
        # Using 1 / (1 + remaining_after_fit) to map smaller remaining capacity to higher scores.
        tight_fit_scores = 1.0 / (1.0 + remaining_after_fit)
        
        # --- Component 3: Preference for "Almost Full" Bins ---
        # Favor bins that have less remaining capacity initially among the suitable ones.
        # This encourages filling up bins more.
        # Using inverse of initial remaining capacity, scaled.
        almost_full_scores = 0.5 * (1.0 / (bins_remain_cap[fitting_indices[~exact_fit_mask]] + 1e-9))

        # Combine scores for non-exact fits: weighted sum
        # Weighting tight_fit_scores more heavily (e.g., 0.8) than almost_full_scores (e.g., 0.2).
        combined_non_exact_score = 0.8 * tight_fit_scores + 0.2 * almost_full_scores
        
        # Scale these combined scores to be less than the exact fit priority.
        # Normalize combined_non_exact_score to [0, 1] and scale down.
        if np.max(combined_non_exact_score) > 0:
            scaled_combined_scores = (combined_non_exact_score / np.max(combined_non_exact_score)) * 1e9
        else:
            scaled_combined_scores = np.zeros_like(combined_non_exact_score)
            
        priorities[fitting_indices[~exact_fit_mask]] = scaled_combined_scores
        
    return priorities
```
