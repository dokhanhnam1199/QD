```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive slack penalty, prioritizing tight fits and
    dynamically adjusting penalty based on item size relative to bin state.
    """
    priorities = np.zeros_like(bins_remain_cap)
    suitable_bins_mask = bins_remain_cap >= item

    if not np.any(suitable_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[suitable_bins_mask]
    
    # Best Fit component: Maximize -(remaining_capacity - item)
    # This directly rewards the smallest remaining capacity after packing.
    best_fit_score = -(suitable_bins_remain_cap - item)

    # Adaptive Slack Penalty component: Penalize bins where slack (remaining_cap - item) is large relative to item size.
    # The penalty is scaled by how important tightness is (item size relative to average bin state).
    # Calculate slack ratio: (remaining_cap - item) / item
    slack_ratio = (suitable_bins_remain_cap - item) / (item + 1e-9)

    # Calculate an adaptive weight for the slack penalty.
    # If the item is large relative to the average remaining capacity of suitable bins,
    # we increase the penalty's influence.
    avg_suitable_remain_cap = np.mean(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else 1.0
    weight_for_tightness = np.clip(item / (avg_suitable_remain_cap + 1e-9), 0.1, 2.0) # Clip to avoid extreme values

    # The adaptive slack score is higher for smaller slack ratios, scaled by weight.
    # We want to ADD this to the best_fit_score.
    adaptive_slack_score = weight_for_tightness * (1.0 / (slack_ratio + 1.0))
    
    # Combine the scores additively. This prioritizes minimizing waste (best_fit_score)
    # and further rewards tight fits adaptively.
    final_priorities = best_fit_score + adaptive_slack_score
    
    priorities[suitable_bins_mask] = final_priorities
    
    return priorities
```
