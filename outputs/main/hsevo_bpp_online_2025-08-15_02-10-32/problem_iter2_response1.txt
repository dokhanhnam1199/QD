```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit (tightness) with a sigmoid for prioritizing near-exact fits.

    Prioritizes bins that are almost full but can fit the item, using a sigmoid
    to smooth the preference for tighter fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[fit_mask]

    # Heuristic: Prioritize bins that are "almost full" but can still fit the item.
    # This is inspired by Best Fit, but uses a sigmoid to give a smoother preference
    # to bins where remaining_capacity - item is small.
    # The input to the sigmoid is scaled such that tighter fits result in a higher score.
    # We use -(valid_bins_remain_cap - item) to make smaller remaining space
    # correspond to larger (less negative) sigmoid inputs.

    # A simple scaling to avoid extreme sigmoid values too quickly.
    # The range of (bins_remain_cap - item) can vary. Let's normalize it.
    # For bins that fit, the "slack" is valid_bins_remain_cap - item.
    # We want to prioritize smaller slack.
    slack = valid_bins_remain_cap - item

    # Normalize slack to be between 0 and 1 for sigmoid input.
    # If all slack is the same, avoid division by zero.
    if slack.size > 0:
        min_slack = np.min(slack)
        max_slack = np.max(slack)

        if max_slack == min_slack:
            normalized_slack = np.zeros_like(slack)
        else:
            # Map slack to a range where sigmoid can differentiate well.
            # We want smaller slack to map to a higher priority.
            # So, map min_slack (tightest fit) to a high sigmoid input,
            # and max_slack (loosest fit) to a low sigmoid input.
            # Consider the inverse of slack: 1 / (slack + epsilon) is similar to Best Fit.
            # Let's use a transformation like: 1 - (slack / max_slack) or similar.
            # A sigmoid on -(slack) might be good: larger negative means smaller slack.
            # sigmoid_input = -slack
            # To control steepness and range, we can use:
            steepness = 5.0 # Tune this parameter
            # We want smaller slack to give higher priority.
            # So, we want a higher value when slack is small.
            # Transform slack to a value that is higher for smaller slack.
            # Example: max_slack - slack. Then normalize.
            transformed_slack = max_slack - slack
            if max_slack - min_slack > 0:
                normalized_transformed_slack = transformed_slack / (max_slack - min_slack)
            else:
                normalized_transformed_slack = np.zeros_like(slack)

            # Use sigmoid on the transformed slack. High transformed_slack (low original slack)
            # should map to a high sigmoid output.
            # We can use `steepness * (normalized_transformed_slack - 0.5)` to center around 0.5.
            sigmoid_input = steepness * (normalized_transformed_slack - 0.5)
            priorities[fit_mask] = 1 / (1 + np.exp(-sigmoid_input))
        
    return priorities
```
