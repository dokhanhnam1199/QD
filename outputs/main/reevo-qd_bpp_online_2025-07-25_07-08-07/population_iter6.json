[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score, utilization score, and capacity score to prioritize bins.\n    The fit score measures how well the item fits into each bin, the utilization score measures how full each bin is,\n    and the capacity score measures the remaining capacity of each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    utilization_score = 1 - (bins_remain_cap / (bins_remain_cap + item))\n    \n    # Calculate a score based on the capacity of each bin\n    capacity_score = bins_remain_cap\n    \n    # Calculate the final priority score as a combination of fit_score, utilization_score, and capacity_score\n    priority_score = utilization_score - (fit_score / item) + (1 / (1 + capacity_score))\n    \n    # Ensure that bins with insufficient remaining capacity have a low priority\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    # Normalize the priority scores to ensure they sum up to 1\n    priority_score = priority_score - np.min(priority_score)\n    priority_score = priority_score / np.sum(priority_score)\n    \n    return priority_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    exact fits, and minimize waste ratio, combining multiple scores with adjustable weights.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = bins_remain_cap - item\n    \n    # Set all negative differences to zero, as these bins cannot hold the item\n    capacity_diff = np.maximum(capacity_diff, 0)\n    \n    # Calculate the priority score as the inverse of the capacity difference\n    # A smaller capacity difference results in a higher priority score\n    tight_packing_score = 1 / (capacity_diff + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Favor exact fits by adding a bonus to the priority score\n    exact_fit_score = np.where(capacity_diff == 0, 1e6, 0)\n    \n    # Calculate the waste ratio for each bin\n    waste_ratio = capacity_diff / bins_remain_cap\n    \n    # Favor bins with a lower waste ratio by subtracting the waste ratio from the priority score\n    waste_ratio_score = -waste_ratio\n    \n    # Combine the scores with adjustable weights\n    weights = np.array([0.6, 0.2, 0.2])  # Adjust the weights as needed\n    priority_scores = weights[0] * tight_packing_score + weights[1] * exact_fit_score + weights[2] * waste_ratio_score\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 235.53074858920888,
    "mi": 70.3565711555274,
    "token_count": 179.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score and utilization score to prioritize bins.\n    The fit score measures how well the item fits into each bin, and the utilization score measures how full each bin is.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fit_score = np.abs(bins_remain_cap - item) / item\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    utilization_score = 1 - (bins_remain_cap / (bins_remain_cap + item))\n    \n    # Calculate the final priority score as the combination of fit_score and utilization_score\n    priority_score = utilization_score - fit_score\n    \n    # Ensure that bins with insufficient remaining capacity have a low priority\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 270.0,
    "mi": 66.42322586804642,
    "token_count": 189.0,
    "exec_success": true
  }
]