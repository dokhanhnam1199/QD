[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score, utilization score, and capacity score to prioritize bins.\n    The fit score measures how well the item fits into each bin, the utilization score measures how full each bin is,\n    and the capacity score measures the remaining capacity of each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    utilization_score = 1 - (bins_remain_cap / (bins_remain_cap + item))\n    \n    # Calculate a score based on the capacity of each bin\n    capacity_score = bins_remain_cap\n    \n    # Calculate the final priority score as a combination of fit_score, utilization_score, and capacity_score\n    priority_score = utilization_score - (fit_score / item) + (1 / (1 + capacity_score))\n    \n    # Ensure that bins with insufficient remaining capacity have a low priority\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    # Normalize the priority scores to ensure they sum up to 1\n    priority_score = priority_score - np.min(priority_score)\n    priority_score = priority_score / np.sum(priority_score)\n    \n    return priority_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on tight packing and favors bins with more remaining capacity.\n    The goal is to minimize the number of bins used by packing items as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = bins_remain_cap - item\n    \n    # Set all negative differences to infinity, as these bins cannot hold the item\n    capacity_diff = np.where(capacity_diff < 0, np.inf, capacity_diff)\n    \n    # Calculate the priority score as the inverse of the capacity difference\n    # A smaller capacity difference results in a higher priority score\n    priority_scores = 1 / (capacity_diff + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Favor bins with more remaining capacity relative to other bins by adding a bonus to the priority score\n    bonus = bins_remain_cap / (np.sum(bins_remain_cap) + 1e-9)  # Avoid division by zero\n    priority_scores *= (1 + bonus)\n    \n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have just enough capacity to pack the item, \n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity, \n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Identify bins that can hold the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority scores\n    # Exact fit bins get a high priority score\n    # Other bins get a priority score based on their remaining capacity (lower remaining capacity gets higher priority)\n    priority = np.where(valid_bins, \n                        np.where(np.isclose(bins_remain_cap, item),  # exact fit\n                                 np.inf, \n                                 1 / (bins_remain_cap - item + 1)),  # minimize remaining capacity\n                        -np.inf)\n    \n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score, utilization score, and remaining capacity score to prioritize bins.\n    The fit score measures how well the item fits into each bin, the utilization score measures how full each bin is,\n    and the remaining capacity score encourages the use of bins with sufficient remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    utilization_score = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # Bins with sufficient remaining capacity are preferred\n    remaining_capacity_score = np.where(bins_remain_cap >= item, 1, 0)\n    \n    # Calculate the final priority score as the combination of fit_score, utilization_score, and remaining_capacity_score\n    priority_score = remaining_capacity_score * (utilization_score - fit_score / item)\n    \n    # Ensure that bins with insufficient remaining capacity have a low priority\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, weights: dict = None) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins based on multiple factors:\n    - how well the item fits into each bin (fit_score)\n    - the remaining capacity of each bin (capacity_score)\n    - the bin's fullness, prioritizing bins that are more full (fullness_score)\n    \n    The weights of these factors can be adjusted based on specific problem requirements.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        weights: Dictionary with keys 'fit_score', 'capacity_score', 'fullness_score' to specify weights.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if weights is None:\n        weights = {'fit_score': 0.3, 'capacity_score': 0.2, 'fullness_score': 0.5}\n\n    # Calculate a score based on how well the item fits into each bin\n    # A lower score is preferred as it means the item fits better\n    fit_score = np.abs(bins_remain_cap - item) / item\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    capacity_score = -bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Calculate a score based on the bin's fullness\n    # A higher fullness score is preferred as it means the bin is more full\n    fullness_score = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the final priority score as the combination of fit_score and capacity_score\n    # Weights can be adjusted based on specific problem requirements\n    priority_score = (weights['fit_score'] * fit_score + \n                      weights['capacity_score'] * capacity_score + \n                      weights['fullness_score'] * fullness_score)\n    \n    # Ensure that bins with negative remaining capacity have a high penalty\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.7, beta: float = 0.3) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score and capacity score with adjustable weights.\n    It prioritizes bins based on how well the item fits into each bin and the remaining capacity of each bin.\n    The weights can be adjusted based on specific problem requirements.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        alpha: Weight for capacity score.\n        beta: Weight for fit score.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    # A lower score is preferred as it means the item fits better\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    capacity_score = -bins_remain_cap\n    \n    # Calculate the final priority score as the combination of fit_score and capacity_score\n    priority_score = alpha * capacity_score - beta * (fit_score / item)\n    \n    # Ensure that bins with negative remaining capacity have a high penalty\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste ratio.\n    The goal is to pack items as tightly as possible to minimize waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_adding_item = np.maximum(bins_remain_cap - item, 0)\n\n    # Bins with less capacity than the item get zero priority\n    valid_bins = bins_remain_cap >= item\n\n    # Calculate the waste ratio for each bin\n    waste_ratio = np.where(valid_bins, remaining_cap_after_adding_item / item, np.inf)\n\n    # Invert the waste ratio to get the priority score, use a small value to avoid division by zero\n    priority_score = np.where(valid_bins, 1 / (waste_ratio + 1e-9), -np.inf)\n\n    # Ensure bins with less capacity than the item get the lowest priority\n    priority_score = np.where(valid_bins, priority_score, -np.inf)\n\n    return priority_score",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no valid bins, return zeros\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Calculate the priority scores for valid bins\n    # Prioritize bins with the least remaining capacity\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (bins_remain_cap[valid_bins] + 1)  # add 1 to avoid division by zero\n    \n    # Normalize the priority scores\n    priorities = priorities / np.sum(priorities)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no valid bins, return zeros\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Calculate the priority scores for valid bins\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = -1 * bins_remain_cap[valid_bins]  # prioritize bins with least remaining capacity\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    The closer the ratio is to 1, the higher the priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Replace zero item size with a small value to avoid division by zero\n    item = np.maximum(item, 1e-9)\n    \n    # Calculate the ratio of the remaining capacity to the item size for each bin\n    ratio = bins_remain_cap / item\n    \n    # Calculate the priority score for each bin based on the ratio\n    # The closer the ratio is to 1, the higher the priority\n    priority_score = -np.abs(ratio - 1)\n    \n    # Set priority to -inf for bins that cannot hold the item\n    priority_score = np.where(bins_remain_cap < item, -np.inf, priority_score)\n    \n    # Normalize the priority scores to ensure they sum up to 1\n    priority_score = priority_score - np.max(priority_score)\n    priority_score = np.exp(priority_score) / np.sum(np.exp(priority_score))\n    \n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 72.33974351909447,
    "mi": 72.16081837779959,
    "token_count": 123.0,
    "exec_success": true
  }
]