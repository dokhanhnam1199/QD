[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "mi": 100.0,
    "token_count": 32.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item.\n    The goal is to minimize the number of bins used by packing items as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    capacity_diff = bins_remain_cap - item\n    \n    # Set all negative differences to zero, as these bins cannot hold the item\n    capacity_diff = np.maximum(capacity_diff, 0)\n    \n    # Calculate the priority score as the inverse of the capacity difference\n    # A smaller capacity difference results in a higher priority score\n    priority_scores = 1 / (capacity_diff + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Favor bins with more remaining capacity by adding a bonus to the priority score\n    bonus = bins_remain_cap / np.sum(bins_remain_cap)\n    priority_scores *= (1 + bonus)\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item) / item))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize bins with the least remaining capacity if no exact fit is found\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap - item + 1), 1 / bins_remain_cap)\n    \n    # If there are exact fit bins, boost their priority to 1 and scale others down\n    if np.sum(exact_fit_bins) > 0:\n        priority = np.where(exact_fit_bins, 1, priority / (1 + np.sum(priority)))\n        priority = np.where(exact_fit_bins, 1, priority)\n    \n    return priority",
    "response_id": 2,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, filter out bins that cannot accommodate the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # For bins that can accommodate the item, prioritize those with the least remaining capacity\n    priorities = np.where(feasible_bins, -bins_remain_cap, -np.inf)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, we calculate the ratio of the remaining capacity and the item size.\n    # We add a small value to the denominator to avoid division by zero.\n    ratio = bins_remain_cap / (item + 1e-8)\n\n    # If a bin has less capacity than the item, we set its priority to zero.\n    ratio[bins_remain_cap < item] = 0\n\n    # We use the ratio as the priority score.\n    # Since we want to prioritize bins with just enough capacity, we use the inverse of the ratio.\n    score = np.where(ratio > 0, 1 / ratio, 0)\n\n    # If all bins have less capacity than the item, we return all zeros.\n    # This is equivalent to starting a new bin for the item.\n    if np.all(score == 0):\n        return np.zeros_like(bins_remain_cap)\n    else:\n        return score",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the capacity difference between each bin and the item size\n    capacity_diff = bins_remain_cap - item\n    \n    # Initialize priority scores with the capacity difference\n    priority_scores = capacity_diff\n    \n    # For bins with enough capacity, increase their priority scores based on their remaining capacity\n    priority_scores[capacity_diff >= 0] += (np.max(bins_remain_cap) - bins_remain_cap)[capacity_diff >= 0]\n    \n    # Ensure that bins with exactly enough capacity have higher priority scores\n    priority_scores[capacity_diff == 0] += np.max(bins_remain_cap)\n    \n    return priority_scores",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    hold the item. It avoids overfilling bins and minimizes waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Calculate the wasted capacity if the item is added to the bin\n    wasted_cap = np.maximum(0, -remaining_cap)\n    \n    # Favor bins with no wasted capacity\n    no_waste = (wasted_cap == 0).astype(int)\n    \n    # Calculate the priority score for each bin\n    priority_score = no_waste / (wasted_cap + 1e-8)\n    \n    return priority_score",
    "response_id": 6,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher remaining capacity compared to the item size, it gets a higher priority.\n    Additionally, bins with lower remaining capacities are prioritized over those with higher remaining capacities,\n    to ensure that bins are fully utilized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priority_scores = np.where(valid_bins, \n                               bins_remain_cap / item - (bins_remain_cap / bins_remain_cap.sum()), \n                               -np.inf)\n    return priority_scores",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # initialize priority scores to zero\n    priority_scores = np.zeros_like(bins_remain_cap)\n    \n    # calculate the ratio of remaining capacity to item size for each bin\n    ratios = bins_remain_cap / item\n    \n    # assign high priority to bins that can hold the item\n    priority_scores[bins_remain_cap >= item] = ratios[bins_remain_cap >= item]\n    \n    # introduce randomness to break ties and promote diversity\n    priority_scores[bins_remain_cap >= item] += np.random.rand(sum(bins_remain_cap >= item))\n    \n    return priority_scores",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\n    \nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n4\n1\n64.52932501298082\n55.58374226588717\n67\n"
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have enough capacity to hold the item and \n    penalize bins that would be overfilled. If multiple bins have enough capacity, it favors the one \n    with the least remaining capacity to minimize the number of partially filled bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the feasibility of each bin (i.e., does the bin have enough capacity to hold the item)\n    feasibility = bins_remain_cap >= item\n    \n    # If a bin is feasible, its priority is inversely proportional to the remaining capacity\n    # This encourages the use of bins that are almost full to minimize the number of partially filled bins\n    priorities = np.where(feasibility, 1 / bins_remain_cap, 0)\n    \n    # Set priority to -np.inf for bins that would be overfilled\n    priorities_non_feasible = -np.inf * np.ones_like(bins_remain_cap)\n    priorities_non_feasible[feasibility] = 0\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item.\n    The goal is to minimize the number of bins used by packing items as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_adding_item = np.maximum(bins_remain_cap - item, 0)\n\n    # Calculate the ratio of remaining capacity after adding the item to the remaining capacity before adding the item\n    # This ratio is used as the priority score; bins with lower ratios are preferred\n    ratio = np.where(bins_remain_cap > 0, remaining_cap_after_adding_item / bins_remain_cap, np.inf)\n\n    # The priority score is the inverse of the ratio; higher priority scores indicate lower ratios\n    priority_score = np.where(ratio > 0, 1 / ratio, np.inf)\n\n    return priority_score",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # If the item size is zero, we can add it to any bin without any effect\n    if item == 0:\n        return np.ones_like(bins_remain_cap)\n    \n    # Calculate the ratio of remaining capacity to item size\n    capacity_ratio = bins_remain_cap / item\n    \n    # Bins with less capacity than the item get zero priority\n    priority = np.where(capacity_ratio >= 1, capacity_ratio, 0)\n    \n    return priority",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(bins_remain_cap - item)))\n    return priority_score",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity and \n    can still fit the item. If a bin cannot fit the item, its priority is set to -1.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the available space in each bin that can fit the item\n    available_space = np.where(bins_remain_cap >= item, bins_remain_cap, -1)\n    \n    # Prioritize bins with the least available space\n    priority = -available_space\n    \n    # Set the priority of bins that cannot fit the item to -1\n    priority = np.where(available_space == -1, -1, priority)\n    \n    # Maximize priority to ensure bins with available space have a higher priority than those without\n    priority = np.where(priority == -1, -np.inf, priority)\n    \n    return priority",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no valid bins, return zeros\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Calculate the priority scores for valid bins\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = 1 / (bins_remain_cap[valid_bins] - item + 1e-6)  # 1e-6 for numerical stability\n    \n    return priorities",
    "response_id": 15,
    "obj": 4.198244914240141,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # For bins that are not exact fit, prioritize bins with the least remaining capacity\n    non_exact_fit_bins = ~exact_fit_bins\n    priority = np.where(non Exact_fit_bins, 1 / (bins_remain_cap + 1e-6), priority)\n    \n    return priority",
    "response_id": 16,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 29\n    priority = np.where(non Exact_fit_bins, 1 / (bins_remain_cap + 1e-6), priority)\n                        ^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\n4\n1\n64.52932501298082\n55.58374226588717\n67\n"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    trying to fill them up as much as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that have just enough capacity to pack the item\n    exact_brim_bins = bins_remain_cap == item\n    \n    # Find bins that have enough capacity to pack the item but are not exactly full\n    less_than_brim_bins = (bins_remain_cap > item) & (~exact_brim_bins)\n    \n    # Assign high priority to bins that are exactly full, since they don't waste space\n    priorities = np.where(exact_brim_bins, 2, 0)\n    \n    # Assign medium priority to bins that are not exactly full but still have enough capacity\n    priorities = np.where(less_than_brim_bins, priorities + 1, priorities)\n    \n    # Break ties by assigning lower priority to bins with more remaining capacity\n    priorities -= bins_remain_cap / bins_remain_cap.sum()\n    \n    return priorities",
    "response_id": 17,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 31, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'subtract' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n4\n1\n64.52932501298082\n55.58374226588717\n67\n"
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # bins that have enough capacity to hold the item\n    valid_bins = (bins_remain_cap >= item)\n    \n    # set priority of invalid bins to 0\n    priority = np.where(valid_bins, (bins_remain_cap - item) / (bins_remain_cap + 1e-9), 0)\n    \n    # to break ties (when multiple bins have the same remaining capacity), prioritize the bin with the most remaining capacity\n    priority += np.maximum(0, np.where(valid_bins, bins_remain_cap - np.max(bins_remain_cap[valid_bins]) + 1e-9, 0))\n    \n    return priority",
    "response_id": 18,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has a higher ratio, it is more likely to be selected.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of remaining capacity to item size for each bin\n    ratio = bins_remain_cap / item\n    \n    # To avoid division by zero when the item size is zero, replace zero item sizes with a small value\n    ratio = np.where(ratio == np.inf, 0, ratio)\n    \n    # Get the priority score for each bin based on the ratio\n    priority_score = -np.abs(ratio - 1)\n    \n    return priority_score",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Prioritize exact fit bins\n    priority = np.where(exact_fit_bins, 1.0, 0.0)\n    \n    # For non-exact fit bins, prioritize bins with the least remaining capacity\n    priority[~exact_fit_bins] = 1.0 / (1.0 + bins_remain_cap[~exact_fit_bins] - min_required_cap)\n    \n    return priority",
    "response_id": 20,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have the least amount of remaining capacity compared to the item size,\n    maximizing the chance of filling the bin to capacity. If multiple bins have the same difference, the bin with the \n    most remaining capacity is chosen.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # calculate the difference between the remaining capacity and the item size\n    diff = np.abs(bins_remain_cap - item)\n    \n    # calculate the priority score, with bins having the smallest difference and largest remaining capacity getting higher scores\n    priority = diff * -1 + bins_remain_cap\n    \n    return priority",
    "response_id": 21,
    "obj": 4.487435181491823,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to accommodate the item.\n    It tries to minimize the number of bins used by trying to fill the bins as much as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the \"best fit\" score for each bin, where best fit is defined as the minimum difference between the bin's remaining capacity and the item's size\n    best_fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Calculate the \"ensation\" score for each bin, where ensation is defined as the ratio of the item's size to the bin's remaining capacity\n    ensation_scores = np.where(bins_remain_cap > 0, item / bins_remain_cap, 0)\n\n    # Calculate the final priority score for each bin, which combines the best fit and ensation scores\n    priority_scores = np.where(best_fit_scores > -np.inf, best_fit_scores + ensation_scores, -np.inf)\n\n    return priority_scores",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to accommodate the item.\n    It gives a higher priority to bins with more remaining capacity, but penalizes bins that are almost full or would be overfilled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity of each bin and the item size\n    cap_diff = bins_remain_cap - item\n    \n    # Assign a high priority to bins that have just enough capacity to accommodate the item\n    priority = np.where(cap_diff >= 0, cap_diff, -1)\n    \n    # Give a higher priority to bins with more remaining capacity\n    priority = np.where(cap_diff >= 0, priority + bins_remain_cap, priority)\n    \n    # Penalize bins that would be overfilled by assigning them a very low priority\n    priority = np.where(cap_diff < 0, -np.inf, priority)\n    \n    return priority",
    "response_id": 23,
    "obj": 149.30195452732352,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it favors bins with the least remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the capacity difference between each bin and the item\n    diff = bins_remain_cap - item\n    \n    # For bins that can contain the item, favor those with the least remaining capacity\n    can_contain = diff >= 0\n    priority = np.where(can_contain, -diff, -1000)  # use -1000 to ensure bins that cannot contain have a very low priority\n    \n    # If there are multiple bins with the same minimum remaining capacity, use a secondary priority to favor bins with larger capacity\n    secondary_priority = np.where(can_contain, bins_remain_cap, 0)\n    return np.where(priority == np.max(priority), secondary_priority, priority)",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    hold the item, minimizing wasted space. If no such bin exists, it favors bins with \n    the least remaining capacity, which can help to distribute items evenly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if there are bins that can exactly fit the item\n    exact_fit_bins = np.where(bins_remain_cap >= item)[0]\n    \n    if len(exact_fit_bins) > 0:\n        # Assign high priority to exact fit bins\n        priority = np.where(bins_remain_cap >= item, 1.0 - (bins_remain_cap - item) / bins_remain_cap, 0.0)\n    else:\n        # If no exact fit, prioritize bins with the least remaining capacity\n        priority = 1.0 - bins_remain_cap\n    \n    return priority",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to \n    hold the item, to avoid splitting the item across multiple bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Create an array to store the priority scores\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # Iterate over each bin\n    for i in range(len(bins_remain_cap)):\n        # Calculate the priority score based on how well the item fits in the bin\n        # A higher priority is given to bins that are closer to being full\n        if bins_remain_cap[i] >= item:\n            priority_scores[i] = 1 - (bins_remain_cap[i] - item) / bins_remain_cap[i]\n        else:\n            # Assign a low priority score to bins that are too small to hold the item\n            priority_scores[i] = -1\n\n    return priority_scores",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # If the item size is zero, we can add it to any bin without decreasing the remaining capacity\n    if item == 0:\n        return np.ones_like(bins_remain_cap)\n    \n    # Calculate the ratio of the remaining capacity and the item size for each bin\n    ratios = np.where(bins_remain_cap >= item, bins_remain_cap / item, 0)\n    \n    # Prioritize bins with ratios closest to 1 (i.e., with just enough capacity to hold the item)\n    return np.where(ratios > 0, -(ratios - 1), 0)",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to encourage the packing of items into bins \n    where the item size is as close as possible to the remaining capacity. It also \n    takes into account the desire to keep the number of bins used as low as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fits_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    capacity_score = -bins_remain_cap\n    \n    # Calculate the final priority score as the combination of fits_score and capacity_score\n    priority_score = capacity_score - 2 * (fits_score / item)\n    \n    # Ensure that bins with negative remaining capacity have a high penalty\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins that have just enough capacity to pack the item,\n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity,\n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score based on the difference and remaining capacity\n    priority = 1 / (diff + 1) + bins_remain_cap / (np.max(bins_remain_cap) + 1)\n    \n    return priority",
    "response_id": 29,
    "obj": 86.27842042281613,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 64.52932501298082,
    "mi": 55.58374226588717,
    "token_count": 67.0,
    "exec_success": true
  }
]