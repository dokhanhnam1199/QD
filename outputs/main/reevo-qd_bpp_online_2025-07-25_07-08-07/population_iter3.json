[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no valid bins, return zeros\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Calculate the priority scores for valid bins\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = -1 * (bins_remain_cap[valid_bins] - item)  # negate the remaining capacity to prioritize smaller ones\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity to the item size\n    ratio = bins_remain_cap / item\n    \n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(1 - ratio)))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how tightly they can pack the item.\n    The goal is to minimize waste by packing items as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_adding_item = np.maximum(bins_remain_cap - item, 0)\n\n    # Bins with less capacity than the item get zero priority\n    valid_bins = bins_remain_cap >= item\n\n    # Calculate the ratio of remaining capacity after adding the item to the item size\n    # This ratio represents how much waste will be left after packing the item\n    waste_ratio = np.where(valid_bins, remaining_cap_after_adding_item / item, np.inf)\n\n    # Calculate the inverse of the waste ratio; higher priority scores indicate lower waste ratios\n    priority_score = np.where(waste_ratio > 0, 1 / waste_ratio, np.inf)\n\n    # Ensure bins with less capacity than the item get zero priority\n    priority_score = np.where(valid_bins, priority_score, 0)\n\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins based on how well the item fits into each bin\n    and the remaining capacity of each bin. It encourages the packing of items into bins where the item \n    size is as close as possible to the remaining capacity, while also keeping the number of bins used \n    as low as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    # A lower score is preferred as it means the item fits better\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    capacity_score = -bins_remain_cap\n    \n    # Calculate the final priority score as the combination of fit_score and capacity_score\n    # Weights can be adjusted based on specific problem requirements\n    priority_score = 0.7 * capacity_score - 0.3 * (fit_score / item)\n    \n    # Ensure that bins with negative remaining capacity have a high penalty\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste of space and efficient use of space.\n    It favors bins where the item size is closest to the remaining capacity, and then considers the remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, \n                         1 / (diff + 1) + bins_remain_cap / (np.max(bins_remain_cap) + 1), \n                         -np.inf)\n    \n    return priority",
    "response_id": 4,
    "obj": 86.27842042281613,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score and utilization score to prioritize bins.\n    The fit score measures how well the item fits into each bin, and the utilization score measures how full each bin is.\n    Bins with a better fit and higher utilization are prioritized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fits_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    utilization_score = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the final priority score as the combination of fits_score and utilization_score\n    priority_score = utilization_score - fits_score / item\n    \n    # Ensure that bins with insufficient remaining capacity have a low priority\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # If the item size is zero, we can add it to any bin without decreasing the remaining capacity\n    if item == 0:\n        return np.ones_like(bins_remain_cap)\n    \n    # Calculate the ratio of the remaining capacity and the item size for each bin\n    ratios = np.where(bins_remain_cap >= item, np.abs(bins_remain_cap / item - 1), np.inf)\n    \n    # Prioritize bins with ratios closest to 0 (i.e., with just enough capacity to hold the item)\n    return -ratios\n\n# Test the function\nitem = 10.0\nbins_remain_cap = np.array([5.0, 10.0, 15.0, 20.0])\npriority_scores = priority_v2(item, bins_remain_cap)\nprint(priority_scores)",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have just enough capacity to pack the item, \n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity, \n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Calculate the priority scores\n    # Exact fit bins get a high priority score (1)\n    # Other bins get a priority score based on their remaining capacity (lower remaining capacity gets higher priority)\n    priority = np.where(exact_fit_bins, 1, 1 / bins_remain_cap)\n    \n    # If there are no exact fit bins, make sure the priorities sum up to 1\n    if np.sum(exact_fit_bins) == 0:\n        priority = priority / np.sum(priority)\n    \n    return priority",
    "response_id": 7,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    The closer the ratio is to 1, the higher the priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Replace zero item size with a small value to avoid division by zero\n    item = np.maximum(item, 1e-9)\n    \n    # Calculate the priority score for each bin based on the ratio\n    priority_score = -np.abs(bins_remain_cap / item - 1)\n    \n    # Set priority to -inf for bins that cannot hold the item\n    priority_score = np.where(bins_remain_cap < item, -np.inf, priority_score)\n    \n    return priority_score",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the item size to the remaining capacity.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins where item size is closer to the remaining capacity\n                              1 / (1 + np.abs(1 - item / bins_remain_cap)))\n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    taking into account the item-bin capacity ratio, tight packing, and weighted scoring.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the item-bin capacity ratio for each bin\n    ratio = item / (bins_remain_cap + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Calculate the weighted scoring based on the ratio\n    weighted_score = 1 / (1 + np.abs(ratio - 1))  # Favor bins with a ratio close to 1\n    \n    # Calculate the tight packing score based on the remaining capacity of each bin\n    tight_packing_score = bins_remain_cap / np.sum(bins_remain_cap)  # Favor bins with more remaining capacity\n    \n    # Calculate the final priority score by combining the weighted scoring and tight packing score\n    priority_scores = weighted_score * (1 + tight_packing_score)\n    \n    # Set priority scores to zero for bins that cannot hold the item\n    priority_scores[bins_remain_cap < item] = 0\n    \n    return priority_scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "mi": 68.58700582298387,
    "token_count": 107.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    prioritizing tight packing and weighted scoring based on the item-bin capacity ratio.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the item size to the remaining capacity of each bin\n    capacity_ratios = item / (bins_remain_cap + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Calculate the priority score as the weighted sum of the capacity ratio and the inverse of the capacity difference\n    capacity_diff = bins_remain_cap - item\n    capacity_diff = np.maximum(capacity_diff, 0)\n    priority_scores = capacity_ratios * (1 / (capacity_diff + 1e-9))\n    \n    # Favor bins with a higher capacity ratio and a smaller capacity difference\n    priority_scores = priority_scores / np.sum(priority_scores) if np.sum(priority_scores) > 0 else np.ones_like(priority_scores)\n    \n    return priority_scores",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "mi": 68.58700582298387,
    "token_count": 107.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    taking into account the item-bin capacity ratio, tight packing, and weighted scoring.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the item-bin capacity ratio for each bin\n    capacity_ratio = bins_remain_cap / item\n    \n    # Set all ratios to zero for bins that cannot hold the item\n    capacity_ratio = np.where(bins_remain_cap < item, 0, capacity_ratio)\n    \n    # Calculate the tight packing score as the inverse of the capacity ratio\n    # A smaller capacity ratio results in a higher priority score\n    tight_packing_score = 1 / (capacity_ratio + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Calculate the weighted scoring based on the remaining capacity of each bin\n    # Favor bins with more remaining capacity by adding a bonus to the priority score\n    bonus = bins_remain_cap / np.sum(bins_remain_cap)\n    weighted_score = tight_packing_score * (1 + bonus)\n    \n    # Calculate the final priority score as a weighted sum of the tight packing score and the weighted score\n    priority_scores = 0.7 * tight_packing_score + 0.3 * weighted_score\n    \n    return priority_scores",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "mi": 68.58700582298387,
    "token_count": 107.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    taking into account the item-bin capacity ratio, tight packing, and weighted scoring.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the item-bin capacity ratio for each bin\n    ratio = item / (bins_remain_cap + 1e-9)  # Add a small value to avoid division by zero\n    \n    # Calculate the weighted scoring based on the ratio\n    weighted_score = 1 / (1 + np.abs(ratio - 1))  # Favor bins with a ratio close to 1\n    \n    # Calculate the tight packing score based on the remaining capacity of each bin\n    tight_packing_score = bins_remain_cap / np.sum(bins_remain_cap)  # Favor bins with more remaining capacity\n    \n    # Calculate the final priority score by combining the weighted scoring and tight packing score\n    priority_scores = weighted_score * (1 + tight_packing_score)\n    \n    # Set all negative differences to zero, as these bins cannot hold the item\n    priority_scores[bins_remain_cap - item < 0] = 0\n    \n    return priority_scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "mi": 68.58700582298387,
    "token_count": 107.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to favor bins that have just enough capacity to pack the item,\n    taking into account the item-bin capacity ratio, tight packing, and weighted scoring.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the item-bin capacity ratio for each bin\n    capacity_ratio = bins_remain_cap / item\n    \n    # Set all ratios to zero where the bin cannot hold the item\n    capacity_ratio[bins_remain_cap < item] = 0\n    \n    # Calculate the priority score based on the capacity ratio\n    # Favor bins with a ratio close to 1 (i.e., just enough capacity to pack the item)\n    priority_scores = np.where(capacity_ratio > 0, 1 / (np.abs(capacity_ratio - 1) + 1e-9), 0)\n    \n    # Add a weighted scoring bonus for bins with more remaining capacity\n    weighted_bonus = bins_remain_cap / (np.sum(bins_remain_cap) + 1e-9)\n    priority_scores *= (1 + weighted_bonus)\n    \n    return priority_scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 127.43782540330756,
    "mi": 68.58700582298387,
    "token_count": 107.0,
    "exec_success": true
  }
]