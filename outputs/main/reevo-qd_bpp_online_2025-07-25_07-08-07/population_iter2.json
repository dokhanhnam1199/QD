[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins with the least remaining capacity that can still accommodate the item.\n    This helps in minimizing the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # If no valid bins, return zeros\n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    # Calculate the priority scores for valid bins\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = -1 * (bins_remain_cap[valid_bins] - item)  # negate the remaining capacity to prioritize smaller ones\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of the remaining capacity to the item size\n    ratio = bins_remain_cap / item\n    \n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins that can just hold the item\n                              1 / (1 + np.abs(1 - ratio)))\n    return priority_score",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on how tightly they can pack the item.\n    The goal is to minimize waste by packing items as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin after adding the item\n    remaining_cap_after_adding_item = np.maximum(bins_remain_cap - item, 0)\n\n    # Bins with less capacity than the item get zero priority\n    valid_bins = bins_remain_cap >= item\n\n    # Calculate the ratio of remaining capacity after adding the item to the item size\n    # This ratio represents how much waste will be left after packing the item\n    waste_ratio = np.where(valid_bins, remaining_cap_after_adding_item / item, np.inf)\n\n    # Calculate the inverse of the waste ratio; higher priority scores indicate lower waste ratios\n    priority_score = np.where(waste_ratio > 0, 1 / waste_ratio, np.inf)\n\n    # Ensure bins with less capacity than the item get zero priority\n    priority_score = np.where(valid_bins, priority_score, 0)\n\n    return priority_score",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function is designed to prioritize bins based on how well the item fits into each bin\n    and the remaining capacity of each bin. It encourages the packing of items into bins where the item \n    size is as close as possible to the remaining capacity, while also keeping the number of bins used \n    as low as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    # A lower score is preferred as it means the item fits better\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    capacity_score = -bins_remain_cap\n    \n    # Calculate the final priority score as the combination of fit_score and capacity_score\n    # Weights can be adjusted based on specific problem requirements\n    priority_score = 0.7 * capacity_score - 0.3 * (fit_score / item)\n    \n    # Ensure that bins with negative remaining capacity have a high penalty\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on minimizing waste of space and efficient use of space.\n    It favors bins where the item size is closest to the remaining capacity, and then considers the remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    valid_bins = bins_remain_cap >= item\n    priority = np.where(valid_bins, \n                         1 / (diff + 1) + bins_remain_cap / (np.max(bins_remain_cap) + 1), \n                         -np.inf)\n    \n    return priority",
    "response_id": 4,
    "obj": 86.27842042281613,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function combines the fit score and utilization score to prioritize bins.\n    The fit score measures how well the item fits into each bin, and the utilization score measures how full each bin is.\n    Bins with a better fit and higher utilization are prioritized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate a score based on how well the item fits into each bin\n    fits_score = np.abs(bins_remain_cap - item)\n    \n    # Calculate a score based on the remaining capacity of each bin\n    # A lower remaining capacity is preferred as it means the bin is more full\n    utilization_score = bins_remain_cap / (bins_remain_cap + item)\n    \n    # Calculate the final priority score as the combination of fits_score and utilization_score\n    priority_score = utilization_score - fits_score / item\n    \n    # Ensure that bins with insufficient remaining capacity have a low priority\n    priority_score[bins_remain_cap < item] = -np.inf\n    \n    return priority_score",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity and the item size.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # If the item size is zero, we can add it to any bin without decreasing the remaining capacity\n    if item == 0:\n        return np.ones_like(bins_remain_cap)\n    \n    # Calculate the ratio of the remaining capacity and the item size for each bin\n    ratios = np.where(bins_remain_cap >= item, np.abs(bins_remain_cap / item - 1), np.inf)\n    \n    # Prioritize bins with ratios closest to 0 (i.e., with just enough capacity to hold the item)\n    return -ratios\n\n# Test the function\nitem = 10.0\nbins_remain_cap = np.array([5.0, 10.0, 15.0, 20.0])\npriority_scores = priority_v2(item, bins_remain_cap)\nprint(priority_scores)",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins that have just enough capacity to pack the item, \n    minimizing waste of space. If no such bin exists, it prioritizes bins with the least remaining capacity, \n    encouraging efficient use of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the minimum remaining capacity required to pack the item\n    min_required_cap = item\n    \n    # Identify bins that have just enough capacity to pack the item\n    exact_fit_bins = bins_remain_cap >= min_required_cap\n    \n    # Calculate the priority scores\n    # Exact fit bins get a high priority score (1)\n    # Other bins get a priority score based on their remaining capacity (lower remaining capacity gets higher priority)\n    priority = np.where(exact_fit_bins, 1, 1 / bins_remain_cap)\n    \n    # If there are no exact fit bins, make sure the priorities sum up to 1\n    if np.sum(exact_fit_bins) == 0:\n        priority = priority / np.sum(priority)\n    \n    return priority",
    "response_id": 7,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the remaining capacity to the item size.\n    The closer the ratio is to 1, the higher the priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Replace zero item size with a small value to avoid division by zero\n    item = np.maximum(item, 1e-9)\n    \n    # Calculate the priority score for each bin based on the ratio\n    priority_score = -np.abs(bins_remain_cap / item - 1)\n    \n    # Set priority to -inf for bins that cannot hold the item\n    priority_score = np.where(bins_remain_cap < item, -np.inf, priority_score)\n    \n    return priority_score",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on the ratio of the item size to the remaining capacity.\n    If a bin has just enough capacity to hold the item, it gets the highest priority.\n    Bins with less capacity than the item get zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins with less capacity than the item get zero priority\n    priority_score = np.where(bins_remain_cap < item, 0, \n                              # Priority is higher for bins where item size is closer to the remaining capacity\n                              1 / (1 + np.abs(1 - item / bins_remain_cap)))\n    return priority_score",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 49.82892142331044,
    "mi": 69.05071046915909,
    "token_count": 62.0,
    "exec_success": true
  }
]