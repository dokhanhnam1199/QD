{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity, best-fit, and dynamic weights.\"\"\"\n\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    max_cap = np.max(bins_remain_cap)\n    capacity_priority = bins_remain_cap / (max_cap + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    best_fit_priority = np.where(feasible, -gap, -1e9)\n    best_fit_priority = np.where(feasible, (best_fit_priority - np.min(best_fit_priority[feasible])) / (np.max(best_fit_priority[feasible]) - np.min(best_fit_priority[feasible]) + 1e-9), -1e9)\n\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n\n    bin_fill_level = 1 - (bins_remain_cap / max_cap)\n    avg_fill = np.mean(bin_fill_level)\n\n    best_fit_weight = min(0.5, avg_fill)\n    ratio_weight = 0.3 * (1 - best_fit_weight)\n    gap_weight = 0.4 * (1 - best_fit_weight)\n    capacity_weight = 0.3 * (1 - best_fit_weight)\n\n    combined_priority = (\n        ratio_weight * ratio_priority +\n        gap_weight * gap_priority +\n        capacity_weight * capacity_priority +\n        best_fit_weight * best_fit_priority\n    )\n\n    return combined_priority\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity, best-fit, and dynamic weights.\"\"\"\n\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    max_cap = np.max(bins_remain_cap)\n    capacity_priority = bins_remain_cap / (max_cap + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    best_fit_priority = np.where(feasible, -gap, -1e9)\n    best_fit_priority = np.where(feasible, (best_fit_priority - np.min(best_fit_priority[feasible])) / (np.max(best_fit_priority[feasible]) - np.min(best_fit_priority[feasible]) + 1e-9), -1e9)\n\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n\n    bin_fill_level = 1 - (bins_remain_cap / max_cap)\n    avg_fill = np.mean(bin_fill_level)\n\n    best_fit_weight = min(0.5, avg_fill)\n    ratio_weight = 0.3 * (1 - best_fit_weight)\n    gap_weight = 0.4 * (1 - best_fit_weight)\n    capacity_weight = 0.3 * (1 - best_fit_weight)\n\n    combined_priority = (\n        ratio_weight * ratio_priority +\n        gap_weight * gap_priority +\n        capacity_weight * capacity_priority +\n        best_fit_weight * best_fit_priority\n    )\n\n    return combined_priority\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity with dynamic penalty and normalization.\"\"\"\n\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap; penalize infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio priority (item size / bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Dynamic almost-full penalty based on remaining capacity\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n    # Capacity priority (normalized)\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n    \n    # Adaptive weights based on item size.\n    item_size_factor = min(1.0, item)\n\n    # Combined priority with adaptive weights\n    combined_priority = (\n        0.3 * ratio_priority +\n        0.4 * gap_priority +\n        0.3 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity with dynamic penalty and normalization.\"\"\"\n\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap; penalize infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio priority (item size / bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Dynamic almost-full penalty based on remaining capacity\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n    # Capacity priority (normalized)\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n    \n    # Adaptive weights based on item size.\n    item_size_factor = min(1.0, item)\n\n    # Combined priority with adaptive weights\n    combined_priority = (\n        0.3 * ratio_priority +\n        0.4 * gap_priority +\n        0.3 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced priority function with adaptive weighting, state-awareness, and robust normalization.\"\"\"\n\n    # Handle edge case: empty bins_remain_cap array\n    if bins_remain_cap.size == 0:\n        return np.array([])\n\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap; penalize infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio priority (item size / bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Dynamic almost-full penalty based on remaining capacity\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n    # Capacity priority (normalized)\n    max_cap = np.max(bins_remain_cap)\n    capacity_priority = bins_remain_cap / (max_cap + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n    \n    # Adaptive weights based on item size and remaining capacity variance.\n    item_size_factor = min(1.0, item)\n    capacity_variance = np.var(bins_remain_cap)\n\n    # Adjust weights based on item size and remaining capacity variance.\n    weight_ratio = 0.2 + 0.2 * item_size_factor # Range: [0.2, 0.4]\n    weight_gap = 0.5 - 0.1 * item_size_factor + 0.1 * min(1.0, capacity_variance) #Range: [0.4, 0.6]\n    weight_capacity = 0.3 - 0.1 * capacity_variance #Ensure sum to 1. Range: [0.1, 0.3]\n\n    # Combined priority with adaptive weights\n    combined_priority = (\n        weight_ratio * ratio_priority +\n        weight_gap * gap_priority +\n        weight_capacity * capacity_priority\n    )\n\n    # Apply a small penalty to bins close to full to encourage better distribution.\n    close_to_full = (gap > 0) & (gap < 0.1)\n    combined_priority = np.where(close_to_full, combined_priority - 0.05, combined_priority)\n\n    return combined_priority\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity, dynamic penalty, adaptive weights, and bin usage.\"\"\"\n\n    # Handle zero capacities to prevent division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, penalize infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio priority (item size / bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap priority with dynamic almost-full penalty and relative gap\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    relative_gap = gap / (bins_remain_cap + 1e-9) # Normalize gap by bin capacity\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty + relative_gap , -1e9)\n\n    # Capacity priority (normalized remaining capacity)\n    max_cap = np.max(bins_remain_cap)\n    capacity_priority = bins_remain_cap / (max_cap + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # Bin usage priority (Prioritize bins closer to full but still feasible.)\n    bin_usage_priority = (max_cap - bins_remain_cap) / (max_cap + 1e-9) # Normalize used capacity\n    bin_usage_priority = np.where(feasible, bin_usage_priority, -1e9)\n\n    # Adaptive weights based on item size and avg bin capacity\n    item_size_factor = min(1.0, item)\n    capacity_factor = min(1.0, avg_cap / (max_cap + 1e-9)) # Adjust sensitivity based on bin utilization\n\n    # Combined priority calculation with dynamic weights\n    combined_priority = (\n        0.25 * ratio_priority +\n        0.45 * gap_priority +\n        0.15 * capacity_priority +\n        0.15 * bin_usage_priority\n    )\n\n    return combined_priority\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity, dynamic penalty, adaptive weights, and bin usage.\"\"\"\n\n    # Handle zero capacities to prevent division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, penalize infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio priority (item size / bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap priority with dynamic almost-full penalty and relative gap\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    relative_gap = gap / (bins_remain_cap + 1e-9) # Normalize gap by bin capacity\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty + relative_gap , -1e9)\n\n    # Capacity priority (normalized remaining capacity)\n    max_cap = np.max(bins_remain_cap)\n    capacity_priority = bins_remain_cap / (max_cap + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # Bin usage priority (Prioritize bins closer to full but still feasible.)\n    bin_usage_priority = (max_cap - bins_remain_cap) / (max_cap + 1e-9) # Normalize used capacity\n    bin_usage_priority = np.where(feasible, bin_usage_priority, -1e9)\n\n    # Adaptive weights based on item size and avg bin capacity\n    item_size_factor = min(1.0, item)\n    capacity_factor = min(1.0, avg_cap / (max_cap + 1e-9)) # Adjust sensitivity based on bin utilization\n\n    # Combined priority calculation with dynamic weights\n    combined_priority = (\n        0.25 * ratio_priority +\n        0.45 * gap_priority +\n        0.15 * capacity_priority +\n        0.15 * bin_usage_priority\n    )\n\n    return combined_priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, capacity, dynamic penalty, and adaptive weights.\"\"\"\n\n    # Handle zero capacities to prevent division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, penalize infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio priority (item size / bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap priority with dynamic almost-full penalty\n    avg_cap = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n    # Capacity priority (normalized remaining capacity)\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # Adaptive weights based on item size\n    item_size_factor = min(1.0, item)\n    \n    # Combined priority calculation\n    combined_priority = (\n        0.3 * ratio_priority +\n        0.5 * gap_priority +\n        0.2 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, and capacity with dynamic penalty.\"\"\"\n\n    # Handle zero capacities\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, mark infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio-based priority\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap-based priority + dynamic almost full penalty\n    almost_full_penalty_scale = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (almost_full_penalty_scale + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n    \n    # Capacity-based priority\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # Combined priority\n    combined_priority = (\n        0.4 * ratio_priority +\n        0.4 * gap_priority +\n        0.2 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, and capacity with dynamic penalty.\"\"\"\n\n    # Handle zero capacities\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, mark infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio-based priority\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap-based priority + dynamic almost full penalty\n    almost_full_penalty_scale = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (almost_full_penalty_scale + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n    \n    # Capacity-based priority\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # Combined priority\n    combined_priority = (\n        0.4 * ratio_priority +\n        0.4 * gap_priority +\n        0.2 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio-based, gap-based, and capacity-based approaches with dynamic penalty and normalization.\n    \"\"\"\n    # Avoid division by zero\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, handling infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio-based priority (normalized item size relative to bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap-based priority + Almost full penalty (dynamically adjusted)\n    almost_full_penalty_scale = np.mean(bins_remain_cap)  # Dynamic scaling\n    almost_full_penalty = np.exp(-50 * gap / (almost_full_penalty_scale + 1e-9))  # Scale gap for penalty\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n    \n    # Capacity-based priority (normalized remaining capacity)\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)  # Normalize capacity\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n    \n    # Combined priority with adaptive weights based on item size\n    item_size_factor = min(1.0, item)  # Scale weights based on item size\n    \n    combined_priority = (\n        0.4 * ratio_priority +\n        0.4 * gap_priority +\n        0.2 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio, gap, and capacity with dynamic penalty.\"\"\"\n\n    # Handle zero capacities\n    bins_remain_cap = np.where(bins_remain_cap <= 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, mark infeasible bins\n    gap = bins_remain_cap - item\n    feasible = gap >= 0\n    gap = np.where(feasible, gap, -1)\n\n    # Ratio-based priority\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # Gap-based priority + dynamic almost full penalty\n    almost_full_penalty_scale = np.mean(bins_remain_cap)\n    almost_full_penalty = np.exp(-50 * gap / (almost_full_penalty_scale + 1e-9))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n    \n    # Capacity-based priority\n    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # Combined priority\n    combined_priority = (\n        0.4 * ratio_priority +\n        0.4 * gap_priority +\n        0.2 * capacity_priority\n    )\n\n    return combined_priority\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A priority function for the online bin packing problem that combines ratio,\n    gap, capacity, dynamic penalty, and adaptive weights, with improved\n    handling of edge cases and state awareness.\n    \"\"\"\n\n    # Small constant to avoid division by zero and other numerical issues\n    epsilon = 1e-9\n\n    # 1. Feasibility check and basic preprocessing\n    feasible = bins_remain_cap >= item\n    num_feasible = np.sum(feasible)\n    \n    # If no bin is feasible, return a low priority for all bins, prioritizing the least full one\n    if num_feasible == 0:\n        return -bins_remain_cap  # Prioritize bins with more remaining capacity\n\n    # 2. Ratio priority (item size / bin capacity), only for feasible bins\n    ratios = item / np.where(bins_remain_cap <= 0, epsilon, bins_remain_cap)\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # 3. Gap priority with dynamic almost-full penalty and scaled gap\n    gap = bins_remain_cap - item\n    gap = np.where(feasible, gap, -1)\n\n    # Dynamic almost-full penalty, scaled by the item size and the number of feasible bins\n    avg_cap = np.mean(bins_remain_cap[feasible]) if num_feasible > 0 else np.mean(bins_remain_cap) # Only consider feasible bins for average cap\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + epsilon))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n    # 4. Capacity priority (normalized remaining capacity), only for feasible bins\n    max_cap = np.max(bins_remain_cap[feasible]) if num_feasible > 0 else np.max(bins_remain_cap) # Max capacity only among feasible bins\n    capacity_priority = bins_remain_cap / (max_cap + epsilon)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # 5. Introduce a \"balancing\" term to encourage more even bin utilization\n    #   This is a state-aware component to avoid filling one bin completely\n    #   before others have had a chance to be used.\n    fill_level = 1.0 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon))  # Fill level of each bin (0 to 1)\n    fill_level_priority = -fill_level # Prefer bins with lower fill levels\n\n    fill_level_priority = np.where(feasible, fill_level_priority, -1e9)\n\n    # 6. Adaptive weights based on item size and bin diversity\n    item_size_factor = min(1.0, item)\n    \n    # Standard deviation of remaining capacities. Higher std means more diverse bins\n    bin_diversity = np.std(bins_remain_cap)\n    diversity_factor = min(1.0, bin_diversity) # Normalize std\n\n    # 7. Combined priority calculation with more emphasis on gap\n    combined_priority = (\n        0.15 * ratio_priority +\n        0.55 * gap_priority +\n        0.15 * capacity_priority +\n        0.15 * fill_level_priority\n    )\n    \n    return combined_priority\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A priority function for the online bin packing problem that combines ratio,\n    gap, capacity, dynamic penalty, and adaptive weights, with improved\n    handling of edge cases and state awareness.\n    \"\"\"\n\n    # Small constant to avoid division by zero and other numerical issues\n    epsilon = 1e-9\n\n    # 1. Feasibility check and basic preprocessing\n    feasible = bins_remain_cap >= item\n    num_feasible = np.sum(feasible)\n    \n    # If no bin is feasible, return a low priority for all bins, prioritizing the least full one\n    if num_feasible == 0:\n        return -bins_remain_cap  # Prioritize bins with more remaining capacity\n\n    # 2. Ratio priority (item size / bin capacity), only for feasible bins\n    ratios = item / np.where(bins_remain_cap <= 0, epsilon, bins_remain_cap)\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(feasible, ratio_priority, -1e9)\n\n    # 3. Gap priority with dynamic almost-full penalty and scaled gap\n    gap = bins_remain_cap - item\n    gap = np.where(feasible, gap, -1)\n\n    # Dynamic almost-full penalty, scaled by the item size and the number of feasible bins\n    avg_cap = np.mean(bins_remain_cap[feasible]) if num_feasible > 0 else np.mean(bins_remain_cap) # Only consider feasible bins for average cap\n    almost_full_penalty = np.exp(-50 * gap / (avg_cap + epsilon))\n    almost_full_penalty = np.where(feasible, almost_full_penalty, 0)\n    gap_priority = np.where(feasible, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n    # 4. Capacity priority (normalized remaining capacity), only for feasible bins\n    max_cap = np.max(bins_remain_cap[feasible]) if num_feasible > 0 else np.max(bins_remain_cap) # Max capacity only among feasible bins\n    capacity_priority = bins_remain_cap / (max_cap + epsilon)\n    capacity_priority = np.where(feasible, capacity_priority, -1e9)\n\n    # 5. Introduce a \"balancing\" term to encourage more even bin utilization\n    #   This is a state-aware component to avoid filling one bin completely\n    #   before others have had a chance to be used.\n    fill_level = 1.0 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon))  # Fill level of each bin (0 to 1)\n    fill_level_priority = -fill_level # Prefer bins with lower fill levels\n\n    fill_level_priority = np.where(feasible, fill_level_priority, -1e9)\n\n    # 6. Adaptive weights based on item size and bin diversity\n    item_size_factor = min(1.0, item)\n    \n    # Standard deviation of remaining capacities. Higher std means more diverse bins\n    bin_diversity = np.std(bins_remain_cap)\n    diversity_factor = min(1.0, bin_diversity) # Normalize std\n\n    # 7. Combined priority calculation with more emphasis on gap\n    combined_priority = (\n        0.15 * ratio_priority +\n        0.55 * gap_priority +\n        0.15 * capacity_priority +\n        0.15 * fill_level_priority\n    )\n    \n    return combined_priority\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines ratio-based and gap-based approaches with penalty.\n    \"\"\"\n    # Avoid division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap, handling infeasible bins\n    gap = bins_remain_cap - item\n    gap = np.where(gap < 0, -1, gap)\n\n    # Ratio-based priority (normalized item size relative to bin capacity)\n    ratios = item / bins_remain_cap\n    ratio_priority = -np.log(ratios)\n    ratio_priority = np.where(gap >= 0, ratio_priority, -1e9)\n\n    # Gap-based priority + Almost full penalty\n    almost_full_penalty = np.exp(-50 * gap)\n    almost_full_penalty = np.where(gap >= 0, almost_full_penalty, 0)\n    gap_priority = np.where(gap >= 0, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9)\n\n\n    # Combine ratio and gap based priorities\n    priorities = 0.5 * ratio_priority + 0.5 * gap_priority\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       This version considers a combination of factors:\n       - Remaining capacity after placing the item (gap).\n       - Bin capacity.\n       - A penalty for bins that are almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap (remaining capacity after placing the item)\n    gap = bins_remain_cap - item\n    # bins where gap < 0 are not feasible: assign a very small priority.\n    gap = np.where(gap < 0, -1, gap)\n    \n    # Calculate a penalty for bins that will be almost full after placing the item\n    almost_full_penalty = np.exp(-50 * gap)  # Exponential penalty, sharp drop-off as gap -> 0\n    almost_full_penalty = np.where(gap >= 0, almost_full_penalty, 0) # only applies to feasible bins\n\n    # Calculate priority score.  Combine bin capacity, gap, and the almost full penalty.\n    priorities = np.where(gap >= 0, (bins_remain_cap / (gap + 0.0001)) - almost_full_penalty, -1e9) # Added constant to prevent possible 0 division.\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio-based and gravity-inspired approaches for bin selection.\"\"\"\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap\n    gap = bins_remain_cap - item\n    gap = np.where(gap < 0, -1, gap)\n\n    # Ratio-based priority (normalized)\n    ratios = np.where(bins_remain_cap > 0, item / bins_remain_cap, 0)\n    normalized_ratios = ratios / np.max(ratios) if np.max(ratios) > 0 else np.zeros_like(ratios)\n\n    # \"Gravitational\" attraction with added constant\n    gravity = np.where(gap >= 0, bins_remain_cap / (gap**2 + 0.0001), -1e9)\n\n    # Combine the two priorities\n    priorities = 0.5 * normalized_ratios + 0.5 * (gravity / np.max(gravity) if np.max(gravity) > 0 else np.zeros_like(gravity))\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines ratio-based and gravity-inspired approaches for bin selection.\"\"\"\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, 1e-9, bins_remain_cap)\n\n    # Calculate gap\n    gap = bins_remain_cap - item\n    gap = np.where(gap < 0, -1, gap)\n\n    # Ratio-based priority (normalized)\n    ratios = np.where(bins_remain_cap > 0, item / bins_remain_cap, 0)\n    normalized_ratios = ratios / np.max(ratios) if np.max(ratios) > 0 else np.zeros_like(ratios)\n\n    # \"Gravitational\" attraction with added constant\n    gravity = np.where(gap >= 0, bins_remain_cap / (gap**2 + 0.0001), -1e9)\n\n    # Combine the two priorities\n    priorities = 0.5 * normalized_ratios + 0.5 * (gravity / np.max(gravity) if np.max(gravity) > 0 else np.zeros_like(gravity))\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Newton's insightful heuristic considers gravitational attraction - smaller gap and larger bin capacity means higher attraction.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, 1e-9, bins_remain_cap) # a very small number to avoid division by zero\n\n    # Calculate gap (remaining capacity after placing the item)\n    gap = bins_remain_cap - item\n    # bins where gap < 0 are not feasible: assign a very small priority.\n    gap = np.where(gap < 0, -1, gap)\n    \n    # \"Gravitational\" attraction: inversely proportional to a power of the distance (gap) and directly propotional to bin capacity\n\n    priorities = np.where(gap >= 0, bins_remain_cap / (gap**2 + 0.0001), -1e9) # Added small constant to prevent possible 0 division. High Penalty for the non feasible ones\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}