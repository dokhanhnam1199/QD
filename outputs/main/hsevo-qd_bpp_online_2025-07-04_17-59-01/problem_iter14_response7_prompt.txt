{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                division_epsilon: float = 8.41613007074527e-09, \n                gravity_epsilon: float = 9.764304781528209e-05,\n                ratio_weight: float = 0.4759852357838289, \n                gravity_weight: float = 0.1773067754705847,\n                negative_gap_penalty: float = -0.30291238428480005,\n                negative_gravity_penalty: float = -9196992900.133415) -> np.ndarray:\n    \"\"\"Combines ratio-based and gravity-inspired approaches for bin selection.\"\"\"\n    # Ensure no division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, division_epsilon, bins_remain_cap)\n\n    # Calculate gap\n    gap = bins_remain_cap - item\n    gap = np.where(gap < 0, negative_gap_penalty, gap)\n\n    # Ratio-based priority (normalized)\n    ratios = np.where(bins_remain_cap > 0, item / bins_remain_cap, 0)\n    normalized_ratios = ratios / np.max(ratios) if np.max(ratios) > 0 else np.zeros_like(ratios)\n\n    # \"Gravitational\" attraction with added constant\n    gravity = np.where(gap >= 0, bins_remain_cap / (gap**2 + gravity_epsilon), negative_gravity_penalty)\n\n    # Combine the two priorities\n    priorities = ratio_weight * normalized_ratios + gravity_weight * (gravity / np.max(gravity) if np.max(gravity) > 0 else np.zeros_like(gravity))\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic combines ratio, gap, capacity, dynamic penalty, bin usage, and adaptive weights, while the worst only considers the ratio between item size and remaining bin capacity. (2nd) is identical to (1st). Comparing (1st) vs (6th), the 1st includes bin usage and adaptive weights based on item size and average bin capacity, while the 6th lacks bin usage and uses adaptive weights based only on item size. Comparing (6th) vs (17th), 6th includes gap, capacity, and dynamic penalty, while the 17th only considers ratio. Comparing (14th) vs (17th), we see that (14th) uses both ratio-based and gravity-inspired approaches, while (17th) is purely ratio-based. Comparing (15th) vs (14th), (15th) introduces tunable parameters and penalties. Comparing (11th) vs (14th), (11th) includes feasibility checks, comprehensive priorities (ratio, gap, capacity, fill level), and handles edge cases, while (14th) simplifies to ratio and gravity. The handling of infeasible bins and the diversity/balancing term are also unique to the higher-ranked heuristics. Overall: More sophisticated heuristics consider multiple factors like ratio, gap, capacity, bin usage, and dynamically adjust weights and penalties, and carefully handles edge cases such as infeasibility. Simpler heuristics only focus on a single factor like ratio or a limited combination of factors. Introducing tunable parameters does not guarantee better performance.\n- \nOkay, let's refine \"Current Self-Reflection\" to maximize its usefulness in heuristic design. We'll focus on actionable advice and avoid vague suggestions.\n\n*   **Keywords:** Factor Combination, Normalization, Dynamic Penalties, Adaptive Weights, Edge Case Handling, Problem State, Multi-Factor.\n\n*   **Advice:** Prioritize combining multiple *normalized* factors, and adjust their relative importance (weights/penalties) *dynamically* based on the current problem state to reflect its context and needs.\n\n*   **Avoid:** Relying on single factor, static approaches, unscaled values, or ignoring edge cases/infeasibility. Avoid vague, domain-specific suggestions.\n\n*   **Explanation:** Combining normalized factors allows a more holistic view. Dynamic penalties and adaptive weights enable the heuristic to react intelligently to the search space and problem features by emphasizing the most critical factor at a given moment.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}