```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit strategy.

    The priority is higher for bins that can fit the item and that have less remaining capacity
    after placing the item. This encourages using bins that are closer to being full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate a priority score.
    # Higher priority for bins with less remaining capacity *after* placing the item.
    # This is the core of the "best fit" idea within a first-fit framework.
    # We want to leave more space in bins that are already quite full if they can accommodate the item.
    if np.any(can_fit_mask):
        remaining_after_placement = bins_remain_cap[can_fit_mask] - item
        # To prioritize bins with *less* remaining capacity, we can invert this.
        # A small remaining capacity means a high priority score.
        # We can use the negative of the remaining capacity, or 1 / (remaining + epsilon)
        # Let's use a large number minus the remaining capacity to emphasize smaller remainders.
        # We add a small epsilon to avoid division by zero if remaining_after_placement is 0.
        priorities[can_fit_mask] = 1000 - remaining_after_placement

    # If no bins can fit, all priorities remain 0.
    return priorities
```
