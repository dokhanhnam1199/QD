```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit strategy.

    The Random Fit strategy is a simple heuristic for the online bin packing problem.
    It randomly selects a bin and places the item in it if it fits. This priority
    function assigns a priority to each bin that could potentially hold the item.

    In this implementation of Random Fit, we want to prioritize bins that have
    *exactly* enough space for the item, as this is a common strategy to try and
    minimize waste. If no bin has exact space, we then consider bins that have
    more than enough space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that can fit the item receive a score, otherwise 0.
        Bins with exact fit get a higher score than those with a loose fit.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Assign priorities
    # Bins with exact fit (remaining_capacity == item) get a high priority
    exact_fit_mask = (bins_remain_cap == item) & can_fit_mask
    priorities[exact_fit_mask] = 1.0

    # Bins with loose fit (remaining_capacity > item) get a lower priority,
    # but still prioritized over non-fitting bins.
    loose_fit_mask = (bins_remain_cap > item) & can_fit_mask
    # To make it slightly random but still favor exact fits, we can assign
    # a score based on how "close" the fit is (i.e., smallest remaining capacity
    # after packing). However, for a strict Random Fit interpretation, the selection
    # is purely random among *valid* bins. For this priority function, we'll
    # simulate a preference for exact fits.
    # We can give a slightly lower priority to loose fits. A simple way is to
    # use the inverse of the difference for demonstration, making smaller gaps
    # slightly higher priority, but this deviates from pure random.
    # Let's stick to a simpler prioritization: exact fit is best, then any fit.
    # For a *truly* random fit within the priority function concept, we would
    # randomly assign a priority to all eligible bins and return that.
    # However, "Random Fit" often means picking *a* random bin among the valid ones.
    # If we are to design a priority function for a selection strategy that *uses*
    # priorities, and the strategy is "Random Fit", we'd typically randomize.

    # Let's refine: a priority function usually guides selection. For Random Fit,
    # the selection is random among those that fit.
    # So, our priority function should indicate *which* bins are candidates,
    # and the selection mechanism will pick randomly from those with the highest score.
    # High score means "can fit".

    # Re-interpreting for a priority function that influences a *random selection*:
    # Assign a positive score to any bin that can fit the item.
    # The selection logic would then randomly pick from the bins with the highest score.
    # To make it "Random Fit" where we randomly pick an eligible bin:
    # Assign a random score to all bins that can fit the item.
    # Bins that don't fit get 0.

    eligible_bins_indices = np.where(bins_remain_cap >= item)[0]

    if eligible_bins_indices.size > 0:
        # Assign a random priority to all eligible bins.
        # The selection mechanism (not part of this function) would then pick
        # randomly from the bins that receive the highest (random) priority.
        # To ensure at least one bin is picked if eligible, we can set a baseline.
        random_priorities = np.random.rand(len(eligible_bins_indices))
        priorities[eligible_bins_indices] = random_priorities
    else:
        # No bins can fit the item.
        priorities = np.zeros_like(bins_remain_cap)

    return priorities
```
