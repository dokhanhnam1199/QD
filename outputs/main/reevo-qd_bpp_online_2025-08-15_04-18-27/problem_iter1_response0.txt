```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    The First Fit strategy prioritizes bins that can accommodate the item.
    Amongst the bins that can accommodate the item, it selects the one that
    leaves the smallest remaining capacity, thus aiming to "fill up" bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    # A bin is eligible if it has enough remaining capacity for the item.
    eligible_bins_mask = bins_remain_cap >= item

    # For eligible bins, the priority is inversely related to the remaining capacity
    # after placing the item. This encourages using bins that will be "almost full".
    # We use a large negative number for ineligible bins to ensure they are never chosen.
    # We add a small epsilon to the remaining capacity before taking the reciprocal
    # to avoid division by zero if a bin has exactly enough space.
    epsilon = 1e-9
    priorities[eligible_bins_mask] = 1.0 / (bins_remain_cap[eligible_bins_mask] - item + epsilon)

    # Invert the priorities so that smaller remaining capacity gets higher priority.
    # We take the negative to effectively sort from smallest remaining to largest.
    priorities[eligible_bins_mask] = -priorities[eligible_bins_mask]

    # Assign a very low priority (high negative value) to bins that cannot fit the item.
    # This ensures they are never selected.
    priorities[~eligible_bins_mask] = -np.inf

    return priorities
```
