```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy prioritizes bins that have just enough remaining capacity
    to fit the item. This aims to leave larger remaining capacities in other bins
    for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value for bins that cannot fit the item
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that have enough capacity for the item
    fitting_bins_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after placing the item
    remaining_after_fit = bins_remain_cap[fitting_bins_mask] - item

    # The "best fit" is the bin where the remaining capacity is minimized.
    # We want to assign higher priority to bins with smaller remaining capacity (after fitting).
    # A simple heuristic for priority could be the inverse of the remaining capacity,
    # but we need to avoid division by zero and give preference to exact fits.
    # A common approach is to penalize larger remaining capacities.
    # We can assign a score that is inversely proportional to the remaining capacity.
    # To make it simple and avoid division by zero, we can use something like:
    # priority = 1 / (remaining_after_fit + epsilon) for small epsilon, or
    # more robustly, map the remaining capacity to a priority score.
    # A high priority should be for the smallest remaining capacity.

    # Let's map the remaining capacity to a priority:
    # If remaining_after_fit is 0, it's a perfect fit, give it highest priority.
    # If remaining_after_fit is small and positive, give it high priority.
    # If remaining_after_fit is large, give it lower priority.

    # To achieve this, we can sort the fitting bins by their remaining capacity.
    # The bin with the smallest remaining capacity should get the highest priority.
    # We can assign priorities based on the rank of the remaining capacity.

    # Find the indices of bins that can fit the item
    fitting_indices = np.where(fitting_bins_mask)[0]

    if len(fitting_indices) > 0:
        # Calculate the remaining capacity for only those bins that can fit the item
        remaining_for_fitting = bins_remain_cap[fitting_indices] - item

        # Create a sorting key: smaller remaining capacity gets higher priority.
        # We can assign priority based on the sorted order. The bin with the smallest
        # remaining capacity (best fit) should have the highest priority value.
        # Let's sort the fitting indices based on remaining_for_fitting in ascending order.
        sorted_fitting_indices = fitting_indices[np.argsort(remaining_for_fitting)]

        # Assign priorities: higher value means higher priority.
        # The best fit bin (smallest remaining capacity) gets the highest priority score.
        # We can use a decreasing sequence of numbers for priority.
        # The number of fitting bins determines the range of priorities.
        num_fitting_bins = len(sorted_fitting_indices)
        for i, idx in enumerate(sorted_fitting_indices):
            # Assign priority such that the best fit gets the highest number.
            # E.g., if 3 bins fit, priorities could be 3, 2, 1.
            priorities[idx] = num_fitting_bins - i

    return priorities
```
