```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    The Almost Full Fit strategy prioritizes bins that are close to being full,
    but still have enough capacity for the current item. This aims to leave
    larger capacity bins for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the "almost full" priority.
    # We want to prioritize bins that are "almost full" but can still fit the item.
    # A good measure for "almost full" is the remaining capacity.
    # We can define priority as inversely proportional to remaining capacity,
    # but also consider that we don't want to pick a bin that is *too* full,
    # as that might be a bad fit.
    # A common approach for "almost full" is to use a function that peaks
    # when remaining capacity is small but positive.
    # For simplicity, we'll use the negative of remaining capacity to
    # prioritize smaller remaining capacities (i.e., fuller bins).
    # Adding a small constant to avoid zero division if remaining capacity is zero
    # and ensuring positive priorities for valid fits.

    # Let's use a strategy that penalizes bins that are too full or too empty.
    # We want to find bins where `bins_remain_cap - item` is small.
    # This means `bins_remain_cap` should be slightly larger than `item`.

    # Option 1: Prioritize bins with the smallest remaining capacity that can fit the item.
    # This is essentially the "Best Fit" approach. For "Almost Full Fit",
    # we want to be *close* to Best Fit.

    # A possible interpretation of "Almost Full Fit" for priority:
    # Prioritize bins where the remaining capacity after placing the item is minimized,
    # but we ensure that the bin is not *completely* full.
    # We can assign a high priority to bins that have just enough space.

    # Let's try a priority function that gives higher scores to bins with
    # smaller remaining capacity, but only if they can fit the item.
    # We want to avoid bins that are *too* empty.

    # A simple way to prioritize "almost full" bins is to sort them by remaining capacity.
    # The bins with the smallest remaining capacity (that can fit the item) are preferred.
    # For a priority score, we want higher scores for preferred bins.

    # Let's assign priority based on how "tightly" the item fits.
    # A tighter fit means `bins_remain_cap - item` is small and non-negative.
    # We want to maximize the priority for bins where `bins_remain_cap - item` is close to 0.

    # We can map the remaining capacity (after fitting the item) to a priority.
    # Smaller remaining capacity should get higher priority.
    # A simple mapping could be `1 / (remaining_capacity + epsilon)`
    # where epsilon is a small value to prevent division by zero.

    # Let's filter out bins that cannot fit the item.
    valid_bins_indices = np.where(can_fit_mask)[0]

    if len(valid_bins_indices) > 0:
        # Calculate remaining capacity for valid bins
        remaining_capacities_for_valid = bins_remain_cap[valid_bins_indices] - item

        # To prioritize "almost full" bins, we want to give higher scores
        # to bins with smaller `remaining_capacities_for_valid`.
        # We can use the negative of these values.
        # However, to avoid very large negative numbers for empty bins and to
        # make the heuristic more focused on being "almost full", we can
        # adjust the values.

        # A good heuristic for "almost full" could be to reward bins
        # where the remaining capacity `bins_remain_cap` is just slightly
        # larger than `item`.

        # Let's consider the ratio `item / bins_remain_cap` for bins that can fit.
        # Higher ratio means the item takes up more of the bin's *current* capacity.
        # This could imply a more "full" bin if the current capacity is already small.
        # However, this might not be the best for "almost full".

        # The core idea of "Almost Full Fit" is to pick a bin that is "nearly full".
        # So, we want bins where `bins_remain_cap` is small but sufficient.

        # Let's create a priority that is inversely proportional to the
        # `bins_remain_cap` itself, but only for bins that can fit the item.
        # This prioritizes bins that are already closer to being full.
        # Add a small epsilon to the denominator to avoid division by zero,
        # and a small offset to ensure positive priorities.

        epsilon = 1e-6  # Small constant to avoid division by zero
        # We want bins with small `bins_remain_cap` (but >= item) to have high priority.
        # So, a good priority could be `1 / bins_remain_cap`.
        # But we only apply this to bins that can fit the item.

        # Let's construct a score that emphasizes bins that are almost full.
        # For a bin with remaining capacity `r`, after placing item `i`, the new remaining capacity is `r-i`.
        # We want to prioritize bins where `r-i` is small.
        # So, a good priority would be inversely related to `r-i`.
        # `priority = 1 / (r-i + epsilon)` for bins where `r >= i`.

        # Let's use the value `bins_remain_cap` directly for priority.
        # Smaller `bins_remain_cap` should have higher priority, but only if `bins_remain_cap >= item`.
        # We can use `1 / bins_remain_cap` but this might penalize very large bins too much.

        # Alternative: Prioritize bins where `bins_remain_cap - item` is minimal.
        # So, `priority = - (bins_remain_cap - item)` for bins that fit.
        # We want higher values for smaller (more negative or closer to zero) differences.
        # So, `priority = -(bins_remain_cap - item)` where `bins_remain_cap - item >= 0`.
        # Let's shift this to be positive and emphasize small positive differences.

        # A heuristic often used for "almost full" or "tight fit" is to reward bins
        # where `bins_remain_cap` is just large enough.
        # Consider the difference `bins_remain_cap - item`. We want this to be small and positive.
        # A priority could be related to `-(bins_remain_cap - item)` or `1 / (bins_remain_cap - item + epsilon)`.

        # Let's try `priority = - (bins_remain_cap - item)` for fitting bins.
        # This means bins with `bins_remain_cap = item` get priority 0.
        # Bins with `bins_remain_cap = item + 1` get priority -1.
        # We want higher priority for bins that are *closer* to being full.
        # So, we want bins with smaller `bins_remain_cap` to have higher priority.

        # A robust "almost full" strategy often involves prioritizing bins
        # that have a small remaining capacity *after* placing the item.
        # This is equivalent to prioritizing bins that were "most full"
        # among those that can accommodate the item.

        # Let's use the negative of the remaining capacity for bins that can fit.
        # This gives higher priority to bins with less remaining capacity.
        # `priorities[valid_bins_indices] = -bins_remain_cap[valid_bins_indices]`
        # This makes bins that are already close to full have higher (less negative) scores.
        # However, we want *positive* priorities that can be sorted.

        # Let's reconsider the objective: pick the bin that becomes "most full"
        # after placing the item. This means picking the bin with the smallest
        # remaining capacity *after* placing the item.
        # Let `r` be the current remaining capacity. The new remaining capacity is `r - item`.
        # We want to minimize `r - item`.
        # So, a good priority score would be `-(r - item)` which is `item - r`.
        # However, this gives higher priority to bins that were already more full.

        # For "Almost Full Fit", we're looking for bins that are *close* to full,
        # but not overfilled.
        # We can define "almost full" as having a remaining capacity that is small,
        # but greater than or equal to the item's size.

        # Let's use a priority that favors bins where `bins_remain_cap` is slightly
        # larger than `item`.
        # We can assign a priority based on `1 / (bins_remain_cap - item + epsilon)`.
        # This prioritizes bins where the "gap" is smallest.

        priorities[valid_bins_indices] = 1.0 / (bins_remain_cap[valid_bins_indices] - item + epsilon)

        # This assigns a very high priority to bins where `bins_remain_cap` is just
        # barely larger than `item`. For instance, if `bins_remain_cap = item + 0.01`,
        # priority is 100. If `bins_remain_cap = item + 1`, priority is 1.
        # This aligns well with the "almost full" concept.

    return priorities

```
