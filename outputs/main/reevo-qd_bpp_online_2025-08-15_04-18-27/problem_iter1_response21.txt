```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    The Best Fit strategy prioritizes bins that have just enough space to
    accommodate the item. This aims to minimize wasted space in bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value (indicating they are not suitable)
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can actually accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # For suitable bins, calculate the "waste" if the item is placed there.
    # The waste is the remaining capacity after placing the item.
    # We want to minimize this waste, so we want the smallest positive waste.
    # A very large negative number will be assigned to bins that cannot fit the item.
    waste = bins_remain_cap - item

    # Assign higher priority to bins with less remaining capacity *after* placing the item.
    # This means we prioritize bins where the remaining capacity is closest to zero,
    # provided the bin can fit the item.
    # We use a large negative number for bins that don't fit the item,
    # and for bins that fit, we use the negative of the remaining capacity.
    # This way, the smallest (least negative) value in `waste` corresponds to the
    # best fit. For example, if capacity is [5, 8, 10] and item is 4:
    # suitable_bins_mask: [True, True, True]
    # waste: [1, 4, 6]
    # priorities: [-1, -4, -6] -> Bin 0 has the highest priority.
    priorities[suitable_bins_mask] = -waste[suitable_bins_mask]

    return priorities
```
