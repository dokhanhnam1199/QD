```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a
    First Fit Decreasing inspired heuristic for the priority function.

    This heuristic prioritizes bins that have just enough space for the item,
    followed by bins that have slightly more space. It aims to leave larger
    bins for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "tightness" of fit for bins that can accommodate the item
    # A smaller residual capacity (tighter fit) is prioritized.
    # We add a small epsilon to avoid division by zero if residual capacity is 0,
    # though technically that case would be a perfect fit.
    residual_capacities = bins_remain_cap[can_fit_mask] - item
    
    # Assign higher priority to bins with less remaining space after fitting the item
    # The priority is inversely proportional to the remaining space, favoring tighter fits.
    # We also add 1 to avoid zero priorities and ensure non-zero positive scores for fitting bins.
    priorities[can_fit_mask] = 1.0 / (residual_capacities + 1e-6) + 1

    # Among bins that can fit the item, we want to slightly favor bins that
    # have a capacity closer to the item's size but still enough.
    # This is an approximation of First Fit Decreasing idea: try to fill bins
    # somewhat efficiently without leaving too much empty space, but also not
    # using up bins that could fit larger items later.

    # Let's refine the priority: bins that have slightly more space are less desirable
    # than those that fit snugly.
    # A simple way to achieve this is to penalize bins with much larger capacities.
    # However, the primary driver should be fitting the item.
    # For simplicity and to adhere to a "priority score", let's use the reciprocal
    # of remaining capacity as the main score, and a penalty for excess capacity.

    # Option 1 (used above): Prioritize tighter fits.
    # Option 2 (alternative idea, could be combined or a different v3):
    # If we wanted to prioritize bins that are "just right" or "slightly over",
    # we could consider bins whose remaining capacity is between item and item + tolerance.
    # However, the current v2 aims to simply prioritize fitting snugly.

    # Let's ensure that bins that *cannot* fit the item get a priority of 0.
    # The initialization handles this.

    # Let's consider the "emptiness" of a bin if it fits. A bin that fits item perfectly
    # has 0 remaining space. A bin that fits item with 1 unit remaining has 1 unit of space.
    # We want to prioritize the former. So, a higher score for lower remaining space.
    # `1.0 / (residual_capacities + epsilon)` does exactly this.

    # To make it more "priority" like, maybe we can adjust based on how "close"
    # the original bin capacity was to the item size.
    # However, the problem asks for a priority for EACH bin. So, the `bins_remain_cap`
    # is the direct information.

    # A slightly more complex heuristic might be:
    # score = (1 / (residual_capacity + epsilon)) + bonus_for_tight_fit
    # where bonus_for_tight_fit is higher if residual_capacity is small.
    # The current `1.0 / (residual_capacities + 1e-6) + 1` already captures this well.
    # The `+ 1` ensures all fitting bins have positive priority, with higher values
    # for tighter fits.

    return priorities
```
