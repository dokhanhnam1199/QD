```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    Almost Full Fit prioritizes bins that are almost full and can still accommodate the item.
    The priority is higher for bins that have less remaining capacity after placing the item,
    but only if the item fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # Calculate remaining capacity if the item is placed
    remaining_if_placed = bins_remain_cap - item

    # For bins where the item fits, assign priority based on how "tight" the fit is.
    # A smaller remaining capacity after placing the item means a higher priority.
    # We invert the remaining capacity to make smaller values higher priority.
    # Add a small epsilon to avoid division by zero or very small numbers if
    # remaining_if_placed becomes zero (perfect fit).
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (remaining_if_placed[can_fit_mask] + epsilon)

    # To implement the "Almost Full Fit" aspect, we can slightly boost bins that
    # are very full (i.e., have a small remaining capacity BEFORE the item is added).
    # This encourages filling up bins that are already quite full.
    # We can use a threshold for "almost full". Let's say if remaining capacity
    # is less than some percentage of the bin's original capacity (not provided here,
    # so we'll use a relative threshold based on the remaining capacities themselves).
    # A simpler approach is to give a bonus to bins that have a small remaining capacity.

    # Let's define "almost full" as having remaining capacity less than, say, 20% of the item size,
    # or simply having a very small absolute remaining capacity.
    # A practical way is to give a multiplier to bins with lower remaining capacity *before* adding the item.

    # We can use the reciprocal of the *original* remaining capacity (if it fits) as a base priority,
    # and then add a bonus if the original remaining capacity was small.
    # For bins that *cannot* fit the item, their priority remains 0.

    # Re-calculating priorities to incorporate the "almost full" aspect more directly.
    # Higher priority for bins that are already quite full (small bins_remain_cap)
    # AND can fit the item. The goal is to leave larger gaps in other bins for larger items.
    # So, priority should be inversely proportional to bins_remain_cap, given the item fits.

    # If a bin can fit the item:
    # Priority = 1 / (bins_remain_cap - item)  -- this favors tighter fits
    # We also want to favor bins that are *already* nearly full.
    # So, let's combine these:
    # Priority = (1 / bins_remain_cap) * (1 / (bins_remain_cap - item)) -- this might over-amplify

    # A common strategy for "almost full" is to prioritize bins with the smallest remaining capacity that can still fit the item.
    # This is exactly what `1.0 / (remaining_if_placed[can_fit_mask] + epsilon)` achieves.
    # If we want to explicitly make it "almost full fit", we can boost bins that
    # have a small `bins_remain_cap` *before* placing the item.

    # Let's refine this:
    # Priority = k * (1 / (bins_remain_cap - item)) for bins that fit
    # where k is a bonus for being "almost full".
    # A simple bonus could be related to the inverse of the original remaining capacity.
    # But we need to be careful not to make bins that are *too* full (where item doesn't fit) get high priority.

    # A common interpretation of "almost full fit" is to sort bins by remaining capacity
    # and pick the first one that fits, but the prompt asks for a priority score.
    # The goal of "almost full fit" is to leave the "most open" bins for potentially larger items.
    # This means we want to fill up bins that are already somewhat full.

    # So, prioritize bins that are already quite full, as long as they can fit the item.
    # A simple heuristic:
    # Priority = 1 / (bins_remain_cap) if item fits, otherwise 0.
    # This would prioritize bins that are *already* closer to full.
    # However, we still need to ensure the item *fits*.

    # Let's combine: Prioritize bins where the item fits *and* which have a small remaining capacity *before* placing the item.
    # This implies that a bin with less remaining capacity is more attractive, IF it can take the item.

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the "tightness" of the fit: how much capacity is left *after* placing the item.
    # Lower remaining capacity after placing means a tighter, more desirable fit for this strategy.
    remaining_after_fit = bins_remain_cap - item

    # Create a mask for bins that can accommodate the item.
    can_accommodate_mask = bins_remain_cap >= item

    # For bins that can accommodate the item, assign a priority.
    # A higher priority is given to bins that will have LESS remaining capacity after the item is placed.
    # We use the reciprocal of the remaining capacity *after* placing the item.
    # Add epsilon to avoid division by zero for perfect fits.
    priorities[can_accommodate_mask] = 1.0 / (remaining_after_fit[can_accommodate_mask] + epsilon)

    # To emphasize the "almost full" aspect, we can further boost bins that
    # had a small remaining capacity *before* the item was considered.
    # This ensures that among bins that create a tight fit, we prefer those that were already closer to full.
    # We can multiply the existing priority by a factor related to the inverse of the original remaining capacity.
    # Again, add epsilon to avoid division by zero for bins that were already full.
    almost_full_boost = 1.0 / (bins_remain_cap[can_accommodate_mask] + epsilon)

    # Combine the two factors: the "tightness of fit" and the "already almost full" state.
    # We want both to contribute. Multiplying them can be effective.
    priorities[can_accommodate_mask] *= almost_full_boost

    # A simpler approach that directly maps to "smallest remaining capacity if it fits":
    # If item fits, priority is proportional to 1 / (bins_remain_cap - item).
    # To emphasize "almost full" specifically, we might want to penalize bins that are *too* empty,
    # or give a bonus to bins that are *already* quite full.

    # Let's go with the interpretation that we want to select bins that are ALMOST full,
    # but still fit the item. This means we prefer bins with a SMALL `bins_remain_cap`
    # as long as `bins_remain_cap >= item`.
    # The "Almost Full Fit" often means picking the bin with the smallest `bins_remain_cap`
    # that can fit the item. This translates to prioritizing bins with low `bins_remain_cap`
    # among those that satisfy `bins_remain_cap >= item`.

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, their priority is inversely proportional
    # to their current remaining capacity. The smaller the remaining capacity,
    # the higher the priority, as it indicates the bin is "almost full".
    # We use the reciprocal of `bins_remain_cap` to achieve this.
    # Add epsilon for numerical stability and to avoid division by zero.
    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] + epsilon)

    return priorities
```
