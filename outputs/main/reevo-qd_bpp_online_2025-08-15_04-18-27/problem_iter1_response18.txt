```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy strategy.

    This strategy balances exploration (trying less-fit bins) and exploitation
    (choosing the best-fit bins).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploration
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Identify feasible bins
    feasible_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(feasible_bins_indices) == 0:
        return np.zeros(num_bins)  # No bin can accommodate the item

    # Exploitation: Prioritize bins that leave the least remaining space after packing
    # This is a common heuristic for Bin Packing (e.g., Best Fit)
    remaining_space = bins_remain_cap[feasible_bins_indices] - item
    # Invert the remaining space to make it a "score" where higher is better for exploitation
    # Add a small epsilon to avoid division by zero if remaining_space can be 0
    exploitation_scores = 1.0 / (remaining_space + 1e-9)

    # Normalize exploitation scores to be between 0 and 1
    if exploitation_scores.max() > 0:
        exploitation_scores = exploitation_scores / exploitation_scores.max()
    else:
        exploitation_scores = np.zeros_like(exploitation_scores) # All feasible bins have same remaining space

    # Exploration: Randomly choose some bins to give a slight boost,
    # or assign a uniform small priority to less-fit bins.
    # Here, we'll add a small random noise to all feasible bins to encourage exploration.
    exploration_scores = np.random.rand(len(feasible_bins_indices)) * epsilon

    # Combine exploitation and exploration
    # We want to exploit the best bins but also give a chance to explore others.
    # A simple way is to add exploration scores to exploitation scores,
    # but ensuring exploration doesn't dominate exploitation completely.
    # Here, we add random noise proportional to epsilon.
    combined_scores = exploitation_scores + exploration_scores

    # Assign the combined scores to the feasible bins
    priorities[feasible_bins_indices] = combined_scores

    # Ensure that bins that cannot fit the item have a priority of 0
    # (already handled by initialization and only assigning to feasible bins)

    return priorities
```
