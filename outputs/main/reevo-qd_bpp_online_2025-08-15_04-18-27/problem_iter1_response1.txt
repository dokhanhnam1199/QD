```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    In the Best Fit strategy, we prioritize bins that have the least remaining capacity
    after placing the item, but only if the item fits. A higher priority is given to
    bins that result in a smaller remaining capacity (closer to zero).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a more preferred bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item can actually fit
    can_fit_mask = bins_remain_cap >= item
    
    # For bins where the item fits, calculate the remaining capacity after placement
    # We want to minimize this remaining capacity, so we use a negative value
    # to make larger negative values (meaning smaller remaining capacity) have higher priority.
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # To make the priorities positive and larger for better fits, we can use
    # a transformation. A common approach is to use the negative of the remaining capacity,
    # or a function that maps smaller positive remaining capacities to larger priority values.
    # Here, we'll use 1 / (remaining_capacity + epsilon) to reward smaller remaining capacities,
    # but this can be unstable if remaining_capacity is zero.
    # A simpler approach for Best Fit is to prioritize bins that result in the *least* waste.
    # So, the priority should be inversely related to the remaining capacity *after* packing.
    # Thus, a higher priority means smaller `remaining_capacities_after_fit`.
    
    # Let's assign priority based on the "tightness" of the fit.
    # The best fit is the one that leaves the minimum remaining capacity.
    # So, we want to maximize the negative of the remaining capacity, or
    # minimize the remaining capacity itself and use that as the ranking.
    
    # A simple heuristic: prioritize bins that have *just enough* space.
    # If a bin has remaining capacity `R` and an item of size `I` arrives,
    # placing it results in `R - I` remaining capacity. We want to minimize `R - I`.
    # Therefore, higher priority for smaller `R - I`.
    # We can represent this by `- (R - I)` or by giving a high score when `R - I` is small.
    
    # Calculate a score that is higher for smaller remaining capacities after packing.
    # For example, `1.0 / (remaining_capacity_after_fit + 1e-6)`
    # or a simple inverse like `-remaining_capacity_after_fit`.
    
    # Using negative remaining capacity for direct comparison (higher value is better)
    priorities[can_fit_mask] = -remaining_capacities_after_fit
    
    # Alternatively, for a "tighter fit" score:
    # Add a small epsilon to avoid division by zero and to ensure positive scores
    # This rewards bins that are almost full.
    # priorities[can_fit_mask] = 1.0 / (remaining_capacities_after_fit + 1e-6)

    # For Best Fit, we want to find the bin with the smallest positive remaining capacity
    # after packing. This is equivalent to maximizing `- (remaining_capacity - item)`.
    
    # Another perspective: what if we prioritize bins where `bins_remain_cap` is closest to `item`?
    # `abs(bins_remain_cap - item)` can measure the "difference". We want to minimize this.
    # So, priority could be `-abs(bins_remain_cap - item)`.
    # This is closer to the *idea* of Best Fit (finding the tightest fit), but the problem
    # statement implies prioritizing based on the *resulting* remaining capacity.
    
    # Sticking to the definition: Best Fit aims to minimize the wasted space.
    # This means choosing the bin such that `bins_remain_cap - item` is minimized (and non-negative).
    # So, for bins that can fit the item, the priority is directly proportional to the
    # negative of the remaining capacity after packing.
    
    return priorities
```
