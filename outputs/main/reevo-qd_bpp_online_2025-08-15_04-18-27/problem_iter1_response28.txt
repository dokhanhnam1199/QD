```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using an Epsilon-Greedy strategy.

    The strategy balances exploration (trying less promising bins) and exploitation
    (choosing the best fitting bin).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.2  # Probability of exploring a random bin

    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Calculate "greedy" scores (exploitation): how well the item fits
    # We want to prioritize bins where the remaining capacity is just enough
    # or slightly more than the item. A good heuristic is to maximize
    # (remaining_capacity - item) while ensuring remaining_capacity >= item.
    # We'll use a transformation to turn a "good fit" into a high score.
    # A simple approach is to use the inverse of the "wasted space" if it fits.
    # If it doesn't fit, assign a very low score.
    fit_scores = np.zeros(num_bins)
    for i in range(num_bins):
        if bins_remain_cap[i] >= item:
            # Score based on how tightly it fits. Smaller waste = higher score.
            # Add a small constant to avoid division by zero if remaining_cap == item
            wasted_space = bins_remain_cap[i] - item
            fit_scores[i] = 1.0 / (wasted_space + 1e-6)

    # Epsilon-Greedy strategy:
    # With probability epsilon, explore a random bin.
    # With probability 1-epsilon, exploit the best fitting bin.

    random_indices = np.random.choice(num_bins, size=num_bins, replace=True)
    random_priorities = np.zeros(num_bins)
    for idx in random_indices:
        random_priorities[idx] = 1.0 # Give a uniform priority to explore

    # Combine greedy and random choices
    # With probability 1-epsilon, we want to select based on fit_scores.
    # With probability epsilon, we want to select randomly (uniform probability).
    # A common way to implement this is to generate a random number for each bin
    # and compare it with a threshold.
    exploration_thresholds = np.random.rand(num_bins)

    # For exploitation: if exploration_thresholds[i] > epsilon, use fit_scores[i]
    # For exploration: if exploration_thresholds[i] <= epsilon, use a random uniform score (or just 1.0 to be chosen)
    # Let's refine this: we want a high score for exploration, so any bin could be chosen.
    # We can use a fixed high score for exploration.

    exploration_scores = np.ones(num_bins) * epsilon  # Low score for exploration attempt
    exploitation_scores = (1 - epsilon) * fit_scores  # High score for exploitation

    # We want to *prefer* a bin if exploration_threshold <= epsilon.
    # A simple way is to add the epsilon probability to the best fitting bins,
    # or to make a random choice with epsilon probability.

    # Let's use the direct Epsilon-Greedy:
    # With probability epsilon, pick a random bin.
    # With probability 1-epsilon, pick the best fitting bin.

    if np.random.rand() < epsilon:
        # Explore: assign equal (high) probability to all valid bins
        valid_bins_mask = bins_remain_cap >= item
        if np.any(valid_bins_mask):
            priorities[valid_bins_mask] = 1.0 / np.sum(valid_bins_mask)
        else:
            priorities.fill(0) # No bin can fit the item
    else:
        # Exploit: assign priorities based on fit scores to valid bins
        valid_bins_mask = bins_remain_cap >= item
        if np.any(valid_bins_mask):
            priorities[valid_bins_mask] = fit_scores[valid_bins_mask]
            # Normalize priorities to sum to 1 for probabilistic selection if needed,
            # but the problem implies choosing the highest score.
            # If we are selecting the highest, we don't need to normalize here.
        else:
            priorities.fill(0) # No bin can fit the item

    # Ensure that bins that cannot fit the item have a priority of 0.
    priorities[bins_remain_cap < item] = 0

    return priorities
```
