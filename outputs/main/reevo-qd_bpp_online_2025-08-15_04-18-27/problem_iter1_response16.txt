```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    The Sigmoid Fit Score prioritizes bins that, after placing the item,
    will have a remaining capacity close to zero. This is achieved by
    mapping the difference between bin capacity and item size to a sigmoid
    function, where values closer to zero (perfect fit) result in a higher score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity if the item is placed in each bin
    potential_remaining_cap = bins_remain_cap - item

    # We want to prioritize bins where potential_remaining_cap is close to 0.
    # The sigmoid function squashes values between 0 and 1.
    # To make values close to 0 have a high score, we can use:
    # sigmoid(k * (item_size - remaining_capacity))
    # where k is a scaling factor. A larger k makes the transition sharper.
    #
    # A simpler approach, to directly penalize larger remaining capacities
    # (which means a worse fit), and reward smaller remaining capacities
    # (better fit), we can use the sigmoid of the negative of the remaining capacity.
    # Or, equivalently, the sigmoid of (item_size - bin_capacity).

    # Let's use the sigmoid of -(potential_remaining_cap) scaled by a factor.
    # We are interested in values where potential_remaining_cap is >= 0
    # and ideally close to 0.

    # Calculate the "fit quality" score: higher for smaller non-negative remaining capacities.
    # We use a steepness factor 'k' to control how quickly the score changes around a perfect fit.
    # A common sigmoid function is 1 / (1 + exp(-x)).
    # We want a high score when potential_remaining_cap is close to 0.
    # So, consider a score like sigmoid(k * (max_capacity - item - remaining_capacity)).
    # For simplicity and to focus on minimizing remaining capacity directly,
    # let's use a sigmoid on the negative difference between the item and the available capacity.
    # Or, equivalently, we want to prioritize bins where (bin_remain_cap - item) is small and non-negative.

    # Calculate how "tight" the fit is. A tighter fit means a smaller remaining capacity.
    # We can map the remaining capacity to a score where 0 is ideal.
    # Sigmoid(x) maps values to (0, 1). We want small non-negative remaining capacities to have high scores.
    # Consider using sigmoid of a value that increases as remaining capacity decreases towards zero.
    # A good candidate is sigmoid(constant - potential_remaining_cap * steepness) or sigmoid(potential_remaining_cap * steepness).
    # Let's try to reward bins that have a remaining capacity *slightly larger than the item*, as this implies a good fit.
    # However, the problem statement implies we want to *minimize* the number of bins, so placing an item
    # in a bin that perfectly fits or leaves minimal space is preferred.

    # Let's refine the sigmoid approach:
    # We want a high score for bins where `potential_remaining_cap` is close to 0.
    # The function `1 / (1 + exp(-x))` is close to 1 for large positive x, and close to 0 for large negative x.
    # So, we want to transform `potential_remaining_cap` into a value that is large positive when `potential_remaining_cap` is near 0.
    # Let's use `k * (some_ideal_remaining_capacity - potential_remaining_cap)`.
    # If we consider the "ideal" remaining capacity after packing an item to be 0, then we want to maximize `sigmoid(-k * potential_remaining_cap)`.
    # Or, even simpler, maximize `sigmoid(k * (item - bin_capacity))`. This doesn't make sense.

    # Let's focus on the condition: we only consider bins where `bins_remain_cap >= item`.
    # For these bins, we want to pick the one that results in the smallest non-negative `potential_remaining_cap`.
    # A sigmoid can transform this "smallness" into a priority.

    # If we want to prioritize bins where `potential_remaining_cap` is close to zero,
    # we can use `1 / (1 + exp(k * potential_remaining_cap))`.
    # This gives a score near 1 for small `potential_remaining_cap` and near 0 for large `potential_remaining_cap`.

    # Define a steepness factor for the sigmoid. Higher values make the priority
    # change more rapidly around the optimal fit.
    steepness = 10.0

    # Calculate the scores. For bins where `bins_remain_cap < item`, they are not valid.
    # We can assign them a very low priority or 0.
    priorities = np.zeros_like(bins_remain_cap)

    # Calculate scores only for bins that can accommodate the item
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Calculate the potential remaining capacity for valid bins
    potential_valid_remaining_cap = valid_bins_remain_cap - item

    # Apply the sigmoid function. We want higher priority for smaller remaining capacities.
    # The sigmoid function: 1 / (1 + exp(-x))
    # To give higher scores for smaller (close to 0) `potential_valid_remaining_cap`,
    # we can use `1 / (1 + exp(steepness * potential_valid_remaining_cap))`.
    # This will be close to 1 for small positive values and decrease as they grow.
    # An alternative to `1 / (1 + exp(x))` is to use `1 / (1 + exp(-x))` and
    # transform the input so that it's large negative for good fits.
    # Let's use `1 / (1 + exp(-steepness * (ideal_fit_metric - current_fit_metric)))`
    # We want `potential_remaining_cap` to be as close to 0 as possible.
    # Let's use `priorities = 1 / (1 + exp(steepness * potential_remaining_cap))`.
    # This makes scores close to 1 for `potential_remaining_cap` near 0, and close to 0 for large `potential_remaining_cap`.

    # Let's try the form: 1 / (1 + exp(k * x)). We want to minimize x.
    # If x = potential_remaining_cap, then as x approaches 0, the score approaches 1.
    # If x is large positive, the score approaches 0. This seems appropriate.
    scores = 1 / (1 + np.exp(steepness * potential_valid_remaining_cap))

    # Assign the calculated scores back to the correct positions in the full priorities array
    priorities[valid_bins_mask] = scores

    return priorities
```
