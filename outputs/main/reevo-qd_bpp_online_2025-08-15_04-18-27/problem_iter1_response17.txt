```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit.

    In Random Fit, we randomly select a subset of bins that can accommodate the item,
    and then choose the best bin from this subset using another heuristic (e.g., best fit).
    For simplicity here, we'll randomly assign higher priorities to bins that can fit,
    and the highest priority will go to a randomly selected bin that fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros (or handle as an error/new bin creation)
    if not np.any(fit_mask):
        return priorities

    # Get the indices of bins that can fit the item
    fitting_bin_indices = np.where(fit_mask)[0]

    # Assign a random high priority to all fitting bins
    # We use a uniform random distribution within a range to give variability
    # This simulates the "randomly select a subset" aspect, where fitting bins are the potential subset.
    # The "best" part from Random Fit is typically a secondary choice (e.g., best fit).
    # Here, we'll simulate this by picking one bin randomly among the fitting ones and giving it
    # an even higher priority to mimic a selection within a randomly chosen subset.

    # Assign base priority to all fitting bins
    base_priority_value = 100 # A value higher than any other potential priority in a more complex scheme
    priorities[fit_mask] = np.random.uniform(base_priority_value, base_priority_value + 10, size=np.sum(fit_mask))

    # Randomly select one of the fitting bins and give it an even higher priority
    # This simulates the selection from a randomly chosen subset, where one is ultimately picked.
    chosen_bin_index = np.random.choice(fitting_bin_indices)
    priorities[chosen_bin_index] = np.max(priorities) + 20 # Ensure this chosen one is the highest

    return priorities
```
