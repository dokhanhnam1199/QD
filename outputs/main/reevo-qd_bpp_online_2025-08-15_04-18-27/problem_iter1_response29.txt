```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Softmax-Based Fit strategy.

    The priority is higher for bins that have enough capacity and are "closer"
    to fitting the item, aiming to minimize wasted space. The softmax function
    normalizes these scores into a probability-like distribution.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very small negative number to avoid issues with log(0)
    # or if no bin can fit the item, effectively giving them near-zero probability.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Calculate a score for each bin that can potentially fit the item.
    # We want to prioritize bins that have just enough space (minimizing waste).
    # A simple heuristic is to consider the "tightness" of the fit.
    # If a bin has capacity `c` and the item is `i`, a good fit is when `c - i` is small.
    # We can use the inverse of `c - i + epsilon` (to avoid division by zero)
    # to give higher scores to tighter fits.

    # A small epsilon to avoid division by zero or extremely large values
    epsilon = 1e-6

    # Filter bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate potential scores for bins that can fit the item
    if np.any(can_fit_mask):
        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item
        # A higher score for smaller remaining capacity (tighter fit)
        # We use 1 / (remaining_capacity + epsilon)
        scores = 1.0 / (remaining_capacities_if_fit + epsilon)
        priorities[can_fit_mask] = scores

    # Apply softmax to convert scores into a probability-like distribution.
    # The bin with the highest raw score will have the highest probability.
    # Ensure we don't apply softmax to -inf if no bin can fit.
    if np.all(priorities == -np.inf):
        # If no bin can fit, return uniform low priorities (or as specified by strategy)
        # For this problem, returning zeros or a uniform small value might be reasonable,
        # but in a typical online setting, if no bin fits, a new bin is usually opened.
        # Here, we'll return uniform low scores to indicate no preference.
        return np.zeros_like(bins_remain_cap)
    else:
        # Softmax: exp(score) / sum(exp(scores))
        exp_priorities = np.exp(priorities - np.max(priorities)) # Subtract max for numerical stability
        softmax_priorities = exp_priorities / np.sum(exp_priorities)
        return softmax_priorities
```
