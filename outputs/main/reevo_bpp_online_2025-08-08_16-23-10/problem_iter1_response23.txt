```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    The Almost Full Fit strategy prioritizes bins that are "almost full" but can
    still accommodate the item. This heuristic aims to leave more space in
    less full bins for potentially larger items later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Bins that cannot fit the item have a priority of 0 (will not be selected).
    # For bins that can fit the item, we want to prioritize those that are
    # "almost full". A simple way to define "almost full" is by considering
    # the remaining capacity relative to the item's size.
    #
    # The logic is:
    # 1. Identify bins where the item can fit.
    # 2. For these bins, calculate a score that is higher for bins with less
    #    remaining capacity (i.e., more full).
    # 3. A good scoring mechanism could be the inverse of the remaining capacity,
    #    or something that increases as remaining capacity decreases.
    #    However, to be "almost full", we don't want the bins that are *exactly*
    #    full (remaining capacity = item size) but rather those where adding
    #    the item leaves a small remainder.
    #
    # A scoring mechanism could be:
    # - (bin_remain_cap - item) : This gives a negative score if it's not a good fit.
    #   We are interested in bins that fit, so `bin_remain_cap >= item`.
    # - The "tightness" of the fit can be measured by how much space is left *after*
    #   fitting the item. We want this left-over space to be small.
    #   So, `bin_remain_cap - item` should be small and non-negative.
    #
    # Let's define the priority as a value that is high when `bin_remain_cap - item`
    # is small and positive.
    # A suitable function could be:
    # priority = 1 / (bin_remain_cap - item + epsilon) where epsilon is a small
    # positive number to avoid division by zero if bin_remain_cap == item.
    # However, this gives higher priority to bins that are *barely* fitting the item,
    # which is what "almost full" implies.

    # Create a boolean mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Initialize priorities to zero
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # For bins that can fit the item, calculate the priority
    # The priority is inversely proportional to the remaining capacity after placing the item.
    # We add a small epsilon to the denominator to prevent division by zero when
    # remaining capacity exactly equals item size.
    epsilon = 1e-6
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit + epsilon)

    # Alternatively, we can express "almost full" as maximizing the remaining space
    # but not too much. A simple approach: we want the remaining capacity to be
    # as small as possible, but greater than or equal to the item size.
    # So, we can sort by `bins_remain_cap` in ascending order for those that fit.
    # A way to convert ascending sort order into higher priority is to take the
    # difference from the maximum possible remaining capacity or a derived value.

    # Let's refine the "almost full" idea. We want bins that leave a small positive
    # remainder. So, `bins_remain_cap - item` should be small and non-negative.
    # We can map this small positive remainder to a high priority.
    #
    # Consider the gap: `gap = bins_remain_cap - item`.
    # We want to maximize `-(gap)` for `gap >= 0`.
    #
    # A more direct "almost full" interpretation might be related to the
    # percentage of capacity used *after* fitting the item.
    # `percentage_used_after_fit = (bin_capacity - (bins_remain_cap - item)) / bin_capacity`
    # This is getting complicated without knowing the original bin capacity.
    #
    # Let's stick to the simpler interpretation: prioritize bins where `bins_remain_cap - item` is minimized.
    # So, the priority is inversely proportional to `bins_remain_cap - item`.
    # This makes bins where `bins_remain_cap` is just slightly larger than `item`
    # have the highest priority.

    # Let's retry with a clear definition: "Almost Full Fit" prioritizes bins that are
    # closest to being full, meaning their remaining capacity is small.
    # When we consider placing 'item', we look at `bins_remain_cap`.
    # We only consider bins where `bins_remain_cap >= item`.
    # Among these, we want the one with the *smallest* `bins_remain_cap`.
    # So, we want to sort by `bins_remain_cap` in ascending order.
    #
    # To convert this to a priority score (higher is better):
    # 1. Find the minimum remaining capacity among bins that can fit the item.
    # 2. Calculate priority based on how close a bin's remaining capacity is to this minimum.
    #
    # Let `min_fitting_remain_cap` be the smallest `bins_remain_cap` such that `bins_remain_cap >= item`.
    # Priority for bin `i` that fits: `some_function(bins_remain_cap[i] - min_fitting_remain_cap)`.
    # A simple decreasing function of this difference will work.
    # Example: `priority = 1 / (bins_remain_cap[i] - min_fitting_remain_cap + epsilon)`
    # This means bins with the smallest fitting capacity (i.e., closest to `item` but >= `item`)
    # will get the highest priority.

    if not np.any(can_fit_mask):
        # No bin can fit the item
        return priorities

    fitting_capacities = bins_remain_cap[can_fit_mask]
    # Find the minimum remaining capacity among bins that can fit the item.
    min_fitting_capacity = np.min(fitting_capacities)

    # Calculate priorities for bins that can fit the item.
    # We want to prioritize bins with `bins_remain_cap` closest to `min_fitting_capacity`.
    # A higher score for smaller difference `bins_remain_cap[i] - min_fitting_capacity`.
    # Use the inverse of the difference (plus epsilon to avoid division by zero if multiple bins have `min_fitting_capacity`).
    differences = bins_remain_cap[can_fit_mask] - min_fitting_capacity
    priorities[can_fit_mask] = 1.0 / (differences + epsilon)

    return priorities
```
