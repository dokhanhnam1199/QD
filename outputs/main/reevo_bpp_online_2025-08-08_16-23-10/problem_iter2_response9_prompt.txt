{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a First Fit Decreasing-like approach.\n\n    This heuristic prioritizes bins that can accommodate the item and\n    gives higher priority to bins that have a remaining capacity closer to the item's size.\n    This is an adaptation of the First Fit Decreasing strategy for the online setting.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value, so bins that cannot fit the item get no priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate a priority score\n    # The score is based on the \"tightness\" of the fit.\n    # A higher score means a tighter fit (remaining capacity closer to item size).\n    # We use the inverse of the difference to give higher priority to tighter fits.\n    # Adding 1 to the denominator prevents division by zero if remaining capacity is exactly the item size.\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9) # Adding a small epsilon for numerical stability\n\n    # Invert the priorities so that the highest value represents the best bin to fit into.\n    # Since we want to minimize bins, we are looking for the tightest fit.\n    # The current calculation already assigns higher values to tighter fits.\n    # So, we can directly return. However, if we wanted to prioritize bins with MORE\n    # remaining capacity for a different strategy, we might need inversion.\n    # For the First Fit concept aiming for tightest fit, the current `priorities` are good.\n    # If we want to use np.argmax, higher values are better.\n\n    # A common First Fit variation might also consider the overall remaining capacity\n    # to avoid \"wasted\" space too early. However, the prompt emphasizes a \"First Fit\"\n    # strategy, which typically implies trying to fit the item into the first available bin.\n    # Our priority here is to define \"first available\" in a way that's beneficial.\n    # The current approach prioritizes bins that are almost full and can still fit the item.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic implements a modified First Fit strategy.\n    It prioritizes bins that can fit the item. Among those that can fit,\n    it gives a higher priority to bins that have just enough remaining capacity\n    to fit the item (minimizing wasted space in that specific bin).\n    If no bin has *exactly* enough space, it falls back to the bin that\n    leaves the least amount of remaining space after packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Find bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item is placed in a bin\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Prioritize bins that have exactly enough space for the item\n    # Assign a high priority (e.g., 2) to these bins.\n    exact_fit_mask = (bins_remain_cap == item) & can_fit_mask\n    priorities[exact_fit_mask] = 2.0\n\n    # For bins that can fit but not perfectly, assign a priority based on\n    # minimizing remaining space.\n    # Assign a priority of 1 to these bins.\n    # The actual sorting will ensure that bins with less remaining space get picked first.\n    can_fit_but_not_exact_mask = can_fit_mask & ~exact_fit_mask\n    priorities[can_fit_but_not_exact_mask] = 1.0\n\n    # For bins that can fit, the secondary sorting criteria (after priority score)\n    # will be the potential remaining capacity. Lower remaining capacity is better.\n    # We can achieve this by making the priority score inversely related to the\n    # remaining capacity for bins that are not an exact fit.\n    # Since we want *least* remaining capacity to be best, and numpy sorts in\n    # ascending order for positive values, we can multiply the remaining capacity\n    # by -1 to give a higher (less negative) score to bins with less space.\n    # However, our current priority scheme already assigns 2 for exact fits and 1 for others.\n    # The subsequent selection logic typically picks the highest priority, and\n    # if priorities are tied, it looks at other criteria.\n    # For simplicity and to align with \"highest priority score means best\",\n    # let's make the priority proportional to how *tightly* it fits.\n    # Higher priority for less remaining space.\n\n    # For bins that can fit, let's assign a priority that favors less remaining space.\n    # A higher priority means we want to pick it.\n    # The value `bins_remain_cap - item` represents the *wasted* space in that bin.\n    # We want to minimize wasted space. So, we want smaller positive values of `bins_remain_cap - item`.\n    # If we want higher priority for smaller wasted space, we can use `1 / (wasted_space + epsilon)`\n    # or subtract the wasted space from a large constant.\n    # Let's try a simpler approach: give a priority that's higher for tighter fits.\n    # Bins that can fit but aren't exact fits:\n    # Priority = 1 + (maximum possible remaining capacity - actual remaining capacity) / maximum possible remaining capacity\n    # This is equivalent to: priority = 1 + (bin_cap - item) / bin_cap IF bin_cap is the same.\n    # With variable bin capacities, we can assign priority based on the remaining space *after* placing the item.\n    # Lower `bins_remain_cap - item` is better.\n    # To make higher priority better, we can use something like:\n    # `max_possible_waste - (bins_remain_cap[i] - item)` if the item fits.\n    # A more direct approach for the 'least remaining space' among fitting bins:\n    # Assign a priority that is inversely related to the remaining space.\n    # For example, `1 / (bins_remain_cap[i] - item + 1e-9)` if it fits.\n    # This makes bins with very little remaining space have very high priorities.\n\n    # Let's refine:\n    # Priority = 0 if cannot fit.\n    # Priority = 1 if fits but not exactly.\n    # Priority = 2 if fits exactly.\n    # For bins with priority 1, we need a tie-breaker: prefer bins with less remaining capacity.\n    # To incorporate this directly into the priority score for easier sorting:\n    # For bins where `can_fit_but_not_exact_mask` is true:\n    # Let's assign a priority that reflects the \"tightness\" of the fit.\n    # A higher score means a tighter fit.\n    # The potential remaining capacity after packing is `bins_remain_cap[i] - item`.\n    # We want to maximize `-(bins_remain_cap[i] - item)` (i.e., minimize `bins_remain_cap[i] - item`).\n    # So, a score like `-(bins_remain_cap[i] - item)` can work for tie-breaking.\n    # Combined priority: 2 for exact, 1 - epsilon * (remaining_after_fit) for others.\n\n    # Let's try a simpler structure for the priority score itself to directly favor less remaining space.\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # For bins that can fit the item\n    fitting_bins_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(fitting_bins_indices) > 0:\n        # Calculate remaining capacity for fitting bins\n        remaining_after_fit = bins_remain_cap[fitting_bins_indices] - item\n\n        # Assign higher priority to bins with less remaining space.\n        # A large negative number for bins with lots of remaining space,\n        # and values closer to zero for bins with very little remaining space.\n        # This way, the maximum priority will come from bins with minimal remaining space.\n        # We can use `np.max(remaining_after_fit) - remaining_after_fit`\n        # to get values where smaller remaining_after_fit results in larger priorities.\n        priorities[fitting_bins_indices] = np.max(remaining_after_fit) - remaining_after_fit\n\n        # Add a bonus for exact fits to ensure they are prioritized even if other bins have very little remaining space.\n        # For example, an exact fit (remaining_after_fit = 0) should have a higher priority than any\n        # non-exact fit where remaining_after_fit > 0.\n        # We can add a large constant to exact fits.\n        exact_fit_indices = fitting_bins_indices[remaining_after_fit == 0]\n        if len(exact_fit_indices) > 0:\n            # Ensure exact fits get a priority higher than any possible non-exact fit score.\n            # The current `remaining_after_fit` values are non-negative.\n            # The priorities we assigned are `max_waste - waste`. Max possible priority is `max_waste`.\n            # So, `max_waste + 1` for exact fits ensures they are always picked over non-exact fits if using argmax.\n            priorities[exact_fit_indices] = np.max(remaining_after_fit) + 1\n\n    return priorities\n\n[Reflection]\nPrioritize exact fits. For others, favor bins with least remaining capacity after packing.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}