```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The strategy prioritizes bins that are almost full but can still accommodate the item.
    A higher priority is given to bins with a smaller remaining capacity that can fit the item.
    If a bin cannot fit the item, its priority is 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate priority
    # The priority is inversely proportional to the remaining capacity,
    # effectively prioritizing bins that will be "almost full" after packing.
    # We add a small epsilon to avoid division by zero if a bin has exactly 'item' remaining capacity.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_remain_cap.size > 0:
        # Calculate priorities for fitting bins.
        # Higher priority for smaller remaining capacity (closer to being full).
        # Using 1 / (remaining_capacity - item + epsilon) ensures smaller remaining_capacity gives higher priority.
        # Adding a small value to denominator to avoid division by zero if remaining_capacity == item
        epsilon = 1e-9
        priorities[can_fit_mask] = 1 / (fitting_bins_remain_cap - item + epsilon)

        # Normalize priorities to have a common scale, for example, a maximum of 1.
        # This can help in scenarios where the absolute values of remaining capacities vary greatly.
        max_priority = np.max(priorities[can_fit_mask])
        if max_priority > 0:
            priorities[can_fit_mask] /= max_priority

    return priorities
```
