{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using an\n    exponentially decaying Best Fit heuristic.\n\n    This heuristic prioritizes bins that can accommodate the item. It assigns\n    a higher priority to bins with smaller remaining capacity after packing,\n    effectively implementing a \"Best Fit\" strategy. A perfect fit (zero remaining\n    capacity after packing) receives the highest possible score (1.0). The\n    priority decays exponentially as the slack (remaining capacity - item) increases.\n\n    The score for a bin is 0 if the item cannot fit. For bins that can fit,\n    the score is calculated as exp(-steepness * (remaining_capacity - item)).\n    This function ensures that perfect fits have a score of 1, and the score\n    decreases as the slack increases. The 'steepness' parameter controls how\n    rapidly the priority drops with increasing slack.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores range from 0 (cannot fit or very loose fit) to 1 (perfect fit).\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    steepness = 10.0  # Tunable parameter: Higher values mean stronger preference for tighter fits.\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the slack (unused capacity) for bins that can fit the item.\n    # slack = remaining_capacity - item. This is always >= 0 for bins in can_fit_mask.\n    slack_valid = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate the priority scores for the valid bins using the exponential function.\n    # score = exp(-steepness * slack).\n    # A slack of 0 (perfect fit) gives exp(0) = 1.\n    # Larger slacks result in scores closer to 0.\n    # We clip the argument to exp to prevent potential overflow/underflow.\n    # Since slack_valid >= 0, the argument `steepness * slack_valid` is also >= 0.\n    # We only need to worry about very large positive arguments, which cause underflow\n    # (score approaching 0). Clipping at -30.0 for the exponent is usually safe.\n    exponent_args = -steepness * slack_valid\n    clipped_exponent_args = np.clip(exponent_args, -30.0, None) # Allow positive values, but limit large negative exp(large_pos)\n\n    priorities[can_fit_mask] = np.exp(clipped_exponent_args)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n\n    This version implements the \"Best Fit\" heuristic. It prioritizes bins\n    that have the least remaining capacity *after* the item is placed,\n    thereby minimizing wasted space. Bins that cannot fit the item are given\n    a priority of 0 (or a very low score).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that have enough capacity for the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity *after* placing the item in the eligible bins\n    # We want to minimize this value for the \"best fit\"\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize the minimum remaining capacity, we can assign a score\n    # that is inversely proportional to it, or simply the negative of it.\n    # The smaller the remaining capacity (i.e., the better the fit), the higher the priority.\n    # Using the negative of the remaining capacity achieves this:\n    # -1 is higher priority than -5.\n    # A small epsilon can be added to avoid perfect zero-remaining bins getting arbitrarily high priority\n    # if other heuristics prefer variety, but for pure \"best fit\", negative remaining capacity is direct.\n    # Let's use a slightly adjusted score: higher priority for smaller remaining capacity.\n    # A common strategy is to assign a score based on the *difference* that is maximized.\n    # The difference is `bins_remain_cap - item`. We want to minimize this.\n    # So, we can assign `-(bins_remain_cap - item)` as priority.\n    # This means a smaller positive difference becomes a larger negative number, which we want to select as the maximum.\n\n    # Assign priorities to bins that can fit the item.\n    # Higher priority means smaller remaining capacity after placing the item.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities\n\n[Reflection]\nPrioritize bins with minimal remaining capacity after packing for better fit.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}