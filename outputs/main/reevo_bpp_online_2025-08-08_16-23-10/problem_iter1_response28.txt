```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    In this version, we explore and exploit bins based on a probability.
    The core idea is to balance choosing the seemingly "best" bin (greedy approach)
    with occasionally trying other bins to potentially find a better overall packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.2  # Probability of exploration (trying random bins)
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify feasible bins for the current item
    feasible_bins_mask = bins_remain_cap >= item
    feasible_bins_indices = np.where(feasible_bins_mask)[0]

    if not feasible_bins_indices.size:
        # No bin can accommodate the item, return all zeros
        return priorities

    # Greedy part: assign higher priority to bins that leave less remaining capacity
    # This is a variation of the First Fit Decreasing or Best Fit heuristic
    # where we prioritize bins that are "tightest" fits.
    # We can normalize remaining capacity to get a 'goodness' score,
    # or simply use the remaining capacity itself as an indicator for greedy choice.
    # Here, we'll favor bins with less remaining capacity among the feasible ones.
    remaining_capacities_feasible = bins_remain_cap[feasible_bins_mask]
    # A higher score indicates a better greedy choice (less remaining space)
    # So we can invert the remaining capacity or use a function like 1 / (remaining_capacity - item + 1)
    # to give higher scores to tighter fits. Adding 1 avoids division by zero.
    greedy_scores = 1.0 / (remaining_capacities_feasible - item + 1e-9)

    # Apply greedy scores to feasible bins
    priorities[feasible_bins_mask] = greedy_scores

    # Exploration part: with probability epsilon, choose a random feasible bin
    if np.random.rand() < epsilon and feasible_bins_indices.size > 0:
        random_feasible_index = np.random.choice(feasible_bins_indices)
        # Assign a uniformly high priority to the randomly chosen bin
        # to ensure it gets a chance. The value is arbitrary but should
        # be high enough to potentially override greedy scores.
        priorities = np.zeros_like(bins_remain_cap, dtype=float) # Reset priorities for exploration
        priorities[random_feasible_index] = 1.0 # Give maximum priority to the random bin
    elif feasible_bins_indices.size > 0:
        # Normalize greedy scores to a common range if needed, or just ensure they are positive
        # and that feasible bins have higher priority than infeasible ones.
        # We already set feasible bins' priorities > 0. If we want to emphasize
        # the greedy choice over random exploration for non-random picks:
        # we can amplify the greedy scores slightly.
        # Let's scale them to be between 0 and 1, for instance.
        min_greedy_score = np.min(greedy_scores)
        max_greedy_score = np.max(greedy_scores)
        if max_greedy_score - min_greedy_score > 1e-9:
            priorities[feasible_bins_mask] = (greedy_scores - min_greedy_score) / (max_greedy_score - min_greedy_score)
        else:
            # All feasible bins have the same greedy score
            priorities[feasible_bins_mask] = 0.5 # Assign a neutral high score


    return priorities

```
