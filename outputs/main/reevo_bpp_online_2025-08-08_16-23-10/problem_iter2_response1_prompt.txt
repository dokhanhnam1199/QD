{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit strategy.\n\n    In Random Fit, we consider bins that can accommodate the item. Among these,\n    we randomly select one. To implement this as a priority function where\n    the highest priority bin is chosen, we can assign a high priority to\n    eligible bins and a low priority to ineligible bins. To introduce\n    randomness within eligible bins, we can add a random perturbation to\n    their priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the item\n    eligible_bins_mask = bins_remain_cap >= item\n    \n    # Assign a base priority to eligible bins\n    # We can use the remaining capacity as a base, aiming to keep larger bins\n    # available for potentially larger future items, though Random Fit doesn't\n    # explicitly optimize for this. A simple uniform high value also works.\n    # Here, we'll use the remaining capacity itself, as it's a common heuristic\n    # for other strategies, but here it's just to provide a non-zero value.\n    priorities[eligible_bins_mask] = bins_remain_cap[eligible_bins_mask] \n    \n    # Add a random perturbation to introduce randomness among eligible bins\n    # This ensures that if multiple bins are equally \"good\" (e.g., same remaining capacity),\n    # the choice is still somewhat random.\n    random_perturbation = np.random.rand(len(bins_remain_cap)) * 0.1  # Small random value\n    priorities[eligible_bins_mask] += random_perturbation[eligible_bins_mask]\n    \n    # Ineligible bins will have a priority of 0 (as initialized),\n    # ensuring they are never chosen if eligible bins exist.\n    \n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n\n    The Exact Fit First strategy prioritizes bins that can exactly fit the item.\n    If no bin can exactly fit the item, it prioritizes bins that leave the smallest\n    remaining capacity after placing the item (Best Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can exactly fit the item\n    exact_fit_bins = (bins_remain_cap == item)\n\n    # Assign a very high priority to exact fit bins\n    # We use a large number (e.g., 1e9) to ensure these are picked first.\n    # The specific value can be tuned, but it should be significantly larger\n    # than any possible \"best fit\" priority.\n    priorities[exact_fit_bins] = 1e9\n\n    # For bins that don't exactly fit, calculate the \"best fit\" priority.\n    # We want to minimize the remaining capacity after placing the item.\n    # Therefore, a smaller (bins_remain_cap - item) is better.\n    # To translate this into a higher priority score, we can use the negative\n    # of the remaining capacity or a transformation like 1 / (remaining_capacity + epsilon).\n    # For simplicity and to ensure non-zero denominators, we'll use a negative score.\n    # We only consider bins that can actually fit the item (bins_remain_cap >= item).\n    \n    # Create a mask for bins that can fit the item but are not an exact fit\n    can_fit_and_not_exact = (bins_remain_cap >= item) & ~exact_fit_bins\n\n    # Calculate the remaining capacity for these bins\n    remaining_after_fit = bins_remain_cap[can_fit_and_not_exact] - item\n\n    # Assign priority based on remaining capacity.\n    # We want smaller remaining capacity to have higher priority.\n    # So, we assign a score that is inversely related to the remaining capacity.\n    # A simple way is to use a large value minus the remaining capacity.\n    # Here, we'll use a large base score minus the remaining capacity.\n    # The 'large base' ensures that even the best \"not exact fit\" is still lower\n    # priority than an \"exact fit\".\n    \n    # Calculate a 'goodness' score for non-exact fits: higher score for smaller remaining capacity\n    # We want to rank these from smallest remaining capacity to largest.\n    # A simple inverse relation or subtracting from a large number works.\n    # Let's subtract the remaining capacity from a large number.\n    # This ensures that a bin with remaining_after_fit=1 has a higher priority than\n    # remaining_after_fit=2, given they are both not exact fits.\n    \n    # Assign priorities for bins that can fit but not exactly\n    # We use a base value that is lower than the exact fit priority,\n    # and then subtract the remaining capacity.\n    # The smaller the remaining_after_fit, the higher the priority for these bins.\n    # For example, if remaining_after_fit = 0.1, priority is 100 - 0.1 = 99.9\n    # If remaining_after_fit = 0.5, priority is 100 - 0.5 = 99.5\n    \n    # To make it consistent with the \"exact fit first\" and then \"best fit\"\n    # the priority score itself should reflect this hierarchy.\n    # Priority for exact fit is `high_priority_value`.\n    # Priority for best fit should be lower, but ordered by smallest `remaining_capacity`.\n    # We can use `score = high_priority_value - epsilon - remaining_capacity`.\n    # Let's use a tiered system:\n    # Tier 1: Exact Fit (priority = 2)\n    # Tier 2: Best Fit (priority = 1 - (remaining_capacity / MAX_CAPACITY)) to keep it positive and ordered.\n    # A simpler approach:\n    # Exact fit bins get priority 1.\n    # Non-exact fit bins that can fit get priority proportional to the inverse of remaining capacity.\n    # Or even simpler: exact fit gets a very high score, others get scores based on their goodness.\n\n    # Let's refine the priority:\n    # Exact fit: priority = 1 (highest category)\n    # Can fit, but not exact fit: priority = 1 - (remaining_capacity / MAX_BIN_CAPACITY)\n    # This way, a smaller remaining capacity gives a higher priority (closer to 1).\n    # Bins that cannot fit should have a priority of 0 or negative.\n\n    # Let's assign 1.0 to exact fits.\n    # For other bins that can fit, let's assign a priority that's a function of\n    # minimizing the remaining space. We want smaller remaining space to be better.\n    # A common approach for \"best fit\" is to maximize `-(remaining_space)`.\n    # So, priority is `- (bins_remain_cap - item)`.\n    # We need to ensure that exact fits are always preferred over non-exact fits.\n\n    # Let's try this scoring:\n    # Exact fit bins: score = infinity (or a very large number)\n    # Non-exact fit bins that can fit: score = 1 / (remaining_capacity + epsilon) - this is prone to large numbers and requires careful scaling.\n    # A more robust way:\n    # Exact fit bins get priority = 2\n    # Bins that can fit, but not exactly: priority = 1 - (bins_remain_cap - item) / MAX_POSSIBLE_REMAINING_CAPACITY.\n    # Bins that cannot fit: priority = 0.\n\n    # A common heuristic approach is to assign discrete levels of priority.\n    # Level 1: Exact Fit\n    # Level 2: Best Fit among those that can fit\n    # Level 0: Cannot fit\n\n    # Let's assign scores directly.\n    # Assign a score to bins that exactly fit.\n    # For bins that can fit but not exactly, assign a score based on how \"close\" they are.\n    # The closer the fit (smaller remaining capacity), the higher the score.\n\n    # Initialize priorities to 0 (representing bins that cannot fit the item)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item (remaining capacity >= item size)\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, we want to find the \"exact fit\" first.\n    # If there are exact fits, give them the highest priority.\n    # Otherwise, give priority based on \"best fit\".\n\n    # Identify exact fit bins\n    exact_fit_mask = (bins_remain_cap == item)\n\n    # Assign highest priority to exact fit bins.\n    # Let's use a scale where higher number is better.\n    # Assigning a value like 1000 for exact fit.\n    priorities[exact_fit_mask] = 1000.0\n\n    # For bins that can fit but are not exact fits, assign a secondary priority.\n    # The priority should be higher for bins with smaller remaining capacity.\n    # We can use a score like: max_possible_remaining - actual_remaining.\n    # To ensure these secondary priorities are lower than exact fit, we can subtract\n    # from a value lower than 1000.\n\n    # Consider only bins that can fit but are not exact fits.\n    non_exact_can_fit_mask = can_fit_mask & ~exact_fit_mask\n\n    # Calculate the remaining capacity for these bins\n    remaining_after_fit_values = bins_remain_cap[non_exact_can_fit_mask] - item\n\n    # To give higher priority to smaller remaining capacities, we can invert it.\n    # For example, if max capacity is 1.0, and item is 0.3:\n    # Remaining capacities: 0.7, 0.5, 0.2\n    # We want priorities: high for 0.2, then 0.5, then 0.7.\n    # A simple inversion like 1 / (remaining_capacity + epsilon) can work,\n    # but might lead to very large numbers if remaining_capacity is small.\n    # A better approach is to use a decreasing function of remaining capacity.\n    # We can map remaining capacities to priorities that are always less than the exact fit priority.\n    # Let's use a large base value (e.g., 900) and subtract a scaled version of remaining capacity.\n    # The maximum possible remaining capacity for a bin that can fit item `i` is `MAX_BIN_CAPACITY - i`.\n    # So, `remaining_after_fit_values` will be in the range `[0, MAX_BIN_CAPACITY - item]`.\n    # We want the highest priority for `remaining_after_fit_values = 0` (which would be exact fit, already handled).\n    # So we focus on `remaining_after_fit_values > 0`.\n    # We want the smallest `remaining_after_fit_values` to have the highest priority within this group.\n    # Let's define a score: `base_score_for_non_exact - remaining_after_fit`.\n    # The `base_score_for_non_exact` should be less than 1000. Let's use 999.\n    # Then the priority for a bin with remaining capacity `R` is `999 - R`.\n    # This prioritizes smaller `R` (closer fits).\n\n    if np.any(non_exact_can_fit_mask):\n        # Assuming bins_remain_cap are always positive and item is positive.\n        # Max possible remaining capacity for a bin that fits item `i` can be bounded by the max capacity of any bin.\n        # A robust approach might use a normalizing factor if bin capacities vary wildly,\n        # but for a fixed capacity bin (as implied by BPP), we can use a value related to that.\n        # Let's just use a score that decreases with remaining capacity.\n        # Example: `999 - remaining_after_fit_values`.\n        priorities[non_exact_can_fit_mask] = 999.0 - remaining_after_fit_values\n\n    return priorities\n\n[Reflection]\nPrioritize exact fits. Then, prioritize minimum remaining capacity.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}