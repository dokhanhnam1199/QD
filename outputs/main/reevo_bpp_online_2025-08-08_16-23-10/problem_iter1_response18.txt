```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    The Epsilon-Greedy strategy balances exploration (trying less optimal bins)
    and exploitation (choosing the best bin).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploration

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit, return zero priorities (this shouldn't happen in a well-defined scenario)
    if not np.any(can_fit_mask):
        return np.zeros_like(bins_remain_cap)

    # Exploitation: Calculate the "goodness" of fitting the item into each capable bin.
    # A good heuristic is to prioritize bins that leave minimal remaining space
    # after packing the item (i.e., minimize waste).
    # We want to maximize this score, so we use (bins_remain_cap - item).
    # Adding a small constant to avoid zero scores for perfect fits might be considered,
    # but for simplicity, we'll keep it as is.
    exploitation_scores = np.zeros_like(bins_remain_cap)
    exploitation_scores[can_fit_mask] = bins_remain_cap[can_fit_mask] - item

    # Exploration: Randomly select bins to explore.
    # With probability epsilon, we choose a random bin that can fit the item.
    # We assign a random positive score to encourage trying it.
    exploration_scores = np.zeros_like(bins_remain_cap)
    num_capable_bins = np.sum(can_fit_mask)
    if num_capable_bins > 0:
        random_indices = np.random.choice(np.where(can_fit_mask)[0], size=max(1, int(epsilon * num_capable_bins)), replace=False)
        # Assign a score to encourage exploration. A small positive value is sufficient.
        # We can also add a small random noise to differentiate exploration choices.
        exploration_scores[random_indices] = np.random.rand(len(random_indices)) * 0.1 # Small random value

    # Combine exploitation and exploration
    # The idea is that with probability (1-epsilon), we use the exploitation score.
    # With probability epsilon, we might pick a random bin (exploration_scores).
    # A simple way to combine is to use a weighted sum, but for a priority function
    # where we select the max, we can think of it as:
    # if random() < epsilon: use exploration score; else: use exploitation score.
    # For generating a priority array, we can modify exploitation scores based on epsilon.
    priorities = exploitation_scores.copy()

    # Introduce some randomness to the best bins based on epsilon
    # This is a common way to implement epsilon-greedy for selection
    # For priority scores, we can add noise to exploitation scores with probability epsilon
    noise_mask = np.random.rand(len(bins_remain_cap)) < epsilon
    noise_mask = np.logical_and(noise_mask, can_fit_mask) # Only add noise to bins that can fit

    # Add small random noise to some of the capable bins to encourage exploration
    # The magnitude of the noise should be small enough not to overpower good exploitation choices
    noise = np.random.rand(len(bins_remain_cap)) * 0.05 # Small noise
    priorities[noise_mask] += noise[noise_mask]

    # Ensure that bins that cannot fit have zero priority.
    priorities[~can_fit_mask] = 0

    return priorities
```
