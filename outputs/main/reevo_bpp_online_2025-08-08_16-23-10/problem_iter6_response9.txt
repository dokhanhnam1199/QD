```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, prioritizing tight fits and item/bin proportion.

    This heuristic prioritizes bins that can accommodate the item and result in a
    small remaining capacity after packing (tight fit). It also incorporates a
    secondary factor that favors packing the item into bins where it represents
    a larger proportion of the *current* remaining capacity. This dual objective
    aims to minimize wasted space by finding tight fits and by encouraging
    larger items to occupy relatively larger available slots.

    The score for a bin is calculated using a sigmoid function applied to the
    "fit gap" (remaining capacity after packing). A smaller fit gap (tighter fit)
    results in a higher score. The sigmoid function `1 / (1 + exp(-k * gap))`
    maps smaller gaps to scores closer to 1.

    The secondary factor is `item / (initial_remaining_capacity + epsilon)`,
    which is high when the item is large relative to the bin's current capacity.

    The final priority is the product of these two scores.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Scores range from 0 (cannot fit) to approximately 1 (excellent fit).
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to avoid division by zero.
    steepness = 15.0 # Tunable parameter: higher values mean stronger preference for tighter fits.

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity for bins that can fit the item.
    # The 'fit gap' is the remaining capacity *after* placing the item.
    # We want to minimize this gap for tight fits.
    fit_gaps = bins_remain_cap[can_fit_mask] - item
    initial_remaining_caps = bins_remain_cap[can_fit_mask]

    # Primary criterion: Tight fit using a sigmoid function.
    # We use `1 / (1 + exp(-steepness * fit_gap))` which results in scores
    # approaching 1 for smaller `fit_gaps` (tighter fits).
    # A perfect fit (fit_gap = 0) gives a score of 0.5.
    # Scores increase as `fit_gap` becomes smaller (approaching 0).
    exponent_args_tight_fit = -steepness * fit_gaps
    # Clip to prevent overflow/underflow in np.exp.
    clipped_exponent_args = np.clip(exponent_args_tight_fit, -30.0, 30.0)
    tight_fit_score = 1.0 / (1.0 + np.exp(clipped_exponent_args))

    # Secondary criterion: Item proportion of current bin capacity.
    # This encourages packing larger items into relatively larger available bins.
    # A higher score is given if the item is a larger fraction of the current bin capacity.
    proportion_score = item / (initial_remaining_caps + epsilon)

    # Combine scores by multiplication.
    # This prioritizes bins that are both a tight fit AND where the item
    # represents a significant portion of the available space.
    priorities[can_fit_mask] = tight_fit_score * proportion_score

    return priorities
```
