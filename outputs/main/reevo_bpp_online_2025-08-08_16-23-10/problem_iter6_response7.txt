```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a tailored inverse mapping with a scaling factor.

    This heuristic prioritizes bins where placing the item leaves the least amount
    of remaining capacity. It calculates the "resulting remaining capacity" for each
    bin that can fit the item and then applies a transformation that maps smaller
    resulting remaining capacities to higher priority scores. The transformation
    involves taking the inverse of the resulting remaining capacity, adding a
    small epsilon to prevent division by zero, and then scaling this value.
    A sensitivity parameter `k` controls how strongly tighter fits are favored.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    # Initialize priorities to zero for all bins. Bins that cannot fit the item will retain this zero priority.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that have enough remaining capacity to fit the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* placing the item.
    # We want to prioritize bins where this resulting remaining capacity is minimized.
    resulting_remaining_cap = bins_remain_cap[can_fit_mask] - item

    # To prioritize smaller resulting remaining capacities, we use a transformation.
    # A common approach is to use the inverse: 1 / (resulting_remaining_cap).
    # This naturally gives higher values for smaller resulting capacities.
    # Add a small epsilon to avoid division by zero or extremely large values when resulting_remaining_cap is very close to zero.
    epsilon = 1e-9
    
    # Scale the inverse by a factor 'k'. A larger 'k' amplifies the difference between bins,
    # making the priority more sensitive to smaller resulting remaining capacities.
    # This is an alternative to the sigmoid in v1, aiming for a more direct mapping of tightness.
    k = 20.0  # Sensitivity parameter: Controls how strongly tighter fits are favored.
    
    # The transformed score directly reflects how "tight" the fit is.
    # A resulting_remaining_cap of 0 gives k / epsilon, which is a very high score.
    # As resulting_remaining_cap increases, the score decreases.
    transformed_scores = k / (resulting_remaining_cap + epsilon)

    # Assign the calculated transformed scores to the bins that can fit the item.
    priorities[can_fit_mask] = transformed_scores

    return priorities
```
