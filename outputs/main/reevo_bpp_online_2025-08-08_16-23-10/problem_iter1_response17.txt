```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit strategy.

    In Random Fit, we consider bins that can accommodate the item. Among these,
    we randomly select one. To implement this as a priority function where
    the highest priority bin is chosen, we can assign a high priority to
    eligible bins and a low priority to ineligible bins. To introduce
    randomness within eligible bins, we can add a random perturbation to
    their priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    eligible_bins_mask = bins_remain_cap >= item
    
    # Assign a base priority to eligible bins
    # We can use the remaining capacity as a base, aiming to keep larger bins
    # available for potentially larger future items, though Random Fit doesn't
    # explicitly optimize for this. A simple uniform high value also works.
    # Here, we'll use the remaining capacity itself, as it's a common heuristic
    # for other strategies, but here it's just to provide a non-zero value.
    priorities[eligible_bins_mask] = bins_remain_cap[eligible_bins_mask] 
    
    # Add a random perturbation to introduce randomness among eligible bins
    # This ensures that if multiple bins are equally "good" (e.g., same remaining capacity),
    # the choice is still somewhat random.
    random_perturbation = np.random.rand(len(bins_remain_cap)) * 0.1  # Small random value
    priorities[eligible_bins_mask] += random_perturbation[eligible_bins_mask]
    
    # Ineligible bins will have a priority of 0 (as initialized),
    # ensuring they are never chosen if eligible bins exist.
    
    return priorities
```
