{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a refined Best Fit strategy.\n\n    This strategy prioritizes bins that have the smallest remaining capacity after packing the item,\n    provided the item fits. Bins that cannot accommodate the item receive a priority of 0.\n    The priority score is designed such that bins with a remaining capacity closer to zero\n    receive higher scores. A sigmoid function is used to provide a smooth ranking.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # For bins that can fit the item, calculate the remaining capacity after packing\n    potential_remaining_cap = bins_remain_cap - item\n    \n    # We want to prioritize bins with the smallest non-negative remaining capacity.\n    # This is a \"Best Fit\" approach. To translate this into a priority score\n    # where higher is better, we can use a function that decreases as\n    # `potential_remaining_cap` increases for `potential_remaining_cap >= 0`.\n    # A sigmoid function of the form `1 / (1 + exp(k * x))` is decreasing if `k > 0`.\n    # Let `x = potential_remaining_cap`.\n    # The larger `potential_remaining_cap` is, the smaller the score will be.\n    # The ideal case is `potential_remaining_cap = 0`, which gives a score of 0.5.\n    # Larger positive remaining capacity gives scores less than 0.5, approaching 0.\n    # This accurately ranks bins by their \"tightness\" of fit among eligible bins.\n    \n    # A steepness parameter controls how quickly the priority drops as remaining capacity increases.\n    # A higher steepness means a stronger preference for tighter fits.\n    steepness = 10.0 # Tunable parameter, higher means more preference for tighter fits\n\n    # Calculate the argument for the sigmoid function for eligible bins.\n    # We use `potential_remaining_cap` directly.\n    exponent_args = steepness * potential_remaining_cap[can_fit_mask]\n    \n    # To avoid numerical overflow/underflow with np.exp, clip the exponent arguments.\n    # Values like exp(700) or exp(-700) can cause issues. A range of [-30, 30] is usually safe.\n    clipped_exponent_args = np.clip(exponent_args, -30.0, 30.0)\n    \n    # Calculate the priority scores using the sigmoid function for eligible bins.\n    # The score will be between (0, 1). Higher scores mean a better fit.\n    priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(clipped_exponent_args))\n    \n    # Bins that cannot fit the item (can_fit_mask is False) retain their initial priority of 0.\n    \n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n\n    This version implements the \"Best Fit\" heuristic. It prioritizes bins\n    that have the least remaining capacity *after* the item is placed,\n    thereby minimizing wasted space. Bins that cannot fit the item are given\n    a priority of 0 (or a very low score).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that have enough capacity for the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity *after* placing the item in the eligible bins\n    # We want to minimize this value for the \"best fit\"\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize the minimum remaining capacity, we can assign a score\n    # that is inversely proportional to it, or simply the negative of it.\n    # The smaller the remaining capacity (i.e., the better the fit), the higher the priority.\n    # Using the negative of the remaining capacity achieves this:\n    # -1 is higher priority than -5.\n    # A small epsilon can be added to avoid perfect zero-remaining bins getting arbitrarily high priority\n    # if other heuristics prefer variety, but for pure \"best fit\", negative remaining capacity is direct.\n    # Let's use a slightly adjusted score: higher priority for smaller remaining capacity.\n    # A common strategy is to assign a score based on the *difference* that is maximized.\n    # The difference is `bins_remain_cap - item`. We want to minimize this.\n    # So, we can assign `-(bins_remain_cap - item)` as priority.\n    # This means a smaller positive difference becomes a larger negative number, which we want to select as the maximum.\n\n    # Assign priorities to bins that can fit the item.\n    # Higher priority means smaller remaining capacity after placing the item.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities\n\n[Reflection]\nPrioritize tighter fits by directly minimizing remaining capacity, avoiding complex functions.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}