```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy with emphasis on tighter fits.

    This version refines the Sigmoid Fit Score by directly focusing on the
    "tightness" of the fit, which is inversely related to the remaining capacity.
    A tighter fit (smaller remaining capacity) should yield a higher priority score.
    The sigmoid function is used to map this tightness to a normalized priority score between 0 and 1.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # For bins that can fit the item, calculate the resulting remaining capacity.
    # We want to prioritize bins where this resulting remaining capacity is minimized.
    resulting_remaining_cap = bins_remain_cap[can_fit_mask] - item

    # To prioritize smaller remaining capacities, we can use the inverse of
    # the resulting remaining capacity as a measure of "fit tightness".
    # A smaller resulting capacity means a larger inverse, hence a tighter fit.
    # Add a small epsilon to avoid division by zero or extremely large values.
    epsilon = 1e-9
    fit_tightness = 1.0 / (resulting_remaining_cap + epsilon)

    # Apply a sigmoid function to normalize the tightness scores and control
    # the sensitivity to different degrees of tightness.
    # The sigmoid function `1 / (1 + exp(-x))` maps larger x to values closer to 1.
    # We scale `fit_tightness` by a factor `k` to control how strongly we
    # favor tighter fits. A larger `k` means a steeper increase in priority
    # as the fit becomes tighter.
    k = 10.0  # Sensitivity parameter: higher k favors tighter fits more strongly.
    scaled_tightness = k * fit_tightness
    sigmoid_scores = 1 / (1 + np.exp(-scaled_tightness))

    # Assign the calculated sigmoid scores to the bins that can fit the item.
    priorities[can_fit_mask] = sigmoid_scores

    return priorities
```
