```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First then Best Fit.

    The strategy prioritizes bins that can exactly fit the item (Exact Fit).
    If no bin can exactly fit the item, it prioritizes bins that leave the
    smallest remaining capacity after placing the item (Best Fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign priorities:
    # 1. Exact Fit: Highest priority.
    # 2. Best Fit: Remaining capacity is minimized.

    # Identify exact fit bins
    exact_fit_mask = (bins_remain_cap == item)

    # Assign a very high priority to exact fit bins.
    # A score like 1.0 can represent the highest tier.
    priorities[exact_fit_mask] = 1.0

    # For bins that can fit but are not exact fits, assign a secondary priority.
    # This priority should be less than 1.0 and higher for bins with smaller remaining capacity.
    # We can use a score derived from the remaining capacity: `1 - (remaining_capacity / MAX_POSSIBLE_REMAINING_CAPACITY)`.
    # A simpler approach is to directly rank by remaining capacity, ensuring it's lower than exact fit.
    # We can use `1 - (remaining_capacity / sum_of_all_capacities)` or a similar normalization,
    # but for simplicity and to maintain hierarchy, we can subtract the remaining capacity from a value just below 1.0.

    # Consider only bins that can fit but are not exact fits.
    non_exact_can_fit_mask = can_fit_mask & ~exact_fit_mask

    if np.any(non_exact_can_fit_mask):
        # Calculate the remaining capacity after fitting the item for these bins.
        remaining_after_fit_values = bins_remain_cap[non_exact_can_fit_mask] - item

        # To prioritize smaller remaining capacities, we can use a score that
        # decreases as remaining capacity increases.
        # A common approach is to use `-(remaining_capacity)` or `max_capacity - remaining_capacity`.
        # To keep scores between 0 and 1 (and lower than exact fit priority of 1.0),
        # we can normalize the remaining capacity.
        # Let's create a score that is high for small remaining capacity.
        # We can achieve this by subtracting the `remaining_after_fit_values` from a value slightly less than 1.0,
        # and then potentially scaling it.
        # A simple way to ensure smaller `remaining_after_fit_values` get higher scores (closer to 1.0, but less than 1.0)
        # is to map the range of `remaining_after_fit_values` to `[0, 0.99]`.
        # If `remaining_after_fit_values` are all positive (which they are, as we excluded exact fits),
        # the smallest value will give the highest priority in this tier.

        # To ensure a proper ordering and a value less than 1.0, we can use:
        # `priority = 0.99 - (remaining_after_fit_values / MAX_EXPECTED_REMAINING)`
        # Or a simpler approach: just use the negative of the remaining capacity,
        # and shift it to be positive and less than 1.0.
        # Example: if remaining capacities are [0.1, 0.5], we want priorities like [0.9, 0.5].
        # This can be achieved by `0.99 - remaining_after_fit_values`.
        # This assigns a higher priority to bins with smaller remaining capacity.
        # The maximum possible remaining capacity for a bin fitting `item` is `max(bins_remain_cap) - item`.
        # However, a simpler fixed scaling can work.

        # Let's assign priorities in the range [0, 0.99].
        # We want smaller `remaining_after_fit_values` to have higher priorities.
        # A simple way is to use `base_score - remaining_capacity`.
        # Let's set a `base_score = 0.99`.
        priorities[non_exact_can_fit_mask] = 0.99 - remaining_after_fit_values

    # Bins that cannot fit the item retain their initial priority of 0.

    return priorities
```
