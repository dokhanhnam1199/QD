```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a tuned Sigmoid Best Fit.

    This heuristic prioritizes bins that can accommodate the item and have the smallest
    remaining capacity after packing (Best Fit strategy). The priority is calculated
    using a sigmoid function with a tunable steepness and an offset. The offset
    introduces a preference for already "good" fits to be even more prioritized,
    especially when considering the proportion of item size to bin capacity.

    The score for a bin is 0 if the item cannot fit. For bins that can fit, the score
    is calculated as 1 / (1 + exp(steepness * (remaining_capacity - item - offset))).
    This function is monotonically decreasing with respect to (remaining_capacity - item - offset).
    A smaller (remaining_capacity - item - offset) leads to a higher score.
    The offset is designed to slightly favor tighter fits that are still relatively generous,
    preventing extremely tight fits from dominating to the exclusion of all else.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Scores range from 0 (cannot fit or very loose fit) to 1 (ideal fit).
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    steepness = 7.0  # Tunable parameter: higher values mean stronger preference for tight fits.
    # Offset to slightly favor fits that are tight but not excessively so.
    # This can be related to item size or bin capacity proportions. Here, a fixed offset is used.
    offset = 0.1 * item # Offset scales with item size, encouraging tighter fits for larger items.

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the effective remaining capacity for bins that can fit the item.
    # This adjusted value includes the offset.
    effective_remaining_cap_valid = bins_remain_cap[can_fit_mask] - item - offset

    # Calculate the exponent argument for the sigmoid function.
    # We want to prioritize smaller `effective_remaining_cap_valid`.
    # The function `1 / (1 + exp(x))` is decreasing in `x`.
    # We set `x = steepness * effective_remaining_cap_valid`.
    # A small `effective_remaining_cap_valid` (tight fit relative to offset) results in a smaller `x`, thus a higher score.
    # A large `effective_remaining_cap_valid` (loose fit relative to offset) results in a larger `x`, thus a lower score.
    exponent_args = steepness * effective_remaining_cap_valid

    # Clip the exponent arguments to prevent potential overflow/underflow in np.exp.
    # A wider range might be acceptable depending on the exact sigmoid behavior desired.
    # [-30, 30] is generally safe for standard float precision.
    clipped_exponent_args = np.clip(exponent_args, -30.0, 30.0)

    # Calculate the priority scores for the valid bins using the sigmoid function.
    # Scores for bins that cannot fit remain 0.
    priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(clipped_exponent_args))

    return priorities
```
