{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using a refined\n    Best Fit strategy with a weighted approach.\n\n    This heuristic prioritizes bins that can accommodate the item. Among these,\n    it strongly favors bins that result in a near-perfect fit (minimal remaining\n    capacity after packing). It also slightly favors bins with more remaining\n    capacity if the \"tightness\" is similar, providing a smoother transition\n    and preventing premature commitment to very small bins that might be better\n    suited for future smaller items.\n\n    The score for a bin is calculated as:\n    score = (1 / (1 + exp(steepness * (remaining_capacity - item)))) * (1 + bonus_factor * (bins_remain_cap[i] - item))\n    where the first term is the \"tightness score\" and the second term is a \"capacity bonus\".\n    The score is 0 if the item cannot fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores range from 0 (cannot fit or very loose fit) to a value greater than 1\n        (ideal fit with high initial capacity).\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    steepness = 5.0  # Tunable parameter: higher values mean stronger preference for tight fits.\n    bonus_factor = 0.1 # Tunable parameter: influences how much more capacity is preferred for similar tightness.\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity for bins that can fit the item.\n    remaining_after_packing = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate the \"tightness score\" using a sigmoid function.\n    # Smaller remaining_after_packing results in a score closer to 1.\n    exponent_args_tightness = steepness * remaining_after_packing\n    clipped_exponent_args_tightness = np.clip(exponent_args_tightness, -30.0, 30.0)\n    tightness_scores = 1.0 / (1.0 + np.exp(clipped_exponent_args_tightness))\n\n    # Calculate the \"capacity bonus\".\n    # This term slightly increases the score for bins that have more remaining capacity\n    # *before* packing, when the tightness is comparable.\n    # We normalize this bonus by the item size to make it less sensitive to absolute bin capacities.\n    # Adding 1 ensures that bins with exactly the same tightness as the item are not penalized.\n    capacity_bonus = 1.0 + bonus_factor * (bins_remain_cap[can_fit_mask] / item) if item > 0 else 1.0\n\n    # Combine the scores. The tightness score is the primary driver,\n    # and the capacity bonus provides a secondary preference.\n    priorities[can_fit_mask] = tightness_scores * capacity_bonus\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n\n    This version implements the \"Best Fit\" heuristic. It prioritizes bins\n    that have the least remaining capacity *after* the item is placed,\n    thereby minimizing wasted space. Bins that cannot fit the item are given\n    a priority of 0 (or a very low score).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that have enough capacity for the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity *after* placing the item in the eligible bins\n    # We want to minimize this value for the \"best fit\"\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize the minimum remaining capacity, we can assign a score\n    # that is inversely proportional to it, or simply the negative of it.\n    # The smaller the remaining capacity (i.e., the better the fit), the higher the priority.\n    # Using the negative of the remaining capacity achieves this:\n    # -1 is higher priority than -5.\n    # A small epsilon can be added to avoid perfect zero-remaining bins getting arbitrarily high priority\n    # if other heuristics prefer variety, but for pure \"best fit\", negative remaining capacity is direct.\n    # Let's use a slightly adjusted score: higher priority for smaller remaining capacity.\n    # A common strategy is to assign a score based on the *difference* that is maximized.\n    # The difference is `bins_remain_cap - item`. We want to minimize this.\n    # So, we can assign `-(bins_remain_cap - item)` as priority.\n    # This means a smaller positive difference becomes a larger negative number, which we want to select as the maximum.\n\n    # Assign priorities to bins that can fit the item.\n    # Higher priority means smaller remaining capacity after placing the item.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities\n\n[Reflection]\nPrioritize minimal remaining capacity, then consider item size and bin capacity dynamics.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}