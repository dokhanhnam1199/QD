```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    The Exact Fit First strategy prioritizes bins that can exactly fit the item.
    If no bin can exactly fit the item, it prioritizes bins that leave the smallest
    remaining capacity after placing the item (Best Fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can exactly fit the item
    exact_fit_bins = (bins_remain_cap == item)

    # Assign a very high priority to exact fit bins
    # We use a large number (e.g., 1e9) to ensure these are picked first.
    # The specific value can be tuned, but it should be significantly larger
    # than any possible "best fit" priority.
    priorities[exact_fit_bins] = 1e9

    # For bins that don't exactly fit, calculate the "best fit" priority.
    # We want to minimize the remaining capacity after placing the item.
    # Therefore, a smaller (bins_remain_cap - item) is better.
    # To translate this into a higher priority score, we can use the negative
    # of the remaining capacity or a transformation like 1 / (remaining_capacity + epsilon).
    # For simplicity and to ensure non-zero denominators, we'll use a negative score.
    # We only consider bins that can actually fit the item (bins_remain_cap >= item).
    
    # Create a mask for bins that can fit the item but are not an exact fit
    can_fit_and_not_exact = (bins_remain_cap >= item) & ~exact_fit_bins

    # Calculate the remaining capacity for these bins
    remaining_after_fit = bins_remain_cap[can_fit_and_not_exact] - item

    # Assign priority based on remaining capacity.
    # We want smaller remaining capacity to have higher priority.
    # So, we assign a score that is inversely related to the remaining capacity.
    # A simple way is to use a large value minus the remaining capacity.
    # Here, we'll use a large base score minus the remaining capacity.
    # The 'large base' ensures that even the best "not exact fit" is still lower
    # priority than an "exact fit".
    
    # Calculate a 'goodness' score for non-exact fits: higher score for smaller remaining capacity
    # We want to rank these from smallest remaining capacity to largest.
    # A simple inverse relation or subtracting from a large number works.
    # Let's subtract the remaining capacity from a large number.
    # This ensures that a bin with remaining_after_fit=1 has a higher priority than
    # remaining_after_fit=2, given they are both not exact fits.
    
    # Assign priorities for bins that can fit but not exactly
    # We use a base value that is lower than the exact fit priority,
    # and then subtract the remaining capacity.
    # The smaller the remaining_after_fit, the higher the priority for these bins.
    # For example, if remaining_after_fit = 0.1, priority is 100 - 0.1 = 99.9
    # If remaining_after_fit = 0.5, priority is 100 - 0.5 = 99.5
    
    # To make it consistent with the "exact fit first" and then "best fit"
    # the priority score itself should reflect this hierarchy.
    # Priority for exact fit is `high_priority_value`.
    # Priority for best fit should be lower, but ordered by smallest `remaining_capacity`.
    # We can use `score = high_priority_value - epsilon - remaining_capacity`.
    # Let's use a tiered system:
    # Tier 1: Exact Fit (priority = 2)
    # Tier 2: Best Fit (priority = 1 - (remaining_capacity / MAX_CAPACITY)) to keep it positive and ordered.
    # A simpler approach:
    # Exact fit bins get priority 1.
    # Non-exact fit bins that can fit get priority proportional to the inverse of remaining capacity.
    # Or even simpler: exact fit gets a very high score, others get scores based on their goodness.

    # Let's refine the priority:
    # Exact fit: priority = 1 (highest category)
    # Can fit, but not exact fit: priority = 1 - (remaining_capacity / MAX_BIN_CAPACITY)
    # This way, a smaller remaining capacity gives a higher priority (closer to 1).
    # Bins that cannot fit should have a priority of 0 or negative.

    # Let's assign 1.0 to exact fits.
    # For other bins that can fit, let's assign a priority that's a function of
    # minimizing the remaining space. We want smaller remaining space to be better.
    # A common approach for "best fit" is to maximize `-(remaining_space)`.
    # So, priority is `- (bins_remain_cap - item)`.
    # We need to ensure that exact fits are always preferred over non-exact fits.

    # Let's try this scoring:
    # Exact fit bins: score = infinity (or a very large number)
    # Non-exact fit bins that can fit: score = 1 / (remaining_capacity + epsilon) - this is prone to large numbers and requires careful scaling.
    # A more robust way:
    # Exact fit bins get priority = 2
    # Bins that can fit, but not exactly: priority = 1 - (bins_remain_cap - item) / MAX_POSSIBLE_REMAINING_CAPACITY.
    # Bins that cannot fit: priority = 0.

    # A common heuristic approach is to assign discrete levels of priority.
    # Level 1: Exact Fit
    # Level 2: Best Fit among those that can fit
    # Level 0: Cannot fit

    # Let's assign scores directly.
    # Assign a score to bins that exactly fit.
    # For bins that can fit but not exactly, assign a score based on how "close" they are.
    # The closer the fit (smaller remaining capacity), the higher the score.

    # Initialize priorities to 0 (representing bins that cannot fit the item)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item (remaining capacity >= item size)
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, we want to find the "exact fit" first.
    # If there are exact fits, give them the highest priority.
    # Otherwise, give priority based on "best fit".

    # Identify exact fit bins
    exact_fit_mask = (bins_remain_cap == item)

    # Assign highest priority to exact fit bins.
    # Let's use a scale where higher number is better.
    # Assigning a value like 1000 for exact fit.
    priorities[exact_fit_mask] = 1000.0

    # For bins that can fit but are not exact fits, assign a secondary priority.
    # The priority should be higher for bins with smaller remaining capacity.
    # We can use a score like: max_possible_remaining - actual_remaining.
    # To ensure these secondary priorities are lower than exact fit, we can subtract
    # from a value lower than 1000.

    # Consider only bins that can fit but are not exact fits.
    non_exact_can_fit_mask = can_fit_mask & ~exact_fit_mask

    # Calculate the remaining capacity for these bins
    remaining_after_fit_values = bins_remain_cap[non_exact_can_fit_mask] - item

    # To give higher priority to smaller remaining capacities, we can invert it.
    # For example, if max capacity is 1.0, and item is 0.3:
    # Remaining capacities: 0.7, 0.5, 0.2
    # We want priorities: high for 0.2, then 0.5, then 0.7.
    # A simple inversion like 1 / (remaining_capacity + epsilon) can work,
    # but might lead to very large numbers if remaining_capacity is small.
    # A better approach is to use a decreasing function of remaining capacity.
    # We can map remaining capacities to priorities that are always less than the exact fit priority.
    # Let's use a large base value (e.g., 900) and subtract a scaled version of remaining capacity.
    # The maximum possible remaining capacity for a bin that can fit item `i` is `MAX_BIN_CAPACITY - i`.
    # So, `remaining_after_fit_values` will be in the range `[0, MAX_BIN_CAPACITY - item]`.
    # We want the highest priority for `remaining_after_fit_values = 0` (which would be exact fit, already handled).
    # So we focus on `remaining_after_fit_values > 0`.
    # We want the smallest `remaining_after_fit_values` to have the highest priority within this group.
    # Let's define a score: `base_score_for_non_exact - remaining_after_fit`.
    # The `base_score_for_non_exact` should be less than 1000. Let's use 999.
    # Then the priority for a bin with remaining capacity `R` is `999 - R`.
    # This prioritizes smaller `R` (closer fits).

    if np.any(non_exact_can_fit_mask):
        # Assuming bins_remain_cap are always positive and item is positive.
        # Max possible remaining capacity for a bin that fits item `i` can be bounded by the max capacity of any bin.
        # A robust approach might use a normalizing factor if bin capacities vary wildly,
        # but for a fixed capacity bin (as implied by BPP), we can use a value related to that.
        # Let's just use a score that decreases with remaining capacity.
        # Example: `999 - remaining_after_fit_values`.
        priorities[non_exact_can_fit_mask] = 999.0 - remaining_after_fit_values

    return priorities

```
