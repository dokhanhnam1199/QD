```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """
    Returns priority with which we want to add item to each bin using a tunable
    exponential decay function that favors tighter fits but allows looser fits
    to retain some priority.

    This heuristic prioritizes bins that can accommodate the item. Among those,
    it strongly favors bins with minimal remaining capacity after packing (tight fits).
    However, it allows the priority score to decay more slowly for bins with
    larger remaining capacities (looser fits), ensuring that these bins are not
    completely disregarded and can still be considered.

    The priority score is calculated using a function of the form:
    `score = exp(-k_high * gap / (1 + alpha * gap))`,
    where `gap` is the remaining capacity after packing (`bins_remain_cap - item`).

    - `k_high` (controlled by `tight_fit_steepness`): Determines how sharply the
      priority drops for small gaps (tight fits). A higher value means a stronger
      preference for very tight fits.
    - `alpha` (controlled by `loose_fit_decay_rate`): Influences how the decay
      rate slows down for larger gaps (looser fits). A higher value means the
      priority decays more slowly for looser fits, giving them more consideration.

    The score for a bin is 0 if the item cannot fit. For bins that can fit,
    the score is calculated as described above. The score is 1 for a perfect fit
    (gap=0) and decreases as the gap increases. The `alpha` parameter ensures
    this decrease is slower for larger gaps.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Scores range from approximately 0 to 1.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Tunable parameters:
    # `tight_fit_steepness`: Controls how rapidly priority drops for small gaps.
    # Higher value means stronger preference for very tight fits.
    tight_fit_steepness = 10.0  
    
    # `loose_fit_decay_rate`: Controls how much the decay slows down for larger gaps.
    # Higher value means looser fits retain priority for longer.
    loose_fit_decay_rate = 0.5  

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity (gap) for bins that can fit the item.
    # gap = remaining_capacity - item
    gaps_valid = bins_remain_cap[can_fit_mask] - item

    # Calculate the score using the tunable exponential decay function.
    # Score = exp(-k_high * gap / (1 + alpha * gap))
    
    k_high = tight_fit_steepness
    alpha = loose_fit_decay_rate

    # Calculate the denominator: 1 + alpha * gap.
    # For gap >= 0 and alpha >= 0, denominator is always >= 1.0.
    denominator = 1.0 + alpha * gaps_valid

    # Calculate the exponent argument: -k_high * gap / denominator
    # This argument will be 0 for gap=0 and become increasingly negative as gap increases.
    exponent_args = -k_high * gaps_valid / denominator

    # Clip the exponent arguments for numerical stability to avoid exp overflow/underflow.
    # Values between -30 and 30 are generally safe for np.exp.
    # The minimum value of exponent_args occurs as gap -> infinity, which is -k_high / alpha.
    # Clipping ensures that exp() operates on values within a stable range.
    clipped_exponent_args = np.clip(exponent_args, -30.0, 30.0)

    # Calculate the priority scores.
    # The score is exp(clipped_exponent_args).
    # For gap=0, score=exp(0)=1.0.
    # For gap>0, score < 1.0 and decays. The decay rate is influenced by k_high and alpha.
    priorities[can_fit_mask] = np.exp(clipped_exponent_args)

    return priorities
```
