{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin using Random Fit.\n\n    In Random Fit, we randomly select a bin that can accommodate the item.\n    The priority function here aims to simulate this by assigning higher priority\n    to bins that can fit the item, and then introducing a random element to break ties\n    and achieve the \"random\" aspect.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(fit_indices) == 0:\n        # If no bin can fit the item, return all zeros (or signal failure)\n        # For this heuristic, we'll return zeros, implying no good fit.\n        return priorities\n\n    # Assign a base priority (e.g., 1) to bins that can fit the item.\n    priorities[fit_indices] = 1.0\n\n    # Introduce randomness to the selection among fitting bins.\n    # We can add a small random value to the priorities of fitting bins.\n    # This ensures that when multiple bins have the same base priority (i.e., they all fit),\n    # the selection becomes random.\n    random_component = np.random.rand(len(bins_remain_cap)) * 0.1  # Small random values between 0 and 0.1\n    priorities += random_component\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.\n\n    The Sigmoid Fit Score prioritizes bins that leave a smaller remaining capacity\n    after the item is placed, aiming to fill bins more efficiently. It uses a\n    sigmoid function to map the \"tightness\" of the fit (inverse of remaining capacity)\n    to a priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # We can only place the item in bins that have enough capacity.\n    # For bins with insufficient capacity, the priority is 0.\n    valid_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity if the item were placed in each valid bin.\n    remaining_capacities = bins_remain_cap[valid_bins_mask] - item\n\n    # We want to prioritize bins where the remaining capacity is *small*.\n    # This means a higher priority for a tighter fit.\n    # A simple way to achieve this is to use the inverse of the remaining capacity.\n    # To avoid division by zero or very large numbers for near-zero remaining capacities,\n    # we can add a small epsilon.\n    epsilon = 1e-6\n    # The \"fit score\" is higher for smaller remaining capacities.\n    # Let's use the inverse of remaining capacity as a proxy for tightness.\n    # Higher inverse means tighter fit.\n    fit_scores = 1.0 / (remaining_capacities + epsilon)\n\n    # Now, we apply a sigmoid function. The sigmoid function squashes values\n    # between 0 and 1. This can help normalize the scores and make them\n    # less sensitive to extreme values.\n    # A common sigmoid is 1 / (1 + exp(-x)).\n    # If fit_score is large (tight fit), exp(-fit_score) will be close to 0, so sigmoid ~ 1.\n    # If fit_score is small (loose fit), exp(-fit_score) will be large, so sigmoid ~ 0.\n    # This maps \"tightness\" (high fit_score) to high priority.\n    # We can also scale and shift the fit_score before applying sigmoid to\n    # control the steepness of the priority change. For simplicity, we'll\n    # directly use the fit_score as input to the sigmoid.\n\n    # Using np.clip to ensure we don't get NaNs or infinities from exp if\n    # fit_scores become extremely large or small (though less likely here).\n    # For demonstration, a simple sigmoid `1 / (1 + exp(-x))` is applied.\n    # To make it sensitive to *small* remaining capacity, we want a high score\n    # for small remaining capacity. So, `fit_scores` directly represent this.\n    # Applying sigmoid directly to `fit_scores`:\n    # A higher `fit_score` (meaning smaller `remaining_capacities`) should yield a higher priority.\n    # `sigmoid(x) = 1 / (1 + exp(-x))` where higher x -> higher sigmoid output.\n    # We can scale `fit_scores` to influence sensitivity. Let's scale by a factor `k`.\n    # `k * fit_scores`. A larger `k` means higher priority for tighter fits.\n    k = 1.0 # Scaling factor - adjust this for desired sensitivity\n    scaled_fit_scores = k * fit_scores\n    sigmoid_priorities = 1 / (1 + np.exp(-scaled_fit_scores))\n\n    # Assign these calculated priorities back to the valid bins\n    priorities[valid_bins_mask] = sigmoid_priorities\n\n    return priorities\n\n[Reflection]\nPrioritize tighter fits. Use sigmoid for smooth, normalized scoring.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}