```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The Almost Full Fit strategy prioritizes bins that are almost full,
    meaning they have very little remaining capacity. This aims to leave
    more space in other bins for potentially larger items later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # We want to prioritize bins with less remaining capacity.
    # A simple inverse relationship can be used.
    # We also need to ensure the item fits.
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            # Higher priority for bins with less remaining capacity.
            # Adding a small constant to avoid division by zero or very small numbers
            # can be considered, but for simplicity, we can use a large value for
            # smaller remaining capacity.
            # A large positive number for bins with very little space.
            # A small positive number for bins with more space.
            # A priority of 0 for bins that cannot fit the item.
            
            # Strategy: prioritize bins that are 'almost full'.
            # This can be interpreted as bins where bins_remain_cap[i] - item is small.
            # So, the priority should be inversely proportional to (bins_remain_cap[i] - item).
            # To avoid division by zero if bins_remain_cap[i] == item, we can add a small epsilon.
            
            # Let's define 'almost full' by a threshold. If remaining capacity is below a certain percentage
            # of the bin's original capacity (we don't have original capacity here, but we can infer
            # relative 'fullness' from remaining capacity itself).
            
            # A simple heuristic: higher priority for smaller remaining capacity.
            # Inverse of remaining capacity, but scaled to avoid extreme values.
            # Consider the 'gap' created: bins_remain_cap[i] - item. Smaller gap is better.
            
            # Let's try a priority that is higher when the remaining capacity is *just enough*
            # or slightly more than the item.
            # For example, priority = 1 / (bins_remain_cap[i] - item + epsilon)
            # Where epsilon is a small positive number.
            # This gives higher priority to bins where the remaining capacity is just slightly
            # larger than the item.

            epsilon = 1e-9  # Small epsilon to prevent division by zero
            priorities[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)
        else:
            priorities[i] = 0.0 # Item does not fit

    # Normalize priorities if needed, but for selection, relative order is sufficient.
    # The higher the value, the more preferred the bin.

    return priorities
```
