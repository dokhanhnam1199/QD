```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using a refined
    Sigmoid Best Fit approach that also considers the "Worst Fit" aspect for
    bins that are not a tight fit.

    This heuristic prioritizes bins that can accommodate the item. Among those,
    it favors bins that result in a smaller remaining capacity (Best Fit).
    However, to avoid creating too many nearly-full bins prematurely, it also
    gives a moderate score to bins that are a significantly looser fit,
    preventing them from being completely ignored but still prioritizing
    tighter fits.

    The priority is calculated using a modified sigmoid-like function that has a
    steeper increase for near-perfect fits and a slower decrease for looser fits.

    The score for a bin is 0 if the item cannot fit. For bins that can fit,
    the score is calculated based on the remaining capacity `g = bins_remain_cap[i] - item`.
    The function used is `exp(-k_high * g / (1 + alpha * g))`:
    - `k_high` (tight_fit_steepness): Controls how sharply the priority drops for gaps close to zero.
    - `alpha` (loose_fit_decay_rate): Controls how quickly the decay rate slows down for larger gaps.
      A higher `alpha` means slower decay for loose fits, giving them more priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Scores are designed to be non-negative, with higher scores indicating
        higher priority. Scores range from 0 (cannot fit) up to 1 (perfect fit).
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Parameters to tune the behavior:
    # `tight_fit_steepness`: Controls how quickly the priority drops for near-perfect fits.
    # `loose_fit_decay_rate`: Controls how quickly the priority decays for looser fits.
    #                         Higher values give more preference to looser fits.
    tight_fit_steepness = 10.0  # Higher value means stronger preference for very tight fits
    loose_fit_decay_rate = 0.5  # Lower value means slower decay for looser fits (higher priority for loose fits)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity for bins that can fit the item.
    # g = remaining_capacity_after_packing
    gaps = bins_remain_cap[can_fit_mask] - item

    # Use the modified sigmoid-like function: exp(-k_high * g / (1 + alpha * g))
    # k_high = tight_fit_steepness
    # alpha = loose_fit_decay_rate
    k_high = tight_fit_steepness
    alpha = loose_fit_decay_rate

    # Calculate the exponent term.
    # Denominator is (1 + alpha * g). For g>=0 and alpha>=0, this is always >= 1.
    denominator = 1.0 + alpha * gaps
    exponent_args = -k_high * gaps / denominator

    # Clip the exponent arguments for numerical stability.
    # Values between -30 and 30 are generally safe for np.exp.
    # As g -> infinity, exponent_args -> -k_high / alpha.
    # For k_high=10, alpha=0.5, this is -20, which is safe.
    clipped_exponent_args = np.clip(exponent_args, -30.0, 30.0)

    # Calculate priorities for the bins that can fit the item.
    # At g=0 (perfect fit), exponent_args=0, score=exp(0)=1.
    # As g increases, the exponent becomes more negative, and the score decreases.
    # The `alpha` parameter slows down this decrease for larger `g`.
    priorities[can_fit_mask] = np.exp(clipped_exponent_args)

    return priorities
```
