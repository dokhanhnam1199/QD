```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Worst Fit strategy.

    In the Worst Fit strategy for the online Bin Packing Problem, we aim to place
    the current item into the bin that has the largest remaining capacity. This
    strategy is "greedy" in the sense that it tries to leave as much space as
    possible in the bins, hoping to accommodate larger items later. For an online
    problem, the priority is assigned based on how "bad" a fit would be in terms
    of minimizing the remaining capacity after the item is placed. Thus, bins
    with more remaining capacity are considered "better" candidates (higher priority)
    for an item in a Worst Fit approach because they represent the worst possible
    fit at that moment.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority (i.e., a bin with more remaining
        capacity).
    """
    # Initialize priorities to a very small negative number to handle cases
    # where an item cannot fit into any bin.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining capacity if the item were placed in each bin.
    # This is only possible if the bin has enough capacity for the item.
    possible_fits = bins_remain_cap >= item

    # For bins where the item fits, the priority is simply the remaining capacity
    # of that bin. This aligns with the Worst Fit strategy where we prefer bins
    # with the most remaining space.
    priorities[possible_fits] = bins_remain_cap[possible_fits]

    return priorities
```
