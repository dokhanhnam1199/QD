```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin using Sigmoid Best Fit
    with emphasis on favoring tighter fits by shifting the sigmoid.

    This heuristic prioritizes bins that can accommodate the item and have the smallest
    remaining capacity after packing (Best Fit strategy). The priority is calculated
    using a modified sigmoid function to provide a smooth ranking, strongly favoring
    tighter fits by mapping perfect fits to scores higher than 0.5.

    The score for a bin is 0 if the item cannot fit. For bins that can fit, the score
    is calculated as 0.5 + 0.5 * sigmoid(steepness * (item - remaining_capacity)).
    This formulation means that a perfect fit (remaining_capacity - item = 0) results
    in a score of 0.75, while looser fits get scores between 0.5 and 0.75, and very
    loose fits approach 0.5. Tighter fits (if possible, i.e., remaining_capacity < item)
    would result in scores greater than 0.75.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Scores range from 0 (cannot fit) upwards, with tighter fits receiving higher scores.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    steepness = 10.0  # Tunable parameter: higher values mean stronger preference for tight fits.

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the negative surplus for bins where the item can fit.
    # Negative surplus = item - remaining_capacity
    # A smaller remaining capacity (tighter fit) leads to a larger negative surplus.
    neg_surplus_valid = item - bins_remain_cap[can_fit_mask]

    # Calculate the argument for the sigmoid function.
    # We want higher scores for smaller `remaining_capacity` (i.e., larger `neg_surplus`).
    # The function `sigmoid(steepness * x)` increases with `x`.
    # Thus, `sigmoid(steepness * neg_surplus)` increases as `neg_surplus` increases.
    sigmoid_argument = steepness * neg_surplus_valid

    # Clip the sigmoid argument for numerical stability.
    # The range [-30, 30] is generally safe for np.exp.
    clipped_sigmoid_argument = np.clip(sigmoid_argument, -30.0, 30.0)

    # Calculate the sigmoid values.
    # For valid bins, neg_surplus_valid <= 0, so sigmoid_argument <= 0.
    # This means sigmoid_values will be <= 0.5 for valid bins.
    sigmoid_values = 1.0 / (1.0 + np.exp(-clipped_sigmoid_argument))

    # Transform sigmoid values to prioritize tighter fits more strongly.
    # We shift and scale the sigmoid output: 0.5 + 0.5 * sigmoid_values.
    # This maps:
    # - Perfect fit (neg_surplus=0): sigmoid_values=0.5 -> priority = 0.5 + 0.5*0.5 = 0.75
    # - Loose fit (neg_surplus<0): sigmoid_values<0.5 -> priority < 0.75 (closer to 0.5 for very loose fits)
    # - Tighter fit (neg_surplus>0, not applicable with mask): sigmoid_values>0.5 -> priority > 0.75
    priorities[can_fit_mask] = 0.5 + 0.5 * sigmoid_values

    return priorities
```
