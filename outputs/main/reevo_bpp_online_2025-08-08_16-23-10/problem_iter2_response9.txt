```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic prioritizes exact fits for the item.
    Among bins that can fit the item but not exactly, it gives higher priority
    to bins that would have the least remaining capacity after packing the item.
    Bins that cannot fit the item receive the lowest priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a low value for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if len(fitting_bins_indices) > 0:
        # Calculate the remaining capacity if the item is placed in a fitting bin
        remaining_after_fit = bins_remain_cap[fitting_bins_indices] - item

        # Assign a base priority to all fitting bins.
        # This base priority should be lower than the bonus for exact fits.
        # We can use the negative of the remaining capacity to favor smaller remaining capacities.
        # The smaller (less negative) the value, the higher the priority.
        # E.g., if remaining capacities are [0.5, 0.1, 0.8], we want higher priority for 0.1.
        # Using -remaining_capacity: [-0.5, -0.1, -0.8]. Argmax would pick -0.1.
        priorities[fitting_bins_indices] = -remaining_after_fit

        # Identify exact fits and give them a significantly higher priority.
        # We can add a large constant to the priority of exact fits.
        # This constant should be larger than the maximum possible value of -remaining_after_fit.
        # The minimum value of remaining_after_fit is 0 (for exact fits).
        # The maximum value of remaining_after_fit could be up to the bin capacity.
        # If we assign -remaining_after_fit, the range is roughly [-(max_capacity), 0].
        # Adding a value larger than max_capacity will ensure exact fits are always preferred.
        exact_fit_mask = (remaining_after_fit == 0)
        if np.any(exact_fit_mask):
            # Add a bonus that is greater than any possible non-exact fit priority.
            # The maximum possible priority from -remaining_after_fit is 0.
            # Any value > 0 will work as a bonus. Let's use a substantial bonus.
            bonus = 100.0
            priorities[fitting_bins_indices[exact_fit_mask]] += bonus

    return priorities
```
