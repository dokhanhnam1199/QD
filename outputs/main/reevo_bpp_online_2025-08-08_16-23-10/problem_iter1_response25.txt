```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # We want to prioritize bins that have just enough space for the item.
    # A bin is a good candidate if its remaining capacity is close to the item size.
    # The "inverse distance" here refers to how close the remaining capacity is to the item size.
    # A smaller difference means a higher priority.
    
    # Calculate the difference between bin remaining capacity and the item size.
    # We are only interested in bins where the item can actually fit.
    differences = bins_remain_cap - item
    
    # For bins where the item doesn't fit, assign a very low priority (or 0)
    # to effectively exclude them from consideration.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item fits
    can_fit_mask = differences >= 0
    
    # For bins where the item fits, calculate the inverse of the difference + a small epsilon 
    # to avoid division by zero if a bin has exactly the required capacity.
    # A smaller difference means a larger inverse, hence higher priority.
    # Adding 1 to the difference and taking the reciprocal is a common way to implement inverse distance.
    # Alternatively, we can use the difference directly and then take the negative to invert the ranking
    # or use a sigmoid-like function to map differences to priorities.
    
    # Let's try a simple inverse: 1 / (difference + 1)
    # This prioritizes bins with smaller remaining capacity, pushing towards a tighter fit.
    priorities[can_fit_mask] = 1.0 / (differences[can_fit_mask] + 1.0)
    
    # Alternative: Prioritize bins that are "almost full" for this item,
    # meaning the remaining capacity is just enough.
    # Let's consider a strategy that favors bins that, after placing the item,
    # have the *least* remaining capacity among those that can fit the item.
    # This is akin to "Best Fit" which is a common heuristic for BPP.
    # If we want to implement "Inverse Distance (Proximity Fit)" in a way that
    # prioritizes bins *closest* to fitting the item, then the difference
    # (bins_remain_cap - item) should be minimized.
    # The reciprocal of this difference (plus a small value) would give higher scores
    # to smaller differences.
    
    # Let's refine this: prioritize bins where `bins_remain_cap - item` is minimal and non-negative.
    # We want higher priority for smaller positive differences.
    # So, a good priority score could be `1 / (bins_remain_cap - item + epsilon)` for fitting bins.
    # Or, if we want to avoid division and just rank them, we could use `- (bins_remain_cap - item)`.
    # The higher the difference (meaning more remaining capacity), the lower the priority.
    
    # Let's use the inverse difference idea, making sure smaller differences get higher scores.
    # We can transform `bins_remain_cap - item` into a priority.
    # A direct mapping: if diff is 0, priority is high. If diff is large, priority is low.
    # A simple way is to use `np.exp(-differences)` for fitting bins, or something similar.
    
    # Let's go with the "Best Fit" intuition adapted for inverse proximity:
    # Prioritize bins that have the *least* remaining capacity but can still fit the item.
    # This means minimizing `bins_remain_cap` among valid bins.
    # A higher priority should be given to a bin if `bins_remain_cap - item` is small and positive.
    
    # Calculate a score based on how "close" the remaining capacity is to the item size.
    # We want to minimize `bins_remain_cap - item` for fitting bins.
    # Let's use the negative of the difference. The smaller the non-negative difference, the larger the negative value will be (closer to zero).
    
    # For bins that can fit the item, the "proximity" is `bins_remain_cap - item`.
    # We want to maximize the priority, so we want to give higher priority to smaller non-negative differences.
    # Consider the values of `bins_remain_cap[can_fit_mask] - item`.
    # If these values are 0, 1, 2, 3... we want priorities that are high, slightly lower, even lower, etc.
    
    # Option 1: Higher priority for smaller non-negative differences.
    # We can use `np.reciprocal(differences[can_fit_mask] + 1.0)` as before, but let's reconsider the scaling.
    # The direct reciprocal might be too sensitive to small differences.
    
    # Option 2: A decreasing function of the difference.
    # Let's try `np.exp(-(bins_remain_cap[can_fit_mask] - item))`.
    # This gives a high priority when the difference is 0 (exponential of 0 is 1), and it decreases as the difference increases.
    # This fits the "proximity" idea well.
    
    # Ensure we don't have extremely large negative exponents if differences are large.
    # However, for BPP, differences usually aren't astronomically large compared to item sizes.
    
    priorities[can_fit_mask] = np.exp(-(differences[can_fit_mask]))

    # To ensure we don't get numerical issues with very large differences,
    # we could cap the negative exponent if needed, but for typical BPP, this is likely fine.
    # For instance, if `bins_remain_cap - item` can be very large (e.g., > 100), `exp(-100)` is close to zero.
    # The problem statement implies we are using the "Inverse Distance" strategy for proximity.
    # A direct interpretation of inverse distance would be `1 / distance`.
    # Here, "distance" is the difference `bins_remain_cap - item`.
    # So, `1 / (bins_remain_cap - item + epsilon)` where epsilon avoids division by zero.
    # Let's refine this: a smaller difference means higher priority.
    
    # Let's stick to the principle of minimizing the gap after placement.
    # If a bin has capacity 10 and item size is 7, gap is 3.
    # If another bin has capacity 12 and item size is 7, gap is 5.
    # We want to prioritize the bin with gap 3 over the bin with gap 5.
    
    # Using `1 / (gap + 1)` means:
    # For gap 0: 1 / (0 + 1) = 1.0 (Highest priority)
    # For gap 1: 1 / (1 + 1) = 0.5
    # For gap 2: 1 / (2 + 1) = 0.333...
    # For gap 5: 1 / (5 + 1) = 0.166...
    # This ranking is correct.

    # Let's reconsider the prompt's suggestion for "Inverse Distance (Proximity Fit)".
    # If we consider "distance" as how far the bin's remaining capacity is from a "perfect fit" (i.e., equal to item size),
    # then this distance is `abs(bins_remain_cap - item)`.
    # However, in online BPP, we *must* fit the item, so `bins_remain_cap >= item`.
    # Thus, the distance is simply `bins_remain_cap - item`.
    # Inverse distance implies higher values for smaller distances.
    
    # So, for fitting bins: priority = 1 / (bins_remain_cap - item + epsilon)
    # Using epsilon to avoid division by zero.
    epsilon = 1e-9  # A small value to avoid division by zero
    
    # Update priorities using the inverse of the non-negative difference
    priorities[can_fit_mask] = 1.0 / (differences[can_fit_mask] + epsilon)
    
    # This heuristic encourages packing into bins that are almost full, minimizing wasted space.
    # It's a form of "Best Fit" heuristic.
    
    return priorities

```
