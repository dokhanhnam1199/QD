```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic implements a modified First Fit strategy.
    It prioritizes bins that can fit the item. Among those that can fit,
    it gives a higher priority to bins that have just enough remaining capacity
    to fit the item (minimizing wasted space in that specific bin).
    If no bin has *exactly* enough space, it falls back to the bin that
    leaves the least amount of remaining space after packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item is placed in a bin
    potential_remaining_cap = bins_remain_cap - item

    # Prioritize bins that have exactly enough space for the item
    # Assign a high priority (e.g., 2) to these bins.
    exact_fit_mask = (bins_remain_cap == item) & can_fit_mask
    priorities[exact_fit_mask] = 2.0

    # For bins that can fit but not perfectly, assign a priority based on
    # minimizing remaining space.
    # Assign a priority of 1 to these bins.
    # The actual sorting will ensure that bins with less remaining space get picked first.
    can_fit_but_not_exact_mask = can_fit_mask & ~exact_fit_mask
    priorities[can_fit_but_not_exact_mask] = 1.0

    # For bins that can fit, the secondary sorting criteria (after priority score)
    # will be the potential remaining capacity. Lower remaining capacity is better.
    # We can achieve this by making the priority score inversely related to the
    # remaining capacity for bins that are not an exact fit.
    # Since we want *least* remaining capacity to be best, and numpy sorts in
    # ascending order for positive values, we can multiply the remaining capacity
    # by -1 to give a higher (less negative) score to bins with less space.
    # However, our current priority scheme already assigns 2 for exact fits and 1 for others.
    # The subsequent selection logic typically picks the highest priority, and
    # if priorities are tied, it looks at other criteria.
    # For simplicity and to align with "highest priority score means best",
    # let's make the priority proportional to how *tightly* it fits.
    # Higher priority for less remaining space.

    # For bins that can fit, let's assign a priority that favors less remaining space.
    # A higher priority means we want to pick it.
    # The value `bins_remain_cap - item` represents the *wasted* space in that bin.
    # We want to minimize wasted space. So, we want smaller positive values of `bins_remain_cap - item`.
    # If we want higher priority for smaller wasted space, we can use `1 / (wasted_space + epsilon)`
    # or subtract the wasted space from a large constant.
    # Let's try a simpler approach: give a priority that's higher for tighter fits.
    # Bins that can fit but aren't exact fits:
    # Priority = 1 + (maximum possible remaining capacity - actual remaining capacity) / maximum possible remaining capacity
    # This is equivalent to: priority = 1 + (bin_cap - item) / bin_cap IF bin_cap is the same.
    # With variable bin capacities, we can assign priority based on the remaining space *after* placing the item.
    # Lower `bins_remain_cap - item` is better.
    # To make higher priority better, we can use something like:
    # `max_possible_waste - (bins_remain_cap[i] - item)` if the item fits.
    # A more direct approach for the 'least remaining space' among fitting bins:
    # Assign a priority that is inversely related to the remaining space.
    # For example, `1 / (bins_remain_cap[i] - item + 1e-9)` if it fits.
    # This makes bins with very little remaining space have very high priorities.

    # Let's refine:
    # Priority = 0 if cannot fit.
    # Priority = 1 if fits but not exactly.
    # Priority = 2 if fits exactly.
    # For bins with priority 1, we need a tie-breaker: prefer bins with less remaining capacity.
    # To incorporate this directly into the priority score for easier sorting:
    # For bins where `can_fit_but_not_exact_mask` is true:
    # Let's assign a priority that reflects the "tightness" of the fit.
    # A higher score means a tighter fit.
    # The potential remaining capacity after packing is `bins_remain_cap[i] - item`.
    # We want to maximize `-(bins_remain_cap[i] - item)` (i.e., minimize `bins_remain_cap[i] - item`).
    # So, a score like `-(bins_remain_cap[i] - item)` can work for tie-breaking.
    # Combined priority: 2 for exact, 1 - epsilon * (remaining_after_fit) for others.

    # Let's try a simpler structure for the priority score itself to directly favor less remaining space.
    priorities = np.zeros_like(bins_remain_cap)

    # For bins that can fit the item
    fitting_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(fitting_bins_indices) > 0:
        # Calculate remaining capacity for fitting bins
        remaining_after_fit = bins_remain_cap[fitting_bins_indices] - item

        # Assign higher priority to bins with less remaining space.
        # A large negative number for bins with lots of remaining space,
        # and values closer to zero for bins with very little remaining space.
        # This way, the maximum priority will come from bins with minimal remaining space.
        # We can use `np.max(remaining_after_fit) - remaining_after_fit`
        # to get values where smaller remaining_after_fit results in larger priorities.
        priorities[fitting_bins_indices] = np.max(remaining_after_fit) - remaining_after_fit

        # Add a bonus for exact fits to ensure they are prioritized even if other bins have very little remaining space.
        # For example, an exact fit (remaining_after_fit = 0) should have a higher priority than any
        # non-exact fit where remaining_after_fit > 0.
        # We can add a large constant to exact fits.
        exact_fit_indices = fitting_bins_indices[remaining_after_fit == 0]
        if len(exact_fit_indices) > 0:
            # Ensure exact fits get a priority higher than any possible non-exact fit score.
            # The current `remaining_after_fit` values are non-negative.
            # The priorities we assigned are `max_waste - waste`. Max possible priority is `max_waste`.
            # So, `max_waste + 1` for exact fits ensures they are always picked over non-exact fits if using argmax.
            priorities[exact_fit_indices] = np.max(remaining_after_fit) + 1

    return priorities
```
