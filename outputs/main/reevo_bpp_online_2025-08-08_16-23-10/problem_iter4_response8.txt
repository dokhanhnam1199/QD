```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version implements an improved "Best Fit" heuristic. It prioritizes bins
    that, after placing the item, will have the smallest remaining capacity.
    This aims to leave bins with larger remaining capacities for potentially larger
    future items, thus optimizing space utilization more effectively.
    Bins that cannot fit the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority (i.e., a bin that results in
        less remaining capacity after packing).
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* placing the item.
    # The heuristic aims to minimize this remaining capacity.
    # A smaller `bins_remain_cap[i] - item` value corresponds to a better fit.
    # We want the highest priority for the smallest positive difference.
    # Therefore, we can use the negative of this difference as the priority.
    # A bin that results in a remaining capacity of 0 (perfect fit) will have a priority of 0.
    # A bin that results in a remaining capacity of 1 will have a priority of -1.
    # This naturally prioritizes bins that are closer to being full.
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    return priorities
```
