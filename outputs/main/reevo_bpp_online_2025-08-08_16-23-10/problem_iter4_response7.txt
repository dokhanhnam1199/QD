```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit heuristic suitable for softmax selection.

    This priority function prioritizes bins that have the least remaining capacity
    while still being able to accommodate the item. This is a form of Best Fit.
    The scores are calculated as the negative of the surplus capacity (remaining_capacity - item_size).
    When these scores are exponentiated (e.g., for a softmax selection), bins with
    smaller surplus capacities will receive higher probabilities, effectively
    prioritizing the "tightest fit". Bins that cannot fit the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    # Initialize priorities to a very low value (negative infinity) for bins that cannot fit the item.
    # When exponentiated, these will become 0, meaning they won't be selected.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that have enough remaining capacity to fit the item.
    valid_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the surplus capacity.
    # Surplus capacity = remaining_capacity - item_size.
    # We want to minimize this surplus.
    surplus_capacity = bins_remain_cap[valid_mask] - item

    # To prioritize smaller surpluses for softmax-like selection, we use the negative surplus.
    # A smaller surplus (e.g., 0) results in a higher score (e.g., 0), leading to a higher probability
    # after exponentiation (e.g., exp(0) = 1). A larger surplus (e.g., 5) results in a lower score
    # (e.g., -5), leading to a lower probability (e.g., exp(-5) â‰ˆ 0.0067).
    scores_for_valid_bins = -surplus_capacity

    # Assign these calculated scores to the corresponding positions in the priorities array.
    priorities[valid_mask] = scores_for_valid_bins

    # Exponentiate the scores to get probabilities. This makes the selection process
    # probabilistic and favors bins with smaller surplus capacities.
    # A bin that cannot fit the item will have a priority of exp(-inf) = 0.
    return np.exp(priorities)
```
