```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have sufficient space but not too much,
    aiming for a fill level close to optimal.  It uses a combination of factors:

    1.  Feasibility:  Invalid bins (those without sufficient remaining capacity) receive the lowest priority.
    2.  Space Utilization: Bins that leave the least amount of wasted space after packing are preferred. A small buffer is introduced to allow for some tolerance.
    3.  Number of used Bins: Penalize the priority of bins that will become the *first* bin opened (after the current bin), since this suggests high item fragmentation. We'll infer used bins using a threshold.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities  # All bins are infeasible. No priority needed

    # Calculate remaining space if item were added
    remaining_space = bins_remain_cap - item

    # Initialize utilization factor, penalizing bins that can't hold the item
    utilization_factor = np.where(feasible_bins, np.exp(-np.abs(remaining_space / np.mean(bins_remain_cap))), 0.0)

    # Penalize bins that would be newly opened. Let's guess used_bins as those bins with capacity < 0.9 max_cap:
    used_bin_threshold = np.max(bins_remain_cap)* 0.9
    number_used_bins = np.sum(bins_remain_cap < used_bin_threshold)
    if number_used_bins == 0:
        penalty = np.where(feasible_bins, -0.1, 0.0) # slight penalty if opening a bin, if non are opened yet
    else:
        penalty = 0.0 # otherwise, the number of opened bins will stay the same

    priorities = utilization_factor + penalty

    return priorities
```
