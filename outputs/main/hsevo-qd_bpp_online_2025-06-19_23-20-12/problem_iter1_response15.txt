```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers multiple factors to prioritize bin selection:
    1. Remaining capacity vs. item size: Bins that can fit the item well
       (but not perfectly) are preferred.  We avoid filling bins too tightly unless necessary.
    2. Avoidance of near-empty bins: We penalize bins with almost full remaining capacity to reduce fragmentation.
    3. "First Fit Decreasing" tendency: slight bias to fill earlier bins.
       This helps to keep the number of active bins lower on average.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # How well does the item fit relative to the remaining capacity?
            # We want a capacity that is slightly bigger than the item, but not much bigger
            fit_ratio = item / cap

            # Penalize if bin has near zero remaining capacity, indicating tight fit
            tight_fit_penalty = np.exp(10 * (fit_ratio - 0.9)) if fit_ratio > 0.9 else 1.0

            # Give slight incentive to fill lower index bins. (First-Fit tendency). Linear decrease.
            bin_index_bonus = (len(bins_remain_cap) - i)/len(bins_remain_cap)*0.1 #small value
            priorities[i] = (1 - fit_ratio) * tight_fit_penalty + bin_index_bonus  # The closer fit ratio is to 1 (but not perfectly 1), the better.

        else:
            priorities[i] = -np.inf  # Cannot fit, so lowest priority

    return priorities
```
