```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with remaining capacity slightly larger than the item
    and penalizes bins that are either too full or have too much extra capacity.
    It uses a combination of the remaining capacity itself, the relative fullness
    (item size / remaining capacity), and a penalty term if the remaining capacity is
    significantly larger than the item.  This aims to balance filling bins effectively
    without leaving too much wasted space in partially filled bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a base value (remaining capacity).  Larger capacity is better initially.
    priorities = bins_remain_cap.copy()

    # Calculate the ratio of item size to remaining capacity.  A ratio near 1 is good.
    ratios = item / bins_remain_cap
    
    # Increase priority for bins that fit the item (ratio <= 1).  The closer to 1, the higher the priority.
    fit_indices = ratios <= 1
    priorities[fit_indices] += (1 - np.abs(1 - ratios[fit_indices]))*10 # Boost for fitting bins close to full

    # Penalize bins with remaining capacity significantly larger than the item.
    # This avoids putting small items into very large bins, leaving too much space.
    large_capacity_penalty = np.maximum(0, bins_remain_cap - item * 2) # Heuristic: Penalize if remaining cap is > 2x item
    priorities -= large_capacity_penalty/10 # Reduce priority if the capacity is too large.

    # For bins that don't fit, heavily penalize them (make them very low priority).
    no_fit_indices = ratios > 1
    priorities[no_fit_indices] -= 1000  # Extremely low priority for bins that don't fit.

    return priorities
```
