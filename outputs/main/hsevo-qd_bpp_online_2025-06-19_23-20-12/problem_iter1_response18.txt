```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item well, avoiding both
    overfilling (if possible) and leaving too much wasted space.  It gives
    higher priority to bins where the remaining capacity after placing the
    item is a smaller fraction of the bin's original capacity (efficient use)
    but only if the item fits. If an item doesnt fit the bin, it gets a large negative priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    original_capacity = 1.0  # Assume original bin capacity is 1 for simplicity. Can be changed.

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if remaining_capacity >= item:
            remaining_after_fit = remaining_capacity - item
            waste_ratio = remaining_after_fit / original_capacity
            priorities[i] = -waste_ratio  # Prefer less waste. Can change sign to prioritize waste
        else:
            priorities[i] = -1e9  # Very low priority if it doesn't fit.

    return priorities
```
