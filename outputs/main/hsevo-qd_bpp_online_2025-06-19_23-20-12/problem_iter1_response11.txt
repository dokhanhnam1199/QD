```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers both space utilization and fragmentation. It prioritizes bins
    that have enough space to accommodate the item but also tries to avoid creating
    too much wasted space after the item is placed.  A "sweet spot" is identified
    where the remaining capacity after placing the item is neither too large (wasteful)
    nor too small (risky for future items).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities  # No suitable bin

    remaining_space = bins_remain_cap[valid_bins] - item
    
    # Sweet spot heuristic: Aim for remaining space around item size.
    # We want a distribution around item, so that we prefer bins with
    # remaining space is closest to item. Avoid creating very small or large wasted space
    sweet_spot_distance = np.abs(remaining_space - item)
    priorities[valid_bins] = np.exp(-sweet_spot_distance / item)

    # Bonus for bins that perfectly fit the item, if available.  Avoids fragmentation.
    perfect_fit = remaining_space == 0
    if np.any(perfect_fit):
      priorities[valid_bins][perfect_fit] += 1.0

    return priorities
```
