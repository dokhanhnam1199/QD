```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    A high priority means the bin is more suitable for the item.
    This version considers:
        1. Remaining capacity: Bins with capacity closer to the item size are preferred.
        2. Waste minimization: Penalize bins that would result in significant waste.
        3. Bin utilization: Reward bins that are already somewhat filled.
        4. Avoidance of near-empty bins after packing: Heavily penalize if remaining capacity after packing exceeds certain threshold.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, remaining_capacity in enumerate(bins_remain_cap):
        if remaining_capacity < item:
            priorities[i] = -np.inf  # Cannot fit, lowest priority
        else:
            # 1. Capacity closeness: closer capacity is better
            capacity_closeness = np.exp(-0.5 * ((remaining_capacity - item) / item)**2)

            # 2. Waste minimization: penalty for large waste. Larger waste implies less good fit
            waste = remaining_capacity - item
            waste_penalty = np.exp(-0.5 * (waste/item * 2)**2)  #Penalize aggressively if waste is comparable or greater than item.

            # 3. Utilization: favor bins already somewhat filled. We want partially filled bins over fresh bins, because it's harder to pack large items in the end if there are lots of nearly empty bins
            utilization = 1 - (remaining_capacity / 1.0)  # Assuming bin capacity is 1. Normalize.
            utilization_reward = np.sqrt(utilization)  # mild reward, sqrt makes this smaller for very high utilizations to encourage spreading
            # 4. Avoid bins which would leave too much empty space: This helps consolidate items, helps avoid packing big items at the end if the bins are still too empty
            post_pack_remain = remaining_capacity - item
            large_remain_penalty = 0
            if post_pack_remain > 0.75:  # If there is lots of remain capacity
                large_remain_penalty = -np.inf

            priorities[i] = capacity_closeness * waste_penalty + 0.5 * utilization_reward + large_remain_penalty

    return priorities
```
