```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Heuristic 1: First-Fit Decreasing variant - prefer bins that can fit the item snugly.
    fit_indices = bins_remain_cap >= item
    if np.any(fit_indices):
        capacities_that_fit = bins_remain_cap[fit_indices]
        slack = capacities_that_fit - item
        min_slack = np.min(slack)
        best_fit_indices = fit_indices & (slack == min_slack)
        priorities[best_fit_indices] += 1000  # Huge bonus for best fit.
        priorities[fit_indices] += 100 # High priority for just fitting
    else:
        # Heuristic 2: Allow breakage but with hefty penalty - prefer less empty bins, avoid high fragmentation.
        priorities += (item - bins_remain_cap)*10 # negative here for the breaking part
    # Heuristic 3: Moderate value on relative capacity usage
    ratios = item / bins_remain_cap
    priorities -= ratios * 10  # Slight penalty for large relative item sizes

    # Heuristic 4: Prefer bins with higher remaining capacity if several bins are nearly identical. Reduces waste in already full bins
    priorities += bins_remain_cap / np.max(bins_remain_cap) * 5  # Scaled Remaining capacity

    return priorities
```
