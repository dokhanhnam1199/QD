```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the concept of entropy and gravitational pull near black holes:
    Prioritizes bins where the item "fits nicely" (moderate utilization increase)
    while avoiding bins that are either too full or barely used.
    This attempts to balance packing efficiency with space distribution.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            # Calculate utilization after placing the item
            new_utilization = (cap - item) / cap
            # Score based on how 'well' the item fits (closer to an ideal utilization)
            # Moderate utilization increase is preferred, avoiding near-empty or over-full bins
            priorities[i] = np.exp(-np.abs(new_utilization - 0.5))  # Gaussian-like preference around 0.5
            # Add a term that slightly favours bins with larger remaining capacity.
            priorities[i] += 0.1 * (cap / np.max(bins_remain_cap))

            #Very small items should be considered, don't let them block out huge bins.
            if item <= 0.1:
                priorities[i] += 0.2
        else:
            priorities[i] = -np.inf  # Cannot fit, extremely low priority

    return priorities
```
