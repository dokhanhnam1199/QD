[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins that can accommodate the item\n    # but have minimal remaining capacity *after* placing the item.\n    # This helps to fill bins as much as possible.\n\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = 1.0 / (remaining_after_fit + 0.00001) # Avoid division by zero\n        \n        # Further prioritization: prioritize bins with remaining capacity closest to item size\n        # This can help prevent creating many bins with small leftover space if possible.\n\n        priorities[can_fit] += 1.0 / np.abs(bins_remain_cap[can_fit] - item + 0.00001)\n\n\n    # If no bins can fit, prioritize the bin with largest capacity.\n    else:\n      priorities = bins_remain_cap\n      \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # First priority: Can the item fit?  If not, priority is -inf\n    can_fit = item <= bins_remain_cap\n    priorities[~can_fit] = -np.inf\n    \n    # Next, prioritize bins where the item fills a significant portion, but doesn't overfill.\n    # Higher priority if the remaining space after placing the item is small, but not zero.\n    \n    remaining_space = bins_remain_cap - item\n    \n    # Avoid division by zero\n    remaining_space[remaining_space <= 0] = np.inf  # Prioritize filling bins almost completely.\n    \n    # Prioritize using smaller bins, as long as item fits.\n    priorities[can_fit] = (item / bins_remain_cap[can_fit]) + (1.0 / remaining_space[can_fit]) #Ratio of fill + inverse of the remaining space\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    almost_fit = (bins_remain_cap - item >= 0) & (bins_remain_cap - item <= 0.1) # Allow for minor floating point issues/epsilon\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a high priority to bins where the item fits perfectly or almost perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    almost_fit = (bins_remain_cap - item >= 0) & (bins_remain_cap - item <= 0.1) # Allow for minor floating point issues/epsilon\n    fits = bins_remain_cap >= item\n    \n    priorities[perfect_fit] = 1000  # Highest priority for perfect fit\n\n    priorities[almost_fit] = 500  # High priority for almost perfect fit\n\n    # Prioritize bins that have enough capacity for the item, but not too much (to avoid fragmentation).\n    remaining_space = bins_remain_cap - item\n    valid_bins = fits & (remaining_space <= np.mean(bins_remain_cap[fits]))\n    \n    priorities[valid_bins] = 100 - (remaining_space[valid_bins] / np.mean(bins_remain_cap[fits]))*50 if np.any(fits) else 0 # Normalize\n\n    # Give a small priority to all bins where the item fits (but not the previous conditions)\n    other_fits = fits & ~perfect_fit & ~almost_fit & ~valid_bins\n    priorities[other_fits] = 1 # Baseline fit priority\n        \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit-Decreasing heuristic adaptation: prioritize bins that can fit the item well\n    fit_indices = bins_remain_cap >= item\n    priorities[fit_indices] = (bins_remain_cap[fit_indices] - item) / bins_remain_cap[fit_indices]  # Remaining capacity ratio\n\n    # Prioritize bins where the item almost fills it. The nearer to 1, the higher the score\n    priorities[fit_indices] = np.where(bins_remain_cap[fit_indices] > 0, 1 - (bins_remain_cap[fit_indices] - item)/bins_remain_cap[fit_indices], 0)\n\n    # If the item can't fit in any bin, penalize\n    if not np.any(fit_indices):\n        priorities = np.full_like(bins_remain_cap, -1.0)\n        # find the bin with maximum remaining capacity and give it a small advantage\n        max_cap_idx = np.argmax(bins_remain_cap)\n        priorities[max_cap_idx] = -0.9 # slightly better than other infeasible bin\n    else:\n         #Scale other priorities\n         priorities[fit_indices] *= 10 # Increase the contribution\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough but with minimum waste.\n    can_fit = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    \n    priorities[can_fit] = 1 / (waste[can_fit] + 0.000001)  # Add a small constant to avoid division by zero\n    \n    # If it can perfectly fit: assign a very high priority to that bin.\n    perfect_fit = waste == 0\n    priorities[perfect_fit] = 1000\n    \n    # Bins where the item does not fit get a zero priority\n    priorities[~can_fit] = -1\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Disqualify bins that cannot fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # 2. Remaining Capacity: Prefer bins with enough space, but not too much\n    # Penalize bins that would have too much or too little space left.\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Calculate a \"waste\" score.  Ideally, we want bins to be relatively full\n    waste_penalty = np.abs(remaining_after_fit - np.mean(remaining_after_fit[remaining_after_fit >= 0])) #Prioritizes bins with the average leftover after packing the item\n\n    # Calculate score based on how close the item fits\n    fit_score = bins_remain_cap - item\n\n    # 3. Combine Scores\n    priorities[~infeasible_bins] = 1.0/(waste_penalty[~infeasible_bins] + 1e-9)  + fit_score[~infeasible_bins] # add a small value to avoid division by zero\n    \n    return priorities",
    "response_id": 5,
    "obj": 133.35660151575587,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic idea\n    # High priority for bins that can fit the item closely\n    \n    # Give a high priority to bins that have enough space to fit\n    fit_indices = bins_remain_cap >= item\n    \n    if np.any(fit_indices):\n        priorities[fit_indices] = (bins_remain_cap[fit_indices] - item)  # Remaining space after placing item\n        priorities[fit_indices] = 1 / (1e-9 + priorities[fit_indices]) # Inverse of the remaining space\n    else:\n        # If no bin can fit, penalize the bins by negative priority (try next fit after bins are filled).\n        priorities[:] = -1.0\n        \n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        # If no bin can accommodate the item, return low priority for all bins.\n        return priorities\n\n    # Calculate remaining capacity after placing the item\n    remaining_capacity = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins based on remaining capacity:\n    # 1. Bins with smaller remaining capacity after placement get higher priority \n    # (First-Fit Decreasing/Best-Fit approximation).\n    priorities[valid_bins] = 1.0 / (remaining_capacity + 1e-9)  # Adding a small constant to prevent division by zero\n\n    # 2. Give a bonus if the remaining capacity is very small\n    almost_full = remaining_capacity <= 0.1  # Adjust threshold (0.1) if needed\n    priorities[valid_bins][almost_full] *= 2.0 # Double the priority\n\n    # 3. Give a penalty if the bin will be very empty after placing the item\n    very_empty = remaining_capacity > 0.9 # Adjust threshold (0.9) if needed\n    priorities[valid_bins][very_empty] /= 2.0  # Reduce the priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Assign a very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Score based on remaining capacity after placing the item\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    \n    # Higher priority to bins where remaining capacity is small, but not too small\n    # to avoid creating very fragmented bins\n    priorities[feasible_mask] = np.exp(-np.abs(remaining_capacity - item/2)) \n    \n    # Add a bonus for almost full bins (to prioritize filling them up)\n    almost_full_mask = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.1)  #tolerate 10% overhead\n    priorities[almost_full_mask] += 1.0 #give significant boost\n\n    return priorities",
    "response_id": 8,
    "obj": 4.876346230554457,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Rule out bins that are too small.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf  # Very low priority\n\n    # 2. Remaining capacity near item size has the highest priority.\n    diff = np.abs(bins_remain_cap - item)\n    priorities[~infeasible] = -diff[~infeasible] # Closer to item size, better\n    \n    # 3. Smallest Remaining Capacity (among feasible bins). This favors bins with very little space.\n    priorities[~infeasible] += -bins_remain_cap[~infeasible]/np.max(bins_remain_cap[~infeasible])\n\n    # 4. Consider the waste (remaining capacity after packing the item). Penalize waste.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = 0 # already considered infeasible, but to be safe\n    priorities[~infeasible] += -waste[~infeasible]/np.max(bins_remain_cap) # Normalize by bin capacity\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority if the item fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0  # Give very high priority to perfect fits.\n\n    # High priority if the item fits and there's minimal wasted space.\n    fits = (bins_remain_cap >= item)\n    if np.any(fits):\n        wasted_space = bins_remain_cap[fits] - item\n        #Prioritize bins where we waste the least space\n        priorities[fits] = 100.0 - wasted_space\n\n    # Give a negative priority (discourage) bins that are too full (less than the item size)\n    no_fit = (bins_remain_cap < item)\n    priorities[no_fit] = -1000.0  # Discourage no-fit bins heavily.\n\n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large items get high priority for bins with sufficient remaining capacity\n    sufficient_capacity = bins_remain_cap >= item\n    priorities[sufficient_capacity] = (bins_remain_cap[sufficient_capacity] - item) / bins_remain_cap[sufficient_capacity]\n\n    # If no bin has sufficient capacity, penalize all bins\n    if not np.any(sufficient_capacity):\n        priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    else:\n        #Small items given some priority to bins which have more than the item size\n        priorities = np.where(bins_remain_cap >= item, 1/(1 + np.abs(bins_remain_cap-item)), 0)\n        priorities[bins_remain_cap < item] = -100 #negative priority to make sure not selected\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired component: Favor bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Give a base priority to bins that can fit.\n\n    # Remaining Capacity Based: Higher remaining capacity, lower priority to balance bin usage.\n    priorities[can_fit] -= (bins_remain_cap[can_fit] - item) / np.max(bins_remain_cap)  # Normalize to avoid dominance\n\n    # Avoidance of nearly full bins component: Discourage bins with very small remaining capacity, which may cause fragmentation\n    nearly_full = (bins_remain_cap > 0) & (bins_remain_cap < item + 0.1) # avoid floats==0, avoid very small gaps, account for float inaccuracy (epsilon 0.1)\n    priorities[nearly_full] -= 0.5\n\n    # Bins that can't fit should get the lowest possible score, so they aren't considered at all\n    priorities[~can_fit] = -np.inf\n\n    return priorities",
    "response_id": 12,
    "obj": 5.075787794176315,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign a very low priority to bins that can't fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n    \n    # 2. Remaining capacity after packing: Prioritize bins with smaller remaining capacity *after* packing the item, but only if they can fit it.\n    feasible_mask = ~infeasible_mask\n    remaining_capacity_after_packing = bins_remain_cap[feasible_mask] - item\n    \n    # Apply a function that penalizes larger remaining capacity while making it monotonically increase from zero.\n    # One option is to use the negative of the remaining capacity. However, very small and close to zero capacities could produce too low priority. We offset by np.max to turn all negative into positive values.\n    priorities[feasible_mask] = -remaining_capacity_after_packing + np.max(bins_remain_cap)\n\n    # 3. Give bins a small bonus if the item fills them close to full\n    filling_ratio = item / bins_remain_cap[feasible_mask]\n    close_to_full_bonus = np.where(filling_ratio > 0.7, 10, 0) # Tunable parameter\n    priorities[feasible_mask] = priorities[feasible_mask] + close_to_full_bonus\n    \n    # 4. A bonus for near-exact fit\n    near_exact_fit_threshold = 0.1 * item  # If bin capacity within 10% of item size\n    near_exact_fit_mask = (bins_remain_cap[feasible_mask] - item) <= near_exact_fit_threshold\n    near_exact_fit_bonus = np.where(near_exact_fit_mask, 20, 0) # A higher bonus for very near-perfect fit\n    priorities[feasible_mask] = priorities[feasible_mask] + near_exact_fit_bonus\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0\n\n    # Prioritize bins with smaller remaining capacity after adding the item\n    remaining_capacity_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1.0 / (remaining_capacity_after_fit + 0.0001) #adding small number to avoid divide by zero.\n\n    # Slightly penalize bins that are almost full after adding the item, since it limits future placements.\n    almost_full_mask = (remaining_capacity_after_fit < (0.1 * np.max(bins_remain_cap))) & fit_mask[bins_remain_cap >= item]  # Correctly index with boolean mask\n    priorities[almost_full_mask] -= 0.2\n\n    #Give zero priority to bins where item can't fit\n    priorities[~fit_mask] = -1.0\n\n    return priorities",
    "response_id": 14,
    "obj": 4.1284403669724865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # 1. Feasibility: High priority for bins that can actually fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[feasible_bins] += 1.0\n\n    # 2. Remaining Capacity: Higher priority for bins with less remaining capacity *after* adding the item\n    remaining_after_add = bins_remain_cap - item\n    remaining_after_add[remaining_after_add < 0] = np.inf  # Ignore infeasible bins\n\n    # Prioritize bins that leave less space\n    priorities[feasible_bins] += 1.0 / (remaining_after_add[feasible_bins] + 0.0001)  # Avoid division by zero\n\n    # 3. Fill ratio\n    fill_ratio = (bins_remain_cap - remaining_after_add) / bins_remain_cap\n    fill_ratio[~feasible_bins] = 0.0\n    priorities[feasible_bins] += fill_ratio[feasible_bins]\n\n    # 4. Bonus for bins close to being full:\n    near_full = (bins_remain_cap - item) < 0.1\n    priorities[near_full & feasible_bins] += 2.0\n\n    return priorities",
    "response_id": 15,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 17, in priority_v2\n    priorities[can_fit] += 1.0\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Bins that can accommodate the item get higher priority.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1.0\n\n    # Rule 2: Favor bins where the item fills a large portion of the remaining capacity.\n    fill_ratios = item / bins_remain_cap\n    fill_ratios[~can_fit] = 0  # Avoid division by zero and prioritize only valid bins\n    priorities += fill_ratios * can_fit #Only consider fill ratios of bins where item can fit\n   \n    # Rule 3: Reduce priority if the bin is getting too full and a small remaining space would be left\n    small_space_mask = (bins_remain_cap - item) < 0.1\n    priorities[can_fit & small_space_mask] -= 0.5 # Reduce priority slightly if a bin will have very little space left\n    \n    # Rule 4: If the bin is empty (equal to initial bin size), boost priority to encourage first-fit type behaviour.\n    empty_bin_mask = bins_remain_cap == bins_remain_cap.max()\n    priorities[empty_bin_mask & can_fit] += 0.75 #Higher priority boost for empty bins where the item can fit.\n\n    # Rule 5: If no bins can accomodate the item return bins with most space.\n    if not np.any(can_fit):\n        priorities = bins_remain_cap/bins_remain_cap.max()\n        \n    return priorities",
    "response_id": 16,
    "obj": 148.23494216194658,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Eliminate bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Very low priority\n    \n    # 2.  Fill-Rate Priority (Higher fill rate is better, but not perfect fit).\n    fill_rates = item / bins_remain_cap\n    fill_rates[infeasible_mask] = 0  # Zero fill rate for infeasible bins.\n    \n    priorities = fill_rates # Original priority with the fill rate\n    \n    #3. Best Fit bonus\n    best_fit_bonus = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / np.max(bins_remain_cap), 0)\n    priorities += - best_fit_bonus * (1 - fill_rates)\n\n    # 4. Small Remaining Capacity penalty (try to use bins with less space left)\n    remaining_cap_normalized = bins_remain_cap / np.max(bins_remain_cap)\n    priorities += (1 - remaining_cap_normalized) * 0.1  # Weigh it less to avoid extreme preference\n    \n\n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Can the item fit in the bin?\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity: Prefer bins where the item fits best (least wasted space)\n    waste = bins_remain_cap - item\n    waste[~feasible_bins] = np.inf  # Assign infinite waste to infeasible bins\n    \n    #Prioritize small amount of waste, only considering bins that can accomodate item\n    priorities[feasible_bins] = -waste[feasible_bins]\n    \n    #3. Bonus for nearly full bins (try to fill them up)\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap <= 2*item) #tune parameters\n    priorities[nearly_full] += 1 #can tune this parameter\n        \n    #4. Large bins: give negative priority to not use if other better option are there.\n    large_bins = bins_remain_cap > 3*item\n    priorities[large_bins] -=0.5\n\n    # Ensure infeasible bins have the lowest priority\n    priorities[~feasible_bins] = -np.inf\n\n    return priorities",
    "response_id": 18,
    "obj": 4.11846828879138,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: If the item doesn't fit, lowest priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit Criterion: Prioritize bins with smallest remaining capacity *after* packing the item\n    #    This encourages filling bins as much as possible.\n    feasible_mask = ~infeasible_mask\n    remaining_after_pack = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -np.abs(remaining_after_pack)  # Smaller absolute value = higher priority\n    \n    # 3. Tie-breaking (Slight Preference for bins that are already somewhat full):\n    #    Add a small bonus based on the *original* fill level. This can help avoid creating many bins with tiny amounts of wasted space.  Important this is added *after* the main Best Fit.\n    fill_levels = 1 - bins_remain_cap / np.max(bins_remain_cap) #Scale fill levels for consistent performance.\n    priorities[feasible_mask] += 0.001 * fill_levels[feasible_mask] # Small influence to avoid dominating best fit\n    \n    # 4. Bonus for exact fit\n    exact_fit_mask = bins_remain_cap == item\n    priorities[exact_fit_mask] = 1000 #Huge boost for exact fit so this is always chosen\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Large bins that can accommodate the item are preferred (First Fit Decreasing inspired)\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Basic priority for being able to fit\n\n    # Bins that have just enough space are preferred (Best Fit inspired)\n    space_left = bins_remain_cap - item\n    \n    # Avoid fragmenting bins too much: penalize almost full bins.\n    almost_full = (space_left > 0) & (space_left <= np.percentile(space_left[space_left>0] if np.any(space_left>0) else [0], 25) if np.any(space_left > 0) else np.array([False])) #only consider positive space_left to avoid indexing errors with negative space_left\n\n    priorities[almost_full] += 2 #Higher Priority\n    \n    # Add small random noise to break ties and explore more possibilities.\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.01\n    \n    return priorities",
    "response_id": 20,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\n    fill_level = 1 - (bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max())\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility Check: Give -inf priority to bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # Priority for bins that can fit:\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        \n        # 1. Smallest Waste First: Prefer bins that leave the smallest waste.  Scaled to be significant.\n        waste_priority = -remaining_space  # Smaller waste is better\n        \n        # 2. Fill Level Preference:  Prefer bins that are already somewhat full, but not too full.\n        fill_level = 1 - (bins_remain_cap[feasible_bins] / bins_remain_cap[feasible_bins].max())\n        fill_priority = fill_level # Slightly full preferred\n\n        # 3. Avoid very empty bins to promote consolidation, avoid fragmentation\n        empty_penalty = np.where(bins_remain_cap[feasible_bins] == bins_remain_cap[feasible_bins].max(), -10, 0) #heavily penalize filling an empty bin unless all other are full\n\n        priorities[feasible_bins] = waste_priority + fill_priority + empty_penalty\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Prioritize bins with smallest remaining capacity that can still fit the item\n            priorities[i] = 1 / (cap + 1e-6) # Avoid division by zero\n            # Add a bonus for near-perfect fit:\n            priorities[i] += np.exp(-10 * abs(cap - item) / item)\n        else:\n            priorities[i] = -1e9  # Very low priority for bins that can't fit the item\n    return priorities",
    "response_id": 22,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999965369992424 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins with smaller waste after placing item (First-Fit Decreasing like)\n            priorities[i] = 1 / (waste + 0.00001)  #Adding small value to avoid dividing by zero\n\n            # Additional considerations for prioritizing fuller bins\n            fullness = 1 - (cap / 1.0) # Assuming bin capacity is 1.0.\n            priorities[i] += fullness * 0.5  # give slight preference to fuller bins\n\n            # Penalize almost full bins to avoid extreme waste\n            if waste < 0.1:\n                priorities[i] *= 0.8\n        else:\n            priorities[i] = -np.inf  # cannot add to bin\n\n    return priorities",
    "response_id": 23,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99996878000093 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing-inspired heuristic: Prefer bins that can fit the item\n    # without a large remaining capacity, but prioritize almost-full bins.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        #Prioritize bins where the remaining capacity after packing is small.\n        remaining_after_packing = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1.0 / (remaining_after_packing + 0.0001)  # Avoid division by zero\n\n        # Boost priority for bins that are close to full after packing\n        almost_full_mask = remaining_after_packing < 0.1 * np.max(bins_remain_cap) #was < 0.1\n        priorities[fit_mask][almost_full_mask] *= 2.0\n\n    else:\n        # If no bin can fit, penalize bins with very low capacity.\n        # This tries to save space for future potentially smaller items.\n        priorities = - (item - bins_remain_cap) #Negative difference\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit Decreasing inspired: prioritize bins that can fit the item well\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Smaller remaining space is better\n    \n    # Avoid bins that are too full after adding the item\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < item + 0.1)  #tolerate floating point errors\n    priorities[almost_full_mask] = -np.inf # Mark them to be avoided.\n\n    # Use remaining cap as tie breaker\n    priorities += bins_remain_cap / np.max(bins_remain_cap, initial=1) / 1000 # prevent division by zero by setting initial to 1\n\n    return priorities",
    "response_id": 25,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 21, in priority_v2\n    \nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate wasted space if item is added to each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits.\n    fit_mask = wasted_space >= 0\n    priorities[fit_mask] = 1 / (wasted_space[fit_mask] + 1e-6)  # Avoid division by zero\n\n    # Slightly penalize bins where the item doesn't fit (discourage overallocation).\n    no_fit_mask = wasted_space < 0\n    priorities[no_fit_mask] = -np.abs(wasted_space[no_fit_mask])\n\n    # Boost priority for bins that are almost full before placing the item, using some sigmoid function.\n    almost_full = (bins_remain_cap > 0) & (bins_remain_cap <= 2 * item)\n    priorities[almost_full] += 1 / (1 + np.exp(-bins_remain_cap[almost_full]))\n\n    # Further prioritizing nearly full bins.\n    nearly_full_mask = fit_mask & (wasted_space < 0.1 * np.max(bins_remain_cap))\n    priorities[nearly_full_mask] += 5 # Give a significant priority boost\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very low priority to bins that cannot accommodate the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Prioritize bins that can fit the item.\n    feasible_bins = ~infeasible_bins\n    \n    if np.any(feasible_bins):\n        # Calculate the waste if the item is added to each feasible bin.\n        waste = bins_remain_cap[feasible_bins] - item\n\n        # Give higher priority to bins with smaller waste.  Invert and exponentiate to amplify the difference.  Add a small constant to avoid log(0) and encourage tighter packing.\n\n        priorities[feasible_bins] = np.exp(-waste / np.mean(bins_remain_cap[feasible_bins]))\n        \n        #Boost priority if item fills the bin completely, using condition and where\n        perfect_fit = np.isclose(waste, 0) & feasible_bins\n        priorities[perfect_fit] = np.inf\n\n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Primary priority: prioritize bins that can fit the item\n            priorities[i] = 1.0 / (cap - item + 0.00001) # avoid division by zero, prefer smaller difference\n        else:\n            # If it doesn't fit, assign a very low priority. We can use a large negative value.\n            priorities[i] = -1000.0 \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give high priority to bins that can fit the item reasonably well, but not perfectly.\n    fit_indices = bins_remain_cap >= item\n    \n    # Avoid bins that are too full or too empty after adding the item\n    \n    remaining_after_fit = bins_remain_cap[fit_indices] - item\n    \n    #Prioritize bins where the remaining capacity after adding the item is a good percentage of bin size\n    priority_fit = (1 - (remaining_after_fit / np.max(bins_remain_cap)))\n    \n    \n    priorities[fit_indices] = priority_fit #* (1 - item / bins_remain_cap[fit_indices])\n\n    # Penalize bins that cannot fit the item or would become nearly empty\n    \n    priority_too_small = (item - bins_remain_cap) #Penalty function for bins that are too small, zero otherwise\n    priority_too_small = np.maximum(priority_too_small, 0)\n\n    priorities = priorities - priority_too_small #Subtraction is correct\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]