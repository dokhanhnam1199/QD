[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority if the item fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0  # Give very high priority to perfect fits.\n\n    # High priority if the item fits\n    fits = (bins_remain_cap >= item)\n    if np.any(fits):\n        wasted_space = bins_remain_cap[fits] - item\n        #Prioritize bins where we waste the least space; invert wasted space to get a positive priority. \n        #Use a larger constant and scale wasted space for better differentiation.\n        priorities[fits] = 500.0 - (wasted_space * 2) \n\n\n    # Give a negative priority (discourage) bins that are too full (less than the item size)\n    no_fit = (bins_remain_cap < item)\n    priorities[no_fit] = -1000.0  # Discourage no-fit bins heavily.\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Assign a very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Prioritize bins with minimal remaining space after placing the item.\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_capacity  # Smaller remaining capacity -> higher priority\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    can_fit = bins_remain_cap >= item\n    priorities[~can_fit] = -np.inf\n\n    # 2. Encourage packing into feasible bins (Base priority boost)\n    priorities[can_fit] += 10.0\n\n    # 3. Balance Remaining Capacity:  Prioritize bins with smaller *normalized* remaining space, but avoid nearly full bins.\n    remaining_space = bins_remain_cap - item\n    \n    # Avoid division by zero by adding a small epsilon value.\n    max_capacity = np.max(bins_remain_cap)\n    epsilon = 1e-6\n\n    normalized_remaining_space = np.zeros_like(bins_remain_cap, dtype=float)\n    normalized_remaining_space[can_fit] = remaining_space[can_fit] / (max_capacity + epsilon)\n\n    # Subtract normalized remaining space from priority.\n    priorities[can_fit] -= normalized_remaining_space[can_fit]\n\n    # 4. Penalize Near-Full Bins: Avoid bins that would become almost full.\n    nearly_full_threshold = 0.1 * max_capacity # Dynamic threshold based on max capacity\n    nearly_full = (remaining_space > 0) & (remaining_space <= nearly_full_threshold)\n    priorities[nearly_full] -= 5.0\n\n    # 5. Bonus for bins that are already somewhat full (but not nearly full). Encourages filling bins that have already been used.\n    already_full_threshold = 0.5 * max_capacity  # Example threshold, adjust as needed\n    already_full = can_fit & (bins_remain_cap < already_full_threshold)\n    priorities[already_full] += 2.0 # Smaller bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 6.531711208615876,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Extremely high priority for perfect fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 10000\n\n    # Very high priority for near-perfect fit (small tolerance)\n    near_perfect_fit = (bins_remain_cap - item > 0) & (bins_remain_cap - item <= 0.1)\n    priorities[near_perfect_fit] = 5000\n\n    # Moderate priority for bins where the item fits\n    fits = bins_remain_cap >= item\n    fits_indices = np.where(fits)[0]\n\n    if len(fits_indices) > 0:\n        remaining_space = bins_remain_cap[fits] - item\n        # Prioritize based on remaining space, smaller remaining space gets higher priority\n        # Use a normalized score to avoid issues with different capacity scales\n        max_remaining = np.max(remaining_space)\n        if max_remaining > 0:  # Avoid division by zero\n            priorities[fits] = 1000 - (remaining_space / max_remaining) * 900  # Scale between 100 and 1000\n        else:\n            priorities[fits] = 1000 #All remaining space is same and 0.\n\n    # Lower priority if it fits but not perfectly/near perfectly and not the best fit, to avoid fragmentation.\n    other_fits = fits & ~perfect_fit & ~near_perfect_fit\n\n    # Apply some baseline priority, but less than perfect/near-perfect\n    priorities[other_fits] = np.maximum(priorities[other_fits],100)\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Normalized remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / bins_remain_cap[can_fit]\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        # This encourages filling up existing bins before opening new ones. Avoid bins near full or near empty.\n        fill_level = (bins_remain_cap[can_fit] / np.max(bins_remain_cap))\n        # Prioritize bins with a medium fill level (e.g., 0.2 to 0.8). Avoid overly empty or full bins\n        fill_penalty = np.abs(fill_level - 0.5)\n        priorities[can_fit] = priorities[can_fit] + (1 - fill_penalty)\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n        \n    return priorities",
    "response_id": 4,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n\n        # Normalized remaining capacity after fit (tighter fit is better)\n        normalized_remaining = remaining_after_fit / bin_capacity\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Dynamic scaling based on bin fill ratio\n        fill_ratio = (bins_remain_cap[can_fit] - remaining_after_fit) / bin_capacity\n\n        # Bonus for fill ratio within a good range (e.g., 0.5 to 0.9)\n        bonus = np.where((fill_ratio >= 0.5) & (fill_ratio <= 0.9), 0.5, 0.0)\n        priorities[can_fit] += bonus\n\n        # Penalize bins that will become nearly full after placing the item.\n        near_full_penalty = np.where(fill_ratio > 0.9, -0.75, 0.0)  # Significant penalty\n        priorities[can_fit] += near_full_penalty\n\n    else:\n        # If no bins can fit, prioritize the bin with the largest remaining capacity to minimize waste\n        priorities = bins_remain_cap / bin_capacity  # Normalize to give preference\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Tighter fit relative to original remaining capacity\n        normalized_remaining = remaining_after_fit / bins_remain_cap[can_fit]\n        priorities[can_fit] = 1.0 - normalized_remaining  # Higher priority for tighter fits\n\n        # Moderate fill level bonus (avoid near-empty or near-full bins)\n        current_fill_level = (np.max(bins_remain_cap) - bins_remain_cap[can_fit]) / np.max(bins_remain_cap)\n        fill_penalty = np.abs(current_fill_level - 0.5)  # Penalize deviations from 0.5 fill level\n        priorities[can_fit] += (1 - fill_penalty) * 0.5 # Scale the bonus\n\n        # Bonus for bins with capacity closest to item size\n        proximity = 1.0 / (np.abs(bins_remain_cap[can_fit] - item) + 0.00001)\n        priorities[can_fit] += proximity * 0.2 # Scale the bonus\n    else:\n        # If no bin fits, prioritize the fullest bin, so remaining_capacity is smallest.\n        priorities = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)\n        \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        max_capacity = np.max(bins_remain_cap)\n\n        # Tighter fit priority\n        normalized_remaining = remaining_after_fit / max_capacity\n        tighter_fit_priority = 1.0 - normalized_remaining\n\n        priorities[can_fit] = tighter_fit_priority\n\n        # Fill level penalty (Gaussian centered at 0.5)\n        fill_level = (max_capacity - bins_remain_cap[can_fit]) / max_capacity\n        fill_penalty = np.exp(-((fill_level - 0.5)**2) / 0.08)\n        priorities[can_fit] *= fill_penalty\n\n        # Proximity score (remaining capacity close to item size)\n        proximity_score = 1.0 / (np.abs(bins_remain_cap[can_fit] - item) / max_capacity + 0.00001)\n        priorities[can_fit] += proximity_score\n\n        # Refine by also considering remaining capacity relative to item size\n        item_relative_remaining = remaining_after_fit / (item + 0.00001)\n        item_relative_priority = np.exp(-((item_relative_remaining - 1.0)**2) / 0.1) # prefer item_relative_remaining = 1\n        priorities[can_fit] += item_relative_priority\n\n    else:\n        # If no bins can fit, prioritize the bin with largest remaining capacity, normalized by item size.\n        priorities = bins_remain_cap / (item + 0.00001)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect/Near-Perfect Fit: Highest Priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    almost_fit = (bins_remain_cap - item >= 0) & (bins_remain_cap - item <= 0.05)\n\n    priorities[perfect_fit] = 10000\n    priorities[almost_fit] = 5000\n\n    # 2. Feasibility Check\n    feasible_bins = bins_remain_cap >= item\n    infeasible_bins = ~feasible_bins\n    priorities[infeasible_bins] = -np.inf  # Ensure infeasible bins are never selected\n\n    # 3. Remaining Capacity Consideration for Feasible Bins\n    feasible_indices = np.where(feasible_bins)[0]\n    if len(feasible_indices) > 0:\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        mean_remaining_cap = np.mean(bins_remain_cap[feasible_bins]) if len(bins_remain_cap[feasible_bins]) > 0 else 0 # Avoid errors\n\n        # Prioritize bins with remaining space close to the mean, but not perfect fits.\n        # Normalized priority: Higher priority for bins closer to the mean remaining capacity\n        valid_bins = feasible_bins & ~perfect_fit & ~almost_fit #exclude perfect/almost fits from this calc\n        space_diff = np.abs(remaining_space[valid_bins[feasible_bins]] - mean_remaining_cap) #compute diff vs the mean\n        max_diff = np.max(np.abs(bins_remain_cap[feasible_bins] - mean_remaining_cap)) if len(bins_remain_cap[feasible_bins]) > 0 else 1 #normalise by max diff, avoid divide by 0\n\n        priorities[valid_bins] = 900 - (space_diff / max_diff) * 800 #scale from 100 to 900\n\n\n        #4. Give minimal priority to remaining feasible bins.\n        other_feasible = feasible_bins & ~perfect_fit & ~almost_fit & ~valid_bins\n        priorities[other_feasible] = 100\n    \n\n    return priorities",
    "response_id": 8,
    "obj": 84.5931392102114,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility Check: Give -inf priority to bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Priority for bins that can fit:\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        remaining_space = bins_remain_cap[feasible_bins] - item\n\n        # 1. Smallest Waste First: Prefer bins that leave the smallest waste. Scaled to be significant.\n        waste_priority = -remaining_space\n\n        # 2. Fill Level Preference: Prefer bins that are already somewhat full, but not too full.\n        # Normalize remaining capacity to a 0-1 scale (0 = full, 1 = empty)\n        normalized_remaining = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n        fill_level_priority = 1 - normalized_remaining  # Higher = more full\n\n        # 3. Fragmentation avoidance: Penalize bins that, after the item is added,\n        #    have remaining capacity larger than the current item. Avoid small items blocking larger ones later\n        frag_penalty = np.where(remaining_space > item, -5, 0)\n\n        # 4. Empty Bin Avoidance: Heavily penalize filling an empty bin unless all other bins are full. Only penalize if there are other feasible bins.\n        empty_penalty = np.where((bins_remain_cap[feasible_bins] == np.max(bins_remain_cap)) & (np.sum(feasible_bins) > 1), -10, 0)\n\n        priorities[feasible_bins] = waste_priority + fill_level_priority + frag_penalty + empty_penalty\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]