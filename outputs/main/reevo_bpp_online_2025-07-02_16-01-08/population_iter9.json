[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after placing the item in each feasible bin.\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity relative to the maximum bin capacity.\n        normalized_remaining = remaining_after_fit / max_cap\n\n        # Prioritize tight fits by minimizing normalized wasted space.  Invert to give higher scores to lower values.\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Perfect Fit Bonus: Give substantial bonus if item fits perfectly\n        perfect_fit = (remaining_after_fit == 0)\n        priorities[can_fit][perfect_fit] += 2.0\n\n        # Near-Perfect Fit Bonus: Give slight bonus if item nearly perfectly fits\n        near_perfect_fit = (remaining_after_fit > 0) & (remaining_after_fit <= 0.1 * max_cap)\n        priorities[can_fit][near_perfect_fit] += 1.0\n\n        # Fill Level Incentive: Encourage medium-full bins and discourage nearly empty.\n        fill_level_before = (bins_remain_cap[can_fit]) / max_cap\n\n        # Penalize bins that are too full after adding item, encouraging space\n        overfull_penalty = (remaining_after_fit < 0.1 * max_cap)\n        priorities[can_fit][overfull_penalty] -= 3.0 # Reduced Penalty\n\n        # Penalize near empty bins, discourage sparsely filled bins\n        empty_penalty = (fill_level_before > 0.9)\n        priorities[can_fit][empty_penalty] -= 0.5\n\n        # Adjust priority range, Ensure no negative scores\n        priorities[priorities < 0] = 0\n\n    else:\n        # If no bin can fit, heavily penalize and open a new bin\n        priorities = -10*np.ones_like(bins_remain_cap)\n        # prioritize bins with larger remaining capacity (to minimize number of needed bins), making them slightly less undesirable.\n        priorities[bins_remain_cap.argmax()] = -5 #Slightly better than others\n        \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)  # Use max capacity for normalization\n    \n        #Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-100*normalized_remaining) #High bonus when normalized_remaining is near zero\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + 2 * perfect_fit_bonus\n        \n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        fill_penalty = np.abs(fill_level - 0.5) # Penality for bins far from being half full.\n        priorities[can_fit] = priorities[can_fit] + (1 - fill_penalty) # Adjust the priorities\n\n\n    else:\n        # If no bin can fit, strongly penalize.\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Normalized remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / bins_remain_cap[can_fit]\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        # This encourages filling up existing bins before opening new ones. Avoid bins near full or near empty.\n        fill_level = (bins_remain_cap[can_fit] / np.max(bins_remain_cap))\n        # Prioritize bins with a medium fill level (e.g., 0.2 to 0.8). Avoid overly empty or full bins\n        fill_penalty = np.abs(fill_level - 0.5)\n        priorities[can_fit] = priorities[can_fit] + (0.5 - fill_penalty) # Scale fill penalty\n\n        # Add a small bonus to bins that are not too full and not too empty.  This may help avoid creating\n        # bins that are difficult to fill later.\n        intermediate_fill_bonus = np.exp(-((fill_level - 0.5)**2) / (2 * 0.15**2))\n        priorities[can_fit] = priorities[can_fit] + 0.1 * intermediate_fill_bonus\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        # Use a different scaling approach to avoid overly small values\n        priorities = bins_remain_cap / np.max(bins_remain_cap) # Normalize to [0, 1]\n        priorities = priorities * 0.2  # Reduce the magnitude to be small\n\n    return priorities",
    "response_id": 2,
    "obj": 4.028719585161557,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Normalized remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap) # Normalize by max capacity\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        # This encourages filling up existing bins before opening new ones. Avoid bins near full or near empty.\n        fill_level = (bins_remain_cap[can_fit] / np.max(bins_remain_cap))\n        # Prioritize bins with a medium fill level (e.g., 0.2 to 0.8). Avoid overly empty or full bins\n        fill_penalty = np.abs(fill_level - 0.5)\n        priorities[can_fit] = priorities[can_fit] + (1 - fill_penalty)\n\n        # Small bonus for almost perfect fit\n        almost_perfect = np.isclose(remaining_after_fit, 0)\n        priorities[can_fit][almost_perfect] += 0.5\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n        \n    return priorities",
    "response_id": 3,
    "obj": 5.10570402871959,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)  # Use max capacity for normalization\n    \n        #Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-50*normalized_remaining) #High bonus when normalized_remaining is near zero. Adjusted exponent.\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n        \n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        fill_penalty = np.abs(fill_level - 0.6) # Penality for bins far from being a bit more than half full. shifted the ideal point\n        priorities[can_fit] = priorities[can_fit] + (0.5 - fill_penalty) # Adjust the priorities. Reduced weight\n\n        #Slightly prioritize bins with bigger initial capacity\n        priorities[can_fit] = priorities[can_fit] + (bins_remain_cap[can_fit] / np.max(bins_remain_cap))*0.1 #weight 0.1\n\n    else:\n        # If no bin can fit, strongly penalize and slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = -1e8 # Slightly favor the empty bins but still penalize strongly\n\n    return priorities",
    "response_id": 4,
    "obj": 3.5700039888312682,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_capacity = np.max(bins_remain_cap)\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / max_capacity\n    \n        #Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-100*normalized_remaining) #High bonus when normalized_remaining is near zero\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n        \n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = (max_capacity - bins_remain_cap[can_fit]) / max_capacity\n        fill_penalty = np.abs(fill_level - 0.5) # Penality for bins far from being half full.\n\n        # Adjust the priorities based on fill level, stronger penalty\n        priorities[can_fit] = priorities[can_fit] + (1 - 2 * fill_penalty)\n\n\n    else:\n        # If no bin can fit, strongly penalize and slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = 1 # Slightly favor the empty bins\n\n    return priorities",
    "response_id": 5,
    "obj": 3.839250099720782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority if the item fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0  # Give very high priority to perfect fits.\n\n    # High priority if the item fits\n    fits = (bins_remain_cap >= item)\n    if np.any(fits):\n        wasted_space = bins_remain_cap[fits] - item\n        #Prioritize bins where we waste the least space; invert wasted space to get a positive priority. \n        #Scale wasted space for better differentiation.\n\n        # Normalize wasted space by item size\n        normalized_wasted_space = wasted_space / item\n\n        # Prioritize smaller wasted space\n        priorities[fits] = 500.0 - (normalized_wasted_space * 500)  # Increased scaling and normalization.\n\n\n    # Give a negative priority (discourage) bins that are too full (less than the item size)\n    no_fit = (bins_remain_cap < item)\n    priorities[no_fit] = -1000.0  # Discourage no-fit bins heavily.\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity AFTER placing item\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity AFTER placing item. Crucial for measuring waste relative to the bin.\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap) # use the original bin capacity\n\n        # Prioritize near-perfect fits. A perfect fit has normalized_remaining close to 0. Stronger effect\n        perfect_fit_bonus = np.exp(-20 * normalized_remaining) # Exponential decay, peaks at 0 remaining\n        priorities[can_fit] += 3 * perfect_fit_bonus\n\n        # Discourage high waste.  Penalize bins that leave a large proportion empty.  Use a stronger quadratic penalty.\n        waste_penalty = normalized_remaining**2 # quadratic penalty, 0 at no waste, 1 at full waste.\n        priorities[can_fit] += -2 * waste_penalty\n\n        #Encourage medium-full bins before placement. Normalize bins_remain_cap before placement.\n        normalized_before = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        medium_full_bonus = np.exp(-5 * (normalized_before - 0.6)**2)\n        priorities[can_fit] += medium_full_bonus # Encourage bins with remaining capacity around 0.6\n\n        #Bonus for using existing bins, but only if it is a good fit\n        already_used = bins_remain_cap < np.max(bins_remain_cap)\n        priorities[already_used & can_fit] += 0.5 * perfect_fit_bonus[already_used[can_fit]]\n\n    else:\n        # If item does not fit, strongly penalize the placement by assigning a very low priority\n        priorities = -1e9 * np.ones_like(bins_remain_cap)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Normalized remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)  # Normalize by max capacity\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Bin Fill Level Heuristic: Encourages filling bins to a certain level\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        # Penalize bins that are too full or too empty. A good range is 0.2 to 0.8, centered around 0.5\n        fill_penalty = np.abs(fill_level - 0.5)  # Distance from the ideal fill level\n        priorities[can_fit] += (1 - fill_penalty) * 0.5  # Scale to avoid overpowering the remaining capacity heuristic\n\n        # Perfect Fit Bonus: Significantly boost bins that offer a perfect fit\n        perfect_fit = np.isclose(remaining_after_fit, 0)\n        priorities[can_fit][perfect_fit] += 1.0  # Substantially increase priority for perfect fits\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity.\n        # This aims to reduce the number of bins opened when a new bin is unavoidable.\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after placing the item in each feasible bin.\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity relative to the original bin capacity.\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)\n\n        # Prioritize tight fits by minimizing normalized wasted space.  Invert the normalized_remaining to give higher scores to lower values.\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Perfect Fit Bonus: Give substantial bonus if item fits perfectly\n        perfect_fit = (remaining_after_fit == 0)\n        priorities[can_fit][perfect_fit] += 5.0\n\n        # Near-Perfect Fit Bonus: Give slight bonus if item nearly perfect fit\n        near_perfect_fit = (remaining_after_fit > 0) & (remaining_after_fit <= 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][near_perfect_fit] += 2.0\n\n        # Fill Level Incentive: Encourage medium-full bins and discourage nearly empty.\n\n        fill_level_before = (bins_remain_cap[can_fit]) / np.max(bins_remain_cap)\n\n        #Penalize bins that are too full after adding item, leave some space\n        overfull_penalty = (remaining_after_fit < 0.1 * np.max(bins_remain_cap))\n        priorities[can_fit][overfull_penalty] -= 5.0  # Very High Penalty\n\n        # Penalize near empty bins:\n\n        empty_penalty = (fill_level_before > 0.9)\n        priorities[can_fit][empty_penalty] -= 1.0\n\n        # Adjust priority range, Ensure no negative scores\n        priorities[priorities < 0] = 0\n\n    else:\n        # If no bin can fit, heavily penalize and try to open a new bin\n        priorities = -100*np.ones_like(bins_remain_cap)\n        # prioritize bins with larger remaining capacity (to minimize number of needed bins).\n        priorities[bins_remain_cap.argmax()] = -50 #Slightly better than others\n        \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)  # Use max capacity for normalization\n    \n        #Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-100*normalized_remaining) #High bonus when normalized_remaining is near zero. Adjusted exponent.\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n        \n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        \n        # Penalize bins that are either too empty or too full\n        fill_penalty = np.exp(-20 * (fill_level - 0.6)**2)  # Gaussian-like penalty, best around 0.6.\n\n        priorities[can_fit] = priorities[can_fit] + fill_penalty * 0.8 # Adjust the priorities. Increased weight\n\n        #Slightly prioritize bins with bigger initial capacity\n        priorities[can_fit] = priorities[can_fit] + (bins_remain_cap[can_fit] / np.max(bins_remain_cap))*0.05 #weight 0.05\n\n    else:\n        # If no bin can fit, strongly penalize and slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = -1e8 # Slightly favor the empty bins but still penalize strongly\n\n    return priorities",
    "response_id": 0,
    "obj": 3.520143597925803,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)  # Use max capacity for normalization\n    \n        #Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-20*normalized_remaining) #High bonus when normalized_remaining is near zero. Adjusted exponent.\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n        \n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        fill_penalty = np.abs(fill_level - 0.7) # Penality for bins far from being a bit more than half full. shifted the ideal point\n        priorities[can_fit] = priorities[can_fit] + (0.5 - fill_penalty)*0.7 # Adjust the priorities. Reduced weight\n\n        #Slightly prioritize bins with bigger initial capacity\n        priorities[can_fit] = priorities[can_fit] + (bins_remain_cap[can_fit] / np.max(bins_remain_cap))*0.05 #weight 0.05\n\n    else:\n        # If no bin can fit, strongly penalize and slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = -1e8 # Slightly favor the empty bins but still penalize strongly\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / bin_capacity\n\n        # Perfect fit bonus (exponential, prioritize near-perfect fits)\n        perfect_fit_bonus = np.exp(-100 * normalized_remaining)\n\n        # Initial priority based on tightness of fit (minimize waste)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n\n        # Fill-level considerations: bonus for medium-full, penalty for extremes\n        fill_level_before = bins_remain_cap[can_fit] / bin_capacity\n        fill_level_after = (bins_remain_cap[can_fit] - item) / bin_capacity\n        \n        # Ideal fill level around 0.7\n        fill_level_target = 0.7\n        fill_penalty = np.abs(fill_level_after - fill_level_target)\n\n        #Bonus for bins moving closer to the fill level target, negative penalty for moving far away\n        fill_bonus = -fill_penalty\n\n        priorities[can_fit] += fill_bonus * 0.5 # Reduce the weights of bonuses and penalties.\n\n\n        #Small priorization of bins that are bigger\n        priorities[can_fit] += (bins_remain_cap[can_fit] / bin_capacity) * 0.05\n    else:\n        # No bin can fit: heavily penalize, slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = -1e8  # Slightly favor largest\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n\n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)  # Use max capacity for normalization\n\n        # Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-100 * normalized_remaining)  # Even stronger bonus when normalized_remaining is near zero.\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        fill_penalty = np.abs(fill_level - 0.7)  # Penality for bins far from being more full, even more shifted the ideal point\n        fill_bonus = 0.5 - fill_penalty # Higher when fill level is around 0.7\n        priorities[can_fit] = priorities[can_fit] + fill_bonus*0.7 # Increase weight\n\n        #Slightly prioritize bins with bigger initial capacity, but less influential\n        priorities[can_fit] = priorities[can_fit] + (bins_remain_cap[can_fit] / np.max(bins_remain_cap)) * 0.05  # Reduced weight\n\n    else:\n        # If no bin can fit, strongly penalize and slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = -1e8  # Slightly favor the empty bins but still penalize strongly\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n\n        # Normalized remaining capacity after fit (relative to the bin's capacity)\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)\n\n        # Prioritize perfect/near-perfect fits\n        perfect_fit_bonus = np.exp(-50 * normalized_remaining)  # High bonus when normalized_remaining is near zero. Adjusted exponent.\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining + perfect_fit_bonus\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        #  Avoid bins near full or near empty to avoid small wastes and over-filling.\n        fill_level = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        \n        # Apply a sigmoid function to provide a smoother transition and fine-tune the fill level preference.\n        # Focus on the \"sweet spot\" around medium fill levels (0.4 to 0.8).\n        fill_preference = 1.0 / (1 + np.exp(-15 * (fill_level - 0.6))) # More aggressive sigmoid. Target fill 0.6\n        \n        priorities[can_fit] = priorities[can_fit] + fill_preference * 0.7  # Increased weight\n\n        #Slightly prioritize bins with bigger initial capacity\n        priorities[can_fit] = priorities[can_fit] + (bins_remain_cap[can_fit] / np.max(bins_remain_cap)) * 0.1\n\n    else:\n        # If no bin can fit, strongly penalize and slightly prefer bins with more capacity\n        priorities = -1e9 * np.ones_like(bins_remain_cap)  # Extremely negative priority\n        priorities[bins_remain_cap == np.max(bins_remain_cap)] = -1e8\n\n    return priorities",
    "response_id": 4,
    "obj": 1.9246110889509442,
    "exec_success": true
  }
]