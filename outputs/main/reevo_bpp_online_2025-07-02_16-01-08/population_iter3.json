[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority if the item fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0  # Give very high priority to perfect fits.\n\n    # High priority if the item fits\n    fits = (bins_remain_cap >= item)\n    if np.any(fits):\n        wasted_space = bins_remain_cap[fits] - item\n        #Prioritize bins where we waste the least space; invert wasted space to get a positive priority. Add a constant to ensure it is positive.\n        priorities[fits] = 100.0 - wasted_space\n\n\n    # Give a negative priority (discourage) bins that are too full (less than the item size)\n    no_fit = (bins_remain_cap < item)\n    priorities[no_fit] = -1000.0  # Discourage no-fit bins heavily.\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Feasibility check: Assign a very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Score based on how well the item fits into the bin\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    \n    # Prioritize bins where the remaining capacity is a good percentage of bin size\n    # A remaining capacity close to zero is also penalized\n\n    fit_score = 1 - np.abs((remaining_capacity / bin_capacity) - 0.5)  # Prefer ~50% remain\n    priorities[feasible_mask] = fit_score\n\n    return priorities",
    "response_id": 1,
    "obj": 76.4260071798963,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility Check: Give -inf priority to bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # Priority for bins that can fit:\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        \n        # 1. Smallest Waste First: Prefer bins that leave the smallest waste. Scaled to be significant.\n        waste_priority = -remaining_space  # Smaller waste is better\n        waste_priority = waste_priority / bins_remain_cap.max() # Normalize\n        waste_priority *= 5 #Scale up\n\n        # 2. Fill Level Preference: Prefer bins that are already somewhat full, but not too full.\n        fill_level = 1 - (bins_remain_cap[feasible_bins] / bins_remain_cap.max())\n        fill_priority = fill_level  # Slightly full preferred\n        #Heavily penalize too full bins\n        too_full = remaining_space < 0.1\n        fill_priority[too_full] -= 2\n        \n        # 3. Avoid very empty bins to promote consolidation, avoid fragmentation\n        empty_penalty = np.where(bins_remain_cap[feasible_bins] == bins_remain_cap.max(), -1, 0)  # heavily penalize filling an empty bin unless all other are full\n\n        priorities[feasible_bins] = waste_priority + fill_priority + empty_penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 4.956122856003196,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Disqualify bins that cannot fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Mark infeasible bins with negative infinity\n\n    # 2. Prioritize feasible bins based on remaining capacity\n    if np.any(feasible_bins):\n        remaining_capacity = bins_remain_cap[feasible_bins] - item\n\n        # Base priority: Inverse of remaining capacity (Best-Fit principle)\n        priorities[feasible_bins] = 1.0 / (remaining_capacity + 1e-9)\n\n        # 3. Reward near-full bins\n        near_full_threshold = 0.1  # Adjust as needed\n        near_full_bins = remaining_capacity <= near_full_threshold\n        priorities[feasible_bins][near_full_bins] *= 2.0  # Double the priority\n\n        # 4. Penalize near-empty bins\n        near_empty_threshold = 0.9  # Adjust as needed\n        near_empty_bins = remaining_capacity > near_empty_threshold\n        priorities[feasible_bins][near_empty_bins] /= 2.0  # Halve the priority\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a very high priority to bins where the item fits perfectly or almost perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    almost_fit = (bins_remain_cap - item >= 0) & (bins_remain_cap - item <= 0.05)  # Epsilon adjusted\n    fits = bins_remain_cap >= item\n\n    priorities[perfect_fit] = 10000  # Extremely high priority for perfect fit\n    priorities[almost_fit] = 5000  # Very high priority for almost perfect fit\n\n    # Prioritize bins that have enough capacity, but not too much (to avoid fragmentation).\n    remaining_space = bins_remain_cap - item\n    fits_indices = np.where(fits)[0]  # Get indices where item fits\n    if len(fits_indices) > 0:\n        mean_remaining_cap = np.mean(bins_remain_cap[fits])\n        valid_bins = fits & (remaining_space <= mean_remaining_cap)\n        # Normalize priority based on remaining space, higher priority for smaller space\n        priorities[valid_bins] = 1000 - (remaining_space[valid_bins] / mean_remaining_cap) * 900\n\n    # Give a small priority to all bins where the item fits (but not the previous conditions)\n    other_fits = fits & ~perfect_fit & ~almost_fit & ~valid_bins\n    priorities[other_fits] = 100  # Moderate priority for general fit\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Prioritize fit: Give a large priority boost to bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 10.0\n\n    # Balance remaining capacity: Smaller remaining capacity after fitting is better, but avoid making bins nearly full\n    remaining_space = bins_remain_cap - item\n    \n    # Normalize remaining space to bin capacity and consider only bins where item can fit.\n    normalized_remaining_space = np.zeros_like(bins_remain_cap, dtype=float)\n    normalized_remaining_space[can_fit] = remaining_space[can_fit] / np.max(bins_remain_cap)\n    \n    # Higher priority if normalized_remaining_space is smaller. Subtract it from the priority.\n    priorities[can_fit] -= normalized_remaining_space[can_fit]\n\n    # Avoid near-full bins: Penalize bins where the remaining space would be very small.\n    nearly_full = (remaining_space > 0) & (remaining_space <= 0.1)\n    priorities[nearly_full] -= 5.0\n\n    # Discourage bins that can't fit by giving lowest possible score.\n    priorities[~can_fit] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility Check: Give -inf priority to bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Priority for bins that can fit:\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        remaining_space = bins_remain_cap[feasible_bins] - item\n\n        # 1. Smallest Waste First: Prefer bins that leave the smallest waste. Scaled to be significant.\n        waste_priority = -remaining_space\n\n        # 2. Fill Level Preference: Prefer bins that are already somewhat full, but not too full.\n        # Normalize remaining capacity to a 0-1 scale (0 = full, 1 = empty)\n        normalized_remaining = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)\n        fill_level_priority = 1 - normalized_remaining  # Higher = more full\n\n        # 3. Fragmentation avoidance: Penalize bins that, after the item is added,\n        #    have remaining capacity larger than the current item. Avoid small items blocking larger ones later\n        frag_penalty = np.where(remaining_space > item, -5, 0)  # Reduced penalty\n\n        # 4. Empty Bin Avoidance: Heavily penalize filling an empty bin unless all other bins are full.\n        empty_penalty = np.where(bins_remain_cap[feasible_bins] == np.max(bins_remain_cap), -10, 0)\n\n        priorities[feasible_bins] = waste_priority + fill_level_priority + frag_penalty + empty_penalty\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Assign a very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Prioritize bins with minimal remaining space after placing the item.\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_capacity  # Smaller remaining capacity -> higher priority\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Eliminate bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Very low priority\n    \n    # 2.  Fill-Rate Priority (Higher fill rate is better, but not perfect fit).\n    fill_rates = item / bins_remain_cap\n    fill_rates[infeasible_mask] = 0  # Zero fill rate for infeasible bins.\n    \n    priorities = fill_rates # Original priority with the fill rate\n    \n    #3. Best Fit bonus/penalty - Prefer bins where the remaining space is small (but feasible).\n    # The closer to zero, the better the fit. Subtracting this value encourages smaller remaining space.\n    best_fit_penalty = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / np.max(bins_remain_cap), 0)\n    priorities -= best_fit_penalty * 0.5 # Scale down the penalty\n\n    # 4. Small Remaining Capacity bonus (try to use bins with less space left).  Prioritizes bins that are already somewhat full.\n    remaining_cap_normalized = bins_remain_cap / np.max(bins_remain_cap)\n    priorities += (1 - remaining_cap_normalized) * 0.1 # Weigh it less to avoid extreme preference.\n\n    # 5. Empty Bin Bonus (First-Fit type encouragement).  Only applied if the item *can* fit.\n    empty_bin_mask = bins_remain_cap == bins_remain_cap.max()\n    priorities[empty_bin_mask & ~infeasible_mask] += 0.2 # Small bonus to encourage use of empty bins.\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.058635819704831,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item.\n    fit_indices = bins_remain_cap >= item\n\n    if np.any(fit_indices):\n        # Calculate the fill ratio (item size / bin capacity after placement). Higher is better.\n        fill_ratio = item / (bins_remain_cap[fit_indices])\n        priorities[fit_indices] = fill_ratio\n\n        # Scale priorities to emphasize tight fits.\n        priorities[fit_indices] *= 10  # Increase contribution of feasible bins\n\n        # Prioritize bins with less remaining space after item is placed (tight fit).\n        remaining_space = bins_remain_cap[fit_indices] - item\n        priorities[fit_indices] += (1 / (remaining_space + 0.0001))  # Avoid division by zero and prioritize smaller remaining space\n\n    else:\n        # If no bin can fit, assign a negative priority to all bins.\n        priorities = np.full_like(bins_remain_cap, -1.0)\n\n        # Find the bin with the maximum remaining capacity and give it a slightly better negative priority.\n        max_cap_idx = np.argmax(bins_remain_cap)\n        priorities[max_cap_idx] = -0.9  # Slightly better than other infeasible bins\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Normalized remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / bins_remain_cap[can_fit]\n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        # This encourages filling up existing bins before opening new ones. Avoid bins near full or near empty.\n        fill_level = (bins_remain_cap[can_fit] / np.max(bins_remain_cap))\n        # Prioritize bins with a medium fill level (e.g., 0.2 to 0.8). Avoid overly empty or full bins\n        fill_penalty = np.abs(fill_level - 0.5)\n        priorities[can_fit] = priorities[can_fit] + (1 - fill_penalty)\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n        \n    return priorities",
    "response_id": 0,
    "obj": 4.038691663342641,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)\n        \n        # Prioritize smaller normalized remaining capacity (tighter fit)\n        priorities[can_fit] = 1.0 - normalized_remaining\n        \n        # Dynamic scaling based on bin state. Avoid near-full or near-empty bins\n        fill_ratio = (bins_remain_cap[can_fit] - remaining_after_fit) / np.max(bins_remain_cap)\n        \n        # Add a bonus if the fill ratio is within a good range (e.g., 0.6 to 0.9)\n        bonus = np.where((fill_ratio >= 0.6) & (fill_ratio <= 0.9), 0.5, 0.0)\n        priorities[can_fit] += bonus\n\n    else:\n        # If no bins can fit, prioritize the bin with the largest remaining capacity.\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity after fit.  Smaller is better.\n        normalized_remaining = remaining_after_fit / bins_remain_cap[can_fit]\n        \n        # Use inverse of normalized remaining capacity as a base priority.\n        # Higher priority to bins that are filled more completely.\n        priorities[can_fit] = 1.0 / (normalized_remaining + 0.00001)  # Avoid division by zero\n        \n        # Prioritize bins whose remaining capacity is closest to the item size.\n        # Minimizes fragmentation and creates tighter fits.\n        proximity_score = 1.0 / (np.abs(bins_remain_cap[can_fit] - item) + 0.00001)\n        priorities[can_fit] += proximity_score\n        \n        # Dynamically scale priorities: Penalize near-full or near-empty bins *after* placing item\n        fill_level_after_fit = (bins_remain_cap[can_fit] - item) / np.max(bins_remain_cap) #Assuming all bins have same initial capacity\n        \n        # Penalize if fill_level_after_fit is close to 0 or 1.  Target medium fill levels.\n        fill_level_penalty = -np.abs(fill_level_after_fit - 0.5) # Penalize deviation from 0.5 (half full)\n\n        priorities[can_fit] += fill_level_penalty\n\n\n    else:\n        # No bins can fit. Prioritize the bin with the largest remaining capacity\n        # but reduce the priority to distinguish from bins that can fit.\n        priorities = bins_remain_cap / np.max(bins_remain_cap) # Normalize\n        priorities = priorities * 0.1  # Reduce priority significantly\n        \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Normalized remaining capacity:  closer to 0 is better (tighter fit).\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)\n\n        # Give higher priority to tighter fits.  Invert and offset to ensure positive values.\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Scale priority based on current fill level.  Avoid near-full or near-empty bins.\n        fill_level = (np.max(bins_remain_cap) - bins_remain_cap[can_fit]) / np.max(bins_remain_cap)\n        \n        # Penalize bins that are already almost full or almost empty.\n        fill_penalty = np.exp(-((fill_level - 0.5)**2) / 0.08)  # Gaussian centered at 0.5\n        priorities[can_fit] *= fill_penalty\n\n        # Prioritize bins with remaining capacity closest to item size\n        proximity_score = 1.0 / (np.abs(bins_remain_cap[can_fit] - item) / np.max(bins_remain_cap) + 0.00001)\n\n        priorities[can_fit] += proximity_score\n        \n    else:\n        # If no bins can fit, prioritize the bin with largest remaining capacity.\n        # This might lead to opening a new bin later.  Divide by the item size to\n        # normalize based on the item we're trying to place.\n        priorities = bins_remain_cap / (item + 0.00001)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0 # Assuming bin size is 1, makes the code more general\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Calculate remaining capacity after placing item\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n\n        # Normalized remaining capacity (waste)\n        normalized_waste = remaining_after_fit / bin_size\n\n        # Priority based on minimizing normalized waste\n        priorities[can_fit] = 1.0 - normalized_waste # Higher priority for less waste\n\n        # Prioritize bins that are already reasonably full, but not too full\n        fill_level = (bin_size - bins_remain_cap[can_fit]) / bin_size\n        \n        # Apply a bonus for bins in a sweet spot of fill level (e.g., 0.4 to 0.8)\n        sweet_spot_lower = 0.4\n        sweet_spot_upper = 0.8\n        in_sweet_spot = (fill_level >= sweet_spot_lower) & (fill_level <= sweet_spot_upper)\n        priorities[can_fit][in_sweet_spot] += 0.5  # Give a significant bonus\n\n        # Penalize near-full bins to avoid extreme fragmentation\n        near_full_threshold = 0.9\n        near_full = fill_level > near_full_threshold\n        priorities[can_fit][near_full] -= 0.2 # Reduce priority if nearly full\n\n    else:\n        # If no bin fits, prioritize the least full bin (to potentially open a new one later)\n        fill_levels = (bin_size - bins_remain_cap) / bin_size\n        priorities = 1.0 - fill_levels  # Higher priority to least full\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]