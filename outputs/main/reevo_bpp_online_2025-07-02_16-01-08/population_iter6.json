[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Normalized remaining capacity after fit, prioritize tighter fits\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap)\n        priorities[can_fit] = 1.0 - normalized_remaining\n        \n        # Encourage medium fill levels before placing item.\n        fill_level_before = bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        fill_penalty = np.abs(fill_level_before - 0.5) # Prefer levels closer to 0.5\n        priorities[can_fit] += (1.0 - fill_penalty)\n\n        # Small bonus for already used bins\n        already_used = bins_remain_cap < np.max(bins_remain_cap)\n        priorities[already_used & can_fit] += 0.5 #Slightly prefer existing bins if feasible\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity.\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.836457917830076,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Normalized remaining capacity after fit, higher is better.\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        normalized_remaining = remaining_after_fit / np.max(bins_remain_cap) \n\n        # Prioritize bins that result in a tighter fit (lower normalized remaining capacity)\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Add a bonus for bins that are already relatively full before the item is added.\n        # This encourages filling up existing bins before opening new ones. Avoid bins near full or near empty.\n        fill_level = (np.max(bins_remain_cap) - bins_remain_cap[can_fit]) / np.max(bins_remain_cap)\n\n        # Prioritize bins with a medium fill level (e.g., 0.2 to 0.8). Avoid overly empty or full bins\n        fill_penalty = np.abs(fill_level - 0.5)\n        priorities[can_fit] = priorities[can_fit] + (1 - fill_penalty) * 0.5 #Scale the bonus\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n        \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Remaining capacity after fit\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Prioritize near-perfect fits\n        perfect_fit_threshold = 0.1 * bin_capacity  # e.g., within 10% of perfect fit\n        near_perfect_fit = (remaining_after_fit >= 0) & (remaining_after_fit <= perfect_fit_threshold)\n        priorities[can_fit][near_perfect_fit] += 2.0  # Higher bonus for near-perfect fit\n\n        # Minimize waste (prioritize tighter fits in general)\n        normalized_remaining = remaining_after_fit / bin_capacity\n        priorities[can_fit] += (1.0 - normalized_remaining)\n        \n        # Dynamic fill level bonus/penalty\n        fill_level = (bin_capacity - bins_remain_cap[can_fit]) / bin_capacity # Current bin fill level\n        mid_range_start = 0.25\n        mid_range_end = 0.75\n\n        mid_fullness_bonus = np.where(\n            (fill_level >= mid_range_start) & (fill_level <= mid_range_end),\n            1.0,  # Give a bonus if in the mid-range\n            0.0\n        )\n        \n        priorities[can_fit] += mid_fullness_bonus\n\n        # Apply a small penalty for bins that are already quite full to encourage using emptier bins when possible, even if the fit isn't perfect\n        high_fullness_penalty = np.where(fill_level > 0.8, -0.5, 0.0) #slight penalty if 80% full\n        priorities[can_fit] += high_fullness_penalty\n\n        #Feasibility score to make sure not NAN values, still allow selection if other scores are equal\n        priorities[can_fit] += 1e-6\n    else:\n        # No bin can fit, prioritize bins with larger remaining capacity, but less aggressively\n        #and also penalize it\n        priorities = (bins_remain_cap / bin_capacity * 0.1) - 0.2 # Lower priority if no fit. Subtract penalty to make it less attractive\n\n    return priorities",
    "response_id": 2,
    "obj": 9.234144395692075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Prioritize tighter fits: normalize remaining capacity *after* placing the item\n        normalized_remaining = remaining_after_fit / (bins_remain_cap[can_fit] + 1e-9)  # Avoid division by zero\n\n        priorities[can_fit] = 1.0 - normalized_remaining\n        \n        # Bonus for bins that are already partially full.\n        current_fill = (bins_remain_cap[can_fit] - remaining_after_fit) / (np.max(bins_remain_cap) + 1e-9) #Use max_cap for current fill, avoid division by zero\n\n        #Give a larger bonus to bins between 0.3 and 0.7 fill range\n        fill_bonus = np.where((current_fill >= 0.3) & (current_fill <= 0.7), 0.5, 0.0) \n        priorities[can_fit] += fill_bonus\n\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        priorities = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9) # Avoid division by zero\n        \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Extremely high priority for perfect fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 100000\n\n    # Very high priority for near-perfect fit (small tolerance)\n    near_perfect_fit = (bins_remain_cap - item > 0) & (bins_remain_cap - item <= 0.05 * item)  # tolerance relative to item size\n    priorities[near_perfect_fit] = 50000\n\n    # Moderate priority for bins where the item fits\n    fits = bins_remain_cap >= item\n    fits_indices = np.where(fits)[0]\n\n    if len(fits_indices) > 0:\n        remaining_space = bins_remain_cap[fits] - item\n        # Prioritize based on remaining space, smaller remaining space gets higher priority\n        # Use a normalized score to avoid issues with different capacity scales\n        min_remaining = np.min(remaining_space)\n        max_remaining = np.max(remaining_space)\n\n        if max_remaining > 0:  # Avoid division by zero\n            # Scale remaining space inversely: smaller remaining space -> higher score\n            priorities[fits] = 1000 - ((remaining_space - min_remaining) / (max_remaining - min_remaining)) * 900  # Scale between 100 and 1000\n            # if remaining space are the same, it will result in division by zero error. subtracting the min_remaining fixes this.\n        else:\n            priorities[fits] = 1000  # All remaining space is the same and 0.\n\n    # Lower priority if it fits but not perfectly/near perfectly and not the best fit, to avoid fragmentation.\n    other_fits = fits & ~perfect_fit & ~near_perfect_fit\n\n    # Apply some baseline priority, but less than perfect/near-perfect\n    priorities[other_fits] = np.maximum(priorities[other_fits], 100)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect Fit: Highest Priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 10000.0\n\n    # 2. Feasibility Check & Wasted Space Minimization\n    feasible_bins = bins_remain_cap >= item\n    infeasible_bins = ~feasible_bins\n    priorities[infeasible_bins] = -np.inf  # Ensure infeasible bins are never selected\n\n    # Prioritize feasible bins based on minimizing wasted space\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    # Invert wasted space to create a priority score; smaller wasted space -> higher priority\n    priorities[feasible_bins] = 1000.0 - wasted_space * 10 # Scale wasted space to make the priority meaningful\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority if the item fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0  # Give very high priority to perfect fits.\n\n    # High priority if the item fits\n    fits = (bins_remain_cap >= item)\n    if np.any(fits):\n        wasted_space = bins_remain_cap[fits] - item\n        #Prioritize bins where we waste the least space; invert wasted space to get a positive priority. \n        #Scale wasted space for better differentiation.\n        priorities[fits] = 500.0 - (wasted_space * 10) # Increased scaling\n\n    # Give a negative priority (discourage) bins that are too full (less than the item size)\n    no_fit = (bins_remain_cap < item)\n    priorities[no_fit] = -1000.0  # Discourage no-fit bins heavily.\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: Assign a very low priority to bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Prioritize bins with minimal remaining space after placing the item.\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_capacity  # Smaller remaining capacity -> higher priority\n\n    # Add a tie-breaker: Prefer bins with higher initial capacity among those with similar remaining capacity\n    priorities[feasible_mask] += bins_remain_cap[feasible_mask] * 1e-6\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):\n        # Tighter fit priority: prioritize smaller remaining capacity after placing the item.\n        remaining_after_fit = bins_remain_cap[can_fit] - item\n        \n        # Relative normalization:  Normalize remaining capacity by the item size. This emphasizes how \"tight\" the fit is *relative* to the item being placed.\n        normalized_remaining = remaining_after_fit / item\n        priorities[can_fit] = 1.0 - normalized_remaining\n\n        # Balanced bin utilization: Prioritize bins that are neither too full nor too empty.\n        current_fill = (np.max(bins_remain_cap) - bins_remain_cap[can_fit]) / np.max(bins_remain_cap)\n        fill_penalty = np.abs(current_fill - 0.5) # Closer to 0.5 is better\n        priorities[can_fit] += (1 - fill_penalty)\n\n        # Additional bonus for bins that are close to full *after* placing the item (but not overfull) to encourage complete filling\n        future_fill = (np.max(bins_remain_cap) - remaining_after_fit) / np.max(bins_remain_cap)\n        fullness_bonus = np.where((future_fill > 0.7) & (future_fill <= 1.0), 0.5, 0.0)\n        priorities[can_fit] += fullness_bonus\n    else:\n        # If no bin can fit, prioritize bins with larger remaining capacity (to minimize number of needed bins)\n        priorities = bins_remain_cap / np.max(bins_remain_cap)\n        \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Infeasible bins get the lowest priority.\n    can_fit = bins_remain_cap >= item\n    priorities[~can_fit] = -np.inf\n\n    # 2. Encourage packing into feasible bins (Base priority boost)\n    priorities[can_fit] += 10.0\n\n    # 3. Balance Remaining Capacity: Prioritize bins with smaller *normalized* remaining space, but avoid nearly full bins.\n    remaining_space = bins_remain_cap - item\n\n    # Avoid division by zero by adding a small epsilon value.\n    max_capacity = np.max(bins_remain_cap)\n    epsilon = 1e-6\n\n    normalized_remaining_space = np.zeros_like(bins_remain_cap, dtype=float)\n    normalized_remaining_space[can_fit] = remaining_space[can_fit] / (max_capacity + epsilon)\n\n    # Subtract normalized remaining space from priority.\n    priorities[can_fit] -= normalized_remaining_space[can_fit] * 5  # Increased impact of normalized space\n\n    # 4. Penalize Near-Full Bins: Avoid bins that would become almost full.\n    nearly_full_threshold = 0.15 * max_capacity  # Dynamic threshold based on max capacity, slightly increased\n    nearly_full = (remaining_space > 0) & (remaining_space <= nearly_full_threshold)\n    priorities[nearly_full] -= 8.0 # Increased penalty\n\n    # 5. Bonus for bins that are already somewhat full (but not nearly full). Encourages filling bins that have already been used.\n    already_full_threshold = 0.6 * max_capacity  # Example threshold, adjust as needed, Increased threshold\n    already_full = can_fit & (bins_remain_cap < already_full_threshold) & ~nearly_full\n    priorities[already_full] += 3.0  # Smaller bonus, slightly increased\n\n    #6. Perfect Fit Bonus\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] += 15.0\n\n    return priorities",
    "response_id": 9,
    "obj": 7.538891104906277,
    "exec_success": true
  }
]