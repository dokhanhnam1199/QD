[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This design implements a \"Best Fit\" like strategy: it prioritizes bins\n    that will have the smallest remaining capacity after the item is placed,\n    thus attempting to fill bins as tightly as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins where the item does not\n        fit are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A smaller 'remaining_after_placement' value indicates a tighter fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity.\n    # This ensures that bins where the item does not fit (or any bin for\n    # that matter, until we assign a valid score) are never chosen\n    # unless there's absolutely no other option (which implies no valid fit).\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item can actually fit (remaining capacity >= 0)\n    can_fit_mask = remaining_after_placement >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # To implement \"Best Fit\" where we want to minimize the remaining capacity,\n    # we take the negative of `remaining_after_placement`.\n    # A smaller positive `remaining_after_placement` (e.g., 0 for a perfect fit)\n    # will result in a priority score closer to 0 (or positive if `remaining_after_placement` was negative, which is already handled by `can_fit_mask`).\n    # For example:\n    #   - If remaining_after_placement is 0 (perfect fit), priority is 0.\n    #   - If remaining_after_placement is 5, priority is -5.\n    # Maximizing this priority score will naturally select the bin with the smallest\n    # non-negative `remaining_after_placement`.\n    priorities[can_fit_mask] = -remaining_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version implements a \"Proportional Best Fit\" heuristic.\n    It prioritizes bins based on how large a proportion of their *remaining capacity*\n    the current item will consume. The goal is to maximize the utilization efficiency\n    of the available space within each candidate bin.\n\n    A perfect fit (where the item's size is exactly equal to the bin's remaining capacity)\n    yields the highest possible score (1.0). Bins that are a tighter fit (where the item\n    fills a larger percentage of the remaining space) receive higher scores.\n\n    Bins where the item cannot fit at all (item size is greater than remaining capacity)\n    are assigned a very low priority (negative infinity) to ensure they are never selected.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin for the item.\n    \"\"\"\n    \n    # Initialize priorities with a very low value. This effectively disqualifies\n    # any bin that doesn't meet the criteria (e.g., item does not fit).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    # Identify bins where the item can physically fit.\n    # We also ensure the remaining capacity is not zero to prevent division by zero,\n    # unless item itself is zero (which is generally not the case in BPP, items have positive size).\n    # If item > 0 and bins_remain_cap == 0, can_fit will be False, so no division issue.\n    can_fit_mask = item <= bins_remain_cap\n    \n    # For bins where the item can fit, calculate the priority score.\n    # The score is item_size / bin_remaining_capacity.\n    # This ratio ranges from just above 0 (for very small items in very large bins)\n    # up to 1.0 (for a perfect fit). Maximizing this ratio promotes efficient space usage.\n    \n    # Only calculate for bins where can_fit_mask is True\n    # If `item` is 0, all `bins_remain_cap` would get a 0.0 priority.\n    # Assuming `item > 0`, `bins_remain_cap[can_fit_mask]` will also be > 0.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy. This heuristic aims to minimize\n    the unused space within a bin after the item is placed. Bins that can\n    fit the item and leave the least remaining capacity will have higher\n    priority. Bins that cannot fit the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that\n    # bins that cannot fit the item will never be chosen, as their\n    # priority will remain at this extremely low value.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the \"wastage\" or\n    # the remaining space after the item is placed. The Best Fit strategy\n    # seeks to minimize this wastage.\n    # To transform this into a priority score where higher is better,\n    # we take the negative of the wastage. This means a smaller positive\n    # wastage value (e.g., 0.1) results in a larger priority score (-0.1)\n    # compared to a larger wastage value (e.g., 0.5) which results in -0.5.\n    wastage = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -wastage\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit\n    approach. Bins that cannot fit the item receive a very low (negative infinity)\n    priority. For bins where the item fits, the priority is higher for bins that\n    would have less remaining capacity after the item is placed (i.e., a \"tighter\" fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a very low value for all bins.\n    # This ensures that bins where the item does not fit will never be chosen,\n    # as their priority will be -infinity.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float32)\n\n    # Determine which bins have enough remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # For bins that can fit, this will be non-negative. For others, it might be negative.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # For a \"Best Fit\" strategy, we want to minimize the remaining capacity after placing the item.\n    # To convert this minimization into a maximization problem (which the priority function seeks\n    # by selecting the bin with the highest score), we can use the negative of the\n    # potential remaining capacity.\n    # A smaller positive remainder (e.g., 0.1) results in a larger priority score (-0.1)\n    # compared to a larger positive remainder (e.g., 10.0) which results in a smaller\n    # priority score (-10.0). A perfect fit (0.0 remaining) results in the highest\n    # possible score of 0.0 among fitting bins.\n    \n    # Apply this logic only to the bins where the item actually fits.\n    priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    implementing a \"Best Fit\" strategy.\n\n    The \"Best Fit\" strategy aims to place the item into the bin that\n    leaves the least amount of remaining space. This encourages filling\n    bins as tightly as possible to minimize the total number of bins used.\n\n    Priority calculation:\n    - For bins where the item does not fit, a very low priority (-infinity) is assigned.\n    - For bins where the item fits, the priority is calculated as the negative\n      of the remaining capacity *after* the item is placed.\n      A smaller positive remaining capacity (tighter fit) results in a priority\n      closer to zero, which is considered higher than a more negative priority\n      (larger remaining capacity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value for bins that cannot fit the item.\n    # Using -np.inf ensures these bins will never be chosen unless no other bin fits.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the current item.\n    can_fit_indices = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity if the item were placed.\n    # This is (current_remaining_capacity - item_size).\n    remaining_space_after_placement = bins_remain_cap[can_fit_indices] - item\n\n    # Assign priorities based on the Best Fit principle.\n    # We want to minimize 'remaining_space_after_placement'.\n    # To convert this to a maximization problem (highest priority wins), we use\n    # the negative of 'remaining_space_after_placement'.\n    # A smaller 'remaining_space_after_placement' (e.g., 0.1) results in a\n    # higher priority (-0.1) compared to a larger one (e.g., 0.5 -> -0.5).\n    priorities[can_fit_indices] = -remaining_space_after_placement\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the Best Fit (BF) heuristic.\n\n    The Best Fit heuristic aims to place an item into the bin that will have the\n    smallest remaining capacity after the item is placed, thus finding the \"tightest fit\".\n    This strategy minimizes the \"wasted\" space in any individual bin for the current item,\n    which often leads to better overall bin utilization.\n\n    A higher priority score indicates a more desirable bin. Bins where the item does not\n    fit will be assigned a very low (negative infinity) priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of the same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A smaller positive value indicates a tighter fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (-np.inf).\n    # This ensures that bins where the item cannot fit will never be selected\n    # if there's any bin that can accommodate the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item actually fits (i.e., remaining capacity >= 0).\n    fits_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a priority.\n    # We want to prioritize bins with a *smaller* potential_remaining_cap.\n    # To achieve this with a \"highest priority\" selection, we take the negative\n    # of the potential_remaining_cap. This transforms a minimization problem\n    # (minimize remaining capacity) into a maximization problem (maximize negative remaining capacity).\n    # Example:\n    #   - If remaining_cap is 0.1, priority is -0.1.\n    #   - If remaining_cap is 0.0 (perfect fit), priority is 0.0.\n    #   - If remaining_cap is 0.2, priority is -0.2.\n    # A priority of 0.0 is higher than -0.1, which is higher than -0.2, correctly\n    # prioritizing the perfect fit, then the tighter non-perfect fit.\n    priorities[fits_mask] = -potential_remaining_cap[fits_mask]\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This heuristic implements a variation of the Best Fit strategy.\n    \n    The Best Fit strategy aims to minimize the remaining space in a bin after an item is placed.\n    This approach helps to consolidate items into fewer bins, leaving larger capacities\n    in other bins for potentially larger future items.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority.\n        Bins that cannot fit the item will have a very low (negative infinity) priority.\n    \"\"\"\n    \n    # Initialize all priorities to a very low value (-np.inf).\n    # This ensures that bins which cannot accommodate the item are effectively\n    # ruled out from consideration, as their priority will always be lower than any\n    # bin that can actually fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask to identify bins where the item can actually fit.\n    # An item can fit if its size is less than or equal to the bin's remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate their scores based on the Best Fit principle.\n    # Best Fit seeks to minimize the remaining space in the bin after placement.\n    #\n    # Let `C` be the current remaining capacity of a bin and `s` be the item size.\n    # The space remaining after placing the item would be `remaining_space = C - s`.\n    # To achieve Best Fit, we want to minimize `remaining_space`.\n    # In a priority function where higher score means higher priority, we need to convert\n    # minimizing `remaining_space` into maximizing a score.\n    # This can be done by maximizing `-(C - s)`, which simplifies to `s - C`.\n    #\n    # Example:\n    # - If `item = 0.3` and `bin_capacity = 0.3` (exact fit): Score = `0.3 - 0.3 = 0.0`\n    # - If `item = 0.3` and `bin_capacity = 0.4`: Score = `0.3 - 0.4 = -0.1`\n    # - If `item = 0.3` and `bin_capacity = 0.5`: Score = `0.3 - 0.5 = -0.2`\n    #\n    # In this scoring system, a perfect fit (remaining space 0) gets the highest score (0.0).\n    # Bins that leave more remaining space have increasingly negative scores, ensuring\n    # that the bin leading to the tightest fit (least remaining space) is chosen.\n    \n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n    scores_for_fitting_bins = item - fitting_bins_capacities\n\n    # Assign these calculated scores only to the bins that can fit the item.\n    # Other bins (where `can_fit_mask` is False) will retain their initial -np.inf priority.\n    priorities[can_fit_mask] = scores_for_fitting_bins\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a \"Best Fit\" strategy, giving highest priority\n    to bins that would have the smallest amount of remaining capacity after\n    the item is placed, assuming the item can fit. Bins that cannot fit\n    the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value. Bins that cannot fit\n    # the item will retain this low priority, ensuring they are not chosen.\n    # Using -np.inf ensures that any valid fit will have a higher priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Identify which bins can currently accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit, calculate the remaining capacity\n    # if the item were to be placed in them.\n    # We want to minimize this remaining capacity to achieve a \"best fit\".\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # To convert \"minimize remaining capacity\" into \"maximize priority score\":\n    # We assign the negative of the remaining capacity as the priority.\n    # A smaller positive remaining capacity (e.g., 2) will result in a larger\n    # (less negative) priority score (e.g., -2) compared to a larger\n    # remaining capacity (e.g., 7 resulting in -7).\n    # A perfect fit (0 remaining capacity) will result in a priority of 0,\n    # which is the highest possible score in this scheme.\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit (BF) strategy.\n\n    Bins where the item fits best (leaves the least remaining capacity) get the highest priority.\n    Bins where the item does not fit get a very low (negative infinity) priority to ensure\n    they are not chosen unless no other bin is available (implying a new bin would be opened).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity in each bin if the item were placed there.\n    # A smaller positive remainder signifies a \"tighter\" or \"better\" fit.\n    potential_leftover = bins_remain_cap - item\n\n    # Initialize priorities array. Bins where the item does not fit should have a\n    # very low priority (e.g., negative infinity) to exclude them from consideration.\n    # This also helps distinguish from valid bins that might have a low positive priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins the item can actually fit into (where leftover is non-negative).\n    fits_mask = potential_leftover >= 0\n\n    # For bins where the item fits, calculate the priority score.\n    # We want a higher priority for bins that leave less space (i.e., smaller positive `potential_leftover`).\n    # The reciprocal (1.0 / x) achieves this:\n    # - If `potential_leftover` is very small (near 0, an \"exact fit\"), 1.0 / (small_number) yields a very high priority.\n    # - If `potential_leftover` is large, 1.0 / (large_number) yields a small priority.\n    # A small epsilon is added to the denominator to prevent division by zero if an item fits exactly.\n    epsilon = 1e-9 \n    \n    # Apply the priority calculation only to the bins where the item fits.\n    priorities[fits_mask] = 1.0 / (potential_leftover[fits_mask] + epsilon)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on a Best-Fit-Decreasing inspired heuristic.\n\n    This heuristic prioritizes bins that, after placing the item, would have the smallest\n    remaining capacity. This strategy aims to 'fill up' bins as much as possible,\n    leaving minimal empty space, thereby reducing the need for new bins.\n    Bins where the item does not fit are assigned the lowest possible priority (-inf).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity in each bin if the current item were placed there.\n    potential_rem_cap = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item are given\n    # a very low priority (negative infinity) to ensure they are never chosen.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Create a boolean mask for bins where the item actually fits (i.e., potential_rem_cap >= 0).\n    can_fit_mask = potential_rem_cap >= 0\n\n    # For bins where the item fits, calculate the Best Fit priority.\n    # The Best Fit strategy aims to minimize the remaining space.\n    # To represent this as a priority score (where higher is better), we use the inverse\n    # of the remaining space. A smaller remaining space results in a larger inverse,\n    # thus a higher priority.\n    # We add a small epsilon to the denominator to prevent division by zero\n    # in cases where the item fits perfectly (potential_rem_cap is exactly 0).\n    epsilon = np.finfo(float).eps\n    priority_scores[can_fit_mask] = 1.0 / (potential_rem_cap[can_fit_mask] + epsilon)\n\n    return priority_scores",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]