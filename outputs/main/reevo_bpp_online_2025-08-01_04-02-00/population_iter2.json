[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This design implements a \"Best Fit\" like strategy: it prioritizes bins\n    that will have the smallest remaining capacity after the item is placed,\n    thus attempting to fill bins as tightly as possible.\n\n    Following the reflection, this version uses a simpler, linear transformation\n    (-remaining_capacity) for priority scores, avoiding non-linear functions\n    that might exaggerate small differences, thereby improving robustness and interpretability.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins where the item does not\n        fit are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A smaller 'remaining_after_placement' value indicates a tighter fit.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity.\n    # This ensures that bins where the item does not fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item can actually fit (remaining capacity >= 0)\n    can_fit_mask = remaining_after_placement >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # To implement \"Best Fit\" where we want to minimize the remaining capacity,\n    # we take the negative of `remaining_after_placement`.\n    # This is a linear transformation. A smaller positive `remaining_after_placement`\n    # (e.g., 0 for a perfect fit) will result in a priority score closer to 0 (the highest possible).\n    # For example:\n    #   - If remaining_after_placement is 0 (perfect fit), priority is 0.\n    #   - If remaining_after_placement is 5, priority is -5.\n    # Maximizing this priority score will naturally select the bin with the smallest\n    # non-negative `remaining_after_placement`.\n    priorities[can_fit_mask] = -remaining_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin,\n    implementing a Best Fit strategy using linear scaling for priority scores.\n\n    This heuristic prioritizes bins that, after placing the item, would have\n    the smallest remaining capacity. To achieve this, it assigns a priority\n    score that is the negative of the remaining capacity. A smaller positive\n    remaining capacity (closer to zero) results in a higher (less negative)\n    priority score, with a perfect fit yielding a score of 0.\n\n    Bins where the item does not fit are assigned the lowest possible priority (-inf).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value (-np.inf).\n    # This ensures that bins incapable of fitting the item will not be selected,\n    # as any valid fit will yield a higher priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Identify which bins have sufficient remaining capacity to accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit, calculate the remaining capacity\n    # if the item were placed there. This is the value we want to minimize for Best Fit.\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority scores using a linear scale: the negative of the\n    # remaining capacity.\n    # This approach correctly converts the goal of minimizing remaining capacity\n    # into maximizing the priority score. A smaller `remaining_after_placement`\n    # (e.g., 0 for a perfect fit) results in a higher (less negative) priority (0),\n    # while a larger `remaining_after_placement` results in a lower (more negative) priority.\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit (BF) strategy.\n\n    Bins where the item fits best (leaves the least remaining capacity) get the highest priority.\n    Bins where the item does not fit get a very low (negative infinity) priority to ensure\n    they are not chosen unless no other bin is available (implying a new bin would be opened).\n\n    This version carefully chooses epsilon for numerical stability, preventing\n    over-differentiation for extremely small remaining capacities and improving robustness.\n    By using a slightly larger epsilon compared to machine epsilon or 1e-9, the\n    priority values are kept within a more manageable range, smoothing out the\n    extreme preference for infinitesimal differences in remaining capacity,\n    without altering the core Best Fit principle.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity in each bin if the item were placed there.\n    # A smaller positive remainder signifies a \"tighter\" or \"better\" fit.\n    potential_leftover = bins_remain_cap - item\n\n    # Initialize priorities array. Bins where the item does not fit should have a\n    # very low priority (e.g., negative infinity) to exclude them from consideration.\n    # This also helps distinguish from valid bins that might have a low positive priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins the item can actually fit into (where leftover is non-negative).\n    fits_mask = potential_leftover >= 0\n\n    # For bins where the item fits, calculate the priority score.\n    # We want a higher priority for bins that leave less space (i.e., smaller positive `potential_leftover`).\n    # The reciprocal (1.0 / x) achieves this.\n    # A small epsilon is added to the denominator to prevent division by zero if an item fits exactly.\n    # Choosing epsilon = 1e-6 aims to prevent excessively large priority values for extremely\n    # small (but non-zero) remainders. This dampens \"over-differentiation\" among\n    # near-perfect fits and improves numerical stability/robustness in scenarios\n    # where such extremely large values might cause issues in downstream calculations,\n    # while still giving clear preference to best fits.\n    epsilon = 1e-6 # A balanced choice for numerical stability and priority magnitude.\n    \n    # Apply the priority calculation only to the bins where the item fits.\n    priorities[fits_mask] = 1.0 / (potential_leftover[fits_mask] + epsilon)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy. This version adheres to the\n    principle of using linear priority transformations for robustness,\n    as recommended by the reflection.\n\n    The heuristic aims to minimize the unused space within a bin after\n    the item is placed. Bins that can fit the item and leave the least\n    remaining capacity will have higher priority. Bins that cannot fit\n    the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that\n    # bins that cannot fit the item will never be chosen, as their\n    # priority will remain at this extremely low value.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the \"wastage\" or\n    # the remaining space after the item is placed. The Best Fit strategy\n    # seeks to minimize this wastage.\n    wastage = bins_remain_cap[can_fit_mask] - item\n\n    # To transform this into a priority score where higher is better,\n    # we use the negative of the wastage. This is a linear transformation\n    # (y = -x) which directly reflects the magnitude of wastage without\n    # exaggerating small differences. For example, a smaller positive\n    # wastage value (e.g., 0.1) results in a larger priority score (-0.1)\n    # compared to a larger wastage value (e.g., 0.5) which results in -0.5.\n    # This aligns with the reflection's guidance for robustness.\n    priorities[can_fit_mask] = -wastage\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy.\n\n    This heuristic adheres to the principle of \"simple, direct waste minimization\"\n    using a linear priority function. It aims to minimize the unused space within\n    a bin after the item is placed. Bins that can fit the item and leave the\n    least remaining capacity will receive a higher priority.\n\n    The priority score is calculated as the negative of the remaining space (wastage)\n    if the item were placed in the bin. This linear transformation means:\n    - A smaller positive wastage (e.g., 0.1) results in a priority closer to zero (-0.1).\n    - A larger positive wastage (e.g., 0.5) results in a more negative priority (-0.5).\n    Bins where the item does not fit are assigned the lowest possible priority (-inf)\n    to ensure they are never selected.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This serves as a baseline\n    # for bins that cannot accommodate the item, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit, calculate the \"wastage\" \u2013 the amount\n    # of remaining capacity after placing the item. The Best Fit strategy aims\n    # to minimize this wastage.\n    wastage = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority scores to the bins that can fit the item.\n    # By taking the negative of the wastage, we ensure that:\n    # - A perfect fit (0 wastage) yields the highest priority (0).\n    # - Small wastages yield priorities closer to 0 (less negative).\n    # - Larger wastages yield more negative priorities.\n    # This directly implements the \"Best Fit\" goal with a simple, linear priority scale.\n    priorities[can_fit_mask] = -wastage\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy. This heuristic aims to minimize\n    the unused space within a bin after the item is placed. Bins that can\n    fit the item and leave the least remaining capacity will have higher\n    priority. Bins that cannot fit the item are given a very low priority.\n\n    This function adheres to using a direct, linear objective function for\n    priority calculation, avoiding complex non-linear transformations that\n    would disproportionately scale priorities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that\n    # bins that cannot fit the item will never be chosen, as their\n    # priority will remain at this extremely low value.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the \"wastage\" or\n    # the remaining space after the item is placed. The Best Fit strategy\n    # seeks to minimize this wastage.\n    # To transform this into a priority score where higher is better,\n    # we take the negative of the wastage. This transformation is linear\n    # and directly reflects the objective (minimize wastage by maximizing\n    # its negative value), without disproportionate scaling.\n    wastage = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -wastage\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin,\n    implementing a \"Best Fit\" strategy with a linear priority score.\n\n    This heuristic prioritizes bins that, after placing the item, would have the\n    smallest remaining capacity. This encourages filling bins as tightly as possible\n    to minimize the total number of bins used.\n\n    Priority calculation:\n    - For bins where the item does not fit, a very low priority (-infinity) is assigned.\n    - For bins where the item fits, the priority is calculated as the negative\n      of the remaining capacity *after* the item is placed.\n      A smaller positive remaining capacity (tighter fit, e.g., 0.1) results in a\n      higher priority score (closer to zero, e.g., -0.1) compared to a larger\n      remaining capacity (e.g., 0.5 -> -0.5). This linear mapping directly\n      reflects the 'best fit' principle where minimizing remaining space is desired.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with the priority score for each bin.\n    \"\"\"\n    # Initialize priorities to a very low value for bins that cannot fit the item.\n    # Using -np.inf ensures these bins will never be chosen unless no other bin fits.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the current item.\n    # An item can fit if its size is less than or equal to the bin's remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity if the item were placed.\n    # This is (current_remaining_capacity - item_size).\n    remaining_space_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities based on the Best Fit principle using a linear mapping.\n    # We want to minimize 'remaining_space_after_placement'.\n    # To convert this to a maximization problem (where the highest priority wins),\n    # we use the negative of 'remaining_space_after_placement'.\n    # This correctly assigns higher priority to bins that result in less empty space.\n    priorities[can_fit_mask] = -remaining_space_after_placement\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns a priority score for each bin based on a Best Fit strategy,\n    prioritizing simpler and numerically robust computation.\n\n    This function implements a \"Best Fit\" heuristic: it assigns higher priority\n    to bins that, after placing the item, would have the smallest remaining capacity.\n    This strategy aims to fill bins as tightly as possible to minimize wasted space\n    and the overall number of bins used.\n\n    The priority is calculated by directly mapping the minimization goal (smallest\n    remaining capacity) to a maximization score: the negative of the remaining capacity.\n    This approach is numerically robust as it avoids division and complex operations,\n    relying only on subtraction and negation.\n\n    Args:\n        item: Size of the item to be placed into a bin.\n        bins_remain_cap: A NumPy array containing the current remaining capacity of each bin.\n\n    Returns:\n        A NumPy array of the same size as `bins_remain_cap`, where each element\n        represents the priority score for the corresponding bin. A higher score\n        indicates a higher priority for selection. Bins where the item does not fit\n        are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the hypothetical remaining capacity for each bin if the item were placed.\n    # A smaller positive value here indicates a tighter fit, which is desirable.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize all priority scores to negative infinity. This ensures that\n    # bins where the item cannot fit are naturally assigned the lowest possible\n    # priority and will not be selected unless no valid fit exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify only those bins where the item can actually fit.\n    can_fit_mask = remaining_after_placement >= 0\n\n    # For the bins where the item fits, calculate the priority score.\n    # To implement \"Best Fit\" (minimize `remaining_after_placement`), we take its\n    # negative. This means:\n    # - A perfect fit (0 remaining) gets a priority of 0.\n    # - A small positive remaining (e.g., 2) gets a priority of -2.\n    # - A larger positive remaining (e.g., 5) gets a priority of -5.\n    # Maximizing this priority score will correctly select the bin with the\n    # smallest non-negative remaining capacity, which aligns with the Best Fit strategy.\n    priorities[can_fit_mask] = -remaining_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit (BF) strategy. This heuristic aims to minimize\n    the unused space within a bin after the item is placed. Bins that can\n    fit the item and leave the least remaining capacity will have higher\n    priority. Bins that cannot fit the item are given a very low priority.\n\n    This version specifically adheres to preferring linear priority mappings\n    (e.g., -cost) over non-linear ones, as identified in the reflection.\n    Minimizing wastage is achieved by maximizing its negative value.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that\n    # bins that cannot fit the item will never be chosen, as their\n    # priority will remain at this extremely low value.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the \"wastage\" or\n    # the remaining space after the item is placed. The Best Fit strategy\n    # seeks to minimize this wastage.\n    # To transform this into a priority score where higher is better,\n    # we take the negative of the wastage. This represents a linear\n    # mapping where a smaller positive wastage (cost) results in a\n    # larger (less negative) priority score.\n    wastage = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -wastage\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit\n    approach. This implementation adheres to the principle of using simple, direct,\n    and linear transformations for robust heuristic design.\n\n    Bins that cannot fit the item receive a very low (negative infinity) priority.\n    For bins where the item fits, the priority is determined by minimizing the\n    remaining capacity. To achieve this as a maximization problem (where higher\n    priority is better), we use the negative of the potential remaining capacity.\n    This linear transformation ensures that smaller remaining capacities result\n    in higher, more positive (or less negative) priority scores.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value. This ensures that bins where\n    # the item does not fit will automatically have the lowest priority and\n    # will not be selected. Using float32 for potential memory efficiency if needed.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float32)\n\n    # Identify which bins have sufficient remaining capacity to accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity in each bin if the current item were placed there.\n    # This calculation is performed for all bins, but only relevant for those where\n    # the item actually fits.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # For bins where the item fits, apply the Best Fit strategy.\n    # The Best Fit strategy aims to minimize the remaining empty space in a bin\n    # after an item is placed. To convert this minimization objective into a\n    # maximization objective (which the priority function seeks), we take the\n    # negative of the potential remaining capacity.\n    # A smaller positive remaining capacity (e.g., 0.1) will result in a\n    # higher priority score (-0.1) compared to a larger positive remaining\n    # capacity (e.g., 10.0) which results in a lower priority score (-10.0).\n    # A perfect fit (0.0 remaining capacity) yields the highest possible score of 0.0\n    # among fitting bins. This is a direct and linear transformation of the objective.\n    priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]