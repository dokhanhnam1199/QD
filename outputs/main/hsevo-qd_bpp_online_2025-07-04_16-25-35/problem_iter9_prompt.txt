{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines capacity, waste, fragmentation, and empty bin considerations.\"\"\"\n\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Sufficient capacity boost\n    sufficient_capacity = bins_remain_cap >= item\n    priority[sufficient_capacity] += 1.8 #Sufficient cap weight\n\n    # Minimize waste boost\n    waste = bins_remain_cap - item\n    positive_waste = waste[waste >= 0]\n    if len(positive_waste) > 0:\n        min_waste = np.min(positive_waste)\n        min_waste_bins_idx = np.where(waste == min_waste)[0]\n        priority[min_waste_bins_idx] += 1.2  #Min waste weight\n\n    # Nearly full bin boost\n    nearly_full = (bins_remain_cap > 0.0) & (bins_remain_cap <= 1.1 * item) & (bins_remain_cap >= item) #threshold multiplier = 1.1\n    priority[nearly_full] += 2.4 #Nearly full weight\n\n    #Small capacity based on relative availability\n    small_cap = (bins_remain_cap >= item)\n    priority[small_cap] += (bins_remain_cap[small_cap] - item) / np.max(bins_remain_cap)\n\n    #Emptiness boost\n    is_empty = bins_remain_cap == np.max(bins_remain_cap)\n    priority[is_empty] += 0.7 #Empty bins weight\n\n    return priority\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, I'll help you refine \"Current self-reflection\" to make it more effective for designing better heuristics. Here's a redefined approach, focusing on actionable steps and avoiding pitfalls:\n\n*   **Keywords:** Mechanism, Rationale, Adaptation, Evaluation.\n\n*   **Advice:** Instead of just \"tuning weights,\" focus on understanding the *mechanism* by which each factor influences the outcome. Define a *rationale* for why these factors are important *before* optimization. Build in *adaptation* mechanisms to adjust to changing conditions. Rigorously *evaluate* performance across diverse problem instances.\n\n*   **Avoid:** Blindly combining factors without understanding their interaction. Treating weight tuning as a magical solution. Ignoring the underlying problem structure. Overfitting to specific data.\n\n*   **Explanation:** Effective heuristic design requires a deep understanding of the problem and the factors influencing the solution. Focus on building heuristics with clear rationales, adaptable mechanisms, and robust evaluation, rather than simply tweaking weights.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}