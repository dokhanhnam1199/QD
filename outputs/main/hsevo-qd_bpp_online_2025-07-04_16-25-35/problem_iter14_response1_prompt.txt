{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines capacity, waste, fragmentation, and empty bin considerations.\"\"\"\n\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Sufficient capacity boost\n    sufficient_capacity = bins_remain_cap >= item\n    priority[sufficient_capacity] += 1.8 #Sufficient cap weight\n\n    # Minimize waste boost\n    waste = bins_remain_cap - item\n    positive_waste = waste[waste >= 0]\n    if len(positive_waste) > 0:\n        min_waste = np.min(positive_waste)\n        min_waste_bins_idx = np.where(waste == min_waste)[0]\n        priority[min_waste_bins_idx] += 1.2  #Min waste weight\n\n    # Nearly full bin boost\n    nearly_full = (bins_remain_cap > 0.0) & (bins_remain_cap <= 1.1 * item) & (bins_remain_cap >= item) #threshold multiplier = 1.1\n    priority[nearly_full] += 2.4 #Nearly full weight\n\n    #Small capacity based on relative availability\n    small_cap = (bins_remain_cap >= item)\n    priority[small_cap] += (bins_remain_cap[small_cap] - item) / np.max(bins_remain_cap)\n\n    #Emptiness boost\n    is_empty = bins_remain_cap == np.max(bins_remain_cap)\n    priority[is_empty] += 0.7 #Empty bins weight\n\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines capacity ratios with waste minimization for bin prioritization.\"\"\"\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Sufficient Capacity\n    sufficient_capacity = bins_remain_cap >= item\n    priority[sufficient_capacity] += 1\n\n    # Heuristic 2: Minimize Waste (Only for bins with sufficient capacity)\n    waste = bins_remain_cap - item\n    min_waste = np.min(waste[sufficient_capacity]) if np.any(sufficient_capacity) else np.inf\n    min_waste_bins_idx = np.where((waste == min_waste) & sufficient_capacity)[0]\n    priority[min_waste_bins_idx] += 2\n\n    # Heuristic 3: Capacity Ratio (Only for bins with sufficient capacity)\n    ratios = item / bins_remain_cap\n    ratios[~sufficient_capacity] = 0  # Ignore bins without sufficient capacity\n    priority += ratios\n\n    return priority\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic considers sufficient capacity, waste minimization, fragmentation avoidance (nearly full bins), small capacity handling, and empty bin prioritization, using carefully chosen weights. The worst heuristic only considers the ratio of item size to remaining capacity in bins, using a log transformation.\n\nComparing (4th) vs (5th), these heuristics are identical.\n\nComparing (6th) vs (8th), these heuristics are identical.\n\nComparing (9th) vs (11th), these heuristics are identical.\n\nComparing (12th) vs (13th), these heuristics are identical.\n\nComparing (14th) vs (16th), these heuristics are identical.\n\nComparing (15th) vs (17th), these heuristics are identical.\n\nComparing (second worst) vs (worst), we see the second worst use `ratios = item / bins_remain_cap` and `log_ratios = np.log(ratios)` calculate simple ratio and log ratio, while the worst do the same.\n\nOverall: The best heuristics incorporate multiple factors with weighted priorities, including capacity, waste, fragmentation, and bin utilization. They often include dynamic adjustments based on item size or bin state. Simpler heuristics that only consider capacity ratios or log ratios perform poorly. Penalizing bins that are close to full but cannot fit the item and rewarding global bin utilization are advanced strategies that improve performance. Giving tunable parameters is beneficial.\n- \nOkay, let's redefine \"Current Self-Reflection\" for designing better heuristics, focusing on actionable advice and avoiding the pitfalls of ineffective approaches.\n\nHere's a refined perspective:\n\n*   **Keywords:** Adaptive, Experimentation, Evaluation, Refinement.\n*   **Advice:** Systematically experiment with different factor combinations and weighting schemes. Continuously evaluate heuristic performance on diverse problem instances. Adapt the heuristic based on observed performance patterns.\n*   **Avoid:** Vague statements about \"importance,\" premature optimization, and lack of rigorous testing.\n*   **Explanation:** Move beyond intuition. Focus on iterative improvement through data-driven insights. Don't over-optimize early. Experiment, measure, adapt.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}