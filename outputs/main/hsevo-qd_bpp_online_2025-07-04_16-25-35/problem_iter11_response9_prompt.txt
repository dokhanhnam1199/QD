{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines capacity, waste, fragmentation, and empty bin considerations with dynamic adjustments.\"\"\"\n\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Sufficient Capacity Boost with Item Size Consideration\n    sufficient_capacity = bins_remain_cap >= item\n    priority[sufficient_capacity] += 1.8\n\n    # 2. Minimize Waste Boost with Adaptive Waste Threshold\n    waste = bins_remain_cap - item\n    positive_waste = waste[waste >= 0]\n\n    if len(positive_waste) > 0:\n        min_waste = np.min(positive_waste)\n        min_waste_bins_idx = np.where(waste == min_waste)[0]\n        priority[min_waste_bins_idx] += 1.2\n\n        #Adaptive waste threshold based on the item size\n        adaptive_waste_threshold = 0.2 * item\n        small_waste_bins = (waste >= 0) & (waste <= adaptive_waste_threshold)\n        priority[small_waste_bins] += 0.6 # Added small waste weight\n\n    # 3. Nearly Full Bin Boost with Dynamic Threshold\n    nearly_full_threshold = 1.1 # Initial threshold\n    nearly_full = (bins_remain_cap > 0.0) & (bins_remain_cap <= nearly_full_threshold * item) & (bins_remain_cap >= item)\n    priority[nearly_full] += 2.4\n\n    # 4. Small Capacity Based on Relative Availability (Normalized)\n    sufficient_bins = bins_remain_cap >= item\n    if np.any(sufficient_bins):\n        max_remaining_cap = np.max(bins_remain_cap[sufficient_bins])\n        priority[sufficient_bins] += (bins_remain_cap[sufficient_bins] - item) / max_remaining_cap #Normalizing\n    \n    # 5. Empty Bin Consideration with bin utilization\n    is_empty = bins_remain_cap == np.max(bins_remain_cap)\n    priority[is_empty] += 0.7\n\n    #6. Penalize bins close to full but can't fit the item\n\n    cannot_fit = (bins_remain_cap < item) & (bins_remain_cap > 0)\n    priority[cannot_fit] -= 0.5\n\n    #7. Reward higher bin utilization globally (Encourage packing)\n\n    total_capacity = np.sum(bins_remain_cap)\n    bin_utilization_score = (num_bins - (total_capacity/np.max(bins_remain_cap)))/num_bins #Scale between 0 and 1\n    priority += 0.2 * bin_utilization_score\n\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                  sufficient_capacity_weight: float = 1.8066941616372154,\n                  min_waste_weight: float = 1.2369759055947915,\n                  nearly_full_threshold_multiplier: float = 1.164912650607926,\n                  nearly_full_weight: float = 2.4304538888032448,\n                  empty_bin_weight: float = 0.7700931706376539,\n                  waste_capacity_ratio_weight: float = 0.5,\n                  bin_utilization_weight: float = 1.0) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        sufficient_capacity_weight: Weight for bins with sufficient capacity.\n        min_waste_weight: Weight for bins that minimize waste.\n        nearly_full_threshold_multiplier: Multiplier for item size to determine nearly full threshold.\n        nearly_full_weight: Weight for bins that are nearly full.\n        empty_bin_weight: Weight for empty bins.\n        waste_capacity_ratio_weight: Weight for the ratio of waste to bin capacity\n        bin_utilization_weight: Weight for the current bin utilization\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bin_capacity = np.max(bins_remain_cap)\n    # Heuristic 1: Sufficient Capacity\n    sufficient_capacity = bins_remain_cap >= item\n    priority = np.zeros_like(bins_remain_cap, dtype=float)\n    priority[sufficient_capacity] += sufficient_capacity_weight  # Base priority if bin can fit item\n\n    # Heuristic 2: Minimize Waste (Maximize filled space).\n    waste = bins_remain_cap - item\n    positive_waste = waste[waste >= 0] # Consider only valid waste\n    if len(positive_waste) > 0:\n        min_waste = np.min(positive_waste)\n        min_waste_bins_idx = np.where(waste == min_waste)[0]\n        priority[min_waste_bins_idx] += min_waste_weight\n\n    # Heuristic 3: Prevent Fragmentation (Bins near full have high priority).\n    nearly_full = (bins_remain_cap > 0.0) & (bins_remain_cap <= nearly_full_threshold_multiplier * item) & (bins_remain_cap >= item)\n    priority[nearly_full] += nearly_full_weight\n\n    # Heuristic 4: Small amount of available capacity and weight by normalized waste\n    sufficient_bins = bins_remain_cap >= item\n    if np.any(sufficient_bins):\n        waste_ratios = waste[sufficient_bins] / bin_capacity\n        priority[sufficient_bins] += waste_capacity_ratio_weight * (1 - waste_ratios)\n    \n    # Heuristic 5: Give higher preference if it is an empty bin.\n    is_empty = bins_remain_cap == bin_capacity\n    priority[is_empty] += empty_bin_weight\n\n    # Heuristic 6: Bin Utilization\n    bin_utilization = (bin_capacity - bins_remain_cap) / bin_capacity\n    priority += bin_utilization_weight * bin_utilization\n\n    return priority\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic considers sufficient capacity, waste minimization, nearly full bins, small capacity, and emptiness, assigning specific weights to each factor. The worst only calculates a priority based on the log of the ratio of item size to remaining capacity, thus lacks crucial considerations such as fragmentation and waste.\nComparing (2nd best) vs (second worst), they are similar to (best) vs (worst).\nComparing (1st) vs (2nd), we see that they are identical, indicating that their performance is likely indistinguishable.\nComparing (3rd) vs (4th), again, both are identical.\nComparing (second worst) vs (worst), both only use ratio of item/bin capacity but second worst use log while worst doesn't.\nOverall: The better heuristics incorporate more features related to bin packing such as waste, nearly full status, and emptiness. Also, better heuristics include weight hyperparameter tuning. Simpler heuristics solely rely on capacity ratios and can be less effective because they ignore key aspects of bin packing that affect performance. Adaptive thresholds or utilization scores also seem beneficial.\n- \nOkay, I understand the goal: to refine the concept of \"Current self-reflection\" for heuristic design, steering clear of the pitfalls outlined in \"Ineffective self-reflection,\" to guide the creation of truly effective heuristics.\n\nHere's a revised approach:\n\n*   **Keywords:** Adaptive, Domain-Specific, Trade-offs, Evaluation.\n*   **Advice:** Design heuristics that *adapt* to specific domain characteristics and problem instance features. Explicitly model and manage *trade-offs* between competing objectives. Rigorously *evaluate* performance across a diverse set of instances.\n*   **Avoid:** Blindly combining factors and tuning weights without understanding the *underlying problem structure*. Avoid assuming complexity guarantees better performance.\n*   **Explanation:** Instead of just adding factors, *understand* their interactions and create rules that are meaningful to problem at hand.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}