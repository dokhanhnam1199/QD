[
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity slightly larger than the item and penalizing those that would lead to significant waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity slightly larger than the item and penalizing those that would lead to significant waste.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste == 0:\n                priority.append(1000)  # Perfect fit\n            else:\n                priority.append(1.0 / (waste + 0.001))  # Inverse of waste, avoiding division by zero\n        else:\n            priority.append(-1)  # Item doesn't fit\n\n    return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the absolute difference between the remaining capacity and the item size after packing, favoring bins where the resulting remaining capacity is close to a target value.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the absolute difference between the remaining capacity and the item size after packing, favoring bins where the resulting remaining capacity is close to a target value.}\"\"\"\n  priority = []\n  target_capacity = 0.5  # Target remaining capacity after placing the item\n  for cap in bins_remain_cap:\n    if cap >= item:\n      new_cap = cap - item\n      priority.append(-abs(new_cap - target_capacity))  # Minimize the difference from the target\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 4.11847,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, preferring bins with higher utilization and avoiding bins that would become nearly full or nearly empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, preferring bins with higher utilization and avoiding bins that would become nearly full or nearly empty.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      new_cap = cap - item\n      if new_cap == 0:\n        priority.append(1000) # Prefer bins that become full\n      elif new_cap < 0.1:  #Avoid almost full\n         priority.append(-100)\n      elif new_cap > 0.9: # Avoid almost empty bins\n         priority.append(-100)\n      else:\n        priority.append(1.0 / new_cap) # Prefer higher utilization\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 4.19824,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin for an item based on a combination of remaining capacity and fill percentage, favoring bins that are neither too full nor too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin for an item based on a combination of remaining capacity and fill percentage, favoring bins that are neither too full nor too empty.}\"\"\"\n    priorities = []\n    bin_capacity = 1 # Assuming bin capacity is 1\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fill_percentage = (bin_capacity - cap + item) / bin_capacity\n            priority = (item/cap) * (1 - abs(fill_percentage-0.5)) #Prioritize more filled and less empty bins\n        else:\n            priority = -1\n        priorities.append(priority)\n    return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins with remaining capacity closest to a target fill level, with a penalty for bins that would be excessively full or empty after packing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins with remaining capacity closest to a target fill level, with a penalty for bins that would be excessively full or empty after packing the item.}\"\"\"\n  priority = []\n  target_fill = 0.75  # Aim for bins to be 75% full\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining = cap - item\n      fill_level = 1 - (remaining / 1) # Assuming bin capacity is 1\n      diff_from_target = abs(fill_level - target_fill)\n      priority_score = -diff_from_target  # Prioritize bins closest to target fill\n\n      if fill_level > 0.95:\n        priority_score -= 5  # Penalty for bins that would become almost full\n      elif fill_level < 0.25:\n          priority_score -=2 # Penalty for bins that are too empty\n\n      priority.append(priority_score)\n    else:\n      priority.append(-100000)  # Extremely low priority if item does not fit\n  return priority",
          "objective": 4.58716,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins by rewarding bins that can accommodate the item and penalizing bins nearing full capacity, favoring even distribution.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins by rewarding bins that can accommodate the item and penalizing bins nearing full capacity, favoring even distribution.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining = cap - item\n      priority_score = 1 / (1 + abs(0.5 - remaining)) # Reward values near 0.5\n      if remaining < 0.2:\n        priority_score -= 5  # Penalize almost full\n      priority.append(priority_score)\n    else:\n      priority.append(-1000)\n  return priority",
          "objective": 5.19545,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how well the item fills the bin, penalizing both near-empty and near-full bins.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how well the item fills the bin, penalizing both near-empty and near-full bins.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_ratio = item / cap  # Ratio of item size to remaining capacity\n      # Prioritize bins that are well-filled, but penalize near-full bins. Penalize also if bin is not filled enough.\n      if fill_ratio > 0.95:\n        priority.append(-100 * (fill_ratio - 0.95)) # penalty for bins almost full\n      elif fill_ratio < 0.2:\n        priority.append(-50 * (0.2 - fill_ratio)) # penalty for bins not filled enough\n      else:\n        priority.append(fill_ratio)\n    else:\n      priority.append(-100000)  # extremely low priority if item does not fit\n      \n  return priority",
          "objective": 6.2126,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how well the item size matches the remaining capacity, rewarding bins where the item fills a significant portion of the remaining space but doesn't overfill.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how well the item size matches the remaining capacity, rewarding bins where the item fills a significant portion of the remaining space but doesn't overfill.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      utilization = item / cap\n      if 0.2 <= utilization <= 0.95:  # Reward significant but not excessive utilization\n        priority.append(utilization)\n      else:\n        priority.append(-10)  # Penalize poor utilization\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 6.22258,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the absolute difference between the item size and a target percentage of the remaining capacity, favoring bins where the item size closely matches the target capacity utilization.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the absolute difference between the item size and a target percentage of the remaining capacity, favoring bins where the item size closely matches the target capacity utilization.}\"\"\"\n  priority = []\n  target_utilization = 0.75  # Aim for 75% utilization\n  for cap in bins_remain_cap:\n    if cap >= item:\n      utilization = item / cap\n      difference = abs(utilization - target_utilization)\n      priority.append(-difference)  # Lower difference means higher priority\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 7.94775,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity close to the item size and penalizing those with too little or too much remaining space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity close to the item size and penalizing those with too little or too much remaining space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priority.append(100.0 / (abs(cap - 1.5 * item) + 0.001)) # Prioritize bins close to item size\n        else:\n            priority.append(-1)  # Item doesn't fit\n\n    return priority",
          "objective": 9.25409,
          "other_inf": null
     }
]