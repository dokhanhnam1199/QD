[
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity slightly larger than the item and penalizing those that would lead to significant waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity slightly larger than the item and penalizing those that would lead to significant waste.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste == 0:\n                priority.append(1000)  # Perfect fit\n            else:\n                priority.append(1.0 / (waste + 0.001))  # Inverse of waste, avoiding division by zero\n        else:\n            priority.append(-1)  # Item doesn't fit\n\n    return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, preferring bins with higher utilization and avoiding bins that would become nearly full or nearly empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, preferring bins with higher utilization and avoiding bins that would become nearly full or nearly empty.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      new_cap = cap - item\n      if new_cap == 0:\n        priority.append(1000) # Prefer bins that become full\n      elif new_cap < 0.1:  #Avoid almost full\n         priority.append(-100)\n      elif new_cap > 0.9: # Avoid almost empty bins\n         priority.append(-100)\n      else:\n        priority.append(1.0 / new_cap) # Prefer higher utilization\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 4.19824,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin for an item based on a combination of remaining capacity and fill percentage, favoring bins that are neither too full nor too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin for an item based on a combination of remaining capacity and fill percentage, favoring bins that are neither too full nor too empty.}\"\"\"\n    priorities = []\n    bin_capacity = 1 # Assuming bin capacity is 1\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fill_percentage = (bin_capacity - cap + item) / bin_capacity\n            priority = (item/cap) * (1 - abs(fill_percentage-0.5)) #Prioritize more filled and less empty bins\n        else:\n            priority = -1\n        priorities.append(priority)\n    return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates priority scores for bins based on a combination of remaining capacity and a bonus for bins that can perfectly fit the item, then returns the priority scores.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates priority scores for bins based on a combination of remaining capacity and a bonus for bins that can perfectly fit the item, then returns the priority scores.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      if cap == item:\n        priority.append(cap * 2)  # perfect fit bonus\n      else:\n        priority.append(cap)\n    else:\n      priority.append(-1)  # Invalid bin\n  return priority",
          "objective": 88.08337,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity, item size, and a penalty for bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"\n  {This algorithm prioritizes bins based on a combination of remaining capacity, item size, and a penalty for bins that are too full or too empty.}\n  \"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority.append(cap - item) # prioritize bins with smaller remaining space after item is placed\n    else:\n      priority.append(-100000)  # extremely low priority if item does not fit\n      \n  return priority",
          "objective": 149.30195,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on the remaining capacity and item size, favoring bins with capacity slightly larger than the item, and penalizing bins that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on the remaining capacity and item size, favoring bins with capacity slightly larger than the item, and penalizing bins that are too full or too empty.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            # Prioritize bins where the item fits reasonably well, but not too tightly or loosely.\n            priority_score = (cap - item) / (cap + item)\n            priority.append(priority_score)\n        else:\n            priority.append(-1) # Item doesn't fit\n    return priority",
          "objective": Infinity,
          "other_inf": null
     }
]