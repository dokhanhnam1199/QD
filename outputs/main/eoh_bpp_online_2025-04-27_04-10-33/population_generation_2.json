[
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity slightly larger than the item and penalizing those that would lead to significant waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity slightly larger than the item and penalizing those that would lead to significant waste.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            if waste == 0:\n                priority.append(1000)  # Perfect fit\n            else:\n                priority.append(1.0 / (waste + 0.001))  # Inverse of waste, avoiding division by zero\n        else:\n            priority.append(-1)  # Item doesn't fit\n\n    return priority",
          "objective": 4.04866,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the absolute difference between the remaining capacity and the item size after packing, favoring bins where the resulting remaining capacity is close to a target value.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the absolute difference between the remaining capacity and the item size after packing, favoring bins where the resulting remaining capacity is close to a target value.}\"\"\"\n  priority = []\n  target_capacity = 0.5  # Target remaining capacity after placing the item\n  for cap in bins_remain_cap:\n    if cap >= item:\n      new_cap = cap - item\n      priority.append(-abs(new_cap - target_capacity))  # Minimize the difference from the target\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 4.11847,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, preferring bins with higher utilization and avoiding bins that would become nearly full or nearly empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, preferring bins with higher utilization and avoiding bins that would become nearly full or nearly empty.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      new_cap = cap - item\n      if new_cap == 0:\n        priority.append(1000) # Prefer bins that become full\n      elif new_cap < 0.1:  #Avoid almost full\n         priority.append(-100)\n      elif new_cap > 0.9: # Avoid almost empty bins\n         priority.append(-100)\n      else:\n        priority.append(1.0 / new_cap) # Prefer higher utilization\n    else:\n      priority.append(-float('inf'))\n  return priority",
          "objective": 4.19824,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin for an item based on a combination of remaining capacity and fill percentage, favoring bins that are neither too full nor too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin for an item based on a combination of remaining capacity and fill percentage, favoring bins that are neither too full nor too empty.}\"\"\"\n    priorities = []\n    bin_capacity = 1 # Assuming bin capacity is 1\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fill_percentage = (bin_capacity - cap + item) / bin_capacity\n            priority = (item/cap) * (1 - abs(fill_percentage-0.5)) #Prioritize more filled and less empty bins\n        else:\n            priority = -1\n        priorities.append(priority)\n    return priority",
          "objective": 4.48744,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins by rewarding bins that can accommodate the item and penalizing bins nearing full capacity, favoring even distribution.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins by rewarding bins that can accommodate the item and penalizing bins nearing full capacity, favoring even distribution.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining = cap - item\n      priority_score = 1 / (1 + abs(0.5 - remaining)) # Reward values near 0.5\n      if remaining < 0.2:\n        priority_score -= 5  # Penalize almost full\n      priority.append(priority_score)\n    else:\n      priority.append(-1000)\n  return priority",
          "objective": 5.19545,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how well the item fills the bin, penalizing both near-empty and near-full bins.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how well the item fills the bin, penalizing both near-empty and near-full bins.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_ratio = item / cap  # Ratio of item size to remaining capacity\n      # Prioritize bins that are well-filled, but penalize near-full bins. Penalize also if bin is not filled enough.\n      if fill_ratio > 0.95:\n        priority.append(-100 * (fill_ratio - 0.95)) # penalty for bins almost full\n      elif fill_ratio < 0.2:\n        priority.append(-50 * (0.2 - fill_ratio)) # penalty for bins not filled enough\n      else:\n        priority.append(fill_ratio)\n    else:\n      priority.append(-100000)  # extremely low priority if item does not fit\n      \n  return priority",
          "objective": 6.2126,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity close to the item size and penalizing those with too little or too much remaining space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin based on a combination of remaining capacity and the waste after packing the item, favoring bins with capacity close to the item size and penalizing those with too little or too much remaining space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priority.append(100.0 / (abs(cap - 1.5 * item) + 0.001)) # Prioritize bins close to item size\n        else:\n            priority.append(-1)  # Item doesn't fit\n\n    return priority",
          "objective": 9.25409,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on how closely the item size matches the remaining capacity, with a bonus for bins that are at least half-full after packing.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on how closely the item size matches the remaining capacity, with a bonus for bins that are at least half-full after packing.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining = cap - item\n      priority_score = -abs(remaining - item) # Prioritize bins where the remaining space is close to item size.\n      if remaining >= 0.5:\n        priority_score += 10  # Bonus for being at least half-full\n      priority.append(priority_score)\n    else:\n      priority.append(-100000)  # Extremely low priority if item does not fit\n  return priority",
          "objective": 30.94336,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates priority based on a bin's closeness to half-full after packing the item, penalizing bins that are too full or would become nearly empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates priority based on a bin's closeness to half-full after packing the item, penalizing bins that are too full or would become nearly empty.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            new_cap = cap - item\n            distance_from_half = abs(new_cap - 50)  # Assuming bin capacity is 100\n            priority.append(100.0 / (distance_from_half + 0.001)) # Inverse of distance from half-full\n        else:\n            priority.append(-1)  # Item doesn't fit\n\n    return priority",
          "objective": 76.42601,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm calculates priority scores for bins based on a combination of remaining capacity and a bonus for bins that can perfectly fit the item, then returns the priority scores.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates priority scores for bins based on a combination of remaining capacity and a bonus for bins that can perfectly fit the item, then returns the priority scores.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      if cap == item:\n        priority.append(cap * 2)  # perfect fit bonus\n      else:\n        priority.append(cap)\n    else:\n      priority.append(-1)  # Invalid bin\n  return priority",
          "objective": 88.08337,
          "other_inf": null
     }
]