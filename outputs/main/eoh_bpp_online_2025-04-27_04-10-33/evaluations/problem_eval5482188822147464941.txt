def priority_v2(item, bins_remain_cap):
  """{This algorithm balances bin utilization by preferring bins with remaining capacity close to the item size while also considering the overall fill level of the bin to avoid near-empty bins.}"""
  priority = []
  for cap in bins_remain_cap:
    if cap >= item:
      waste = cap - item
      utilization = 1 - (cap / 1.0)  # Assuming bin capacity is 1.0

      # Favor bins where waste is small and utilization is moderate
      if waste == 0:
        priority.append(1000) # Perfect fit
      else:
          priority_score = (1.0 / (waste + 0.001)) + (utilization * 5) # Inverse of waste + Utilization Factor
          priority.append(priority_score)
    else:
      priority.append(-float('inf'))
  return priority
