def priority_v2(item, bins_remain_cap):
    """{This algorithm evaluates bins based on how close their remaining capacity is to half the bin size after adding the current item, favoring bins that approach this ideal mid-fullness.}"""
    priority = []
    bin_size = 1.0  # Assuming bin size is 1
    for cap in bins_remain_cap:
        if cap >= item:
            new_cap = cap - item
            ideal_capacity = bin_size / 2.0
            # Calculate the absolute difference from the ideal capacity
            diff = abs(new_cap - ideal_capacity)
            # Invert the difference to prioritize bins closer to the ideal
            priority_score = 1.0 / (1.0 + diff)  # Adding 1 to avoid division by zero
            priority.append(priority_score)
        else:
            priority.append(-1.0)  # Item does not fit
    return priority
