def priority_v2(item, bins_remain_cap):
    """{This algorithm calculates the priority of each bin based on the remaining capacity, penalizing bins that are too full or too empty, and favors bins with remaining capacity slightly larger than the item size.}"""
    priority = []
    for cap in bins_remain_cap:
        if cap < item:
            priority.append(-1000)  # Very low priority if the item doesn't fit
        else:
            # Calculate a score based on how well the item fits.
            # A higher score indicates a better fit.

            # Basic fit score: higher when remaining capacity is close to item size
            fit_score = 1.0 / (abs(cap - item) + 0.1)

            # Penalize bins that are too empty to avoid excessive fragmentation
            empty_penalty = min(1.0, float(item) / cap)

            # Combine the scores and penalties
            total_score = fit_score * empty_penalty
            priority.append(total_score)
    return priority
