import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively improves routes by randomly swapping customers and evaluating the cost reduction and feasibility, updating a heuristic matrix based on the frequency of edges in improved routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    
    # Initialize a random solution
    permutation = np.random.permutation(np.arange(1, n))
    routes = []
    current_route = [0]
    current_demand = 0

    for customer in permutation:
        if current_demand + demands[customer] <= capacity:
            current_route.append(customer)
            current_demand += demands[customer]
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0, customer]
            current_demand = demands[customer]

    current_route.append(0)
    routes.append(current_route)
    
    best_routes = routes
    best_cost = calculate_total_distance(best_routes, distance_matrix)

    for _ in range(num_iterations):
        # Create a copy of the current solution
        temp_routes = [route[:] for route in best_routes]

        # Randomly select two customers to swap
        route_index1 = np.random.randint(0, len(temp_routes))
        route_index2 = np.random.randint(0, len(temp_routes))
        
        if len(temp_routes[route_index1]) <= 2 or len(temp_routes[route_index2]) <= 2:
            continue

        customer_index1 = np.random.randint(1, len(temp_routes[route_index1])-1)
        customer_index2 = np.random.randint(1, len(temp_routes[route_index2])-1)

        customer1 = temp_routes[route_index1][customer_index1]
        customer2 = temp_routes[route_index2][customer_index2]

        # Swap the customers
        temp_routes[route_index1][customer_index1] = customer2
        temp_routes[route_index2][customer_index2] = customer1

        # Check feasibility of new routes and adjust if necessary
        temp_routes = adjust_routes_for_feasibility(temp_routes, demands, capacity)

        # Calculate the cost of the new solution
        new_cost = calculate_total_distance(temp_routes, distance_matrix)

        # If the new solution is better, update the current solution
        if new_cost < best_cost and is_feasible_routes(temp_routes, demands, capacity):
            best_routes = temp_routes
            best_cost = new_cost
            
            # Update heuristics matrix
            for route in best_routes:
                for i in range(len(route) - 1):
                    u = route[i]
                    v = route[i+1]
                    heuristics_matrix[u, v] += 1
                    heuristics_matrix[v, u] += 1

    # Normalize the matrix
    heuristics_matrix = heuristics_matrix / num_iterations
    
    return heuristics_matrix

def calculate_total_distance(routes, distance_matrix):
  total_distance = 0
  for route in routes:
    for i in range(len(route) - 1):
      total_distance += distance_matrix[route[i], route[i+1]]
  return total_distance

def adjust_routes_for_feasibility(routes, demands, capacity):
    adjusted_routes = []
    for route in routes:
        current_route = [0]
        current_demand = 0
        for customer in route[1:-1]:
            if current_demand + demands[customer] <= capacity:
                current_route.append(customer)
                current_demand += demands[customer]
            else:
                current_route.append(0)
                adjusted_routes.append(current_route)
                current_route = [0, customer]
                current_demand = demands[customer]
        current_route.append(0)
        adjusted_routes.append(current_route)
    return adjusted_routes

def is_feasible_routes(routes, demands, capacity):
    for route in routes:
        route_demand = sum([demands[i] for i in route])
        if route_demand > capacity:
            return False
    return heuristics_matrix
