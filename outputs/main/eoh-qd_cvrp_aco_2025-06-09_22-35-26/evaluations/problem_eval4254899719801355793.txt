import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an ant colony optimization approach, simulating ant traversal to find good routes and updating pheromone levels on edges based on route quality.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones((n, n))  # Initialize pheromone levels
    heuristics_matrix = np.zeros((n, n))
    alpha = 1  # Pheromone influence
    beta = 2   # Distance influence
    rho = 0.5  # Evaporation rate
    Q = 100    # Pheromone deposit constant
    num_ants = 50
    num_iterations = 100

    for iteration in range(num_iterations):
        ant_routes = []
        ant_distances = []
        ant_feasible = []

        for ant in range(num_ants):
            unvisited = list(range(1, n))
            current_node = 0
            route = [0]
            current_capacity = 0
            routes = []

            while unvisited:
                probabilities = np.zeros(len(unvisited))
                for i, node in enumerate(unvisited):
                    eta = 1 / distance_matrix[current_node, node]
                    probabilities[i] = (pheromone_matrix[current_node, node]**alpha) * (eta**beta)

                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(unvisited, p=probabilities)

                if current_capacity + demands[next_node] <= capacity:
                    route.append(next_node)
                    current_capacity += demands[next_node]
                    current_node = next_node
                    unvisited.remove(next_node)
                else:
                    route.append(0)
                    routes.append(route)
                    route = [0]
                    current_capacity = 0
                    current_node = 0

            route.append(0)
            routes.append(route)
            ant_routes.append(routes)

            total_distance = 0
            feasible = True
            for r in routes:
                route_demand = sum(demands[i] for i in r)
                if route_demand > capacity:
                    feasible = False
                    break
                for i in range(len(r) - 1):
                    total_distance += distance_matrix[r[i], r[i+1]]

            ant_distances.append(total_distance)
            ant_feasible.append(feasible)
        
        # Pheromone update
        pheromone_matrix *= (1 - rho)  # Evaporation

        for ant in range(num_ants):
            if ant_feasible[ant]:
                routes = ant_routes[ant]
                distance = ant_distances[ant]
                for route in routes:
                    for i in range(len(route) - 1):
                        pheromone_matrix[route[i], route[i+1]] += Q / distance
                        pheromone_matrix[route[i+1], route[i]] += Q / distance

    # Convert pheromone matrix to heuristics matrix
    heuristics_matrix = pheromone_matrix

    # Normalize
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix = heuristics_matrix / max_val

    return heuristics_matrix
