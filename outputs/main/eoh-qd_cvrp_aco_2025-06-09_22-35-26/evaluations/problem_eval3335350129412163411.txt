import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a nearest neighbor approach to construct initial routes, evaluates them based on distance and capacity, and then refines the routes using a local search based on edge swaps, updating a heuristic matrix based on the frequency of edges in improved routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        # Nearest Neighbor Initialization
        unvisited = set(range(1, n))
        routes = []
        current_route = [0]
        current_capacity = 0

        while unvisited:
            last_node = current_route[-1]
            nearest_neighbor = None
            min_distance = float('inf')

            for neighbor in unvisited:
                if demands[neighbor] + current_capacity <= capacity and distance_matrix[last_node, neighbor] < min_distance:
                    nearest_neighbor = neighbor
                    min_distance = distance_matrix[last_node, neighbor]

            if nearest_neighbor is None:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_capacity = 0

                nearest_neighbor = None
                min_distance = float('inf')
                for neighbor in unvisited:
                     if demands[neighbor] <= capacity and distance_matrix[last_node, neighbor] < min_distance:
                        nearest_neighbor = neighbor
                        min_distance = distance_matrix[last_node, neighbor]

                if nearest_neighbor is None: #All remaining nodes exceed capacity
                    break

            current_route.append(nearest_neighbor)
            current_capacity += demands[nearest_neighbor]
            unvisited.remove(nearest_neighbor)
        
        current_route.append(0)
        routes.append(current_route)


        # Local Search (Edge Swaps)
        best_routes = routes
        best_distance = float('inf')
        is_feasible = True
        total_distance = 0
        for route in routes:
            route_demand = sum(demands[i] for i in route)
            if route_demand > capacity:
                is_feasible = False
                break
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]
        
        if is_feasible:
            best_distance = total_distance

        for i in range(len(routes)):
            for j in range(len(routes[i]) - 1):
                for k in range(i, len(routes)):
                    for l in range(len(routes[k]) - 1):

                        if i == k and abs(j-l) <=1:
                            continue

                        temp_routes = [route[:] for route in routes]
                        u = temp_routes[i][j]
                        v = temp_routes[i][j+1]
                        x = temp_routes[k][l]
                        y = temp_routes[k][l+1]
                        
                        temp_routes[i][j+1] = y
                        temp_routes[k][l+1] = v

                        temp_is_feasible = True
                        temp_total_distance = 0
                        for route in temp_routes:
                            route_demand = sum(demands[idx] for idx in route)
                            if route_demand > capacity:
                                temp_is_feasible = False
                                break
                            for m in range(len(route)-1):
                                temp_total_distance += distance_matrix[route[m], route[m+1]]
                        
                        if temp_is_feasible and temp_total_distance < best_distance:
                            best_routes = [route[:] for route in temp_routes]
                            best_distance = temp_total_distance
                            

        # Update heuristics matrix
        score = 1 / (best_distance + 1e-6)
        for route in best_routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += score
                heuristics_matrix[node2, node1] += score #Symmetric
    
    #Normalize so that each entry is between 0 and 1
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
      heuristics_matrix = heuristics_matrix / max_val

    return heuristics_matrix
