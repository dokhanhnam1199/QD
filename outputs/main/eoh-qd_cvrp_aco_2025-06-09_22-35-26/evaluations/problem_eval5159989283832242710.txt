import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge desirability for CVRP by generating random routes, evaluating feasibility and cost, and then biases edge frequencies towards routes with lower cost, assigning higher weights to edges in better solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000
    alpha = 0.5  # Weighting factor for cost

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        permutation = list(range(1, n))
        random.shuffle(permutation)

        # Create routes based on capacity constraints
        routes = []
        current_route = [0]  # Start at the depot
        current_demand = 0

        for customer in permutation:
            if current_demand + demands[customer] <= capacity:
                current_route.append(customer)
                current_demand += demands[customer]
            else:
                current_route.append(0)  # Return to depot
                routes.append(current_route)
                current_route = [0, customer]  # Start new route from depot
                current_demand = demands[customer]
        
        current_route.append(0) # close the last route
        routes.append(current_route)

        # Calculate the cost of the routes
        total_cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_cost += distance_matrix[route[i]][route[i+1]]
        
        # Calculate a score based on the cost (lower cost is better)
        score = np.exp(-alpha * total_cost)

        # Update the heuristics matrix based on the edges used in the route, weighted by the score
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1][node2] += score
                heuristics_matrix[node2][node1] += score  # Assuming symmetric distance matrix

    # Normalize the heuristics matrix by the sum of scores
    total_score = np.sum(heuristics_matrix)
    if total_score > 0:
      heuristics_matrix /= total_score

    return heuristics_matrix
