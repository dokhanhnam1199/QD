import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses stochastic solution sampling with a Clarke-Wright savings heuristic to estimate the probability of each edge being in a good CVRP solution, using these probabilities as heuristics.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        # Clarke-Wright Savings Algorithm
        savings = {}
        for i in range(1, n):
            for j in range(i + 1, n):
                savings[(i, j)] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]

        # Sort savings in descending order
        sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)

        routes = {i: [i] for i in range(1, n)}
        route_capacities = {i: demands[i] for i in range(1, n)}
        node_route = {i: i for i in range(1, n)}

        for (i, j), saving in sorted_savings:
            route_i = node_route[i]
            route_j = node_route[j]

            if route_i != route_j and route_capacities[route_i] + route_capacities[route_j] <= capacity:
                # Merge routes
                new_route = routes[route_i] + routes[route_j]
                new_capacity = route_capacities[route_i] + route_capacities[route_j]

                # Update route information
                for node in new_route:
                    node_route[node] = route_i

                routes[route_i] = new_route
                route_capacities[route_i] = new_capacity

                # Remove route j
                del routes[route_j]
                del route_capacities[route_j]

        # Construct the final tour from the routes
        final_tour = []
        for route_id in routes:
            route = routes[route_id]
            final_tour.append(0)
            final_tour.extend(route)
            final_tour.append(0)

        # Update heuristics based on edges in the tour
        for i in range(len(final_tour) - 1):
            heuristics_matrix[final_tour[i], final_tour[i+1]] += 1
            heuristics_matrix[final_tour[i+1], final_tour[i]] += 1  # Account for symmetry

    # Normalize the heuristic matrix
    heuristics_matrix /= num_samples

    return heuristics_matrix
