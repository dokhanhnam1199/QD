import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a route using a stochastic construction based on regret insertion, where the regret is the difference in cost between inserting a node at its best position and its second-best position in the current route.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Initialize route with the depot
        current_route = [0]
        remaining_nodes = list(range(1, n))
        current_capacity = 0

        while remaining_nodes:
            # Calculate insertion cost for each remaining node at each possible position in the route
            insertion_costs = {}
            for node in remaining_nodes:
                insertion_costs[node] = {}
                for i in range(len(current_route)):
                    if current_capacity + demands[node] <= capacity:
                        cost = distance_matrix[current_route[i-1], node] + distance_matrix[node, current_route[i]] - distance_matrix[current_route[i-1], current_route[i]] if i > 0 else distance_matrix[current_route[i], node] + distance_matrix[node, current_route[i+1]] - distance_matrix[current_route[i], current_route[i+1]]
                        insertion_costs[node][i] = cost
                    else:
                        insertion_costs[node][i] = float('inf')
            
            # Find the best and second-best insertion positions and calculate regret for each remaining node
            regrets = {}
            for node in remaining_nodes:
                if all(val == float('inf') for val in insertion_costs[node].values()):
                    regrets[node] = float('inf')
                    continue
                
                sorted_insertions = sorted(insertion_costs[node].items(), key=lambda item: item[1])
                best_insertion = sorted_insertions[0]
                
                if len(sorted_insertions) > 1:
                    second_best_insertion = sorted_insertions[1]
                    regrets[node] = second_best_insertion[1] - best_insertion[1]
                else:
                    regrets[node] = 0

            # Choose a node to insert probabilistically based on regret (higher regret = higher probability)
            if all(val == float('inf') for val in regrets.values()):
                current_route.append(0)
                current_capacity = 0
                continue
            
            probabilities = [regrets[node] if regrets[node] != float('inf') else 0 for node in remaining_nodes]
            
            if sum(probabilities) == 0:
                chosen_node = random.choice(remaining_nodes)
            else:
                probabilities = [p / sum(probabilities) for p in probabilities]
                chosen_node = random.choices(remaining_nodes, weights=probabilities, k=1)[0]

            # Insert the chosen node at its best position in the route
            best_insertion_position = min(insertion_costs[chosen_node], key=insertion_costs[chosen_node].get)
            
            if insertion_costs[chosen_node][best_insertion_position] == float('inf'):
                current_route.append(0)
                current_capacity = 0
                remaining_nodes = list(range(1, n))
                current_route = [0]
                continue
            
            current_route.insert(best_insertion_position, chosen_node)
            current_capacity += demands[chosen_node]
            remaining_nodes.remove(chosen_node)
        
        current_route.append(0) # Return to depot after visiting all customers
        
        # Update the heuristics matrix based on the route
        for i in range(len(current_route) - 1):
            node1 = current_route[i]
            node2 = current_route[i+1]
            heuristics_matrix[node1, node2] += 1

    return heuristics_matrix
