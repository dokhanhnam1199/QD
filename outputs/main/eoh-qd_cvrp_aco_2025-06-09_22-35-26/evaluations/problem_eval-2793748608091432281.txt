import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs an initial feasible solution using a savings-based approach, iteratively refines it by relocating nodes between routes based on cost reduction and capacity constraints, and returns a matrix representing the frequency of each edge's appearance in sampled solutions as a heuristic indicator.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 100

    def calculate_route_demand(route):
        return sum(demands[i] for i in route)

    def calculate_total_distance(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance

    def construct_initial_solution():
        unvisited = set(range(1, n))
        routes = [[0, i, 0] for i in range(1, n)]
        
        valid_routes = []
        for route in routes:
            if calculate_route_demand(route) <= capacity:
                valid_routes.append(route)
            
        return valid_routes

    def savings_heuristic():
        savings = {}
        for i in range(1, n):
            for j in range(i + 1, n):
                savings[(i, j)] = distance_matrix[i][0] + distance_matrix[0][j] - distance_matrix[i][j]

        sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)
        routes = [[0, i, 0] for i in range(1, n)]
        
        for (i, j), saving in sorted_savings:
            route_i = None
            route_j = None

            for route in routes:
                if i in route and route[1] == i:
                    route_i = route
                if j in route and route[1] == j:
                    route_j = route
            
            if route_i is not None and route_j is not None and route_i != route_j:
                if calculate_route_demand(route_i[1:-1] + route_j[1:-1]) <= capacity:
                    new_route = route_i[:-1] + route_j[1:]
                    routes.remove(route_i)
                    routes.remove(route_j)
                    routes.append(new_route)
        
        return routes

    def relocate_node(routes):
        best_routes = routes[:]
        best_distance = calculate_total_distance(routes)
        
        for i in range(len(routes)):
            for j in range(1, len(routes[i]) -1):
                node_to_move = routes[i][j]
                original_routes = [route[:] for route in routes]
                original_routes[i].pop(j)
                
                if calculate_route_demand(original_routes[i][1:-1]) > capacity:
                    original_routes = routes
                    continue
                    
                for k in range(len(routes)):
                    for l in range(1, len(routes[k])):
                        new_routes = [route[:] for route in original_routes]
                        new_routes[k].insert(l, node_to_move)
                        
                        if calculate_route_demand(new_routes[k][1:-1]) <= capacity:
                            new_distance = calculate_total_distance(new_routes)
                            if new_distance < best_distance:
                                best_distance = new_distance
                                best_routes = new_routes
        return best_routes

    initial_solution = savings_heuristic()
    best_solution = initial_solution

    for _ in range(num_samples):
        sampled_routes = relocate_node(best_solution)

        if calculate_total_distance(sampled_routes) < calculate_total_distance(best_solution):
            best_solution = sampled_routes
            
        for route in sampled_routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i]][route[i+1]] += 1
                heuristics_matrix[route[i+1]][route[i]] += 1

    return heuristics_matrix
