import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs routes using a greedy approach with probabilistic selection based on distance and demand, then refines routes by swapping nodes to improve feasibility and reduce cost, and finally evaluates edges based on their frequency in the refined routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_routes = n  # Number of routes to generate

    for _ in range(num_routes):
        unvisited = list(range(1, n))
        routes = []
        
        while unvisited:
            current_route = [0]
            current_load = 0
            
            while unvisited:
                # Probabilistic selection of next node
                probabilities = []
                for node in unvisited:
                    distance = distance_matrix[current_route[-1], node]
                    demand = demands[node]
                    #Heuristic to balance distance and demand
                    heuristic_value = (1 / (distance + 1e-6)) * (1 / (demand + 1e-6))  
                    probabilities.append(heuristic_value)
                
                probabilities = np.array(probabilities)
                probabilities /= np.sum(probabilities)
                
                next_node = random.choices(unvisited, probabilities)[0]

                if current_load + demands[next_node] <= capacity:
                    current_route.append(next_node)
                    current_load += demands[next_node]
                    unvisited.remove(next_node)
                else:
                    break
            current_route.append(0)
            routes.append(current_route)

        # Route refinement: Swap nodes between routes to improve feasibility and cost
        for i in range(len(routes)):
            for j in range(i + 1, len(routes)):
                route1 = routes[i]
                route2 = routes[j]

                for idx1 in range(1, len(route1) - 1):
                    for idx2 in range(1, len(route2) - 1):
                        node1 = route1[idx1]
                        node2 = route2[idx2]
                        
                        #Check capacity constraints after swap
                        load1 = sum(demands[node] for node in route1[1:-1]) - demands[node1] + demands[node2]
                        load2 = sum(demands[node] for node in route2[1:-1]) - demands[node2] + demands[node1]

                        if load1 <= capacity and load2 <= capacity:
                            #Evaluate cost after swap
                            cost_before = distance_matrix[route1[idx1-1],node1] + distance_matrix[node1,route1[idx1+1]] + distance_matrix[route2[idx2-1],node2] + distance_matrix[node2,route2[idx2+1]]
                            cost_after = distance_matrix[route1[idx1-1],node2] + distance_matrix[node2,route1[idx1+1]] + distance_matrix[route2[idx2-1],node1] + distance_matrix[node1,route2[idx2+1]]
                            if cost_after < cost_before:
                                route1[idx1], route2[idx2] = route2[idx2], route1[idx1]

        # Evaluate edges based on frequency in refined routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
