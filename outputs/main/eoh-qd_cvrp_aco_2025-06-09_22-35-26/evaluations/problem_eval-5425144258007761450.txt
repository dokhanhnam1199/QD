import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an ant colony optimization approach to probabilistically construct routes, favoring edges with shorter distances and higher pheromone levels, and updates pheromone levels based on route feasibility and length.}
    """
    n = len(demands)
    pheromone_matrix = np.ones_like(distance_matrix)
    heuristics_matrix = np.zeros_like(distance_matrix)
    alpha = 1  # Pheromone influence
    beta = 2  # Distance influence
    rho = 0.5  # Evaporation rate
    Q = 100  # Pheromone deposit constant
    num_ants = 50
    num_iterations = 100

    for iteration in range(num_iterations):
        all_routes = []
        for ant in range(num_ants):
            unvisited = set(range(1, n))
            current_route = [0]
            current_capacity = 0
            
            while unvisited:
                probabilities = []
                for node in unvisited:
                    if current_capacity + demands[node] <= capacity:
                        pheromone = pheromone_matrix[current_route[-1], node] ** alpha
                        distance = (1 / distance_matrix[current_route[-1], node]) ** beta if distance_matrix[current_route[-1], node] > 0 else 0
                        probabilities.append((node, pheromone * distance))
                    else:
                        probabilities.append((node, 0))

                total_prob = sum(prob for node, prob in probabilities)
                if total_prob > 0:
                    probabilities = [(node, prob / total_prob) for node, prob in probabilities]
                    
                    next_node = random.choices([node for node, prob in probabilities], weights=[prob for node, prob in probabilities], k=1)[0]
                    
                    current_route.append(next_node)
                    current_capacity += demands[next_node]
                    unvisited.remove(next_node)
                else:
                    current_route.append(0)
                    all_routes.append(current_route + [0])
                    current_route = [0]
                    current_capacity = 0
                    break

            if current_route[-1] != 0:
                current_route.append(0)
            all_routes.append(current_route)

        # Evaluate routes and update pheromones
        for route in all_routes:
            total_distance = 0
            feasible = True
            total_load = 0
            
            route_adjusted = []
            current_route = [0]
            current_capacity = 0

            for i in range(1, len(route)):
                if route[i] != 0:
                    if current_capacity + demands[route[i]] <= capacity:
                        current_route.append(route[i])
                        current_capacity += demands[route[i]]
                    else:
                        current_route.append(0)
                        route_adjusted.append(current_route)
                        current_route = [0, route[i]]
                        current_capacity = demands[route[i]]
                else:
                    current_route.append(0)
                    route_adjusted.append(current_route)
                    current_route = [0]
                    current_capacity = 0
            
            if len(current_route) > 1:
                current_route.append(0)
                route_adjusted.append(current_route)
            
            
            for r in route_adjusted:
              for i in range(len(r) - 1):
                  total_distance += distance_matrix[r[i], r[i+1]]
                  total_load += demands[r[i]]
              if total_load > capacity:
                  feasible = False

            if feasible and total_distance > 0:
                for r in route_adjusted:
                  for i in range(len(r) - 1):
                      pheromone_matrix[r[i], r[i+1]] += Q / total_distance
                      pheromone_matrix[r[i+1], r[i]] += Q / total_distance


        pheromone_matrix *= (1 - rho)

    for i in range(n):
      for j in range(n):
        heuristics_matrix[i, j] = pheromone_matrix[i, j] / np.max(pheromone_matrix)
        
    return heuristics_matrix
