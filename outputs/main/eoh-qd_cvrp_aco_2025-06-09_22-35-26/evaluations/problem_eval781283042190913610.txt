import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a genetic algorithm to evolve a population of routes, and then uses the frequency of edges in the best routes of the final generation to estimate their desirability.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1

    def create_individual():
        customer_permutation = list(range(1, n))
        random.shuffle(customer_permutation)
        return customer_permutation

    def evaluate_individual(individual):
        routes = []
        current_route = [0]
        current_load = 0
        total_cost = 0
        
        for customer in individual:
            if current_load + demands[customer] <= capacity:
                current_route.append(customer)
                current_load += demands[customer]
            else:
                total_cost += distance_calculation(current_route)
                routes.append(current_route)
                current_route = [0, customer]
                current_load = demands[customer]
        total_cost += distance_calculation(current_route)
        routes.append(current_route)
        return total_cost

    def distance_calculation(route):
        cost = 0
        if len(route) > 1:
            cost += distance_matrix[0, route[0]]
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i], route[i + 1]]
            cost += distance_matrix[route[-1], 0]
        return cost

    def crossover(parent1, parent2):
        start = random.randint(0, n - 2)
        end = random.randint(start + 1, n - 1)

        child = parent1[start:end]
        remaining = [item for item in parent2 if item not in child]
        child = remaining[:start] + child + remaining[start:]
        return child

    def mutate(individual):
        for i in range(len(individual)):
            if random.random() < mutation_rate:
                j = random.randint(0, len(individual) - 1)
                individual[i], individual[j] = individual[j], individual[i]
        return individual

    # Initialize population
    population = [create_individual() for _ in range(population_size)]

    # Evolve population
    for _ in range(num_generations):
        # Evaluate fitness
        fitness = [(evaluate_individual(individual), individual) for individual in population]
        fitness.sort(key=lambda x: x[0])

        # Select parents (tournament selection)
        selected = [individual for _, individual in fitness[:population_size // 2]]

        # Create new generation
        new_population = selected[:]
        while len(new_population) < population_size:
            parent1 = random.choice(selected)
            parent2 = random.choice(selected)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)

        population = new_population

    # Update heuristics matrix based on best route of final generation
    best_fitness, best_individual = min((evaluate_individual(individual), individual) for individual in population)
    
    routes = []
    current_route = [0]
    current_load = 0
    for customer in best_individual:
        if current_load + demands[customer] <= capacity:
            current_route.append(customer)
            current_load += demands[customer]
        else:
            routes.append(current_route)
            current_route = [0, customer]
            current_load = demands[customer]
    routes.append(current_route)

    for route in routes:
      route_with_depot = route + [0]
      route_with_depot[0] = 0
      for i in range(len(route_with_depot) - 1):
        heuristics_matrix[route_with_depot[i], route_with_depot[i+1]] += 1
        heuristics_matrix[route_with_depot[i+1], route_with_depot[i]] += 1
    return heuristics_matrix
