import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an Ant Colony Optimization (ACO) approach to iteratively construct routes, updating pheromone levels based on route quality and returning a matrix representing pheromone levels as a heuristic indicator.}
    """
    n = len(demands)
    pheromone_matrix = np.ones_like(distance_matrix)
    heuristic_matrix = np.zeros_like(distance_matrix)
    alpha = 1
    beta = 2
    rho = 0.5
    Q = 100
    num_ants = 20
    num_iterations = 100

    def calculate_route_demand(route):
        return sum(demands[i] for i in route)

    def construct_route(pheromone_matrix, current_node, unvisited, capacity, current_demand):
        route = [current_node]
        while unvisited:
            probabilities = []
            for node in unvisited:
                if current_demand + demands[node] <= capacity:
                    probabilities.append((pheromone_matrix[current_node][node]**alpha) * ((1 / distance_matrix[current_node][node])**beta))
                else:
                    probabilities.append(0)

            if sum(probabilities) == 0:
                break

            probabilities = [p / sum(probabilities) for p in probabilities]
            next_node = random.choices(list(unvisited), weights=probabilities, k=1)[0]
            route.append(next_node)
            unvisited.remove(next_node)
            current_demand += demands[next_node]
        return route

    def calculate_route_length(route):
        length = 0
        for i in range(len(route) - 1):
            length += distance_matrix[route[i]][route[i+1]]
        return length

    for iteration in range(num_iterations):
        all_routes = []
        all_route_lengths = []

        for ant in range(num_ants):
            routes = []
            unvisited = set(range(1, n))
            while unvisited:
                route = construct_route(pheromone_matrix, 0, unvisited.copy(), capacity, 0)
                routes.append([0] + route + [0])
                for node in route:
                    if node in unvisited:
                        unvisited.remove(node)

            total_distance = 0
            for route in routes:
                total_distance += calculate_route_length(route)
            
            all_routes.append(routes)
            all_route_lengths.append(total_distance)

        best_iteration_index = np.argmin(all_route_lengths)
        best_iteration_routes = all_routes[best_iteration_index]
        best_iteration_length = all_route_lengths[best_iteration_index]
        
        # Pheromone update
        pheromone_matrix *= (1 - rho)
        for routes in all_routes:
            for route in routes:
                route_length = calculate_route_length(route)
                for i in range(len(route) - 1):
                    pheromone_matrix[route[i]][route[i+1]] += Q / route_length
                    pheromone_matrix[route[i+1]][route[i]] += Q / route_length


    return heuristics_matrix
