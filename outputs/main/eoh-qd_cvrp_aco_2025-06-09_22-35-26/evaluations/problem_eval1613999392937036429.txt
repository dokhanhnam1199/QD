import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a population of random CVRP solutions, evaluates their costs, and biases edge selection probabilities based on the solution costs using a Gibbs sampling approach.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100  # Population size
    num_iterations = 50 # Gibbs sampling iterations
    temperature = 100.0  # Temperature parameter for Gibbs sampling

    def create_random_solution():
        remaining_nodes = list(range(1, n))
        routes = []
        current_route = [0]
        current_load = 0

        while remaining_nodes:
            next_node = random.choice(remaining_nodes)
            if current_load + demands[next_node] <= capacity:
                current_route.append(next_node)
                current_load += demands[next_node]
                remaining_nodes.remove(next_node)
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0

        current_route.append(0)
        routes.append(current_route)
        return routes

    def calculate_solution_cost(solution):
        cost = 0
        for route in solution:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i], route[i+1]]
        return cost
    
    #Initialize population of solutions
    population = [create_random_solution() for _ in range(num_samples)]

    for _ in range(num_iterations):
        for i in range(num_samples):
            #Gibbs sampling: perturb the current solution

            #Select a random route from the current solution
            if len(population[i])>0:
                route_index = random.randint(0, len(population[i]) -1)
                
                #Remove the route from the current solution
                removed_route = population[i].pop(route_index)
                
                #Add the nodes in the removed route back to unvisited nodes
                unvisited_nodes = removed_route[1:-1]

                #Reinsert the unvisited nodes
                for node in unvisited_nodes:
                    # Find the best place to insert the node in all routes
                    best_insertion = None
                    best_insertion_cost = float('inf')
                    
                    for route_index2 in range(len(population[i])+1):
                        
                        #Create a new route if route_index2 is the last of the routes
                        if route_index2 == len(population[i]):
                            new_route = [0, node, 0]
                            
                            # check capacity
                            if demands[node] <= capacity:
                                new_cost = distance_matrix[0,node] + distance_matrix[node,0]
                                if new_cost < best_insertion_cost:
                                    best_insertion = (route_index2, [0,node,0])
                                    best_insertion_cost = new_cost
                            
                        else:
                            route = population[i][route_index2]
                            
                            # Find the best place to insert node in this route
                            for insert_index in range(1, len(route)):
                                temp_route = route[:insert_index] + [node] + route[insert_index:]
                                
                                # check capacity
                                load = 0
                                for n_idx in temp_route:
                                    load += demands[n_idx]
                                    
                                if load <= capacity:                                    
                                    temp_cost = 0
                                    for idx in range(len(temp_route)-1):
                                        temp_cost += distance_matrix[temp_route[idx], temp_route[idx+1]]
                                        
                                    if temp_cost < best_insertion_cost:
                                        best_insertion = (route_index2, temp_route)
                                        best_insertion_cost = temp_cost
                    
                    if best_insertion is not None:
                        route_index2, new_route = best_insertion
                        if route_index2 == len(population[i]):
                            population[i].append(new_route)
                        else:
                            population[i][route_index2] = new_route

        #Calculate solution costs
        costs = [calculate_solution_cost(sol) for sol in population]
        
        #Calculate probabilities based on solution costs (Gibbs sampling)
        probabilities = np.exp(-np.array(costs) / temperature)
        probabilities /= np.sum(probabilities)

        #Update heuristics matrix based on edge frequencies and solution probabilities
        for i in range(num_samples):
            solution = population[i]
            for route in solution:
                for j in range(len(route) - 1):
                    node1 = route[j]
                    node2 = route[j+1]
                    heuristics_matrix[node1, node2] += probabilities[i]
                    heuristics_matrix[node2, node1] += probabilities[i]

    return heuristics_matrix
