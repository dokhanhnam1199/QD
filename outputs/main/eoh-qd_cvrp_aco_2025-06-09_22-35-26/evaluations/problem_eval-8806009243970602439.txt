import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a genetic algorithm approach to evolve a population of routes, using edge frequency in promising routes to construct a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1

    def create_individual():
        customer_indices = list(range(1, n))
        random.shuffle(customer_indices)
        routes = []
        current_route = [0]
        current_capacity = 0
        for customer in customer_indices:
            if current_capacity + demands[customer] <= capacity:
                current_route.append(customer)
                current_capacity += demands[customer]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, customer]
                current_capacity = demands[customer]
        current_route.append(0)
        routes.append(current_route)
        return routes

    def calculate_fitness(individual):
        is_feasible = True
        total_distance = 0
        for route in individual:
            route_demand = sum(demands[i] for i in route)
            if route_demand > capacity:
                is_feasible = False
                return float('inf')
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]
        if not is_feasible:
            return float('inf')
        return total_distance

    def crossover(parent1, parent2):
        #Simple one-point crossover on flattened route representation
        flat_parent1 = [node for route in parent1 for node in route]
        flat_parent2 = [node for route in parent2 for node in route]

        crossover_point = random.randint(1, min(len(flat_parent1), len(flat_parent2)) - 1)

        child1_flat = flat_parent1[:crossover_point] + flat_parent2[crossover_point:]
        child2_flat = flat_parent2[:crossover_point] + flat_parent1[crossover_point:]

        #Reshape back into routes (basic split, needs improvement)
        child1_routes = []
        current_route = []
        for node in child1_flat:
            current_route.append(node)
            if node == 0 and len(current_route) > 1:
                child1_routes.append(current_route)
                current_route = []
        if current_route:
            child1_routes.append(current_route)

        child2_routes = []
        current_route = []
        for node in child2_flat:
            current_route.append(node)
            if node == 0 and len(current_route) > 1:
                child2_routes.append(current_route)
                current_route = []
        if current_route:
            child2_routes.append(current_route)


        return child1_routes, child2_routes

    def mutate(individual):
        if random.random() < mutation_rate:
            #Swap two random nodes in the routes
            route_index1 = random.randint(0, len(individual) - 1)
            route_index2 = random.randint(0, len(individual) - 1)

            if len(individual[route_index1]) > 1 and len(individual[route_index2]) > 1:
                node_index1 = random.randint(1, len(individual[route_index1]) - 1) # Don't swap depot
                node_index2 = random.randint(1, len(individual[route_index2]) - 1)

                individual[route_index1][node_index1], individual[route_index2][node_index2] = individual[route_index2][node_index2], individual[route_index1][node_index1]
        return individual

    # Initialize population
    population = [create_individual() for _ in range(population_size)]

    # Evolve population
    for generation in range(num_generations):
        # Evaluate fitness
        fitnesses = [calculate_fitness(individual) for individual in population]

        # Selection (tournament selection)
        selected_indices = random.choices(range(population_size), weights=[1/ (f + 1e-6) for f in fitnesses], k=population_size)  #Inverse fitness weighting
        selected_population = [population[i] for i in selected_indices]

        # Crossover and Mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[i+1 if i+1 < population_size else i]
            child1, child2 = crossover(parent1, parent2)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
        
        population = new_population

    # Evaluate final population and find best individual
    fitnesses = [calculate_fitness(individual) for individual in population]
    best_individual = population[np.argmin(fitnesses)]

    # Update heuristics matrix based on the best solution
    for route in best_individual:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize the heuristics matrix
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
      heuristics_matrix = heuristics_matrix / max_val
    
    return heuristics_matrix
