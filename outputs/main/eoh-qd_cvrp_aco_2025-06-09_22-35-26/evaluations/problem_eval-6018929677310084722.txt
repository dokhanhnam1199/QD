import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then weights the edge frequency based on an exponential decay of the route cost.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000
    top_k = 50
    cost_scaling = 0.1

    feasible_routes = []

    for _ in range(num_samples):
        route = list(range(1, n))
        random.shuffle(route)

        current_route = []
        current_demand = 0
        total_cost = 0
        is_feasible = True

        vehicle_routes = []

        for node in route:
            if current_demand + demands[node] <= capacity:
                current_route.append(node)
                current_demand += demands[node]
            else:
                if len(current_route) > 0:
                    total_cost += distance_matrix[0, current_route[0]]
                    for i in range(len(current_route) - 1):
                        total_cost += distance_matrix[current_route[i], current_route[i+1]]
                    total_cost += distance_matrix[current_route[-1], 0]
                    vehicle_routes.append(current_route)

                else:
                    is_feasible = False
                    break

                current_route = [node]
                current_demand = demands[node]

        if is_feasible:
            if len(current_route) > 0:
                total_cost += distance_matrix[0, current_route[0]]
                for i in range(len(current_route) - 1):
                    total_cost += distance_matrix[current_route[i], current_route[i + 1]]
                total_cost += distance_matrix[current_route[-1], 0]
                vehicle_routes.append(current_route)
            feasible_routes.append((vehicle_routes, total_cost))

    feasible_routes.sort(key=lambda x: x[1])

    for vehicle_routes, total_cost in feasible_routes[:min(top_k, len(feasible_routes))]:
        weight = np.exp(-cost_scaling * total_cost)
        for route in vehicle_routes:
            route_with_depot = [0] + route + [0]
            for i in range(len(route_with_depot) - 1):
                heuristics_matrix[route_with_depot[i], route_with_depot[i+1]] += weight
                heuristics_matrix[route_with_depot[i+1], route_with_depot[i]] += weight

    return heuristics_matrix
