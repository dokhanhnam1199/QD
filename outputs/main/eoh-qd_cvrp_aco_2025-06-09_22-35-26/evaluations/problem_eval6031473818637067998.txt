import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines routes by probabilistically accepting or rejecting edge swaps based on a combination of distance improvement and edge frequency from past iterations, creating a heuristic matrix reflecting edge selection probabilities.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    alpha = 0.9
    beta = 0.1

    def construct_initial_solution():
        unvisited = set(range(1, n))
        routes = []
        current_route = [0]
        current_demand = 0

        while unvisited:
            best_node = None
            min_dist = float('inf')

            for node in unvisited:
                dist = distance_matrix[current_route[-1]][node]
                if dist < min_dist and current_demand + demands[node] <= capacity:
                    min_dist = dist
                    best_node = node

            if best_node is None:
                routes.append(current_route + [0])
                current_route = [0]
                current_demand = 0
                continue

            current_route.append(best_node)
            current_demand += demands[best_node]
            unvisited.remove(best_node)

        routes.append(current_route + [0])
        return routes

    def calculate_total_distance(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance

    def two_opt_swap(route, i, k):
        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
        return new_route
    
    def is_feasible(route):
        current_demand = 0
        for node in route[1:-1]:
          current_demand += demands[node]
        return current_demand <= capacity

    current_solution = construct_initial_solution()
    best_solution = current_solution
    
    edge_counts = np.zeros_like(distance_matrix)

    for iteration in range(num_iterations):
      
        new_solution = []
        for route in current_solution:
          
          if len(route) > 3:
            
            i = random.randint(1, len(route) - 2)
            k = random.randint(i + 1, len(route) - 1)
            new_route = two_opt_swap(route, i, k)

            if is_feasible(new_route):

                delta_distance = sum(distance_matrix[new_route[j]][new_route[j+1]] for j in range(len(new_route) - 1)) - sum(distance_matrix[route[j]][route[j+1]] for j in range(len(route) - 1))
                
                edge_frequency_change = 0
                for j in range(len(route) -1):
                    edge_frequency_change -= edge_counts[route[j]][route[j+1]] + edge_counts[route[j+1]][route[j]]

                for j in range(len(new_route) - 1):
                    edge_frequency_change += edge_counts[new_route[j]][new_route[j+1]] + edge_counts[new_route[j+1]][new_route[j]]

                probability = np.exp(-alpha * delta_distance + beta * edge_frequency_change)
                
                if random.random() < probability:
                    new_solution.append(new_route)
                    
                    for j in range(len(new_route) - 1):
                        heuristics_matrix[new_route[j]][new_route[j+1]] += 1
                        heuristics_matrix[new_route[j+1]][new_route[j]] += 1

                else:
                  new_solution.append(route)
                  for j in range(len(route) - 1):
                      heuristics_matrix[route[j]][route[j+1]] += 0
                      heuristics_matrix[route[j+1]][route[j]] += 0
            else:
              new_solution.append(route)
          else:
            new_solution.append(route)
        
        current_solution = new_solution
        
        if calculate_total_distance(current_solution) < calculate_total_distance(best_solution):
            best_solution = current_solution

        for route in current_solution:
            for i in range(len(route) - 1):
                edge_counts[route[i]][route[i+1]] += 1
                edge_counts[route[i+1]][route[i]] += 1
    
    return heuristics_matrix
