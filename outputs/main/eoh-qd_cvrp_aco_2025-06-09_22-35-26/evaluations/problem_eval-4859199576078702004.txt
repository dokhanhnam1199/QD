import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm builds routes using a savings-based approach with stochastic selection, prioritizing merging routes that maximize savings while respecting capacity constraints, and constructing a heuristic matrix based on edge frequencies in the resulting routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Initialize routes: each customer is served by a separate vehicle
        routes = [[i] for i in range(1, n)]
        
        # Calculate savings for all pairs of routes
        savings = {}
        for i in range(len(routes)):
            for j in range(i + 1, len(routes)):
                node_i = routes[i][0]
                node_j = routes[j][0]
                savings[(i, j)] = distance_matrix[node_i, 0] + distance_matrix[node_j, 0] - distance_matrix[node_i, node_j]

        # Sort savings in descending order
        sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)
        
        # Merge routes based on savings until no more merges are possible
        merged_routes = []
        route_indices = list(range(len(routes)))  # Keep track of route indices
        
        for (i, j), saving in sorted_savings:
            # Check if routes are still valid and not already merged
            if i in route_indices and j in route_indices:
                original_i = route_indices.index(i)
                original_j = route_indices.index(j)
                
                route_i = routes[i]
                route_j = routes[j]
                
                # Check capacity constraint
                total_demand = sum(demands[node] for node in route_i + route_j)
                if total_demand <= capacity:
                    # Merge routes i and j
                    merged_route = route_i + route_j
                    merged_routes.append(merged_route)
                    
                    # Remove route indices that are merged
                    
                    # Find the original indices in route_indices
                    index_i = route_indices.index(i)
                    index_j = route_indices.index(j)

                    # Make sure index_i is always the smaller index
                    if index_j < index_i:
                        index_i, index_j = index_j, index_i

                    # Remove the merged indices
                    del route_indices[index_j]  # Delete the larger index first
                    del route_indices[index_i]
                    
                    # Update routes list: replace the first route and remove the second one
                    routes[i] = merged_route

        # Update heuristics matrix based on edges in the constructed routes
        final_routes = []
        used_routes_indices = []
        
        for i in range(len(routes)):
            if i in route_indices:
                final_routes.append(routes[i])

        for route in final_routes:
            full_route = [0] + route + [0]
            for i in range(len(full_route) - 1):
                heuristics_matrix[full_route[i], full_route[i+1]] += 1
                heuristics_matrix[full_route[i+1], full_route[i]] += 1

    # Normalize the heuristic matrix
    heuristics_matrix /= num_samples

    return heuristics_matrix
