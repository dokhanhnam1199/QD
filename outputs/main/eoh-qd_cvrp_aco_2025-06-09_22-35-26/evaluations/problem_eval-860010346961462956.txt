import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm constructs a heuristic matrix by iteratively improving routes using a greedy insertion approach within a simulated annealing framework.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    temperature = 100.0
    cooling_rate = 0.995

    # Initialize a random solution
    unvisited = list(range(1, n))
    routes = []
    current_route = [0]
    current_load = 0

    while unvisited:
        next_node = random.choice(unvisited)
        if current_load + demands[next_node] <= capacity:
            current_route.append(next_node)
            current_load += demands[next_node]
            unvisited.remove(next_node)
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0]
            current_load = 0

    current_route.append(0)
    routes.append(current_route)

    def calculate_route_distance(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance

    current_distance = calculate_route_distance(routes)

    for i in range(num_iterations):
        # Select a random route
        route_index = random.randint(0, len(routes) - 1)
        route = routes[route_index]

        # Select a random node (excluding depot)
        if len(route) <= 2:
            continue

        node_index = random.randint(1, len(route) - 2)
        node_to_move = route[node_index]

        # Remove the node from the current route
        current_load -= demands[node_to_move]
        route.pop(node_index)

        # Find the best position to insert the node in any route
        best_insertion_distance = float('inf')
        best_insertion_route_index = -1
        best_insertion_index = -1

        for j in range(len(routes)):
            temp_route = routes[j]
            temp_load = sum(demands[node] for node in temp_route if node !=0)

            for k in range(1, len(temp_route)):
                if temp_load + demands[node_to_move] <= capacity:
                    temp_route.insert(k, node_to_move)
                    new_distance = distance_matrix[temp_route[k-1]][temp_route[k]] + distance_matrix[temp_route[k]][temp_route[k+1]] - distance_matrix[temp_route[k-1]][temp_route[k+1]]
                    if new_distance < best_insertion_distance:
                        best_insertion_distance = new_distance
                        best_insertion_route_index = j
                        best_insertion_index = k
                    temp_route.pop(k)

        # Insert the node in the best position
        if best_insertion_route_index != -1:
            routes[best_insertion_route_index].insert(best_insertion_index, node_to_move)

            new_distance = calculate_route_distance(routes)
            delta = new_distance - current_distance

            if delta < 0 or random.random() < np.exp(-delta / temperature):
                current_distance = new_distance

                # Update heuristics matrix based on the new solution
                heuristics_matrix = np.zeros_like(distance_matrix)
                for route in routes:
                    for i in range(len(route) - 1):
                        node1 = route[i]
                        node2 = route[i + 1]
                        heuristics_matrix[node1, node2] += 1
                        heuristics_matrix[node2, node1] += 1
            else:
                route.insert(node_index, node_to_move)
        else:
                route.insert(node_index, node_to_move)

        temperature *= cooling_rate

    return heuristics_matrix
