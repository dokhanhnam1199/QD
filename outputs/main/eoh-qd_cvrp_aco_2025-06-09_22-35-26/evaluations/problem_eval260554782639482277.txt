import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes incrementally using a savings-based approach with stochastic elements, prioritizing edges that lead to higher savings while respecting capacity constraints, and repeating this process to build a heuristics matrix based on edge usage frequency.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000  # Number of route construction iterations

    for _ in range(num_iterations):
        unvisited = set(range(1, n))
        routes = []
        while unvisited:
            # Start a new route
            current_route = []
            current_demand = 0
            current_node = 0  # Start at the depot

            # Add a random customer to start the route
            possible_starts = list(unvisited)
            if not possible_starts:
                break
            next_node = random.choice(possible_starts)

            if current_demand + demands[next_node] <= capacity:
                current_route.append(next_node)
                current_demand += demands[next_node]
                unvisited.remove(next_node)
            else:
                continue # If random start exceeds capacity try different random starts

            # Extend the route greedily based on savings, with stochasticity
            while True:
                best_savings = -np.inf
                best_node = None

                for neighbor in unvisited:
                    if current_demand + demands[neighbor] <= capacity:
                        # Savings calculation (savings = distance to depot - distance to neighbor)
                        savings = distance_matrix[0, current_route[-1]] + distance_matrix[neighbor, 0] - distance_matrix[current_route[-1], neighbor] 

                        #Stochastic acceptance based on savings
                        probability = np.exp(savings) #Higher saving high probability

                        if random.random() < probability:

                            if savings > best_savings: # deterministic part, best savings
                                best_savings = savings
                                best_node = neighbor


                if best_node is not None:
                    current_route.append(best_node)
                    current_demand += demands[best_node]
                    unvisited.remove(best_node)
                else:
                    break

            # Add the complete route to the list of routes
            routes.append(current_route)

        # Update heuristics matrix based on the constructed routes
        for route in routes:
            route_with_depot = [0] + route + [0]
            for i in range(len(route_with_depot) - 1):
                heuristics_matrix[route_with_depot[i], route_with_depot[i + 1]] += 1
                heuristics_matrix[route_with_depot[i + 1], route_with_depot[i]] += 1

    return heuristics_matrix
