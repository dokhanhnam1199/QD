import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples multiple random routes, evaluates their feasibility based on capacity constraints, and then assigns heuristic values to edges based on both frequency of appearance in feasible routes and the distance between the nodes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        customer_indices = list(range(1, n))
        random.shuffle(customer_indices)

        # Construct routes based on capacity constraints
        routes = []
        current_route = [0]  # Start at the depot
        current_capacity = 0

        for customer in customer_indices:
            if current_capacity + demands[customer] <= capacity:
                current_route.append(customer)
                current_capacity += demands[customer]
            else:
                current_route.append(0)  # Return to depot
                routes.append(current_route)
                current_route = [0, customer]  # Start new route from depot
                current_capacity = demands[customer]

        current_route.append(0)  # Return to depot after the last customer
        routes.append(current_route)

        # Update heuristics matrix based on edges in feasible routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i + 1]
                # Incorporate distance into the heuristic
                heuristics_matrix[node1, node2] += 1 / (distance_matrix[node1, node2] + 1e-6) # Avoid division by zero
                heuristics_matrix[node2, node1] += 1 / (distance_matrix[node2, node1] + 1e-6)  # Assuming symmetry

    # Normalize heuristics matrix
    heuristics_matrix = heuristics_matrix / num_samples

    return heuristics_matrix
