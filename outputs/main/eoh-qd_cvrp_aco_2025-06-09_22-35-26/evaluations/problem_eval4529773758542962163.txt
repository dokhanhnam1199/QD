import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs an initial solution, then iteratively perturbs and optimizes it using a variable neighborhood search combined with stochastic acceptance to avoid local optima, returning a matrix representing edge frequencies in accepted solutions as a heuristic guide.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 100

    def calculate_route_demand(route):
        return sum(demands[i] for i in route)

    def construct_initial_solution():
        unvisited = set(range(1, n))
        routes = []
        current_route = [0]
        current_demand = 0

        while unvisited:
            best_node = None
            min_dist = float('inf')
            
            for node in unvisited:
                dist = distance_matrix[current_route[-1]][node]
                if dist < min_dist and current_demand + demands[node] <= capacity:
                    min_dist = dist
                    best_node = node

            if best_node is None:
                routes.append(current_route + [0])
                current_route = [0]
                current_demand = 0
                continue

            current_route.append(best_node)
            current_demand += demands[best_node]
            unvisited.remove(best_node)
        
        routes.append(current_route + [0])
        return routes

    def calculate_total_distance(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance

    def two_opt_swap(route, i, k):
        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
        return new_route

    def improve_route(routes):
        improved_routes = routes[:]
        
        for route_index in range(len(improved_routes)):
            route = improved_routes[route_index][:]
            best_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route) - 1))
            
            improved = True
            while improved:
                improved = False
                for i in range(1, len(route) - 2):
                    for k in range(i + 1, len(route) - 1):
                        new_route = two_opt_swap(route, i, k)
                        new_distance = sum(distance_matrix[new_route[j]][new_route[j+1]] for j in range(len(new_route) - 1))
                        
                        if new_distance < best_distance:
                            improved_routes[route_index] = new_route
                            route = new_route[:]
                            best_distance = new_distance
                            improved = True
                            break
                    if improved:
                        break
        return improved_routes
    
    def perturb_solution(routes):
        perturbed_routes = []
        for route in routes:
            if len(route) > 3:
                # Apply random 2-opt swap
                i = np.random.randint(1, len(route) - 2)
                k = np.random.randint(i + 1, len(route) - 1)
                new_route = two_opt_swap(route, i, k)
                perturbed_routes.append(new_route)
            else:
                perturbed_routes.append(route[:])  # Create a copy to avoid modifying the original
        return perturbed_routes


    initial_solution = construct_initial_solution()
    best_solution = improve_route(initial_solution)
    best_distance = calculate_total_distance(best_solution)

    for _ in range(num_samples):
        perturbed_solution = perturb_solution(best_solution)
        improved_solution = improve_route(perturbed_solution)
        new_distance = calculate_total_distance(improved_solution)

        # Stochastic acceptance criterion (Metropolis-Hastings)
        delta = new_distance - best_distance
        temperature = 1.0 # You can anneal this over time for better results
        acceptance_probability = np.exp(-delta / temperature) if delta > 0 else 1.0

        if np.random.rand() < acceptance_probability:
            best_solution = improved_solution
            best_distance = new_distance

        for route in best_solution:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i]][route[i+1]] += 1
                heuristics_matrix[route[i+1]][route[i]] += 1

    return heuristics_matrix
