import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by iteratively improving a set of initial random solutions using a guided local search approach, penalizing edges present in high-cost solutions and rewarding edges present in low-cost solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 500
    num_solutions = 50
    penalty_factor = 0.1

    solutions = []
    for _ in range(num_solutions):
        route = list(range(1, n))
        random.shuffle(route)
        
        vehicle_routes = []
        current_route = []
        current_demand = 0

        for node in route:
            if current_demand + demands[node] <= capacity:
                current_route.append(node)
                current_demand += demands[node]
            else:
                vehicle_routes.append(current_route)
                current_route = [node]
                current_demand = demands[node]
        vehicle_routes.append(current_route)
        solutions.append(vehicle_routes)

    def calculate_cost(routes):
      total_cost = 0
      for route in routes:
        route_with_depot = [0] + route + [0]
        for i in range(len(route_with_depot) - 1):
          total_cost += distance_matrix[route_with_depot[i], route_with_depot[i+1]]
      return total_cost

    for _ in range(num_iterations):
        # Select a random solution
        idx = random.randint(0, num_solutions-1)
        routes = solutions[idx]

        # Calculate the cost of the current solution
        current_cost = calculate_cost(routes)

        # Generate a neighbor by randomly swapping two customers in different routes
        neighbor_routes = [route[:] for route in routes]
        
        if len(neighbor_routes) > 1:
          route_index1 = random.randint(0, len(neighbor_routes)-1)
          route_index2 = random.randint(0, len(neighbor_routes)-1)

          if len(neighbor_routes[route_index1]) > 0 and len(neighbor_routes[route_index2]) > 0:

            customer_index1 = random.randint(0, len(neighbor_routes[route_index1])-1)
            customer_index2 = random.randint(0, len(neighbor_routes[route_index2])-1)

            customer1 = neighbor_routes[route_index1][customer_index1]
            customer2 = neighbor_routes[route_index2][customer_index2]

            neighbor_routes[route_index1][customer_index1] = customer2
            neighbor_routes[route_index2][customer_index2] = customer1
        
        #Check capacity feasibility for new routes
        neighbor_feasible = True
        for route in neighbor_routes:
          route_demand = sum([demands[node] for node in route])
          if route_demand > capacity:
            neighbor_feasible = False
            break
        
        if neighbor_feasible:
          neighbor_cost = calculate_cost(neighbor_routes)
        else:
          neighbor_cost = float('inf') # Mark as infeasible

        # Update heuristics matrix based on solution quality
        if neighbor_cost < current_cost:
            # Reward edges in the better solution
            for route in neighbor_routes:
                route_with_depot = [0] + route + [0]
                for i in range(len(route_with_depot) - 1):
                    heuristics_matrix[route_with_depot[i], route_with_depot[i+1]] += 1
                    heuristics_matrix[route_with_depot[i+1], route_with_depot[i]] += 1
            
            #Replace the old solution
            solutions[idx] = neighbor_routes
        else:
          # Penalize edges in the worse solution
            for route in routes:
                route_with_depot = [0] + route + [0]
                for i in range(len(route_with_depot) - 1):
                    heuristics_matrix[route_with_depot[i], route_with_depot[i+1]] -= penalty_factor
                    heuristics_matrix[route_with_depot[i+1], route_with_depot[i]] -= penalty_factor

    return heuristics_matrix
