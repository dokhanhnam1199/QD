import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs solutions by adding edges based on a combination of distance and pheromone-like values, updating the pheromone values based on the quality of the constructed solutions.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) * 1e-6  # Initialize with a small value
    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)
    alpha = 1.0  # Importance of pheromone
    beta = 2.0  # Importance of distance
    rho = 0.1  # Evaporation rate
    Q = 100.0  # Pheromone deposit constant
    num_iterations = 100

    for iteration in range(num_iterations):
        routes = []
        unvisited = set(range(1, n))
        current_route = [0]
        current_capacity = capacity

        while unvisited:
            probabilities = np.zeros(n)
            for j in range(1, n):
                if j in unvisited:
                    probabilities[j] = (pheromone_matrix[current_route[-1], j]**alpha) / (distance_matrix[current_route[-1], j]**beta)
            
            if np.sum(probabilities) == 0:
                next_node = None
            else:
                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(range(1, n), p=probabilities[1:])
                next_node = next_node + 1

                if demands[next_node] <= current_capacity and next_node in unvisited:
                    current_route.append(next_node)
                    current_capacity -= demands[next_node]
                    unvisited.remove(next_node)
                else:
                    routes.append(current_route + [0])
                    current_route = [0]
                    current_capacity = capacity
        
        routes.append(current_route + [0])
        
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]

        # Update pheromones
        delta_pheromone = Q / total_distance if total_distance > 0 else 0
        for route in routes:
            for i in range(len(route) - 1):
                pheromone_matrix[route[i], route[i+1]] = (1 - rho) * pheromone_matrix[route[i], route[i+1]] + rho * delta_pheromone
                pheromone_matrix[route[i+1], route[i]] = pheromone_matrix[route[i], route[i+1]]

        # Update heuristics based on pheromones
        heuristics_matrix = pheromone_matrix / distance_matrix
        max_value = np.max(heuristics_matrix)
        if max_value > 0:
            heuristics_matrix /= max_value

    return heuristics_matrix
