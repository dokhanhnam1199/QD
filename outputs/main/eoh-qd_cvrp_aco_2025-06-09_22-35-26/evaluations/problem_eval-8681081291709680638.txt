import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by iteratively refining routes using a combination of random insertion and local search, favoring edges that lead to capacity-feasible and shorter routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000

    for _ in range(num_iterations):
        # Initialize a random route
        unvisited_nodes = list(range(1, n))
        routes = [[0]]
        current_capacity = 0

        while unvisited_nodes:
            next_node = random.choice(unvisited_nodes)
            if current_capacity + demands[next_node] <= capacity:
                routes[-1].append(next_node)
                current_capacity += demands[next_node]
                unvisited_nodes.remove(next_node)
            else:
                routes[-1].append(0)
                routes.append([0])
                current_capacity = 0
        routes[-1].append(0)

        # Local search (swap within route) - attempt to shorten the route
        for route in routes:
            for i in range(1, len(route) - 1):
                for j in range(i + 1, len(route) - 1):
                    # Swap i and j
                    temp_route = route[:]
                    temp_route[i], temp_route[j] = temp_route[j], temp_route[i]
                    
                    # Check if the swap reduces the distance
                    current_distance = distance_matrix[route[i-1], route[i]] + distance_matrix[route[j], route[j+1]] + sum(distance_matrix[temp_route[k-1], temp_route[k]] for k in range(1, len(temp_route)))
                    swapped_distance = distance_matrix[temp_route[i-1], temp_route[i]] + distance_matrix[temp_route[j], temp_route[j+1]] + sum(distance_matrix[route[k-1], route[k]] for k in range(1, len(route)))
                    
                    
                    if current_distance > swapped_distance : # and self.is_feasible_route(temp_route, demands, capacity):
                        route[:] = temp_route[:] # update route if the swapped distance is smaller
                

        # Update heuristics matrix based on edges in the refined routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1  # Symmetry

    # Normalize the heuristics matrix
    heuristics_matrix /= num_iterations

    return heuristics_matrix
