import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a Monte Carlo tree search approach to explore the solution space and build a heuristic matrix based on the value of states (partial routes) explored.}"""
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_simulations = 500

    def calculate_route_cost(route):
        cost = 0
        for i in range(len(route) - 1):
            cost += distance_matrix[route[i], route[i+1]]
        return cost

    def simulate(state, visited, current_load, routes):
        if len(visited) == n:
            state.append(0)
            routes.append(state)
            return calculate_route_cost(state), routes

        possible_next_nodes = [i for i in range(1, n) if i not in visited and demands[i] + current_load <= capacity]
        
        if not possible_next_nodes:
            state.append(0)
            routes.append(state)
            return simulate([0], visited, 0, routes) 
        
        next_node = random.choice(possible_next_nodes)
        new_state = state + [next_node]
        new_visited = visited.copy()
        new_visited.add(next_node)
        new_load = current_load + demands[next_node]
        return simulate(new_state, new_visited, new_load, routes)
    
    total_cost = 0
    all_routes = []
    for _ in range(num_simulations):
        cost, routes = simulate([0], {0}, 0, [])
        total_cost += cost
        all_routes.extend(routes)

    for route in all_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
