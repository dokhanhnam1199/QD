import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm combines random route sampling with a savings heuristic to create a heuristic matrix that favors edges present in high-quality, capacity-feasible routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # 1. Generate a random initial route (all customers served directly from the depot)
        routes = [[0, i, 0] for i in range(1, n)]

        # 2. Savings heuristic: iteratively merge routes based on savings
        improved = True
        while improved:
            improved = False
            best_savings = -1
            best_i, best_j = -1, -1

            for i in range(len(routes)):
                for j in range(i + 1, len(routes)):
                    # Calculate savings from merging routes i and j
                    savings = distance_matrix[routes[i][-2], 0] + distance_matrix[0, routes[j][1]] - distance_matrix[routes[i][-2], routes[j][1]]

                    # Check capacity constraint for merged route
                    combined_route = routes[i][:-1] + routes[j][1:]
                    total_demand = sum(demands[node] for node in combined_route[1:-1])
                    if total_demand <= capacity and savings > best_savings:
                        best_savings = savings
                        best_i, best_j = i, j

            if best_savings > 0:
                # Merge the routes
                routes[best_i] = routes[best_i][:-1] + routes[best_j][1:]
                del routes[best_j]
                improved = True

        # Calculate the total distance of the routes
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]

        # Update the heuristics matrix based on route quality
        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1.0 / total_distance
                heuristics_matrix[route[i+1], route[i]] += 1.0 / total_distance

    # Normalize the heuristics matrix
    max_value = np.max(heuristics_matrix)
    if max_value > 0:
        heuristics_matrix /= max_value

    return heuristics_matrix
