import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs an initial feasible solution using a greedy approach, iteratively improves it via stochastic sampling of edge swaps, and returns a matrix representing the frequency of each edge's appearance in sampled solutions as a heuristic indicator.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 100

    def calculate_route_demand(route):
        return sum(demands[i] for i in route)

    def construct_initial_solution():
        unvisited = set(range(1, n))
        routes = []
        current_route = [0]
        current_demand = 0

        while unvisited:
            best_node = None
            min_dist = float('inf')
            
            for node in unvisited:
                dist = distance_matrix[current_route[-1]][node]
                if dist < min_dist and current_demand + demands[node] <= capacity:
                    min_dist = dist
                    best_node = node

            if best_node is None:
                routes.append(current_route + [0])
                current_route = [0]
                current_demand = 0
                continue

            current_route.append(best_node)
            current_demand += demands[best_node]
            unvisited.remove(best_node)
        
        routes.append(current_route + [0])
        return routes

    def calculate_total_distance(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i]][route[i+1]]
        return total_distance

    def two_opt_swap(route, i, k):
        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]
        return new_route

    def improve_route(routes):
        improved_routes = routes[:]
        
        for route_index in range(len(improved_routes)):
            route = improved_routes[route_index][:]
            best_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route) - 1))
            
            improved = True
            while improved:
                improved = False
                for i in range(1, len(route) - 2):
                    for k in range(i + 1, len(route) - 1):
                        new_route = two_opt_swap(route, i, k)
                        new_distance = sum(distance_matrix[new_route[j]][new_route[j+1]] for j in range(len(new_route) - 1))
                        
                        if new_distance < best_distance:
                            improved_routes[route_index] = new_route
                            route = new_route[:]
                            best_distance = new_distance
                            improved = True
                            break
                    if improved:
                        break
        return improved_routes
    

    initial_solution = construct_initial_solution()
    best_solution = improve_route(initial_solution)

    for _ in range(num_samples):
        
        sampled_routes = []
        for route in best_solution:
            
            if len(route) > 3:
                i = np.random.randint(1,len(route) -2)
                k = np.random.randint(i+1,len(route)-1)
                
                new_route = two_opt_swap(route, i, k)
                sampled_routes.append(new_route)
            else:
                sampled_routes.append(route)
                
        
        sampled_routes = improve_route(sampled_routes)

        
        if calculate_total_distance(sampled_routes) < calculate_total_distance(best_solution):
            best_solution = sampled_routes

        for route in sampled_routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i]][route[i+1]] += 1
                heuristics_matrix[route[i+1]][route[i]] += 1

    return heuristics_matrix
