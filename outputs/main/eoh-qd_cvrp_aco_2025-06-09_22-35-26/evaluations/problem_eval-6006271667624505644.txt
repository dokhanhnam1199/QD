import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses stochastic solution sampling with an insertion heuristic, biased towards shorter distances and lower demand utilization, to estimate the probability of each edge being in a good CVRP solution, using these probabilities as heuristics.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        unvisited_nodes = set(range(1, n))
        vehicle_tours = []
        current_vehicle_tour = [0]
        current_load = 0

        while unvisited_nodes:
            # If the current tour is full, start a new one
            if current_load == capacity:
                current_vehicle_tour.append(0)
                vehicle_tours.append(current_vehicle_tour)
                current_vehicle_tour = [0]
                current_load = 0
            
            # Calculate insertion costs for each unvisited node
            insertion_costs = {}
            for node in unvisited_nodes:
                if current_load + demands[node] <= capacity:
                    min_insertion_cost = float('inf')
                    best_insertion_index = -1
                    for i in range(len(current_vehicle_tour)):
                        cost = distance_matrix[current_vehicle_tour[i-1], node] + distance_matrix[node, current_vehicle_tour[i]] - distance_matrix[current_vehicle_tour[i-1], current_vehicle_tour[i]]
                        if cost < min_insertion_cost:
                            min_insertion_cost = cost
                            best_insertion_index = i

                    insertion_costs[node] = (min_insertion_cost, best_insertion_index)
                else:
                    insertion_costs[node] = (float('inf'), -1)

            # Select the node with the lowest insertion cost
            best_node = None
            min_cost = float('inf')
            for node, (cost, _) in insertion_costs.items():
                if cost < min_cost:
                    min_cost = cost
                    best_node = node
            
            # If all insertions have infinite costs, start a new route
            if best_node is None or min_cost == float('inf'):
                current_vehicle_tour.append(0)
                vehicle_tours.append(current_vehicle_tour)
                current_vehicle_tour = [0]
                current_load = 0
                continue
            
            # Insert the best node into the current tour
            insertion_index = insertion_costs[best_node][1]
            current_vehicle_tour.insert(insertion_index, best_node)
            current_load += demands[best_node]
            unvisited_nodes.remove(best_node)

        # Close the last tour
        current_vehicle_tour.append(0)
        vehicle_tours.append(current_vehicle_tour)

        # Update heuristics based on edges in the tour
        for tour in vehicle_tours:
            for i in range(len(tour) - 1):
                heuristics_matrix[tour[i], tour[i+1]] += 1
                heuristics_matrix[tour[i+1], tour[i]] += 1

    # Normalize the heuristic matrix
    heuristics_matrix /= num_samples

    return heuristics_matrix
