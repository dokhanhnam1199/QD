import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs solutions by iteratively inserting unrouted customers into the best possible position within existing routes based on a cost-saving criterion, using a stochastic acceptance probability to diversify the search.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100

    for _ in range(num_samples):
        unrouted_customers = list(range(1, n))
        routes = [[0] for _ in range(1)]  # Start with one route containing only the depot
        route_demands = [0]
        temperature = 100.0  # Initial temperature for simulated annealing

        while unrouted_customers:
            customer_to_insert = random.choice(unrouted_customers)
            best_route_index = -1
            best_insertion_index = -1
            best_cost_saving = -float('inf')

            for route_index, route in enumerate(routes):
                if route_demands[route_index] + demands[customer_to_insert] <= capacity:
                    for insertion_index in range(1, len(route)):  # Insert after depot
                        cost_saving = (distance_matrix[route[insertion_index - 1]][route[insertion_index]] -
                                        distance_matrix[route[insertion_index - 1]][customer_to_insert] -
                                        distance_matrix[customer_to_insert][route[insertion_index]])

                        if cost_saving > best_cost_saving:
                            best_cost_saving = cost_saving
                            best_route_index = route_index
                            best_insertion_index = insertion_index
            
            if best_route_index != -1:
                #Accept the solution based on simulated annealing
                acceptance_probability = np.exp(best_cost_saving / temperature)
                if random.random() < acceptance_probability:
                    routes[best_route_index].insert(best_insertion_index, customer_to_insert)
                    route_demands[best_route_index] += demands[customer_to_insert]
                    unrouted_customers.remove(customer_to_insert)

            # If no suitable insertion point is found, create a new route.
            else:
                
                routes.append([0, customer_to_insert])
                route_demands.append(demands[customer_to_insert])
                unrouted_customers.remove(customer_to_insert)

        # Add return to depot at the end of each route.
        for route in routes:
            route.append(0)

        # Update heuristics matrix based on edges used in the routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1][node2] += 1
                heuristics_matrix[node2][node1] += 1

        temperature *= 0.95 #Reduce temperature for next sample
    
    heuristics_matrix /= num_samples
    return heuristics_matrix
