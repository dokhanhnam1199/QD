import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm learns edge importance by iteratively generating partial routes, evaluating their cost and feasibility, and reinforcing edges in successful routes while penalizing those in unsuccessful ones.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones((n, n))  # Initialize with ones to allow for penalization
    num_iterations = 1000
    learning_rate = 0.1

    for _ in range(num_iterations):
        # Start with a random node (excluding the depot)
        current_node = random.randint(1, n - 1)
        current_route = [0, current_node]
        current_load = demands[current_node]

        # Iteratively extend the route
        while True:
            # Find potential next nodes, excluding already visited ones
            potential_nodes = [i for i in range(1, n) if i not in current_route]

            if not potential_nodes:
                current_route.append(0)  # Return to depot if no more unvisited nodes
                break

            # Calculate attractiveness of each potential node based on heuristics and distance
            attractiveness = []
            for node in potential_nodes:
                attractiveness.append(heuristics_matrix[current_node, node] / distance_matrix[current_node, node])

            # Select the next node probabilistically
            probabilities = np.array(attractiveness) / np.sum(attractiveness)
            next_node = np.random.choice(potential_nodes, p=probabilities)

            # Check capacity constraint
            if current_load + demands[next_node] <= capacity:
                current_route.append(next_node)
                current_load += demands[next_node]
                current_node = next_node
            else:
                current_route.append(0)  # Return to depot if capacity exceeded
                current_load = 0
                current_node = 0 # Back to depot

                potential_nodes = [i for i in range(1, n) if i not in current_route] # Find the next customer from depot

                if not potential_nodes:
                    current_route.append(0)
                    break

                # Calculate attractiveness of each potential node based on heuristics and distance
                attractiveness = []
                for node in potential_nodes:
                    attractiveness.append(heuristics_matrix[current_node, node] / distance_matrix[current_node, node])

                # Select the next node probabilistically
                probabilities = np.array(attractiveness) / np.sum(attractiveness)
                next_node = np.random.choice(potential_nodes, p=probabilities)

                current_route.append(next_node)
                current_load += demands[next_node]
                current_node = next_node

        # Evaluate the route (simplified: just check feasibility)
        route_feasible = True
        route_load = 0
        temp_route = [current_route[0]]
        for i in range(1, len(current_route)):
            if current_route[i] != 0:
                if route_load + demands[current_route[i]] <= capacity:
                    route_load += demands[current_route[i]]
                    temp_route.append(current_route[i])
                else:
                    route_feasible = False
                    break
            else:
                route_load = 0
                temp_route.append(current_route[i])

        # Update heuristics matrix based on route performance
        for i in range(len(current_route) - 1):
            node1 = current_route[i]
            node2 = current_route[i + 1]
            if route_feasible:
                heuristics_matrix[node1, node2] *= (1 + learning_rate)  # Reinforce
                heuristics_matrix[node2, node1] *= (1 + learning_rate) #Reinforce
            else:
                heuristics_matrix[node1, node2] *= (1 - learning_rate)  # Penalize
                heuristics_matrix[node2, node1] *= (1 - learning_rate)  # Penalize

        #Ensure the matrix is non-negative and has a reasonable upper bound
        heuristics_matrix = np.maximum(heuristics_matrix, 0.001) #prevent division by zero in later stages
        heuristics_matrix = np.minimum(heuristics_matrix, 10)

    return heuristics_matrix
