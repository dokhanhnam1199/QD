import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs solutions incrementally by prioritizing edges that connect nodes with high demand and are relatively short, while ensuring capacity constraints are met.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Calculate a demand-weighted distance matrix
    demand_weights = np.outer(demands, demands)
    weighted_distance_matrix = distance_matrix + 1e-6 # Avoid division by zero
    weighted_distance_matrix = demand_weights / weighted_distance_matrix
    
    num_vehicles = 0
    visited = [False] * n
    visited[0] = True
    
    while not all(visited):
        num_vehicles += 1
        current_node = 0
        current_load = 0
        
        while True:
            # Find the nearest unvisited node considering demand and distance
            best_node = -1
            best_score = -1
            
            for j in range(1, n):
                if not visited[j] and current_load + demands[j] <= capacity:
                    score = weighted_distance_matrix[current_node, j]
                    if score > best_score:
                        best_score = score
                        best_node = j
            
            if best_node == -1:
                # No suitable node found, return to depot
                heuristics_matrix[current_node, 0] += 1
                heuristics_matrix[0, current_node] += 1
                break
            else:
                # Visit the best node
                heuristics_matrix[current_node, best_node] += 1
                heuristics_matrix[best_node, current_node] += 1
                visited[best_node] = True
                current_load += demands[best_node]
                current_node = best_node
        
    return heuristics_matrix
