import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm combines stochastic solution sampling with a clustering approach based on node demands and proximity to the depot to generate promising edges for the CVRP solution.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 500

    # Clustering based on demand and proximity
    num_clusters = 3
    clusters = [[] for _ in range(num_clusters)]

    for node in range(1, n):
        # Calculate a score based on demand and distance to depot
        score = demands[node] + distance_matrix[0, node]  # Higher score means further from depot
        cluster_index = int(score % num_clusters)
        clusters[cluster_index].append(node)

    for _ in range(num_samples):
        routes = []
        remaining_nodes = set(range(1, n))
        while remaining_nodes:
            # Select a random cluster
            cluster_index = random.randint(0, num_clusters - 1)
            cluster_nodes = [node for node in clusters[cluster_index] if node in remaining_nodes]

            if not cluster_nodes:
                continue

            current_route = []
            current_demand = 0
            
            # Add nodes from the selected cluster to the route
            while cluster_nodes and current_demand + min(demands[node] for node in cluster_nodes) <= capacity:
                # Choose the nearest node from remaining nodes in cluster
                nearest_node = min(cluster_nodes, key=lambda node: distance_matrix[0 if not current_route else current_route[-1], node])
                
                if current_demand + demands[nearest_node] <= capacity:
                    current_route.append(nearest_node)
                    current_demand += demands[nearest_node]
                    remaining_nodes.remove(nearest_node)
                    cluster_nodes.remove(nearest_node)
                else:
                    break
            
            if current_route:
                routes.append(current_route)

        # Update heuristics matrix based on the generated routes
        for route in routes:
            route_with_depot = [0] + route + [0]
            for i in range(len(route_with_depot) - 1):
                heuristics_matrix[route_with_depot[i], route_with_depot[i+1]] += 1
                heuristics_matrix[route_with_depot[i+1], route_with_depot[i]] += 1

    return heuristics_matrix
