import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a nearest neighbor solution, then iteratively perturbs and refines the solution by re-assigning customers between routes to improve the overall cost.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # 1. Initial Nearest Neighbor Solution
    routes = []
    unvisited = set(range(1, n))
    current_route = [0]
    current_capacity = 0

    while unvisited:
        nearest_customer = None
        min_dist = float('inf')
        
        for customer in unvisited:
            dist = distance_matrix[current_route[-1]][customer]
            if dist < min_dist and current_capacity + demands[customer] <= capacity:
                min_dist = dist
                nearest_customer = customer

        if nearest_customer is not None:
            current_route.append(nearest_customer)
            current_capacity += demands[nearest_customer]
            unvisited.remove(nearest_customer)
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0]
            current_capacity = 0

    current_route.append(0)
    routes.append(current_route)
    
    # 2. Iterative Perturbation and Refinement
    num_iterations = 1000
    for _ in range(num_iterations):
        # a. Select a random route
        if len(routes) > 1:
            route_index = random.randint(0, len(routes) - 1)
        else:
            route_index = 0
            
        route_to_perturb = routes[route_index]
        
        if len(route_to_perturb) <= 2:
            continue # Skip routes with only depot visits.

        # b. Select a random customer from the route (excluding depot)
        customer_index = random.randint(1, len(route_to_perturb) - 2)
        customer_to_move = route_to_perturb[customer_index]

        # c. Remove customer from the current route
        
        route_to_perturb.pop(customer_index)

        # Recalculate route capacities if needed. For simplicity, not recomputing exact cap here.
        # In a full implementation, route capacities would need to be accurately tracked and updated.

        # d. Find the best route to insert the customer into (or create a new route)
        best_route_index = -1
        best_insertion_index = -1
        best_cost_change = float('inf')
        
        for i in range(len(routes)):
            
            temp_route = routes[i]
            
            
            #Check possible insert locations on the route
            for j in range(1, len(temp_route)):
                
                #Check route capacity constraints. Can skip if capacity is always met due to problem structure.
                
                
                #Calculate the cost change from inserting the customer.
                cost_before = distance_matrix[temp_route[j-1]][temp_route[j]]
                cost_after = distance_matrix[temp_route[j-1]][customer_to_move] + distance_matrix[customer_to_move][temp_route[j]]
                cost_change = cost_after - cost_before

                if cost_change < best_cost_change:
                    best_cost_change = cost_change
                    best_route_index = i
                    best_insertion_index = j

        # e. Create a new route if no suitable route is found.  Capacity would need to be checked
        if best_route_index == -1:
            routes.append([0, customer_to_move, 0])
        else:
            routes[best_route_index].insert(best_insertion_index, customer_to_move)
            
        # Clean empty routes
        routes = [r for r in routes if len(r) > 2]

    # 3. Update heuristics matrix based on the refined routes
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
