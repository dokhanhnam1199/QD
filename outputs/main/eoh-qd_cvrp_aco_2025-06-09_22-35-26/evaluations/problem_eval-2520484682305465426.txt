import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge desirability for CVRP by generating random routes, evaluates feasibility and cost, and weights edge frequencies based on the inverse of the route cost, prioritizing edges in cheaper routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        permutation = list(range(1, n))
        random.shuffle(permutation)

        # Create routes based on capacity constraints
        routes = []
        current_route = [0]  # Start at the depot
        current_demand = 0

        for customer in permutation:
            if current_demand + demands[customer] <= capacity:
                current_route.append(customer)
                current_demand += demands[customer]
            else:
                current_route.append(0)  # Return to depot
                routes.append(current_route)
                current_route = [0, customer]  # Start new route from depot
                current_demand = demands[customer]
        
        current_route.append(0) # close the last route
        routes.append(current_route)

        # Calculate the cost of the routes
        total_cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_cost += distance_matrix[route[i]][route[i+1]]
        
        #Weight routes. Cheaper routes have greater weights
        if total_cost > 0:
          route_weight = 1/total_cost
        else:
          route_weight = 1 #Avoid division by zero if total cost somehow is zero


        # Update the heuristics matrix based on the edges used in the route, weighted by route cost
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1][node2] += route_weight
                heuristics_matrix[node2][node1] += route_weight  # Assuming symmetric distance matrix

    # Normalize the heuristics matrix by the number of samples
    total_weight = np.sum(heuristics_matrix)
    if total_weight > 0:
        heuristics_matrix /= total_weight
    else:
        pass

    return heuristics_matrix
