import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm combines stochastic sampling with a clustering approach to identify potentially good edges based on intra-cluster connectivity.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 500
    num_clusters = 5

    for _ in range(num_samples):
        # Cluster customers using k-means
        from sklearn.cluster import KMeans
        kmeans = KMeans(n_clusters=num_clusters, random_state=_) #Use _ as seed

        # Exclude depot from clustering
        customer_indices = np.arange(1, n)
        customer_coordinates = coordinates[1:, :]
        clusters = kmeans.fit_predict(customer_coordinates)

        # Build routes based on clusters
        routes = []
        for cluster_id in range(num_clusters):
            cluster_customers = customer_indices[clusters == cluster_id]
            if len(cluster_customers) > 0:
              
                current_route = [0]  # Start from the depot
                current_capacity = 0
                
                for customer in sorted(cluster_customers, key=lambda x: distance_matrix[0, x]):  #Nearest neighbor within cluster

                    if current_capacity + demands[customer] <= capacity:
                        current_route.append(customer)
                        current_capacity += demands[customer]
                    else:
                        current_route.append(0)  # Return to depot
                        routes.append(current_route)
                        current_route = [0, customer]  # Start a new route
                        current_capacity = demands[customer]

                current_route.append(0) # Close the last route
                routes.append(current_route)
        
        #Evaluate solution feasibility (necessary for checking)
        is_feasible = True
        for route in routes:
            route_demand = sum(demands[i] for i in route)
            if route_demand > capacity:
                is_feasible = False
                break

        # Update heuristics matrix if the solution is feasible
        if is_feasible:
            for route in routes:
                for i in range(len(route) - 1):
                    node1 = route[i]
                    node2 = route[i+1]
                    heuristics_matrix[node1, node2] += 1
                    heuristics_matrix[node2, node1] += 1  # Symmetric

    # Normalize the heuristic matrix
    max_val = np.max(heuristics_matrix)
    if max_val > 0:
        heuristics_matrix /= max_val
    
    return heuristics_matrix
