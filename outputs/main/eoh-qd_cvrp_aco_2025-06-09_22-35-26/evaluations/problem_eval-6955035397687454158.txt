import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines routes by swapping nodes based on a cost-benefit analysis that considers distance and capacity, updating edge frequencies in improved routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100

    # Initialize with a random solution (similar to v1's initial sampling)
    customer_indices = np.random.permutation(range(1, n))
    routes = []
    current_route = [0]
    current_load = 0
    for customer in customer_indices:
        if current_load + demands[customer] <= capacity:
            current_route.append(customer)
            current_load += demands[customer]
        else:
            current_route.append(0)
            routes.append(current_route)
            current_route = [0, customer]
            current_load = demands[customer]
    current_route.append(0)
    routes.append(current_route)

    best_routes = routes[:] # Initialize best routes to be the original routes.

    for iteration in range(num_iterations):
        # Try swapping nodes between routes to improve the solution
        improved = False
        for i in range(len(routes)):
            for j in range(len(routes)):
                if i == j:
                    continue

                route1 = routes[i]
                route2 = routes[j]

                for idx1 in range(1, len(route1) - 1):  # Exclude depot
                    for idx2 in range(1, len(route2) - 1):  # Exclude depot
                        node1 = route1[idx1]
                        node2 = route2[idx2]

                        # Calculate new loads if we swap
                        new_load1 = sum(demands[node] for node in route1 if node != node1) + demands[node2]
                        new_load2 = sum(demands[node] for node in route2 if node != node2) + demands[node1]

                        # Check capacity constraints
                        if new_load1 <= capacity and new_load2 <= capacity:
                            # Calculate the cost change
                            cost_change = (distance_matrix[route1[idx1-1], node2] + distance_matrix[node2, route1[idx1+1]] -
                                           distance_matrix[route1[idx1-1], node1] - distance_matrix[node1, route1[idx1+1]] +
                                           distance_matrix[route2[idx2-1], node1] + distance_matrix[node1, route2[idx2+1]] -
                                           distance_matrix[route2[idx2-1], node2] - distance_matrix[node2, route2[idx2+1]])

                            # Swap if it improves the cost
                            if cost_change < 0:
                                # Perform the swap
                                temp = route1[idx1]
                                route1[idx1] = route2[idx2]
                                route2[idx2] = temp
                                improved = True
                                

        # Update heuristic matrix based on the improved routes
        if improved:
            
            total_cost = 0
            for route in routes:
                for i in range(len(route) - 1):
                    total_cost += distance_matrix[route[i], route[i+1]]

            total_best_cost = 0
            for route in best_routes:
                for i in range(len(route) - 1):
                    total_best_cost += distance_matrix[route[i], route[i+1]]

            if total_cost < total_best_cost: # We found a better solution, so update best_routes
                best_routes = routes[:] # Make copy instead of assigning directly
            

    # After iterations, use the best routes
    for route in best_routes:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize the matrix
    heuristics_matrix = heuristics_matrix / (num_iterations * len(best_routes)) # Normalize with #iterations * #of best routes because we are running iterations within the loop

    return heuristics_matrix
