import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm generates candidate routes using a combination of nearest neighbor and random selection, evaluates them based on cost and feasibility, and updates a heuristic matrix to favor edges present in good solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        # Start with a random node
        start_node = random.randint(1, n - 1)
        current_node = 0
        route = [0]
        current_load = 0
        unvisited = set(range(1, n))
        
        # Construct a route using a mix of nearest neighbor and random selection
        while unvisited:
            # Find the nearest neighbors among unvisited nodes
            distances = {node: distance_matrix[current_node][node] for node in unvisited}
            nearest_neighbors = sorted(distances.items(), key=lambda item: item[1])
            
            # Select a neighbor with a probability inversely proportional to its distance
            probabilities = [1.0 / (dist + 1e-6) for _, dist in nearest_neighbors]
            probabilities /= np.sum(probabilities)

            # Consider either best neighbor or random neighbor
            if random.random() < 0.5: # balance between exploitation and exploration
              next_node = nearest_neighbors[0][0] 
            else: 
              next_node = random.choices([node for node, _ in nearest_neighbors], probabilities)[0] 

            if current_load + demands[next_node] <= capacity:
                route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)
                current_node = next_node
            else:
                route.append(0)
                route.append(next_node)
                current_load = demands[next_node]
                unvisited.remove(next_node)
                current_node = 0
                

        route.append(0)

        # Divide the permutation into routes based on depot visits
        routes = []
        current_route = []
        for node in route:
          current_route.append(node)
          if node == 0 and len(current_route) > 1:
            routes.append(current_route[:-1])
            current_route = [0]
        routes.append(current_route)


        # Calculate the total distance of the solution
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i]][route[i+1]]

        # Update the heuristics matrix
        for route in routes:
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i+1]
                heuristics_matrix[u][v] += 1.0 / total_distance

    return heuristics_matrix
