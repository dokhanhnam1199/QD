import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge desirability for CVRP by generating random routes, evaluates feasibility and cost, and weights edge frequencies by the inverse of the route cost, favoring edges from cheaper routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        permutation = list(range(1, n))
        random.shuffle(permutation)

        # Create routes based on capacity constraints
        routes = []
        current_route = [0]  # Start at the depot
        current_demand = 0

        for customer in permutation:
            if current_demand + demands[customer] <= capacity:
                current_route.append(customer)
                current_demand += demands[customer]
            else:
                current_route.append(0)  # Return to depot
                routes.append(current_route)
                current_route = [0, customer]  # Start new route from depot
                current_demand = demands[customer]
        
        current_route.append(0) # close the last route
        routes.append(current_route)
        

        # Calculate the cost of the routes
        total_cost = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_cost += distance_matrix[route[i]][route[i+1]]

        # Update the heuristics matrix based on the edges used in the route
        # Weight the contribution of each route by the inverse of its cost
        if total_cost > 0:
            weight = 1.0 / total_cost
        else:
            weight = 1.0  # Avoid division by zero. If total_cost is zero, assign weight 1
        
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1][node2] += weight
                heuristics_matrix[node2][node1] += weight  # Assuming symmetric distance matrix

    # Normalize the heuristics matrix by the number of samples
    total_weight = np.sum(heuristics_matrix)
    if total_weight > 0:
        heuristics_matrix /= total_weight
    else:
        pass  # heuristics_matrix remains zero if all routes had zero cost or all routes were infeasible.


    return heuristics_matrix
