import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a Monte Carlo tree search approach to explore the solution space, iteratively building a search tree by simulating random routes and biasing the search towards promising edges based on their frequency in successful routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    exploration_constant = 1.0

    def simulate_route(start_node, unvisited_nodes, current_demand, current_route):
        if not unvisited_nodes:
            return current_route + [0], distance_matrix[current_route[-1]][0] if current_route else 0, True

        best_node = None
        best_score = -float('inf')

        for node in unvisited_nodes:
            score = heuristics_matrix[start_node][node] + exploration_constant * np.sqrt(np.log(num_iterations + 1) / (1 + 1e-6)) # Add small constant to avoid division by zero.

            if score > best_score:
                best_score = score
                best_node = node
                
        if best_node is None:
            best_node = random.choice(unvisited_nodes) # If there isn't enough info, random exploration

        if current_demand + demands[best_node] <= capacity:
            new_unvisited_nodes = unvisited_nodes[:]
            new_unvisited_nodes.remove(best_node)
            new_route = current_route + [best_node]

            return simulate_route(best_node, new_unvisited_nodes, current_demand + demands[best_node], new_route)
        else:
            return current_route + [0], distance_matrix[current_route[-1]][0] if current_route else 0, False # Return to depot

    for _ in range(num_iterations):
        unvisited_nodes = list(range(1, n))
        current_route = [0]
        total_distance = 0
        all_routes = []
        is_feasible = True

        while unvisited_nodes:
            route, dist, feasible = simulate_route(current_route[-1], unvisited_nodes, 0, [0])
            
            if not feasible:
                is_feasible = False
                break
            
            
            new_unvisited_nodes = []
            for node in list(range(1, n)):
                if node not in route:
                    new_unvisited_nodes.append(node)
            
            unvisited_nodes = new_unvisited_nodes
            
            
            sub_route = route[1:]
            if 0 in sub_route:
                depot_index = sub_route.index(0)
                sub_route = sub_route[:depot_index]
            
            all_routes.append([0] + sub_route)

        if is_feasible:
            total_distance = 0
            complete_routes = []
            for route in all_routes:
                route += [0]
                complete_routes.append(route)

            for route in complete_routes:
                for i in range(len(route) - 1):
                    total_distance += distance_matrix[route[i]][route[i+1]]

            if total_distance > 0:
                route_score = 1 / total_distance
                for route in complete_routes:
                    for i in range(len(route) - 1):
                        node1 = route[i]
                        node2 = route[i+1]
                        heuristics_matrix[node1][node2] += route_score
                        heuristics_matrix[node2][node1] += route_score

    return heuristics_matrix
