import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge desirability by repeatedly sampling random routes, evaluating their feasibility and length, and then recording the frequency with which each edge appears in feasible routes weighted by route length, further biasing toward shorter routes and penalizing links to the depot from nearly full routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Generate a random route (permutation of nodes 1 to n-1)
        route = np.random.permutation(np.arange(1, n))
        
        # Split route into feasible sub-routes (vehicle routes)
        vehicle_routes = []
        current_route = []
        current_demand = 0
        
        for node in route:
            if current_demand + demands[node] <= capacity:
                current_route.append(node)
                current_demand += demands[node]
            else:
                vehicle_routes.append(current_route)
                current_route = [node]
                current_demand = demands[node]
                
        if current_route:
            vehicle_routes.append(current_route)
        
        # Calculate total route length
        total_length = 0
        full_route = [0]  # Start from depot
        for vr in vehicle_routes:
            full_route += vr + [0] # depot to vr and back to depot

        for i in range(len(full_route)-1):
             total_length += distance_matrix[full_route[i], full_route[i+1]]

        # Update heuristics matrix based on edges in feasible route and route length
        if vehicle_routes: # Only update if route is feasible
            for vr in vehicle_routes:
                route_len = len(vr)
                if route_len > 0:

                    route_demand = sum([demands[i] for i in vr])
                    # Penalize links to the depot from routes that are close to full
                    depot_penalty = max(0.0, (route_demand / capacity) - 0.8) * 5 

                    if vr[0] !=0:
                         heuristics_matrix[0, vr[0]] += 1.0 / (total_length + 1e-9) * (1-depot_penalty)
                         heuristics_matrix[vr[0], 0] += 1.0 / (total_length + 1e-9) * (1-depot_penalty)
                    for i in range(route_len - 1):
                        heuristics_matrix[vr[i], vr[i+1]] += 1.0 / (total_length + 1e-9)
                        heuristics_matrix[vr[i+1], vr[i]] += 1.0 / (total_length + 1e-9)


    return heuristics_matrix
