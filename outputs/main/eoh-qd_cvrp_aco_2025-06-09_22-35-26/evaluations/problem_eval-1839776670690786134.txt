import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes by probabilistically selecting the next node based on distance and demand, favoring closer, feasible nodes, and updates edge weights based on route inclusion.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    alpha = 1.0  # Parameter to control the influence of distance

    for _ in range(num_iterations):
        # Initialize route construction
        routes = []
        current_route = [0]  # Start at the depot
        current_capacity = 0
        unvisited_nodes = set(range(1, n))

        while unvisited_nodes:
            current_node = current_route[-1]
            # Calculate selection probabilities for unvisited nodes
            probabilities = []
            for next_node in unvisited_nodes:
                if current_capacity + demands[next_node] <= capacity:
                    distance = distance_matrix[current_node, next_node]
                    # probability inversely proportional to distance
                    probability = np.exp(-alpha * distance)
                    probabilities.append((next_node, probability))
                else:
                    probabilities.append((next_node, 0))  # Cannot visit due to capacity

            # Normalize probabilities
            total_probability = sum(p for _, p in probabilities)
            if total_probability > 0:
                normalized_probabilities = [(node, p / total_probability) for node, p in probabilities]
            else:
                # If no feasible nodes, return to depot
                routes.append(current_route + [0])  # Complete current route by returning to depot
                current_route = [0]
                current_capacity = 0
                break

            # Select the next node probabilistically
            if total_probability > 0:
                next_node = random.choices([node for node, _ in normalized_probabilities], weights=[p for _, p in normalized_probabilities], k=1)[0]
            else:
                next_node = None

            if next_node is None:
                routes.append(current_route + [0])  # Complete current route by returning to depot
                current_route = [0]
                current_capacity = 0
                unvisited_nodes = set(range(1, n)) - set([node for route in routes for node in route])
                continue


            # Add the selected node to the current route
            current_route.append(next_node)
            current_capacity += demands[next_node]
            unvisited_nodes.remove(next_node)

            # If the capacity is full, return to the depot
            if not unvisited_nodes or all(current_capacity + demands[node] > capacity for node in unvisited_nodes):
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_capacity = 0
                unvisited_nodes = set(range(1, n)) - set([node for route in routes for node in route])

        # Update heuristics matrix based on edges in the routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i + 1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1  # Assuming symmetry

    # Normalize heuristics matrix
    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix
