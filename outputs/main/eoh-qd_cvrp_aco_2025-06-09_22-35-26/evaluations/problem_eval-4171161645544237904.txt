import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by iteratively building routes using a nearest neighbor approach with stochastic selection, penalizing edges that lead to capacity violations and rewarding edges in feasible routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000
    penalty_factor = 10.0 
    reward_factor = 1.0

    for _ in range(num_samples):
        current_node = 0  # Start at the depot
        current_route = [0]
        current_load = 0
        unvisited = set(range(1, n))
        routes = []

        while unvisited:
            # Find nearest neighbors
            nearest_neighbors = []
            for neighbor in unvisited:
                nearest_neighbors.append((neighbor, distance_matrix[current_node][neighbor]))
            nearest_neighbors.sort(key=lambda x: x[1])

            # Stochastic selection of next node among k-nearest
            k = min(5, len(nearest_neighbors))  # Consider top k nearest neighbors
            selected_neighbor_index = random.randint(0, k - 1)
            next_node = nearest_neighbors[selected_neighbor_index][0]

            if current_load + demands[next_node] <= capacity:
                current_route.append(next_node)
                current_load += demands[next_node]
                heuristics_matrix[current_node][next_node] += reward_factor
                heuristics_matrix[next_node][current_node] += reward_factor

                unvisited.remove(next_node)
                current_node = next_node
            else:
                # Capacity violation: Return to depot
                current_route.append(0)
                routes.append(current_route)

                # Penalize edges leading to overload
                heuristics_matrix[current_node][next_node] -= penalty_factor
                heuristics_matrix[next_node][current_node] -= penalty_factor
                
                #Start new route
                current_route = [0]
                routes.append(current_route)
                current_node = 0
                current_load = 0

        current_route.append(0)
        routes.append(current_route)
        
        # Normalize route for complete routes
        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1][node2] += reward_factor
                heuristics_matrix[node2][node1] += reward_factor

    # Normalize the heuristics matrix
    heuristics_matrix /= num_samples

    return heuristics_matrix
