import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge desirability by repeatedly sampling random routes, evaluating their feasibility and length, and then recording the frequency with which each edge appears in feasible routes, biasing toward shorter routes, and using a node insertion score based on distance and remaining capacity.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000

    for _ in range(num_samples):
        # Start with an empty route for each vehicle
        vehicle_routes = [[]]
        remaining_capacity = [capacity]
        unvisited_nodes = list(range(1, n))  # All nodes except depot

        while unvisited_nodes:
            # Choose a random unvisited node
            node_idx = np.random.randint(0, len(unvisited_nodes))
            node = unvisited_nodes[node_idx]

            # Find the best route to insert the node into
            best_route_idx = -1
            best_insertion_cost = np.inf

            for i in range(len(vehicle_routes)):
                if remaining_capacity[i] >= demands[node]:
                    # Insertion cost: distance to the previous and next nodes
                    if vehicle_routes[i]:
                        insertion_cost = distance_matrix[vehicle_routes[i][-1], node] + distance_matrix[node, 0] - distance_matrix[vehicle_routes[i][-1], 0]
                    else:
                        insertion_cost = distance_matrix[0, node] + distance_matrix[node, 0]

                    if insertion_cost < best_insertion_cost:
                        best_insertion_cost = insertion_cost
                        best_route_idx = i

            if best_route_idx != -1:
                # Insert the node into the best route
                vehicle_routes[best_route_idx].append(node)
                remaining_capacity[best_route_idx] -= demands[node]
                unvisited_nodes.pop(node_idx)
            else:
                # Create a new route if no suitable route is found
                vehicle_routes.append([node])
                remaining_capacity.append(capacity - demands[node])
                unvisited_nodes.pop(node_idx)

        # Calculate the total length of the route
        total_length = 0
        for route in vehicle_routes:
            current_node = 0  # Start from the depot
            for node in route:
                total_length += distance_matrix[current_node, node]
                current_node = node
            total_length += distance_matrix[current_node, 0]  # Return to the depot

        # Update the heuristics matrix
        for route in vehicle_routes:
            current_node = 0
            for node in route:
                heuristics_matrix[current_node, node] += 1.0 / (total_length + 1e-9)
                heuristics_matrix[node, current_node] += 1.0 / (total_length + 1e-9)
                current_node = node
            heuristics_matrix[current_node, 0] += 1.0 / (total_length + 1e-9)
            heuristics_matrix[0, current_node] += 1.0 / (total_length + 1e-9)
    return heuristics_matrix
