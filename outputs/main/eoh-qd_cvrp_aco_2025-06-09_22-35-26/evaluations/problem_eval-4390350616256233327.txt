import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively builds solutions by probabilistically selecting edges based on their cost and the current state of the solution, favoring edges that connect unvisited nodes and lead to feasible routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    alpha = 0.5 # Weight for distance in probability calculation

    for _ in range(num_iterations):
        current_route = []
        current_demand = 0
        unvisited_nodes = set(range(1, n))
        current_node = 0  # Start at the depot

        while unvisited_nodes:
            # Calculate probabilities for each possible next node
            probabilities = []
            candidates = list(unvisited_nodes)
            for next_node in candidates:
                if current_demand + demands[next_node] <= capacity:
                    # Probability based on distance, prioritize shorter distances
                    probabilities.append(np.exp(-alpha * distance_matrix[current_node, next_node]))
                else:
                    probabilities.append(0) # Cannot exceed vehicle capacity

            # Normalize probabilities
            if sum(probabilities) > 0:
                probabilities = np.array(probabilities) / sum(probabilities)
            else:
                # If no feasible next node exists, return to depot
                probabilities = [1/len(candidates)] * len(candidates)

            # Choose the next node probabilistically
            try:
                next_node_index = np.random.choice(len(candidates), p=probabilities)
            except:
                next_node_index = random.randint(0,len(candidates)-1)
            next_node = candidates[next_node_index]

            # Update the route and state
            current_route.append((current_node, next_node))
            current_demand += demands[next_node]
            unvisited_nodes.remove(next_node)
            current_node = next_node

        # Return to depot from last node
        current_route.append((current_node, 0))
        
        # Update the heuristics matrix
        for edge in current_route:
            heuristics_matrix[edge[0], edge[1]] += 1
            heuristics_matrix[edge[1], edge[0]] += 1

    return heuristics_matrix
