{
     "algorithm": "This algorithm constructs an initial feasible solution using a greedy approach, iteratively improves it via stochastic sampling of edge swaps, and returns a matrix representing the frequency of each edge's appearance in sampled solutions as a heuristic indicator.",
     "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs an initial feasible solution using a greedy approach, iteratively improves it via stochastic sampling of edge swaps, and returns a matrix representing the frequency of each edge's appearance in sampled solutions as a heuristic indicator.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100\n\n    def calculate_route_demand(route):\n        return sum(demands[i] for i in route)\n\n    def construct_initial_solution():\n        unvisited = set(range(1, n))\n        routes = []\n        current_route = [0]\n        current_demand = 0\n\n        while unvisited:\n            best_node = None\n            min_dist = float('inf')\n            \n            for node in unvisited:\n                dist = distance_matrix[current_route[-1]][node]\n                if dist < min_dist and current_demand + demands[node] <= capacity:\n                    min_dist = dist\n                    best_node = node\n\n            if best_node is None:\n                routes.append(current_route + [0])\n                current_route = [0]\n                current_demand = 0\n                continue\n\n            current_route.append(best_node)\n            current_demand += demands[best_node]\n            unvisited.remove(best_node)\n        \n        routes.append(current_route + [0])\n        return routes\n\n    def calculate_total_distance(routes):\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i]][route[i+1]]\n        return total_distance\n\n    def two_opt_swap(route, i, k):\n        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n        return new_route\n\n    def improve_route(routes):\n        improved_routes = routes[:]\n        \n        for route_index in range(len(improved_routes)):\n            route = improved_routes[route_index][:]\n            best_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route) - 1))\n            \n            improved = True\n            while improved:\n                improved = False\n                for i in range(1, len(route) - 2):\n                    for k in range(i + 1, len(route) - 1):\n                        new_route = two_opt_swap(route, i, k)\n                        new_distance = sum(distance_matrix[new_route[j]][new_route[j+1]] for j in range(len(new_route) - 1))\n                        \n                        if new_distance < best_distance:\n                            improved_routes[route_index] = new_route\n                            route = new_route[:]\n                            best_distance = new_distance\n                            improved = True\n                            break\n                    if improved:\n                        break\n        return improved_routes\n    \n\n    initial_solution = construct_initial_solution()\n    best_solution = improve_route(initial_solution)\n\n    for _ in range(num_samples):\n        \n        sampled_routes = []\n        for route in best_solution:\n            \n            if len(route) > 3:\n                i = np.random.randint(1,len(route) -2)\n                k = np.random.randint(i+1,len(route)-1)\n                \n                new_route = two_opt_swap(route, i, k)\n                sampled_routes.append(new_route)\n            else:\n                sampled_routes.append(route)\n                \n        \n        sampled_routes = improve_route(sampled_routes)\n\n        \n        if calculate_total_distance(sampled_routes) < calculate_total_distance(best_solution):\n            best_solution = sampled_routes\n\n        for route in sampled_routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i]][route[i+1]] += 1\n                heuristics_matrix[route[i+1]][route[i]] += 1\n\n    return heuristics_matrix",
     "objective": 15.68183,
     "other_inf": null,
     "SLOC": 34.0,
     "cyclomatic_complexity": 10.0,
     "halstead": 203.5602880225656
}