[
     {
          "algorithm": "This algorithm constructs an initial feasible solution using a greedy approach, iteratively improves it via stochastic sampling of edge swaps, and returns a matrix representing the frequency of each edge's appearance in sampled solutions as a heuristic indicator.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs an initial feasible solution using a greedy approach, iteratively improves it via stochastic sampling of edge swaps, and returns a matrix representing the frequency of each edge's appearance in sampled solutions as a heuristic indicator.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 100\n\n    def calculate_route_demand(route):\n        return sum(demands[i] for i in route)\n\n    def construct_initial_solution():\n        unvisited = set(range(1, n))\n        routes = []\n        current_route = [0]\n        current_demand = 0\n\n        while unvisited:\n            best_node = None\n            min_dist = float('inf')\n            \n            for node in unvisited:\n                dist = distance_matrix[current_route[-1]][node]\n                if dist < min_dist and current_demand + demands[node] <= capacity:\n                    min_dist = dist\n                    best_node = node\n\n            if best_node is None:\n                routes.append(current_route + [0])\n                current_route = [0]\n                current_demand = 0\n                continue\n\n            current_route.append(best_node)\n            current_demand += demands[best_node]\n            unvisited.remove(best_node)\n        \n        routes.append(current_route + [0])\n        return routes\n\n    def calculate_total_distance(routes):\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i]][route[i+1]]\n        return total_distance\n\n    def two_opt_swap(route, i, k):\n        new_route = route[:i] + route[i:k+1][::-1] + route[k+1:]\n        return new_route\n\n    def improve_route(routes):\n        improved_routes = routes[:]\n        \n        for route_index in range(len(improved_routes)):\n            route = improved_routes[route_index][:]\n            best_distance = sum(distance_matrix[route[i]][route[i+1]] for i in range(len(route) - 1))\n            \n            improved = True\n            while improved:\n                improved = False\n                for i in range(1, len(route) - 2):\n                    for k in range(i + 1, len(route) - 1):\n                        new_route = two_opt_swap(route, i, k)\n                        new_distance = sum(distance_matrix[new_route[j]][new_route[j+1]] for j in range(len(new_route) - 1))\n                        \n                        if new_distance < best_distance:\n                            improved_routes[route_index] = new_route\n                            route = new_route[:]\n                            best_distance = new_distance\n                            improved = True\n                            break\n                    if improved:\n                        break\n        return improved_routes\n    \n\n    initial_solution = construct_initial_solution()\n    best_solution = improve_route(initial_solution)\n\n    for _ in range(num_samples):\n        \n        sampled_routes = []\n        for route in best_solution:\n            \n            if len(route) > 3:\n                i = np.random.randint(1,len(route) -2)\n                k = np.random.randint(i+1,len(route)-1)\n                \n                new_route = two_opt_swap(route, i, k)\n                sampled_routes.append(new_route)\n            else:\n                sampled_routes.append(route)\n                \n        \n        sampled_routes = improve_route(sampled_routes)\n\n        \n        if calculate_total_distance(sampled_routes) < calculate_total_distance(best_solution):\n            best_solution = sampled_routes\n\n        for route in sampled_routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i]][route[i+1]] += 1\n                heuristics_matrix[route[i+1]][route[i]] += 1\n\n    return heuristics_matrix",
          "objective": 15.68183,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm uses stochastic solution sampling with a nearest neighbor heuristic to estimate the probability of each edge being in a good CVRP solution, using these probabilities as heuristics.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm uses stochastic solution sampling with a nearest neighbor heuristic to estimate the probability of each edge being in a good CVRP solution, using these probabilities as heuristics.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of sample solutions to generate\n\n    for _ in range(num_samples):\n        # Generate a random start node (excluding depot)\n        start_node = np.random.choice(range(1, n))\n\n        # Nearest neighbor tour construction\n        current_node = start_node\n        unvisited_nodes = set(range(1, n))\n        unvisited_nodes.remove(current_node)\n        tour = [0, current_node]\n        current_load = demands[current_node]\n        vehicle_tours = []\n        current_vehicle_tour = [0, current_node]\n\n        while unvisited_nodes:\n            # Find the nearest unvisited node\n            nearest_node = None\n            min_distance = float('inf')\n            for neighbor in unvisited_nodes:\n                dist = distance_matrix[current_node, neighbor]\n                if dist < min_distance:\n                    min_distance = dist\n                    nearest_node = neighbor\n\n            # Check if adding the nearest node exceeds capacity\n            if current_load + demands[nearest_node] <= capacity:\n                # Add to current tour\n                tour.append(nearest_node)\n                current_vehicle_tour.append(nearest_node)\n                current_load += demands[nearest_node]\n                current_node = nearest_node\n                unvisited_nodes.remove(nearest_node)\n            else:\n                # Return to depot\n                tour.append(0)\n                current_vehicle_tour.append(0)\n                vehicle_tours.append(current_vehicle_tour)\n\n                # Start a new tour from the depot with the nearest node\n                tour.append(nearest_node)\n                current_vehicle_tour = [0, nearest_node]\n\n                current_load = demands[nearest_node]\n                current_node = nearest_node\n                unvisited_nodes.remove(nearest_node)\n\n        # Close the last tour\n        tour.append(0)\n        current_vehicle_tour.append(0)\n        vehicle_tours.append(current_vehicle_tour)\n\n        # Update heuristics based on edges in the tour\n        tour = [node for tour_item in vehicle_tours for node in tour_item]\n\n        for i in range(len(tour) - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1  # Account for symmetry\n\n    # Normalize the heuristic matrix\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 18.3864,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by generating random routes, applying a capacity check, and updating an edge importance matrix based on route validity and length.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm estimates edge inclusion probabilities by generating random routes, applying a capacity check, and updating an edge importance matrix based on route validity and length.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of random routes to sample\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customer indices (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct a route based on the random permutation\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                current_capacity = 0\n                current_route.append(customer)\n                current_capacity += demands[customer]\n        \n        current_route.append(0) # Return to depot after visiting all customers\n\n        # Update the heuristics matrix based on the route\n        route_length = 0\n        for i in range(len(current_route) - 1):\n            node1 = current_route[i]\n            node2 = current_route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            route_length += distance_matrix[node1, node2]\n\n        # Normalize heuristics based on route length (shorter routes are preferred)\n        for i in range(len(current_route) - 1):\n            node1 = current_route[i]\n            node2 = current_route[i+1]\n            heuristics_matrix[node1, node2] /= route_length\n\n    return heuristics_matrix",
          "objective": 26.0692,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then uses the frequency of each edge appearing in feasible, low-cost routes to estimate its desirability.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then uses the frequency of each edge appearing in feasible, low-cost routes to estimate its desirability.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000  # Number of random routes to sample\n    top_k = 10 # Consider the top k best routes\n\n    feasible_routes = []\n\n    for _ in range(num_samples):\n        # Generate a random route\n        route = list(range(1, n))\n        random.shuffle(route)\n\n        # Check feasibility and calculate cost\n        current_route = []\n        current_demand = 0\n        total_cost = 0\n        is_feasible = True\n\n        vehicle_routes = []\n\n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                # Vehicle returns to depot\n                if len(current_route) > 0:\n                    total_cost += distance_matrix[0, current_route[0]]\n                    for i in range(len(current_route) - 1):\n                        total_cost += distance_matrix[current_route[i], current_route[i+1]]\n                    total_cost += distance_matrix[current_route[-1], 0]\n                    vehicle_routes.append(current_route)\n\n                else:\n                    is_feasible = False\n                    break\n\n                current_route = [node]\n                current_demand = demands[node]\n\n        # Handle the last vehicle route\n        if is_feasible:\n            if len(current_route) > 0:\n                total_cost += distance_matrix[0, current_route[0]]\n                for i in range(len(current_route) - 1):\n                    total_cost += distance_matrix[current_route[i], current_route[i + 1]]\n                total_cost += distance_matrix[current_route[-1], 0]\n                vehicle_routes.append(current_route)\n            feasible_routes.append((vehicle_routes, total_cost))\n\n\n    # Rank the routes by cost\n    feasible_routes.sort(key=lambda x: x[1])\n\n    # Update heuristics matrix based on the best routes\n    for vehicle_routes, _ in feasible_routes[:min(top_k, len(feasible_routes))]:  # Iterate through top k routes\n        for route in vehicle_routes:\n            route_with_depot = [0] + route + [0]\n            for i in range(len(route_with_depot) - 1):\n                heuristics_matrix[route_with_depot[i], route_with_depot[i+1]] += 1\n                heuristics_matrix[route_with_depot[i+1], route_with_depot[i]] += 1\n\n    return heuristics_matrix",
          "objective": 26.47434,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm estimates edge desirability by repeatedly sampling random routes, evaluating their feasibility and length, and then recording the frequency with which each edge appears in feasible routes weighted by route length, further biasing toward shorter routes and penalizing links to the depot from nearly full routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge desirability by repeatedly sampling random routes, evaluating their feasibility and length, and then recording the frequency with which each edge appears in feasible routes weighted by route length, further biasing toward shorter routes and penalizing links to the depot from nearly full routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random route (permutation of nodes 1 to n-1)\n        route = np.random.permutation(np.arange(1, n))\n        \n        # Split route into feasible sub-routes (vehicle routes)\n        vehicle_routes = []\n        current_route = []\n        current_demand = 0\n        \n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                vehicle_routes.append(current_route)\n                current_route = [node]\n                current_demand = demands[node]\n                \n        if current_route:\n            vehicle_routes.append(current_route)\n        \n        # Calculate total route length\n        total_length = 0\n        full_route = [0]  # Start from depot\n        for vr in vehicle_routes:\n            full_route += vr + [0] # depot to vr and back to depot\n\n        for i in range(len(full_route)-1):\n             total_length += distance_matrix[full_route[i], full_route[i+1]]\n\n        # Update heuristics matrix based on edges in feasible route and route length\n        if vehicle_routes: # Only update if route is feasible\n            for vr in vehicle_routes:\n                route_len = len(vr)\n                if route_len > 0:\n\n                    route_demand = sum([demands[i] for i in vr])\n                    # Penalize links to the depot from routes that are close to full\n                    depot_penalty = max(0.0, (route_demand / capacity) - 0.8) * 5 \n\n                    if vr[0] !=0:\n                         heuristics_matrix[0, vr[0]] += 1.0 / (total_length + 1e-9) * (1-depot_penalty)\n                         heuristics_matrix[vr[0], 0] += 1.0 / (total_length + 1e-9) * (1-depot_penalty)\n                    for i in range(route_len - 1):\n                        heuristics_matrix[vr[i], vr[i+1]] += 1.0 / (total_length + 1e-9)\n                        heuristics_matrix[vr[i+1], vr[i]] += 1.0 / (total_length + 1e-9)\n\n\n    return heuristics_matrix",
          "objective": 26.62825,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000  # Number of random routes to sample\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Build routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from the depot\n                current_capacity = demands[customer]\n\n        current_route.append(0)  # Return to depot for the last route\n        routes.append(current_route)\n\n        # Check feasibility (all customers visited)\n        visited = set()\n        for route in routes:\n            visited.update(route)\n        \n        if len(visited) == n:  # All customers visited\n\n            # Update heuristics matrix based on edges in routes\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += 1\n                    heuristics_matrix[node2, node1] += 1  # Symmetry\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.2358,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates them based on distance and capacity constraints, and then constructs a heuristic matrix representing the frequency with which each edge appears in feasible and good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples multiple random routes, evaluates them based on distance and capacity constraints, and then constructs a heuristic matrix representing the frequency with which each edge appears in feasible and good solutions.}\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.arange(1, n)\n        np.random.shuffle(customer_indices)\n\n        routes = []\n        current_route = [0]  # Start from the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_capacity = demands[customer]\n\n        current_route.append(0) # Close the last route\n        routes.append(current_route)\n\n\n        # Evaluate the solution: Check for feasibility and calculate total distance\n        is_feasible = True\n        total_distance = 0\n        for route in routes:\n            route_demand = sum(demands[i] for i in route)\n            if route_demand > capacity:\n                is_feasible = False\n                break\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i+1]]\n\n\n        # Update heuristics matrix if the solution is feasible\n        if is_feasible:\n            # A simple score, can be improved with more sophisticated methods\n            score = 1 / (total_distance + 1e-6)  # Avoid division by zero\n\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += score\n                    heuristics_matrix[node2, node1] += score #Symmetric\n    \n    #Normalize so that each entry is between 0 and 1\n    max_val = np.max(heuristics_matrix)\n    if max_val > 0:\n      heuristics_matrix = heuristics_matrix / max_val\n\n    return heuristics_matrix",
          "objective": 29.45327,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm generates multiple random routes, evaluates their feasibility and cost based on capacity constraints, and then calculates a heuristic matrix that indicates the frequency with which each edge appears in feasible solutions, weighted by solution quality.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates multiple random routes, evaluates their feasibility and cost based on capacity constraints, and then calculates a heuristic matrix that indicates the frequency with which each edge appears in feasible solutions, weighted by solution quality.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_permutation = random.sample(range(1, n), n - 1)\n\n        # Divide the permutation into routes based on capacity\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        \n        for customer in customer_permutation:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to the depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_load = demands[customer]\n        \n        current_route.append(0) # Return to depot after last customer\n        routes.append(current_route)\n        \n        # Calculate the total distance of the solution (sum of all routes)\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i]][route[i+1]]\n\n        # Update the heuristics matrix if the solution is feasible (always feasible due to construction)\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u][v] += 1.0 / total_distance  # Weight by solution quality (inverse of distance)\n\n    return heuristics_matrix",
          "objective": 29.50064,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm samples many random routes, checks their feasibility based on capacity, and averages the edge occurrences in feasible routes to create a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, checks their feasibility based on capacity, and averages the edge occurrences in feasible routes to create a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        random.shuffle(route)\n        \n        current_route = [0]\n        current_load = 0\n        feasible = True\n        routes = []\n\n        for node in route:\n            if current_load + demands[node] <= capacity:\n                current_route.append(node)\n                current_load += demands[node]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, node]\n                current_load = demands[node]\n        current_route.append(0)\n        routes.append(current_route)\n        \n        for r in routes:\n            for i in range(len(r) - 1):\n                heuristics_matrix[r[i], r[i+1]] += 1\n                heuristics_matrix[r[i+1], r[i]] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 29.52918,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by sampling random routes, evaluating their feasibility with respect to capacity constraints, and accumulating edge counts across feasible routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge inclusion probabilities by sampling random routes, evaluating their feasibility with respect to capacity constraints, and accumulating edge counts across feasible routes.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customer indices\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct routes based on the random permutation\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n        \n        current_route.append(0) # Terminate at the depot\n        routes.append(current_route)\n\n        # Update heuristics matrix based on the sampled routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n\n    return heuristics_matrix",
          "objective": 29.54342,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm estimates edge importance by sampling random routes, evaluating their feasibility and length, and updating edge scores based on frequency in good routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge importance by sampling random routes, evaluating their feasibility and length, and updating edge scores based on frequency in good routes.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct routes based on capacity constraint\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route at the depot\n                current_demand = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Calculate route length\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i]][route[i+1]]\n\n        # Update heuristics matrix based on route length\n        if total_distance > 0: #Avoid potential divide by zero\n            route_score = 1 / total_distance \n\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1][node2] += route_score\n                    heuristics_matrix[node2][node1] += route_score\n\n    return heuristics_matrix",
          "objective": 29.56177,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm samples a set of random routes respecting capacity constraints, and then counts how often each edge appears in the sampled routes to estimate its desirability.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a set of random routes respecting capacity constraints, and then counts how often each edge appears in the sampled routes to estimate its desirability.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of random routes to sample\n\n    for _ in range(num_samples):\n        unvisited = list(range(1, n))  # Nodes excluding depot\n        routes = []\n        current_route = [0]  # Start at depot\n        current_load = 0\n\n        while unvisited:\n            # Select next node randomly\n            next_node = random.choice(unvisited)\n            \n            if current_load + demands[next_node] <= capacity:\n                current_route.append(next_node)\n                current_load += demands[next_node]\n                unvisited.remove(next_node)\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0]\n                current_load = 0\n\n        current_route.append(0)  # Return to depot\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in the sampled routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 29.71216,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility and cost, and uses this information to create a heuristic matrix favoring edges that appear in good solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and uses this information to create a heuristic matrix favoring edges that appear in good solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random route (permutation of customers)\n        customer_indices = np.random.permutation(range(1, n))\n\n        # Split the route into feasible vehicle routes\n        routes = []\n        current_route = [0]\n        current_demand = 0\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_demand = demands[customer]\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Calculate the total distance of the routes\n        total_distance = 0\n        feasible = True\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i+1]]\n\n        # Update the heuristics matrix based on route quality\n        if feasible:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    heuristics_matrix[route[i], route[i+1]] += 1.0 / total_distance\n                    heuristics_matrix[route[i+1], route[i]] += 1.0 / total_distance\n\n    # Normalize the heuristics matrix\n    max_value = np.max(heuristics_matrix)\n    if max_value > 0:\n        heuristics_matrix /= max_value\n\n    return heuristics_matrix",
          "objective": 29.77411,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm estimates the probability of each edge being in a good CVRP solution by sampling random feasible routes and counting edge occurrences.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates the probability of each edge being in a good CVRP solution by sampling random feasible routes and counting edge occurrences.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000  # Number of sample routes to generate\n\n    for _ in range(num_samples):\n        route = []\n        remaining_nodes = list(range(1, n))  # Exclude depot\n        current_load = 0\n        current_route = [0]  # Start from depot\n\n        while remaining_nodes:\n            # Select a random node from remaining nodes\n            next_node = random.choice(remaining_nodes)\n            \n            # Check capacity constraint\n            if current_load + demands[next_node] <= capacity:\n                current_route.append(next_node)\n                current_load += demands[next_node]\n                remaining_nodes.remove(next_node)\n            else:\n                # Return to depot\n                current_route.append(0)\n                route.append(current_route)\n                \n                # Start a new route\n                current_route = [0]\n                current_load = 0\n\n        # Add last route if not empty\n        if len(current_route) > 1:\n            current_route.append(0)\n            route.append(current_route)\n            \n        # Update heuristics matrix\n        for r in route:\n            for i in range(len(r) - 1):\n                node1 = r[i]\n                node2 = r[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix\n\n    # Normalize heuristics matrix by the number of samples\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 29.79052,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility and cost, and uses the frequency with which each edge appears in feasible routes to build a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and uses the frequency with which each edge appears in feasible routes to build a heuristic matrix.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        permutation = np.random.permutation(np.arange(1, n))\n        \n        # Build routes based on the permutation\n        routes = []\n        current_route = [0]\n        current_demand = 0\n        \n        for customer in permutation:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_demand = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Evaluate the feasibility and cost of routes\n        total_demand = 0\n        is_feasible = True\n        for route in routes:\n            route_demand = sum([demands[i] for i in route])\n            if route_demand > capacity:\n                is_feasible = False\n                break\n            total_demand += route_demand\n            \n        #Update heuristics matrix if the route is feasible \n        if is_feasible:\n          for route in routes:\n            for i in range(len(route) - 1):\n              u = route[i]\n              v = route[i+1]\n              heuristics_matrix[u, v] += 1\n              heuristics_matrix[v, u] += 1\n\n    # Normalize the matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n    \n    return heuristics_matrix",
          "objective": 29.8529,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm estimates edge desirability for CVRP by generating random routes, evaluating feasibility and cost, and then averaging edge frequencies across feasible and high-quality solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge desirability for CVRP by generating random routes, evaluating feasibility and cost, and then averaging edge frequencies across feasible and high-quality solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        permutation = list(range(1, n))\n        random.shuffle(permutation)\n\n        # Create routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in permutation:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_demand = demands[customer]\n        \n        current_route.append(0) # close the last route\n        routes.append(current_route)\n        \n\n        # Calculate the cost of the routes\n        total_cost = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_cost += distance_matrix[route[i]][route[i+1]]\n\n        # Update the heuristics matrix based on the edges used in the route\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1][node2] += 1\n                heuristics_matrix[node2][node1] += 1  # Assuming symmetric distance matrix\n\n    # Normalize the heuristics matrix by the number of samples\n    heuristics_matrix /= num_samples\n\n    return heuristics_matrix",
          "objective": 29.95119,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm generates many random feasible routes and uses the frequency of each edge appearing in these routes to estimate its desirability, resulting in a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm generates many random feasible routes and uses the frequency of each edge appearing in these routes to estimate its desirability, resulting in a heuristic matrix.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_permutation = list(range(1, n))\n        random.shuffle(customer_permutation)\n\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n\n        for customer in customer_permutation:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_load = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n        \n        # Update the heuristic matrix based on the edges in the route\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Since it's undirected\n\n    return heuristics_matrix",
          "objective": 29.96313,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility based on capacity constraints, and then assigns higher heuristic values to edges that appear more frequently in feasible routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility based on capacity constraints, and then assigns higher heuristic values to edges that appear more frequently in feasible routes.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_capacity = demands[customer]\n\n        current_route.append(0)  # Return to depot after the last customer\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i + 1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetry\n\n    # Normalize heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 30.10695,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     },
     {
          "algorithm": "This algorithm estimates edge importance by sampling random routes and penalizing edges used in infeasible routes, rewarding edges used in feasible routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm estimates edge importance by sampling random routes and penalizing edges used in infeasible routes, rewarding edges used in feasible routes.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        random.shuffle(route)\n        \n        current_route = [0]\n        current_load = 0\n        routes = []\n        \n        for node in route:\n            if current_load + demands[node] <= capacity:\n                current_route.append(node)\n                current_load += demands[node]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, node]\n                current_load = demands[node]\n        \n        current_route.append(0)\n        routes.append(current_route)\n        \n        is_feasible = True\n        for r in routes:\n          load = 0\n          for node in r[1:-1]:\n            load += demands[node]\n          if load > capacity:\n            is_feasible = False\n            break\n\n        if is_feasible:\n            for r in routes:\n                for i in range(len(r) - 1):\n                    node1 = r[i]\n                    node2 = r[i+1]\n                    heuristics_matrix[node1, node2] += 1\n                    heuristics_matrix[node2, node1] += 1\n        else:\n            for r in routes:\n                for i in range(len(r) - 1):\n                    node1 = r[i]\n                    node2 = r[i+1]\n                    heuristics_matrix[node1, node2] -= 1\n                    heuristics_matrix[node2, node1] -= 1\n    return heuristics_matrix",
          "objective": 30.16567,
          "other_inf": null,
          "SLOC": 34.0,
          "cyclomatic_complexity": 10.0,
          "halstead": 203.5602880225656
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility and cost, and then calculates edge frequencies in feasible routes, using these frequencies as heuristics.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility and cost, and then calculates edge frequencies in feasible routes, using these frequencies as heuristics.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Build routes based on capacity constraint\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        \n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_load = demands[customer]\n\n        current_route.append(0) # End the last route by returning to depot\n        routes.append(current_route)\n\n        # Check feasibility (essential for correctness)\n        feasible = True\n        for route in routes:\n            load = 0\n            for node in route:\n                load += demands[node]\n            if load > capacity:\n                feasible = False\n                break\n        \n        # Update heuristics matrix if the solution is feasible\n        if feasible:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += 1\n                    heuristics_matrix[node2, node1] += 1\n\n    # Normalize the matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 30.45737,
          "other_inf": null,
          "SLOC": 45.0,
          "cyclomatic_complexity": 9.0,
          "halstead": 127.43782540330756
     }
]