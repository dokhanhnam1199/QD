{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. It strongly penalizes bins that cannot fit the item,\n    boosts bins with the smallest gaps, and is sensitive to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Linear decreasing priority based on remaining capacity\n    priority = np.maximum(0, bins_remain_cap - item) / item\n\n    # Strongly penalize bins that cannot fit the item\n    can_fit_item_mask = bins_remain_cap >= item\n    priority[~can_fit_item_mask] -= 10  # Strong penalty for bins that cannot fit the item\n\n    # Boost bins with the smallest gaps after placing the item\n    if np.any(can_fit_item_mask):\n        gaps = bins_remain_cap[can_fit_item_mask] - item\n        if len(gaps) > 1:\n            smallest_two_gaps = np.partition(gaps, 1)[:2]\n            smallest_gap = smallest_two_gaps[0]\n            second_smallest_gap = smallest_two_gaps[1]\n            smallest_idx = np.where(np.isclose(gaps, smallest_gap))[0]\n            second_smallest_idx = np.where(np.isclose(gaps, second_smallest_gap))[0]\n            for idx in smallest_idx:\n                priority[can_fit_item_mask][idx] += 2  # Boost for the smallest gap\n            for idx in second_smallest_idx:\n                priority[can_fit_item_mask][idx] += 1  # Lesser boost for the second smallest gap\n\n    return priority\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation gives a high priority to bins that are closer to being full\n    while ensuring that bins where the item cannot fit receive a very low priority.\n    The priority score is calculated based on the remaining capacity relative to the\n    original capacity of the bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Original bin capacities, assuming all bins start with the same capacity\n    bins_original_cap = np.max(bins_remain_cap)\n    \n    # Penalty for bins with less remaining capacity than the item (can't fit the item)\n    penalties = (bins_remain_cap < item) * -np.inf\n    \n    # Calculate priority: moving closer to full has a priority proportional to the fullness\n    priority = 1 - (bins_remain_cap / bins_original_cap)\n    \n    # Apply penalties to bins where the item can't be placed\n    priority += penalties\n    \n    # Invert so that bins closer to full but feasible get the highest priority\n    priority = -priority\n    \n    return priority\n\n[Reflection]\nPrioritize bins closer to full, penalize infeasible placements, use relative fullness for consistency.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}