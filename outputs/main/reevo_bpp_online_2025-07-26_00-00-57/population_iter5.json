[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. Bins that are closer to being full get higher\n    priority, with a strong penalty for bins that cannot fit the item. It focuses on\n    filling bins with the second smallest gap first to encourage less fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority with remaining capacity relative to item size\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Penalize bins that cannot fit the item heavily\n    priority[bins_remain_cap < item] -= 10\n    \n    # Encourage filling the bin with the second smallest gap\n    valid_gaps = bins_remain_cap - item\n    valid_gaps_indices = np.argsort(valid_gaps)\n    \n    # Check if there's a valid second smallest gap\n    if len(valid_gaps_indices) > 1:\n        second_smallest_gap_index = valid_gaps_indices[1]\n        priority[second_smallest_gap_index] += 5  # can be tuned\n\n    return priority",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins with the second smallest gap after\n    accounting for the item size, penalizes bins that cannot fit the item directly,\n    and normalizes the priority scores by the item size to ensure consistency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority with remaining capacity relative to item size\n    priority = (bins_remain_cap - item) / item\n    \n    # Penalize bins that cannot fit the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    # Encourage filling the bin with the second smallest gap\n    valid_gaps = bins_remain_cap - item\n    valid_gaps_indices = valid_gaps.argsort()\n    \n    # Check if there's a valid second smallest gap\n    if len(valid_gaps_indices) > 1:\n        second_smallest_gap_index = valid_gaps_indices[1]\n        priority[second_smallest_gap_index] += 3  # can be tuned\n\n    return priority",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation normalizes the remaining capacities, prioritizes bins that are closer to being full,\n    penalizes bins with large gaps after adding the item, and makes bins infeasible if they cannot fit the item.\n    It aims to balance these factors effectively to minimize the number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Normalize the remaining capacities\n    max_cap = bins_remain_cap.max()\n    normalized_cap = bins_remain_cap / max_cap\n\n    # Base priority is higher for bins with less remaining capacity (closer to being full)\n    base_priority = (1 - normalized_cap)\n\n    # Penalize bins that have less capacity than the item itself (make them infeasible)\n    feasibility_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n\n    # Penalize bins with large gaps after adding the item\n    gap_penalty_weight = 0.5  # Adjust this weight to balance between fullness and gap minimization\n    gap_penalty = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / max_cap, 0) * gap_penalty_weight\n\n    # Combine penalties and base priority into a final score\n    priority_score = base_priority - gap_penalty + feasibility_penalty\n\n    return priority_score",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This implementation normalizes the remaining capacities, penalizes bins with large gaps after adding the item,\n    and ensures feasibility explicitly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Normalize the remaining capacities\n    max_cap = bins_remain_cap.max()\n    normalized_cap = bins_remain_cap / max_cap\n\n    # Base priority is higher for bins with less remaining capacity (closer to being full)\n    base_priority = (1 - normalized_cap)\n\n    # Penalize bins that have less capacity than the item itself (make them infeasible)\n    feasibility_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n\n    # Penalize bins with large gaps after adding the item\n    gap_penalty = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / max_cap, 0)\n\n    # Combine penalties and base priority into a final score\n    priority_score = base_priority - gap_penalty + feasibility_penalty\n\n    return priority_score",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins that are closer to being full but ensures\n    that items are only placed into bins where they can fit. It penalizes bins that\n    cannot fit the item and normalizes the priorities based on the original bin capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalty for bins with less remaining capacity than the item (can't fit the item)\n    penalties = np.where(bins_remain_cap < item, -np.inf, 0)\n    \n    # Calculate priority: moving closer to full has a priority proportional to the fullness\n    priority = 1 - (bins_remain_cap / bins_remain_cap.max())\n    \n    # Apply penalties to bins where the item can't be placed\n    priority += penalties\n    \n    # Inverse so that closer to full but feasible slots get highest priority\n    priority = -priority\n    \n    return priority",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers both the remaining capacity and the number of\n    bins used using a weighted score. It prioritizes bins that are near full but can\n    still fit the item, penalizes bins that cannot fit the item, and boosts bins\n    that have a close-to-subtle gap to reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores\n    priority = np.full_like(bins_remain_cap, -np.inf)\n    \n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_capacity = bins_remain_cap - item\n    \n    # Mark bins that can fit the item\n    can_fit_item_mask = remaining_capacity >= 0\n    \n    # Assign high priority to bins that can fit the item, scaled by remaining capacity\n    priority[can_fit_item_mask] = remaining_capacity[can_fit_item_mask] / bins_remain_cap[can_fit_item_mask]\n    \n    # Penalize bins that cannot fit the item (already set to -np.inf)\n    \n    # Boost bins that have a close-to-subtle gap to reduce fragmentation\n    if np.any(can_fit_item_mask):\n        sorted_indices = np.argsort(remaining_capacity[can_fit_item_mask])\n        if len(sorted_indices) > 1:\n            subtle_gap = remaining_capacity[can_fit_item_mask][sorted_indices[1]]  # Second smallest gap\n        else:\n            subtle_gap = remaining_capacity[can_fit_item_mask][sorted_indices[0]]  # Only one option if only one bin can fit the item\n        \n        # Boost bins that have this subtle gap\n        subtle_gap_indices = np.where(np.isclose(remaining_capacity, subtle_gap))[0]\n        priority[subtle_gap_indices] += 1\n    \n    return priority",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation focuses on balancing remaining capacity, usage of bins, and penalties.\n    Bins that can accommodate the item with less remaining capacity (closer to being full) receive\n    higher priority, while bins that cannot fit the item receive an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Penalize bins that have less capacity than the item itself with a very low priority\n    feasibility_mask = bins_remain_cap >= item\n\n    # Calculate base priority: higher for bins with less remaining capacity\n    base_priority = np.where(feasibility_mask, 1 - (bins_remain_cap - item) / bins_remain_cap.max(), 0)\n\n    # Penalize underused bins to avoid leftover bins, scaled by the difference from maximum capacity\n    usage_discount = np.where(feasibility_mask, (bins_remain_cap.max() - bins_remain_cap) / bins_remain_cap.max(), 0) * 0.1\n\n    # Combine base priority and usage discount\n    priority_score = base_priority - usage_discount\n\n    # Assign very low priority (-np.inf) to infeasible bins\n    priority_score[~feasibility_mask] = -np.inf\n\n    return priority_score",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation normalizes the remaining capacities, penalizes gaps, prioritizes bins that are closer to being full,\n    and ensures item feasibility. It aims to reduce fragmentation and avoid underutilized bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Normalize the remaining capacities\n    max_cap = bins_remain_cap.max()\n    if max_cap == 0:\n        normalized_cap = bins_remain_cap  # To handle edge case where all bins are full\n    else:\n        normalized_cap = bins_remain_cap / max_cap\n\n    # Base priority is higher for bins with less remaining capacity (closer to being full)\n    base_priority = (1 - normalized_cap)\n\n    # Penalize bins that have less capacity than the item itself (make them infeasible)\n    feasibility_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n\n    # Penalize bins with large gaps after adding the item\n    gap_penalty = np.where(bins_remain_cap >= item, (bins_remain_cap - item) / max_cap, 0)\n\n    # Combine penalties and base priority into a final score\n    priority_score = base_priority - gap_penalty + feasibility_penalty\n\n    return priority_score",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation prioritizes bins that are closer to being full while ensuring\n    that bins where the item cannot fit receive a very low priority. The priority score\n    is calculated based on the remaining capacity relative to the original capacity of the bins.\n    It also boosts bins with the smallest gaps after placing the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Original bin capacities, assuming all bins start with the same capacity\n    bins_original_cap = np.max(bins_remain_cap)\n    \n    # Penalty for bins with less remaining capacity than the item (can't fit the item)\n    penalties = (bins_remain_cap < item) * -np.inf\n    \n    # Calculate priority: moving closer to full has a priority proportional to the fullness\n    priority = 1 - (bins_remain_cap / bins_original_cap)\n    \n    # Apply penalties to bins where the item can't be placed\n    priority += penalties\n    \n    # Invert so that bins closer to full but feasible get the highest priority\n    priority = -priority\n    \n    # Boost bins with the smallest gaps after placing the item\n    feasible_caps = bins_remain_cap[bins_remain_cap >= item]\n    if len(feasible_caps) > 0:\n        gaps = feasible_caps - item\n        smallest_two_gaps = np.partition(gaps, 1)[:2]\n        smallest_gap = smallest_two_gaps[0]\n        second_smallest_gap = smallest_two_gaps[1]\n        smallest_indices = np.where(np.isclose(bins_remain_cap - item, smallest_gap))[0]\n        second_smallest_indices = np.where(np.isclose(bins_remain_cap - item, second_smallest_gap))[0]\n        priority[smallest_indices] += 2  # Boost for the smallest gap\n        priority[second_smallest_indices] += 1  # Lesser boost for the second smallest gap\n\n    return priority",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation focuses on filling bins that have the second smallest gap\n    after placing the item, penalizing bins that cannot fit the item, and using\n    relative remaining capacities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    import numpy as np\n\n    # Initialize priority with remaining capacity relative to item size\n    priority = np.maximum(0, bins_remain_cap - item) / item\n    \n    # Penalize bins that cannot fit the item\n    priority[bins_remain_cap < item] -= 2\n    \n    # Encourage filling the bin with the second smallest gap\n    valid_gaps = bins_remain_cap - item\n    valid_gaps[valid_gaps < 0] = np.inf  # Ignore infeasible gaps\n    sorted_gaps_indices = np.argsort(valid_gaps)\n    \n    # Check if there's a valid second smallest gap\n    if len(sorted_gaps_indices) > 1:\n        second_smallest_gap_index = sorted_gaps_indices[1]\n        priority[second_smallest_gap_index] += 3  # can be tuned\n\n    return priority",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1, in <module>\n    def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\nNameError: name 'np' is not defined\n"
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers the remaining capacity, normalizes capacities,\n    prioritizes bins that are near full, penalizes infeasibility, gaps, and\n    balances priorities while favoring the second smallest gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities\n    normalized_cap = bins_remain_cap / bins_remain_cap.max()\n\n    # Base priority based on remaining normalized capacity\n    base_priority = normalized_cap\n\n    # Penalize bins that have less capacity than the item itself\n    infeasibility_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n\n    # Calculate gaps for second smallest gaps\n    sorted_gaps = np.sort(bins_remain_cap - item)\n    second_smallest_gap = sorted_gaps[1] if len(sorted_gaps) > 1 else np.inf\n    gap_penalty = 1 - np.where(bins_remain_cap - item == second_smallest_gap, 0, 0.1)\n\n    # Combine base priority, infeasibility penalty, and gap penalty\n    priority_score = base_priority + infeasibility_penalty + gap_penalty\n\n    return priority_score",
    "response_id": 0,
    "obj": 149.1822895891504,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers the remaining capacity, normalizes capacities,\n    prioritizes bins that are near full, penalizes infeasibility, and balances\n    priorities while favoring the second smallest gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize remaining capacities\n    normalized_cap = bins_remain_cap / bins_remain_cap.max()\n\n    # Penalize bins that have less capacity than the item itself\n    penalty_infeasibility = np.where(bins_remain_cap < item, -np.inf, 0)\n\n    # Calculate gaps and find the second smallest gap\n    gaps = np.sort(bins_remain_cap - item)\n    gaps = gaps[gaps >= 0]  # only consider feasible gaps\n    second_smallest_gap = gaps[1] if len(gaps) > 1 else gaps[0]\n\n    # Penalize larger gaps, favoring nearly full bins\n    penalty_gap = (bins_remain_cap - item - second_smallest_gap)**2 * -0.01\n\n    # Combine normalized capacity, gap penalty, and infeasibility penalty into a final score\n    priority_score = normalized_cap + penalty_gap + penalty_infeasibility\n\n    return priority_score",
    "response_id": 1,
    "obj": 5.963302752293574,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers normalized remaining capacity, prioritizes bins\n    near full, penalizes infeasibility, penalizes gaps, balances priorities, and\n    favors second smallest gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize remaining capacities\n    max_cap = bins_remain_cap.max()\n    min_cap = bins_remain_cap.min()\n    normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap)\n\n    # Calculate gaps\n    gaps = bins_remain_cap - item\n\n    # Penalize infeasibility (bins too small for the item)\n    infeasibility_penalty = np.where(gaps < 0, -np.inf, 0)\n\n    # Favor bins near full (high priority for bins with small gaps)\n    # Penalize bins that have significantly more remaining capacity than the item\n    gap_penalty = np.where(gaps > 0, gaps / max_cap, 0)\n\n    # Favor second smallest gaps to avoid packing items into the smallest gaps first\n    sorted_gaps = np.sort(gaps[gaps >= 0])\n    second_smallest_gap = sorted_gaps[1] if len(sorted_gaps) > 1 else 0\n    gap_favor = np.where(gaps == second_smallest_gap, 0.1, 0)\n\n    # Combine all factors into a final priority score\n    priority_score = normalized_cap - gap_penalty + infeasibility_penalty + gap_favor\n\n    return priority_score",
    "response_id": 2,
    "obj": 148.66374152373353,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers the remaining capacity, normalizes capacities,\n    prioritizes bins that are near full, penalizes infeasibility, and balances\n    priorities while favoring the second smallest gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize remaining capacities\n    normalized_cap = bins_remain_cap / bins_remain_cap.max()\n\n    # Priority for bins that can fit the item: penalize infeasibility\n    feasible = bins_remain_cap >= item\n    penalty_infeasibility = np.where(feasible, 0, -np.inf)\n\n    # Calculate gaps if the item is added to each bin\n    gaps = np.where(feasible, bins_remain_cap - item, np.inf)\n\n    # Favor the second smallest gap\n    sorted_gaps = np.sort(gaps[gaps < np.inf])\n    second_smallest_gap = sorted_gaps[1] if len(sorted_gaps) > 1 else sorted_gaps[0]\n    favor_second_smallest = np.where(gaps == second_smallest_gap, 0.1, 0)\n\n    # Combine normalized capacity, penalty for infeasibility, and favor for second smallest gap\n    priority_score = normalized_cap + penalty_infeasibility + favor_second_smallest\n\n    return priority_score",
    "response_id": 3,
    "obj": 149.1822895891504,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implementation considers normalized capacities, prioritizes bins near full,\n    penalizes infeasibility, gaps, balances priorities, and favors second smallest gaps.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize remaining capacities\n    normalized_cap = bins_remain_cap / bins_remain_cap.max()\n\n    # Base priority: Favor bins that are near full\n    base_priority = normalized_cap\n\n    # Penalize bins that have less capacity than the item itself (infeasible)\n    infeasibility_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n\n    # Calculate gaps between item and bin capacity\n    gaps = bins_remain_cap - item\n\n    # Penalty for gaps: Smaller gaps are better, but favor the second smallest gap\n    sorted_gaps = np.sort(gaps[gaps >= 0])\n    second_smallest_gap_penalty = np.where(gaps == sorted_gaps[1], -0.05, 0) if len(sorted_gaps) > 1 else 0\n\n    # Combine base priority, infeasibility penalty, and gap penalties into a final score\n    priority_score = base_priority + infeasibility_penalty + second_smallest_gap_penalty\n\n    return priority_score",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]