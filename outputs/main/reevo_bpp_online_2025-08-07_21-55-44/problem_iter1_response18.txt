```python
import numpy as np

# Global epsilon for the feasible level of exploration.
# You can tune this value or expose it as a function argument.
_EPSILON = 0.15


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem using an
    epsilon‑greedy scheme.

    With probability ε we explore: the feasible bins receive a random
    priority, making the eventual choice essentially random.
    With probability 1‑ε we exploit: we use a best‑fit heuristic that
    prefers the bin that will have the smallest leftover capacity after
    placing the item.

    Parameters
    ----------
    item : float
        Size of the arriving item.
    bins_remain_cap : np.ndarray
        Remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; the caller should select the bin
        with the highest score. Infeasible bins get -inf to guarantee they
        are never chosen.
    """
    # Bins that can actually accommodate the item
    feasible = bins_remain_cap >= item

    # Initialise all priorities to -inf (i.e., unusable)
    priorities = np.full(bins_remember_shape(bins_remain_cap.shape), -np.inf, dtype=float)

    # If no bin can hold the item, return the -inf vector so the caller knows
    # a new bin must be opened.
    if not np.any(feasible):
        return priorities

    # Decide whether to explore or exploit this step
    if np.random.rand() < _EPSILON:
        # Exploration: random uniform scores for feasible bins
        priorities[feasible] = np.random.rand(feasible.sum())
    else:
        # Exploitation: best‑fit (tightest) heuristic
        # Compute leftover capacity after the item would be placed
        leftover = bins_remain_cap[feasible] - item
        # Higher priority for smaller leftover (tighter fit)
        priorities[feasible] = -leftover

    return priorities


def bins_remain_cap_shape(shape):
    """Utility to preserve the shape (including potential multidimensional input)."""
    # For a 1‑D array we just return shape, but this helper allows future
    # extension without touching the main routine.
    return shape
```
