```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function implementing an epsilon‑greedy strategy for online Bin Packing.

    This strategy:
        - Excludes bins that cannot accommodate the item.
        - Prefers bins with the smallest slack (best fit) as exploitation.
        - Occasionally injects random exploration noise with probability epsilon.
        - The epsilon value adjusts with the proportion of fitting bins.

    The returned priorities can be compared, and the bin with the maximum
    priority score will be chosen.
    """
    # Boolean mask of bins that can hold the item
    fits = bins_remain_cap >= item

    # Count how many bins are still feasible
    num_fits = np.count_nonzero(fits)
    bin_cnt = bins_remain_cap.size

    # Adjust epsilon: more bins that fit -> explore a bit more; clamp between 0.05 and 0.3
    eps = np.clip(0.3 - 0.2 * (num_fits / bin_cnt), 0.05, 0.3)

    # Base exploitation score: best‑fit (smallest slack) => higher priority
    slack = bins_remain_cap - item
    exploit_score = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    exploit_score[fits] = -slack[fits]  # lower slack -> larger (less negative) score

    # Exploration score: uniform random noise on feasible bins
    rng = np.random.default_rng()
    explore_score = rng.uniform(0.0, 1.0, size=bins_remain_cap)
    explore_score[~fits] = -np.inf

    # Blend exploitation and exploration using epsilon‑greedy mixture
    combined_score = (1.0 - eps) * exploit_score + eps * explore_score

    return combined_score
```
