[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1-D array of remaining capacities of existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Higher score indicates more desirable bin.\n        Bins that cannot accommodate the item receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.shape[0]\n\n    # Default score for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Compute leftover after placing the item\n    leftover = caps - item\n\n    # Feasible bins\n    feasible = leftover >= 0\n\n    if not feasible.any():\n        # No bin can accommodate the item\n        return priorities\n\n    # Base priority: penalize leftover, weighted by item size\n    # Larger items see a stronger penalty for the same leftover\n    priorities[feasible] = -leftover[feasible] * item\n\n    # Exact fits get a massive bonus\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)\n    if exact_fit.any():\n        # Use a value large enough to dominate any other feasible bin\n        EXACT_FIT_BONUS = 1e12\n        priorities[exact_fit] = EXACT_FIT_BONUS\n\n    # Tie\u2011break by lower index: subtract a tiny epsilon proportional to the index\n    epsilon = 1e-6\n    priorities -= epsilon * np.arange(n_bins)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[np.ndarray] = None,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The priority favours bins that will have a small positive residual after\n    packing the current `item`.  It additionally:\n\n    * Adjusts the sigmoid sharpness (parameter `k`) according to how full the\n      bin already is \u2013 fuller bins receive a steeper curve, encouraging tighter\n      packing.\n    * Normalises gaps by the bin capacity to make the score scale\u2011invariant.\n    * Adds a tiny random tie\u2011breaker to avoid deterministic ties.\n    * (Optionally) incorporates a simple look\u2011ahead: bins that are also able to\n      accommodate more of the upcoming items obtain a boost.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n    bin_capacity : float, optional\n        Fixed capacity of each bin.  If omitted it is inferred as the maximum\n        possible capacity observed (the largest remaining capacity plus the\n        current item size).  All bins are assumed to have the same capacity.\n    lookahead_items : np.ndarray, optional\n        1\u2011D array of sizes of future items that may arrive soon.  The function\n        rewards bins that could also hold at least one of these items after the\n        current one is placed.\n    random_state : int, optional\n        Seed for the internal RNG used for tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Infeasible bins (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------ #\n    # Preparations\n    # ------------------------------------------------------------------ #\n    rng = np.random.default_rng(random_state)\n\n    # Ensure a proper NumPy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Infer bin capacity if not supplied (assumes homogeneous bins)\n    if bin_capacity is None:\n        # At least one bin must be able to hold the current item.\n        # Adding `item` guarantees capacity is not underestimated.\n        bin_capacity = float(bins_remain_cap.max() + item)\n\n    # ------------------------------------------------------------------ #\n    # Feasibility mask\n    # ------------------------------------------------------------------ #\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities with -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    if not feasible.any():\n        # No bin can accommodate the item; return all -inf.\n        return priorities\n\n    # ------------------------------------------------------------------ #\n    # Core sigmoid score (small residuals preferred)\n    # ------------------------------------------------------------------ #\n    # Gap after placing the item\n    gaps = bins_remain_cap - item                     # may be negative for infeasible\n\n    # Normalise gaps to [0, 1] using the known bin capacity\n    norm_gaps = gaps / bin_capacity\n\n    # Base steepness of the sigmoid\n    base_k = 8.0\n\n    # Dynamically adjust k: fuller bins (small remaining capacity) get larger k\n    # fullness factor = (C - remaining) / C  \u2208 [0, 1]\n    fullness = (bin_capacity - bins_remain_cap) / bin_capacity\n    dynamic_k = base_k * (1.0 + fullness)            # \u2208 [base_k, 2*base_k]\n\n    # Compute sigmoid safely (clip exponent to avoid overflow)\n    exponent = np.clip(dynamic_k * norm_gaps, -700, 700)\n    sigmoid_score = np.where(\n        feasible,\n        1.0 / (1.0 + np.exp(exponent)),  # larger when norm_gaps is small\n        -np.inf\n    )\n\n    # ------------------------------------------------------------------ #\n    # Tie\u2011breaking random noise (very small magnitude)\n    # ------------------------------------------------------------------ #\n    noise = rng.uniform(0.0, 1e-6, size=bins_remain_cap.shape)\n    sigmoid_score += noise\n\n    # ------------------------------------------------------------------ #\n    # Look\u2011ahead boost (optional)\n    # ------------------------------------------------------------------ #\n    if lookahead_items is not None and lookahead_items.size > 0:\n        # Broadcast to compute remaining capacity after placing current item\n        # and each look\u2011ahead item.\n        future_gaps = bins_remain_cap[:, None] - item - lookahead_items[None, :]\n        # Count how many future items could still fit in each bin.\n        future_fits = (future_gaps >= 0).sum(axis=1)\n        # Normalise to [0, 1]\n        fit_ratio = future_fits / lookahead_items.size\n        # Boost factor: bins that can host more future items are slightly favoured.\n        # Alpha controls the strength of the boost.\n        alpha = 0.2\n        boost = 1.0 + alpha * fit_ratio\n        sigmoid_score *= boost\n\n    # ------------------------------------------------------------------ #\n    # Assemble final priority vector\n    # ------------------------------------------------------------------ #\n    priorities[feasible] = sigmoid_score[feasible]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 38.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing that blends worst\u2011fit\n    with best\u2011fit using a softmax\u2011style score, temperature scaling,\n    and a linear waste penalty.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently used bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  The bin with the highest score will\n        be selected.  Feasible bins that cannot accommodate the item receive\n        a score of -inf and are never chosen.\n    \"\"\"\n    # Ensure we are working with floats\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Start with all bins infeasible\n    priorities = np.full_like(caps, fill_value=-np.inf, dtype=float)\n\n    # Identify bins that can accept the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities\n\n    # Leftover capacity if the item were placed in each feasible bin\n    leftover = caps[feasible] - item  # >= 0\n\n    # ---------- Heuristic parameters ----------\n    alpha = 0.5            # 0 \u2192 pure best\u2011fit, 1 \u2192 pure worst\u2011fit\n    penalty_factor = 0.1   # linear penalty proportional to wasted capacity\n    temperature = 1.0      # temperature for scaling (larger \u2192 flatter)\n\n    # ---------- Combine best\u2011fit and worst\u2011fit ----------\n    # Best\u2011fit score: tighter fit \u2192 higher priority (negative leftover)\n    best_score = -leftover\n    # Worst\u2011fit score: more remaining capacity \u2192 higher priority (positive leftover)\n    worst_score = leftover\n    # Linear blend\n    combined = (1 - alpha) * best_score + alpha * worst_score\n\n    # ---------- Penalize waste ----------\n    combined -= penalty_factor * leftover  # larger leftover => more penalty\n\n    # ---------- Temperature scaling ----------\n    if temperature <= 0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # Assign the computed priorities to the feasible bins\n    priorities[feasible] = combined\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\nfrom typing import Union, Optional\n\ndef priority_v2(\n    item: Union[float, int],\n    bins_remain_cap: np.ndarray,\n    atol: float = 1e-12,\n    boost_factor: Optional[float] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float or int\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n    atol : float, optional\n        Absolute tolerance for deciding whether a bin is an exact fit.\n        Defaults to 1e-12.\n    boost_factor : float, optional\n        Positive constant added to exact\u2011fit bins.  If ``None`` a dynamic\n        boost is computed that is guaranteed to exceed any feasible\n        non\u2011exact priority.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).  Bins\n        that cannot accommodate the item receive ``-np.inf``.  The bin with the\n        highest score should be selected for the item.\n    \"\"\"\n    # Ensure a float array for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    item_val = float(item)\n\n    # Slack after hypothetically placing the item\n    slack = caps - item_val\n\n    # Feasibility mask (item fits if slack >= 0)\n    feasible = slack >= 0\n\n    # Exact\u2011fit mask (slack is effectively zero)\n    exact_fit = feasible & np.isclose(slack, 0.0, atol=atol, rtol=0.0)\n\n    # Initialise priorities with the worst possible value\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Feasible, non\u2011exact bins: priority = -slack (higher when slack smaller)\n    non_exact = feasible & ~exact_fit\n    priorities[non_exact] = -slack[non_exact]\n\n    # Determine a boost that dominates any non\u2011exact priority\n    if boost_factor is None:\n        # Max priority among non\u2011exact feasible bins (or -inf if none)\n        max_non_exact = priorities[non_exact].max() if non_exact_exact := non_exact.any() else -np.inf\n        # Use a safe margin; if no feasible bins, fall back to a large constant\n        boost_factor = (max_non_exact + 1.0) if max_non_exact != -np.inf else 1e6\n\n    # Exact\u2011fit bins get the boost\n    priorities[exact_fit] = boost_factor\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 57\n    max_non_exact = priorities[non_exact].max() if non_exact_exact := non_exact.any() else -np.inf\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: expected 'else' after 'if' expression\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 57\n    max_non_exact = priorities[non_exact].max() if non_exact_exact := non_exact.any() else -np.inf\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: expected 'else' after 'if' expression\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 57\n    max_non_exact = priorities[non_exact].max() if non_exact_exact := non_exact.any() else -np.inf\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: expected 'else' after 'if' expression\n"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes priority scores for placing an incoming item in existing bins.\n\n    Priority is defined as the negative waste (unused space) that would remain after\n    placing the item.  Bins that cannot accommodate the item receive a priority of\n    -inf, guaranteeing they are never selected.  In case several bins would leave\n    the same amount of waste, a tiny deterministic bias favouring the lowest\u2011indexed\n    bin is added, ensuring stable behaviour.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin.  The caller should select the bin\n        with the maximum priority.\n    \"\"\"\n    # Ensure the input is a NumPy array of float type\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute waste if the item were placed in each bin\n    waste = bins_remain_cap - item\n\n    # Determine feasible bins (non\u2011negative waste)\n    feasible = waste >= 0\n\n    # Base priority: negative waste (larger => smaller waste)\n    base_priority = np.where(feasible, -waste, -np.inf)\n\n    # Deterministic tie\u2011breaker: smaller index gets a tiny advantage\n    epsilon = 1e-12\n    tie_breaker = -np.arange(bins_remain_cap.size, dtype=float) * epsilon\n\n    return base_priority + tie_breaker",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing Problem.\n\n    The priority blends a logistic fit of the item\u2011to\u2011capacity ratio,\n    a slight index bias (first\u2011fit), a penalty for very tight residual capacity,\n    and a tie\u2011breaker based on the variance of the bins' remaining capacities\n    after a hypothetical placement.  Parameters of the logistic function\n    (steepness and centre) adapt to the current number of bins.\n\n    A higher score indicates a more desirable bin.  Bins that cannot accommodate\n    the item receive ``-np.inf`` so they will never be selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure the capacities are a NumPy float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.shape[0]\n\n    # Edge case: no bins present\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Feasibility mask: can the item fit into the bin?\n    feasible = caps >= item\n\n    # -----------------------------------------------------------------\n    # 1) Logistic fit of item\u2011to\u2011capacity ratio\n    # -----------------------------------------------------------------\n    ratio = np.empty_like(caps)\n    ratio.fill(0.0)                     # placeholder for infeasible bins\n    ratio[feasible] = item / caps[feasible]\n\n    # Adapt logistic parameters to the number of bins\n    k = 5.0 + n_bins / 5.0               # steepness grows with bin count\n    centre = 0.5 + 0.4 * (n_bins / (n_bins + 20.0))  # moves from 0.5 toward 0.9\n\n    # Logistic score (higher when the ratio exceeds the centre)\n    exp_arg = -k * (ratio - centre)\n    # Clip exponent to avoid overflow/underflow in np.exp\n    exp_arg = np.clip(exp_arg, -700, 700)\n    logistic_score = 1.0 / (1.0 + np.exp(exp_arg))\n\n    # -----------------------------------------------------------------\n    # 2) Index bias (first\u2011fit) \u2013 tiny boost for lower indices\n    # -----------------------------------------------------------------\n    idx = np.arange(n_bins, dtype=float)\n    epsilon_idx = 1e-6\n    index_score = -idx * epsilon_idx   # lower index \u2192 larger (less negative) score\n\n    # -----------------------------------------------------------------\n    # 3) Penalty for very tight residual capacity\n    # -----------------------------------------------------------------\n    residual = caps - item\n    residual_frac = np.empty_like(caps)\n    residual_frac.fill(0.0)\n    residual_frac[feasible] = residual[feasible] / caps[feasible]\n\n    alpha = 0.2          # maximum penalty magnitude\n    beta = 10.0          # decay speed of the penalty with residual fraction\n    penalty = -alpha * np.exp(-beta * residual_frac)\n\n    # -----------------------------------------------------------------\n    # 4) Variance\u2011based tie\u2011breaker (favor balanced bins)\n    # -----------------------------------------------------------------\n    # Compute variance of remaining capacities after placing the item in each bin.\n    caps_matrix = np.tile(caps, (n_bins, 1))\n    new_caps_matrix = caps_matrix - item * np.eye(n_bins, dtype=float)\n    variances = new_caps_matrix.var(axis=1)          # shape (n_bins,)\n    weight_var = 0.01                                 # small scaling factor\n    variance_score = -weight_var * variances\n\n    # -----------------------------------------------------------------\n    # Combine all components\n    # -----------------------------------------------------------------\n    total_score = logistic_score + index_score + penalty + variance_score\n\n    # Infeasible bins should never be selected\n    total_score = np.where(feasible, total_score, -np.inf)\n\n    return total_score",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997539499964 seconds"
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap= np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute deterministic priority scores for online bin packing.\n\n    The priority reflects:\n      * exact fits receive a massive bonus,\n      * among feasible bins, the smaller the leftover after placing the item,\n        the higher the priority,\n      * a tiny index\u2011based epsilon breaks ties deterministically,\n      * a quadratic penalty on leftover discourages creating large fragments,\n        which helps anticipate future items.\n\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more desirable).  The caller should select the\n        bin with the maximal score.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.shape[0]\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return priorities\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Base priority: negative leftover (smaller leftover => larger priority)\n    # plus a quadratic penalty to heavily discourage large leftovers.\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Deterministic tie\u2011breaker: small epsilon weighted by bin index\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    priorities[feasible] = base_priority[feasible]\n\n    # Exact fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e9\n        # Override priority for exact fits (including tie\u2011breaker)\n        priorities[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    The priority is composed of:\n      * Primary component: smaller bin index receives higher priority (first\u2011fit).\n      * Secondary component: tighter fit (smaller leftover capacity) breaks ties.\n      * Infeasible bins (cannot accommodate the item) receive -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure we are working with a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask: bin can hold the item\n    feasible = caps >= item\n\n    # Primary ordering: smaller index => higher priority.\n    # Use negative indices: idx 0 -> 0, idx 1 -> -1, idx 2 -> -2, ...\n    idx = np.arange(caps.size, dtype=float)\n    primary = -idx\n\n    # Secondary ordering: tighter fit (smaller leftover) => higher priority.\n    leftover = caps - item                     # >= 0 for feasible bins\n    epsilon = 1e-6                             # tiny weight so primary dominates\n    secondary = -leftover * epsilon\n\n    # Combine components\n    scores = primary + secondary\n\n    # Mask infeasible bins\n    scores = np.where(feasible, scores, -np.inf)\n\n    return scores",
    "response_id": 7,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that prefers bins with the\n    smallest leftover space after placing the item, while giving a huge\n    bonus to exact fits.  No bias is introduced based on bin index.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        An array of priority scores, one per bin.  The bin with the\n        maximum score will be selected.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure we are working with a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialize all priorities to -inf (unfeasible)\n    priorities = np.full(caps.shape, -np.inf, dtype=float)\n\n    # Feasible bins: those with enough capacity for the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No existing bin can fit the item; caller may decide to open a new bin\n        return priorities\n\n    # Compute leftover space if the item were placed in each feasible bin\n    leftover = caps - item\n\n    # Base priority: larger leftover => lower priority (negative leftover)\n    priorities[feasible] = -leftover[feasible]\n\n    # Detect exact fits within a small tolerance and give them a massive bonus\n    # This ensures an exact fit is always chosen over a bin with a small leftover.\n    tolerance = 1e-9\n    exact_fit = feasible & (leftover <= tolerance)\n    if np.any(exact_fit):\n        # A large constant that dominates any other priority\n        EXACT_FIT_BONUS = 1e9\n        priorities[exact_fit] = EXACT_FIT_BONUS\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    beta: float = 10.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    The priority is based on a normalized residual capacity after placing the\n    item, transformed through a steep sigmoid so that bins with a tight fit\n    obtain a high score while bins with large leftover capacity obtain a low\n    score. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` to guarantee they are never selected, unless the optional\n    ``epsilon``\u2011greedy exploration is active.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for the existing bins.\n    beta : float, optional\n        Steepness of the sigmoid; larger values increase the contrast between\n        tight and loose fits. Must be non\u2011negative.\n    epsilon : float, optional\n        Exploration probability (0 \u2264 epsilon \u2264 1). With probability ``epsilon``\n        the function returns random scores for feasible bins to encourage\n        exploration of sub\u2011optimal placements.\n    rng : np.random.Generator | None, optional\n        Random number generator for reproducibility. If ``None``, a fresh\n        default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape ``bins_remain_cap.shape``). Higher\n        values indicate a more desirable placement.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    # Ensure input is a 1\u2011D float array\n    remain = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = remain.size\n\n    # Empty case \u2013 nothing to score\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialise all priorities as -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible_mask = remain >= item\n    n_feasible = feasible_mask.sum()\n    if n_feasible == 0:\n        # No bin can accommodate the item; return all -inf\n        return priorities\n\n    # Exploration vs exploitation\n    explore = rng.random() < epsilon\n\n    if explore:\n        # Random uniform scores for exploration\n        raw_scores = rng.random(n_feasible)\n    else:\n        # Residual capacity after placing the item\n        residual = remain[feasible_mask] - item\n\n        # Normalise residuals to [0, 1] using the maximum residual as scale.\n        scale = residual.max()\n        scale = scale if scale > 0 else 1.0  # avoid division by zero\n        normalized = residual / scale\n\n        # Sigmoid transform: higher priority for smaller residuals.\n        # Numerically stable: exponent \u2208 [-beta, 0]\n        exp_term = np.exp(-beta * normalized)\n        raw_scores = 1.0 / (1.0 + exp_term)\n\n    # Tiny jitter to break ties deterministically\n    jitter = rng.random(n_feasible) * 1e-9\n    raw_scores = raw_scores + jitter\n\n    # Populate the priority array\n    priorities[feasible_mask] = raw_scores\n\n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 32.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_sigmoid_k: float = 10.0,\n    next_item_bonus: float = 0.1,\n    jitter: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    The function returns a score for each currently opened bin. Higher scores\n    indicate a more desirable bin for the incoming `item`.\n\n    Heuristics incorporated:\n    \u2022 Huge bonus for exact fits (remaining capacity after placement \u2248 0).\n    \u2022 Primary ranking by minimal waste (negative remaining slack).\n    \u2022 A sigmoid\u2011like exponential bonus for bins with small slack\n      (normalized waste \u2192 exp(-k\u00b7norm_slack)).\n    \u2022 Small extra bonus for bins that would still have enough room for another\n      item of size `item` after placement (anticipating the next item).\n    \u2022 Infeasible bins (insufficient capacity) receive -inf priority.\n    \u2022 Tiny index\u2011based jitter to break ties deterministically.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each opened bin.\n    exact_fit_bonus : float, optional\n        Large constant added when the item exactly fits a bin.\n    slack_sigmoid_k : float, optional\n        Controls the steepness of the exponential slack bonus.\n    next_item_bonus : float, optional\n        Small bonus for bins that would still accommodate another item of\n        size `item` after this placement.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``). The caller should\n        select the bin with the maximum priority.\n    \"\"\"\n    # Ensure input is a 1\u2011D NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins_remain_cap.size\n\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Compute remaining slack if the item were placed in each bin\n    slack = bins_remain_cap - item  # slack >= 0 => feasible\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Base priority: negative slack (higher = less waste) for feasible bins,\n    # -inf for infeasible bins.\n    base_priority = np.where(feasible, -slack, -np.inf)\n\n    # Normalized slack for feasible bins (to [0, 1])\n    norm_slack = np.zeros_like(slack)\n    if np.any(feasible):\n        max_slack = np.max(slack[feasible])\n        # Avoid division by zero when all feasible bins have zero slack\n        denom = max_slack + 1e-12\n        norm_slack[feasible] = slack[feasible] / denom\n\n    # Exponential slack bonus: high when slack is small, low when slack is large\n    slack_bonus = np.exp(-slack_sigmoid_k * norm_slack)\n\n    # Anticipate next item: give a tiny boost if the bin would still have\n    # enough capacity for another item of size `item` after this placement.\n    anticipate_bonus = np.where(feasible & (slack >= item), next_item_bonus, 0.0)\n\n    # Combine all components\n    priority = base_priority + slack_bonus + anticipate_bonus\n\n    # Add huge bonus for exact fits (within numerical tolerance)\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: slightly favor lower\u2011index bins\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priority += tie_breaker\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]