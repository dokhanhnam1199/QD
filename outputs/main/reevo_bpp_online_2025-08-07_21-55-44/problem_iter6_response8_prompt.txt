{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute dynamic priority scores for bins in an online Bin Packing Problem.\n\n    The priority blends best\u2011fit (tight leftover) and worst\u2011fit (large leftover)\n    using a data\u2011driven weight \u03b1 that adapts to the current distribution of\n    leftovers.  A linear waste penalty is subtracted, and a temperature\n    scaling smooths the scores.  A tiny negative tie\u2011breaker based on the\n    bin index resolves exact ties.  Feasible bins that cannot accommodate the\n    item receive -inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure numeric array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n\n    # If no feasible bin, return -inf for all\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item is placed\n    leftover = caps[feasible] - item  # >= 0\n\n    # ----- Dynamic alpha based on leftover distribution -----\n    max_leftover = np.max(leftover)\n    if max_leftover > 0:\n        mean_leftover = np.mean(leftover)\n        alpha = np.clip(mean_leftover / max_leftover, 0.0, 1.0)\n    else:\n        # All feasible bins are exact fits\n        alpha = 0.5\n\n    # ----- Normalize leftover to [0,1] for stable scoring -----\n    if max_leftover > 0:\n        leftover_norm = leftover / max_leftover\n    else:\n        leftover_norm = leftover  # all zeros\n\n    # ----- Best\u2011fit and worst\u2011fit components -----\n    best_score = -leftover_norm   # tighter fit \u2192 higher\n    worst_score = leftover_norm   # larger leftover \u2192 higher\n\n    # ----- Linear blend -----\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # ----- Waste penalty -----\n    base_penalty = 0.1\n    penalty_factor = base_penalty * np.mean(leftover_norm)\n    combined -= penalty_factor * leftover_norm\n\n    # ----- Temperature scaling -----\n    std_norm = np.std(leftover_norm)\n    temperature = 1.0 + std_norm  # higher variation \u2192 smoother scores\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # ----- Tie\u2011breaker based on bin index (avoid fixed epsilon) -----\n    idx = np.arange(caps.size, dtype=float)\n    epsilon = 1e-6 * (np.max(np.abs(combined)) + 1e-12)\n    tie_break = -epsilon * idx\n\n    # ----- Assemble final scores -----\n    full_scores = np.full_like(caps, -np.inf, dtype=float)\n    full_scores[feasible] = combined + tie_break[feasible]\n\n    return full_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute deterministic priority scores for online bin packing.\n\n    The priority reflects:\n      * Exact fits receive a huge bonus.\n      * Among feasible bins, a smaller leftover after placing the item\n        yields a higher priority.\n      * A quadratic penalty on leftover discourages large fragments.\n      * A tiny index\u2011based epsilon breaks ties deterministically.\n\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more desirable).  The caller should\n        select the bin with the maximal score.\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Handle empty input\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialize priorities to -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return priorities\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Base priority: negative leftover plus a small quadratic penalty\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Deterministic tie\u2011breaker: tiny epsilon weighted by bin index\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    priorities[feasible] = base_priority[feasible]\n\n    # Exact fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e9\n        priorities[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return priorities\n\n[Reflection]\nUse deterministic scores: huge exact\u2011fit bonus, quadratic leftover penalty, simple index tie\u2011break; avoid complex adaptive scaling.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}