```python
import numpy as np
from typing import Optional, Union, Sequence


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, Sequence[float]],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,
    k_base: float = 8.0,
    k_scale: float = 5.0,
    reuse_bonus: float = 0.05,
    exact_fit_bonus: float = 10.0,
    lookahead_alpha: float = 0.2,
    jitter: float = 1e-9,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacity of each currently opened bin.
    bin_capacity : float, optional
        Fixed capacity of a bin.  If ``None``, a default of 1.0 is used.
    lookahead_items : array‑like of float, optional
        Sizes of future items.  Bins that can still accommodate more of these
        items after the current placement receive a multiplicative boost.
    k_base : float, default 8.0
        Base steepness for the adaptive sigmoid.
    k_scale : float, default 5.0
        How much the steepness grows with bin fullness (0–1).
    reuse_bonus : float, default 0.05
        Constant added to scores of feasible bins, favouring reuse over
        opening a new bin.
    exact_fit_bonus : float, default 10.0
        Large boost for bins where the item exactly fits.
    lookahead_alpha : float, default 0.2
        Strength of the look‑ahead boost (0 ≤ α ≤ 1).
    jitter : float, default 1e-9
        Magnitude of deterministic and random tie‑breakers.
    random_state : int or np.random.Generator, optional
        Seed or generator for reproducible random tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins
        (remaining capacity < ``item``) receive ``-np.inf``.
    """
    # Convert bins to a NumPy array
    bins = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins.size

    if n_bins == 0:
        # No bins opened yet
        return np.empty(0, dtype=float)

    # Determine the nominal bin capacity
    if bin_capacity is None:
        bin_capacity = 1.0

    # Feasibility mask: bins that can hold the item
    feasible = bins >= item

    # Initialise priority vector with -inf for infeasible bins
    priority = np.full_like(bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – caller will open a new bin
        return priority

    # Slack after placing the item (non‑negative for feasible bins)
    slack = bins[feasible] - item
    norm_slack = slack / bin_capacity  # normalized to [0, 1]

    # Fullness before placement (0 = empty, 1 = completely full)
    fullness = (bin_capacity - bins[feasible]) / bin_capacity
    fullness = np.clip(fullness, 0.0, 1.0)

    # Adaptive sigmoid steepness: steeper for fuller bins
    k = k_base * (1.0 + k_scale * fullness)

    # Decreasing sigmoid: yields 1 for exact fit (slack=0) and →0 for large slack
    exponent = np.clip(k * norm_slack, -700.0, 700.0)  # avoid overflow
    sigmoid_score = 2.0 / (1.0 + np.exp(exponent))

    # Exact‑fit bonus
    eps = 1e-12
    exact_bonus = np.where(slack <= eps, exact_fit_bonus, 0.0)

    # Base score (sigmoid + bonuses)
    base_score = sigmoid_score + exact_bonus + reuse_bonus

    # Optional look‑ahead boost
    if lookahead_items is not None:
        lookahead = np.asarray(lookahead_items, dtype=float)
        if lookahead.size > 0:
            # Remaining capacity after placement for each feasible bin
            remaining = slack[:, None]                     # shape (m, 1)
            fits = (remaining >= lookahead[None, :]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0, 1]
            boost = 1.0 + np.clip(lookahead_alpha, 0.0, 1.0) * fit_ratio
            base_score *= boost

    # Random tie‑breaker (tiny noise)
    rng = np.random.default_rng(random_state)
    noise = rng.uniform(0.0, jitter, size=base_score.shape)
    base_score += noise

    # Assign scores to feasible bins
    priority[feasible] = base_score

    # Deterministic tie‑breaker: lower index gets a tiny advantage
    deterministic_jitter = -np.arange(n_bins, dtype=float) * jitter
    priority += deterministic_jitter

    return priority
```
