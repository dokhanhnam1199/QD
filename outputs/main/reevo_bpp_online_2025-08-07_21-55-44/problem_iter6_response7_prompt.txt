{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute dynamic priority scores for bins in an online Bin Packing Problem.\n\n    The priority blends best\u2011fit (tight leftover) and worst\u2011fit (large leftover)\n    using a data\u2011driven weight \u03b1 that adapts to the current distribution of\n    leftovers.  A linear waste penalty is subtracted, and a temperature\n    scaling smooths the scores.  A tiny negative tie\u2011breaker based on the\n    bin index resolves exact ties.  Feasible bins that cannot accommodate the\n    item receive -inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure numeric array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n\n    # If no feasible bin, return -inf for all\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item is placed\n    leftover = caps[feasible] - item  # >= 0\n\n    # ----- Dynamic alpha based on leftover distribution -----\n    max_leftover = np.max(leftover)\n    if max_leftover > 0:\n        mean_leftover = np.mean(leftover)\n        alpha = np.clip(mean_leftover / max_leftover, 0.0, 1.0)\n    else:\n        # All feasible bins are exact fits\n        alpha = 0.5\n\n    # ----- Normalize leftover to [0,1] for stable scoring -----\n    if max_leftover > 0:\n        leftover_norm = leftover / max_leftover\n    else:\n        leftover_norm = leftover  # all zeros\n\n    # ----- Best\u2011fit and worst\u2011fit components -----\n    best_score = -leftover_norm   # tighter fit \u2192 higher\n    worst_score = leftover_norm   # larger leftover \u2192 higher\n\n    # ----- Linear blend -----\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # ----- Waste penalty -----\n    base_penalty = 0.1\n    penalty_factor = base_penalty * np.mean(leftover_norm)\n    combined -= penalty_factor * leftover_norm\n\n    # ----- Temperature scaling -----\n    std_norm = np.std(leftover_norm)\n    temperature = 1.0 + std_norm  # higher variation \u2192 smoother scores\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # ----- Tie\u2011breaker based on bin index (avoid fixed epsilon) -----\n    idx = np.arange(caps.size, dtype=float)\n    epsilon = 1e-6 * (np.max(np.abs(combined)) + 1e-12)\n    tie_break = -epsilon * idx\n\n    # ----- Assemble final scores -----\n    full_scores = np.full_like(caps, -np.inf, dtype=float)\n    full_scores[feasible] = combined + tie_break[feasible]\n\n    return full_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e7,\n    slack_decay: float = 12.0,\n    next_item_factor: float = 0.05,\n    jitter: float = 1e-12,\n    atol: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    Higher scores indicate a more desirable bin for the incoming ``item``.\n    The priority combines several heuristics:\n      \u2022 Large bonus for an exact fit (remaining capacity \u2248 0).\n      \u2022 Exponential slack penalty: bins with less leftover capacity get a\n        larger boost, encouraging tight packing.\n      \u2022 Anticipation bonus: slight extra score if the bin would still hold\n        another item of the same size after placement.\n      \u2022 Deterministic tie\u2011breaker based on bin index (jitter).\n\n    Infeasible bins (insufficient capacity) receive ``-inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    exact_fit_bonus : float, optional\n        Bonus added for bins where the item fits exactly.\n    slack_decay : float, optional\n        Controls steepness of the exponential slack bonus.\n    next_item_factor : float, optional\n        Small bonus for bins that could still accommodate another item of\n        size ``item`` after this placement.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n    atol : float, optional\n        Absolute tolerance for detecting an exact fit.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Compute slack (remaining capacity after placing the item)\n    slack = caps - item\n    feasible : np.ndarray = slack >= 0\n\n    # Initialise priority with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin; return early\n        # (All entries already -inf)\n        return priority\n\n    # Base priority: negative slack (less waste = higher score)\n    base = -slack[feasible]\n\n    # Normalized slack for exponential bonus\n    max_slack = np.max(slack[feasible])\n    norm_slack = slack[feasible] / (max_slack + atol)  # avoid division by zero\n\n    # Exponential slack bonus (high when slack is small)\n    slack_bonus = np.exp(-slack_decay * norm_slack)\n\n    # Combine base and slack bonus\n    priority[feasible] = base + slack_bonus\n\n    # Anticipation bonus: still room for another item of same size\n    anticipate_mask = feasible & (slack >= item)\n    priority[anticipate_mask] += next_item_factor\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins slightly\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority\n\n[Reflection]\nScore by negative slack\u202f+\u202fexponential bonus, large exact\u2011fit bonus, tiny index jitter; avoid complex dynamic blending and scaling.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}