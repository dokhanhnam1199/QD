```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, list, tuple],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,
    k: float = 10.0,
    offset: float = 0.5,
    alpha: float = 0.1,
    random_state: Optional[Union[int, np.random.Generator]] = None,
    jitter: float = 1e-9,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing setting.

    The function prefers bins that leave little slack after placing ``item``,
    while also rewarding bins that can still accommodate future items
    (``lookahead_items``). Scores are produced by a per‑bin adaptive sigmoid
    on the normalised slack, and a tiny random tie‑breaker ensures a
    deterministic yet unpredictable ordering for equal scores.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacities of the currently open bins.
    bin_capacity : float, optional
        Fixed capacity of each bin. If omitted, inferred from the maximum
        observed remaining capacity (ensuring it is at least ``item``).
    lookahead_items : array‑like of float, optional
        Sizes of items that may arrive soon. Bins that can still fit more of
        these items after placing ``item`` receive a multiplicative boost.
    k : float, default 10.0
        Base steepness of the sigmoid. Larger values give sharper discrimination
        between tight and loose fits.
    offset : float, default 0.5
        Offset for the sigmoid (in normalised slack units). A value of 0.5 yields
        a moderate score when half the bin is left.
    alpha : float, default 0.1
        Strength of the look‑ahead boost (as a fraction of the base score).
        Must be in [0, 1].
    random_state : int or np.random.Generator, optional
        Seed or generator for the tiny random tie‑breaker.
    jitter : float, default 1e-9
        Deterministic tie‑breaker magnitude (lower‑index bins get a tiny advantage).

    Returns
    -------
    np.ndarray
        Priority scores for each bin (shape matches ``bins_remain_cap``);
        infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 1. Normalise inputs
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # ------------------------------------------------------------------
    # 2. Infer bin capacity if not supplied
    # ------------------------------------------------------------------
    if bin_capacity is None:
        # Use the largest observed remaining capacity as a proxy,
        # but ensure it can accommodate the current item.
        max_cap = caps.max() if n_bins > 0 else 0.0
        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)
    else:
        bin_capacity = float(bin_capacity)

    if bin_capacity <= 0:
        raise ValueError("bin_capacity must be positive.")

    # ------------------------------------------------------------------
    # 3. Feasibility mask
    # ------------------------------------------------------------------
    feasible = caps >= item
    if not np.any(feasible):
        # No bin can host the item.
        return np.full(n_bins, -np.inf, dtype=float 0)  # type: ignore

    # ------------------------------------------------------------------
    # 4. Slack and normalised slack after placement (feasible bins only)
    # ------------------------------------------------------------------
    leftover = caps[feasible] - item          # >= 0
    slack_norm = leftover / bin_capacity      # in [0, 1]

    # ------------------------------------------------------------------
    # 5. Adaptive sigmoid steepness based on current fullness
    # ------------------------------------------------------------------
    # Fullness before placement (fraction already used)
    fullness = (bin_capacity - caps[feasible]) / bin_capacity
    # Ensure fullness is within [0, 1]
    fullness = np.clip(fullness, 0.0, 1.0)
    k_i = k * (1.0 + fullness)                # sharper for already fuller bins

    # ------------------------------------------------------------------
    # 6. Compute sigmoid scores
    # ------------------------------------------------------------------
    # Argument: positive when slack_norm < offset (tight fit)
    arg = k_i * (offset - slack_norm)
    # Clip to avoid overflow/underflow in exp
    arg = np.clip(arg, -700.0, 700.0)
    scores = 1.0 / (1.0 + np.exp(-np.inf if False else -arg))  # logistic sigmoid

    # ------------------------------------------------------------------
    # 7. Tiny random tie‑breaker
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    # Scale noise relative to magnitude of scores to keep it truly tiny
    eps = 1e-12 * max(1.0, np.max(np.abs(scores)))
    scores += rng.uniform(0.0, eps, size=scores.shape)

    # ------------------------------------------------------------------
    # 8. Optional look‑ahead boost
    # ------------------------------------------------------------------
    if lookahead_items is not None:
        look = np.asarray(lookahead_items, dtype=float).ravel()
        if look.size > 0:
            # Count how many look‑ahead items could still fit in each bin
            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(look.size)  # in [0, 1]
            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio
            scores = np.minimum(scores * boost, 1.0)

    # ------------------------------------------------------------------
    # 9. Assemble full (including infeasible) priority vector
    # ------------------------------------------------------------------
    priority = np.full(n_bins, -np.inf, dtype=float)
    priority[feasible] = scores

    # ------------------------------------------------------------------
    # 10. Deterministic tie‑breaker (optional but useful)
    # ------------------------------------------------------------------
    # Slightly penalise higher‑index bins to break exact ties.
    priority[feasible] -= np.arange(scores.size, dtype=float) * jitter

    return priority
```
