```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Exact‑Fit‑First priority function for the online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each open bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as `bins_remain_cap`).  The bin
        with the highest score should be chosen for the item.

    Strategy
    --------
    1. **Exact fits** (remaining capacity after placement ≈ 0) receive a very
       large positive boost, guaranteeing they are selected whenever possible.
    2. **Feasible but non‑exact bins** receive a priority equal to the negative
       slack (`- (remaining capacity - item)`).  Since the slack is non‑negative,
       a smaller slack yields a larger priority (e.g., slack = 0.1 → −0.1 > −1.0).
    3. **Infeasible bins** receive `-inf` so they are never selected.
    """
    # Compute remaining capacity after putting the item into each bin
    slack = bins_remain_cap - item

    # Feasibility mask (slack >= 0, i.e., item fits)
    feasible = slack >= 0

    # Exact‑fit mask (slack is essentially zero, tolerant to floating‑point noise)
    exact_fit = feasible & np.isclose(slack, 0.0, atol=1e-12)

    # Initialise all priorities as -inf (worst possible)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Assign a huge constant to exact‑fit bins
    BIG_BOOST = 1e9
    priorities[exact_fit] = BIG_BOOST

    # For the remaining feasible bins, priority = -slack (higher when slack is smaller)
    non_exact = feasible & ~exact_fit
    priorities[non_exact] = -slack[non_exact]

    return priorities
```
