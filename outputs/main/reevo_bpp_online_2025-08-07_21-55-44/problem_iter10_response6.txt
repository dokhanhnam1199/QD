```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin in an online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently opened bin.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as `bins_remain_cap`). Higher scores
        indicate more desirable bins. Infeasible bins receive -inf.
    """
    # Constants
    exact_fit_bonus = 1e9   # Large reward for an exact fit
    slack_decay = 10.0      # Steepness of the exponential slack penalty
    jitter = 1e-12          # Deterministic tie‑breaker magnitude
    atol = 1e-12            # Tolerance for detecting an exact fit

    # Convert to flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Remaining capacity after placing the item
    slack = caps - item

    # Feasibility mask (allow tiny negative due to floating point)
    feasible = slack >= -atol

    # Initialise priorities with -inf for infeasible bins
    priority = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – return early
        return priority

    # Indices of feasible bins
    feasible_idx = np.nonzero(feasible)[0]
    slack_feasible = slack[feasible_idx]

    # Monotonic base score: negative slack (smaller slack ⇒ higher score)
    base_score = -slack_feasible

    # Normalised slack for exponential penalty
    max_slack = np.max(slack_feasible)
    norm_slack = slack_feasible / (max_slack + atol)

    # Exponential slack penalty (larger slack ⇒ larger penalty)
    slack_penalty = np.exp(slack_decay * norm_slack)

    # Combine base and penalty (higher is better)
    priority[feasible_idx] = base_score - slack_penalty

    # Exact‑fit bonus (detect near‑zero slack)
    exact_fit_mask = np.isclose(slack_feasible, 0.0, atol=atol)
    if np.any(exact_fit_mask):
        priority[feasible_idx[exact_fit_mask]] += exact_fit_bonus

    # Deterministic tie‑breaker: prefer lower‑index bins slightly
    priority -= np.arange(n_bins, dtype=float) * jitter

    # Reshape to original shape
    return priority.reshape(bins_remain_cap.shape)
```
