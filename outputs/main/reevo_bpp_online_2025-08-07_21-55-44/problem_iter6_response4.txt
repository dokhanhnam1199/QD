```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.5,
    alpha: float = 0.1,
    exact_fit_bonus: float = 1e6,
    epsilon: float = 1e-12,
    next_item: float | None = None,
) -> np.ndarray:
    """
    Compute priority scores for each bin in an online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently opened bins.
    temperature : float, optional
        Softmax temperature. Lower values increase the contrast between bins.
    alpha : float, optional
        Quadratic waste penalty coefficient.
    exact_fit_bonus : float, optional
        Large bonus added to bins that accommodate the item exactly.
    epsilon : float, optional
        Tiny index‑based tie‑breaker; lower indices get a slight advantage.
    next_item : float or None, optional
        Size of the next item (look‑ahead). Bins that can also host the next
        item receive a small extra boost.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins are
        assigned ``-np.inf`` and will never be chosen.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    if bins_remain_cap.ndim != 1:
        raise ValueError("bins_remain_cap must be a 1‑D array")

    waste = bins_remain_cap - item
    feasible = waste >= 0

    # If no feasible bin, return all -inf to signal the need for a new bin.
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Base score: prefer smaller waste, optionally quadratic penalty.
    base = -waste - alpha * np.square(waste)

    # Exact‑fit bonus.
    exact_mask = np.isclose(waste, 0.0, atol=1e-12)
    base[exact_mask] += exact_fit_bonus

    # Optional look‑ahead: boost bins that can also hold the next item.
    if next_item is not None:
        future_waste = waste - next_item
        can_fit_next = future_waste >= 0
        lookahead_bonus = np.where(
            can_fit_next,
            0.05 - 0.01 * future_waste,  # base boost minus penalty for large leftover
            0.0,
        )
        base += lookahead_bonus

    # Tie‑breaker: give a tiny advantage to lower‑index bins.
    base -= epsilon * np.arange(bins_remain_cap.size)

    # Temperature‑scaled softmax.
    if temperature <= 0.0:
        temperature = 1e-8
    scaled = base / temperature

    # Stable exponentiation only for feasible bins.
    feasible_scaled = scaled[feasible]
    max_scaled = np.max(feasible_scaled)
    exp_scaled = np.exp(feasible_scaled - max_scaled)

    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    scores[feasible] = exp_scaled

    return scores
```
