```python
import numpy as np

# Global constant for bin capacity (assumed normalized to 1.0)
BIN_CAPACITY = 1.0

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    The score for each currently opened bin combines:
      • a sigmoid on the normalized slack after placement, with steepness
        scaling according to how full the bin already is;
      • a large bonus for an exact fit;
      • a modest reuse bonus (penalising opening a new bin);
      • a one‑step look‑ahead term that slightly favours bins leaving some slack;
      • a tiny deterministic jitter to break exact ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each opened bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``). Infeasible
        bins receive ``-inf`` so they are never selected.
    """
    # Ensure NumPy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Feasibility mask: bin can accommodate the item only if remaining capacity >= item
    feasible = bins_remain_cap >= item

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – caller should open a new bin
        return priorities

    # Slack after placing the item (non‑negative for feasible bins)
    slack = bins_remain_cap - item
    slack_norm = slack / BIN_CAPACITY  # normalized to [0, 1]

    # Fullness of each bin before placement (0 for empty, 1 for completely full)
    fullness = 1.0 - (bins_remain_cap / BIN_CAPACITY)

    # Steepness of the sigmoid scales with fullness
    base_k = 5.0            # base steepness
    scale_factor = 5.0      # how much steepness grows with fullness
    k = base_k * (1.0 + scale_factor * fullness)

    # Decreasing sigmoid on normalized slack; multiplied by 2 maps exact‑fit to 1
    sigmoid_score = 2.0 / (1.0 + np.exp(k * slack_norm))

    # Exact‑fit bonus (large boost when slack is essentially zero)
    eps = 1e-12
    exact_fit_bonus = np.where(slack <= eps, 10.0, 0.0)

    # Reuse bonus – small constant that makes using an existing bin slightly better
    reuse_bonus = 0.05

    # One‑step look‑ahead term: modestly reward bins that leave a bit of slack
    lookahead_weight = 0.2
    lookahead_score = lookahead_weight * slack_norm

    # Tiny deterministic jitter to break ties (prefers lower index)
    # Using a negative sign ensures index 0 gets the highest tie‑breaker.
    jitter = -np.arange(bins_remain_cap.size) * 1e-12

    # Combine all components for feasible bins
    combined_score = (
        sigmoid_score
        + exact_fit_bonus
        + reuse_bonus
        + lookahead_score
        + jitter
    )

    # Assign combined scores only to feasible bins
    priorities[feasible] = combined_score[feasible]

    return priorities
```
