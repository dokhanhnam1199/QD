```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    alpha: float = 0.5,
    penalty_factor: float = 0.1,
    temperature: float = 1.0,
    index_weight: float = 1e-6,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing problem.

    The priority blends a best‑fit (tight fit) component with a worst‑fit
    (spreading load) component, penalises waste, and applies temperature
    scaling. Infeasible bins receive ``-inf``. A tiny index bias favours bins
    with lower indices when scores are otherwise equal.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently opened bin.
    alpha : float, optional
        Blend factor in [0, 1] controlling the mix of worst‑fit (alpha=1) and
        best‑fit (alpha=0). Default is 0.5.
    penalty_factor : float, optional
        Linear penalty proportional to the leftover capacity (waste). Larger
        values discourage placing items into bins that would leave a lot of
        unused space. Default is 0.1.
    temperature : float, optional
        Temperature for scaling the raw scores; must be >0. Higher values flatten
        the distribution, making the choice more exploratory. Default is 1.0.
    index_weight : float, optional
        Small coefficient applied to the bin index to break ties in favour of
        lower‑indexed bins. Default is 1e-6.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``). The bin
        with the highest score should be selected for the item.
    """
    # Ensure we work with a float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialise all scores as infeasible
    scores = np.full_like(caps, fill_value=-np.inf, dtype=float)

    # Feasibility mask: bins that can accommodate the item
    feasible = caps >= item
    if not np.any(feasible):
        return scores

    # Leftover capacity after placing the item (non‑negative)
    leftover = caps[feasible] - item

    # Best‑fit component (tight fit → higher priority)
    best_score = -leftover
    # Worst‑fit component (more free space → higher priority)
    worst_score = leftover

    # Blend best‑fit and worst‑fit
    combined = (1.0 - alpha) * best_score + alpha * worst_score

    # Penalise waste (larger leftover ⇒ larger penalty)
    combined -= penalty_factor * leftover

    # Temperature scaling (guard against non‑positive values)
    if temperature <= 0.0:
        temperature = 1e-8
    combined /= temperature

    # Index bias: lower indices receive a slight boost
    idx = np.arange(caps.size, dtype=float)
    combined -= index_weight * idx[feasible]

    # Assign computed priorities back to the full score vector
    scores[feasible] = combined

    return scores
```
