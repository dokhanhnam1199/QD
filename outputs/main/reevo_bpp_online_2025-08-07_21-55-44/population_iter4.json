[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute deterministic priority scores for online bin packing.\n\n    The priority reflects:\n      * Exact fits receive a huge bonus.\n      * Among feasible bins, a smaller leftover after placing the item\n        yields a higher priority.\n      * A quadratic penalty on leftover discourages large fragments.\n      * A tiny index\u2011based epsilon breaks ties deterministically.\n\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more desirable).  The caller should\n        select the bin with the maximal score.\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Handle empty input\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialize priorities to -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return priorities\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Base priority: negative leftover plus a small quadratic penalty\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Deterministic tie\u2011breaker: tiny epsilon weighted by bin index\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    priorities[feasible] = base_priority[feasible]\n\n    # Exact fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e9\n        priorities[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute dynamic priority scores for bins in an online Bin Packing Problem.\n\n    The priority blends best\u2011fit (tight leftover) and worst\u2011fit (large leftover)\n    using a data\u2011driven weight \u03b1 that adapts to the current distribution of\n    leftovers.  A linear waste penalty is subtracted, and a temperature\n    scaling smooths the scores.  A tiny negative tie\u2011breaker based on the\n    bin index resolves exact ties.  Feasible bins that cannot accommodate the\n    item receive -inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure numeric array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n\n    # If no feasible bin, return -inf for all\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item is placed\n    leftover = caps[feasible] - item  # >= 0\n\n    # ----- Dynamic alpha based on leftover distribution -----\n    max_leftover = np.max(leftover)\n    if max_leftover > 0:\n        mean_leftover = np.mean(leftover)\n        alpha = np.clip(mean_leftover / max_leftover, 0.0, 1.0)\n    else:\n        # All feasible bins are exact fits\n        alpha = 0.5\n\n    # ----- Normalize leftover to [0,1] for stable scoring -----\n    if max_leftover > 0:\n        leftover_norm = leftover / max_leftover\n    else:\n        leftover_norm = leftover  # all zeros\n\n    # ----- Best\u2011fit and worst\u2011fit components -----\n    best_score = -leftover_norm   # tighter fit \u2192 higher\n    worst_score = leftover_norm   # larger leftover \u2192 higher\n\n    # ----- Linear blend -----\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # ----- Waste penalty -----\n    base_penalty = 0.1\n    penalty_factor = base_penalty * np.mean(leftover_norm)\n    combined -= penalty_factor * leftover_norm\n\n    # ----- Temperature scaling -----\n    std_norm = np.std(leftover_norm)\n    temperature = 1.0 + std_norm  # higher variation \u2192 smoother scores\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # ----- Tie\u2011breaker based on bin index (avoid fixed epsilon) -----\n    idx = np.arange(caps.size, dtype=float)\n    epsilon = 1e-6 * (np.max(np.abs(combined)) + 1e-12)\n    tie_break = -epsilon * idx\n\n    # ----- Assemble final scores -----\n    full_scores = np.full_like(caps, -np.inf, dtype=float)\n    full_scores[feasible] = combined + tie_break[feasible]\n\n    return full_scores",
    "response_id": 1,
    "obj": 120.811727163941,
    "SLOC": 33.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    alpha: float = 0.5,\n    penalty_factor: float = 0.1,\n    temperature: float = 1.0,\n    index_weight: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing problem.\n\n    The priority blends a best\u2011fit (tight fit) component with a worst\u2011fit\n    (spreading load) component, penalises waste, and applies temperature\n    scaling. Infeasible bins receive ``-inf``. A tiny index bias favours bins\n    with lower indices when scores are otherwise equal.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    alpha : float, optional\n        Blend factor in [0, 1] controlling the mix of worst\u2011fit (alpha=1) and\n        best\u2011fit (alpha=0). Default is 0.5.\n    penalty_factor : float, optional\n        Linear penalty proportional to the leftover capacity (waste). Larger\n        values discourage placing items into bins that would leave a lot of\n        unused space. Default is 0.1.\n    temperature : float, optional\n        Temperature for scaling the raw scores; must be >0. Higher values flatten\n        the distribution, making the choice more exploratory. Default is 1.0.\n    index_weight : float, optional\n        Small coefficient applied to the bin index to break ties in favour of\n        lower\u2011indexed bins. Default is 1e-6.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``). The bin\n        with the highest score should be selected for the item.\n    \"\"\"\n    # Ensure we work with a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all scores as infeasible\n    scores = np.full_like(caps, fill_value=-np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        return scores\n\n    # Leftover capacity after placing the item (non\u2011negative)\n    leftover = caps[feasible] - item\n\n    # Best\u2011fit component (tight fit \u2192 higher priority)\n    best_score = -leftover\n    # Worst\u2011fit component (more free space \u2192 higher priority)\n    worst_score = leftover\n\n    # Blend best\u2011fit and worst\u2011fit\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # Penalise waste (larger leftover \u21d2 larger penalty)\n    combined -= penalty_factor * leftover\n\n    # Temperature scaling (guard against non\u2011positive values)\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # Index bias: lower indices receive a slight boost\n    idx = np.arange(caps.size, dtype=float)\n    combined -= index_weight * idx[feasible]\n\n    # Assign computed priorities back to the full score vector\n    scores[feasible] = combined\n\n    return scores",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Higher scores indicate more desirable bins. Infeasible bins receive\n        ``-np.inf``.\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.shape[0]\n\n    # Default score for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        return priorities\n\n    # Remaining capacity after placing the item\n    leftover = caps - item\n\n    # Feasible bins: enough space to accommodate the item\n    feasible = leftover >= 0\n\n    if not np.any(feasible):\n        # No bin can accommodate the item\n        return priorities\n\n    # Linear penalty: larger leftover => lower priority,\n    # weighted by the item size.\n    priorities[feasible] = -leftover[feasible] * item\n\n    # Reward exact fits with a huge bonus\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)\n    if np.any(exact_fit):\n        EXACT_FIT_BONUS = 1e12\n        priorities[exact_fit] = EXACT_FIT_BONUS\n\n    # Deterministic tie\u2011breaker: slightly penalise larger indices\n    TIE_EPS = 1e-6\n    priorities -= TIE_EPS * np.arange(n_bins)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    The priority incorporates:\n      * Massive bonus for exact fits.\n      * Quadratic penalty on leftover capacity (discourages large fragments).\n      * Tiny index\u2011based epsilon tie\u2011breaker for deterministic selection.\n      * Infeasible bins are assigned ``-np.inf``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better).  The caller should pick\n        the bin with the maximal score.\n    \"\"\"\n    # Convert to a float array for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    n_bins = caps.shape[0]\n\n    # Initialise all scores as -inf (infeasible)\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return scores\n\n    # Leftover capacity after placing the item\n    leftover = caps - item\n\n    # Quadratic penalty on leftover (smaller leftover => larger priority)\n    # \u03b1 controls the strength of the quadratic term\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Tiny epsilon tie\u2011breaker weighted by bin index (earlier bins preferred)\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    scores[feasible] = base_priority[feasible]\n\n    # Exact\u2011fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e12  # sufficiently large to dominate any other term\n        scores[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item, bins_remain_cap, *, bin_capacity=None, lookahead_items=None,\n                alpha=0.2, k_base=8.0, random_state=None):\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing scenario.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array-like of float\n        Remaining capacity of each existing bin.\n    bin_capacity : float, optional\n        Capacity of each bin. If omitted, it is inferred as max(bins_remain_cap) + item.\n    lookahead_items : array-like of float, optional\n        Sizes of future items that may arrive soon.  Bins that can also accommodate\n        more of these items after the current placement receive a bonus.\n    alpha : float, optional\n        Strength of the look\u2011ahead bonus (default 0.2).\n    k_base : float, optional\n        Base steepness for the sigmoid (default 8.0).  It is dynamically increased\n        for bins that are already fuller.\n    random_state : int or np.random.Generator, optional\n        Seed or RNG for tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Infeasible bins (remaining capacity < item) receive ``-np.inf``.\n    \"\"\"\n    rng = np.random.default_rng(random_state)\n\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    if bin_capacity is None:\n        bin_capacity = float(max(bins.max() + item, 1.0))\n\n    feasible = bins >= item\n    if not feasible.any():\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    gaps = bins - item\n    norm_gaps = gaps / bin_capacity\n    fullness = (bin_capacity - bins) / bin_capacity\n    k = k_base * (1.0 + fullness)\n\n    exponent = k * norm_gaps\n    exponent = np.clip(exponent, -700, 700)\n\n    # Compute sigmoid for feasible bins\n    exp_val = np.exp(exponent[feasible])\n    scores = 1.0 / (1.0 + exp_val)\n\n    # Tiny random noise to break ties deterministically\n    scores += rng.uniform(0.0, 1e-6, size=scores.shape)\n\n    # Optional look\u2011ahead boost\n    if lookahead_items is not None and lookahead_items.size > 0:\n        future_gaps = gaps[feasible][:, None] - np.asarray(lookahead_items, dtype=float)[None, :]\n        fits = (future_gaps >= 0).sum(axis=1)\n        fit_ratio = fits / float(lookahead_items.size)\n        scores *= (1.0 + alpha * fit_ratio)\n\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    alpha: float = 0.5,\n    penalty_factor: float = 0.1,\n    temperature: float = 1.0,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    The score for each bin blends a best\u2011fit component (tightest remaining\n    capacity) with a worst\u2011fit component (largest remaining capacity).  A\n    linear waste penalty discourages selections that would leave a lot of\n    unused space.  Scores are temperature\u2011scaled to control the sharpness\n    of the selection.  Infeasible bins (remaining capacity < item) receive\n    ``-np.inf`` and are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    alpha : float, optional\n        Weight of the worst\u2011fit component (0 \u2192 pure best\u2011fit, 1 \u2192 pure worst\u2011fit).\n        Default ``0.5`` (equal blend).\n    penalty_factor : float, optional\n        Coefficient for the linear waste penalty. Larger values penalise bins\n        that would leave more leftover capacity. Default ``0.1``.\n    temperature : float, optional\n        # Temperature for scaling the combined score.\n        Higher values flatten the distribution (more exploration);\n        lower values sharpen differences (more exploitation). Default ``1.0``.\n    epsilon : float, optional\n        Small constant to avoid division\u2011by\u2011zero and to provide a deterministic\n        tie\u2011breaker based on bin index. Default ``1e-12``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Infeasible bins have score ``-np.inf``.\n    \"\"\"\n    # Ensure the input is a float NumPy array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all scores as -inf (infeasible)\n    scores = np.full_like(caps, fill_value=-np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No feasible bin \u2013 return the all -inf array\n        return scores\n\n    # Clip alpha to [0, 1] for safety\n    alpha = np.clip(alpha, 0.0, 1.0)\n\n    # Compute leftover capacity for each feasible bin\n    leftover capacity after placing the item\n    leftover = caps[feasible] - item  # >= 0\n\n    # ---- Component scores -------------------------------------------------\n    # Best\u2011fit: tighter fit \u2192 higher priority (negative leftover)\n    best_score = -leftover\n\n    # Worst\u2011fit: looser fit \u2192 higher priority (positive leftover)\n    worst_score = leftover\n\n    # Linear blend of best\u2011fit and worst\u2011fit\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # Apply a linear waste penalty (larger leftover => larger penalty)\n    combined -= penalty_factor * leftover\n\n    # ---- Temperature scaling -----------------------------------------------\n    temp = max(temperature, epsilon)  # avoid division by zero\n    combined /= temp\n\n    # ---- Deterministic tie\u2011breaker (prefer lower index) --------------------\n    # Subtract a tiny amount proportional to the bin index.\n    idx = np.arange(caps.size, dtype=float)[feasible]\n    combined -= epsilon * idx\n\n    # Populate the scores array for feasible bins\n    scores[feasible] = combined\n\n    return scores",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 63\n    leftover capacity after placing the item\n             ^^^^^^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 63\n    leftover capacity after placing the item\n             ^^^^^^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 63\n    leftover capacity after placing the item\n             ^^^^^^^^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e7,\n    slack_decay: float = 12.0,\n    next_item_factor: float = 0.05,\n    jitter: float = 1e-12,\n    atol: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    Higher scores indicate a more desirable bin for the incoming ``item``.\n    The priority combines several heuristics:\n      \u2022 Large bonus for an exact fit (remaining capacity \u2248 0).\n      \u2022 Exponential slack penalty: bins with less leftover capacity get a\n        larger boost, encouraging tight packing.\n      \u2022 Anticipation bonus: slight extra score if the bin would still hold\n        another item of the same size after placement.\n      \u2022 Deterministic tie\u2011breaker based on bin index (jitter).\n\n    Infeasible bins (insufficient capacity) receive ``-inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    exact_fit_bonus : float, optional\n        Bonus added for bins where the item fits exactly.\n    slack_decay : float, optional\n        Controls steepness of the exponential slack bonus.\n    next_item_factor : float, optional\n        Small bonus for bins that could still accommodate another item of\n        size ``item`` after this placement.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n    atol : float, optional\n        Absolute tolerance for detecting an exact fit.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Compute slack (remaining capacity after placing the item)\n    slack = caps - item\n    feasible : np.ndarray = slack >= 0\n\n    # Initialise priority with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin; return early\n        # (All entries already -inf)\n        return priority\n\n    # Base priority: negative slack (less waste = higher score)\n    base = -slack[feasible]\n\n    # Normalized slack for exponential bonus\n    max_slack = np.max(slack[feasible])\n    norm_slack = slack[feasible] / (max_slack + atol)  # avoid division by zero\n\n    # Exponential slack bonus (high when slack is small)\n    slack_bonus = np.exp(-slack_decay * norm_slack)\n\n    # Combine base and slack bonus\n    priority[feasible] = base + slack_bonus\n\n    # Anticipation bonus: still room for another item of same size\n    anticipate_mask = feasible & (slack >= item)\n    priority[anticipate_mask] += next_item_factor\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins slightly\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_exponent_k: float = 12.0,\n    next_item_bonus: float = 0.05,\n    jitter: float = 1e-12,\n    exact_fit_atol: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    For a given incoming ``item`` the function returns a score for each currently\n    opened bin.  Higher scores indicate a more desirable bin for placement.\n\n    Heuristics incorporated:\n    \u2022 **Exact\u2011fit bonus** \u2013 a huge boost when the item fills a bin almost\n      perfectly.\n    \u2022 **Slack penalty** \u2013 bins with larger residual capacity after placement are\n      penalised via an exponential term.\n    \u2022 **Anticipation bonus** \u2013 a small extra reward if the bin would still have\n      enough room for another item of the same size after the placement.\n    \u2022 **Deterministic jitter** \u2013 a tiny index\u2011based term to break ties in a\n      reproducible way.\n    \u2022 **Infeasibility handling** \u2013 bins that cannot accommodate the item receive\n      ``-np.inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each opened bin.\n    exact_fit_bonus : float, optional\n        Large constant added when the item exactly fits a bin (default 1e6).\n    slack_exponent_k : float, optional\n        Controls steepness of the exponential slack penalty (default 12.0).\n    next_item_bonus : float, optional\n        Small bonus for bins that would still accommodate another item of the\n        same size after placement (default 0.05).\n    jitter : float, optional\n        Magnitude of deterministic tie\u2011breaker based on bin index (default\n        1e-12).\n    exact_fit_atol : float, optional\n        Absolute tolerance for treating a placement as an exact fit (default\n        1e-12).\n    eps : float, optional\n        Small constant to avoid division\u2011by\u2011zero when normalising slack\n        (default 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  The caller should\n        select the bin with the maximum priority.\n    \"\"\"\n    # Ensure a flat float array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins_remain_cap.size\n\n    # Edge case: no bins at all\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Compute slack (remaining capacity) if the item were placed\n    slack = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative slack can hold the item\n    feasible = slack >= 0.0\n\n    # Initialise priorities with -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If there are no feasible bins, return early\n    if not feasible.any():\n        return priorities\n\n    # Base priority: negative slack (higher for tighter fits)\n    base_priority = -slack[feasible]\n\n    # Normalise slack for the exponential term\n    max_slack = slack[feasible].max()\n    denom = max_slack + eps          # avoid division by zero\n    norm_slack = slack[feasible] / denom\n\n    # Exponential slack bonus: larger for smaller slack\n    slack_bonus = np.exp(-slack_exponent_k * norm_slack)\n\n    # Anticipation bonus: bin still fits another item of the same size\n    anticipate_bonus = np.where(slack[feasible] >= item, next_item_bonus, 0.0)\n\n    # Combine components for feasible bins\n    priority_feasible = base_priority + slack_bonus + anticipate_bonus\n\n    # Exact\u2011fit boost (within tolerance)\n    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)\n    priority_feasible[exact_fit_mask] += exact_fit_bonus\n\n    # Insert feasible priorities back into full array\n    priorities[feasible] = priority_feasible\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins ever so slightly\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priorities += tie_breaker\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a deterministic priority score for each bin in an online bin\u2011packing\n    scenario.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array (or array\u2011like) containing the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Higher scores indicate a more desirable bin. Infeasible bins (remaining\n        capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # Convert to a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Default score for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Feasible bins have non\u2011negative leftover\n    feasible = leftover >= 0\n    if not feasible.any():\n        # No feasible bin; return all -inf\n        return priorities\n\n    # Linear penalty: larger leftover \u2192 lower priority.\n    # Multiplying by ``item`` gives a stronger penalty for larger items.\n    priorities[feasible] = -leftover[feasible] * item\n\n    # Exact\u2011fit detection: treat negligible leftover as zero.\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 43\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1\n                                     ^\nSyntaxError: '(' was never closed\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 43\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1\n                                     ^\nSyntaxError: '(' was never closed\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 43\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1\n                                     ^\nSyntaxError: '(' was never closed\n"
  }
]