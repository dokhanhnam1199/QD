```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Enhanced priority function for online Bin Packing.

    The priority is higher (i.e., less negative) for bins that:
      • Can accommodate the item (feasibility).
      • Will have minimal slack after placement (best‑fit style).
      • Are already relatively full (steepness scaled by current fullness).
      • Provide an exact fit (large bonus).
      • Leave only a small slack (small look‑ahead boost).
      • Are not empty (penalize near‑empty bins to discourage opening new bins).

    Tie‑breaking is done with a tiny deterministic jitter based on the bin index.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently opened bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``). The caller
        should select the bin with the maximum priority. Bins that cannot hold
        the item receive ``-np.inf`` priority.
    """
    # Ensure NumPy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no bins opened yet
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Estimate the (fixed) bin capacity.
    # For online BPP the full capacity is the maximum remaining capacity among
    # opened bins (empty bins retain full capacity). Fallback to 1.0 if needed.
    capacity = bins_remain_cap.max()
    if capacity <= 0:
        capacity = 1.0

    # Slack (waste) if the item were placed in each bin
    waste = bins_remain_cap - item

    # Feasibility mask
    feasible = waste >= 0

    # Normalized slack (0 = exact fit, 1 = completely empty bin)
    slack_norm = np.where(feasible, waste / capacity, np.nan)

    # Current fullness before placement (0 = empty, 1 = full)
    fullness = (capacity - bins_remain_cap) / capacity

    # --- 1. Base priority: scaled best‑fit via a power‑law (sigmoid‑like) ---
    # Steepness grows with bin fullness: fuller bins get a steeper penalty for
    # any remaining slack.
    gamma = 2.0               # controls steepness scaling
    steepness = 1.0 + gamma * fullness
    # Power‑law transformation: smaller slack -> higher (less negative) priority
    base_priority = np.where(
        feasible,
        - (slack_norm ** steepness),
        -np.inf
    )

    # --- 2. Exact‑fit bonus (strongly reward waste == 0) ---
    exact_fit_bonus = np.where(
        feasible & np.isclose(waste, 0.0, atol=1e-12),
        10.0,                     # large positive boost
        0.0
    )

    # --- 3. Small look‑ahead boost for bins that would leave tiny slack ---
    # Encourage bins that after placement still have room for a typical future
    # item (here approximated by slack <= 5% of capacity).
    lookahead_threshold = 0.05
    lookahead_boost = np.where(
        feasible & (slack_norm <= lookahead_threshold),
        0.5,                      # modest positive boost
        0.0
    )

    # --- 4. Penalty for using near‑empty bins (discourage new bin usage) ---
    beta = 0.5
    empty_penalty = -beta * (1.0 - fullness)   # larger penalty for emptier bins

    # --- 5. Deterministic tie‑breaker (tiny jitter) ---
    epsilon = 1e-12
    tie_breaker = -np.arange(bins_remain_cap.size) * epsilon

    # Combine all components
    priority = (
        base_priority
        + exact_fit_bonus
        + lookahead_boost
        + empty_penalty
        + tie_breaker
    )

    return priority
```
