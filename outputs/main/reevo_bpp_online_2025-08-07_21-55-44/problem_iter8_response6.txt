```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    bin_capacity: float = 1.0,
    exact_fit_bonus: float = 1e6,
    slack_weight: float = 1.0,
    new_bin_penalty: float = 0.2,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Compute priority scores for an online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of already opened bins.
    bin_capacity : float, optional
        Fixed capacity of every bin (default 1.0).
    exact_fit_bonus : float, optional
        Bonus added to a bin that would be exactly filled (default 1e6).
    slack_weight : float, optional
        Linear weight for normalized slack (default 1.0).
    new_bin_penalty : float, optional
        Multiplicative penalty applied to the waste of a newly opened bin
        (default 0.2 → 20 % extra waste).
    epsilon : float, optional
        Tiny value for deterministic tie‑breaking (default 1e‑12).

    Returns
    -------
    np.ndarray
        Array of priority scores with shape ``(len(bins_remain_cap) + 1,)``.
        The last entry corresponds to the virtual new bin.
    """
    # Basic validation
    if bin_capacity <= 0:
        raise ValueError("bin_capacity must be positive")
    if item < 0:
        raise ValueError("item size must be non‑negative")

    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    if bins_remain_cap.ndim != 1:
        raise ValueError("bins_remain_cap must be a 1‑D array")

    n_bins = bins_remain_cap.size

    # Waste after placing the item in each existing bin
    waste = bins_remain_cap - item
    feasible = waste >= 0

    # Normalized slack (waste / bin_capacity) for feasible bins
    slack = np.where(feasible, waste / bin_capacity, np.inf)

    # Base priority: negative weighted slack (smaller slack → higher priority)
    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)

    # Exact‑fit bonus
    exact_fit_mask = np.isclose(waste, 0.0, atol=epsilon)
    base_priority = np.where(exact_fit_mask, base_priority + exact_fit_bonus, base_priority)

    # Deterministic tie‑breaker: tiny advantage for lower indices
    base_priority += -np.arange(n_bins, dtype=float) * epsilon

    # -------- Virtual new bin ----------
    waste_new = bin_capacity - item
    if waste_new < 0:
        new_bin_priority = -np.inf
    else:
        slack_new = waste_new / bin_capacity
        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)
        if np.isclose(waste_new, 0.0, atol=epsilon):
            new_bin_priority += exact_fit_bonus
        # Tie‑breaker for the virtual bin (neutral index after all real bins)
        new_bin_priority += -n_bins * epsilon

    # Append virtual new bin priority as the last element
    priorities = np.append(base_priority, new_bin_priority)

    return priorities
```
