```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    bin_capacity: float = 1.0,
    avg_future_item: float = None,
) -> np.ndarray:
    """
    Advanced priority function for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently opened bins.
    bin_capacity : float, optional
        Fixed capacity of each bin (default = 1.0).
    avg_future_item : float, optional
        Expected size of a typical future item; used for a one‑step look‑ahead boost.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher values indicate more desirable bins.
        Infeasible bins receive ``-np.inf``.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    waste = bins_remain_cap - item
    feasible = waste >= 0

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # ---------- Parameter settings ----------
    alpha = 5.0          # exponential slack penalty steepness
    beta = 4.0           # scaling with current bin fullness
    exact_fit_reward = 1e6
    lookahead_boost = 0.2
    epsilon = 1e-12
    tol = 1e-9
    # ----------------------------------------

    # Fullness before placement (0 = empty, 1 = full)
    fullness_before = (bin_capacity - bins_remain_cap) / bin_capacity
    # Penalty steepness factor grows with bin fullness
    factor = 1.0 + beta * fullness_before

    # Normalized slack (waste) after placing the item
    normalized_slack = waste / bin_capacity

    # Exponential penalty: larger slack → more negative priority
    penalty = -np.exp(alpha * normalized_slack * factor)

    # Apply penalty to feasible bins
    priorities[feasible] = penalty[feasible]

    # Massive reward for an exact fit (waste ≈ 0)
    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=tol)
    priorities[exact_fit_mask] = exact_fit_reward

    # One‑step look‑ahead boost if we have an estimate of future item size
    if avg_future_item is not None:
        boost_mask = feasible & (waste >= avg_future_item)
        if np.any(boost_mask):
            # Boost proportional to the surplus capacity beyond the expected future item
            boost = lookahead_boost * ((waste[boost_mask] - avg_future_item) / bin_capacity)
            priorities[boost_mask] += boost

    # Tiny tie‑breaker: deterministic component (index) plus minuscule random noise
    N = bins_remain_cap.size
    det_eps = -np.arange(N) * epsilon
    rand_eps = (np.random.rand(N) - 0.5) * epsilon * 0.1  # ±0.05·ε
    tie_breaker = det_eps + rand_eps
    priorities += tie_breaker

    return priorities
```
