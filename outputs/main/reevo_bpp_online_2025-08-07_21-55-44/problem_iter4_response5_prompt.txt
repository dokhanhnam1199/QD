{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    beta: float = 10.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    The priority is based on a normalized residual capacity after placing the\n    item, transformed through a steep sigmoid so that bins with a tight fit\n    obtain a high score while bins with large leftover capacity obtain a low\n    score. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` to guarantee they are never selected, unless the optional\n    ``epsilon``\u2011greedy exploration is active.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for the existing bins.\n    beta : float, optional\n        Steepness of the sigmoid; larger values increase the contrast between\n        tight and loose fits. Must be non\u2011negative.\n    epsilon : float, optional\n        Exploration probability (0 \u2264 epsilon \u2264 1). With probability ``epsilon``\n        the function returns random scores for feasible bins to encourage\n        exploration of sub\u2011optimal placements.\n    rng : np.random.Generator | None, optional\n        Random number generator for reproducibility. If ``None``, a fresh\n        default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape ``bins_remain_cap.shape``). Higher\n        values indicate a more desirable placement.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    # Ensure input is a 1\u2011D float array\n    remain = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = remain.size\n\n    # Empty case \u2013 nothing to score\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialise all priorities as -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible_mask = remain >= item\n    n_feasible = feasible_mask.sum()\n    if n_feasible == 0:\n        # No bin can accommodate the item; return all -inf\n        return priorities\n\n    # Exploration vs exploitation\n    explore = rng.random() < epsilon\n\n    if explore:\n        # Random uniform scores for exploration\n        raw_scores = rng.random(n_feasible)\n    else:\n        # Residual capacity after placing the item\n        residual = remain[feasible_mask] - item\n\n        # Normalise residuals to [0, 1] using the maximum residual as scale.\n        scale = residual.max()\n        scale = scale if scale > 0 else 1.0  # avoid division by zero\n        normalized = residual / scale\n\n        # Sigmoid transform: higher priority for smaller residuals.\n        # Numerically stable: exponent \u2208 [-beta, 0]\n        exp_term = np.exp(-beta * normalized)\n        raw_scores = 1.0 / (1.0 + exp_term)\n\n    # Tiny jitter to break ties deterministically\n    jitter = rng.random(n_feasible) * 1e-9\n    raw_scores = raw_scores + jitter\n\n    # Populate the priority array\n    priorities[feasible_mask] = raw_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[np.ndarray] = None,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The priority favours bins that will have a small positive residual after\n    packing the current `item`.  It additionally:\n\n    * Adjusts the sigmoid sharpness (parameter `k`) according to how full the\n      bin already is \u2013 fuller bins receive a steeper curve, encouraging tighter\n      packing.\n    * Normalises gaps by the bin capacity to make the score scale\u2011invariant.\n    * Adds a tiny random tie\u2011breaker to avoid deterministic ties.\n    * (Optionally) incorporates a simple look\u2011ahead: bins that are also able to\n      accommodate more of the upcoming items obtain a boost.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n    bin_capacity : float, optional\n        Fixed capacity of each bin.  If omitted it is inferred as the maximum\n        possible capacity observed (the largest remaining capacity plus the\n        current item size).  All bins are assumed to have the same capacity.\n    lookahead_items : np.ndarray, optional\n        1\u2011D array of sizes of future items that may arrive soon.  The function\n        rewards bins that could also hold at least one of these items after the\n        current one is placed.\n    random_state : int, optional\n        Seed for the internal RNG used for tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Infeasible bins (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------ #\n    # Preparations\n    # ------------------------------------------------------------------ #\n    rng = np.random.default_rng(random_state)\n\n    # Ensure a proper NumPy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Infer bin capacity if not supplied (assumes homogeneous bins)\n    if bin_capacity is None:\n        # At least one bin must be able to hold the current item.\n        # Adding `item` guarantees capacity is not underestimated.\n        bin_capacity = float(bins_remain_cap.max() + item)\n\n    # ------------------------------------------------------------------ #\n    # Feasibility mask\n    # ------------------------------------------------------------------ #\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities with -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    if not feasible.any():\n        # No bin can accommodate the item; return all -inf.\n        return priorities\n\n    # ------------------------------------------------------------------ #\n    # Core sigmoid score (small residuals preferred)\n    # ------------------------------------------------------------------ #\n    # Gap after placing the item\n    gaps = bins_remain_cap - item                     # may be negative for infeasible\n\n    # Normalise gaps to [0, 1] using the known bin capacity\n    norm_gaps = gaps / bin_capacity\n\n    # Base steepness of the sigmoid\n    base_k = 8.0\n\n    # Dynamically adjust k: fuller bins (small remaining capacity) get larger k\n    # fullness factor = (C - remaining) / C  \u2208 [0, 1]\n    fullness = (bin_capacity - bins_remain_cap) / bin_capacity\n    dynamic_k = base_k * (1.0 + fullness)            # \u2208 [base_k, 2*base_k]\n\n    # Compute sigmoid safely (clip exponent to avoid overflow)\n    exponent = np.clip(dynamic_k * norm_gaps, -700, 700)\n    sigmoid_score = np.where(\n        feasible,\n        1.0 / (1.0 + np.exp(exponent)),  # larger when norm_gaps is small\n        -np.inf\n    )\n\n    # ------------------------------------------------------------------ #\n    # Tie\u2011breaking random noise (very small magnitude)\n    # ------------------------------------------------------------------ #\n    noise = rng.uniform(0.0, 1e-6, size=bins_remain_cap.shape)\n    sigmoid_score += noise\n\n    # ------------------------------------------------------------------ #\n    # Look\u2011ahead boost (optional)\n    # ------------------------------------------------------------------ #\n    if lookahead_items is not None and lookahead_items.size > 0:\n        # Broadcast to compute remaining capacity after placing current item\n        # and each look\u2011ahead item.\n        future_gaps = bins_remain_cap[:, None] - item - lookahead_items[None, :]\n        # Count how many future items could still fit in each bin.\n        future_fits = (future_gaps >= 0).sum(axis=1)\n        # Normalise to [0, 1]\n        fit_ratio = future_fits / lookahead_items.size\n        # Boost factor: bins that can host more future items are slightly favoured.\n        # Alpha controls the strength of the boost.\n        alpha = 0.2\n        boost = 1.0 + alpha * fit_ratio\n        sigmoid_score *= boost\n\n    # ------------------------------------------------------------------ #\n    # Assemble final priority vector\n    # ------------------------------------------------------------------ #\n    priorities[feasible] = sigmoid_score[feasible]\n\n    return priorities\n\n[Reflection]\nUse capacity\u2011scaled sigmoid, dynamic k per bin fullness, tie\u2011breaker noise, lookahead boosts, ensure numerically stable exponent clipping.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}