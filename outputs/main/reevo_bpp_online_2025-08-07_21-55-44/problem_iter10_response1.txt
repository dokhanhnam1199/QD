```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, list, tuple],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,
    k_base: float = 8.0,
    alpha: float = 0.2,
    random_state: Optional[Union[int, np.random.Generator]] = None,
    jitter: float = 1e-6,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacity of each currently opened bin.
    bin_capacity : float, optional
        Fixed capacity of a bin.  If ``None`` the maximum remaining
        capacity observed in ``bins_remain_cap`` is used.
    lookahead_items : array‑like of float, optional
        Sizes of future items.  Bins that can still accommodate more of
        these items after the current placement receive a modest
        multiplicative boost.
    k_base : float, default 8.0
        Base steepness for the adaptive sigmoid.  The steepness is
        scaled by bin fullness so fuller bins get a steeper curve.
    alpha : float, default 0.2
        Strength of the look‑ahead boost (0 ≤ alpha ≤ 1).
    random_state : int or np.random.Generator, optional
        Seed or generator for a tiny random tie‑breaking noise.
    jitter : float, default 1e-6
        Magnitude of deterministic tie‑breaker (lower‑index bins get a tiny
        advantage).  Also used as the upper bound for random noise.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  Infeasible
        bins (remaining capacity < ``item``) receive ``-np.inf`` and are
        never selected.

    Notes
    -----
    The score for each feasible bin is based on:
      1. Normalised slack after placing the item.
      2. An adaptive sigmoid that steepens with bin fullness.
      3. A multiplicative look‑ahead boost if ``lookahead_items`` are
         provided.
      4. Tiny deterministic and random tie‑breakers to resolve exact
         ties reproducibly.
    """
    bins = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    if bin_capacity is None:
        # Use the maximum remaining capacity observed as the nominal bin size.
        bin_capacity = float(np.max(bins)) + 1e-9

    # Feasibility mask
    feasible = bins >= item
    if not np.any(feasible):
        return np.full_like(bins, -np.inf, dtype=float)

    # Slack after placement for feasible bins
    slack = bins[feasible] - item  # shape (m,)
    # Normalised gaps (0 when tight fit, 1 when fully slack)
    norm_gaps = slack / bin_capacity
    norm_gaps = np.clip(norm_gaps, 0.0, 1.0)

    # Bin fullness relative to capacity (0 empty, 1 full)
    fullness = (bin_capacity - bins[feasible]) / bin_capacity
    fullness = np.clip(fullness, 0.0, 1.0)

    # Adaptive sigmoid steepness: fuller bins get steeper curves
    k = k_base * (1.0 + fullness)

    # Shift gaps so that tighter fits get higher values
    max_norm_gap = np.max(norm_gaps)
    shift = max_norm_gap - norm_gaps
    exponent = k * shift
    exponent = np.clip(exponent, -700.0, 700.0)  # avoid overflow

    # Adaptive sigmoid scoring in (0.5, 1]
    scores = 1.0 / (1.0 + np.exp(-exponent))

    # Optional look‑ahead boost
    if lookahead_items is not None:
        lookahead = np.asarray(lookahead_items, dtype=float)
        if lookahead.size > 0:
            # Remaining capacity after placement for each feasible bin
            remaining = slack  # shape (m,)
            # Count how many lookahead items each bin can still fit
            fits = (remaining[:, None] >= lookahead[None, :]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0,1]
            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio
            scores *= boost

    # Tiny random tie‑breaker
    rng = np.random.default_rng(random_state)
    noise = rng.uniform(0.0, jitter, size=scores.shape)
    scores += noise

    # Assemble priority vector
    priority = np.full_like(bins, -np.inf, dtype=float)
    priority[feasible] = scores

    # Deterministic tie‑breaker (lower index gets a slight advantage)
    priority += -np.arange(n_bins, dtype=float) * jitter

    return priority
```
