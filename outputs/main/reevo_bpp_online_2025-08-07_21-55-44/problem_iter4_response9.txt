```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a deterministic priority score for each bin in an online bin‑packing
    scenario.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array (or array‑like) containing the remaining capacity of each existing bin.

    Returns
    -------
    np.ndarray
        Array of priority scores with the same shape as ``bins_remain_cap``.
        Higher scores indicate a more desirable bin. Infeasible bins (remaining
        capacity < ``item``) receive ``-np.inf``.
    """
    # Convert to a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Default score for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Compute leftover capacity after placing the item
    leftover = caps - item

    # Feasible bins have non‑negative leftover
    feasible = leftover >= 0
    if not feasible.any():
        # No feasible bin; return all -inf
        return priorities

    # Linear penalty: larger leftover → lower priority.
    # Multiplying by ``item`` gives a stronger penalty for larger items.
    priorities[feasible] = -leftover[feasible] * item

    # Exact‑fit detection: treat negligible leftover as zero.
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1

```
**Error**: The provided code snippet has a syntax error. The function `priority_v2` is missing the closing parentheses for its definition. Additionally, the code block ends abruptly and is incomplete. Please correct the syntax errors and ensure the entire function is properly defined and closed.```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a deterministic priority score for each bin in an online bin‑packing
    scenario.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array (or array‑like) containing the remaining capacity of each
        existing bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher scores indicate a more desirable
        bin. Infeasible bins (remaining capacity < ``item``) receive ``-np.inf``.
    """
    # Ensure a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Default score for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Remaining capacity after placing the item
    leftover = caps - item

    # Feasible bins have non‑negative leftover
    feasible = leftover >= 0
    if not feasible.any():
        # No bin can accommodate the item
        return priorities

    # Linear penalty: larger leftover → lower priority.
    # Multiplying by ``item`` makes the penalty stronger for larger items.
    priorities[feasible] = -leftover[feasible] * item

    # Exact‑fit detection (tolerance handles floating‑point noise)
    exact_fit = feasible & np.isclose(leftover,  # type: ignore[operator]
                                    0.0,
                                    atol=1e-12,
                                    rtol=0.0)
    if exact_fit.any():
        # Choose a bonus that dominates any possible linear penalty.
        # The worst (most negative) penalty is -max(leftover) * item.
        max_penalty = -np.max(leftover[feasible]) * item
        EXACT_FIT_BONUS = max_penalty + 1.0e6
        priorities[exact_fit] = EXACT_FIT_BONUS

    # Deterministic tie‑break: prefer lower‑index bins.
    # The epsilon is tiny enough not to affect ordering from penalties/bonuses.
    epsilon = 1e-9
    priorities -= epsilon * np.arange(n_bins)

    return priorities
```
