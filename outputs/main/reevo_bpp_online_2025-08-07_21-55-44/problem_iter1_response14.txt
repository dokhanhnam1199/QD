```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Exact Fit First priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1â€‘D array with the remaining capacities of existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher = more desirable).  The caller
        should select the bin with the maximal score.  Bins that cannot fit
        the item receive a large negative penalty, exact fits receive a very
        high bonus, and among the remaining feasible bins the one leaving the
        smallest leftover gets the highest priority.
    """
    # Ensure we work with floats (copy not mandatory but safe)
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialize all priorities to a very low value (unfeasible)
    priorities = np.full(caps.shape, -np.inf, dtype=float)

    # Feasibility mask: bins that have enough space for the item
    feasible = caps >= item
    if not feasible.any():
        # No bin can accommodate the item; return penalties (caller can open a new bin)
        return priorities

    # Compute leftover space after placing the item in each feasible bin
    leftover = caps - item

    # Base priority: the smaller the leftover, the higher the priority.
    # Using negative leftover makes an exact fit (leftover = 0) the highest
    # among feasible bins (priority = 0), while larger leftovers give negative values.
    priorities[feasible] = -leftover[feasible]

    # Detect exact fits (within a tolerance) and give them a massive boost
    exact_tolerance = 1e-9
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)
    if exact_fit.any():
        # Bonus large enough to dominate any other feasible priority
        EXACT_FIT_BONUS = 1e9
        priorities[exact_fit] = EXACT_FIT_BONUS

    return priorities
```
