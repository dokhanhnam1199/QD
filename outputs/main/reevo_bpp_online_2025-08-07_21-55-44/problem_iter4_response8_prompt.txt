{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    beta: float = 10.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    The priority is based on a normalized residual capacity after placing the\n    item, transformed through a steep sigmoid so that bins with a tight fit\n    obtain a high score while bins with large leftover capacity obtain a low\n    score. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` to guarantee they are never selected, unless the optional\n    ``epsilon``\u2011greedy exploration is active.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for the existing bins.\n    beta : float, optional\n        Steepness of the sigmoid; larger values increase the contrast between\n        tight and loose fits. Must be non\u2011negative.\n    epsilon : float, optional\n        Exploration probability (0 \u2264 epsilon \u2264 1). With probability ``epsilon``\n        the function returns random scores for feasible bins to encourage\n        exploration of sub\u2011optimal placements.\n    rng : np.random.Generator | None, optional\n        Random number generator for reproducibility. If ``None``, a fresh\n        default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape ``bins_remain_cap.shape``). Higher\n        values indicate a more desirable placement.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    # Ensure input is a 1\u2011D float array\n    remain = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = remain.size\n\n    # Empty case \u2013 nothing to score\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialise all priorities as -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible_mask = remain >= item\n    n_feasible = feasible_mask.sum()\n    if n_feasible == 0:\n        # No bin can accommodate the item; return all -inf\n        return priorities\n\n    # Exploration vs exploitation\n    explore = rng.random() < epsilon\n\n    if explore:\n        # Random uniform scores for exploration\n        raw_scores = rng.random(n_feasible)\n    else:\n        # Residual capacity after placing the item\n        residual = remain[feasible_mask] - item\n\n        # Normalise residuals to [0, 1] using the maximum residual as scale.\n        scale = residual.max()\n        scale = scale if scale > 0 else 1.0  # avoid division by zero\n        normalized = residual / scale\n\n        # Sigmoid transform: higher priority for smaller residuals.\n        # Numerically stable: exponent \u2208 [-beta, 0]\n        exp_term = np.exp(-beta * normalized)\n        raw_scores = 1.0 / (1.0 + exp_term)\n\n    # Tiny jitter to break ties deterministically\n    jitter = rng.random(n_feasible) * 1e-9\n    raw_scores = raw_scores + jitter\n\n    # Populate the priority array\n    priorities[feasible_mask] = raw_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_sigmoid_k: float = 10.0,\n    next_item_bonus: float = 0.1,\n    jitter: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    The function returns a score for each currently opened bin. Higher scores\n    indicate a more desirable bin for the incoming `item`.\n\n    Heuristics incorporated:\n    \u2022 Huge bonus for exact fits (remaining capacity after placement \u2248 0).\n    \u2022 Primary ranking by minimal waste (negative remaining slack).\n    \u2022 A sigmoid\u2011like exponential bonus for bins with small slack\n      (normalized waste \u2192 exp(-k\u00b7norm_slack)).\n    \u2022 Small extra bonus for bins that would still have enough room for another\n      item of size `item` after placement (anticipating the next item).\n    \u2022 Infeasible bins (insufficient capacity) receive -inf priority.\n    \u2022 Tiny index\u2011based jitter to break ties deterministically.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each opened bin.\n    exact_fit_bonus : float, optional\n        Large constant added when the item exactly fits a bin.\n    slack_sigmoid_k : float, optional\n        Controls the steepness of the exponential slack bonus.\n    next_item_bonus : float, optional\n        Small bonus for bins that would still accommodate another item of\n        size `item` after this placement.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``). The caller should\n        select the bin with the maximum priority.\n    \"\"\"\n    # Ensure input is a 1\u2011D NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins_remain_cap.size\n\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Compute remaining slack if the item were placed in each bin\n    slack = bins_remain_cap - item  # slack >= 0 => feasible\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Base priority: negative slack (higher = less waste) for feasible bins,\n    # -inf for infeasible bins.\n    base_priority = np.where(feasible, -slack, -np.inf)\n\n    # Normalized slack for feasible bins (to [0, 1])\n    norm_slack = np.zeros_like(slack)\n    if np.any(feasible):\n        max_slack = np.max(slack[feasible])\n        # Avoid division by zero when all feasible bins have zero slack\n        denom = max_slack + 1e-12\n        norm_slack[feasible] = slack[feasible] / denom\n\n    # Exponential slack bonus: high when slack is small, low when slack is large\n    slack_bonus = np.exp(-slack_sigmoid_k * norm_slack)\n\n    # Anticipate next item: give a tiny boost if the bin would still have\n    # enough capacity for another item of size `item` after this placement.\n    anticipate_bonus = np.where(feasible & (slack >= item), next_item_bonus, 0.0)\n\n    # Combine all components\n    priority = base_priority + slack_bonus + anticipate_bonus\n\n    # Add huge bonus for exact fits (within numerical tolerance)\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: slightly favor lower\u2011index bins\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priority += tie_breaker\n\n    return priority\n\n[Reflection]\nUse exact\u2011fit bonus, exponential slack penalty, anticipate next\u2011item capacity, deterministic jitter; avoid random exploration.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}