{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.1,\n    rng: np.random.Generator | None = None\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for placing an incoming item into existing bins using an epsilon\u2011greedy policy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each existing bin (shape: (n_bins,)).\n    epsilon : float, optional\n        Exploration probability (default=0.1). With probability ``epsilon`` the function returns\n        purely random scores to encourage exploration of sub\u2011optimal bins.\n    rng : np.random.Generator, optional\n        Random number generator for reproducibility. If None, a default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin (higher is preferred). Bins that cannot accommodate the item\n        receive ``-np.inf`` when exploiting, ensuring they are never chosen unless exploration occurs.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    n_bins = bins_remain_cap.shape[0]\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Decide whether to explore (random) or exploit (best\u2011fit heuristic)\n    if rng.random() < epsilon:\n        # Exploration: assign random scores to all bins\n        return rng.random(n_bins)\n    else:\n        # Exploitation: Best\u2011Fit \u2013 prefer bins that leave the smallest slack.\n        remaining_after = bins_remain_cap - item\n        feasible = remaining_after >= 0\n\n        # Initialize all priorities as -inf (infeasible bins)\n        priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n        # For feasible bins, compute a score inversely proportional to the slack.\n        # Smaller slack \u2192 larger score.\n        slack = remaining_after[feasible]\n        # Adding a tiny epsilon prevents division by zero for perfect fits.\n        priorities[feasible] = 1.0 / (slack + 1e-12)\n\n        # Add a tiny random jitter to break ties deterministically.\n        jitter = rng.random(np.count_nonzero(feasible)) * 1e-6\n        priorities[feasible] += jitter\n\n        return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Numerically stable logistic function.\"\"\"\n    return 1.0 / (1.0 + np.exp(-x))\n\n    \"\"\"\n    Sigmoid Fit Score based priority function for online Bin Packing.\n\n    Bins that leave a smaller leftover capacity after placing the item\n    receive higher priority.  The residual (remaining capacity minus the\n    item size) is normalised and fed into a logistic (sigmoid)\n    transform so that bins with an almost perfect fit get a score close\n    to 0.5 while bins with a large remaining capacity get a score\n    approaching 0.  Bins that cannot accommodate the item receive a\n    priority of -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n    beta : float, optional\n        Steepness of the logistic curve; larger values lead to a\n        sharper differentiation between exact and loose fits.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin, same shape as `bins_remain_cap`.\n    \"\"\"\n    # Convert to array for safety\n    remain = np.asarray(bins_remain_cap, dtype=float)\n\n    # Default low priority for bins that cannot hold the item\n    priorities = np.full(remain.shape, -np.inf, dtype=float)\n\n    # Identify bins that can accept the item\n    fit_mask = remain >= item\n    if not np.any(fit_mask):\n        return priorities\n\n    # Remaining space after placing the item\n    diff = remain[fit_mask] - item\n\n    # Normalise the difference so that the sigmoid operates on a comparable scale.\n    # The maximum diff among candidate bins provides a good scale.\n    scale = diff.max() if diff.size else 1.0\n    scale = scale if scale > 0 else 1.0\n    norm_diff = diff / scale\n\n    # Logistic transform with negative sign to turn higher residuals into lower scores.\n    # Higher priority => smaller leftover after packing.\n    priorities[fit_mask] = sigmoid(-beta * norm_diff)\n\n    return priorities\n\n[Reflection]\nNormalize residuals, apply sigmoid/softmax, tune steepness, assign \u2013inf to infeasible bins, add tiny jitter for ties.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}