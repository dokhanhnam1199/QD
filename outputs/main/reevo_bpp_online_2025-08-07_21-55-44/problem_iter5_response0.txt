```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    temperature: float = 0.5,
    alpha: float = 0.1,
    exact_fit_bonus: float = 1e6,
    epsilon: float = 1e-12,
    next_item: float | None = None,
) -> np.ndarray:
    """
    Advanced priority function for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently opened bins.
    temperature : float, optional
        Temperature for the softmax scaling. Lower values amplify differences.
    alpha : float, optional
        Coefficient of the quadratic waste penalty (enables online adaptation).
    exact_fit_bonus : float, optional
        Large positive bonus added when an item exactly fits a bin.
    epsilon : float, optional
        Tiny index‑based tie‑breaker; smaller index gets a slight advantage.
    next_item : float | None, optional
        Size of the next item (if known). Bins that can also accommodate the
        next item receive a small additional boost.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins are
        assigned ``-np.inf`` (they will never be selected).
    """
    # Ensure a NumPy array of floats.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Compute waste (remaining capacity after placing the current item).
    waste = bins_remain_cap - item
    feasible = waste >= 0

    # Linear + quadratic waste penalty.
    base = -waste - alpha * np.square(waste)

    # Exact‑fit bonus (massive boost for zero slack).
    exact_fit_mask = np.isclose(waste, 0.0, atol=1e-12)
    base = np.where(exact_fit_mask, base + exact_fit_bonus, base)

    # Optional look‑ahead for the next item.
    if next_item is not None:
        future_waste = waste - next_item
        can_fit_next = future_waste >= 0
        # Small boost for bins that can also host the next item.
        # Additionally, penalise large leftover after both items.
        lookahead_bonus = np.where(
            can_fit_next,
            0.05 - 0.01 * future_waste,  # 0.05 is a base boost.
            0.0,
        )
        base += lookahead_bonus

    # Temperature‑scaled softmax (monotonic transformation).
    if np.any(feasible):
        scaled = base / temperature
        # Stabilise exponentiation by subtracting the max feasible value.
        max_scaled = np.max(scaled[feasible])
        exp_scores = np.exp(scaled - max_scaled)
        # Infeasible bins become -inf so they are never chosen.
        scores = np.where(feasible, exp_scores, -np.inf)
    else:
        # No feasible bin – all scores are -inf (caller should open a new bin).
        scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Deterministic tie‑breaker: favour lower indices by a tiny epsilon.
    scores = scores - epsilon * np.arange(bins_remain_cap.size)

    return scores
```
