```python
import numpy as np
from typing import Optional, Union, Sequence

def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, Sequence[float]],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,
    k_base: float = 8.0,
    reuse_bonus: float = 0.05,
    exact_fit_bonus: float = 10.0,
    lookahead_alpha: float = 0.2,
    jitter: float = 1e-12,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacities of the currently opened bins.
    bin_capacity : float, optional
        Fixed capacity of a bin.  If ``None`` the maximum remaining capacity
        observed is taken as the nominal capacity (plus a tiny epsilon).
    lookahead_items : array‑like of float, optional
        Sizes of future items.  Bins that can still accommodate more of these
        items after the current placement receive a multiplicative boost.
    k_base : float, default 8.0
        Base steepness for the adaptive sigmoid.  Steepness is scaled by
        bin fullness (fuller bins get a steeper curve).
    reuse_bonus : float, default 0.05
        Small constant added to all feasible bins to prefer reusing an
        existing bin over opening a new one.
    exact_fit_bonus : float, default 10.0
        Large boost when the item exactly fits the remaining capacity.
    lookahead_alpha : float, default 0.2
        Strength of the look‑ahead boost (0 ≤ lookahead_alpha ≤ 1).
    jitter : float, default 1e-12
        Magnitude of deterministic tie‑breaker (lower‑index bins get a
        slight advantage) and the upper bound for random noise.
    random_state : int or np.random.Generator, optional
        Seed or generator for the random tie‑breaker.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (shape matches ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf`` and are never selected.
    """
    # Convert inputs to NumPy arrays
    bins = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Determine bin capacity if not supplied
    if bin_capacity is None:
        # Use a tiny epsilon to avoid division by zero if all bins are empty
        bin_capacity = float(np.max(bins)) + 1e-9

    # Feasibility mask: bin can host the item only if it has enough remaining capacity
    feasible = bins >= item
    if not np.any(feasible):
        # No feasible bin – caller will need to open a new one
        return np.full_like(bins, -np.inf, dtype=float)

    # Slack after placing the item (only for feasible bins)
    slack = bins[feasible] - item                     # shape (m,)
    slack_norm = slack / bin_capacity                 # normalised slack ∈ [0, 1]

    # Bin fullness before placement (0 = empty, 1 = completely full)
    fullness = (bin_capacity - bins[feasible]) / bin_capacity
    fullness = np.clip(fullness, 0.0, 1.0)

    # Adaptive sigmoid steepness: steeper for fuller bins
    k = k_base * (1.0 + fullness)                     # shape (m,)

    # Decreasing sigmoid on normalised slack.
    # Smaller slack → larger score. Score ∈ (0, 0.5] after the division.
    # Clip exponent to avoid overflow.
    exponent = k * slack_norm
    exponent = np.clip(exponent, -700.0, 700.0)
    sigmoid_score = 1.0 / (1.0 + np.exp(exponent))

    # Exact‑fit bonus (large boost when slack is essentially zero)
    eps = 1e-12
    exact_bonus = np.where(slack <= eps, exact_fit_bonus, 0.0)

    # Optional look‑ahead boost
    lookahead_boost = np.ones_like(sigmoid_score)
    if lookahead_items is not None:
        look = np.asarray(lookahead_items, dtype=float)
        if look.size > 0:
            # Remaining capacity after the current placement
            remaining = slack  # shape (m,)
            # Count how many look‑ahead items each bin could still accommodate
            fits = (remaining[:, None] >= look[None, :]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(look.size)  # ∈ [0, 1]
            lookahead_boost = 1.0 + lookahead_alpha * fit_ratio

    # Combine base score with bonuses
    scores = sigmoid_score + reuse_bonus + exact_bonus
    scores *= lookahead_boost

    # Tiny random tie‑breaker
    rng = np.random.default_rng(random_state)
    random_noise = rng.uniform(0.0, jitter, size=scores.shape)
    scores += random_noise

    # Assemble final priority vector, initialise with -inf for infeasible bins
    priority = np.full_like(bins, -np.inf, dtype=float)
    priority[feasible] = scores

    # Deterministic tie‑breaker: lower‑index bins receive a minuscule advantage
    priority -= np.arange(n_bins, dtype=float) * jitter

    return priority
```
