```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Softmax‑based fit priority for the online Bin Packing Problem.

    Each feasible bin (i.e., with enough remaining capacity for ``item``) receives a
    probability proportional to ``exp(-remaining_space / T)`` where ``remaining_space``
    is the leftover capacity after placing the item.  Bins that cannot accommodate
    the item get a priority of 0.  The temperature ``T`` controls how greedy the
    decision is: lower ``T`` yields a more deterministic choice (tightest fit), while
    higher ``T`` spreads probability more uniformly.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities of existing bins.

    Returns:
        An array of the same shape as ``bins_remain_cap`` containing the priority
        (probability) for each bin.
    """
    # Ensure a NumPy array of float for safe arithmetic
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialize all priorities to zero (including infeasible bins)
    priorities = np.zeros_like(caps, dtype=float)

    # Identify bins that can accommodate the item
    feasible = caps >= item
    if not np.any(feasible):
        # No feasible bin – return all zeros (caller may open a new bin)
        return priorities

    # Compute the leftover capacity if the item were placed in each feasible bin
    leftover = caps[feasible] - item                      # >= 0

    # Score is higher for tighter fits: smaller leftover -> larger (less negative) score
    # Using negative leftover as raw score for softmax
    raw_scores = -leftover

    # Temperature controls greediness; choose a sensible default
    temperature = 0.5
    # Prevent division by zero or extremely sharp distributions
    temperature = max(temperature, 1e-8)

    # Stable softmax: shift by the maximum raw score before exponent
    max_score = np.max(raw_scores)
    exp_shifted = np.exp((raw_scores - max_score) / temperature)

    # Normalize to obtain a probability distribution over feasible bins
    probs = exp_shifted / exp_shifted.sum()

    # Assign the probabilities back to the full priority vector
    priorities[feasible] = probs
    return priorities
```
