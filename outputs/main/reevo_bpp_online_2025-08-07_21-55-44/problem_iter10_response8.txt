```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    bin_capacity: float = 1.0,
    exact_fit_bonus: float = 1e9,
    slack_weight: float = 1.0,
    new_bin_penalty: float = 0.2,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Compute priority scores for an online Bin Packing decision.

    The priority is based on a linear penalty for waste (remaining capacity
    after placing the item).  An exact fit receives a large bonus.  Opening a
    new bin is penalised by a small factor to discourage unnecessary bins.
    A deterministic tie‑breaker prefers lower‑index bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of already opened bins.
    bin_capacity : float, optional
        Capacity of every bin (default 1.0).
    exact_fit_bonus : float, optional
        Bonus added when the placement exactly fills a bin.
    slack_weight : float, optional
        Weight of the linear waste penalty.
    new_bin_penalty : float, optional
        Multiplicative penalty applied to the waste of a newly opened bin.
    epsilon : float, optional
        Small deterministic tie‑breaker value.

    Returns
    -------
    np.ndarray
        Priority scores of shape ``(len(bins_remain_cap) + 1,)``.
        The last element corresponds to opening a new bin.  Infeasible
        bins receive ``-np.inf``.
    """
    # Convert input to a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # ---- Existing bins ----
    waste = caps - item
    feasible = waste >= -epsilon          # allow tiny negative due to rounding

    # Normalized slack (fraction of bin capacity that will remain)
    slack = np.where(feasible, waste / bin_capacity, np.inf)

    # Base priority: lower waste is better
    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)

    # Bonus for exact fits
    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=epsilon)
    base_priority[exact_fit_mask] += exact_fit_bonus

    # Deterministic tie‑breaker (favor lower indices)
    base_priority += -np.arange(n_bins, dtype=float) * epsilon

    # ---- Virtual new bin ----
    waste_new = bin_capacity - item
    if waste_new >= -epsilon:
        slack_new = waste_new / bin_capacity
        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)
        if np.isclose(waste_new, 0.0, atol=epsilon):
            new_bin_priority += exact_fit_bonus
        # Tie‑breaker for the virtual bin (after all real bins)
        new_bin_priority -= n_bins * epsilon
    else:
        new_bin_priority = -np.inf

    # Append the virtual bin priority
    priorities = np.append(base_priority, new_bin_priority)
    return priorities
```
