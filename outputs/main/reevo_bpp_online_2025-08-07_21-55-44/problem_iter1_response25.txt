```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    alpha: float = 10.0,
    eps: float = 1e-9,
) -> np.ndarray:
    """
    Inverse Distance (Proximity Fit) priority for online bin packing.

    For each bin we compute the remaining space after placing the item
    (gap = remaining_capacity - item).  Bins that cannot accommodate the
    item receive a priority of 0.  Among feasible bins the priority grows
    as the gap shrinks, using a blend of an inverse distance term and an
    exponential term to sharpen the preference for tight fits.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1â€‘D array of remaining capacities of existing bins.
        alpha: Scaling factor for the exponential term (default 10.0).
        eps: Small constant to avoid division by zero (default 1e-9).

    Returns:
        ndarray of same shape as `bins_remain_cap` containing priority scores.
    """
    # Compute the free space left after inserting the item.
    gap = bins_remain_cap - item

    # Determine which bins can actually hold the item.
    feasible = gap >= 0

    # Initialise priority array with zeros (infeasible bins stay zero).
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Inverse distance component: larger when the gap is smaller.
    inv_gap = np.zeros_like(gap, dtype=float)
    inv_gap[feasible] = 1.0 / (gap[feasible] + eps)

    # Exponential sharpening component.
    exp_term = np.exp(-alpha * gap[feasible])

    # Blend both components (geometric mean keeps the scale balanced).
    priorities[feasible] = np.sqrt(inv_gap[feasible] * exp_term)

    return priorities
```
