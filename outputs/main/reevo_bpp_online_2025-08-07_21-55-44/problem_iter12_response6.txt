```python
import numpy as np
from typing import Optional, Sequence, Union


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, Sequence[float]],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,
    base_steepness: float = 8.0,
    lookahead_alpha: float = 0.2,
    exact_fit_bonus: float = 0.15,
    jitter: float = 1e-7,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float, shape (n_bins,)
        Remaining capacities of the currently opened bins.
    bin_capacity : float, optional
        Fixed capacity of each bin.  If ``None`` the capacity is inferred as
        ``max(bins_remain_cap) + item`` (plus a tiny epsilon).  Must be > 0.
    lookahead_items : array‑like of float, optional
        Sizes of a few future items.  Bins that can still accommodate many of
        these items after placing the current item receive a multiplicative
        boost.
    base_steepness : float, default 8.0
        Base steepness for the sigmoid; scaled by ``1 + fullness``.
    lookahead_alpha : float, default 0.2
        Strength of the look‑ahead boost (0 ≤ α ≤ 1).
    exact_fit_bonus : float, default 0.15
        Additive bonus for bins that fit the item exactly.
    jitter : float, default 1e-7
        Amplitude of tiny random noise for tie‑breaking.  A deterministic
        offset proportional to the bin index is also added.
    random_state : int or np.random.Generator, optional
        Seed or generator for reproducible jitter.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 1. Normalise inputs
    # ------------------------------------------------------------------
    bins = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = bins.size
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # ------------------------------------------------------------------
    # 2. Determine (or validate) bin capacity
    # ------------------------------------------------------------------
    if bin_capacity is None:
        # Infer a capacity that is at least as large as the largest observed
        # remaining capacity plus the current item.
        bin_capacity = float(np.max(bins) + item + 1e-9)
    else:
        bin_capacity = float(bin_capacity)
    if bin_capacity <= 0.0:
        raise ValueError("bin_capacity must be a positive number.")

    # ------------------------------------------------------------------
    # 3. Feasibility mask
    # ------------------------------------------------------------------
    feasible = bins >= item
    if not np.any(feasible):
        # No bin can host the item.
        return np.full_like(bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # 4. Slack after placement and derived quantities (only for feasible)
    # ------------------------------------------------------------------
    slack = bins - item                     # slack ≥ 0 for feasible bins
    slack_feas = slack[feasible]

    # Normalised slack (0 = exact fit, 1 = empty bin after placement)
    norm_slack = np.clip(slack_feas / bin_capacity, 0.0, 1.0)

    # Fullness before placement (0 = empty, 1 = full)
    fullness = np.clip((bin_capacity - bins[feasible]) / bin_capacity, 0.0, 1.0)

    # ------------------------------------------------------------------
    # 5. Adaptive sigmoid steepness
    # ------------------------------------------------------------------
    k = base_steepness * (1.0 + fullness)   # steeper for already‑full bins

    # ------------------------------------------------------------------
    # 6. Sigmoid score (higher for tighter fit)
    # ------------------------------------------------------------------
    # Exponent is largest when norm_slack is smallest (tight fit).
    exponent = k * (1.0 - norm_slack)        # in [0, k]
    exponent = np.clip(exponent, -700.0, 700.0)  # guard against overflow
    scores = 1.0 / (1.0 + np.exp(-exponent))  # ∈ (0.5, 1]

    # ------------------------------------------------------------------
    # 7. Exact‑fit bonus
    # ------------------------------------------------------------------
    exact_fit_mask = np.isclose(slack_feas, 0.0, atol=1e-12)
    scores[exact_fit_mask] += exact_fit_bonus

    # ------------------------------------------------------------------
    # 8. Look‑ahead boost (optional)
    # ------------------------------------------------------------------
    if lookahead_items is not None:
        lookahead = np.asarray(lookahead_items, dtype=float).ravel()
        if lookahead.size > 0:
            # Remaining capacity after placing the current item.
            remaining_after = slack_feas
            # Count how many look‑ahead items could still fit into each bin.
            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)
            fit_ratio = fits.astype(float) / lookahead.size  # ∈ [0, 1]
            boost = 1.0 + np.clip(lookahead_alpha, 0.0, 1.0) * fit_ratio
            scores *= boost

    # ------------------------------------------------------------------
    # 9. Tiny jitter for stochastic tie‑breaking
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    jitter_noise = np.zeros_like(bins)
    jitter_noise[feasible] = rng.uniform(0.0, jitter, size=np.count_nonzero(feasible))

    # Deterministic offset: lower index gets a slight advantage.
    deterministic_offset = -np.arange(n_bins, dtype=float) * (jitter * 0.1)

    # ------------------------------------------------------------------
    # 10. Assemble final priority vector
    # ------------------------------------------------------------------
    priority = np.full(bins.shape, -np.inf, dtype=float)
    priority[feasible] = (
        scores
        + jitter_noise[feasible]
        + deterministic_offset[feasible]
    )

    return priority
```
