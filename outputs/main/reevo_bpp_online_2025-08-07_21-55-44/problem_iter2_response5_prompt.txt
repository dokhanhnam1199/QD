{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"First\u2011Fit priority for the online Bin Packing Problem.\n\n    The returned scores satisfy the First\u2011Fit rule:\n      * Bins that cannot hold ``item`` receive ``-np.inf`` so they will never be\n        chosen.\n      * Among the feasible bins, the one with the smallest index obtains the\n        highest score (i.e., the \u201cfirst\u201d bin).  If several bins share the same\n        index (theoretically impossible) a secondary tie\u2011breaker prefers the\n        tighter fit (smaller leftover capacity).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the current bins (1\u2011D array).\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.\n    \"\"\"\n    # Convert to float for arithmetic safety\n    caps = bins_remain_cap.astype(float)\n\n    # Feasibility mask: bin can accommodate the item\n    feasible = caps >= item\n\n    # Primary component: enforce the \"first\" bin rule.\n    # Bin 0 -> 0, Bin 1 -> -1, Bin 2 -> -2, ...  Higher value means higher priority.\n    idx = np.arange(caps.size, dtype=float)\n    primary = -idx\n\n    # Secondary component (tie\u2011breaker): prefer a tighter fit.\n    # The leftover after placing the item is (caps - item).\n    # Smaller leftover \u2192 larger secondary priority.\n    # Scale it by a tiny epsilon so it never overpowers the primary ordering.\n    epsilon = 1e-4\n    secondary = - (caps - item) * epsilon\n\n    # Combine components\n    scores = primary + secondary\n\n    # Infeasible bins should never be selected\n    scores = np.where(feasible, scores, -np.inf)\n\n    return scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Priority based on a Sigmoid Fit Score for the online Bin Packing Problem.\n\n    A high score is given when the incoming item almost exactly fills the\n    remaining capacity of a bin (i.e., the residual space is minimal).  \n    The score is computed using a logistic (sigmoid) function applied to\n    the ratio of the item size to the remaining capacity.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin. Bins that cannot accommodate the\n        item receive -np.inf so they are never selected.\n    \"\"\"\n    # Can this item fit in a particular bin?\n    can_fit = bins_remain_cap >= item\n\n    # Avoid division by zero\n    eps = 1e-12\n    ratio = np.empty_like(bins_remain_cap, dtype=float)\n    ratio[can_fit] = item / (bins_remain_cap[can_fit] + eps)\n    ratio[~can_fit] = 0.0  # placeholder; will be overwritten\n\n    # Logistic parameters\n    k = 12.0          # steepness of the sigmoid\n    center = 0.5      # center (ratio) giving a medium score\n\n    # Compute the sigmoid fit score: higher when ratio ~ 1 (i.e., good fit)\n    priorities = 1.0 / (1.0 + np.exp(-k * (ratio - center)))\n\n    # Exclude bins that cannot accommodate the item\n    priorities[~can_fit] = -np.inf\n\n    return priorities\n\n[Reflection]\nBlend logistic fit and index; adapt k, center with bin count; penalize tight residuals; tie\u2011break by variance.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}