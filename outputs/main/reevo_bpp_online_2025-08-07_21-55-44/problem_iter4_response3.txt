```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin in an online bin‑packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher scores indicate more desirable bins. Infeasible bins receive
        ``-np.inf``.
    """
    # Ensure a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.shape[0]

    # Default score for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if n_bins == 0:
        return priorities

    # Remaining capacity after placing the item
    leftover = caps - item

    # Feasible bins: enough space to accommodate the item
    feasible = leftover >= 0

    if not np.any(feasible):
        # No bin can accommodate the item
        return priorities

    # Linear penalty: larger leftover => lower priority,
    # weighted by the item size.
    priorities[feasible] = -leftover[feasible] * item

    # Reward exact fits with a huge bonus
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)
    if np.any(exact_fit):
        EXACT_FIT_BONUS = 1e12
        priorities[exact_fit] = EXACT_FIT_BONUS

    # Deterministic tie‑breaker: slightly penalise larger indices
    TIE_EPS = 1e-6
    priorities -= TIE_EPS * np.arange(n_bins)

    return priorities
```
