[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: float = 1.0,\n    exact_fit_bonus: float = 1e9,\n    slack_weight: float = 1.0,\n    new_bin_penalty: float = 0.2,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for an online Bin Packing decision.\n\n    For each currently opened bin the function returns a score that rewards\n    small waste (linear slack penalty) and gives a huge bonus for exact fits.\n    A virtual new bin is appended as the last entry; opening a new bin incurs\n    an extra waste penalty controlled by ``new_bin_penalty``.  A tiny\n    deterministic tie\u2011breaker (``epsilon``) prefers lower\u2011index bins.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of already opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of every bin (default 1.0).\n    exact_fit_bonus : float, optional\n        Large bonus added when a placement would fill a bin exactly.\n    slack_weight : float, optional\n        Linear weight for the normalized slack (waste). Larger values increase\n        the penalty for waste.\n    new_bin_penalty : float, optional\n        Multiplicative factor applied to the waste of a newly opened bin\n        (e.g., 0.2 adds a 20\u202f% penalty).\n    epsilon : float, optional\n        Tiny value used for deterministic tie\u2011breaking.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores with shape ``(len(bins_remain_cap) + 1,)``.  The last\n        element corresponds to the virtual new bin.  Infeasible bins receive\n        ``-np.inf`` and will never be selected.\n    \"\"\"\n    # Ensure a 1\u2011D NumPy array of floats\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # ---------- Existing bins ----------\n    # Waste (remaining capacity after placing the item)\n    waste = caps - item\n    feasible = waste >= -epsilon  # tolerate tiny numerical negatives\n\n    # Normalized slack (waste as fraction of bin capacity)\n    slack = np.where(feasible, waste / bin_capacity, np.inf)\n\n    # Base priority: linear penalty on slack (smaller slack \u2192 higher priority)\n    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=epsilon)\n    base_priority = np.where(\n        exact_fit_mask,\n        base_priority + exact_fit_bonus,\n        base_priority,\n    )\n\n    # Deterministic tie\u2011breaker (favor lower indices)\n    tie_breaker = -np.arange(n_bins, dtype=float) * epsilon\n    base_priority += tie_breaker\n\n    # ---------- Virtual new bin ----------\n    waste_new = bin_capacity - item\n    if waste_new < -epsilon:\n        # Item does not fit into an empty bin \u2192 infeasible\n        new_bin_priority = -np.inf\n    else:\n        slack_new = waste_new / bin_capacity\n        # Apply penalty for opening a new bin\n        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)\n\n        # Exact\u2011fit bonus for a perfect new bin\n        if np.isclose(waste_new, 0.0, atol=epsilon):\n            new_bin_priority += exact_fit_bonus\n\n        # Tie\u2011breaker for the virtual bin (place it after all real bins)\n        new_bin_priority += -n_bins * epsilon\n\n    # Append the virtual bin priority\n    priorities = np.append(base_priority, new_bin_priority)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 35.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\nfrom typing import Optional, Union, Sequence\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    exact_fit_tol: float = 1e-12,\n    exact_fit_bonus: float = 1e-3,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If ``None``, the maximum observed remaining\n        capacity plus a tiny epsilon is used as a surrogate.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can still accommodate more of these\n        items after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the sigmoid.  It is scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).  The boost is\n        multiplicative: ``score *= (1 + alpha * fit_ratio)``.\n    exact_fit_tol : float, default 1e-12\n        Tolerance for detecting an exact fit (gap \u2248 0).\n    exact_fit_bonus : float, default 1e-3\n        Small additive bonus for exact\u2011fit bins (default is modest to avoid\n        huge constant bonuses).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for a tiny random tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Prepare inputs\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer the true bin capacity if not supplied.\n    if bin_capacity is None:\n        # Use the largest observed remaining capacity as a proxy.\n        # Adding a tiny epsilon avoids division by zero in degenerate cases.\n        bin_capacity = float(np.max(bins) + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    # ------------------------------------------------------------------\n    # 2. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item - exact_fit_tol  # allow tiny tolerance\n    if not np.any(feasible:\n        # No bin can host the item \u2013 return -inf for all entries.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 3. Gaps and normalized gaps\n    # ------------------------------------------------------------------\n    gaps = bins - item                     # >= 0 for feasible bins\n    norm_gaps = np.clip(gaps / bin_capacity, 0.0, 1.0)  # scale to [0, 1]\n\n    # ------------------------------------------------------------------\n    # 4. Dynamic sigmoid steepness based on bin fullness\n    # ------------------------------------------------------------------\n    # Fullness = used capacity / total capacity (0 = empty, 1 = full)\n    fullness = (bin_capacity - bins) / bin_capacity\n    k = k_base * (1.0 + fullness)         # steeper for fuller bins\n\n    # ------------------------------------------------------------------\n    # 5. Sigmoid score on normalized gaps (higher score = tighter fit)\n    # ------------------------------------------------------------------\n    # For the sigmoid we need a reference point; we use the maximum gap\n    # among feasible bins.  Adding a tiny epsilon ensures a positive shift.\n    eps = 1e-12\n    max_gap = np.max(norm_gaps[feasible])\n    shift = max_gap - norm_gaps[feasible] + eps   # larger => tighter fit\n\n    exponent = k[feasible] * shift\n    # Clip exponent to avoid overflow/underflow in exp().\n    exponent = np.clip(exponent, -700.0, 700.0)\n\n    # Sigmoid mapping: values in (0.5, 1) with exact fits approaching 1.\n    scores = 1.0 / (1.0 + np.exp(-exponent))\n\n    # ------------------------------------------------------------------\n    # 6. Small bonus for exact fits (gap \u2248 0)\n    # ------------------------------------------------------------------\n    exact_fit_mask = feasible & (np.abs(gaps) <= exact_fit_tol)\n    scores[exact_fit_mask] += exact_fit_bonus\n\n    # ------------------------------------------------------------------\n    # 7. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    scores += rng.uniform(0.0, 1e-6, size=scores.shape)\n\n    # ------------------------------------------------------------------\n    # 8. Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float).ravel()\n    if lookahead.size > 0:\n            # Remaining capacity after placing the current item.\n            remaining_after = gaps[feasible]\n            # Count how many look\u2011ahead items each bin could still fit.\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)   # [0, 1]\n            # Apply multiplicative boost.\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores *= boost\n\n    # ------------------------------------------------------------------\n    # 9. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 71\n    if not np.any(feasible:\n                          ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 71\n    if not np.any(feasible:\n                          ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 71\n    if not np.any(feasible:\n                          ^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\nfrom typing import Union, Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    exact_fit_bonus: float = 1e5,\n    jitter_eps: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array-like of float\n        Remaining capacities of the current bins.\n    bin_capacity : float, optional\n        The fixed capacity of each bin. If omitted, it is inferred from the\n        current bins, ensuring that the inferred capacity can accommodate\n        the incoming item.\n    lookahead_items : array-like of float, optional\n        Sizes of items that are expected to arrive soon. Bins that can still\n        accommodate more of these items after the current placement receive\n        a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness parameter for the sigmoid; scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (fractional multiplier).\n    exact_fit_bonus : float, default 1e5\n        Large additive bonus for bins that will have zero slack after\n        placement (i.e., an exact fit).\n    jitter_eps : float, default 1e-12\n        Magnitude of the tiny random tie\u2011breaker added to each score.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the tiny random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same length as ``bins_remain_cap``.\n        Feasible bins receive a finite score; infeasible bins receive\n        ``-np.inf`` and will never be selected.\n    \"\"\"\n    # Convert input to a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not provided\n    if bin_capacity is None:\n        max_cap = np.max(caps)\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # Feasibility mask\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # Remaining capacity after placing the item (only for feasible bins)\n    leftover = caps[feasible] - item  # >= 0\n    gap_norm = leftover / bin_capacity  # normalised gap in [0, 1)\n\n    # Fullness before placement (fraction already used)\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n    k = k_base * (1.0 + fullness)  # dynamic steepness\n\n    # Logistic sigmoid: decreasing in gap_norm\n    arg = k * (gap_norm - 0.5)\n    # Clip to avoid overflow\n    arg = np.clip(arg, -700.0, 700.0)\n    scores = 1.0 / (1.0 + np.exp(arg))  # in (0,1)\n\n    # Tiny random tie\u2011breaker\n    rng = np.random.default_rng(random_state)\n    eps = jitter_eps * max(1.0, np.max(scores)) if scores.size else 0.0\n    scores += rng.uniform(0.0, eps, size=scores.shape)\n\n    # Look\u2011ahead boost\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            fits = (look <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits / float(look.size)  # in [0, 1]\n            scores = scores * (1.0 + alpha * fit_ratio)\n            scores = np.clip(scores, 0.0, 1.0)\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = np.isclose(leftover, 0.0, atol=1e-12)\n    if np.any(exact_fit_mask):\n        scores[exact_fit_mask] += exact_fit_bonus\n\n    # Assemble full priority vector\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 47.0,
    "cyclomatic_complexity": 10.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n    jitter: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin. If ``None`` the maximum remaining capacity\n        observed in ``bins_remain_cap`` is used.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can still accommodate more of these\n        items after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the adaptive sigmoid.  The steepness is scaled by\n        bin fullness so fuller bins get a steeper curve.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for a tiny random tie\u2011breaking noise.\n    jitter : float, default 1e-6\n        Deterministic tie\u2011breaker magnitude (lower\u2011index bins get a tiny\n        advantage).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf`` and are never\n        selected.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Prepare inputs\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not provided\n    if bin_capacity is None:\n        bin_capacity = float(np.max(bins) + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    # ------------------------------------------------------------------\n    # 2. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 3. Compute gaps and normalized gaps\n    # ------------------------------------------------------------------\n    slack = bins - item  # remaining capacity after placing the item\n    norm_gaps = slack / bin_capacity  # [0,1] (or slightly >1 for overflow)\n    norm_gaps = np.clip(norm_gaps, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # 4. Dynamic sigmoid steepness based on bin fullness\n    # ------------------------------------------------------------------\n    fullness = (bin_capacity - bins) / bin_capacity  # [0,1]\n    fullness = np.clip(fullness, 0.0, 1.0)\n    k = k_base * (1.0 + fullness)  # steeper for fuller bins\n\n    # ------------------------------------------------------------------\n    # 5. Adaptive sigmoid on normalized gaps\n    # ------------------------------------------------------------------\n    # Shift gaps so that the smallest gap gets the highest score\n    feasible_gaps = norm_gaps[feasible]\n    feasible_k = k[feasible]\n    max_norm_gap = np.max(feasible_gaps)\n    shift = max_norm_gap - feasible_gaps  # larger for tighter fits\n    exponent = feasible_k * shift\n    exponent = np.clip(exponent, -700.0, 700.0)  # avoid overflow\n    scores = 1.0 / (1.0 + np.exp(-exponent))  # in (0.5, 1]\n\n    # ------------------------------------------------------------------\n    # 6. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    noise = rng.uniform(0.0, 1e-6, size=scores.shape)\n    scores += noise\n\n    # ------------------------------------------------------------------\n    # 7. Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n        if lookahead.size > 0:\n            remaining_after = slack[feasible]  # capacity left after placement\n            # Count how many lookahead items each bin can still fit\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0,1]\n            # Apply multiplicative boost\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores *= boost\n\n    # ------------------------------------------------------------------\n    # 8. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    # ------------------------------------------------------------------\n    # 9. Deterministic tie\u2011breaker\n    # ------------------------------------------------------------------\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 3,
    "obj": 4.108496210610296,
    "SLOC": 50.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function assigns a score to each currently open bin based on:\n      * Feasibility (bins that cannot accommodate the item receive -inf).\n      * Adaptive slack weighting: a coefficient \u03b1 is derived from the\n        distribution (mean/std) of leftover capacities among feasible bins.\n      * Non\u2011linear penalty on leftover capacity (quadratic term) to\n        prioritize tighter fits.\n      * Small bonus for bins that would still be able to accommodate another\n        item of the same size after this placement.\n      * Massive bonus for exact fits (leftover \u2248 0) that dominates all other\n        terms.\n      * Deterministic index\u2011based tie\u2011breaker (tiny epsilon) to ensure a\n        reproducible choice when scores are otherwise equal.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better).  Infeasible bins have\n        ``-np.inf`` and will never be selected.\n    \"\"\"\n    # Ensure a 1\u2011D float array; do not modify caller's array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Initialise all scores as infeasible.\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        return scores\n\n    # Feasibility mask: bin can accommodate the item.\n    feasible = caps >= item\n    if not np.any(feasible):\n        return scores\n\n    # Remaining capacity after placing the item (non\u2011negative for feasible bins).\n    leftover = caps - item\n\n    # Adaptive slack weighting: compute coefficient \u03b1 from the spread of leftovers.\n    leftover_feas = leftover[feasible]\n    mean_left = leftover_feas.mean()\n    std_left = leftover_feas.std()\n    cv = std_left / mean_left if mean_left > 0 else 0.0   # coefficient of variation\n    base_alpha = 1e-4                                     # baseline quadratic strength\n    alpha = base_alpha * (1.0 + cv)                       # larger cv \u2192 stronger penalty\n\n    # Non\u2011linear leftover penalty (quadratic).\n    # The more leftover, the lower (more negative) the score.\n    base_score = -leftover_feas - alpha * (leftover_feas ** 2)\n\n    # Small bonus for bins that would still fit another item of the same size.\n    future_factor = 1e-2\n    future_mask = feasible & (leftover >= item)\n\n    # Tiny deterministic tie\u2011breaker (lower index gets a minuscule advantage).\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n\n    # Assign base scores (including tie\u2011breaker) to feasible bins.\n    scores[feasible] = base_score + tie_breaker[feasible]\n\n    # Apply the future\u2011capacity bonus.\n    scores[future_mask] += future_factor\n\n    # Massive exact\u2011fit bonus: dominates any other term.\n    exact_tolerance = 1e-12\n    exact_fit_mask = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if np.any(exact_fit_mask):\n        EXACT_BONUS = 1e12\n        scores[exact_fit_mask] = EXACT_BONUS + tie_breaker[exact_fit_mask]\n\n    return scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, *,\n                exact_fit_bonus: float = 1e6,\n                slack_exponent_k: float = 10.0,\n                next_item_bonus: float = 0.05,\n                jitter: float = 1e-12,\n                exact_fit_atol: float = 1e-12,\n                eps: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1-D array of remaining capacities of the currently opened bins.\n    exact_fit_bonus : float, optional\n        Large constant added for (near) exact fits.\n    slack_exponent_k : float, optional\n        Controls steepness of the exponential slack bonus.\n    next_item_bonus : float, optional\n        Bonus if the bin would still hold another item of the same size.\n    jitter : float, optional\n        Tiny magnitude for deterministic tie\u2011breaking.\n    exact_fit_atol : float, optional\n        Absolute tolerance for treating a placement as an exact fit.\n    eps : float, optional\n        Small constant to avoid division\u2011by\u2011zero when normalising slack.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Higher scores are\n        more desirable.\n    \"\"\"\n    # Ensure a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Edge case: no bins at all\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Feasibility mask: slack must be non\u2011negative\n    feasible = slack >= 0.0\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If nothing fits, return early\n    if not feasible.any():\n        return priorities\n\n    # Compute base priority: tighter fit \u2192 larger (less negative) value\n    base_priority = -slack[feasible]\n\n    # Normalise slack for exponential term (avoid division by zero)\n    max_slack = slack[feasible].max()\n    denom = max_slack + eps\n    slack_norm = slack[feasible] / denom\n\n    # Exponential slack bonus: larger for smaller slack_norm\n    exp_bonus = np.exp(-slack_exponent_k * slack_norm)\n\n    # Anticipation bonus: can still fit another item of the same size\n    anticipate_bonus = np.where(slack[feasible] >= item, next_item_bonus, 0.0)\n\n    # Combine components\n    priority_feasible = base_priority + exp_bonus + anticipate_bonus\n\n    # Exact\u2011fit boost (within tolerance)\n    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)\n    priority_feasible[exact_fit_mask] += exact_fit_bonus\n\n    # Insert feasible priorities back into full array\n    priorities[feasible] = priority_feasible\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins ever so slightly\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priorities += tie_breaker\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: float = 1.0,\n    exact_fit_bonus: float = 1e6,\n    slack_weight: float = 1.0,\n    new_bin_penalty: float = 0.2,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for an online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of already opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of every bin (default 1.0).\n    exact_fit_bonus : float, optional\n        Bonus added to a bin that would be exactly filled (default 1e6).\n    slack_weight : float, optional\n        Linear weight for normalized slack (default 1.0).\n    new_bin_penalty : float, optional\n        Multiplicative penalty applied to the waste of a newly opened bin\n        (default 0.2 \u2192 20\u202f% extra waste).\n    epsilon : float, optional\n        Tiny value for deterministic tie\u2011breaking (default 1e\u201112).\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with shape ``(len(bins_remain_cap) + 1,)``.\n        The last entry corresponds to the virtual new bin.\n    \"\"\"\n    # Basic validation\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive\")\n    if item < 0:\n        raise ValueError(\"item size must be non\u2011negative\")\n\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    if bins_remain_cap.ndim != 1:\n        raise ValueError(\"bins_remain_cap must be a 1\u2011D array\")\n\n    n_bins = bins_remain_cap.size\n\n    # Waste after placing the item in each existing bin\n    waste = bins_remain_cap - item\n    feasible = waste >= 0\n\n    # Normalized slack (waste / bin_capacity) for feasible bins\n    slack = np.where(feasible, waste / bin_capacity, np.inf)\n\n    # Base priority: negative weighted slack (smaller slack \u2192 higher priority)\n    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = np.isclose(waste, 0.0, atol=epsilon)\n    base_priority = np.where(exact_fit_mask, base_priority + exact_fit_bonus, base_priority)\n\n    # Deterministic tie\u2011breaker: tiny advantage for lower indices\n    base_priority += -np.arange(n_bins, dtype=float) * epsilon\n\n    # -------- Virtual new bin ----------\n    waste_new = bin_capacity - item\n    if waste_new < 0:\n        new_bin_priority = -np.inf\n    else:\n        slack_new = waste_new / bin_capacity\n        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)\n        if np.isclose(waste_new, 0.0, atol=epsilon):\n            new_bin_priority += exact_fit_bonus\n        # Tie\u2011breaker for the virtual bin (neutral index after all real bins)\n        new_bin_priority += -n_bins * epsilon\n\n    # Append virtual new bin priority as the last element\n    priorities = np.append(base_priority, new_bin_priority)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 36.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\nfrom typing import Optional, Union, Sequence\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    jitter: float = 1e-7,\n    exact_fit_bonus: float = 0.15,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If ``None`` a small estimate is derived\n        from the data (max remaining capacity + the incoming item).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can also accommodate more of these\n        items after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the sigmoid.  Scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).\n    jitter : float, default 1e-7\n        Amplitude of the random tie\u2011breaker noise.\n    exact_fit_bonus : float, default 0.15\n        Small additive bonus for bins that fit the item exactly.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Prepare input\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 2. Infer bin capacity if not provided\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # Use the largest observed remaining capacity plus the current item.\n        # Adding a tiny epsilon guards against division\u2011by\u2011zero.\n        bin_capacity = float(np.max(bins) + item + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    if bin_capacity <= 0.0:\n        raise ValueError(\"Bin capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # 3. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 4. Slack (remaining capacity after placing the item)\n    # ------------------------------------------------------------------\n    slack = bins - item                       # may be negative for infeasible bins\n\n    # ------------------------------------------------------------------\n    # 5. Normalised slack (gap) and bin fullness (used fraction)\n    # ------------------------------------------------------------------\n    # Normalise slack to [0, 1] using the (estimated) bin capacity.\n    norm_gap = np.clip(slack / bin_capacity, 0.0, 1.0)\n\n    # Fullness = used capacity / total capacity\n    fullness = np.clip((bin_capacity - bins) / bin_capacity, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # 6. Dynamic sigmoid steepness based on bin fullness\n    # ------------------------------------------------------------------\n    # Bins that are already more full get a steeper curve, rewarding\n    # tight fits even more strongly.\n    k = k_base * (1.0 + fullness)               # shape (n_bins,)\n\n    # ------------------------------------------------------------------\n    # 7. Sigmoid score favouring tighter fits\n    # ------------------------------------------------------------------\n    # We want a monotone decreasing function of the normalised gap.\n    # Using shift = 1 - norm_gap makes a perfect fit (gap=0) give the\n    # largest exponent, hence the highest sigmoid value.\n    shift = 1.0 - norm_gap                       # larger -> tighter fit\n    exponent = k * shift                        # shape (n_bins,)\n\n    # feasible bins only\n    # Clip exponent to avoid overflow in exp()\n    exponent = np.clip(exponent, -700.0, 700.0)\n\n    # Logistic sigmoid in (0, 1)\n    scores = 1.0 / (1.0 + np.exp(-exponent))\n\n    # ------------------------------------------------------------------\n    # 8. Exact\u2011fit bonus (small additive bump)\n    # ------------------------------------------------------------------\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    scores[exact_fit_mask] += exact_fit_bonus\n\n    # ------------------------------------------------------------------\n    # 9. Look\u2011ahead boost (optional)\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float).ravel()\n        if lookahead.size > 0:\n            # Capacity left after the current placement for each feasible bin.\n            remaining_after = slack[feasible]                      # >= 0\n            # Count how many look\u2011ahead items each bin could still accommodate.\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)                                   # in [0, 1]\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores[feasible] *= boost\n\n    # ------------------------------------------------------------------\n    # 10. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    scores[feasible] += rng.uniform(0.0, jitter, size=np.count_nonzero(feasible))\n\n    # ------------------------------------------------------------------\n    # 11. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores[feasible]\n\n    return priority",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 48.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k: float = 10.0,\n    offset: float = 0.5,\n    alpha: float = 0.1,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    The function prefers bins that leave little slack after placing ``item``,\n    while also rewarding bins that can still accommodate future items\n    (``lookahead_items``). Scores are produced by a per\u2011bin sigmoid on the\n    normalised slack, avoiding large fixed bonuses. A tiny random tie\u2011breaker\n    ensures deterministic but unpredictable ordering for equal scores.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacities of the currently open bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin. If omitted, inferred from the maximum\n        observed remaining capacity (ensuring it is at least ``item``).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of items that may arrive soon. Bins that can still fit more of\n        these items after placing ``item`` receive a multiplicative boost.\n    k : float, default 10.0\n        Base steepness of the sigmoid. Larger values give sharper\n        discrimination between small and large slack.\n    offset : float, default 0.5\n        Offset for the sigmoid (in normalised slack units). A value of 0.5\n        yields a moderate score when half the bin is left.\n    alpha : float, default 0.1\n        Strength of the look\u2011ahead boost (as a fraction of the base score).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the tiny random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape matches ``bins_remain_cap``);\n        infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise inputs\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Infer bin capacity if not supplied\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # Use the maximum observed remaining capacity as a proxy.\n        # Ensure the capacity can accommodate the current item.\n        max_cap = np.max(caps) if n_bins > 0 else 0.0\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No bin can hold the item\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Slack and normalised slack after placement (feasible bins only)\n    # ------------------------------------------------------------------\n    leftover = caps[feasible] - item                     # >= 0\n    slack_norm = leftover / bin_capacity                 # in [0, 1]\n\n    # ------------------------------------------------------------------\n    # Per\u2011bin sigmoid steepness based on current fullness\n    # ------------------------------------------------------------------\n    # Fullness before placement (fraction already used)\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n    k_i = k * (1.0 + fullness)  # sharper for bins that are already fuller\n\n    # Sigmoid argument: positive when slack_norm < offset (i.e., small slack)\n    arg = k_i * (offset - slack_norm)\n    # Clip to avoid overflow in exp\n    arg = np.clip(arg, -700.0, 700.0)\n\n    # Logistic sigmoid maps arg -> score in (0, 1)\n    scores = 1.0 / (1.0 + np.exp(-arg))\n\n    # ------------------------------------------------------------------\n    # Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    eps = 1e-12 * max(1.0, np.max(np.abs(scores)))\n    scores += rng.uniform(0.0, eps, size=scores.shape)\n\n    # ------------------------------------------------------------------\n    # Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            # For each bin, count how many look\u2011ahead items could still fit\n            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits / float(look.size)          # in [0, 1]\n            # Multiplicative boost, clipped to keep scores \u2264 1\n            scores = np.minimum(scores * (1.0 + alpha * fit_ratio), 1.0)\n\n    # ------------------------------------------------------------------\n    # Assemble full priority vector\n    # ------------------------------------------------------------------\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 42.0,
    "cyclomatic_complexity": 9.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, *,\n                exact_fit_bonus: float = 1e9,\n                slack_decay: float = 10.0,\n                jitter: float = 1e-12,\n                atol: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing Problem.\n\n    Higher scores indicate a more desirable bin for the incoming ``item``.\n    The scoring scheme follows the reflection:\n\n    * Monotonic slack base: bins with less leftover capacity after placement\n      receive a higher base score (-slack).\n    * Exponential slack penalty: larger leftovers are penalised by an\n      exponential term, preserving monotonicity.\n    * Large bonus for exact fits.\n    * Tiny deterministic tie\u2011breaker based on bin index (``jitter``).\n\n    Infeasible bins (capacity < item) receive ``-inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    exact_fit_bonus : float, optional\n        Bonus added for bins where the item fits exactly.\n    slack_decay : float, optional\n        Controls steepness of the exponential slack penalty.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n    atol : float, optional\n        Absolute tolerance for detecting an exact fit.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Convert to 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Edge case: no bins\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Remaining capacity after placing the item\n    slack = caps - item\n\n    # Feasibility mask (allow tiny negative due to floating point)\n    feasible = slack >= -atol\n\n    # Initialise priorities with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 return early\n        return priority\n\n    # Indices of feasible bins\n    feasible_idx = np.nonzero(feasible)[0]\n    slack_feasible = slack[feasible_idx]\n\n    # Monotonic base score: negative slack (smaller slack \u21d2 higher score)\n    base_score = -slack_feasible\n\n    # Normalised slack for exponential penalty (avoid division by zero)\n    max_slack = np.max(slack_feasible)\n    norm_slack = slack_feasible / (max_slack + atol)\n\n    # Exponential slack penalty (larger slack \u21d2 larger penalty)\n    slack_penalty = np.exp(slack_decay * norm_slack)\n\n    # Combine base and penalty (higher is better)\n    priority[feasible_idx] = base_score - slack_penalty\n\n    # Exact\u2011fit bonus (detect near\u2011zero slack)\n    exact_fit_mask = np.isclose(slack_feasible, 0.0, atol=atol)\n    if np.any(exact_fit_mask):\n        priority[feasible_idx[exact_fit_mask]] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: prefer lower\u2011index bins slightly\n    priority -= np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    bin_capacity: float = 1.0,\n    avg_future_item: float = None,\n) -> np.ndarray:\n    \"\"\"\n    Advanced priority function for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the currently opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin (default = 1.0).\n    avg_future_item : float, optional\n        Expected size of a typical future item; used for a one\u2011step look\u2011ahead boost.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher values indicate more desirable bins.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    waste = bins_remain_cap - item\n    feasible = waste >= 0\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # ---------- Parameter settings ----------\n    alpha = 5.0          # exponential slack penalty steepness\n    beta = 4.0           # scaling with current bin fullness\n    exact_fit_reward = 1e6\n    lookahead_boost = 0.2\n    epsilon = 1e-12\n    tol = 1e-9\n    # ----------------------------------------\n\n    # Fullness before placement (0 = empty, 1 = full)\n    fullness_before = (bin_capacity - bins_remain_cap) / bin_capacity\n    # Penalty steepness factor grows with bin fullness\n    factor = 1.0 + beta * fullness_before\n\n    # Normalized slack (waste) after placing the item\n    normalized_slack = waste / bin_capacity\n\n    # Exponential penalty: larger slack \u2192 more negative priority\n    penalty = -np.exp(alpha * normalized_slack * factor)\n\n    # Apply penalty to feasible bins\n    priorities[feasible] = penalty[feasible]\n\n    # Massive reward for an exact fit (waste \u2248 0)\n    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=tol)\n    priorities[exact_fit_mask] = exact_fit_reward\n\n    # One\u2011step look\u2011ahead boost if we have an estimate of future item size\n    if avg_future_item is not None:\n        boost_mask = feasible & (waste >= avg_future_item)\n        if np.any(boost_mask):\n            # Boost proportional to the surplus capacity beyond the expected future item\n            boost = lookahead_boost * ((waste[boost_mask] - avg_future_item) / bin_capacity)\n            priorities[boost_mask] += boost\n\n    # Tiny tie\u2011breaker: deterministic component (index) plus minuscule random noise\n    N = bins_remain_cap.size\n    det_eps = -np.arange(N) * epsilon\n    rand_eps = (np.random.rand(N) - 0.5) * epsilon * 0.1  # \u00b10.05\u00b7\u03b5\n    tie_breaker = det_eps + rand_eps\n    priorities += tie_breaker\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 36.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  }
]