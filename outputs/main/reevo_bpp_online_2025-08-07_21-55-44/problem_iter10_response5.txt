```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    bin_capacity: float = 1.0,
    exact_fit_bonus: float = 1e9,
    slack_weight: float = 1.0,
    new_bin_penalty: float = 0.2,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Priority scores for an online Bin Packing decision.

    Each existing bin receives a score that:
      * rewards exact fits with a large bonus,
      * penalises remaining slack linearly (smaller slack → higher score),
      * breaks ties deterministically in favour of lower‑index bins.

    A virtual "new bin" is appended as the last entry; opening a new bin
    incurs an additional penalty (controlled by ``new_bin_penalty``).  Infeasible
    bins receive ``-np.inf`` and are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of already opened bins.
    bin_capacity : float, optional
        Fixed capacity of every bin (default 1.0).  Must be positive.
    exact_fit_bonus : float, optional
        Large bonus added when a placement would fill a bin exactly.
    slack_weight : float, optional
        Linear weight for the normalized slack (waste).  Larger values increase
        the penalty for waste.
    new_bin_penalty : float, optional
        Multiplicative factor applied to the waste of a newly opened bin.
    epsilon : float, optional
        Tiny deterministic tie‑breaker magnitude.

    Returns
    -------
    np.ndarray
        Priority scores with shape ``(len(bins_remain_cap) + 1,)``.  The last
        element corresponds to the virtual new bin.
    """
    if bin_capacity <= 0:
        raise ValueError("bin_capacity must be positive.")

    # Ensure a 1‑D NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # ---------- Existing bins ----------
    waste = caps - item                     # capacity left after placing the item
    feasible = waste >= -epsilon            # allow tiny negative due to FP

    # Normalized slack (waste as fraction of bin capacity)
    slack = np.where(feasible, waste / bin_capacity, np.inf)

    # Base priority: linear penalty on slack (more slack → lower score)
    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)

    # Exact‑fit bonus
    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=epsilon)
    base_priority = np.where(
        exact_fit_mask,
        base_priority + exact_fit_bonus,
        base_priority,
    )

    # Deterministic tie‑breaker (favor lower indices)
    tie_breaker = -np.arange(n_bins, dtype=float) * epsilon
    base_priority += tie_breaker

    # ---------- Virtual new bin ----------
    waste_new = bin_capacity - item
    feasible_new = waste_new >= -epsilon

    if feasible_new:
        slack_new = waste_new / bin_capacity
        # Apply extra penalty for opening a new bin
        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)

        # Exact‑fit bonus for a perfect new bin
        if np.isclose(waste_new, 0.0, atol=epsilon):
            new_bin_priority += exact_fit_bonus
    else:
        new_bin_priority = -np.inf

    # Tie‑breaker for the virtual bin (placed after all real bins)
    new_bin_priority += -n_bins * epsilon

    # ---------- Assemble final priority vector ----------
    priorities = np.append(base_priority, new_bin_priority)

    return priorities
```
