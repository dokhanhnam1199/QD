```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    exact_fit_bonus: float = 1e5,
    slack_decay: float = 10.0,
    next_item_factor: float = 0.1,
    jitter: float = 1e-6,
    atol: float = 1e-12,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently opened bin.
    exact_fit_bonus : float, optional
        Large bonus added for bins that can accommodate the item exactly.
    slack_decay : float, optional
        Controls the steepness of the exponential slack bonus.
    next_item_factor : float, optional
        Small bonus for bins that can still hold another item of the same size
        after the current placement.
    jitter : float, optional
        Deterministic tie‑breaker magnitude (lower‑index bins get a tiny
        advantage).
    atol : float, optional
        Absolute tolerance for detecting an exact fit.

    Returns
    -------
    np.ndarray
        Priority scores of the same shape as ``bins_remain_cap``.  Feasible
        bins receive finite scores; infeasible bins receive ``-np.inf`` and
        are never selected.
    """
    # Convert to a 1‑D float array; avoid modifying the caller's array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Initialise all scores to -inf (infeasible)
    priority = np.full_like(caps, -np.inf, dtype=float)

    if n_bins == 0:
        return priority

    # Slack after placing the item
    slack = caps - item
    feasible = slack >= 0

    # No feasible bins: return early
    if not np.any(feasible):
        return priority

    # Normalise slack within feasible bins to [0, 1]
    max_slack = np.max(slack[feasible])  # >= 0
    slack_norm = slack[feasible] / (max_slack + atol)

    # Exponential slack bonus: small slack → large bonus
    slack_bonus = np.exp(-slack_decay * slack_norm)

    # Base priority from slack bonus
    priority[feasible] = slack_bonus

    # Anticipation bonus: still room for another item of the same size
    anticipation_mask = feasible & (slack >= item)
    priority[anticipation_mask] += next_item_factor

    # Exact‑fit bonus
    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol)
    priority[exact_fit_mask] += exact_fit_bonus

    # Deterministic tie‑breaker: favor lower‑index bins slightly
    priority += -np.arange(n_bins, dtype=float) * jitter

    return priority
```
