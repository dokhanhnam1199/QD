```python
import numpy as np
from typing import Optional, Sequence

def priority_v2(
    item: float,
    bins_remain_cap: Sequence[float],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Sequence[float]] = None,
    lookahead_weight: float = 0.2,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (Best‑Fit with optional look‑ahead).

    Returns a score for each currently opened bin; higher scores indicate a more
    desirable bin for placing ``item``.  The caller should select the bin with the
    maximum score.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : Sequence[float]
        Remaining capacity of each open bin.
    bin_capacity : float, optional
        Fixed capacity of a bin.  If omitted, the maximum remaining capacity
        among the bins is used as a surrogate (any constant works because the
        same value is applied to all bins).
    lookahead_items : Sequence[float], optional
        Sizes of items known to arrive later.  Bins that can still accommodate
        more of these items after the current placement receive a boost
        proportional to ``lookahead_weight``.
    lookahead_weight : float, default 0.2
        Strength of the look‑ahead boost (0 ⇒ ignore look‑ahead, 1 ⇒ full boost).
    epsilon : float, default 1e-12
        Tiny deterministic tie‑breaker; lower‑index bins get a slight advantage.

    Returns
    -------
    np.ndarray
        Priority scores, same shape as ``bins_remain_cap``.  Infeasible bins
        (remaining capacity < ``item``) receive ``-np.inf``.
    """
    # Convert input to a NumPy array for vectorised operations.
    bins = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins.size

    # Empty input -> empty priority vector.
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Estimate bin capacity if not supplied.
    if bin_capacity is None:
        # Use the maximum remaining capacity as a proxy; add a tiny epsilon
        # to avoid division by zero when all bins are full.
        bin_capacity = float(np.max(bins)) if n_bins > 0 else 1.0
        if bin_capacity <= 0.0:
            bin_capacity = 1.0

    # Compute slack after placing the current item.
    slack = bins - item
    feasible = slack >= 0.0

    # Initialise all priorities to -inf (infeasible by default).
    priority = np.full_like(bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can hold the item; return all -inf.
        return priority

    # Normalised slack (0 = perfect fit, 1 = empty bin).
    norm_slack = slack[feasible] / bin_capacity
    # Base priority: higher for smaller slack (best‑fit).
    base_pr = -norm_slack  # values in [-1, 0].

    # Optional look‑ahead boost.
    if lookahead_items is not None:
        lookahead = np.asarray(lookahead_items, dtype=float)
        if lookahead.size > 0:
            remaining = slack[feasible]  # capacity left after placing `item`.
            # Count how many look‑ahead items each bin could still fit.
            fits = (remaining[:, None] >= lookahead[None, :]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0, 1]
            # Linear boost proportional to the ratio of future items that fit.
            base_pr = base_pr + lookahead_weight * fit_ratio

    # Deterministic tie‑breaker: lower index gets a tiny advantage.
    tie_breaker = -np.arange(n_bins, dtype=float) * epsilon
    # Combine base priority and tie‑breaker for feasible bins.
    priority[feasible] = base_pr + tie_breaker[feasible]

    return priority
```
