```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    exact_fit_bonus: float = 1e6,
    slack_exponent_k: float = 12.0,
    next_item_bonus: float = 0.05,
    jitter: float = 1e-12,
    exact_fit_atol: float = 1e-12,
    eps: float = 1e-12,
) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    For a given incoming ``item`` the function returns a score for each currently
    opened bin.  Higher scores indicate a more desirable bin for placement.

    Heuristics incorporated:
    • **Exact‑fit bonus** – a huge boost when the item fills a bin almost
      perfectly.
    • **Slack penalty** – bins with larger residual capacity after placement are
      penalised via an exponential term.
    • **Anticipation bonus** – a small extra reward if the bin would still have
      enough room for another item of the same size after the placement.
    • **Deterministic jitter** – a tiny index‑based term to break ties in a
      reproducible way.
    • **Infeasibility handling** – bins that cannot accommodate the item receive
      ``-np.inf`` priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each opened bin.
    exact_fit_bonus : float, optional
        Large constant added when the item exactly fits a bin (default 1e6).
    slack_exponent_k : float, optional
        Controls steepness of the exponential slack penalty (default 12.0).
    next_item_bonus : float, optional
        Small bonus for bins that would still accommodate another item of the
        same size after placement (default 0.05).
    jitter : float, optional
        Magnitude of deterministic tie‑breaker based on bin index (default
        1e-12).
    exact_fit_atol : float, optional
        Absolute tolerance for treating a placement as an exact fit (default
        1e-12).
    eps : float, optional
        Small constant to avoid division‑by‑zero when normalising slack
        (default 1e-12).

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  The caller should
        select the bin with the maximum priority.
    """
    # Ensure a flat float array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = bins_remain_cap.size

    # Edge case: no bins at all
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Compute slack (remaining capacity) if the item were placed
    slack = bins_remain_cap - item

    # Feasibility mask: only bins with non‑negative slack can hold the item
    feasible = slack >= 0.0

    # Initialise priorities with -inf (infeasible bins)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # If there are no feasible bins, return early
    if not feasible.any():
        return priorities

    # Base priority: negative slack (higher for tighter fits)
    base_priority = -slack[feasible]

    # Normalise slack for the exponential term
    max_slack = slack[feasible].max()
    denom = max_slack + eps          # avoid division by zero
    norm_slack = slack[feasible] / denom

    # Exponential slack bonus: larger for smaller slack
    slack_bonus = np.exp(-slack_exponent_k * norm_slack)

    # Anticipation bonus: bin still fits another item of the same size
    anticipate_bonus = np.where(slack[feasible] >= item, next_item_bonus, 0.0)

    # Combine components for feasible bins
    priority_feasible = base_priority + slack_bonus + anticipate_bonus

    # Exact‑fit boost (within tolerance)
    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)
    priority_feasible[exact_fit_mask] += exact_fit_bonus

    # Insert feasible priorities back into full array
    priorities[feasible] = priority_feasible

    # Deterministic tie‑breaker: favor lower‑index bins ever so slightly
    tie_breaker = -np.arange(n_bins, dtype=float) * jitter
    priorities += tie_breaker

    return priorities
```
