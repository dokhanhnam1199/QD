```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    exact_fit_bonus: float = 1e6,
    slack_exponent_k: float = 10.0,
    next_item_bonus: float = 0.05,
    jitter: float = 1e-12,
    exact_fit_atol: float = 1e-12,
    eps: float = 1e-12,
) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online Bin Packing problem.

    Heuristics (kept simple):
    • Exact‑fit boost – a very large constant when the item fills a bin almost
      perfectly.
    • Exponential slack penalty – tighter fits (smaller slack) receive a higher
      bonus via exp(-k * normalized_slack).
    • Anticipation bonus – a small extra reward if the bin would still fit another
      item of the same size after placement.
    • Deterministic tie‑breaker – tiny index‑based term to make the decision
      reproducible.
    • Infeasible bins receive -inf priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently opened bins.
    exact_fit_bonus : float, optional
        Large constant added for (near) exact fits.
    slack_exponent_k : float, optional
        Controls steepness of the exponential slack bonus.
    next_item_bonus : float, optional
        Bonus if the bin would still hold another item of the same size.
    jitter : float, optional
        Tiny magnitude for deterministic tie‑breaking.
    exact_fit_atol : float, optional
        Absolute tolerance for treating a placement as an exact fit.
    eps : float, optional
        Small constant to avoid division‑by‑zero when normalising slack.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  Higher scores are
        more desirable.
    """
    # Ensure a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Edge case: no bins at all
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Slack after placing the item
    slack = caps - item

    # Feasibility mask: slack must be non‑negative
    feasible = slack >= 0.0

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # If nothing fits, return early
    if not feasible.any():
        return priorities

    # Base priority: tighter fit → larger (negative slack)
    base_priority = -slack[feasible]

    # Normalise slack for exponential term (avoid division by zero)
    max_slack = slack[feasible].max()
    denom = max_slack + eps
    slack_norm = slack[feasible] / denom

    # Exponential slack bonus: larger for smaller slack_norm
    slack_bonus = np.exp(-slack_exponent_k * slack_norm)

    # Anticipation bonus: can still fit another item of the same size
    anticipate_bonus = np.where(slack[feasible] >= item, next_item_bonus, 0.0)

    # Combine components
    priority_feasible = base_priority + slack_bonus + anticipate_bonus

    # Exact‑fit boost (within tolerance)
    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)
    priority_feasible[exact_fit_mask] += exact_fit_bonus

    # Insert feasible priorities back into full array
    priorities[feasible] = priority_feasible

    # Deterministic tie‑breaker: favor lower‑index bins ever so slightly
    tie_breaker = -np.arange(n_bins, dtype=float) * jitter
    priorities += tie_breaker

    return priorities
```
