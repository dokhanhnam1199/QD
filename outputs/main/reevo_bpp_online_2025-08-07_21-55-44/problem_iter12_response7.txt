```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each open bin in an online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently opened bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better).  Infeasible bins receive -inf.
    """
    # Ensure 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Array to hold scores, -inf for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if n_bins == 0:
        return priorities

    # Slack after placing the item
    slack = caps - item

    # Feasible bins: slack >= 0
    feasible = slack >= 0.0

    if not np.any(feasible):
        return priorities

    # Constants for the scoring scheme
    EXACT_FIT_BONUS = 1e6      # Large boost for exact fit
    SLACK_EXPONENT_K = 12.0    # Controls steepness of exponential reward
    NEXT_ITEM_BONUS = 0.05     # Bonus if bin can still fit another same‑size item
    JITTER = 1e-12             # Tiny deterministic tie‑breaker
    EXACT_FIT_ATOL = 1e-12     # Tolerance for exact fit check

    # Normalise slack among feasible bins (avoid division by zero)
    max_slack = slack[feasible].max()
    denom = max_slack if max_slack > 0 else 1e-12
    slack_norm = slack[feasible] / denom

    # Linear base favouring tighter fits
    base = 1.0 - slack_norm

    # Exponential reward: tighter slack -> larger reward
    exp_reward = np.exp(-SLACK_EXPONENT_K * slack_norm)

    # Bonus if the bin will still be able to accommodate another same‑size item
    anticipate = np.where(slack[feasible] >= item, NEXT_ITEM_BONUS, 0.0)

    # Combine components
    score = base + exp_reward + anticipate

    # Exact‑fit boost (within tolerance)
    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=EXACT_FIT_ATOL)
    score[exact_fit_mask] += EXACT_FIT_BONUS

    # Assign scores to feasible bins
    priorities[feasible] = score

    # Deterministic tie‑breaker: lower index gets a tiny advantage
    priorities += -np.arange(n_bins, dtype=float) * JITTER

    return priorities
```
