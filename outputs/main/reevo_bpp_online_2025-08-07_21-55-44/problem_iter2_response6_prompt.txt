{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Random-fit priority score, selecting uniformly at random among bins that can\n    accommodate the incoming item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item to be packed.\n    bins_remain_cap : np.ndarray\n        1-D array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    priorities : np.ndarray\n        Array of the same shape as ``bins_remain_cap``.  Feasible bins (those with\n        remaining capacity >= ``item``) receive a uniform random priority in\n        the range [0, 1).  Infeasible bins are given a sentinel value of\n        ``-np.inf`` so they are never chosen when the algorithm selects the\n        bin with the highest priority.\n    \"\"\"\n    # Find bins that can accommodate the item\n    feasible_mask = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    # Assign random priorities only to feasible bins\n    if feasible_mask.any():\n        # Uniform random numbers in [0, 1) for the feasible bins\n        priorities[feasible_mask] = np.random.rand(feasible_mask.sum())\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Exact Fit First priority for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacities of existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher = more desirable).  The caller\n        should select the bin with the maximal score.  Bins that cannot fit\n        the item receive a large negative penalty, exact fits receive a very\n        high bonus, and among the remaining feasible bins the one leaving the\n        smallest leftover gets the highest priority.\n    \"\"\"\n    # Ensure we work with floats (copy not mandatory but safe)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialize all priorities to a very low value (unfeasible)\n    priorities = np.full(caps.shape, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that have enough space for the item\n    feasible = caps >= item\n    if not feasible.any():\n        # No bin can accommodate the item; return penalties (caller can open a new bin)\n        return priorities\n\n    # Compute leftover space after placing the item in each feasible bin\n    leftover = caps - item\n\n    # Base priority: the smaller the leftover, the higher the priority.\n    # Using negative leftover makes an exact fit (leftover = 0) the highest\n    # among feasible bins (priority = 0), while larger leftovers give negative values.\n    priorities[feasible] = -leftover[feasible]\n\n    # Detect exact fits (within a tolerance) and give them a massive boost\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        # Bonus large enough to dominate any other feasible priority\n        EXACT_FIT_BONUS = 1e9\n        priorities[exact_fit] = EXACT_FIT_BONUS\n\n    return priorities\n\n[Reflection]\nPrefer exact fits, minimize leftover, penalize infeasible, deterministic scoring, tie\u2011breaking, anticipate future items.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}