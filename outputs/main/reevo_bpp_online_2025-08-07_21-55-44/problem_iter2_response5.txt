```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin in an online Bin Packing Problem.

    The priority blends a logistic fit of the item‑to‑capacity ratio,
    a slight index bias (first‑fit), a penalty for very tight residual capacity,
    and a tie‑breaker based on the variance of the bins' remaining capacities
    after a hypothetical placement.  Parameters of the logistic function
    (steepness and centre) adapt to the current number of bins.

    A higher score indicates a more desirable bin.  Bins that cannot accommodate
    the item receive ``-np.inf`` so they will never be selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
    """
    # Ensure the capacities are a NumPy float array
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.shape[0]

    # Edge case: no bins present
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask: can the item fit into the bin?
    feasible = caps >= item

    # -----------------------------------------------------------------
    # 1) Logistic fit of item‑to‑capacity ratio
    # -----------------------------------------------------------------
    ratio = np.empty_like(caps)
    ratio.fill(0.0)                     # placeholder for infeasible bins
    ratio[feasible] = item / caps[feasible]

    # Adapt logistic parameters to the number of bins
    k = 5.0 + n_bins / 5.0               # steepness grows with bin count
    centre = 0.5 + 0.4 * (n_bins / (n_bins + 20.0))  # moves from 0.5 toward 0.9

    # Logistic score (higher when the ratio exceeds the centre)
    exp_arg = -k * (ratio - centre)
    # Clip exponent to avoid overflow/underflow in np.exp
    exp_arg = np.clip(exp_arg, -700, 700)
    logistic_score = 1.0 / (1.0 + np.exp(exp_arg))

    # -----------------------------------------------------------------
    # 2) Index bias (first‑fit) – tiny boost for lower indices
    # -----------------------------------------------------------------
    idx = np.arange(n_bins, dtype=float)
    epsilon_idx = 1e-6
    index_score = -idx * epsilon_idx   # lower index → larger (less negative) score

    # -----------------------------------------------------------------
    # 3) Penalty for very tight residual capacity
    # -----------------------------------------------------------------
    residual = caps - item
    residual_frac = np.empty_like(caps)
    residual_frac.fill(0.0)
    residual_frac[feasible] = residual[feasible] / caps[feasible]

    alpha = 0.2          # maximum penalty magnitude
    beta = 10.0          # decay speed of the penalty with residual fraction
    penalty = -alpha * np.exp(-beta * residual_frac)

    # -----------------------------------------------------------------
    # 4) Variance‑based tie‑breaker (favor balanced bins)
    # -----------------------------------------------------------------
    # Compute variance of remaining capacities after placing the item in each bin.
    caps_matrix = np.tile(caps, (n_bins, 1))
    new_caps_matrix = caps_matrix - item * np.eye(n_bins, dtype=float)
    variances = new_caps_matrix.var(axis=1)          # shape (n_bins,)
    weight_var = 0.01                                 # small scaling factor
    variance_score = -weight_var * variances

    # -----------------------------------------------------------------
    # Combine all components
    # -----------------------------------------------------------------
    total_score = logistic_score + index_score + penalty + variance_score

    # Infeasible bins should never be selected
    total_score = np.where(feasible, total_score, -np.inf)

    return total_score
```
