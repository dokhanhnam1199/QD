```python
import numpy as np
from typing import Optional, Union

__all__ = ["priority_v2"]


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, list, tuple],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,
    k_base: float = 8.0,
    alpha: float = 0.2,
    exact_fit_bonus: float = 1e6,
    jitter_eps: float = 1e-12,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacity of each currently opened bin.
    bin_capacity : float, optional
        Fixed capacity of a bin. If omitted, it is inferred from the
        current bins (ensuring it is at least ``item``).
    lookahead_items : array‑like of float, optional
        Sizes of items that are expected to arrive soon.  Bins that can still
        accommodate more of these items after the current placement receive a
        multiplicative boost.
    k_base = float, default 8.0
        Base steepness for the exponential decay; scaled by bin fullness.
    alpha : float, default 0.2
        Strength of the look‑ahead boost (0 ≤ alpha ≤ 1).
    exact_fit_bonus : float, default 1e6
        Large additive bonus for bins that become perfectly full after
        placing the item (i.e., zero slack).
    jitter_eps : float, default 1e-12
        Magnitude of the tiny random tie‑breaker added to each score.
    random_state : int or np.random.Generator, optional
        Seed or generator for the random tie‑breaker.

    Returns
    -------
    np.ndarray
        Priority scores (same length as ``bins_remain_cap``).  Infeasible bins
        receive ``-np.inf`` and will never be selected.
    """
    # ------------------------------------------------------------------
    # 1. Normalise inputs
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # ------------------------------------------------------------------
    # 2. Determine bin capacity
    # ------------------------------------------------------------------
    if bin_capacity is None:
        # At least the largest observed capacity; if that is smaller than
        # the incoming item, enlarge it just enough.
        max_cap = np.max(caps) if caps.size else 0.0
        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)
    else:
        bin_capacity = float(bin_capacity)
    if bin_capacity <= 0:
        raise ValueError("bin_capacity must be positive.")

    # ------------------------------------------------------------------
    # 3. Feasibility mask
    # ------------------------------------------------------------------
    feasible = caps >= item
    if not np.any(feasible):
        # No bin can host the item.
        return np.full(n_bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # 4. Compute leftover capacity after placement (feasible bins only)
    # ------------------------------------------------------------------
    leftover = caps[feasible] - item               # >= 0
    gap_norm = leftover / bin_capacity              # in [0, 1]

    # ------------------------------------------------------------------
    # 5. Dynamic steepness based on pre‑placement fullness
    # ------------------------------------------------------------------
    fullness_before = (bin_capacity - caps[feasible]) / bin_capacity = bin_capacity - caps[feasible]) / bin_capacity
    k = k_base * (1.0 + fullness_before)            # larger for fuller bins
    # Clip to avoid extreme values that could cause overflow/underflow
    k = np.clip(k, 0.1, 1e3)

    # ------------------------------------------------------------------
    # 6. Base priority via exponential decay (tight sigmoid analogue)
    # ------------------------------------------------------------------
    # Larger leftover => smaller score
    base_score = np.exp(-k * gap_norm)              # in (0, 1], 1 when gap_norm=0

    # ------------------------------------------------------------------
    # 7. Look‑ahead boost (optional)
    # ------------------------------------------------------------------
    if lookahead_items is not None:
        look = np.asarray(lookahead_items, dtype=float).ravel()
        if look.size > 0:
            # Count how many look‑ahead items each bin could still fit
            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(look.size)   # in [0, 1]
            boost = 1.0 + np.clip(alpha, 0.0, 1.   # Ensure alpha stays bounded
                               ) * fit_ratio
            base_score *= boost

    # ------------------------------------------------------------------
    # 8. Exact‑fit bonus
    # ------------------------------------------------------------------
    exact_fit_mask = np.isclose(leftover, 0.0, atol=1e-12)
    if np.any(exact_fit_mask):
        base_score[exact_fit_mask] += exact_fit_bonus

    # ------------------------------------------------------------------
    # 9. Tiny random tie‑breaker
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    jitter = rng.uniform(0.0, jitter_eps, size=base_score.shape)
    base_score += jitter

    # ------------------------------------------------------------------
    # 10. Assemble full priority vector
    # ------------------------------------------------------------------
    priority = np.full(n_bins, -np.inf, dtype=float)
    priority[feasible] = base_score

    # ------------------------------------------------------------------
    # 11. Deterministic tie‑breaker (optional, ensures reproducibility)
    # ------------------------------------------------------------------
    # Subtract a vanishing amount proportional to bin index so that lower
    # indices win when scores are otherwise identical.
    priority[feasible] -= np.arange(priority[feasible].size, dtype=float) * (jitter_eps * jitter_eps) # tiny decreasing term

    return priority
```
