```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    beta: float = 10.0,
    epsilon: float = 0.0,
    rng: np.random.Generator | None = None,
) -> np.ndarray:
    """
    Compute a priority score for each bin in an online bin‑packing setting.

    The priority is based on a normalized residual capacity after placing the
    item, transformed through a steep sigmoid so that bins with a tight fit
    obtain a high score while bins with large leftover capacity obtain a low
    score. Infeasible bins (insufficient remaining capacity) receive
    ``-np.inf`` to guarantee they are never selected, unless the optional
    ``epsilon``‑greedy exploration is active.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for the existing bins.
    beta : float, optional
        Steepness of the sigmoid; larger values increase the contrast between
        tight and loose fits. Must be non‑negative.
    epsilon : float, optional
        Exploration probability (0 ≤ epsilon ≤ 1). With probability ``epsilon``
        the function returns random scores for feasible bins to encourage
        exploration of sub‑optimal placements.
    rng : np.random.Generator | None, optional
        Random number generator for reproducibility. If ``None``, a fresh
        default generator is used.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (shape ``bins_remain_cap.shape``). Higher
        values indicate a more desirable placement.
    """
    if rng is None:
        rng = np.random.default_rng()

    # Ensure input is a 1‑D float array
    remain = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = remain.size

    # Empty case – nothing to score
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Initialise all priorities as -inf (infeasible by default)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Identify feasible bins
    feasible_mask = remain >= item
    n_feasible = feasible_mask.sum()
    if n_feasible == 0:
        # No bin can accommodate the item; return all -inf
        return priorities

    # Exploration vs exploitation
    explore = rng.random() < epsilon

    if explore:
        # Random uniform scores for exploration
        raw_scores = rng.random(n_feasible)
    else:
        # Residual capacity after placing the item
        residual = remain[feasible_mask] - item

        # Normalise residuals to [0, 1] using the maximum residual as scale.
        scale = residual.max()
        scale = scale if scale > 0 else 1.0  # avoid division by zero
        normalized = residual / scale

        # Sigmoid transform: higher priority for smaller residuals.
        # Numerically stable: exponent ∈ [-beta, 0]
        exp_term = np.exp(-beta * normalized)
        raw_scores = 1.0 / (1.0 + exp_term)

    # Tiny jitter to break ties deterministically
    jitter = rng.random(n_feasible) * 1e-9
    raw_scores = raw_scores + jitter

    # Populate the priority array
    priorities[feasible_mask] = raw_scores

    return priorities
```
