[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\nfrom typing import Optional, Union, Sequence\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    k_base: float = 8.0,\n    k_scale: float = 5.0,\n    reuse_bonus: float = 0.05,\n    exact_fit_bonus: float = 10.0,\n    lookahead_alpha: float = 0.2,\n    jitter: float = 1e-9,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If ``None``, a default of 1.0 is used.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can still accommodate more of these\n        items after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the adaptive sigmoid.\n    k_scale : float, default 5.0\n        How much the steepness grows with bin fullness (0\u20131).\n    reuse_bonus : float, default 0.05\n        Constant added to scores of feasible bins, favouring reuse over\n        opening a new bin.\n    exact_fit_bonus : float, default 10.0\n        Large boost for bins where the item exactly fits.\n    lookahead_alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202f\u03b1\u202f\u2264\u202f1).\n    jitter : float, default 1e-9\n        Magnitude of deterministic and random tie\u2011breakers.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible random tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # Convert bins to a NumPy array\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    if n_bins == 0:\n        # No bins opened yet\n        return np.empty(0, dtype=float)\n\n    # Determine the nominal bin capacity\n    if bin_capacity is None:\n        bin_capacity = 1.0\n\n    # Feasibility mask: bins that can hold the item\n    feasible = bins >= item\n\n    # Initialise priority vector with -inf for infeasible bins\n    priority = np.full_like(bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 caller will open a new bin\n        return priority\n\n    # Slack after placing the item (non\u2011negative for feasible bins)\n    slack = bins[feasible] - item\n    norm_slack = slack / bin_capacity  # normalized to [0, 1]\n\n    # Fullness before placement (0 = empty, 1 = completely full)\n    fullness = (bin_capacity - bins[feasible]) / bin_capacity\n    fullness = np.clip(fullness, 0.0, 1.0)\n\n    # Adaptive sigmoid steepness: steeper for fuller bins\n    k = k_base * (1.0 + k_scale * fullness)\n\n    # Decreasing sigmoid: yields 1 for exact fit (slack=0) and \u21920 for large slack\n    exponent = np.clip(k * norm_slack, -700.0, 700.0)  # avoid overflow\n    sigmoid_score = 2.0 / (1.0 + np.exp(exponent))\n\n    # Exact\u2011fit bonus\n    eps = 1e-12\n    exact_bonus = np.where(slack <= eps, exact_fit_bonus, 0.0)\n\n    # Base score (sigmoid + bonuses)\n    base_score = sigmoid_score + exact_bonus + reuse_bonus\n\n    # Optional look\u2011ahead boost\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n        if lookahead.size > 0:\n            # Remaining capacity after placement for each feasible bin\n            remaining = slack[:, None]                     # shape (m, 1)\n            fits = (remaining >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0, 1]\n            boost = 1.0 + np.clip(lookahead_alpha, 0.0, 1.0) * fit_ratio\n            base_score *= boost\n\n    # Random tie\u2011breaker (tiny noise)\n    rng = np.random.default_rng(random_state)\n    noise = rng.uniform(0.0, jitter, size=base_score.shape)\n    base_score += noise\n\n    # Assign scores to feasible bins\n    priority[feasible] = base_score\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage\n    deterministic_jitter = -np.arange(n_bins, dtype=float) * jitter\n    priority += deterministic_jitter\n\n    return priority",
    "response_id": 0,
    "obj": 4.108496210610296,
    "SLOC": 49.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\nfrom typing import Optional, Union, Sequence\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    k_base: float = 8.0,\n    reuse_bonus: float = 0.05,\n    exact_fit_bonus: float = 10.0,\n    lookahead_alpha: float = 0.2,\n    jitter: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacities of the currently opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If ``None`` the maximum remaining capacity\n        observed is taken as the nominal capacity (plus a tiny epsilon).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can still accommodate more of these\n        items after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the adaptive sigmoid.  Steepness is scaled by\n        bin fullness (fuller bins get a steeper curve).\n    reuse_bonus : float, default 0.05\n        Small constant added to all feasible bins to prefer reusing an\n        existing bin over opening a new one.\n    exact_fit_bonus : float, default 10.0\n        Large boost when the item exactly fits the remaining capacity.\n    lookahead_alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0 \u2264 lookahead_alpha \u2264 1).\n    jitter : float, default 1e-12\n        Magnitude of deterministic tie\u2011breaker (lower\u2011index bins get a\n        slight advantage) and the upper bound for random noise.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape matches ``bins_remain_cap``).\n        Infeasible bins receive ``-np.inf`` and are never selected.\n    \"\"\"\n    # Convert inputs to NumPy arrays\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Determine bin capacity if not supplied\n    if bin_capacity is None:\n        # Use a tiny epsilon to avoid division by zero if all bins are empty\n        bin_capacity = float(np.max(bins)) + 1e-9\n\n    # Feasibility mask: bin can host the item only if it has enough remaining capacity\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No feasible bin \u2013 caller will need to open a new one\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # Slack after placing the item (only for feasible bins)\n    slack = bins[feasible] - item                     # shape (m,)\n    slack_norm = slack / bin_capacity                 # normalised slack \u2208 [0, 1]\n\n    # Bin fullness before placement (0 = empty, 1 = completely full)\n    fullness = (bin_capacity - bins[feasible]) / bin_capacity\n    fullness = np.clip(fullness, 0.0, 1.0)\n\n    # Adaptive sigmoid steepness: steeper for fuller bins\n    k = k_base * (1.0 + fullness)                     # shape (m,)\n\n    # Decreasing sigmoid on normalised slack.\n    # Smaller slack \u2192 larger score. Score \u2208 (0, 0.5] after the division.\n    # Clip exponent to avoid overflow.\n    exponent = k * slack_norm\n    exponent = np.clip(exponent, -700.0, 700.0)\n    sigmoid_score = 1.0 / (1.0 + np.exp(exponent))\n\n    # Exact\u2011fit bonus (large boost when slack is essentially zero)\n    eps = 1e-12\n    exact_bonus = np.where(slack <= eps, exact_fit_bonus, 0.0)\n\n    # Optional look\u2011ahead boost\n    lookahead_boost = np.ones_like(sigmoid_score)\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float)\n        if look.size > 0:\n            # Remaining capacity after the current placement\n            remaining = slack  # shape (m,)\n            # Count how many look\u2011ahead items each bin could still accommodate\n            fits = (remaining[:, None] >= look[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(look.size)  # \u2208 [0, 1]\n            lookahead_boost = 1.0 + lookahead_alpha * fit_ratio\n\n    # Combine base score with bonuses\n    scores = sigmoid_score + reuse_bonus + exact_bonus\n    scores *= lookahead_boost\n\n    # Tiny random tie\u2011breaker\n    rng = np.random.default_rng(random_state)\n    random_noise = rng.uniform(0.0, jitter, size=scores.shape)\n    scores += random_noise\n\n    # Assemble final priority vector, initialise with -inf for infeasible bins\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    # Deterministic tie\u2011breaker: lower\u2011index bins receive a minuscule advantage\n    priority -= np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 49.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\nfrom typing import Optional, Sequence\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Sequence[float],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Sequence[float]] = None,\n    lookahead_weight: float = 0.2,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (Best\u2011Fit with optional look\u2011ahead).\n\n    Returns a score for each currently opened bin; higher scores indicate a more\n    desirable bin for placing ``item``.  The caller should select the bin with the\n    maximum score.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : Sequence[float]\n        Remaining capacity of each open bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If omitted, the maximum remaining capacity\n        among the bins is used as a surrogate (any constant works because the\n        same value is applied to all bins).\n    lookahead_items : Sequence[float], optional\n        Sizes of items known to arrive later.  Bins that can still accommodate\n        more of these items after the current placement receive a boost\n        proportional to ``lookahead_weight``.\n    lookahead_weight : float, default 0.2\n        Strength of the look\u2011ahead boost (0 \u21d2 ignore look\u2011ahead, 1 \u21d2 full boost).\n    epsilon : float, default 1e-12\n        Tiny deterministic tie\u2011breaker; lower\u2011index bins get a slight advantage.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, same shape as ``bins_remain_cap``.  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # Convert input to a NumPy array for vectorised operations.\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    # Empty input -> empty priority vector.\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Estimate bin capacity if not supplied.\n    if bin_capacity is None:\n        # Use the maximum remaining capacity as a proxy; add a tiny epsilon\n        # to avoid division by zero when all bins are full.\n        bin_capacity = float(np.max(bins)) if n_bins > 0 else 1.0\n        if bin_capacity <= 0.0:\n            bin_capacity = 1.0\n\n    # Compute slack after placing the current item.\n    slack = bins - item\n    feasible = slack >= 0.0\n\n    # Initialise all priorities to -inf (infeasible by default).\n    priority = np.full_like(bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can hold the item; return all -inf.\n        return priority\n\n    # Normalised slack (0 = perfect fit, 1 = empty bin).\n    norm_slack = slack[feasible] / bin_capacity\n    # Base priority: higher for smaller slack (best\u2011fit).\n    base_pr = -norm_slack  # values in [-1, 0].\n\n    # Optional look\u2011ahead boost.\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n        if lookahead.size > 0:\n            remaining = slack[feasible]  # capacity left after placing `item`.\n            # Count how many look\u2011ahead items each bin could still fit.\n            fits = (remaining[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0, 1]\n            # Linear boost proportional to the ratio of future items that fit.\n            base_pr = base_pr + lookahead_weight * fit_ratio\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage.\n    tie_breaker = -np.arange(n_bins, dtype=float) * epsilon\n    # Combine base priority and tie\u2011breaker for feasible bins.\n    priority[feasible] = base_pr + tie_breaker[feasible]\n\n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 34.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\nfrom typing import Optional, Union, Sequence\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    base_steepness: float = 8.0,\n    lookahead_alpha: float = 0.2,\n    exact_fit_bonus: float = 0.15,\n    jitter: float = 1e-7,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like, shape (n_bins,)\n        Remaining capacities of the currently opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin. If ``None``, it is inferred as\n        ``max(bins_remain_cap) + item`` (plus a tiny epsilon).\n    lookahead_items : array\u2011like, optional\n        Sizes of a few future items.  Bins that can still accommodate many of\n        these items after the current placement receive a multiplicative boost.\n    base_steepness : float, default 8.0\n        Base steepness for the sigmoid; scaled by ``1 + fullness``.\n    lookahead_alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202f\u03b1\u202f\u2264\u202f1).\n    exact_fit_bonus : float, default 0.15\n        Additive bonus for bins that fit the item exactly.\n    jitter : float, default 1e-7\n        Amplitude of tiny random noise for tie\u2011breaking.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible jitter.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (0\u2011based). Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    if bin_capacity is None:\n        bin_capacity = float(np.max(bins) + item + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n    if bin_capacity <= 0.0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    feasible = bins >= item\n    if not np.any(feasible):\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    slack = bins - item                     # >= 0 for feasible bins\n    norm_gap = np.clip(slack / bin_capacity, 0.0, 1.0)  # normalised slack \u2208[0,1]\n    fullness = np.clip((bin_capacity - bins) / bin_capacity, 0.0, 1.0)\n\n    k = base_steepness * (1.0 + fullness)   # steeper for already\u2011full bins\n    exponent = k * (0.5 - norm_gap)         # larger \u2192 tighter fit\n    exponent = np.clip(exponent, -700.0, 700.0)  # avoid overflow\n    scores = 1.0 / (1.0 + np.exp(-exponent))\n\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    scores[exact_fit_mask] += exact_fit_bonus\n\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float).ravel()\n        if lookahead.size > 0:\n            remaining_after = slack[feasible]   # \u22650\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / lookahead.size\n            boost = 1.0 + np.clip(lookahead_alpha, 0.0, 1.0) * fit_ratio\n            scores[feasible] *= boost\n\n    rng = np.random.default_rng(random_state)\n    jitter_noise = rng.uniform(0.0, jitter, size=np.count_nonzero(feasible))\n    scores[feasible] += jitter_noise\n\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores[feasible]\n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 48.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority scores for online Bin Packing.\n\n    Higher scores indicate more desirable bins.\n    Infeasible bins receive -inf so they are never chosen.\n\n    The score is monotonic: bins that would leave less slack after placing the\n    item receive a higher score.  A simple exponential penalty discourages\n    leaving large slack, an enormous exact\u2011fit bonus forces a perfect fit when\n    possible, and a tiny deterministic jitter breaks ties in favour of lower\n    index bins.  Only a few hyper\u2011parameters are used.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D (or flattenable) array of remaining capacities of the currently\n        opened bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n    \"\"\"\n    # ---- Hyper\u2011parameters (minimal set) ----\n    slack_decay = 5.0          # steepness of the exponential slack penalty\n    exact_fit_bonus = 1e12     # huge reward for an exact fit\n    jitter_eps = 1e-12         # deterministic tie\u2011breaker magnitude\n    atol = 1e-12               # tolerance for floating\u2011point comparisons\n    # -----------------------------------------\n\n    # Flatten input for vectorised work, remember original shape for output\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Early exit for empty input\n    if n_bins = n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Remaining slack after (hypothetically) placing the item\n    slack_raw = caps - item\n\n    # Feasibility mask: allow a tiny negative slack due to FP errors\n    feasible = slack_raw >= -atol\n\n    # Initialise priority array with -inf (infeasible bins)\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 caller will open a new bin\n        return priority.reshape(bins_remain_cap.shape)\n\n    # Clip slack to zero for feasible bins (negative slack treated as zero)\n    slack = np.where(feasible, np.maximum(slack_raw, 0.0), 0.0)\n\n    # Base monotonic component: smaller slack \u2192 larger (less negative) score\n    base_score = -slack\n\n    # Exponential slack penalty (larger slack \u2192 larger penalty)\n    slack_penalty = np.exp(slack_decay * slack)\n\n    # Combined score for feasible bins\n    score = base_score - slack_penalty\n\n    # Exact\u2011fit detection (slack effectively zero) and huge bonus\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol)\n    if np.any(exact_fit_mask):\n        score[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic jitter: prefers lower\u2011index bins\n    jitter = np.arange(n_bins, dtype=float) * jitter_eps\n    score -= jitter\n\n    # Write scores back to the priority array\n    priority[feasible] = score[feasible]\n\n    # Reshape to original input shape\n    return priority.reshape(bins_remain_cap.shape)",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41\n    if n_bins = n_bins == 0:\n       ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41\n    if n_bins = n_bins == 0:\n       ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41\n    if n_bins = n_bins == 0:\n       ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n"
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\nfrom typing import Optional, Sequence, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    base_k: float = 8.0,\n    lookahead_alpha: float = 0.2,\n    exact_fit_bonus: float = 1e6,\n    jitter_eps: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array-like of float\n        Remaining capacities of the currently opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of a bin. If ``None`` the capacity is inferred from the\n        maximum remaining capacity (plus the current item if needed).\n    lookahead_items : array-like of float, optional\n        Sizes of items expected to arrive soon. Bins that can still accommodate\n        a larger fraction of these items after placing the current item receive\n        a multiplicative boost.\n    base_k : float, default 8.0\n        Steepness of the logistic scaling; larger values make the function\n        more discriminative between tight and loose fits.\n    lookahead_alpha : float, default 0.2\n        Strength of the multiplicative look\u2011ahead boost.\n    exact_fit_bonus : float, default 1e6\n        Large additive bonus for bins that become exactly full after placement.\n    jitter_eps : float, default 1e-12\n        Magnitude of the random tie\u2011breaker added to each score.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible jitter.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Convert bins to numpy array and flatten\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not provided\n    if bin_capacity is None:\n        max_cap = caps.max() if caps.size > 0 else 0.0\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    if bin_capacity <= 0.0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # Feasibility mask: bin can hold the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # Remaining capacity after placing the item (only for feasible bins)\n    leftover = caps[feasible] - item\n    slack_norm = leftover / bin_capacity  # normalized slack in [0, 1]\n\n    # Logistic scaling: high score for small slack, low score for large slack.\n    # Center the logistic at slack = 0.5 so a half\u2011empty bin gets ~0.5.\n    arg = base_k * (slack_norm - 0.5)\n    arg = np.clip(arg, -700.0, 700.0)               # avoid overflow\n    scores = 1.0 / (1.0 + np.exp(arg))              # values in (0, 1)\n\n    # Look\u2011ahead multiplicative boost\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            fits = (look <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits / float(look.size)    # proportion of look\u2011ahead items that still fit\n            scores *= (1.0 + lookahead_alpha * fit_ratio)\n\n    # Exact\u2011fit bonus\n    eps = 1e-12\n    exact_fit_mask = leftover <= eps\n    if np.any(exact_fit_mask):\n        scores[exact_fit_mask] += exact_fit_bonus\n\n    # Random jitter to break ties\n    rng = np.random.default_rng(random_state)\n    jitter = rng.uniform(-jitter_eps, jitter_eps, size=scores.shape)\n    scores += jitter\n\n    # Assemble full priority vector\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 45.0,
    "cyclomatic_complexity": 10.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\nfrom typing import Optional, Sequence, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    base_steepness: float = 8.0,\n    lookahead_alpha: float = 0.2,\n    exact_fit_bonus: float = 0.15,\n    jitter: float = 1e-7,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float, shape (n_bins,)\n        Remaining capacities of the currently opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin.  If ``None`` the capacity is inferred as\n        ``max(bins_remain_cap) + item`` (plus a tiny epsilon).  Must be > 0.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of a few future items.  Bins that can still accommodate many of\n        these items after placing the current item receive a multiplicative\n        boost.\n    base_steepness : float, default 8.0\n        Base steepness for the sigmoid; scaled by ``1 + fullness``.\n    lookahead_alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202f\u03b1\u202f\u2264\u202f1).\n    exact_fit_bonus : float, default 0.15\n        Additive bonus for bins that fit the item exactly.\n    jitter : float, default 1e-7\n        Amplitude of tiny random noise for tie\u2011breaking.  A deterministic\n        offset proportional to the bin index is also added.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible jitter.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Normalise inputs\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 2. Determine (or validate) bin capacity\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # Infer a capacity that is at least as large as the largest observed\n        # remaining capacity plus the current item.\n        bin_capacity = float(np.max(bins) + item + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n    if bin_capacity <= 0.0:\n        raise ValueError(\"bin_capacity must be a positive number.\")\n\n    # ------------------------------------------------------------------\n    # 3. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 4. Slack after placement and derived quantities (only for feasible)\n    # ------------------------------------------------------------------\n    slack = bins - item                     # slack \u2265 0 for feasible bins\n    slack_feas = slack[feasible]\n\n    # Normalised slack (0 = exact fit, 1 = empty bin after placement)\n    norm_slack = np.clip(slack_feas / bin_capacity, 0.0, 1.0)\n\n    # Fullness before placement (0 = empty, 1 = full)\n    fullness = np.clip((bin_capacity - bins[feasible]) / bin_capacity, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # 5. Adaptive sigmoid steepness\n    # ------------------------------------------------------------------\n    k = base_steepness * (1.0 + fullness)   # steeper for already\u2011full bins\n\n    # ------------------------------------------------------------------\n    # 6. Sigmoid score (higher for tighter fit)\n    # ------------------------------------------------------------------\n    # Exponent is largest when norm_slack is smallest (tight fit).\n    exponent = k * (1.0 - norm_slack)        # in [0, k]\n    exponent = np.clip(exponent, -700.0, 700.0)  # guard against overflow\n    scores = 1.0 / (1.0 + np.exp(-exponent))  # \u2208 (0.5, 1]\n\n    # ------------------------------------------------------------------\n    # 7. Exact\u2011fit bonus\n    # ------------------------------------------------------------------\n    exact_fit_mask = np.isclose(slack_feas, 0.0, atol=1e-12)\n    scores[exact_fit_mask] += exact_fit_bonus\n\n    # ------------------------------------------------------------------\n    # 8. Look\u2011ahead boost (optional)\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float).ravel()\n        if lookahead.size > 0:\n            # Remaining capacity after placing the current item.\n            remaining_after = slack_feas\n            # Count how many look\u2011ahead items could still fit into each bin.\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / lookahead.size  # \u2208 [0, 1]\n            boost = 1.0 + np.clip(lookahead_alpha, 0.0, 1.0) * fit_ratio\n            scores *= boost\n\n    # ------------------------------------------------------------------\n    # 9. Tiny jitter for stochastic tie\u2011breaking\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    jitter_noise = np.zeros_like(bins)\n    jitter_noise[feasible] = rng.uniform(0.0, jitter, size=np.count_nonzero(feasible))\n\n    # Deterministic offset: lower index gets a slight advantage.\n    deterministic_offset = -np.arange(n_bins, dtype=float) * (jitter * 0.1)\n\n    # ------------------------------------------------------------------\n    # 10. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full(bins.shape, -np.inf, dtype=float)\n    priority[feasible] = (\n        scores\n        + jitter_noise[feasible]\n        + deterministic_offset[feasible]\n    )\n\n    return priority",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 54.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each open bin in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently opened bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better).  Infeasible bins receive -inf.\n    \"\"\"\n    # Ensure 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Array to hold scores, -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        return priorities\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Feasible bins: slack >= 0\n    feasible = slack >= 0.0\n\n    if not np.any(feasible):\n        return priorities\n\n    # Constants for the scoring scheme\n    EXACT_FIT_BONUS = 1e6      # Large boost for exact fit\n    SLACK_EXPONENT_K = 12.0    # Controls steepness of exponential reward\n    NEXT_ITEM_BONUS = 0.05     # Bonus if bin can still fit another same\u2011size item\n    JITTER = 1e-12             # Tiny deterministic tie\u2011breaker\n    EXACT_FIT_ATOL = 1e-12     # Tolerance for exact fit check\n\n    # Normalise slack among feasible bins (avoid division by zero)\n    max_slack = slack[feasible].max()\n    denom = max_slack if max_slack > 0 else 1e-12\n    slack_norm = slack[feasible] / denom\n\n    # Linear base favouring tighter fits\n    base = 1.0 - slack_norm\n\n    # Exponential reward: tighter slack -> larger reward\n    exp_reward = np.exp(-SLACK_EXPONENT_K * slack_norm)\n\n    # Bonus if the bin will still be able to accommodate another same\u2011size item\n    anticipate = np.where(slack[feasible] >= item, NEXT_ITEM_BONUS, 0.0)\n\n    # Combine components\n    score = base + exp_reward + anticipate\n\n    # Exact\u2011fit boost (within tolerance)\n    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=EXACT_FIT_ATOL)\n    score[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # Assign scores to feasible bins\n    priorities[feasible] = score\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage\n    priorities += -np.arange(n_bins, dtype=float) * JITTER\n\n    return priorities",
    "response_id": 7,
    "obj": 4.058635819704831,
    "SLOC": 27.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\nfrom typing import Optional, Union, Sequence\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    exact_fit_bonus: float = 1e5,\n    reuse_bonus: float = 0.05,\n    jitter_eps: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each open bin in an online bin\u2011packing setting.\n\n    The score is larger for bins that:\n      * can accommodate the item (infeasible bins get -inf);\n      * leave little slack after placement, with a sigmoid that becomes steeper\n        for bins that are already fuller;\n      * achieve an exact fit (large additive bonus);\n      * are expected to accommodate look\u2011ahead items (multiplicative boost);\n      * are already opened (small reuse bonus);\n      * have a tiny random jitter to break ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacities of currently open bins.\n    bin_capacity is optional: the fixed capacity of each bin. If omitted it is\n        inferred from the maximum remaining capacity, guaranteeing it can\n        accommodate the current item.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of items expected to arrive soon. Bins that can still fit many\n        of these after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the logistic sigmoid; scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead multiplicative boost.\n    exact_fit_bonus : float, default 1e5\n        Large additive bonus for bins that become exactly full after placement.\n    reuse_bonus : float, default 0.05\n        Small constant added to every feasible bin to prefer reusing an existing bin.\n    jitter_eps : float, default 1e-12\n        Magnitude of the random tie\u2011breaker added to each feasible score.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores of shape ``(len(bins_remain_cap),)``. Infeasible bins\n        contain ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------\n    # Normalise inputs\n    # ------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not supplied\n    if bin_capacity is None:\n        max_cap = caps.max() if caps.size > 0 else 0.0\n        # Ensure capacity can hold the incoming item\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n\n    if bin_capacity <= 0.0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------\n    # Feasibility mask\n    # ------------------------------------------------------------\n    feasible = caps >= item\n    priority = np.full(n_bins, -np.inf, dtype=float)\n\n    if not feasible.any():\n        # No bin can accommodate the item; caller may open a new bin.\n        return priority\n\n    # ------------------------------------------------------------\n    # Core deterministic components\n    # ------------------------------------------------------------\n    # Slack after placing the item (non\u2011negative for feasible bins)\n    slack = caps[feasible] - item\n    slack_norm = slack / bin_capacity                      # \u2208 [0, 1]\n\n    # Bin fullness before placement (0 = empty, 1 = full)\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n\n    # Sigmoid steepness scales with fullness\n    k = k_base * (1.0 + fullness)\n\n    # Logistic sigmoid decreasing with slack_norm\n    # Argument centred at slack = 0.5 * bin_capacity so that slack = 0.5*C yields 0.5 score.\n    arg = k * (slack_norm - 0.5)\n    arg = np.clip(arg, -700.0, 700.0)          # avoid overflow in exp\n    sigmoid_score = 1.0 / (1.0 + np.exp(arg))  # range (0, 1)\n\n    # Exact\u2011fit bonus (large additive boost)\n    exact_fit_mask = np.isclose(slack, 0.0, atol=1e-12)\n    exact_fit_add = np.where(exact_fit_mask, exact_fit_bonus, 0.0)\n\n    # ------------------------------------------------------------\n    # Look\u2011ahead multiplicative boost\n    # ------------------------------------------------------------\n    lookahead_multiplier = 1.0\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            # For each feasible bin count how many look\u2011ahead items would still fit.\n            fits = (look[None, :] <= slack[:, None]).sum(axis=1)\n            fit_ratio = fits / float(look.size)          # \u2208 [0, 1]\n            lookahead_multiplier = 1.0 + alpha * fit_ratio\n\n    # ------------------------------------------------------------\n    # Random jitter for tie\u2011breaking\n    # ------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    jitter = rng.uniform(-jitter_eps, jitter_eps, size=slack.shape)\n\n    # ------------------------------------------------------------\n    # Assemble final scores for feasible bins\n    # ------------------------------------------------------------\n    scores = (\n        sigmoid_score * lookahead_multiplier\n        + exact_fit_add\n        + reuse_bonus\n        + jitter\n    )\n\n    priority[feasible] = scores\n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 52.0,
    "cyclomatic_complexity": 9.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\nfrom typing import Union, Sequence\n\ndef priority_v2(item: float,\n                bins_remain_cap: Union[np.ndarray, Sequence[float]],\n                *,\n                epsilon: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Best\u2011fit priority function for the online Bin Packing Problem.\n\n    The function returns a priority score for each bin such that the bin\n    with the highest score (i.e., the largest priority) is the one that\n    would leave the smallest remaining capacity after placing ``item``.\n    Infeasible bins (remaining capacity < ``item``) receive ``-np.inf`` so\n    they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    epsilon : float, optional\n        Tiny tie\u2011breaker added to favour lower\u2011index bins when the waste\n        is identical. The default value (1e\u201112) is far smaller than any\n        realistic waste difference.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, same shape as ``bins_remain_cap``.\n    \"\"\"\n    # Convert to a NumPy float array for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Early exit for empty bin list\n    if caps.size == 0:\n        return np.empty(0, dtype=float)\n\n    # Compute waste (remaining capacity after placing the item)\n    waste = caps - item\n\n    # Feasibility mask: only bins with non\u2011negative waste can hold the item\n    feasible = waste >= 0\n\n    # Base priority: negative waste (larger value \u21d2 tighter fit)\n    base_priority = np.where(feasible, -waste, -np.inf)\n\n    # Tiny deterministic tie\u2011breaker: lower\u2011index bins get a minute advantage\n    tie_breaker = -np.arange(caps.size, dtype=float) * epsilon\n\n    return base_priority + tie_breaker",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enhanced priority function for online Bin Packing.\n\n    The priority is higher (i.e., less negative) for bins that:\n      \u2022 Can accommodate the item (feasibility).\n      \u2022 Will have minimal slack after placement (best\u2011fit style).\n      \u2022 Are already relatively full (steepness scaled by current fullness).\n      \u2022 Provide an exact fit (large bonus).\n      \u2022 Leave only a small slack (small look\u2011ahead boost).\n      \u2022 Are not empty (penalize near\u2011empty bins to discourage opening new bins).\n\n    Tie\u2011breaking is done with a tiny deterministic jitter based on the bin index.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``). The caller\n        should select the bin with the maximum priority. Bins that cannot hold\n        the item receive ``-np.inf`` priority.\n    \"\"\"\n    # Ensure NumPy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Edge case: no bins opened yet\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n\n    # Estimate the (fixed) bin capacity.\n    # For online BPP the full capacity is the maximum remaining capacity among\n    # opened bins (empty bins retain full capacity). Fallback to 1.0 if needed.\n    capacity = bins_remain_cap.max()\n    if capacity <= 0:\n        capacity = 1.0\n\n    # Slack (waste) if the item were placed in each bin\n    waste = bins_remain_cap - item\n\n    # Feasibility mask\n    feasible = waste >= 0\n\n    # Normalized slack (0 = exact fit, 1 = completely empty bin)\n    slack_norm = np.where(feasible, waste / capacity, np.nan)\n\n    # Current fullness before placement (0 = empty, 1 = full)\n    fullness = (capacity - bins_remain_cap) / capacity\n\n    # --- 1. Base priority: scaled best\u2011fit via a power\u2011law (sigmoid\u2011like) ---\n    # Steepness grows with bin fullness: fuller bins get a steeper penalty for\n    # any remaining slack.\n    gamma = 2.0               # controls steepness scaling\n    steepness = 1.0 + gamma * fullness\n    # Power\u2011law transformation: smaller slack -> higher (less negative) priority\n    base_priority = np.where(\n        feasible,\n        - (slack_norm ** steepness),\n        -np.inf\n    )\n\n    # --- 2. Exact\u2011fit bonus (strongly reward waste == 0) ---\n    exact_fit_bonus = np.where(\n        feasible & np.isclose(waste, 0.0, atol=1e-12),\n        10.0,                     # large positive boost\n        0.0\n    )\n\n    # --- 3. Small look\u2011ahead boost for bins that would leave tiny slack ---\n    # Encourage bins that after placement still have room for a typical future\n    # item (here approximated by slack <= 5% of capacity).\n    lookahead_threshold = 0.05\n    lookahead_boost = np.where(\n        feasible & (slack_norm <= lookahead_threshold),\n        0.5,                      # modest positive boost\n        0.0\n    )\n\n    # --- 4. Penalty for using near\u2011empty bins (discourage new bin usage) ---\n    beta = 0.5\n    empty_penalty = -beta * (1.0 - fullness)   # larger penalty for emptier bins\n\n    # --- 5. Deterministic tie\u2011breaker (tiny jitter) ---\n    epsilon = 1e-12\n    tie_breaker = -np.arange(bins_remain_cap.size) * epsilon\n\n    # Combine all components\n    priority = (\n        base_priority\n        + exact_fit_bonus\n        + lookahead_boost\n        + empty_penalty\n        + tie_breaker\n    )\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 41.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]