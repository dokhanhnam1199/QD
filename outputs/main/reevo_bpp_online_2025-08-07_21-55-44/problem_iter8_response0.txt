```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    bin_capacity: float = 1.0,
    exact_fit_bonus: float = 1e9,
    slack_weight: float = 1.0,
    new_bin_penalty: float = 0.2,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Compute priority scores for an online Bin Packing decision.

    For each currently opened bin the function returns a score that rewards
    small waste (linear slack penalty) and gives a huge bonus for exact fits.
    A virtual new bin is appended as the last entry; opening a new bin incurs
    an extra waste penalty controlled by ``new_bin_penalty``.  A tiny
    deterministic tie‑breaker (``epsilon``) prefers lower‑index bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of already opened bins.
    bin_capacity : float, optional
        Fixed capacity of every bin (default 1.0).
    exact_fit_bonus : float, optional
        Large bonus added when a placement would fill a bin exactly.
    slack_weight : float, optional
        Linear weight for the normalized slack (waste). Larger values increase
        the penalty for waste.
    new_bin_penalty : float, optional
        Multiplicative factor applied to the waste of a newly opened bin
        (e.g., 0.2 adds a 20 % penalty).
    epsilon : float, optional
        Tiny value used for deterministic tie‑breaking.

    Returns
    -------
    np.ndarray
        Priority scores with shape ``(len(bins_remain_cap) + 1,)``.  The last
        element corresponds to the virtual new bin.  Infeasible bins receive
        ``-np.inf`` and will never be selected.
    """
    # Ensure a 1‑D NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # ---------- Existing bins ----------
    # Waste (remaining capacity after placing the item)
    waste = caps - item
    feasible = waste >= -epsilon  # tolerate tiny numerical negatives

    # Normalized slack (waste as fraction of bin capacity)
    slack = np.where(feasible, waste / bin_capacity, np.inf)

    # Base priority: linear penalty on slack (smaller slack → higher priority)
    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)

    # Exact‑fit bonus
    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=epsilon)
    base_priority = np.where(
        exact_fit_mask,
        base_priority + exact_fit_bonus,
        base_priority,
    )

    # Deterministic tie‑breaker (favor lower indices)
    tie_breaker = -np.arange(n_bins, dtype=float) * epsilon
    base_priority += tie_breaker

    # ---------- Virtual new bin ----------
    waste_new = bin_capacity - item
    if waste_new < -epsilon:
        # Item does not fit into an empty bin → infeasible
        new_bin_priority = -np.inf
    else:
        slack_new = waste_new / bin_capacity
        # Apply penalty for opening a new bin
        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)

        # Exact‑fit bonus for a perfect new bin
        if np.isclose(waste_new, 0.0, atol=epsilon):
            new_bin_priority += exact_fit_bonus

        # Tie‑breaker for the virtual bin (place it after all real bins)
        new_bin_priority += -n_bins * epsilon

    # Append the virtual bin priority
    priorities = np.append(base_priority, new_bin_priority)

    return priorities
```
