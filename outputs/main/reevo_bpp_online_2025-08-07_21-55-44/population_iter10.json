[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nfrom typing import Optional, Sequence, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Sequence[float]],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,\n    base_steepness: float = 8.0,\n    lookahead_alpha: float = 0.2,\n    exact_fit_bonus: float = 0.15,\n    jitter: float = 1e-7,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like, shape (n_bins,)\n        Remaining capacities of the currently opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin. If ``None``, it is inferred as\n        ``max(bins_remain_cap) + item`` (plus a tiny epsilon to avoid division\n        by zero).\n    lookahead_items : array\u2011like, optional\n        Sizes of a few future items. Bins that can still accommodate many of\n        these items after the current placement receive a multiplicative boost.\n    base_steepness : float, default 8.0\n        Base steepness for the sigmoid; scaled by ``1 + fullness``.\n    lookahead_alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202f\u03b1\u202f\u2264\u202f1).\n    exact_fit_bonus : float, default 0.15\n        Small additive bonus for bins that fit the item exactly.\n    jitter : float, default 1e-7\n        Amplitude of tiny random noise for tie\u2011breaking.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible jitter.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (0\u2011based). Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Normalise inputs\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 2. Determine bin capacity if not supplied\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # Estimate capacity from the largest observed remaining capacity.\n        bin_capacity = float(np.max(bins) + item + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    if bin_capacity <= 0.0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # 3. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 4. Slack after placement and derived quantities\n    # ------------------------------------------------------------------\n    slack = bins - item                     # \u22650 for feasible bins\n    norm_gap = np.clip(slack / bin_capacity, 0.0, 1.0)      # normalised slack \u2208[0,1]\n\n    # Fullness before placement (used capacity / total capacity)\n    fullness = np.clip((bin_capacity - bins) / bin_capacity, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # 5. Dynamic sigmoid steepness\n    # ------------------------------------------------------------------\n    k = base_steepness * (1.0 + fullness)   # steeper for already\u2011full bins\n\n    # ------------------------------------------------------------------\n    # 6. Sigmoid score (monotonically decreasing with slack)\n    # ------------------------------------------------------------------\n    # Using an inflection point at norm_gap = 0.5.\n    exponent = k * (0.5 - norm_gap)        # larger \u2192 tighter fit\n    exponent = np.clip(exponent, -700.0, 700.0)  # safe for exp()\n    scores = 1.0 / (1.0 + np.exp(-exponent))\n\n    # ------------------------------------------------------------------\n    # 7. Exact\u2011fit bonus\n    # ------------------------------------------------------------------\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    scores[exact_fit_mask] += exact_fit_bonus\n\n    # ------------------------------------------------------------------\n    # 8. Look\u2011ahead boost (optional)\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float).ravel()\n        if lookahead.size > 0:\n            # Remaining capacity after placing the current item (only for feasible bins)\n            remaining_after = slack[feasible]   # \u22650\n            # Count how many look\u2011ahead items could still fit into each bin\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / lookahead.size  # \u2208[0,1]\n            boost = 1.0 + np.clip(lookahead_alpha, 0.0, 1.0) * fit_ratio\n            scores[feasible] *= boost\n\n    # ------------------------------------------------------------------\n    # 9. Tiny jitter for deterministic tie\u2011breaking\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    jitter_noise = rng.uniform(0.0, jitter, size=np.count_nonzero(feasible))\n    scores[feasible,] = scores[feasible] + jitter_noise  # type: ignore\n\n    # ------------------------------------------------------------------\n    # 10. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores[feasible]\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 48.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n    jitter: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If ``None`` the maximum remaining\n        capacity observed in ``bins_remain_cap`` is used.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can still accommodate more of\n        these items after the current placement receive a modest\n        multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the adaptive sigmoid.  The steepness is\n        scaled by bin fullness so fuller bins get a steeper curve.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for a tiny random tie\u2011breaking noise.\n    jitter : float, default 1e-6\n        Magnitude of deterministic tie\u2011breaker (lower\u2011index bins get a tiny\n        advantage).  Also used as the upper bound for random noise.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible\n        bins (remaining capacity < ``item``) receive ``-np.inf`` and are\n        never selected.\n\n    Notes\n    -----\n    The score for each feasible bin is based on:\n      1. Normalised slack after placing the item.\n      2. An adaptive sigmoid that steepens with bin fullness.\n      3. A multiplicative look\u2011ahead boost if ``lookahead_items`` are\n         provided.\n      4. Tiny deterministic and random tie\u2011breakers to resolve exact\n         ties reproducibly.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    if bin_capacity is None:\n        # Use the maximum remaining capacity observed as the nominal bin size.\n        bin_capacity = float(np.max(bins)) + 1e-9\n\n    # Feasibility mask\n    feasible = bins >= item\n    if not np.any(feasible):\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # Slack after placement for feasible bins\n    slack = bins[feasible] - item  # shape (m,)\n    # Normalised gaps (0 when tight fit, 1 when fully slack)\n    norm_gaps = slack / bin_capacity\n    norm_gaps = np.clip(norm_gaps, 0.0, 1.0)\n\n    # Bin fullness relative to capacity (0 empty, 1 full)\n    fullness = (bin_capacity - bins[feasible]) / bin_capacity\n    fullness = np.clip(fullness, 0.0, 1.0)\n\n    # Adaptive sigmoid steepness: fuller bins get steeper curves\n    k = k_base * (1.0 + fullness)\n\n    # Shift gaps so that tighter fits get higher values\n    max_norm_gap = np.max(norm_gaps)\n    shift = max_norm_gap - norm_gaps\n    exponent = k * shift\n    exponent = np.clip(exponent, -700.0, 700.0)  # avoid overflow\n\n    # Adaptive sigmoid scoring in (0.5, 1]\n    scores = 1.0 / (1.0 + np.exp(-exponent))\n\n    # Optional look\u2011ahead boost\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n        if lookahead.size > 0:\n            # Remaining capacity after placement for each feasible bin\n            remaining = slack  # shape (m,)\n            # Count how many lookahead items each bin can still fit\n            fits = (remaining[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0,1]\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores *= boost\n\n    # Tiny random tie\u2011breaker\n    rng = np.random.default_rng(random_state)\n    noise = rng.uniform(0.0, jitter, size=scores.shape)\n    scores += noise\n\n    # Assemble priority vector\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    # Deterministic tie\u2011breaker (lower index gets a slight advantage)\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 1,
    "obj": 4.11846828879138,
    "SLOC": 46.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_exponent_k: float = 12.0,\n    next_item_bonus: float = 0.05,\n    jitter: float = 1e-12,\n    exact_fit_atol: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each open bin in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item \u2264 bin capacity).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently opened bins.\n    exact_fit_bonus : float, optional\n        Large additive boost for (near) exact fits.\n    slack_exponent_k : float, optional\n        Controls the steepness of the exponential reward for tight fits.\n    next_item_bonus : float, optional\n        Bonus added if the bin would still be able to accommodate another\n        item of the same size after placing the current one.\n    jitter : float, optional\n        Tiny deterministic tie\u2011breaker (lower\u2011index bins get a minute advantage).\n    exact_fit_atol : float, optional\n        Absolute tolerance for treating a placement as an exact fit.\n    eps : float, optional\n        Small constant to avoid division\u2011by\u2011zero in normalisation.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``). Higher scores indicate\n        more desirable bins. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Early exit if there are no bins\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Feasibility mask: only bins with non\u2011negative slack are candidates\n    feasible = slack >= 0.0\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If nothing fits, return early\n    if not feasible.any():\n        return priorities\n\n    # ----- Base component: prefer tighter fits -----\n    # Negative slack: less waste yields a larger (less negative) value\n    base = -slack[feasible]\n\n    # ----- Normalised slack for exponential reward -----\n    # Normalise by the largest slack among feasible bins (keeps values in [0,1])\n    max_slack = slack[feasible].max()\n    denom = max_slack + eps\n    slack_norm = slack[feasible] / denom\n\n    # Exponential reward: larger when slack_norm is small (tight fit)\n    exp_reward = np.exp(-slack_exponent_k * slack_norm)\n\n    # ----- Anticipation bonus: can still fit another same\u2011size item -----\n    anticipate = np.where(slack[feasible] >= item, next_item_bonus, 0.0)\n\n    # ----- Combine components -----\n    score = base + exp_reward + anticipate\n\n    # ----- Exact\u2011fit boost (within tolerance) -----\n    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)\n    score[exact_fit_mask] += exact_fit_bonus\n\n    # Insert feasible scores back into the full array\n    priorities[feasible] = score\n\n    # ----- Deterministic tie\u2011breaker: lower index gets a minuscule advantage -----\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priorities += tie_breaker\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    exact_fit_bonus: float = 1e5,\n    jitter_eps: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array-like of float\n        Remaining capacities of the current bins.\n    bin_capacity : float, optional\n        The fixed capacity of each bin. If omitted, it is inferred from\n        the current bins, ensuring that the inferred capacity can accommodate\n        the incoming item.\n    lookahead_items : array-like of float, optional\n        Sizes of items that are expected to arrive soon. Bins that can still\n        accommodate more of these items after the current placement receive\n        a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness parameter for the logistic sigmoid; scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (fractional multiplier).\n    exact_fit_bonus : float, default 1e5\n        Large additive bonus for bins that will have zero slack after\n        placement (i.e., an exact fit).\n    jitter_eps : float, default 1e-12\n        Magnitude of the tiny random tie\u2011breaker added to each score.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the tiny random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same length as ``bins_remain_cap``.\n        Feasible bins receive a finite score; infeasible bins receive\n        ``-np.inf`` and will never be selected.\n    \"\"\"\n    # Convert input to a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not provided\n    if bin_capacity is None:\n        max_cap = np.max(caps) if caps.size > 0 else 0.0\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    if bin_capacity <= 0.0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # Feasibility mask\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # Remaining capacity after placing the item (for feasible bins)\n    leftover = caps[feasible] - item\n    gap_norm = leftover / bin_capacity\n\n    # Fullness before placement\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n    k = k_base * (1.0 + fullness)\n\n    # Logistic sigmoid: decreasing in gap_norm\n    arg = k * (gap_norm - 0.5)\n    arg = np.clip(arg, -700.0, 700.0)\n    scores = 1.0 / (1.0 + np.exp(arg))  # in (0,1)\n\n    # Look\u2011ahead boost (multiplicative)\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            fits = (look <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits / float(look.size)\n            scores = scores * (1.0 + alpha * fit_ratio)\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = np.isclose(leftover, 0.0, atol=1e-12)\n    if np.any(exact_fit_mask):\n        scores[exact_fit_mask] += exact_fit_bonus\n\n    # Tiny random tie\u2011breaker\n    rng = np.random.default_rng(random_state)\n    scores += rng.uniform(-jitter_eps, jitter_eps, size=scores.shape)\n\n    # Assemble full priority vector\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 45.0,
    "cyclomatic_complexity": 10.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\n...",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\nImportError: cannot import name 'priority_v2' from 'gpt' (/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\nImportError: cannot import name 'priority_v2' from 'gpt' (/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\nImportError: cannot import name 'priority_v2' from 'gpt' (/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py)\n"
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: float = 1.0,\n    exact_fit_bonus: float = 1e9,\n    slack_weight: float = 1.0,\n    new_bin_penalty: float = 0.2,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority scores for an online Bin Packing decision.\n\n    Each existing bin receives a score that:\n      * rewards exact fits with a large bonus,\n      * penalises remaining slack linearly (smaller slack \u2192 higher score),\n      * breaks ties deterministically in favour of lower\u2011index bins.\n\n    A virtual \"new bin\" is appended as the last entry; opening a new bin\n    incurs an additional penalty (controlled by ``new_bin_penalty``).  Infeasible\n    bins receive ``-np.inf`` and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of already opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of every bin (default 1.0).  Must be positive.\n    exact_fit_bonus : float, optional\n        Large bonus added when a placement would fill a bin exactly.\n    slack_weight : float, optional\n        Linear weight for the normalized slack (waste).  Larger values increase\n        the penalty for waste.\n    new_bin_penalty : float, optional\n        Multiplicative factor applied to the waste of a newly opened bin.\n    epsilon : float, optional\n        Tiny deterministic tie\u2011breaker magnitude.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores with shape ``(len(bins_remain_cap) + 1,)``.  The last\n        element corresponds to the virtual new bin.\n    \"\"\"\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # Ensure a 1\u2011D NumPy array of floats\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # ---------- Existing bins ----------\n    waste = caps - item                     # capacity left after placing the item\n    feasible = waste >= -epsilon            # allow tiny negative due to FP\n\n    # Normalized slack (waste as fraction of bin capacity)\n    slack = np.where(feasible, waste / bin_capacity, np.inf)\n\n    # Base priority: linear penalty on slack (more slack \u2192 lower score)\n    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=epsilon)\n    base_priority = np.where(\n        exact_fit_mask,\n        base_priority + exact_fit_bonus,\n        base_priority,\n    )\n\n    # Deterministic tie\u2011breaker (favor lower indices)\n    tie_breaker = -np.arange(n_bins, dtype=float) * epsilon\n    base_priority += tie_breaker\n\n    # ---------- Virtual new bin ----------\n    waste_new = bin_capacity - item\n    feasible_new = waste_new >= -epsilon\n\n    if feasible_new:\n        slack_new = waste_new / bin_capacity\n        # Apply extra penalty for opening a new bin\n        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)\n\n        # Exact\u2011fit bonus for a perfect new bin\n        if np.isclose(waste_new, 0.0, atol=epsilon):\n            new_bin_priority += exact_fit_bonus\n    else:\n        new_bin_priority = -np.inf\n\n    # Tie\u2011breaker for the virtual bin (placed after all real bins)\n    new_bin_priority += -n_bins * epsilon\n\n    # ---------- Assemble final priority vector ----------\n    priorities = np.append(base_priority, new_bin_priority)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 38.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as `bins_remain_cap`). Higher scores\n        indicate more desirable bins. Infeasible bins receive -inf.\n    \"\"\"\n    # Constants\n    exact_fit_bonus = 1e9   # Large reward for an exact fit\n    slack_decay = 10.0      # Steepness of the exponential slack penalty\n    jitter = 1e-12          # Deterministic tie\u2011breaker magnitude\n    atol = 1e-12            # Tolerance for detecting an exact fit\n\n    # Convert to flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Remaining capacity after placing the item\n    slack = caps - item\n\n    # Feasibility mask (allow tiny negative due to floating point)\n    feasible = slack >= -atol\n\n    # Initialise priorities with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 return early\n        return priority\n\n    # Indices of feasible bins\n    feasible_idx = np.nonzero(feasible)[0]\n    slack_feasible = slack[feasible_idx]\n\n    # Monotonic base score: negative slack (smaller slack \u21d2 higher score)\n    base_score = -slack_feasible\n\n    # Normalised slack for exponential penalty\n    max_slack = np.max(slack_feasible)\n    norm_slack = slack_feasible / (max_slack + atol)\n\n    # Exponential slack penalty (larger slack \u21d2 larger penalty)\n    slack_penalty = np.exp(slack_decay * norm_slack)\n\n    # Combine base and penalty (higher is better)\n    priority[feasible_idx] = base_score - slack_penalty\n\n    # Exact\u2011fit bonus (detect near\u2011zero slack)\n    exact_fit_mask = np.isclose(slack_feasible, 0.0, atol=atol)\n    if np.any(exact_fit_mask):\n        priority[feasible_idx[exact_fit_mask]] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: prefer lower\u2011index bins slightly\n    priority -= np.arange(n_bins, dtype=float) * jitter\n\n    # Reshape to original shape\n    return priority.reshape(bins_remain_cap.shape)",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n__all__ = [\"priority_v2\"]\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    exact_fit_bonus: float = 1e6,\n    jitter_eps: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin. If omitted, it is inferred from the\n        current bins (ensuring it is at least ``item``).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of items that are expected to arrive soon.  Bins that can still\n        accommodate more of these items after the current placement receive a\n        multiplicative boost.\n    k_base = float, default 8.0\n        Base steepness for the exponential decay; scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).\n    exact_fit_bonus : float, default 1e6\n        Large additive bonus for bins that become perfectly full after\n        placing the item (i.e., zero slack).\n    jitter_eps : float, default 1e-12\n        Magnitude of the tiny random tie\u2011breaker added to each score.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same length as ``bins_remain_cap``).  Infeasible bins\n        receive ``-np.inf`` and will never be selected.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Normalise inputs\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 2. Determine bin capacity\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # At least the largest observed capacity; if that is smaller than\n        # the incoming item, enlarge it just enough.\n        max_cap = np.max(caps) if caps.size else 0.0\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    else:\n        bin_capacity = float(bin_capacity)\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # 3. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 4. Compute leftover capacity after placement (feasible bins only)\n    # ------------------------------------------------------------------\n    leftover = caps[feasible] - item               # >= 0\n    gap_norm = leftover / bin_capacity              # in [0, 1]\n\n    # ------------------------------------------------------------------\n    # 5. Dynamic steepness based on pre\u2011placement fullness\n    # ------------------------------------------------------------------\n    fullness_before = (bin_capacity - caps[feasible]) / bin_capacity = bin_capacity - caps[feasible]) / bin_capacity\n    k = k_base * (1.0 + fullness_before)            # larger for fuller bins\n    # Clip to avoid extreme values that could cause overflow/underflow\n    k = np.clip(k, 0.1, 1e3)\n\n    # ------------------------------------------------------------------\n    # 6. Base priority via exponential decay (tight sigmoid analogue)\n    # ------------------------------------------------------------------\n    # Larger leftover => smaller score\n    base_score = np.exp(-k * gap_norm)              # in (0, 1], 1 when gap_norm=0\n\n    # ------------------------------------------------------------------\n    # 7. Look\u2011ahead boost (optional)\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            # Count how many look\u2011ahead items each bin could still fit\n            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(look.size)   # in [0, 1]\n            boost = 1.0 + np.clip(alpha, 0.0, 1.   # Ensure alpha stays bounded\n                               ) * fit_ratio\n            base_score *= boost\n\n    # ------------------------------------------------------------------\n    # 8. Exact\u2011fit bonus\n    # ------------------------------------------------------------------\n    exact_fit_mask = np.isclose(leftover, 0.0, atol=1e-12)\n    if np.any(exact_fit_mask):\n        base_score[exact_fit_mask] += exact_fit_bonus\n\n    # ------------------------------------------------------------------\n    # 9. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    jitter = rng.uniform(0.0, jitter_eps, size=base_score.shape)\n    base_score += jitter\n\n    # ------------------------------------------------------------------\n    # 10. Assemble full priority vector\n    # ------------------------------------------------------------------\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = base_score\n\n    # ------------------------------------------------------------------\n    # 11. Deterministic tie\u2011breaker (optional, ensures reproducibility)\n    # ------------------------------------------------------------------\n    # Subtract a vanishing amount proportional to bin index so that lower\n    # indices win when scores are otherwise identical.\n    priority[feasible] -= np.arange(priority[feasible].size, dtype=float) * (jitter_eps * jitter_eps) # tiny decreasing term\n\n    return priority",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 91\n    fullness_before = (bin_capacity - caps[feasible]) / bin_capacity = bin_capacity - caps[feasible]) / bin_capacity\n                                                                                                    ^\nSyntaxError: unmatched ')'\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 91\n    fullness_before = (bin_capacity - caps[feasible]) / bin_capacity = bin_capacity - caps[feasible]) / bin_capacity\n                                                                                                    ^\nSyntaxError: unmatched ')'\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 91\n    fullness_before = (bin_capacity - caps[feasible]) / bin_capacity = bin_capacity - caps[feasible]) / bin_capacity\n                                                                                                    ^\nSyntaxError: unmatched ')'\n"
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: float = 1.0,\n    exact_fit_bonus: float = 1e9,\n    slack_weight: float = 1.0,\n    new_bin_penalty: float = 0.2,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for an online Bin Packing decision.\n\n    The priority is based on a linear penalty for waste (remaining capacity\n    after placing the item).  An exact fit receives a large bonus.  Opening a\n    new bin is penalised by a small factor to discourage unnecessary bins.\n    A deterministic tie\u2011breaker prefers lower\u2011index bins.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of already opened bins.\n    bin_capacity : float, optional\n        Capacity of every bin (default 1.0).\n    exact_fit_bonus : float, optional\n        Bonus added when the placement exactly fills a bin.\n    slack_weight : float, optional\n        Weight of the linear waste penalty.\n    new_bin_penalty : float, optional\n        Multiplicative penalty applied to the waste of a newly opened bin.\n    epsilon : float, optional\n        Small deterministic tie\u2011breaker value.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores of shape ``(len(bins_remain_cap) + 1,)``.\n        The last element corresponds to opening a new bin.  Infeasible\n        bins receive ``-np.inf``.\n    \"\"\"\n    # Convert input to a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # ---- Existing bins ----\n    waste = caps - item\n    feasible = waste >= -epsilon          # allow tiny negative due to rounding\n\n    # Normalized slack (fraction of bin capacity that will remain)\n    slack = np.where(feasible, waste / bin_capacity, np.inf)\n\n    # Base priority: lower waste is better\n    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)\n\n    # Bonus for exact fits\n    exact_fit_mask = feasible & np.isclose(waste, 0.0, atol=epsilon)\n    base_priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker (favor lower indices)\n    base_priority += -np.arange(n_bins, dtype=float) * epsilon\n\n    # ---- Virtual new bin ----\n    waste_new = bin_capacity - item\n    if waste_new >= -epsilon:\n        slack_new = waste_new / bin_capacity\n        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)\n        if np.isclose(waste_new, 0.0, atol=epsilon):\n            new_bin_priority += exact_fit_bonus\n        # Tie\u2011breaker for the virtual bin (after all real bins)\n        new_bin_priority -= n_bins * epsilon\n    else:\n        new_bin_priority = -np.inf\n\n    # Append the virtual bin priority\n    priorities = np.append(base_priority, new_bin_priority)\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k: float = 10.0,\n    offset: float = 0.5,\n    alpha: float = 0.1,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n    jitter: float = 1e-9,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    The function prefers bins that leave little slack after placing ``item``,\n    while also rewarding bins that can still accommodate future items\n    (``lookahead_items``). Scores are produced by a per\u2011bin adaptive sigmoid\n    on the normalised slack, and a tiny random tie\u2011breaker ensures a\n    deterministic yet unpredictable ordering for equal scores.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacities of the currently open bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin. If omitted, inferred from the maximum\n        observed remaining capacity (ensuring it is at least ``item``).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of items that may arrive soon. Bins that can still fit more of\n        these items after placing ``item`` receive a multiplicative boost.\n    k : float, default 10.0\n        Base steepness of the sigmoid. Larger values give sharper discrimination\n        between tight and loose fits.\n    offset : float, default 0.5\n        Offset for the sigmoid (in normalised slack units). A value of 0.5 yields\n        a moderate score when half the bin is left.\n    alpha : float, default 0.1\n        Strength of the look\u2011ahead boost (as a fraction of the base score).\n        Must be in [0, 1].\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the tiny random tie\u2011breaker.\n    jitter : float, default 1e-9\n        Deterministic tie\u2011breaker magnitude (lower\u2011index bins get a tiny advantage).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape matches ``bins_remain_cap``);\n        infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Normalise inputs\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 2. Infer bin capacity if not supplied\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # Use the largest observed remaining capacity as a proxy,\n        # but ensure it can accommodate the current item.\n        max_cap = caps.max() if n_bins > 0 else 0.0\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # 3. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full(n_bins, -np.inf, dtype=float 0)  # type: ignore\n\n    # ------------------------------------------------------------------\n    # 4. Slack and normalised slack after placement (feasible bins only)\n    # ------------------------------------------------------------------\n    leftover = caps[feasible] - item          # >= 0\n    slack_norm = leftover / bin_capacity      # in [0, 1]\n\n    # ------------------------------------------------------------------\n    # 5. Adaptive sigmoid steepness based on current fullness\n    # ------------------------------------------------------------------\n    # Fullness before placement (fraction already used)\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n    # Ensure fullness is within [0, 1]\n    fullness = np.clip(fullness, 0.0, 1.0)\n    k_i = k * (1.0 + fullness)                # sharper for already fuller bins\n\n    # ------------------------------------------------------------------\n    # 6. Compute sigmoid scores\n    # ------------------------------------------------------------------\n    # Argument: positive when slack_norm < offset (tight fit)\n    arg = k_i * (offset - slack_norm)\n    # Clip to avoid overflow/underflow in exp\n    arg = np.clip(arg, -700.0, 700.0)\n    scores = 1.0 / (1.0 + np.exp(-np.inf if False else -arg))  # logistic sigmoid\n\n    # ------------------------------------------------------------------\n    # 7. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    # Scale noise relative to magnitude of scores to keep it truly tiny\n    eps = 1e-12 * max(1.0, np.max(np.abs(scores)))\n    scores += rng.uniform(0.0, eps, size=scores.shape)\n\n    # ------------------------------------------------------------------\n    # 8. Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            # Count how many look\u2011ahead items could still fit in each bin\n            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(look.size)  # in [0, 1]\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores = np.minimum(scores * boost, 1.0)\n\n    # ------------------------------------------------------------------\n    # 9. Assemble full (including infeasible) priority vector\n    # ------------------------------------------------------------------\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    # ------------------------------------------------------------------\n    # 10. Deterministic tie\u2011breaker (optional but useful)\n    # ------------------------------------------------------------------\n    # Slightly penalise higher\u2011index bins to break exact ties.\n    priority[feasible] -= np.arange(scores.size, dtype=float) * jitter\n\n    return priority",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 87\n    return np.full(n_bins, -np.inf, dtype=float 0)  # type: ignore\n                                          ^^^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 87\n    return np.full(n_bins, -np.inf, dtype=float 0)  # type: ignore\n                                          ^^^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 87\n    return np.full(n_bins, -np.inf, dtype=float 0)  # type: ignore\n                                          ^^^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\n"
  }
]