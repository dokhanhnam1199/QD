{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Random-fit priority score, selecting uniformly at random among bins that can\n    accommodate the incoming item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item to be packed.\n    bins_remain_cap : np.ndarray\n        1-D array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    priorities : np.ndarray\n        Array of the same shape as ``bins_remain_cap``.  Feasible bins (those with\n        remaining capacity >= ``item``) receive a uniform random priority in\n        the range [0, 1).  Infeasible bins are given a sentinel value of\n        ``-np.inf`` so they are never chosen when the algorithm selects the\n        bin with the highest priority.\n    \"\"\"\n    # Find bins that can accommodate the item\n    feasible_mask = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    # Assign random priorities only to feasible bins\n    if feasible_mask.any():\n        # Uniform random numbers in [0, 1) for the feasible bins\n        priorities[feasible_mask] = np.random.rand(feasible_mask.sum())\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Sigmoid Fit Score for online Bin Packing.\n\n    Computes a priority score for each bin such that bins leaving a\n    small positive residual after packing the given `item` obtain the\n    highest scores.  Bins that cannot accommodate the item receive\n    a large negative penalty.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be packed.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin (1\u2011D array).\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as `bins_remain_cap` containing priority\n        scores; the bin with the maximum score is chosen.\n    \"\"\"\n    # Calculate the leftover capacity after placing the item\n    gaps = bins_remain_cap - item\n\n    # Parameter controlling the sharpness of the sigmoid curve.\n    # Larger values yield stronger preference for very small gaps.\n    k = 8.0\n\n    # Assign a very low score for bins that cannot hold the item.\n    NEG_INF = -1e10\n\n    # Compute the sigmoid over the gaps for bins that can accommodate the item.\n    priorities = np.where(\n        gaps >= 0,\n        1.0 / (1.0 + np.exp(k * gaps)),   # Higher when gaps are small\n        NEG_INF                           # Impossible fits get minimal priority\n    )\n\n    return priorities\n\n[Reflection]\nAdjust sigmoid\u202fk to reflect bin fullness, normalize gaps, add tie\u2011breaking randomness, and consider lookahead item sizes.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}