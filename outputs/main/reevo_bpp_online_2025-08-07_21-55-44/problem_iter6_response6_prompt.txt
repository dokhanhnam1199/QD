{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute dynamic priority scores for bins in an online Bin Packing Problem.\n\n    The priority blends best\u2011fit (tight leftover) and worst\u2011fit (large leftover)\n    using a data\u2011driven weight \u03b1 that adapts to the current distribution of\n    leftovers.  A linear waste penalty is subtracted, and a temperature\n    scaling smooths the scores.  A tiny negative tie\u2011breaker based on the\n    bin index resolves exact ties.  Feasible bins that cannot accommodate the\n    item receive -inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure numeric array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n\n    # If no feasible bin, return -inf for all\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item is placed\n    leftover = caps[feasible] - item  # >= 0\n\n    # ----- Dynamic alpha based on leftover distribution -----\n    max_leftover = np.max(leftover)\n    if max_leftover > 0:\n        mean_leftover = np.mean(leftover)\n        alpha = np.clip(mean_leftover / max_leftover, 0.0, 1.0)\n    else:\n        # All feasible bins are exact fits\n        alpha = 0.5\n\n    # ----- Normalize leftover to [0,1] for stable scoring -----\n    if max_leftover > 0:\n        leftover_norm = leftover / max_leftover\n    else:\n        leftover_norm = leftover  # all zeros\n\n    # ----- Best\u2011fit and worst\u2011fit components -----\n    best_score = -leftover_norm   # tighter fit \u2192 higher\n    worst_score = leftover_norm   # larger leftover \u2192 higher\n\n    # ----- Linear blend -----\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # ----- Waste penalty -----\n    base_penalty = 0.1\n    penalty_factor = base_penalty * np.mean(leftover_norm)\n    combined -= penalty_factor * leftover_norm\n\n    # ----- Temperature scaling -----\n    std_norm = np.std(leftover_norm)\n    temperature = 1.0 + std_norm  # higher variation \u2192 smoother scores\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # ----- Tie\u2011breaker based on bin index (avoid fixed epsilon) -----\n    idx = np.arange(caps.size, dtype=float)\n    epsilon = 1e-6 * (np.max(np.abs(combined)) + 1e-12)\n    tie_break = -epsilon * idx\n\n    # ----- Assemble final scores -----\n    full_scores = np.full_like(caps, -np.inf, dtype=float)\n    full_scores[feasible] = combined + tie_break[feasible]\n\n    return full_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    The priority incorporates:\n      * Massive bonus for exact fits.\n      * Quadratic penalty on leftover capacity (discourages large fragments).\n      * Tiny index\u2011based epsilon tie\u2011breaker for deterministic selection.\n      * Infeasible bins are assigned ``-np.inf``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better).  The caller should pick\n        the bin with the maximal score.\n    \"\"\"\n    # Convert to a float array for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    n_bins = caps.shape[0]\n\n    # Initialise all scores as -inf (infeasible)\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return scores\n\n    # Leftover capacity after placing the item\n    leftover = caps - item\n\n    # Quadratic penalty on leftover (smaller leftover => larger priority)\n    # \u03b1 controls the strength of the quadratic term\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Tiny epsilon tie\u2011breaker weighted by bin index (earlier bins preferred)\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    scores[feasible] = base_priority[feasible]\n\n    # Exact\u2011fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e12  # sufficiently large to dominate any other term\n        scores[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return scores\n\n[Reflection]\nUse exact\u2011fit bonuses, quadratic leftover penalties, adaptive weighting, and tiny index tie\u2011breakers for deterministic selection.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}