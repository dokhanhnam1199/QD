{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    beta: float = 10.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    The priority is based on a normalized residual capacity after placing the\n    item, transformed through a steep sigmoid so that bins with a tight fit\n    obtain a high score while bins with large leftover capacity obtain a low\n    score. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` to guarantee they are never selected, unless the optional\n    ``epsilon``\u2011greedy exploration is active.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for the existing bins.\n    beta : float, optional\n        Steepness of the sigmoid; larger values increase the contrast between\n        tight and loose fits. Must be non\u2011negative.\n    epsilon : float, optional\n        Exploration probability (0 \u2264 epsilon \u2264 1). With probability ``epsilon``\n        the function returns random scores for feasible bins to encourage\n        exploration of sub\u2011optimal placements.\n    rng : np.random.Generator | None, optional\n        Random number generator for reproducibility. If ``None``, a fresh\n        default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape ``bins_remain_cap.shape``). Higher\n        values indicate a more desirable placement.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    # Ensure input is a 1\u2011D float array\n    remain = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = remain.size\n\n    # Empty case \u2013 nothing to score\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialise all priorities as -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible_mask = remain >= item\n    n_feasible = feasible_mask.sum()\n    if n_feasible == 0:\n        # No bin can accommodate the item; return all -inf\n        return priorities\n\n    # Exploration vs exploitation\n    explore = rng.random() < epsilon\n\n    if explore:\n        # Random uniform scores for exploration\n        raw_scores = rng.random(n_feasible)\n    else:\n        # Residual capacity after placing the item\n        residual = remain[feasible_mask] - item\n\n        # Normalise residuals to [0, 1] using the maximum residual as scale.\n        scale = residual.max()\n        scale = scale if scale > 0 else 1.0  # avoid division by zero\n        normalized = residual / scale\n\n        # Sigmoid transform: higher priority for smaller residuals.\n        # Numerically stable: exponent \u2208 [-beta, 0]\n        exp_term = np.exp(-beta * normalized)\n        raw_scores = 1.0 / (1.0 + exp_term)\n\n    # Tiny jitter to break ties deterministically\n    jitter = rng.random(n_feasible) * 1e-9\n    raw_scores = raw_scores + jitter\n\n    # Populate the priority array\n    priorities[feasible_mask] = raw_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute priority scores for each bin for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1-D array of remaining capacities of existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Higher score indicates more desirable bin.\n        Bins that cannot accommodate the item receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.shape[0]\n\n    # Default score for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Compute leftover after placing the item\n    leftover = caps - item\n\n    # Feasible bins\n    feasible = leftover >= 0\n\n    if not feasible.any():\n        # No bin can accommodate the item\n        return priorities\n\n    # Base priority: penalize leftover, weighted by item size\n    # Larger items see a stronger penalty for the same leftover\n    priorities[feasible] = -leftover[feasible] * item\n\n    # Exact fits get a massive bonus\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)\n    if exact_fit.any():\n        # Use a value large enough to dominate any other feasible bin\n        EXACT_FIT_BONUS = 1e12\n        priorities[exact_fit] = EXACT_FIT_BONUS\n\n    # Tie\u2011break by lower index: subtract a tiny epsilon proportional to the index\n    epsilon = 1e-6\n    priorities -= epsilon * np.arange(n_bins)\n\n    return priorities\n\n[Reflection]\nPrefer linear residual penalty, reward exact fits, avoid heavy sigmoid transforms, add tiny deterministic tie\u2011breaker, keep O(n) cost.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}