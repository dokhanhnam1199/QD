{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n    jitter: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin. If ``None`` the maximum remaining capacity\n        observed in ``bins_remain_cap`` is used.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can still accommodate more of these\n        items after the current placement receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the adaptive sigmoid.  The steepness is scaled by\n        bin fullness so fuller bins get a steeper curve.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for a tiny random tie\u2011breaking noise.\n    jitter : float, default 1e-6\n        Deterministic tie\u2011breaker magnitude (lower\u2011index bins get a tiny\n        advantage).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf`` and are never\n        selected.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Prepare inputs\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not provided\n    if bin_capacity is None:\n        bin_capacity = float(np.max(bins) + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    # ------------------------------------------------------------------\n    # 2. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 3. Compute gaps and normalized gaps\n    # ------------------------------------------------------------------\n    slack = bins - item  # remaining capacity after placing the item\n    norm_gaps = slack / bin_capacity  # [0,1] (or slightly >1 for overflow)\n    norm_gaps = np.clip(norm_gaps, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # 4. Dynamic sigmoid steepness based on bin fullness\n    # ------------------------------------------------------------------\n    fullness = (bin_capacity - bins) / bin_capacity  # [0,1]\n    fullness = np.clip(fullness, 0.0, 1.0)\n    k = k_base * (1.0 + fullness)  # steeper for fuller bins\n\n    # ------------------------------------------------------------------\n    # 5. Adaptive sigmoid on normalized gaps\n    # ------------------------------------------------------------------\n    # Shift gaps so that the smallest gap gets the highest score\n    feasible_gaps = norm_gaps[feasible]\n    feasible_k = k[feasible]\n    max_norm_gap = np.max(feasible_gaps)\n    shift = max_norm_gap - feasible_gaps  # larger for tighter fits\n    exponent = feasible_k * shift\n    exponent = np.clip(exponent, -700.0, 700.0)  # avoid overflow\n    scores = 1.0 / (1.0 + np.exp(-exponent))  # in (0.5, 1]\n\n    # ------------------------------------------------------------------\n    # 6. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    noise = rng.uniform(0.0, 1e-6, size=scores.shape)\n    scores += noise\n\n    # ------------------------------------------------------------------\n    # 7. Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n        if lookahead.size > 0:\n            remaining_after = slack[feasible]  # capacity left after placement\n            # Count how many lookahead items each bin can still fit\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)  # [0,1]\n            # Apply multiplicative boost\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores *= boost\n\n    # ------------------------------------------------------------------\n    # 8. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    # ------------------------------------------------------------------\n    # 9. Deterministic tie\u2011breaker\n    # ------------------------------------------------------------------\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k: float = 10.0,\n    offset: float = 0.5,\n    alpha: float = 0.1,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    The function prefers bins that leave little slack after placing ``item``,\n    while also rewarding bins that can still accommodate future items\n    (``lookahead_items``). Scores are produced by a per\u2011bin sigmoid on the\n    normalised slack, avoiding large fixed bonuses. A tiny random tie\u2011breaker\n    ensures deterministic but unpredictable ordering for equal scores.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacities of the currently open bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin. If omitted, inferred from the maximum\n        observed remaining capacity (ensuring it is at least ``item``).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of items that may arrive soon. Bins that can still fit more of\n        these items after placing ``item`` receive a multiplicative boost.\n    k : float, default 10.0\n        Base steepness of the sigmoid. Larger values give sharper\n        discrimination between small and large slack.\n    offset : float, default 0.5\n        Offset for the sigmoid (in normalised slack units). A value of 0.5\n        yields a moderate score when half the bin is left.\n    alpha : float, default 0.1\n        Strength of the look\u2011ahead boost (as a fraction of the base score).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the tiny random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape matches ``bins_remain_cap``);\n        infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise inputs\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Infer bin capacity if not supplied\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        # Use the maximum observed remaining capacity as a proxy.\n        # Ensure the capacity can accommodate the current item.\n        max_cap = np.max(caps) if n_bins > 0 else 0.0\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No bin can hold the item\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Slack and normalised slack after placement (feasible bins only)\n    # ------------------------------------------------------------------\n    leftover = caps[feasible] - item                     # >= 0\n    slack_norm = leftover / bin_capacity                 # in [0, 1]\n\n    # ------------------------------------------------------------------\n    # Per\u2011bin sigmoid steepness based on current fullness\n    # ------------------------------------------------------------------\n    # Fullness before placement (fraction already used)\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n    k_i = k * (1.0 + fullness)  # sharper for bins that are already fuller\n\n    # Sigmoid argument: positive when slack_norm < offset (i.e., small slack)\n    arg = k_i * (offset - slack_norm)\n    # Clip to avoid overflow in exp\n    arg = np.clip(arg, -700.0, 700.0)\n\n    # Logistic sigmoid maps arg -> score in (0, 1)\n    scores = 1.0 / (1.0 + np.exp(-arg))\n\n    # ------------------------------------------------------------------\n    # Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    eps = 1e-12 * max(1.0, np.max(np.abs(scores)))\n    scores += rng.uniform(0.0, eps, size=scores.shape)\n\n    # ------------------------------------------------------------------\n    # Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        look = np.asarray(lookahead_items, dtype=float).ravel()\n        if look.size > 0:\n            # For each bin, count how many look\u2011ahead items could still fit\n            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)\n            fit_ratio = fits / float(look.size)          # in [0, 1]\n            # Multiplicative boost, clipped to keep scores \u2264 1\n            scores = np.minimum(scores * (1.0 + alpha * fit_ratio), 1.0)\n\n    # ------------------------------------------------------------------\n    # Assemble full priority vector\n    # ------------------------------------------------------------------\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority\n\n[Reflection]\nNormalize slack, use adaptive sigmoid scaled by fullness, offset for balanced fit, proportional look\u2011ahead boost, tiny random tie\u2011breaker.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}