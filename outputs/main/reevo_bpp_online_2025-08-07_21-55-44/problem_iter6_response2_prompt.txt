{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute dynamic priority scores for bins in an online Bin Packing Problem.\n\n    The priority blends best\u2011fit (tight leftover) and worst\u2011fit (large leftover)\n    using a data\u2011driven weight \u03b1 that adapts to the current distribution of\n    leftovers.  A linear waste penalty is subtracted, and a temperature\n    scaling smooths the scores.  A tiny negative tie\u2011breaker based on the\n    bin index resolves exact ties.  Feasible bins that cannot accommodate the\n    item receive -inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure numeric array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n\n    # If no feasible bin, return -inf for all\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item is placed\n    leftover = caps[feasible] - item  # >= 0\n\n    # ----- Dynamic alpha based on leftover distribution -----\n    max_leftover = np.max(leftover)\n    if max_leftover > 0:\n        mean_leftover = np.mean(leftover)\n        alpha = np.clip(mean_leftover / max_leftover, 0.0, 1.0)\n    else:\n        # All feasible bins are exact fits\n        alpha = 0.5\n\n    # ----- Normalize leftover to [0,1] for stable scoring -----\n    if max_leftover > 0:\n        leftover_norm = leftover / max_leftover\n    else:\n        leftover_norm = leftover  # all zeros\n\n    # ----- Best\u2011fit and worst\u2011fit components -----\n    best_score = -leftover_norm   # tighter fit \u2192 higher\n    worst_score = leftover_norm   # larger leftover \u2192 higher\n\n    # ----- Linear blend -----\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # ----- Waste penalty -----\n    base_penalty = 0.1\n    penalty_factor = base_penalty * np.mean(leftover_norm)\n    combined -= penalty_factor * leftover_norm\n\n    # ----- Temperature scaling -----\n    std_norm = np.std(leftover_norm)\n    temperature = 1.0 + std_norm  # higher variation \u2192 smoother scores\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # ----- Tie\u2011breaker based on bin index (avoid fixed epsilon) -----\n    idx = np.arange(caps.size, dtype=float)\n    epsilon = 1e-6 * (np.max(np.abs(combined)) + 1e-12)\n    tie_break = -epsilon * idx\n\n    # ----- Assemble final scores -----\n    full_scores = np.full_like(caps, -np.inf, dtype=float)\n    full_scores[feasible] = combined + tie_break[feasible]\n\n    return full_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_exponent_k: float = 12.0,\n    next_item_bonus: float = 0.05,\n    jitter: float = 1e-12,\n    exact_fit_atol: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    For a given incoming ``item`` the function returns a score for each currently\n    opened bin.  Higher scores indicate a more desirable bin for placement.\n\n    Heuristics incorporated:\n    \u2022 **Exact\u2011fit bonus** \u2013 a huge boost when the item fills a bin almost\n      perfectly.\n    \u2022 **Slack penalty** \u2013 bins with larger residual capacity after placement are\n      penalised via an exponential term.\n    \u2022 **Anticipation bonus** \u2013 a small extra reward if the bin would still have\n      enough room for another item of the same size after the placement.\n    \u2022 **Deterministic jitter** \u2013 a tiny index\u2011based term to break ties in a\n      reproducible way.\n    \u2022 **Infeasibility handling** \u2013 bins that cannot accommodate the item receive\n      ``-np.inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each opened bin.\n    exact_fit_bonus : float, optional\n        Large constant added when the item exactly fits a bin (default 1e6).\n    slack_exponent_k : float, optional\n        Controls steepness of the exponential slack penalty (default 12.0).\n    next_item_bonus : float, optional\n        Small bonus for bins that would still accommodate another item of the\n        same size after placement (default 0.05).\n    jitter : float, optional\n        Magnitude of deterministic tie\u2011breaker based on bin index (default\n        1e-12).\n    exact_fit_atol : float, optional\n        Absolute tolerance for treating a placement as an exact fit (default\n        1e-12).\n    eps : float, optional\n        Small constant to avoid division\u2011by\u2011zero when normalising slack\n        (default 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  The caller should\n        select the bin with the maximum priority.\n    \"\"\"\n    # Ensure a flat float array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins_remain_cap.size\n\n    # Edge case: no bins at all\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Compute slack (remaining capacity) if the item were placed\n    slack = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative slack can hold the item\n    feasible = slack >= 0.0\n\n    # Initialise priorities with -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If there are no feasible bins, return early\n    if not feasible.any():\n        return priorities\n\n    # Base priority: negative slack (higher for tighter fits)\n    base_priority = -slack[feasible]\n\n    # Normalise slack for the exponential term\n    max_slack = slack[feasible].max()\n    denom = max_slack + eps          # avoid division by zero\n    norm_slack = slack[feasible] / denom\n\n    # Exponential slack bonus: larger for smaller slack\n    slack_bonus = np.exp(-slack_exponent_k * norm_slack)\n\n    # Anticipation bonus: bin still fits another item of the same size\n    anticipate_bonus = np.where(slack[feasible] >= item, next_item_bonus, 0.0)\n\n    # Combine components for feasible bins\n    priority_feasible = base_priority + slack_bonus + anticipate_bonus\n\n    # Exact\u2011fit boost (within tolerance)\n    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)\n    priority_feasible[exact_fit_mask] += exact_fit_bonus\n\n    # Insert feasible priorities back into full array\n    priorities[feasible] = priority_feasible\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins ever so slightly\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priorities += tie_breaker\n\n    return priorities\n\n[Reflection]\nPrioritize exact fits, penalize slack exponentially, add small anticipation bonus, use deterministic tie\u2011breaker, keep calculations simple.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}