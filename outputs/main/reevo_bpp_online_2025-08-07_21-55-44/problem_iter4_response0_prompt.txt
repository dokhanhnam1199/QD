{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    beta: float = 10.0,\n    epsilon: float = 0.0,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    The priority is based on a normalized residual capacity after placing the\n    item, transformed through a steep sigmoid so that bins with a tight fit\n    obtain a high score while bins with large leftover capacity obtain a low\n    score. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` to guarantee they are never selected, unless the optional\n    ``epsilon``\u2011greedy exploration is active.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for the existing bins.\n    beta : float, optional\n        Steepness of the sigmoid; larger values increase the contrast between\n        tight and loose fits. Must be non\u2011negative.\n    epsilon : float, optional\n        Exploration probability (0 \u2264 epsilon \u2264 1). With probability ``epsilon``\n        the function returns random scores for feasible bins to encourage\n        exploration of sub\u2011optimal placements.\n    rng : np.random.Generator | None, optional\n        Random number generator for reproducibility. If ``None``, a fresh\n        default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (shape ``bins_remain_cap.shape``). Higher\n        values indicate a more desirable placement.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    # Ensure input is a 1\u2011D float array\n    remain = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = remain.size\n\n    # Empty case \u2013 nothing to score\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Initialise all priorities as -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Identify feasible bins\n    feasible_mask = remain >= item\n    n_feasible = feasible_mask.sum()\n    if n_feasible == 0:\n        # No bin can accommodate the item; return all -inf\n        return priorities\n\n    # Exploration vs exploitation\n    explore = rng.random() < epsilon\n\n    if explore:\n        # Random uniform scores for exploration\n        raw_scores = rng.random(n_feasible)\n    else:\n        # Residual capacity after placing the item\n        residual = remain[feasible_mask] - item\n\n        # Normalise residuals to [0, 1] using the maximum residual as scale.\n        scale = residual.max()\n        scale = scale if scale > 0 else 1.0  # avoid division by zero\n        normalized = residual / scale\n\n        # Sigmoid transform: higher priority for smaller residuals.\n        # Numerically stable: exponent \u2208 [-beta, 0]\n        exp_term = np.exp(-beta * normalized)\n        raw_scores = 1.0 / (1.0 + exp_term)\n\n    # Tiny jitter to break ties deterministically\n    jitter = rng.random(n_feasible) * 1e-9\n    raw_scores = raw_scores + jitter\n\n    # Populate the priority array\n    priorities[feasible_mask] = raw_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute deterministic priority scores for online bin packing.\n\n    The priority reflects:\n      * exact fits receive a massive bonus,\n      * among feasible bins, the smaller the leftover after placing the item,\n        the higher the priority,\n      * a tiny index\u2011based epsilon breaks ties deterministically,\n      * a quadratic penalty on leftover discourages creating large fragments,\n        which helps anticipate future items.\n\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more desirable).  The caller should select the\n        bin with the maximal score.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.shape[0]\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return priorities\n\n    # Compute leftover capacity after placing the item\n    leftover = caps - item\n\n    # Base priority: negative leftover (smaller leftover => larger priority)\n    # plus a quadratic penalty to heavily discourage large leftovers.\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Deterministic tie\u2011breaker: small epsilon weighted by bin index\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    priorities[feasible] = base_priority[feasible]\n\n    # Exact fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e9\n        # Override priority for exact fits (including tie\u2011breaker)\n        priorities[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return priorities\n\n[Reflection]\nPrioritize deterministic scores, huge exact\u2011fit bonus, quadratic leftover penalty, tiny index\u2011based tie\u2011breaker; avoid random jitter.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}