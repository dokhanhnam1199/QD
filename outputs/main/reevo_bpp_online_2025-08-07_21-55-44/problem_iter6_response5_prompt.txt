{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute dynamic priority scores for bins in an online Bin Packing Problem.\n\n    The priority blends best\u2011fit (tight leftover) and worst\u2011fit (large leftover)\n    using a data\u2011driven weight \u03b1 that adapts to the current distribution of\n    leftovers.  A linear waste penalty is subtracted, and a temperature\n    scaling smooths the scores.  A tiny negative tie\u2011breaker based on the\n    bin index resolves exact ties.  Feasible bins that cannot accommodate the\n    item receive -inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure numeric array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n\n    # If no feasible bin, return -inf for all\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item is placed\n    leftover = caps[feasible] - item  # >= 0\n\n    # ----- Dynamic alpha based on leftover distribution -----\n    max_leftover = np.max(leftover)\n    if max_leftover > 0:\n        mean_leftover = np.mean(leftover)\n        alpha = np.clip(mean_leftover / max_leftover, 0.0, 1.0)\n    else:\n        # All feasible bins are exact fits\n        alpha = 0.5\n\n    # ----- Normalize leftover to [0,1] for stable scoring -----\n    if max_leftover > 0:\n        leftover_norm = leftover / max_leftover\n    else:\n        leftover_norm = leftover  # all zeros\n\n    # ----- Best\u2011fit and worst\u2011fit components -----\n    best_score = -leftover_norm   # tighter fit \u2192 higher\n    worst_score = leftover_norm   # larger leftover \u2192 higher\n\n    # ----- Linear blend -----\n    combined = (1.0 - alpha) * best_score + alpha * worst_score\n\n    # ----- Waste penalty -----\n    base_penalty = 0.1\n    penalty_factor = base_penalty * np.mean(leftover_norm)\n    combined -= penalty_factor * leftover_norm\n\n    # ----- Temperature scaling -----\n    std_norm = np.std(leftover_norm)\n    temperature = 1.0 + std_norm  # higher variation \u2192 smoother scores\n    if temperature <= 0.0:\n        temperature = 1e-8\n    combined /= temperature\n\n    # ----- Tie\u2011breaker based on bin index (avoid fixed epsilon) -----\n    idx = np.arange(caps.size, dtype=float)\n    epsilon = 1e-6 * (np.max(np.abs(combined)) + 1e-12)\n    tie_break = -epsilon * idx\n\n    # ----- Assemble final scores -----\n    full_scores = np.full_like(caps, -np.inf, dtype=float)\n    full_scores[feasible] = combined + tie_break[feasible]\n\n    return full_scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                alpha=0.2, k_base=8.0, random_state=None):\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing scenario.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array-like of float\n        Remaining capacity of each existing bin.\n    bin_capacity : float, optional\n        Capacity of each bin. If omitted, it is inferred as max(bins_remain_cap) + item.\n    lookahead_items : array-like of float, optional\n        Sizes of future items that may arrive soon.  Bins that can also accommodate\n        more of these items after the current placement receive a bonus.\n    alpha : float, optional\n        Strength of the look\u2011ahead bonus (default 0.2).\n    k_base : float, optional\n        Base steepness for the sigmoid (default 8.0).  It is dynamically increased\n        for bins that are already fuller.\n    random_state : int or np.random.Generator, optional\n        Seed or RNG for tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with the same shape as ``bins_remain_cap``.\n        Infeasible bins (remaining capacity < item) receive ``-np.inf``.\n    \"\"\"\n    rng = np.random.default_rng(random_state)\n\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    if bin_capacity is None:\n        bin_capacity = float(max(bins.max() + item, 1.0))\n\n    feasible = bins >= item\n    if not feasible.any():\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    gaps = bins - item\n    norm_gaps = gaps / bin_capacity\n    fullness = (bin_capacity - bins) / bin_capacity\n    k = k_base * (1.0 + fullness)\n\n    exponent = k * norm_gaps\n    exponent = np.clip(exponent, -700, 700)\n\n    # Compute sigmoid for feasible bins\n    exp_val = np.exp(exponent[feasible])\n    scores = 1.0 / (1.0 + exp_val)\n\n    # Tiny random noise to break ties deterministically\n    scores += rng.uniform(0.0, 1e-6, size=scores.shape)\n\n    # Optional look\u2011ahead boost\n    if lookahead_items is not None and lookahead_items.size > 0:\n        future_gaps = gaps[feasible][:, None] - np.asarray(lookahead_items, dtype=float)[None, :]\n        fits = (future_gaps >= 0).sum(axis=1)\n        fit_ratio = fits / float(lookahead_items.size)\n        scores *= (1.0 + alpha * fit_ratio)\n\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority\n\n[Reflection]\nUse a monotonic sigmoid on normalized gaps; limit parameters; add tiny random tie\u2011break; include optional look\u2011ahead.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}