[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    alpha: float = 0.2,\n    k_base: float = 8.0,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacities of the existing bins.\n    bin_capacity : float, optional\n        Fixed capacity of each bin. If omitted, inferred from the maximum\n        observed remaining capacity (augmented by ``item`` if needed).\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items that may arrive soon. Bins that can still fit\n        more of these items after placing the current item receive a boost.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (multiplicative factor).\n    k_base : float, default 8.0\n        Base steepness for the sigmoid; scaled by each bin\u2019s fullness.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for the tiny random tie\u2011breaker.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise inputs\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Infer bin capacity if not supplied\n    # ------------------------------------------------------------------\n    if bin_capacity is None:\n        max_cap = np.max(caps)\n        # Ensure the inferred capacity can hold the current item\n        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)\n    if bin_capacity <= 0:\n        raise ValueError(\"bin_capacity must be positive.\")\n\n    # ------------------------------------------------------------------\n    # Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # Compute leftover capacity after placing the item (feasible bins only)\n    # ------------------------------------------------------------------\n    leftover = caps[feasible] - item                # >= 0\n    gap_norm = leftover / bin_capacity               # normalised gap in [0, 1)\n\n    # ------------------------------------------------------------------\n    # Dynamic sigmoid steepness based on bin fullness\n    # ------------------------------------------------------------------\n    # Fullness before placement (fraction already used)\n    fullness = (bin_capacity - caps[feasible]) / bin_capacity\n    k = k_base * (1.0 + fullness)                    # per\u2011bin steepness\n\n    # ------------------------------------------------------------------\n    # Monotonic decreasing sigmoid: high score for small gap_norm\n    # ------------------------------------------------------------------\n    # Shift sigmoid so that gap_norm = 0.5 maps to a moderate score.\n    arg = k * (0.5 - gap_norm)\n    # Clip to avoid overflow in exp\n    arg = np.clip(arg, -700.0, 700.0)\n    scores = 1.0 / (1.0 + np.exp(-arg))\n\n    # ------------------------------------------------------------------\n    # Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    eps = 1e-12 * max(1.0, np.max(np.abs(scores)))\n    scores += rng.uniform(0.0, eps, size=scores.shape)\n\n    # ------------------------------------------------------------------\n    # Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None and len(lookahead_items) > 0:\n        look = np.asarray(lookahead_items, dtype=float)\n        # For each feasible bin, count future items that would still fit\n        fits = (look[None, :] <= leftover[:, None]).sum(axis=1)\n        fit_ratio = fits / float(look.size)        # in [0, 1]\n        # Multiplicative boost (clipped to keep scores bounded)\n        scores = scores * (1.0 + alpha * fit_ratio)\n        scores = np.clip(scores, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # Assemble full priority vector\n    # ------------------------------------------------------------------\n    priority = np.full(n_bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 41.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin\u2011packing setting.\n\n    The priority is based on a simple linear penalty proportional to the\n    leftover capacity after placing the item.  Bins that provide an exact\n    fit receive a large constant bonus.  A tiny deterministic tie\u2011breaker\n    slightly penalises bins with larger indices so that the choice is\n    reproducible.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Higher scores indicate more desirable bins.  Infeasible bins receive\n        ``-np.inf``.\n    \"\"\"\n    shape = np.shape(bins_remain_cap)\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        return priorities.reshape(shape)\n\n    leftover = caps - item\n    feasible = leftover >= 0\n\n    if not np.any(feasible):\n        return priorities.reshape(shape)\n\n    # Linear penalty: larger leftover -> lower priority\n    priorities[feasible] = -leftover[feasible] * item\n\n    # Reward exact fits with a huge bonus\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)\n    if np.any(exact_fit):\n        priorities[exact_fit] = 1e12\n\n    # Deterministic tie\u2011breaker: slightly penalise larger indices\n    TIE_EPS = 1e-6\n    priorities -= TIE_EPS * np.arange(n_bins)\n\n    return priorities.reshape(shape)",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_exponent_k: float = 10.0,\n    next_item_bonus: float = 0.05,\n    jitter: float = 1e-12,\n    exact_fit_atol: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing problem.\n\n    Heuristics (kept simple):\n    \u2022 Exact\u2011fit boost \u2013 a very large constant when the item fills a bin almost\n      perfectly.\n    \u2022 Exponential slack penalty \u2013 tighter fits (smaller slack) receive a higher\n      bonus via exp(-k * normalized_slack).\n    \u2022 Anticipation bonus \u2013 a small extra reward if the bin would still fit another\n      item of the same size after placement.\n    \u2022 Deterministic tie\u2011breaker \u2013 tiny index\u2011based term to make the decision\n      reproducible.\n    \u2022 Infeasible bins receive -inf priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently opened bins.\n    exact_fit_bonus : float, optional\n        Large constant added for (near) exact fits.\n    slack_exponent_k : float, optional\n        Controls steepness of the exponential slack bonus.\n    next_item_bonus : float, optional\n        Bonus if the bin would still hold another item of the same size.\n    jitter : float, optional\n        Tiny magnitude for deterministic tie\u2011breaking.\n    exact_fit_atol : float, optional\n        Absolute tolerance for treating a placement as an exact fit.\n    eps : float, optional\n        Small constant to avoid division\u2011by\u2011zero when normalising slack.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Higher scores are\n        more desirable.\n    \"\"\"\n    # Ensure a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Edge case: no bins at all\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Feasibility mask: slack must be non\u2011negative\n    feasible = slack >= 0.0\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If nothing fits, return early\n    if not feasible.any():\n        return priorities\n\n    # Base priority: tighter fit \u2192 larger (negative slack)\n    base_priority = -slack[feasible]\n\n    # Normalise slack for exponential term (avoid division by zero)\n    max_slack = slack[feasible].max()\n    denom = max_slack + eps\n    slack_norm = slack[feasible] / denom\n\n    # Exponential slack bonus: larger for smaller slack_norm\n    slack_bonus = np.exp(-slack_exponent_k * slack_norm)\n\n    # Anticipation bonus: can still fit another item of the same size\n    anticipate_bonus = np.where(slack[feasible] >= item, next_item_bonus, 0.0)\n\n    # Combine components\n    priority_feasible = base_priority + slack_bonus + anticipate_bonus\n\n    # Exact\u2011fit boost (within tolerance)\n    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)\n    priority_feasible[exact_fit_mask] += exact_fit_bonus\n\n    # Insert feasible priorities back into full array\n    priorities[feasible] = priority_feasible\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins ever so slightly\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priorities += tie_breaker\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e5,\n    slack_decay: float = 10.0,\n    next_item_factor: float = 0.1,\n    jitter: float = 1e-6,\n    atol: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    exact_fit_bonus : float, optional\n        Large bonus added for bins that can accommodate the item exactly.\n    slack_decay : float, optional\n        Controls the steepness of the exponential slack bonus.\n    next_item_factor : float, optional\n        Small bonus for bins that can still hold another item of the same size\n        after the current placement.\n    jitter : float, optional\n        Deterministic tie\u2011breaker magnitude (lower\u2011index bins get a tiny\n        advantage).\n    atol : float, optional\n        Absolute tolerance for detecting an exact fit.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores of the same shape as ``bins_remain_cap``.  Feasible\n        bins receive finite scores; infeasible bins receive ``-np.inf`` and\n        are never selected.\n    \"\"\"\n    # Convert to a 1\u2011D float array; avoid modifying the caller's array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Initialise all scores to -inf (infeasible)\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        return priority\n\n    # Slack after placing the item\n    slack = caps - item\n    feasible = slack >= 0\n\n    # No feasible bins: return early\n    if not np.any(feasible):\n        return priority\n\n    # Normalise slack within feasible bins to [0, 1]\n    max_slack = np.max(slack[feasible])  # >= 0\n    slack_norm = slack[feasible] / (max_slack + atol)\n\n    # Exponential slack bonus: small slack \u2192 large bonus\n    slack_bonus = np.exp(-slack_decay * slack_norm)\n\n    # Base priority from slack bonus\n    priority[feasible] = slack_bonus\n\n    # Anticipation bonus: still room for another item of the same size\n    anticipation_mask = feasible & (slack >= item)\n    priority[anticipation_mask] += next_item_factor\n\n    # Exact\u2011fit bonus\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins slightly\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 3,
    "obj": 5.215396888711603,
    "SLOC": 29.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    temperature: float = 0.5,\n    alpha: float = 0.1,\n    exact_fit_bonus: float = 1e6,\n    epsilon: float = 1e-12,\n    next_item: float | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently opened bins.\n    temperature : float, optional\n        Softmax temperature. Lower values increase the contrast between bins.\n    alpha : float, optional\n        Quadratic waste penalty coefficient.\n    exact_fit_bonus : float, optional\n        Large bonus added to bins that accommodate the item exactly.\n    epsilon : float, optional\n        Tiny index\u2011based tie\u2011breaker; lower indices get a slight advantage.\n    next_item : float or None, optional\n        Size of the next item (look\u2011ahead). Bins that can also host the next\n        item receive a small extra boost.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Infeasible bins are\n        assigned ``-np.inf`` and will never be chosen.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    if bins_remain_cap.ndim != 1:\n        raise ValueError(\"bins_remain_cap must be a 1\u2011D array\")\n\n    waste = bins_remain_cap - item\n    feasible = waste >= 0\n\n    # If no feasible bin, return all -inf to signal the need for a new bin.\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Base score: prefer smaller waste, optionally quadratic penalty.\n    base = -waste - alpha * np.square(waste)\n\n    # Exact\u2011fit bonus.\n    exact_mask = np.isclose(waste, 0.0, atol=1e-12)\n    base[exact_mask] += exact_fit_bonus\n\n    # Optional look\u2011ahead: boost bins that can also hold the next item.\n    if next_item is not None:\n        future_waste = waste - next_item\n        can_fit_next = future_waste >= 0\n        lookahead_bonus = np.where(\n            can_fit_next,\n            0.05 - 0.01 * future_waste,  # base boost minus penalty for large leftover\n            0.0,\n        )\n        base += lookahead_bonus\n\n    # Tie\u2011breaker: give a tiny advantage to lower\u2011index bins.\n    base -= epsilon * np.arange(bins_remain_cap.size)\n\n    # Temperature\u2011scaled softmax.\n    if temperature <= 0.0:\n        temperature = 1e-8\n    scaled = base / temperature\n\n    # Stable exponentiation only for feasible bins.\n    feasible_scaled = scaled[feasible]\n    max_scaled = np.max(feasible_scaled)\n    exp_scaled = np.exp(feasible_scaled - max_scaled)\n\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[feasible] = exp_scaled\n\n    return scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 39.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    bin_capacity: Optional[float] = None,\n    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,\n    k_base: float = 8.0,\n    alpha: float = 0.2,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority scores for bins in an online Bin Packing problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like of float\n        Remaining capacity of each currently opened bin.\n    bin_capacity : float, optional\n        Fixed capacity of a bin.  If ``None``, the maximum observed remaining\n        capacity plus the incoming item is used as a proxy.\n    lookahead_items : array\u2011like of float, optional\n        Sizes of future items.  Bins that can also accommodate more of these\n        items after placing the current one receive a multiplicative boost.\n    k_base : float, default 8.0\n        Base steepness for the sigmoid.  It is scaled by bin fullness.\n    alpha : float, default 0.2\n        Strength of the look\u2011ahead boost (0\u202f\u2264\u202falpha\u202f\u2264\u202f1).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for a tiny random tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins\n        (remaining capacity < ``item``) receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Prepare inputs\n    # ------------------------------------------------------------------\n    bins = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = bins.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Infer bin capacity if not provided\n    if bin_capacity is None:\n        # Use the largest observed remaining capacity as a surrogate.\n        # Adding a tiny epsilon avoids division by zero.\n        bin_capacity = float(np.max(bins) + 1e-9)\n    else:\n        bin_capacity = float(bin_capacity)\n\n    # ------------------------------------------------------------------\n    # 2. Feasibility mask\n    # ------------------------------------------------------------------\n    feasible = bins >= item\n    if not np.any(feasible):\n        # No bin can host the item.\n        return np.full_like(bins, -np.inf, dtype=float)\n\n    # ------------------------------------------------------------------\n    # 3. Compute gaps and normalized gaps\n    # ------------------------------------------------------------------\n    gaps = bins - item                     # >= 0 for feasible bins\n    norm_gaps = gaps / bin_capacity        # scale to [0, 1] (approx.)\n    norm_gaps = np.clip(norm_gaps, 0.0, 1.0)\n\n    # ------------------------------------------------------------------\n    # 4. Dynamic sigmoid steepness based on bin fullness\n    # ------------------------------------------------------------------\n    # Fullness = used capacity / total capacity\n    fullness = (bin_capacity - bins) / bin_capacity          # [0, 1]\n    k = k_base * (1.0 + fullness)                           # shape (n_bins,)\n\n    # ------------------------------------------------------------------\n    # 5. Monotonic sigmoid on normalized gaps\n    # ------------------------------------------------------------------\n    # We want higher scores for tighter fits (smaller gaps).  Use the\n    # largest normalized gap as a reference and apply a decreasing sigmoid.\n    norm_gaps_feas = norm_gaps[feasible]\n    k_feas = k[feasible]\n\n    max_norm_gap = np.max(norm_gaps_feas)                   # reference\n    # Shift such that exact fits (gap = 0) get the largest positive argument.\n    shifted = max_norm_gap - norm_gaps_feas                  # larger => tighter fit\n    exponent = k_feas * shifted\n\n    # Clip exponent to avoid overflow in exp().\n    exponent = np.clip(exponent, -700.0, 700.0)\n\n    # Sigmoid (monotonic decreasing in original gap)\n    scores = 1.0 / (1.0 + np.exp(-exponent))                # in (0, 1)\n\n    # ------------------------------------------------------------------\n    # 6. Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    scores += rng.uniform(0.0, 1e-6, size=scores.shape)\n\n    # ------------------------------------------------------------------\n    # 7. Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n        if lookahead.size > 0:\n            remaining_after = gaps[feasible]               # capacity left after current placement\n            # Count how many look\u2011ahead items each bin could still fit\n            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)\n            fit_ratio = fits.astype(float) / float(lookahead.size)   # in [0, 1]\n            # Apply multiplicative boost\n            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio\n            scores *= boost\n\n    # ------------------------------------------------------------------\n    # 8. Assemble final priority vector\n    # ------------------------------------------------------------------\n    priority = np.full_like(bins, -np.inf, dtype=float)\n    priority[feasible] = scores\n\n    return priority",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 46.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing Problem.\n\n    The scoring scheme combines:\n      * A massive bonus for exact fits.\n      * A quadratic penalty on leftover capacity (smaller leftover \u2192 higher priority).\n      * An adaptive weighting factor (\u03b1) that reacts to the distribution of\n        leftover capacities among feasible bins.\n      * A tiny index\u2011based epsilon tie\u2011breaker for deterministic selection.\n      * Infeasible bins receive ``-np.inf`` and are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better).  The caller should select\n        the bin with the maximal score.\n    \"\"\"\n    # Ensure we work with a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    n_bins = caps.shape[0]\n\n    # Initialise all scores as infeasible\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item\n    feasible = caps >= item\n    if not feasible.any():\n        return scores\n\n    # Remaining capacity after placing the item\n    leftover = caps - item  # >= 0 for feasible bins\n\n    # -----------------------------------------------------------------\n    # Adaptive weighting: compute a coefficient \u03b1 based on the spread\n    # of leftover capacities among feasible bins.\n    # -----------------------------------------------------------------\n    leftover_feas = leftover[feasible]\n    mean_left = leftover_feas.mean()\n    std_left = leftover_feas.std()\n    # Coefficient of variation (cv) captures relative dispersion; avoid div\u2011by\u2011zero\n    cv = std_left / mean_left if mean_left > 0 else 0.0\n    base_alpha = 1e-3               # baseline quadratic strength\n    alpha = base_alpha * (1.0 + cv) # larger cv \u2192 stronger quadratic penalty\n\n    # -----------------------------------------------------------------\n    # Quadratic penalty: prioritize bins with smaller leftovers\n    # -----------------------------------------------------------------\n    # priority = -leftover - \u03b1 * leftover\u00b2  (more negative \u2192 lower priority)\n    base_priority = -leftover_feas - alpha * (leftover_feas ** 2)\n\n    # -----------------------------------------------------------------\n    # Tiny tie\u2011breaker based on bin index (deterministic)\n    # -----------------------------------------------------------------\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n\n    # Assign base priority (including tie\u2011breaker) to feasible bins\n    scores[feasible] = base_priority + tie_breaker[feasible]\n\n    # -----------------------------------------------------------------\n    # Exact\u2011fit detection: give a massive bonus to bins that fit the item perfectly\n    # -----------------------------------------------------------------\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        EXACT_BONUS = 1e12  # dominates any other term\n        scores[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return scores",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e7,\n    slack_decay: float = 12.0,\n    jitter: float = 1e-12,\n    atol: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing Problem.\n\n    Higher scores indicate a more desirable bin for the incoming ``item``.\n    The score is built from three simple components:\n\n    1. **Negative slack** \u2013 bins that would waste less space get a higher base score.\n    2. **Exponential slack bonus** \u2013 adds a smooth boost when the leftover\n       (slack slack) is small, encouraging tight fits.\n    3. **Exact\u2011fit bonus** \u2013 a large constant added when the item fits the bin\n       exactly (within ``atol``).\n    4. **Deterministic jitter** \u2013 a tiny decreasing term based on bin index\n       to break ties consistently (favoring lower\u2011index bins).\n\n    Infeasible bins (insufficient capacity) receive ``-inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    exact_fit_bonus : float, optional\n        Large bonus added for bins where the item fits exactly.\n    slack_decay : float, optional\n        Controls steepness of the exponential slack bonus.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n    atol : float, optional\n        Absolute tolerance for detecting an exact fit.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Slack after placing the item\n    slack = caps - item\n    feasible = slack >= 0\n\n    # Initialise all priorities to -inf (infeasible)\n    priority = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 return early\n        return priority\n\n    # Base priority: negative slack (smaller leftover => larger score)\n    base = -slack[feasible]\n\n    # Normalised slack for exponential bonus\n    max_slack = np.max(slack[feasible])\n    norm_slack = slack[feasible] / (max_slack + atol)  # avoid div\u2011by\u2011zero\n    slack_bonus = np.exp(-slack_decay * norm_slack)   # 1 when slack=0, decays with slack\n\n    # Combine base and exponential bonus\n    priority[feasible] = base + slack_bonus\n\n    # Exact\u2011fit bonus (large incentive)\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol=atol)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins slightly\n    priority += -np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 78\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol=atol)\n                                                                ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 78\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol=atol)\n                                                                ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 78\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol=atol)\n                                                                ^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Deterministic priority scoring for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more desirable).  The caller should\n        select the bin with the maximal score.\n\n    Notes\n    -----\n    * Exact fits receive a huge bonus.\n    * Feasible bins are scored with a quadratic penalty on leftover.\n    * A tiny index\u2011based epsilon breaks ties deterministically.\n    * Infeasible bins receive ``-np.inf`` so they are never selected.\n    \"\"\"\n    # Flatten input to 1\u2011D for vectorised operations\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Handle empty input\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Default priorities: infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities.reshape(bins_remain_cap.shape)\n\n    # Leftover after placing the item\n    leftover = caps - item\n\n    # Base priority: negative leftover plus a small quadratic penalty\n    alpha = 1e-3\n    base_priority = -leftover - alpha * (leftover ** 2)\n\n    # Deterministic tie\u2011breaker: tiny epsilon weighted by bin index\n    epsilon = 1e-12\n    tie_breaker = -epsilon * np.arange(n_bins, dtype=float)\n    base_priority += tie_breaker\n\n    # Assign base priority to feasible bins\n    priorities[feasible] = base_priority[feasible]\n\n    # Exact fit detection and massive bonus\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if np.any(exact_fit):\n        EXACT_BONUS = 1e9\n        priorities[exact_fit] = EXACT_BONUS + tie_breaker[exact_fit]\n\n    return priorities.reshape(bins_remain_cap.shape)",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e7,\n    slack_decay: float = 10.0,\n    jitter: float = 1e-12,\n    atol: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing Problem.\n\n    Higher scores indicate a more desirable bin for the incoming ``item``1``.\n    The scoring scheme follows the reflection:\n\n    \u2022 Monotonic slack score: bins with less leftover capacity after placement\n      receive a higher base score (``-slack``).\n    \u2022 Exponential slack penalty: larger leftovers are penalised by an\n      exponential term, preserving monotonicity.\n    \u2022 Large bonus for exact fits.\n    \u2022 Tiny deterministic tie\u2011breaker based on bin index (``jitter``).\n\n    Infeasible bins (capacity < item) receive ``-inf`` priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n    exact_fit_bonus : float, optional\n        Bonus added for bins where the item fits exactly.\n    slack_decay : float, optional\n        Controls steepness of the exponential slack penalty.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n    atol : float, optional\n        Absolute tolerance for detecting an exact fit.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Convert to 1\u2011D float  array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Edge case: no bins\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Remaining capacity after placing the item\n    slack = caps - item\n\n    # Feasibility mask (allow tiny negative due to floating point)\n    feasible = slack >= -atol\n\n    # Initialise priorities with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 return early\n        return priority\n\n    # Monotonic base score: negative slack (smaller slack \u21d2 higher score)\n    base_score = -slack[feasible]\n\n    # Normalised slack for exponential penalty (avoid division by zero)\n    max_slack = np.max(slack[feasible])\n    norm_slack = slack[feasible] / (max_slack + atol)\n\n    # Exponential slack penalty (larger slack \u21d2 larger penalty)\n    slack_penalty = np.exp(slack_decay * norm_slack)\n\n    # Combine base and penalty (higher is better)\n    priority[feasible] = base_score - slack_penalty\n\n    # Exact\u2011fit bonus (detect near\u2011zero slack)\n    exact_fit = np.isclose(slack[feasible], 0.0, atol=atol)\n    if np.any(exact_fit):\n        priority[feasible][exact_fit] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: prefer lower\u2011index bins slightly\n    priority -= np.arange(n_bins, dtype=float) * jitter\n\n    return priority",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 28.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    bin_capacity: float = 1.0,\n    exact_fit_bonus: float = 1e6,\n    slack_weight: float = 1.0,\n    new_bin_penalty: float = 0.2,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    The function evaluates each currently open bin and a virtual new bin.\n    Higher returned values indicate more desirable bins.\n\n    - Exact\u2011fit bins receive a large ``exact_fit_bonus``.\n    - For other feasible bins the priority decreases linearly with the\n      normalized slack (waste / bin_capacity).  Slack is multiplied by\n      ``slack_weight``; larger slack => lower priority.\n    - Opening a new bin is penalised by ``new_bin_penalty`` proportionally to its\n      expected waste.\n    - A tiny deterministic tie\u2011breaker (``epsilon``) favours lower indices.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of already opened bins.\n    bin_capacity : float, optional\n        Fixed capacity of every bin (default 1.0).\n    exact_fit_bonus : float, optional\n        Bonus added to a bin that would be exactly filled (default 1e6).\n    slack_weight : float, optional\n        Linear weight for normalized slack (default 1.0).\n    new_bin_penalty : float, optional\n        Multiplicative penalty applied to the waste of a newly opened bin\n        (default 0.2 \u2192 20\u202f% extra waste (default 0.2 \u2192 20\u202f% extra waste cost).\n    epsilon : float, optional\n        Tiny value for deterministic tie\u2011breaking (default 1e\u201112).\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores with shape ``(len(bins_remain_cap) + 1,)``.\n        The last entry corresponds to the virtual new bin.\n    \"\"\"\n    # Ensure NumPy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Waste (remaining capacity after placement) for each existing bin\n    waste = bins_remain_cap - item\n    feasible = waste >= 0\n\n    # Normalized slack: waste divided by the fixed bin capacity\n    slack = np.where(feasible, waste / bin_capacity, np.inf)\n\n    # Base priority: negative weighted slack (smaller slack \u2192 higher priority)\n    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)\n\n    # Exact\u2011fit bonus (within tolerance)\n    exact_fit_mask = np.isclose(waste, 0.0, atol=epsilon)\n    base_priority = np.where(exact_fit_mask, base_priority + exact_fit_bonus, base_priority)\n\n    # Deterministic tie\u2011breaker: tiny advantage for lower indices\n    tie_breaker = -np.arange(bins_remain_cap.size) * epsilon\n    base_priority = base_priority + tie_breaker\n\n    # ---------- Virtual new bin ----------\n    waste_new = bin_capacity - item\n    if waste_new < 0:\n        new_bin_priority = -np.inf\n    else:\n        slack_new = waste_new / bin_capacity\n        # Apply penalty proportional to expected waste\n        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)\n        # Exact\u2011fit bonus for a perfect new bin\n        if np.isclose(waste_new, 0.0, atol=epsilon):\n            new_bin_priority += exact_fit_bonus\n        # Tie\u2011breaker for the virtual bin (give it a neutral index after all real bins)\n        new_bin_priority += -bins_remain_cap.size * epsilon\n\n    # Append virtual new bin priority as the last element\n    priorities = np.append(base_priority, new_bin_priority)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]