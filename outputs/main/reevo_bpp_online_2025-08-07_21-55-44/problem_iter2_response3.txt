```python
import numpy as np
from typing import Union, Optional

def priority_v2(
    item: Union[float, int],
    bins_remain_cap: np.ndarray,
    atol: float = 1e-12,
    boost_factor: Optional[float] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    Parameters
    ----------
    item : float or int
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each currently open bin.
    atol : float, optional
        Absolute tolerance for deciding whether a bin is an exact fit.
        Defaults to 1e-12.
    boost_factor : float, optional
        Positive constant added to exact‑fit bins.  If ``None`` a dynamic
        boost is computed that is guaranteed to exceed any feasible
        non‑exact priority.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``).  Bins
        that cannot accommodate the item receive ``-np.inf``.  The bin with the
        highest score should be selected for the item.
    """
    # Ensure a float array for vectorised operations
    caps = np.asarray(bins_remain_cap, dtype=float)
    item_val = float(item)

    # Slack after hypothetically placing the item
    slack = caps - item_val

    # Feasibility mask (item fits if slack >= 0)
    feasible = slack >= 0

    # Exact‑fit mask (slack is effectively zero)
    exact_fit = feasible & np.isclose(slack, 0.0, atol=atol, rtol=0.0)

    # Initialise priorities with the worst possible value
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Feasible, non‑exact bins: priority = -slack (higher when slack smaller)
    non_exact = feasible & ~exact_fit
    priorities[non_exact] = -slack[non_exact]

    # Determine a boost that dominates any non‑exact priority
    if boost_factor is None:
        # Max priority among non‑exact feasible bins (or -inf if none)
        max_non_exact = priorities[non_exact].max() if non_exact_exact := non_exact.any() else -np.inf
        # Use a safe margin; if no feasible bins, fall back to a large constant
        boost_factor = (max_non_exact + 1.0) if max_non_exact != -np.inf else 1e6

    # Exact‑fit bins get the boost
    priorities[exact_fit] = boost_factor

    return priorities
```
