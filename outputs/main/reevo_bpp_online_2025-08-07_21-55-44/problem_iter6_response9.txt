```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    exact_fit_bonus: float = 1e7,
    slack_decay: float = 10.0,
    jitter: float = 1e-12,
    atol: float = 1e-12,
) -> np.ndarray:
    """
    Compute a priority score for each bin in an online Bin Packing Problem.

    Higher scores indicate a more desirable bin for the incoming ``item``1``.
    The scoring scheme follows the reflection:

    • Monotonic slack score: bins with less leftover capacity after placement
      receive a higher base score (``-slack``).
    • Exponential slack penalty: larger leftovers are penalised by an
      exponential term, preserving monotonicity.
    • Large bonus for exact fits.
    • Tiny deterministic tie‑breaker based on bin index (``jitter``).

    Infeasible bins (capacity < item) receive ``-inf`` priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently opened bin.
    exact_fit_bonus : float, optional
        Bonus added for bins where the item fits exactly.
    slack_decay : float, optional
        Controls steepness of the exponential slack penalty.
    jitter : float, optional
        Magnitude of the deterministic tie‑breaker based on bin index.
    atol : float, optional
        Absolute tolerance for detecting an exact fit.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).
    """
    # Convert to 1‑D float  array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Edge case: no bins
    if n_bins == 0:
        return np.array([], dtype=float)

    # Remaining capacity after placing the item
    slack = caps - item

    # Feasibility mask (allow tiny negative due to floating point)
    feasible = slack >= -atol

    # Initialise priorities with -inf for infeasible bins
    priority = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – return early
        return priority

    # Monotonic base score: negative slack (smaller slack ⇒ higher score)
    base_score = -slack[feasible]

    # Normalised slack for exponential penalty (avoid division by zero)
    max_slack = np.max(slack[feasible])
    norm_slack = slack[feasible] / (max_slack + atol)

    # Exponential slack penalty (larger slack ⇒ larger penalty)
    slack_penalty = np.exp(slack_decay * norm_slack)

    # Combine base and penalty (higher is better)
    priority[feasible] = base_score - slack_penalty

    # Exact‑fit bonus (detect near‑zero slack)
    exact_fit = np.isclose(slack[feasible], 0.0, atol=atol)
    if np.any(exact_fit):
        priority[feasible][exact_fit] += exact_fit_bonus

    # Deterministic tie‑breaker: prefer lower‑index bins slightly
    priority -= np.arange(n_bins, dtype=float) * jitter

    return priority
```
