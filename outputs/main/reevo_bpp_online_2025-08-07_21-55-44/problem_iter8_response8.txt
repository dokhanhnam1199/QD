```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, list, tuple],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, list, tuple]] = None,
    k: float = 10.0,
    offset: float = 0.5,
    alpha: float = 0.1,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing setting.

    The function prefers bins that leave little slack after placing ``item``,
    while also rewarding bins that can still accommodate future items
    (``lookahead_items``). Scores are produced by a per‑bin sigmoid on the
    normalised slack, avoiding large fixed bonuses. A tiny random tie‑breaker
    ensures deterministic but unpredictable ordering for equal scores.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacities of the currently open bins.
    bin_capacity : float, optional
        Fixed capacity of each bin. If omitted, inferred from the maximum
        observed remaining capacity (ensuring it is at least ``item``).
    lookahead_items : array‑like of float, optional
        Sizes of items that may arrive soon. Bins that can still fit more of
        these items after placing ``item`` receive a multiplicative boost.
    k : float, default 10.0
        Base steepness of the sigmoid. Larger values give sharper
        discrimination between small and large slack.
    offset : float, default 0.5
        Offset for the sigmoid (in normalised slack units). A value of 0.5
        yields a moderate score when half the bin is left.
    alpha : float, default 0.1
        Strength of the look‑ahead boost (as a fraction of the base score).
    random_state : int or np.random.Generator, optional
        Seed or generator for the tiny random tie‑breaker.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (shape matches ``bins_remain_cap``);
        infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # Normalise inputs
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # ------------------------------------------------------------------
    # Infer bin capacity if not supplied
    # ------------------------------------------------------------------
    if bin_capacity is None:
        # Use the maximum observed remaining capacity as a proxy.
        # Ensure the capacity can accommodate the current item.
        max_cap = np.max(caps) if n_bins > 0 else 0.0
        bin_capacity = float(max_cap if max_cap >= item else max_cap + item)
    if bin_capacity <= 0:
        raise ValueError("bin_capacity must be positive.")

    # ------------------------------------------------------------------
    # Feasibility mask
    # ------------------------------------------------------------------
    feasible = caps >= item
    if not np.any(feasible):
        # No bin can hold the item
        return np.full(n_bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # Slack and normalised slack after placement (feasible bins only)
    # ------------------------------------------------------------------
    leftover = caps[feasible] - item                     # >= 0
    slack_norm = leftover / bin_capacity                 # in [0, 1]

    # ------------------------------------------------------------------
    # Per‑bin sigmoid steepness based on current fullness
    # ------------------------------------------------------------------
    # Fullness before placement (fraction already used)
    fullness = (bin_capacity - caps[feasible]) / bin_capacity
    k_i = k * (1.0 + fullness)  # sharper for bins that are already fuller

    # Sigmoid argument: positive when slack_norm < offset (i.e., small slack)
    arg = k_i * (offset - slack_norm)
    # Clip to avoid overflow in exp
    arg = np.clip(arg, -700.0, 700.0)

    # Logistic sigmoid maps arg -> score in (0, 1)
    scores = 1.0 / (1.0 + np.exp(-arg))

    # ------------------------------------------------------------------
    # Tiny random tie‑breaker
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    eps = 1e-12 * max(1.0, np.max(np.abs(scores)))
    scores += rng.uniform(0.0, eps, size=scores.shape)

    # ------------------------------------------------------------------
    # Optional look‑ahead boost
    # ------------------------------------------------------------------
    if lookahead_items is not None:
        look = np.asarray(lookahead_items, dtype=float).ravel()
        if look.size > 0:
            # For each bin, count how many look‑ahead items could still fit
            fits = (look[None, :] <= leftover[:, None]).sum(axis=1)
            fit_ratio = fits / float(look.size)          # in [0, 1]
            # Multiplicative boost, clipped to keep scores ≤ 1
            scores = np.minimum(scores * (1.0 + alpha * fit_ratio), 1.0)

    # ------------------------------------------------------------------
    # Assemble full priority vector
    # ------------------------------------------------------------------
    priority = np.full(n_bins, -np.inf, dtype=float)
    priority[feasible] = scores

    return priority
```
