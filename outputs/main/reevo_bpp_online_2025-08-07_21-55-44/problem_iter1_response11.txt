```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Best‑Fit priority for the online Bin Packing Problem.

    The function returns a priority score for each existing bin. The bin that yields the
    smallest leftover capacity after the item is placed receives the highest priority.
    Bins that cannot accommodate the item are assigned -inf (worst possible score).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Priority scores – same shape as `bins_remain_cap`. Higher values indicate a more
        desirable bin for placement.
    """
    # Ensure we work with float dtype (required for -inf)
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Compute the unused space that would remain if the item were placed in each bin
    gap = bins_remain_cap - item

    # Valid bins are those where the item fits (gap >= 0)
    valid_mask = gap >= 0

    # Initialise all priorities to the worst possible score
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # For feasible bins, priority is the negative of the remaining gap.
    # The smaller the gap, the larger (closer to zero) the priority.
    # This implements the Best‑Fit rule: prefer bins with minimal waste.
    priorities[valid_mask] = -gap[valid_mask]

    # ----------------------------------------------------------------------
    # Creative tie‑breaker: add a tiny deterministic bias based on the bin index.
    # This ensures reproducible selections when multiple bins have identical gaps.
    # The bias is orders of magnitude smaller than any realistic gap, so it
    # does not affect the primary ordering.
    # ----------------------------------------------------------------------
    eps = 1e-12
    if valid_mask.any():
        # Use the original order of indices as the deterministic source.
        idx = np.arange(bins_remain_cap.size, dtype=float)
        priorities[valid_mask] += eps * idx[valid_mask]

    return priorities
```
