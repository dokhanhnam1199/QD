```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin in an online bin‑packing setting.

    The priority is based on a simple linear penalty proportional to the
    leftover capacity after placing the item.  Bins that provide an exact
    fit receive a large constant bonus.  A tiny deterministic tie‑breaker
    slightly penalises bins with larger indices so that the choice is
    reproducible.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher scores indicate more desirable bins.  Infeasible bins receive
        ``-np.inf``.
    """
    shape = np.shape(bins_remain_cap)
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if n_bins == 0:
        return priorities.reshape(shape)

    leftover = caps - item
    feasible = leftover >= 0

    if not np.any(feasible):
        return priorities.reshape(shape)

    # Linear penalty: larger leftover -> lower priority
    priorities[feasible] = -leftover[feasible] * item

    # Reward exact fits with a huge bonus
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-9)
    if np.any(exact_fit):
        priorities[exact_fit] = 1e12

    # Deterministic tie‑breaker: slightly penalise larger indices
    TIE_EPS = 1e-6
    priorities -= TIE_EPS * np.arange(n_bins)

    return priorities.reshape(shape)
```
