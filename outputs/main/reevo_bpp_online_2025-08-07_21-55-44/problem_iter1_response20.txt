```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """First‑Fit priority for the online Bin Packing Problem.

    The returned scores satisfy the First‑Fit rule:
      * Bins that cannot hold ``item`` receive ``-np.inf`` so they will never be
        chosen.
      * Among the feasible bins, the one with the smallest index obtains the
        highest score (i.e., the “first” bin).  If several bins share the same
        index (theoretically impossible) a secondary tie‑breaker prefers the
        tighter fit (smaller leftover capacity).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the current bins (1‑D array).

    Returns
    -------
    np.ndarray
        An array of the same shape as ``bins_remain_cap`` containing the
        priority score for each bin.
    """
    # Convert to float for arithmetic safety
    caps = bins_remain_cap.astype(float)

    # Feasibility mask: bin can accommodate the item
    feasible = caps >= item

    # Primary component: enforce the "first" bin rule.
    # Bin 0 -> 0, Bin 1 -> -1, Bin 2 -> -2, ...  Higher value means higher priority.
    idx = np.arange(caps.size, dtype=float)
    primary = -idx

    # Secondary component (tie‑breaker): prefer a tighter fit.
    # The leftover after placing the item is (caps - item).
    # Smaller leftover → larger secondary priority.
    # Scale it by a tiny epsilon so it never overpowers the primary ordering.
    epsilon = 1e-4
    secondary = - (caps - item) * epsilon

    # Combine components
    scores = primary + secondary

    # Infeasible bins should never be selected
    scores = np.where(feasible, scores, -np.inf)

    return scores
```
