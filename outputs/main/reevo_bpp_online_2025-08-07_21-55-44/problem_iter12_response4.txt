```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority scores for online Bin Packing.

    Higher scores indicate more desirable bins.
    Infeasible bins receive -inf so they are never chosen.

    The score is monotonic: bins that would leave less slack after placing the
    item receive a higher score.  A simple exponential penalty discourages
    leaving large slack, an enormous exact‑fit bonus forces a perfect fit when
    possible, and a tiny deterministic jitter breaks ties in favour of lower
    index bins.  Only a few hyper‑parameters are used.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D (or flattenable) array of remaining capacities of the currently
        opened bins.

    Returns
    -------
    np.ndarray
        Array of priority scores with the same shape as ``bins_remain_cap``.
    """
    # ---- Hyper‑parameters (minimal set) ----
    slack_decay = 5.0          # steepness of the exponential slack penalty
    exact_fit_bonus = 1e12     # huge reward for an exact fit
    jitter_eps = 1e-12         # deterministic tie‑breaker magnitude
    atol = 1e-12               # tolerance for floating‑point comparisons
    # -----------------------------------------

    # Flatten input for vectorised work, remember original shape for output
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Early exit for empty input
    if n_bins = n_bins == 0:
        return np.empty(0, dtype=float)

    # Remaining slack after (hypothetically) placing the item
    slack_raw = caps - item

    # Feasibility mask: allow a tiny negative slack due to FP errors
    feasible = slack_raw >= -atol

    # Initialise priority array with -inf (infeasible bins)
    priority = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – caller will open a new bin
        return priority.reshape(bins_remain_cap.shape)

    # Clip slack to zero for feasible bins (negative slack treated as zero)
    slack = np.where(feasible, np.maximum(slack_raw, 0.0), 0.0)

    # Base monotonic component: smaller slack → larger (less negative) score
    base_score = -slack

    # Exponential slack penalty (larger slack → larger penalty)
    slack_penalty = np.exp(slack_decay * slack)

    # Combined score for feasible bins
    score = base_score - slack_penalty

    # Exact‑fit detection (slack effectively zero) and huge bonus
    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol)
    if np.any(exact_fit_mask):
        score[exact_fit_mask] += exact_fit_bonus

    # Deterministic jitter: prefers lower‑index bins
    jitter = np.arange(n_bins, dtype=float) * jitter_eps
    score -= jitter

    # Write scores back to the priority array
    priority[feasible] = score[feasible]

    # Reshape to original input shape
    return priority.reshape(bins_remain_cap.shape)
```
