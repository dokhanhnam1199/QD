```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 0.1,
    rng: np.random.Generator | None = None
) -> np.ndarray:
    """
    Compute priority scores for placing an incoming item into existing bins using an epsilon‑greedy policy.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacity of each existing bin (shape: (n_bins,)).
    epsilon : float, optional
        Exploration probability (default=0.1). With probability ``epsilon`` the function returns
        purely random scores to encourage exploration of sub‑optimal bins.
    rng : np.random.Generator, optional
        Random number generator for reproducibility. If None, a default generator is used.

    Returns
    -------
    np.ndarray
        Priority score for each bin (higher is preferred). Bins that cannot accommodate the item
        receive ``-np.inf`` when exploiting, ensuring they are never chosen unless exploration occurs.
    """
    if rng is None:
        rng = np.random.default_rng()

    n_bins = bins_remain_cap.shape[0]
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Decide whether to explore (random) or exploit (best‑fit heuristic)
    if rng.random() < epsilon:
        # Exploration: assign random scores to all bins
        return rng.random(n_bins)
    else:
        # Exploitation: Best‑Fit – prefer bins that leave the smallest slack.
        remaining_after = bins_remain_cap - item
        feasible = remaining_after >= 0

        # Initialize all priorities as -inf (infeasible bins)
        priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

        # For feasible bins, compute a score inversely proportional to the slack.
        # Smaller slack → larger score.
        slack = remaining_after[feasible]
        # Adding a tiny epsilon prevents division by zero for perfect fits.
        priorities[feasible] = 1.0 / (slack + 1e-12)

        # Add a tiny random jitter to break ties deterministically.
        jitter = rng.random(np.count_nonzero(feasible)) * 1e-6
        priorities[feasible] += jitter

        return priorities
```
