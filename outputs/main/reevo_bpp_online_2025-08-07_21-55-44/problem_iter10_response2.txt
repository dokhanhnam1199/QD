```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    exact_fit_bonus: float = 1e6,
    slack_exponent_k: float = 12.0,
    next_item_bonus: float = 0.05,
    jitter: float = 1e-12,
    exact_fit_atol: float = 1e-12,
    eps: float = 1e-12,
) -> np.ndarray:
    """
    Compute priority scores for each open bin in an online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item ≤ bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently opened bins.
    exact_fit_bonus : float, optional
        Large additive boost for (near) exact fits.
    slack_exponent_k : float, optional
        Controls the steepness of the exponential reward for tight fits.
    next_item_bonus : float, optional
        Bonus added if the bin would still be able to accommodate another
        item of the same size after placing the current one.
    jitter : float, optional
        Tiny deterministic tie‑breaker (lower‑index bins get a minute advantage).
    exact_fit_atol : float, optional
        Absolute tolerance for treating a placement as an exact fit.
    eps : float, optional
        Small constant to avoid division‑by‑zero in normalisation.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``). Higher scores indicate
        more desirable bins. Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Early exit if there are no bins
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Slack after placing the item
    slack = caps - item

    # Feasibility mask: only bins with non‑negative slack are candidates
    feasible = slack >= 0.0

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # If nothing fits, return early
    if not feasible.any():
        return priorities

    # ----- Base component: prefer tighter fits -----
    # Negative slack: less waste yields a larger (less negative) value
    base = -slack[feasible]

    # ----- Normalised slack for exponential reward -----
    # Normalise by the largest slack among feasible bins (keeps values in [0,1])
    max_slack = slack[feasible].max()
    denom = max_slack + eps
    slack_norm = slack[feasible] / denom

    # Exponential reward: larger when slack_norm is small (tight fit)
    exp_reward = np.exp(-slack_exponent_k * slack_norm)

    # ----- Anticipation bonus: can still fit another same‑size item -----
    anticipate = np.where(slack[feasible] >= item, next_item_bonus, 0.0)

    # ----- Combine components -----
    score = base + exp_reward + anticipate

    # ----- Exact‑fit boost (within tolerance) -----
    exact_fit_mask = np.isclose(slack[feasible], 0.0, atol=exact_fit_atol)
    score[exact_fit_mask] += exact_fit_bonus

    # Insert feasible scores back into the full array
    priorities[feasible] = score

    # ----- Deterministic tie‑breaker: lower index gets a minuscule advantage -----
    tie_breaker = -np.arange(n_bins, dtype=float) * jitter
    priorities += tie_breaker

    return priorities
```
