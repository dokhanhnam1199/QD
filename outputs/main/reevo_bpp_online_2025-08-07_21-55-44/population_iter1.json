[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority assignment for first\u2011fit online bin packing.\n\n    Returns a higher priority for bins that can accommodate the incoming item.\n    Among those, the earliest bin (smallest index) is favoured. Unfeasible\n    bins receive a priority of negative infinity so they are never selected.\n    \n    Parameters\n    ----------\n    item : float\n        Size of the item to add to a bin.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n    \n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin, of the same shape as\n        ``bins_remain_cap``.\n    \"\"\"\n    # Ensure a 1\u2011D array of floats\n    bins = np.asarray(bins_remain_cap, dtype=float).ravel()\n    \n    # Base priority: earlier bins get a larger (less negative) score\n    base_priority = -np.arange(bins.size, dtype=float)\n    \n    # Bins that can fit the item\n    fit_mask = bins >= item\n    \n    # Initialise all priorities to -inf (exclude infeasible bins)\n    priorities = np.full_like(bins, -np.inf, dtype=float)\n    \n    # Assign priorities only to feasible bins\n    priorities[fit_mask] = base_priority[fit_mask]\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority function for online Bin Packing.\n\n    The priority is higher (i.e., less negative) for bins that will have the\n    smallest remaining capacity after placing ``item``. Bins that cannot accommodate\n    the item receive ``-inf`` priority to guarantee they are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently opened bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, same shape as ``bins_remain_cap``. The caller\n        should select the bin with the maximum priority.\n    \"\"\"\n    # Ensure a NumPy array (in case a list or other sequence is passed)\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the waste (unused space) if the item were placed in each bin.\n    waste = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative waste can hold the item.\n    feasible = waste >= 0\n\n    # Primary priority: negative waste (larger value \u21d2 smaller waste).\n    base_priority = np.where(feasible, -waste, -np.inf)\n\n    # Tie\u2011breaker: give a tiny advantage to bins with smaller index.\n    # This factor is far smaller than any realistic waste difference.\n    epsilon = 1e-12\n    tie_breaker = -np.arange(bins_remain_cap.size) * epsilon\n\n    priorities = base_priority + tie_breaker\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function using the Worst Fit strategy.\n\n    The priority returned for a bin equals the remaining capacity that would be left\n    after placing the given `item`.  The larger this value, the worse the fit, so the\n    bin with the maximum priority is the best choice.  Bins that cannot accommodate\n    the item receive a priority of -inf, ensuring they are never selected.\n\n    Args:\n        item: Size of the item to place.\n        bins_remain_cap: 1-D array of remaining capacities for each bin.\n\n    Returns:\n        np.ndarray of priority scores, same shape as `bins_remain_cap`.\n    \"\"\"\n    # Determine which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # Start with very low priorities for all bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For bins that can fit, priority is remaining capacity after the item\n    priorities[can_fit] = bins_remain_cap[can_fit] - item\n\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for each bin according to the Almost Full Fit heuristic.\n\n    The heuristic prefers the bin that, after receiving the item, would have the\n    smallest leftover capacity (i.e., be \"almost full\").\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; higher values correspond to more desirable bins.\n        Unfeasible bins receive -inf priority.\n    \"\"\"\n    # Compute the hypothetical remaining capacity after placing the item\n    new_remain = bins_remain_cap - item\n\n    # Identify bins where the item fits\n    feasible = new_remain >= 0\n\n    # Initialize priorities with -inf for infeasible bins\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # For feasible bins, higher priority for smaller leftover (almost full)\n    priorities[feasible] = -new_remain[feasible]\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact\u2011Fit\u2011First priority function for the online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as `bins_remain_cap`).  The bin\n        with the highest score should be chosen for the item.\n\n    Strategy\n    --------\n    1. **Exact fits** (remaining capacity after placement \u2248 0) receive a very\n       large positive boost, guaranteeing they are selected whenever possible.\n    2. **Feasible but non\u2011exact bins** receive a priority equal to the negative\n       slack (`- (remaining capacity - item)`).  Since the slack is non\u2011negative,\n       a smaller slack yields a larger priority (e.g., slack\u202f=\u202f0.1 \u2192 \u22120.1 > \u22121.0).\n    3. **Infeasible bins** receive `-inf` so they are never selected.\n    \"\"\"\n    # Compute remaining capacity after putting the item into each bin\n    slack = bins_remain_cap - item\n\n    # Feasibility mask (slack >= 0, i.e., item fits)\n    feasible = slack >= 0\n\n    # Exact\u2011fit mask (slack is essentially zero, tolerant to floating\u2011point noise)\n    exact_fit = feasible & np.isclose(slack, 0.0, atol=1e-12)\n\n    # Initialise all priorities as -inf (worst possible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Assign a huge constant to exact\u2011fit bins\n    BIG_BOOST = 1e9\n    priorities[exact_fit] = BIG_BOOST\n\n    # For the remaining feasible bins, priority = -slack (higher when slack is smaller)\n    non_exact = feasible & ~exact_fit\n    priorities[non_exact] = -slack[non_exact]\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse Distance (Proximity Fit) priority for online Bin Packing.\n\n    Returns a priority score for each bin where bins that would have the smallest\n    leftover capacity after placing the item obtain the highest score.\n    Infeasible bins (cannot accommodate the item) receive a score of 0.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each open bin.\n\n    Returns:\n        np.ndarray of the same shape as ``bins_remain_cap`` containing priority scores.\n    \"\"\"\n    epsilon = 1e-9  # Prevent division by zero for a perfect fit.\n\n    # Compute the hypothetical leftover capacity if the item were placed.\n    leftover = bins_remain_cap - item\n\n    # Bins that can actually accommodate the item.\n    feasible = leftover >= 0\n\n    # Initialise priorities (infeasible bins stay at zero).\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # For feasible bins compute the inverse of the leftover capacity.\n    # Smaller leftover => higher priority. For exact fits use epsilon.\n    safe_leftover = np.where(leftover[feasible] == 0, epsilon, leftover[feasible])\n    priorities[feasible] = 1.0 / safe_leftover\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score for online Bin Packing.\n\n    Computes a priority score for each bin such that bins leaving a\n    small positive residual after packing the given `item` obtain the\n    highest scores.  Bins that cannot accommodate the item receive\n    a large negative penalty.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be packed.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin (1\u2011D array).\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as `bins_remain_cap` containing priority\n        scores; the bin with the maximum score is chosen.\n    \"\"\"\n    # Calculate the leftover capacity after placing the item\n    gaps = bins_remain_cap - item\n\n    # Parameter controlling the sharpness of the sigmoid curve.\n    # Larger values yield stronger preference for very small gaps.\n    k = 8.0\n\n    # Assign a very low score for bins that cannot hold the item.\n    NEG_INF = -1e10\n\n    # Compute the sigmoid over the gaps for bins that can accommodate the item.\n    priorities = np.where(\n        gaps >= 0,\n        1.0 / (1.0 + np.exp(k * gaps)),   # Higher when gaps are small\n        NEG_INF                           # Impossible fits get minimal priority\n    )\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Random\u2011Fit priority for the online Bin Packing Problem.\n\n    Each bin that can accommodate the incoming `item` receives a random\n    priority in the interval (0, 1). Bins that lack sufficient remaining\n    capacity are assigned a priority of -\u221e so they are never selected.\n    The bin with the highest priority (i.e., the highest random draw among\n    feasible bins) is chosen, which corresponds exactly to picking a random\n    feasible bin.\n\n    Parameters\n    ----------\n    item : float\n        Size of the newly arriving item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` with a priority scores.\n    \"\"\"\n    # Initialize all priorities to -infinity (unselectable)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Identify bins that can hold the item\n    feasible = bins_remain_cap >= item\n\n    # Assign a uniform random priority to each feasible bin\n    if np.any(feasible):\n        # Random values drawn independently for each feasible bin\n        priorities[feasible] = np.random.rand(np.count_nonzero(feasible))\n\n    return priorities",
    "response_id": 7,
    "obj": 73.50418827283607,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.1,\n    rng: np.random.Generator | None = None\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for placing an incoming item into existing bins using an epsilon\u2011greedy policy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each existing bin (shape: (n_bins,)).\n    epsilon : float, optional\n        Exploration probability (default=0.1). With probability ``epsilon`` the function returns\n        purely random scores to encourage exploration of sub\u2011optimal bins.\n    rng : np.random.Generator, optional\n        Random number generator for reproducibility. If None, a default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin (higher is preferred). Bins that cannot accommodate the item\n        receive ``-np.inf`` when exploiting, ensuring they are never chosen unless exploration occurs.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n\n    n_bins = bins_remain_cap.shape[0]\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Decide whether to explore (random) or exploit (best\u2011fit heuristic)\n    if rng.random() < epsilon:\n        # Exploration: assign random scores to all bins\n        return rng.random(n_bins)\n    else:\n        # Exploitation: Best\u2011Fit \u2013 prefer bins that leave the smallest slack.\n        remaining_after = bins_remain_cap - item\n        feasible = remaining_after >= 0\n\n        # Initialize all priorities as -inf (infeasible bins)\n        priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n        # For feasible bins, compute a score inversely proportional to the slack.\n        # Smaller slack \u2192 larger score.\n        slack = remaining_after[feasible]\n        # Adding a tiny epsilon prevents division by zero for perfect fits.\n        priorities[feasible] = 1.0 / (slack + 1e-12)\n\n        # Add a tiny random jitter to break ties deterministically.\n        jitter = rng.random(np.count_nonzero(feasible)) * 1e-6\n        priorities[feasible] += jitter\n\n        return priorities",
    "response_id": 8,
    "obj": 4.2181890706023095,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax\u2011based fit priority for the online Bin Packing Problem.\n\n    Each feasible bin (i.e., with enough remaining capacity for ``item``) receives a\n    probability proportional to ``exp(-remaining_space / T)`` where ``remaining_space``\n    is the leftover capacity after placing the item.  Bins that cannot accommodate\n    the item get a priority of 0.  The temperature ``T`` controls how greedy the\n    decision is: lower ``T`` yields a more deterministic choice (tightest fit), while\n    higher ``T`` spreads probability more uniformly.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of existing bins.\n\n    Returns:\n        An array of the same shape as ``bins_remain_cap`` containing the priority\n        (probability) for each bin.\n    \"\"\"\n    # Ensure a NumPy array of float for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialize all priorities to zero (including infeasible bins)\n    priorities = np.zeros_like(caps, dtype=float)\n\n    # Identify bins that can accommodate the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No feasible bin \u2013 return all zeros (caller may open a new bin)\n        return priorities\n\n    # Compute the leftover capacity if the item were placed in each feasible bin\n    leftover = caps[feasible] - item                      # >= 0\n\n    # Score is higher for tighter fits: smaller leftover -> larger (less negative) score\n    # Using negative leftover as raw score for softmax\n    raw_scores = -leftover\n\n    # Temperature controls greediness; choose a sensible default\n    temperature = 0.5\n    # Prevent division by zero or extremely sharp distributions\n    temperature = max(temperature, 1e-8)\n\n    # Stable softmax: shift by the maximum raw score before exponent\n    max_score = np.max(raw_scores)\n    exp_shifted = np.exp((raw_scores - max_score) / temperature)\n\n    # Normalize to obtain a probability distribution over feasible bins\n    probs = exp_shifted / exp_shifted.sum()\n\n    # Assign the probabilities back to the full priority vector\n    priorities[feasible] = probs\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function for online bin packing using the First Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Bins that can accommodate the item receive a\n        priority equal to the negative of their index (so lower index \u21d2 higher\n        priority). Bins that cannot accommodate the item receive ``-np.inf``,\n        guaranteeing they are never selected.\n    \"\"\"\n    # Boolean mask: True where the bin can hold the item\n    fits = bins_remain_cap >= item\n\n    # Bin indices (0, 1, 2, \u2026)\n    idx = np.arange(bins_remain_cap.shape[0], dtype=float)\n\n    # Assign priority: -index for fitting bins, -inf otherwise\n    priorities = np.where(fits, -idx, -np.inf)\n\n    return priorities",
    "response_id": 10,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for the online Bin Packing Problem.\n\n    The function returns a priority score for each existing bin. The bin that yields the\n    smallest leftover capacity after the item is placed receives the highest priority.\n    Bins that cannot accommodate the item are assigned -inf (worst possible score).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores \u2013 same shape as `bins_remain_cap`. Higher values indicate a more\n        desirable bin for placement.\n    \"\"\"\n    # Ensure we work with float dtype (required for -inf)\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the unused space that would remain if the item were placed in each bin\n    gap = bins_remain_cap - item\n\n    # Valid bins are those where the item fits (gap >= 0)\n    valid_mask = gap >= 0\n\n    # Initialise all priorities to the worst possible score\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For feasible bins, priority is the negative of the remaining gap.\n    # The smaller the gap, the larger (closer to zero) the priority.\n    # This implements the Best\u2011Fit rule: prefer bins with minimal waste.\n    priorities[valid_mask] = -gap[valid_mask]\n\n    # ----------------------------------------------------------------------\n    # Creative tie\u2011breaker: add a tiny deterministic bias based on the bin index.\n    # This ensures reproducible selections when multiple bins have identical gaps.\n    # The bias is orders of magnitude smaller than any realistic gap, so it\n    # does not affect the primary ordering.\n    # ----------------------------------------------------------------------\n    eps = 1e-12\n    if valid_mask.any():\n        # Use the original order of indices as the deterministic source.\n        idx = np.arange(bins_remain_cap.size, dtype=float)\n        priorities[valid_mask] += eps * idx[valid_mask]\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes a priority for each bin using the Worst\u2011Fit strategy for the\n    online Bin Packing Problem.  The bin with the highest priority will be\n    chosen for the incoming item.\n\n    For each bin we calculate the amount of free capacity that would remain\n    after placing the item.  This value is used as the priority; bins that\n    cannot accommodate the item receive a sentinel negative value (\u2212\u221e) so\n    they will never be chosen.\n\n    Args:\n        item: The size of the item that must be placed.\n        bins_remain_cap: 1\u2011D numpy array holding the remaining capacity of each bin.\n\n    Returns:\n        A numpy array of floats, same shape as ``bins_remain_cap``.  Each element\n        represents the priority of the corresponding bin.\n    \"\"\"\n    # Ensure we are working with float values\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    item = float(item)\n\n    # Compute the remaining capacity if the item were placed\n    slack = bins_remain_cap - item\n\n    # Bins that cannot fit the item receive a very negative priority\n    # so they are never selected by argmax.\n    priorities = np.where(slack >= 0, slack, -np.inf)\n\n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns a priority score for placing an item into each bin based on the \n    Almost Full Fit strategy.\n\n    Strategy Overview\n    -----------------\n    *  Prefer bins that can accommodate the item.\n    *  Prefer bins that are already highly utilized so the new item will fill \n       the gap and keep most bins near capacity (Almost Full).\n    *  Combine the current occupancy of a bin with the remaining space after\n       the new item is added.  The score is higher for bins that are both\n       well\u2011filled and will become close to full.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (0 < item <= 1).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each bin.  Assumes each bin \n        has capacity of 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        Same shape as ``bins_remain_cap`` containing a score for each bin.  \n        The bin with the maximum score will be chosen.  Bins that cannot\n        accommodate the item receive ``-np.inf`` as their score.\n    \"\"\"\n    # Ensure we operate on a float array.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can hold the item.\n    feasible = bins_remain_cap >= item\n\n    # Initialise priorities: impossible placements get the lowest value.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        # Space that will remain after packing the item.\n        new_rem = bins_remain_cap[feasible] - item\n\n        # How full the bin is before adding the item.\n        # (1.0 - remaining capacity) is the fraction of capacity already used.\n        current_load = 1.0 - bins_remain_cap[feasible]\n\n        # Base score: more filled bins & less remaining space => higher score.\n        # Small epsilon prevents division by zero.\n        priorities[feasible] = current_load / (new_rem + 1e-8)\n\n        # *Almost Full* boost: give a 20\u202f% extra weight to bins that will be\n        # nearly full after the placement (remaining capacity <= 0.1).\n        almost_full_mask = new_rem <= 0.1\n        priorities[feasible][almost_full_mask] *= 1.2\n\n    return priorities",
    "response_id": 13,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact Fit First priority for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacities of existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher = more desirable).  The caller\n        should select the bin with the maximal score.  Bins that cannot fit\n        the item receive a large negative penalty, exact fits receive a very\n        high bonus, and among the remaining feasible bins the one leaving the\n        smallest leftover gets the highest priority.\n    \"\"\"\n    # Ensure we work with floats (copy not mandatory but safe)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialize all priorities to a very low value (unfeasible)\n    priorities = np.full(caps.shape, -np.inf, dtype=float)\n\n    # Feasibility mask: bins that have enough space for the item\n    feasible = caps >= item\n    if not feasible.any():\n        # No bin can accommodate the item; return penalties (caller can open a new bin)\n        return priorities\n\n    # Compute leftover space after placing the item in each feasible bin\n    leftover = caps - item\n\n    # Base priority: the smaller the leftover, the higher the priority.\n    # Using negative leftover makes an exact fit (leftover = 0) the highest\n    # among feasible bins (priority = 0), while larger leftovers give negative values.\n    priorities[feasible] = -leftover[feasible]\n\n    # Detect exact fits (within a tolerance) and give them a massive boost\n    exact_tolerance = 1e-9\n    exact_fit = feasible & np.isclose(leftover, 0.0, atol=exact_tolerance)\n    if exact_fit.any():\n        # Bonus large enough to dominate any other feasible priority\n        EXACT_FIT_BONUS = 1e9\n        priorities[exact_fit] = EXACT_FIT_BONUS\n\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing using Inverse Distance\n    and a simple utilization enhancement.\n\n    For each bin the function computes how close the remaining capacity\n    would be to a perfect fit if the item were placed there (Inverse\n    Distance).  It also mildly biases the selection toward bins that are\n    already more heavily utilized (smaller remaining capacity relative\n    to the best feasible bin).  Bins that cannot fit the item receive\n    a priority of -np.inf and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to place.\n    bins_remain_cap : np.ndarray\n        Current remaining capacities of all bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Remaining capacity after adding the item (distance from perfect fit)\n    dist = bins_remain_cap - item\n\n    # Boolean mask for bins that can accommodate the item\n    feasible = dist >= 0\n\n    # Base array: unusable bins get -inf priority\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can fit the item; downstream logic may open a new bin\n        return priorities\n\n    # Work with feasible bins only\n    dist_vals = dist[feasible]\n\n    # 1/(distance + eps) : larger value \u2192 tighter fit\n    proximity = 1.0 / (dist_vals + eps)\n\n    # Utilization factor: higher when the remaining capacity is relatively small\n    max_remaining = np.max(bins_remain_cap[feasible])\n    utilization = 1.0 - (dist_vals / (max_remaining + eps))\n    utilization = np.clip(utilization, 0.0, 1.0)\n\n    # Combine proximity and utilization.  A simple product gives the correct\n    # ranking: tight fits win, and among similar tight fits, prefer more used bins.\n    combined = proximity * utilization\n\n    # Write priorities back to the full array\n    priorities[feasible] = combined\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority based on a Sigmoid Fit Score for the online Bin Packing Problem.\n\n    A high score is given when the incoming item almost exactly fills the\n    remaining capacity of a bin (i.e., the residual space is minimal).  \n    The score is computed using a logistic (sigmoid) function applied to\n    the ratio of the item size to the remaining capacity.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin. Bins that cannot accommodate the\n        item receive -np.inf so they are never selected.\n    \"\"\"\n    # Can this item fit in a particular bin?\n    can_fit = bins_remain_cap >= item\n\n    # Avoid division by zero\n    eps = 1e-12\n    ratio = np.empty_like(bins_remain_cap, dtype=float)\n    ratio[can_fit] = item / (bins_remain_cap[can_fit] + eps)\n    ratio[~can_fit] = 0.0  # placeholder; will be overwritten\n\n    # Logistic parameters\n    k = 12.0          # steepness of the sigmoid\n    center = 0.5      # center (ratio) giving a medium score\n\n    # Compute the sigmoid fit score: higher when ratio ~ 1 (i.e., good fit)\n    priorities = 1.0 / (1.0 + np.exp(-k * (ratio - center)))\n\n    # Exclude bins that cannot accommodate the item\n    priorities[~can_fit] = -np.inf\n\n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Random-fit priority score, selecting uniformly at random among bins that can\n    accommodate the incoming item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item to be packed.\n    bins_remain_cap : np.ndarray\n        1-D array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    priorities : np.ndarray\n        Array of the same shape as ``bins_remain_cap``.  Feasible bins (those with\n        remaining capacity >= ``item``) receive a uniform random priority in\n        the range [0, 1).  Infeasible bins are given a sentinel value of\n        ``-np.inf`` so they are never chosen when the algorithm selects the\n        bin with the highest priority.\n    \"\"\"\n    # Find bins that can accommodate the item\n    feasible_mask = bins_remain_cap >= item\n\n    # Initialize all priorities to -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    # Assign random priorities only to feasible bins\n    if feasible_mask.any():\n        # Uniform random numbers in [0, 1) for the feasible bins\n        priorities[feasible_mask] = np.random.rand(feasible_mask.sum())\n\n    return priorities",
    "response_id": 17,
    "obj": 73.65376944555247,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\n# Global epsilon for the feasible level of exploration.\n# You can tune this value or expose it as a function argument.\n_EPSILON = 0.15\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem using an\n    epsilon\u2011greedy scheme.\n\n    With probability \u03b5 we explore: the feasible bins receive a random\n    priority, making the eventual choice essentially random.\n    With probability 1\u2011\u03b5 we exploit: we use a best\u2011fit heuristic that\n    prefers the bin that will have the smallest leftover capacity after\n    placing the item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the arriving item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; the caller should select the bin\n        with the highest score. Infeasible bins get -inf to guarantee they\n        are never chosen.\n    \"\"\"\n    # Bins that can actually accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise all priorities to -inf (i.e., unusable)\n    priorities = np.full(bins_remember_shape(bins_remain_cap.shape), -np.inf, dtype=float)\n\n    # If no bin can hold the item, return the -inf vector so the caller knows\n    # a new bin must be opened.\n    if not np.any(feasible):\n        return priorities\n\n    # Decide whether to explore or exploit this step\n    if np.random.rand() < _EPSILON:\n        # Exploration: random uniform scores for feasible bins\n        priorities[feasible] = np.random.rand(feasible.sum())\n    else:\n        # Exploitation: best\u2011fit (tightest) heuristic\n        # Compute leftover capacity after the item would be placed\n        leftover = bins_remain_cap[feasible] - item\n        # Higher priority for smaller leftover (tighter fit)\n        priorities[feasible] = -leftover\n\n    return priorities\n\n\ndef bins_remain_cap_shape(shape):\n    \"\"\"Utility to preserve the shape (including potential multidimensional input).\"\"\"\n    # For a 1\u2011D array we just return shape, but this helper allows future\n    # extension without touching the main routine.\n    return shape",
    "response_id": 18,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 37, in priority_v2\nNameError: name 'bins_remember_shape' is not defined. Did you mean: 'bins_remain_cap_shape'?\n11\n3\n"
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax\u2011based priority for each bin in online bin packing.\n\n    A bin with the item that would fill it most (i.e. leaving minimal\n    leftover) receives the highest probability.  Bins that cannot hold\n    the item are given a negligible priority.  The probabilities sum to\n    one, providing a convenient score for selecting the bin with the\n    maximum priority.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        A float array of the same shape as *bins_remain_cap* containing\n        a softmax priority for each bin.\n    \"\"\"\n    # Compute leftover after placing the item; bins that cannot fit will\n    # get a huge negative value to zero their probability after softmax.\n    leftover = bins_remain_cap - item\n    fit_val = np.where(leftover >= 0, -leftover, -1e9)\n\n    # Numerically stable softmax\n    max_fit = np.max(fit_val)\n    exp_fit = np.exp(fit_val - max_fit)\n\n    sum_exp = np.sum(exp_fit)\n    if sum_exp <= 0:            # no bin can accommodate the item\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    priority = exp_fit / sum_exp\n    return priority",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"First\u2011Fit priority for the online Bin Packing Problem.\n\n    The returned scores satisfy the First\u2011Fit rule:\n      * Bins that cannot hold ``item`` receive ``-np.inf`` so they will never be\n        chosen.\n      * Among the feasible bins, the one with the smallest index obtains the\n        highest score (i.e., the \u201cfirst\u201d bin).  If several bins share the same\n        index (theoretically impossible) a secondary tie\u2011breaker prefers the\n        tighter fit (smaller leftover capacity).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the current bins (1\u2011D array).\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.\n    \"\"\"\n    # Convert to float for arithmetic safety\n    caps = bins_remain_cap.astype(float)\n\n    # Feasibility mask: bin can accommodate the item\n    feasible = caps >= item\n\n    # Primary component: enforce the \"first\" bin rule.\n    # Bin 0 -> 0, Bin 1 -> -1, Bin 2 -> -2, ...  Higher value means higher priority.\n    idx = np.arange(caps.size, dtype=float)\n    primary = -idx\n\n    # Secondary component (tie\u2011breaker): prefer a tighter fit.\n    # The leftover after placing the item is (caps - item).\n    # Smaller leftover \u2192 larger secondary priority.\n    # Scale it by a tiny epsilon so it never overpowers the primary ordering.\n    epsilon = 1e-4\n    secondary = - (caps - item) * epsilon\n\n    # Combine components\n    scores = primary + secondary\n\n    # Infeasible bins should never be selected\n    scores = np.where(feasible, scores, -np.inf)\n\n    return scores",
    "response_id": 20,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best-Fit priority: Prefer the bin that leaves the smallest leftover capacity.\n\n    The function assigns a higher (less negative) priority to bins where the item fits\n    and the remaining space after placement is minimal. Bins that cannot accommodate\n    the item receive a very low priority (negative infinity) to exclude them.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each bin.\n\n    Returns:\n        np.ndarray of priorities, same shape as ``bins_remain_cap``.\n    \"\"\"\n    # Ensure floating point arithmetic to handle -inf safely\n    caps = bins_remain_cap.astype(float, copy=False)\n\n    # Compute the residual capacity if the item were placed in each bin\n    residual = caps - item\n\n    # Feasible bins: residual >= 0; priority is negative residual (smaller residual => higher priority)\n    # Infeasible bins: assign -inf so they will never be chosen.\n    priorities = np.where(residual >= 0, -residual, -np.inf)\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function implementing the Worst\u2011Fit heuristic for online\n    bin packing.\n\n    The worst\u2011fit strategy chooses the bin with the *largest* remaining\n    capacity that can still accommodate the incoming item.  We compute,\n    for each bin, the capacity that would remain after putting the\n    item.  Bins that cannot hold the item receive an effectively\n    minimal priority value (negative infinity), ensuring they are\n    never selected by a max\u2011arg operation.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin in use.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as `bins_remain_cap`.  Higher values\n        correspond to more desirable bins for the upcoming item.\n    \"\"\"\n    # Residual capacity after placing the item (negative if impossible)\n    remaining_after = bins_remain_cap - item\n\n    # Bins that cannot accommodate the item get a very low priority.\n    # Using -np.inf guarantees they will never be chosen by np.argmax.\n    low_priority = -np.inf\n    priorities = np.where(remaining_after >= 0, remaining_after, low_priority)\n\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements the \u201cAlmost Full Fit\u201d priority heuristic.\n\n    For bins that can accept the incoming item it assigns a score that\n    grows when the remaining capacity after placement is small,\n    i.e., the bin would become almost full.  A tiny additional bonus\n    is given to bins that would leave a slack of no more than a\n    fixed tolerance, encouraging the algorithm to first fill those\n    bins before starting a new one.\n\n    The function returns an array of scores; the largest score is the\n    preferred bin.\n    \"\"\"\n    # start with a very negative priority \u2013 this guarantees that bins\n    # which cannot accommodate the item will never be selected.\n    priorities = np.full_like(bins_remain_cap, -1e9, dtype=float)\n\n    # identify bins that can host the item\n    fit = bins_remain_cap >= item\n    if not np.any(fit):\n        # nothing can accept the item \u2013 the calling routine will open\n        # a new bin\n        return priorities\n\n    # remaining space after placing the item\n    slack = bins_remain_cap[fit] - item\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # Base priority: 1 / slack \u2192 smaller slack gives larger priority\n    base = 1.0 / (slack + eps)\n\n    # Almost\u2011full bonus \u2013 strengthen priority for bins that would\n    # have a slack smaller than a chosen tolerance\n    ALMOST_FULL_TOL = 0.05  # 5\u202f% of a unit\u2011size bin\n    bonus = 50.0            # tuned to be dominant over the 1/slack term\n    almost_full = slack <= ALMOST_FULL_TOL\n    base = np.where(almost_full, base + bonus, base)\n\n    # Store the computed priorities for the eligible bins\n    priorities[fit] = base\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First priority function for online Bin Packing.\n\n    The function awards the highest priority to bins that can accommodate the item with the smallest\n    remaining slack. Bins that cannot accommodate the item receive -inf priority, ensuring they are never\n    selected. When an exact fit (remaining capacity equals the item size) exists, a large bonus is added\n    to guarantee its selection.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D NumPy array containing the remaining capacity of each current bin.\n\n    Returns:\n        NumPy array of the same shape as ``bins_remain_cap`` with priority scores for each bin.\n    \"\"\"\n    # Compute how much space would remain after placing the item in each bin\n    slack = bins_remain_cap - item\n\n    # Determine which bins are feasible (slack >= 0)\n    feasible = slack >= 0\n\n    # Base priority: higher for smaller slack (i.e., tighter fit)\n    # Infeasible bins get -inf so they are never chosen.\n    priorities = np.where(feasible, -slack, -np.inf)\n\n    # Exact fit detection (accounting for floating\u2011point imprecision)\n    eps = 1e-12\n    exact_fit = np.abs(slack) <= eps\n\n    # Add a large constant to exact fits to dominate any other feasible bin\n    EXACT_FIT_BONUS = 1e9\n    priorities = np.where(exact_fit, priorities + EXACT_FIT_BONUS, priorities)\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    alpha: float = 10.0,\n    eps: float = 1e-9,\n) -> np.ndarray:\n    \"\"\"\n    Inverse Distance (Proximity Fit) priority for online bin packing.\n\n    For each bin we compute the remaining space after placing the item\n    (gap = remaining_capacity - item).  Bins that cannot accommodate the\n    item receive a priority of 0.  Among feasible bins the priority grows\n    as the gap shrinks, using a blend of an inverse distance term and an\n    exponential term to sharpen the preference for tight fits.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of existing bins.\n        alpha: Scaling factor for the exponential term (default 10.0).\n        eps: Small constant to avoid division by zero (default 1e-9).\n\n    Returns:\n        ndarray of same shape as `bins_remain_cap` containing priority scores.\n    \"\"\"\n    # Compute the free space left after inserting the item.\n    gap = bins_remain_cap - item\n\n    # Determine which bins can actually hold the item.\n    feasible = gap >= 0\n\n    # Initialise priority array with zeros (infeasible bins stay zero).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Inverse distance component: larger when the gap is smaller.\n    inv_gap = np.zeros_like(gap, dtype=float)\n    inv_gap[feasible] = 1.0 / (gap[feasible] + eps)\n\n    # Exponential sharpening component.\n    exp_term = np.exp(-alpha * gap[feasible])\n\n    # Blend both components (geometric mean keeps the scale balanced).\n    priorities[feasible] = np.sqrt(inv_gap[feasible] * exp_term)\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef sigmoid(x: np.ndarray) -> np.ndarray:\n    \"\"\"Numerically stable logistic function.\"\"\"\n    return 1.0 / (1.0 + np.exp(-x))\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, beta: float = 8.0) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score based priority function for online Bin Packing.\n\n    Bins that leave a smaller leftover capacity after placing the item\n    receive higher priority.  The residual (remaining capacity minus the\n    item size) is normalised and fed into a logistic (sigmoid)\n    transform so that bins with an almost perfect fit get a score close\n    to 0.5 while bins with a large remaining capacity get a score\n    approaching 0.  Bins that cannot accommodate the item receive a\n    priority of -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n    beta : float, optional\n        Steepness of the logistic curve; larger values lead to a\n        sharper differentiation between exact and loose fits.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin, same shape as `bins_remain_cap`.\n    \"\"\"\n    # Convert to array for safety\n    remain = np.asarray(bins_remain_cap, dtype=float)\n\n    # Default low priority for bins that cannot hold the item\n    priorities = np.full(remain.shape, -np.inf, dtype=float)\n\n    # Identify bins that can accept the item\n    fit_mask = remain >= item\n    if not np.any(fit_mask):\n        return priorities\n\n    # Remaining space after placing the item\n    diff = remain[fit_mask] - item\n\n    # Normalise the difference so that the sigmoid operates on a comparable scale.\n    # The maximum diff among candidate bins provides a good scale.\n    scale = diff.max() if diff.size else 1.0\n    scale = scale if scale > 0 else 1.0\n    norm_diff = diff / scale\n\n    # Logistic transform with negative sign to turn higher residuals into lower scores.\n    # Higher priority => smaller leftover after packing.\n    priorities[fit_mask] = sigmoid(-beta * norm_diff)\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\n# Random number generator (single instance for reproducibility across calls)\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Random Fit priority for online Bin Packing.\n\n    For each bin that can accommodate ``item`` a random priority in (0, 1) is\n    generated. Bins with insufficient remaining capacity receive a priority of\n    ``-np.inf`` so they are never selected. The bin with the highest priority\n    (i.e., a random feasible bin) will be chosen.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        A 1\u2011D array of the same shape as ``bins_remain_cap of priorities.\n    \"\"\"\n    # Feasibility mask: True where the item fits into the bin.\n    feasible = bins_remain_cap >= item\n\n    # Random priorities for all bins (uniform in (0, 1)).\n    random_priorities = _rng.random(bins_remain_cap.shape)\n\n    # Infeasible bins get -inf priority, guaranteeing they are never chosen.\n    priorities = np.where(feasible, random_priorities, -np.inf)\n\n    return priorities",
    "response_id": 27,
    "obj": 74.1723175109693,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function implementing an epsilon\u2011greedy strategy for online Bin Packing.\n\n    This strategy:\n        - Excludes bins that cannot accommodate the item.\n        - Prefers bins with the smallest slack (best fit) as exploitation.\n        - Occasionally injects random exploration noise with probability epsilon.\n        - The epsilon value adjusts with the proportion of fitting bins.\n\n    The returned priorities can be compared, and the bin with the maximum\n    priority score will be chosen.\n    \"\"\"\n    # Boolean mask of bins that can hold the item\n    fits = bins_remain_cap >= item\n\n    # Count how many bins are still feasible\n    num_fits = np.count_nonzero(fits)\n    bin_cnt = bins_remain_cap.size\n\n    # Adjust epsilon: more bins that fit -> explore a bit more; clamp between 0.05 and 0.3\n    eps = np.clip(0.3 - 0.2 * (num_fits / bin_cnt), 0.05, 0.3)\n\n    # Base exploitation score: best\u2011fit (smallest slack) => higher priority\n    slack = bins_remain_cap - item\n    exploit_score = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exploit_score[fits] = -slack[fits]  # lower slack -> larger (less negative) score\n\n    # Exploration score: uniform random noise on feasible bins\n    rng = np.random.default_rng()\n    explore_score = rng.uniform(0.0, 1.0, size=bins_remain_cap)\n    explore_score[~fits] = -np.inf\n\n    # Blend exploitation and exploration using epsilon\u2011greedy mixture\n    combined_score = (1.0 - eps) * exploit_score + eps * explore_score\n\n    return combined_score",
    "response_id": 28,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 33, in priority_v2\n    # Feasibility mask: only bins with non\u2011negative residual can host the item.\n  File \"numpy/random/_generator.pyx\", line 1100, in numpy.random._generator.Generator.uniform\n  File \"numpy/random/_common.pyx\", line 657, in numpy.random._common.cont\nValueError: maximum supported dimension for an ndarray is currently 64, found 5000\n13\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Softmax\u2011based fit priority for online bin packing.\n\n    For each bin a fit score is computed that favours a tight packing\n    (small remaining capacity after placing *item*).  The scores are\n    transformed by a softmax to obtain a probability\u2011like priority\n    distribution over the bins.  Bins that cannot host the item receive\n    a priority of zero.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priorities, one per bin.  Priorities sum to one over all\n        feasible bins and are zero when no bin can accommodate the item.\n    \"\"\"\n    # Temperature determines how deterministic the softmax is.\n    # Very low -> almost always pick the tightest fit.\n    # Higher -> smoother distribution over feasible bins.\n    temperature = 0.05\n\n    # Residual capacity after (hypothetically) placing the item.\n    residual = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative residual can host the item.\n    feasible = residual >= 0\n\n    # Initialise scores with -inf so that exp(-inf) = 0 for infeasible bins.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Fit score: tighter fit (smaller residual) \u2192 larger score.\n    # Using -residual / temperature makes tighter fits produce higher exponents.\n    scores[feasible] = -residual[feasible] / temperature\n\n    # Compute a numerically\u2011stable softmax.\n    if np.any(feasible):\n        max_score = np.max(scores[feasible])          # shift for stability\n        exp_scores = np.exp(scores - max_score)       # infeasible stay near zero\n        exp_scores[~feasible] = 0.0                    # guarantee exact zero\n        total = exp_scores.sum()\n        priorities = exp_scores / total if total > 0 else np.zeros_like(bins_remain_cap, dtype=np.float64)\n    else:\n        # No bin can accommodate the item \u2192 all priorities zero (caller may open a new bin).\n        priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]