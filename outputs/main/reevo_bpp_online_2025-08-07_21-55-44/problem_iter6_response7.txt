```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    exact_fit_bonus: float = 1e7,
    slack_decay: float = 12.0,
    jitter: float = 1e-12,
    atol: float = 1e-12,
) -> np.ndarray:
    """
    Compute a priority score for each bin in an online Bin Packing Problem.

    Higher scores indicate a more desirable bin for the incoming ``item``.
    The score is built from three simple components:

    1. **Negative slack** – bins that would waste less space get a higher base score.
    2. **Exponential slack bonus** – adds a smooth boost when the leftover
       (slack slack) is small, encouraging tight fits.
    3. **Exact‑fit bonus** – a large constant added when the item fits the bin
       exactly (within ``atol``).
    4. **Deterministic jitter** – a tiny decreasing term based on bin index
       to break ties consistently (favoring lower‑index bins).

    Infeasible bins (insufficient capacity) receive ``-inf`` priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently opened bin.
    exact_fit_bonus : float, optional
        Large bonus added for bins where the item fits exactly.
    slack_decay : float, optional
        Controls steepness of the exponential slack bonus.
    jitter : float, optional
        Magnitude of the deterministic tie‑breaker based on bin index.
    atol : float, optional
        Absolute tolerance for detecting an exact fit.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).
    """
    # Ensure a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Slack after placing the item
    slack = caps - item
    feasible = slack >= 0

    # Initialise all priorities to -inf (infeasible)
    priority = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – return early
        return priority

    # Base priority: negative slack (smaller leftover => larger score)
    base = -slack[feasible]

    # Normalised slack for exponential bonus
    max_slack = np.max(slack[feasible])
    norm_slack = slack[feasible] / (max_slack + atol)  # avoid div‑by‑zero
    slack_bonus = np.exp(-slack_decay * norm_slack)   # 1 when slack=0, decays with slack

    # Combine base and exponential bonus
    priority[feasible] = base + slack_bonus

    # Exact‑fit bonus (large incentive)
    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=atol=atol)
    priority[exact_fit_mask] += exact_fit_bonus

    # Deterministic tie‑breaker: favor lower‑index bins slightly
    priority += -np.arange(n_bins, dtype=float) * jitter

    return priority
```
