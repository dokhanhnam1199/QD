{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem.\n\n    The priority is composed of:\n      * Primary component: smaller bin index receives higher priority (first\u2011fit).\n      * Secondary component: tighter fit (smaller leftover capacity) breaks ties.\n      * Infeasible bins (cannot accommodate the item) receive -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).\n    \"\"\"\n    # Ensure we are working with a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask: bin can hold the item\n    feasible = caps >= item\n\n    # Primary ordering: smaller index => higher priority.\n    # Use negative indices: idx 0 -> 0, idx 1 -> -1, idx 2 -> -2, ...\n    idx = np.arange(caps.size, dtype=float)\n    primary = -idx\n\n    # Secondary ordering: tighter fit (smaller leftover) => higher priority.\n    leftover = caps - item                     # >= 0 for feasible bins\n    epsilon = 1e-6                             # tiny weight so primary dominates\n    secondary = -leftover * epsilon\n\n    # Combine components\n    scores = primary + secondary\n\n    # Mask infeasible bins\n    scores = np.where(feasible, scores, -np.inf)\n\n    return scores\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    exact_fit_bonus: float = 1e6,\n    slack_sigmoid_k: float = 10.0,\n    next_item_bonus: float = 0.1,\n    jitter: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    The function returns a score for each currently opened bin. Higher scores\n    indicate a more desirable bin for the incoming `item`.\n\n    Heuristics incorporated:\n    \u2022 Huge bonus for exact fits (remaining capacity after placement \u2248 0).\n    \u2022 Primary ranking by minimal waste (negative remaining slack).\n    \u2022 A sigmoid\u2011like exponential bonus for bins with small slack\n      (normalized waste \u2192 exp(-k\u00b7norm_slack)).\n    \u2022 Small extra bonus for bins that would still have enough room for another\n      item of size `item` after placement (anticipating the next item).\n    \u2022 Infeasible bins (insufficient capacity) receive -inf priority.\n    \u2022 Tiny index\u2011based jitter to break ties deterministically.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each opened bin.\n    exact_fit_bonus : float, optional\n        Large constant added when the item exactly fits a bin.\n    slack_sigmoid_k : float, optional\n        Controls the steepness of the exponential slack bonus.\n    next_item_bonus : float, optional\n        Small bonus for bins that would still accommodate another item of\n        size `item` after this placement.\n    jitter : float, optional\n        Magnitude of the deterministic tie\u2011breaker based on bin index.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``). The caller should\n        select the bin with the maximum priority.\n    \"\"\"\n    # Ensure input is a 1\u2011D NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = bins_remain_cap.size\n\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Compute remaining slack if the item were placed in each bin\n    slack = bins_remain_cap - item  # slack >= 0 => feasible\n\n    # Feasibility mask\n    feasible = slack >= 0\n\n    # Base priority: negative slack (higher = less waste) for feasible bins,\n    # -inf for infeasible bins.\n    base_priority = np.where(feasible, -slack, -np.inf)\n\n    # Normalized slack for feasible bins (to [0, 1])\n    norm_slack = np.zeros_like(slack)\n    if np.any(feasible):\n        max_slack = np.max(slack[feasible])\n        # Avoid division by zero when all feasible bins have zero slack\n        denom = max_slack + 1e-12\n        norm_slack[feasible] = slack[feasible] / denom\n\n    # Exponential slack bonus: high when slack is small, low when slack is large\n    slack_bonus = np.exp(-slack_sigmoid_k * norm_slack)\n\n    # Anticipate next item: give a tiny boost if the bin would still have\n    # enough capacity for another item of size `item` after this placement.\n    anticipate_bonus = np.where(feasible & (slack >= item), next_item_bonus, 0.0)\n\n    # Combine all components\n    priority = base_priority + slack_bonus + anticipate_bonus\n\n    # Add huge bonus for exact fits (within numerical tolerance)\n    exact_fit_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    priority[exact_fit_mask] += exact_fit_bonus\n\n    # Deterministic tie\u2011breaker: slightly favor lower\u2011index bins\n    tie_breaker = -np.arange(n_bins, dtype=float) * jitter\n    priority += tie_breaker\n\n    return priority\n\n[Reflection]\nLarge exact\u2011fit bonus, exponential slack penalty, next\u2011item anticipation, jitter tie\u2011breaking.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}