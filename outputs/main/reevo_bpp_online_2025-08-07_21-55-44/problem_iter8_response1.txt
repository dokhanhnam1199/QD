```python
import numpy as np
from typing import Optional, Union, Sequence

def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, Sequence[float]],
    *,
    bin_capacity: Optional[float] = None,
    lookahead_items: Optional[Union[np.ndarray, Sequence[float]]] = None,
    k_base: float = 8.0,
    alpha: float = 0.2,
    exact_fit_tol: float = 1e-12,
    exact_fit_bonus: float = 1e-3,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like of float
        Remaining capacity of each currently opened bin.
    bin_capacity : float, optional
        Fixed capacity of a bin.  If ``None``, the maximum observed remaining
        capacity plus a tiny epsilon is used as a surrogate.
    lookahead_items : array‑like of float, optional
        Sizes of future items.  Bins that can still accommodate more of these
        items after the current placement receive a multiplicative boost.
    k_base : float, default 8.0
        Base steepness for the sigmoid.  It is scaled by bin fullness.
    alpha : float, default 0.2
        Strength of the look‑ahead boost (0 ≤ alpha ≤ 1).  The boost is
        multiplicative: ``score *= (1 + alpha * fit_ratio)``.
    exact_fit_tol : float, default 1e-12
        Tolerance for detecting an exact fit (gap ≈ 0).
    exact_fit_bonus : float, default 1e-3
        Small additive bonus for exact‑fit bins (default is modest to avoid
        huge constant bonuses).
    random_state : int or np.random.Generator, optional
        Seed or generator for a tiny random tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  Infeasible bins
        (remaining capacity < ``item``) receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 1. Prepare inputs
    # ------------------------------------------------------------------
    bins = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = bins.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Infer the true bin capacity if not supplied.
    if bin_capacity is None:
        # Use the largest observed remaining capacity as a proxy.
        # Adding a tiny epsilon avoids division by zero in degenerate cases.
        bin_capacity = float(np.max(bins) + 1e-9)
    else:
        bin_capacity = float(bin_capacity)

    # ------------------------------------------------------------------
    # 2. Feasibility mask
    # ------------------------------------------------------------------
    feasible = bins >= item - exact_fit_tol  # allow tiny tolerance
    if not np.any(feasible:
        # No bin can host the item – return -inf for all entries.
        return np.full_like(bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # 3. Gaps and normalized gaps
    # ------------------------------------------------------------------
    gaps = bins - item                     # >= 0 for feasible bins
    norm_gaps = np.clip(gaps / bin_capacity, 0.0, 1.0)  # scale to [0, 1]

    # ------------------------------------------------------------------
    # 4. Dynamic sigmoid steepness based on bin fullness
    # ------------------------------------------------------------------
    # Fullness = used capacity / total capacity (0 = empty, 1 = full)
    fullness = (bin_capacity - bins) / bin_capacity
    k = k_base * (1.0 + fullness)         # steeper for fuller bins

    # ------------------------------------------------------------------
    # 5. Sigmoid score on normalized gaps (higher score = tighter fit)
    # ------------------------------------------------------------------
    # For the sigmoid we need a reference point; we use the maximum gap
    # among feasible bins.  Adding a tiny epsilon ensures a positive shift.
    eps = 1e-12
    max_gap = np.max(norm_gaps[feasible])
    shift = max_gap - norm_gaps[feasible] + eps   # larger => tighter fit

    exponent = k[feasible] * shift
    # Clip exponent to avoid overflow/underflow in exp().
    exponent = np.clip(exponent, -700.0, 700.0)

    # Sigmoid mapping: values in (0.5, 1) with exact fits approaching 1.
    scores = 1.0 / (1.0 + np.exp(-exponent))

    # ------------------------------------------------------------------
    # 6. Small bonus for exact fits (gap ≈ 0)
    # ------------------------------------------------------------------
    exact_fit_mask = feasible & (np.abs(gaps) <= exact_fit_tol)
    scores[exact_fit_mask] += exact_fit_bonus

    # ------------------------------------------------------------------
    # 7. Tiny random tie‑breaker
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    scores += rng.uniform(0.0, 1e-6, size=scores.shape)

    # ------------------------------------------------------------------
    # 8. Optional look‑ahead boost
    # ------------------------------------------------------------------
    if lookahead_items is not None:
        lookahead = np.asarray(lookahead_items, dtype=float).ravel()
    if lookahead.size > 0:
            # Remaining capacity after placing the current item.
            remaining_after = gaps[feasible]
            # Count how many look‑ahead items each bin could still fit.
            fits = (remaining_after[:, None] >= lookahead[None, :]).sum(axis=1)
            fit_ratio = fits.astype(float) / float(lookahead.size)   # [0, 1]
            # Apply multiplicative boost.
            boost = 1.0 + np.clip(alpha, 0.0, 1.0) * fit_ratio
            scores *= boost

    # ------------------------------------------------------------------
    # 9. Assemble final priority vector
    # ------------------------------------------------------------------
    priority = np.full_like(bins, -np.inf, dtype=float)
    priority[feasible] = scores

    return priority
```
