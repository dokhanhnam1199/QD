```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    bin_capacity: float = 1.0,
    exact_fit_bonus: float = 1e6,
    slack_weight: float = 1.0,
    new_bin_penalty: float = 0.2,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    The function evaluates each currently open bin and a virtual new bin.
    Higher returned values indicate more desirable bins.

    - Exact‑fit bins receive a large ``exact_fit_bonus``.
    - For other feasible bins the priority decreases linearly with the
      normalized slack (waste / bin_capacity).  Slack is multiplied by
      ``slack_weight``; larger slack => lower priority.
    - Opening a new bin is penalised by ``new_bin_penalty`` proportionally to its
      expected waste.
    - A tiny deterministic tie‑breaker (``epsilon``) favours lower indices.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of already opened bins.
    bin_capacity : float, optional
        Fixed capacity of every bin (default 1.0).
    exact_fit_bonus : float, optional
        Bonus added to a bin that would be exactly filled (default 1e6).
    slack_weight : float, optional
        Linear weight for normalized slack (default 1.0).
    new_bin_penalty : float, optional
        Multiplicative penalty applied to the waste of a newly opened bin
        (default 0.2 → 20 % extra waste (default 0.2 → 20 % extra waste cost).
    epsilon : float, optional
        Tiny value for deterministic tie‑breaking (default 1e‑12).

    Returns
    -------
    np.ndarray
        Array of priority scores with shape ``(len(bins_remain_cap) + 1,)``.
        The last entry corresponds to the virtual new bin.
    """
    # Ensure NumPy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Waste (remaining capacity after placement) for each existing bin
    waste = bins_remain_cap - item
    feasible = waste >= 0

    # Normalized slack: waste divided by the fixed bin capacity
    slack = np.where(feasible, waste / bin_capacity, np.inf)

    # Base priority: negative weighted slack (smaller slack → higher priority)
    base_priority = np.where(feasible, -slack_weight * slack, -np.inf)

    # Exact‑fit bonus (within tolerance)
    exact_fit_mask = np.isclose(waste, 0.0, atol=epsilon)
    base_priority = np.where(exact_fit_mask, base_priority + exact_fit_bonus, base_priority)

    # Deterministic tie‑breaker: tiny advantage for lower indices
    tie_breaker = -np.arange(bins_remain_cap.size) * epsilon
    base_priority = base_priority + tie_breaker

    # ---------- Virtual new bin ----------
    waste_new = bin_capacity - item
    if waste_new < 0:
        new_bin_priority = -np.inf
    else:
        slack_new = waste_new / bin_capacity
        # Apply penalty proportional to expected waste
        new_bin_priority = -slack_weight * slack_new * (1.0 + new_bin_penalty)
        # Exact‑fit bonus for a perfect new bin
        if np.isclose(waste_new, 0.0, atol=epsilon):
            new_bin_priority += exact_fit_bonus
        # Tie‑breaker for the virtual bin (give it a neutral index after all real bins)
        new_bin_priority += -bins_remain_cap.size * epsilon

    # Append virtual new bin priority as the last element
    priorities = np.append(base_priority, new_bin_priority)

    return priorities
```
