[
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the exponential of the negative rank of the tour length, favoring shorter tours more strongly.",
          "code": "import numpy as np\n\ndef heuristics_v3(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the exponential of the negative rank of the tour length, favoring shorter tours more strongly.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        tour_lengths.append(tour_length)\n        tours.append(tour)\n\n    # Rank the tour lengths\n    ranks = np.argsort(tour_lengths)\n\n    # Update heuristics matrix based on rank\n    for i in range(num_samples):\n        tour = tours[ranks[i]]\n        weight = np.exp(-i / (num_samples / 5))  # Exponential rank weighting\n        for j in range(n):\n            node1 = tour[j]\n            node2 = tour[j+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.71559,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple tours using a nearest neighbor approach with random starting nodes and incorporates 2-opt swaps for local optimization, weighting edge frequencies by the inverse rank of tour lengths to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates multiple tours using a nearest neighbor approach with random starting nodes and incorporates 2-opt swaps for local optimization, weighting edge frequencies by the inverse rank of tour lengths to construct a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        # Generate a tour using nearest neighbor\n        start_node = np.random.randint(n)\n        unvisited = list(range(n))\n        tour = [start_node]\n        unvisited.remove(start_node)\n\n        while unvisited:\n            current_node = tour[-1]\n            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])\n            tour.append(nearest_neighbor)\n            unvisited.remove(nearest_neighbor)\n\n        tour.append(start_node)\n        tour = np.array(tour)\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0.0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        \n        tour_lengths.append(tour_length)\n        tours.append(tour)\n\n    # Rank the tour lengths\n    ranks = np.argsort(np.argsort(tour_lengths)) + 1\n\n    # Update heuristics matrix with weight based on rank\n    for idx in range(num_samples):\n        tour = tours[idx]\n        rank = ranks[idx]\n        weight = 1.0 / rank\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n    \n    # Normalize heuristics matrix\n    total_weight = np.sum([1.0 / r for r in ranks])\n    if total_weight > 0:\n        heuristics_matrix /= total_weight\n    return heuristics_matrix",
          "objective": 5.71889,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours, with a modified scoring function that prioritizes edges in very short tours more aggressively.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours, with a modified scoring function that prioritizes edges in very short tours more aggressively.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Update heuristics matrix, weighting by squared inverse of tour length to prioritize short tours more\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1.0 / (tour_length * tour_length)\n            heuristics_matrix[node2, node1] += 1.0 / (tour_length * tour_length)\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.72212,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions, with edge weights inversely proportional to their appearance rank in sorted edge lists based on tour length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions, with edge weights inversely proportional to their appearance rank in sorted edge lists based on tour length.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        tour_lengths.append(tour_length)\n        tours.append(tour)\n\n    # Sort tours by length\n    sorted_indices = np.argsort(tour_lengths)\n\n    for rank, index in enumerate(sorted_indices):\n        tour = tours[index]\n        # Weight based on rank (better tours have higher weight)\n        weight = (num_samples - rank) / num_samples  # Linear rank weighting\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.72421,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions, with edge weights based on an exponential function of their rank in sorted edge lists based on tour length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions, with edge weights based on an exponential function of their rank in sorted edge lists based on tour length.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        tour_lengths.append(tour_length)\n        tours.append(tour)\n\n    # Sort tours by length\n    sorted_indices = np.argsort(tour_lengths)\n\n    for rank, index in enumerate(sorted_indices):\n        tour = tours[index]\n        # Weight based on rank (better tours have higher weight)\n        weight = np.exp(-rank / (num_samples / 10))  # Exponential rank weighting\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.72519,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the rank of the tour length, favoring shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the rank of the tour length, favoring shorter tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    tour_lengths = []\n    tours = []\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        tour_lengths.append(tour_length)\n        tours.append(tour)\n\n    # Rank the tour lengths\n    ranks = np.argsort(tour_lengths)\n\n    # Update heuristics matrix based on rank\n    for i in range(num_samples):\n        tour = tours[ranks[i]]\n        weight = (num_samples - i) / num_samples  # Linear rank weighting\n        for j in range(n):\n            node1 = tour[j]\n            node2 = tour[j+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.72842,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.74068,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on an exponential score function of the tour length, heavily favoring shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on an exponential score function of the tour length, heavily favoring shorter tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Weight based on exponential of negative tour length (shorter tours have higher weight)\n        weight = np.exp(-tour_length / n)\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.75362,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours, and applies a sigmoid function to the inverse tour length before weighting.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours, and applies a sigmoid function to the inverse tour length before weighting.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Apply sigmoid function to the inverse of tour length\n        weight = 1.0 / (1 + np.exp(tour_length - np.mean([np.sum(distance_matrix[i]) for i in range(n)])))\n\n        # Update heuristics matrix, weighting by inverse of tour length\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.75703,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the tour length, favoring shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the tour length, favoring shorter tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Weight based on inverse tour length (shorter tours have higher weight)\n        weight = 1.0 / tour_length\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.76276,
          "other_inf": null
     }
]