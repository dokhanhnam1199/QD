[
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies in the improved solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies in the improved solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])  # Return to start\n\n        # Improve the tour using 2-opt swaps\n        improved_tour = tour.copy()\n        for i in range(n):\n            for j in range(i + 2, n + 1):\n                new_tour = np.concatenate((improved_tour[:i], improved_tour[i:j][::-1], improved_tour[j:]))\n                \n                current_cost = sum(distance_matrix[improved_tour[k], improved_tour[k+1]] for k in range(n))\n                new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n                \n                if new_cost < current_cost:\n                    improved_tour = new_tour\n                    \n        # Update heuristics matrix\n        for i in range(n):\n            node1 = improved_tour[i]\n            node2 = improved_tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.8302,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            # Probabilistically choose between nearest neighbor and random selection\n            if np.random.rand() < 0.7:  # Favor nearest neighbor\n                nearest_neighbor = -1\n                min_distance = np.inf\n                for neighbor in unvisited_nodes:\n                    distance = distance_matrix[current_node, neighbor]\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_neighbor = neighbor\n                next_node = nearest_neighbor\n            else:  # Random selection\n                next_node = np.random.choice(list(unvisited_nodes))\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1 #symmetric\n            current_node = next_node\n        \n        # Complete the tour\n        heuristics_matrix[current_node, tour[0]] += 1\n        heuristics_matrix[tour[0], current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.01684,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by assigning higher probabilities to shorter edges and edges connected to nodes with high degree, based on sampled solutions obtained by a nearest neighbor search.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs a heuristics matrix by assigning higher probabilities to shorter edges and edges connected to nodes with high degree, based on sampled solutions obtained by a nearest neighbor search.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = -1\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                if distance_matrix[current_node, neighbor] < min_distance:\n                    min_distance = distance_matrix[current_node, neighbor]\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        tour.append(start_node)\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n            \n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    # Incorporate distance information\n    heuristics_matrix = heuristics_matrix / (distance_matrix + 1e-9)  # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 6.055,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by assigning higher probabilities to shorter edges and edges connected to nodes with low degree, based on sampled solutions obtained by a nearest neighbor search, also with a degree centrality component and a random factor.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs a heuristics matrix by assigning higher probabilities to shorter edges and edges connected to nodes with low degree, based on sampled solutions obtained by a nearest neighbor search, also with a degree centrality component and a random factor.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    # Calculate degree centrality\n    degree_centrality = np.sum(1 / (distance_matrix + 1e-9), axis=0)\n    degree_centrality = degree_centrality / np.sum(degree_centrality)  # Normalize\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = -1\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                if distance_matrix[current_node, neighbor] < min_distance:\n                    min_distance = distance_matrix[current_node, neighbor]\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        tour.append(start_node)\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n            \n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    # Incorporate distance information and degree centrality and a random factor\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                heuristics_matrix[i, j] = (heuristics_matrix[i, j] / (distance_matrix[i, j] + 1e-9)) * (1 - degree_centrality[i]) * (1 - degree_centrality[j]) + np.random.rand()*0.01\n            else:\n                heuristics_matrix[i, j] = 0\n\n    return heuristics_matrix",
          "objective": 6.09679,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by iteratively constructing tours using a weighted combination of shortest edge selection and a Metropolis-Hastings-inspired acceptance criterion, favoring edges that consistently lead to shorter overall tour lengths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge importance by iteratively constructing tours using a weighted combination of shortest edge selection and a Metropolis-Hastings-inspired acceptance criterion, favoring edges that consistently lead to shorter overall tour lengths.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n    temperature = 1.0  # Initial temperature for Metropolis-Hastings\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            # Calculate probabilities based on inverse distance and temperature\n            probabilities = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = np.exp(-distance_matrix[current_node, neighbor] / temperature)\n            probabilities /= np.sum(probabilities)  # Normalize\n\n            # Select the next node using the Metropolis-Hastings-inspired probabilities\n            next_node = np.random.choice(range(n), p=probabilities)\n            if next_node not in unvisited_nodes:\n               valid_neighbors = list(unvisited_nodes)\n               next_node = valid_neighbors[np.argmin([distance_matrix[current_node,neighbor] for neighbor in valid_neighbors])]\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        tour.append(start_node)  # Return to starting node\n\n        # Update heuristics matrix based on tour edges\n        tour_length = 0\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n            tour_length += distance_matrix[node1, node2]\n\n        # Anneal the temperature (reduce it over time)\n        temperature *= 0.95\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.10284,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies in the improved solutions, but modifies the 2-opt swap to only consider swaps that result in a shorter path and incorporates a simulated annealing-like acceptance probability.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies in the improved solutions, but modifies the 2-opt swap to only consider swaps that result in a shorter path and incorporates a simulated annealing-like acceptance probability.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    temperature = 1.0\n    cooling_rate = 0.95\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])  # Return to start\n\n        # Improve the tour using 2-opt swaps\n        improved_tour = tour.copy()\n        for i in range(n):\n            for j in range(i + 2, n + 1):\n                new_tour = np.concatenate((improved_tour[:i], improved_tour[i:j][::-1], improved_tour[j:]))\n                \n                current_cost = sum(distance_matrix[improved_tour[k], improved_tour[k+1]] for k in range(n))\n                new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n                \n                cost_diff = new_cost - current_cost\n                if cost_diff < 0:\n                    improved_tour = new_tour\n                else:\n                    # Simulated annealing-like acceptance\n                    if np.random.rand() < np.exp(-cost_diff / temperature):\n                        improved_tour = new_tour\n        temperature *= cooling_rate            \n        # Update heuristics matrix\n        for i in range(n):\n            node1 = improved_tour[i]\n            node2 = improved_tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.11854,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by a hybrid approach of nearest neighbor and random edge swaps.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by a hybrid approach of nearest neighbor and random edge swaps.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Nearest Neighbor tour\n        start_node = np.random.randint(n)\n        unvisited_nodes = list(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n        tour = [start_node]\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        tour.append(start_node)\n        tour = np.array(tour)\n        \n        # Improve with random edge swaps\n        num_swaps = n // 2\n        for _ in range(num_swaps):\n            i, j = np.random.choice(n, 2, replace=False)\n            \n            if i > j:\n              i, j = j, i\n            \n            new_tour = np.concatenate((tour[:i], tour[i:j+1][::-1], tour[j+1:]))\n            \n            current_cost = sum(distance_matrix[tour[k], tour[k+1]] for k in range(n))\n            new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n            \n            if new_cost < current_cost:\n                tour = new_tour\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.12054,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively refines edge probabilities by combining information from short sub-tours and global tour evaluations, encouraging exploration of promising edges while maintaining diversity.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively refines edge probabilities by combining information from short sub-tours and global tour evaluations, encouraging exploration of promising edges while maintaining diversity.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones_like(distance_matrix)\n\n    num_iterations = 50\n    num_subtours = 20\n    subtour_length = n // 3\n\n    for _ in range(num_iterations):\n        for _ in range(num_subtours):\n            start_node = np.random.randint(n)\n            nodes = [start_node]\n            remaining_nodes = list(range(n))\n            remaining_nodes.remove(start_node)\n\n            # Construct a subtour greedily\n            current_node = start_node\n            for _ in range(min(subtour_length - 1, len(remaining_nodes))):\n                nearest_neighbor = -1\n                min_distance = np.inf\n                for neighbor in remaining_nodes:\n                    distance = distance_matrix[current_node, neighbor]\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_neighbor = neighbor\n\n                if nearest_neighbor != -1:\n                    nodes.append(nearest_neighbor)\n                    remaining_nodes.remove(nearest_neighbor)\n                    current_node = nearest_neighbor\n                else:\n                    break\n                \n            # Evaluate the subtour length\n            subtour_length_val = 0\n            for i in range(len(nodes) - 1):\n                subtour_length_val += distance_matrix[nodes[i], nodes[i+1]]\n            if len(nodes) > 1:\n                subtour_length_val += distance_matrix[nodes[-1], nodes[0]]\n\n            # Update heuristics based on subtour length\n            if len(nodes) > 1:\n                for i in range(len(nodes) - 1):\n                    heuristics_matrix[nodes[i], nodes[i+1]] += 1 / (subtour_length_val + 1e-6)\n                    heuristics_matrix[nodes[i+1], nodes[i]] += 1 / (subtour_length_val + 1e-6)\n                heuristics_matrix[nodes[-1], nodes[0]] += 1 / (subtour_length_val + 1e-6)\n                heuristics_matrix[nodes[0], nodes[-1]] += 1 / (subtour_length_val + 1e-6)\n\n        # Global tour evaluation to regularize\n        tour = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        \n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i+1]] += 0.1 / (tour_length + 1e-6)\n            heuristics_matrix[tour[i+1], tour[i]] += 0.1 / (tour_length + 1e-6)\n        heuristics_matrix[tour[-1], tour[0]] += 0.1 / (tour_length + 1e-6)\n        heuristics_matrix[tour[0], tour[-1]] += 0.1 / (tour_length + 1e-6)\n\n    return heuristics_matrix",
          "objective": 6.15936,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies and edge lengths from multiple solutions generated by a hybrid approach of nearest neighbor and random edge swaps, penalizing longer edges.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies and edge lengths from multiple solutions generated by a hybrid approach of nearest neighbor and random edge swaps, penalizing longer edges.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Nearest Neighbor tour\n        start_node = np.random.randint(n)\n        unvisited_nodes = list(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n        tour = [start_node]\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        tour.append(start_node)\n        tour = np.array(tour)\n        \n        # Improve with random edge swaps\n        num_swaps = n // 2\n        for _ in range(num_swaps):\n            i, j = np.random.choice(n, 2, replace=False)\n            \n            if i > j:\n              i, j = j, i\n            \n            new_tour = np.concatenate((tour[:i], tour[i:j+1][::-1], tour[j+1:]))\n            \n            current_cost = sum(distance_matrix[tour[k], tour[k+1]] for k in range(n))\n            new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n            \n            if new_cost < current_cost:\n                tour = new_tour\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            edge_length = distance_matrix[node1, node2]\n            heuristics_matrix[node1, node2] += 1 / (1 + edge_length)  # Penalize longer edges\n            heuristics_matrix[node2, node1] += 1 / (1 + edge_length)\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.20013,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs stochastic sampling to construct tours by iteratively adding the edge with the highest heuristic value from a matrix that combines distance and edge frequency information, thereby estimating edge importance for TSP solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm employs stochastic sampling to construct tours by iteratively adding the edge with the highest heuristic value from a matrix that combines distance and edge frequency information, thereby estimating edge importance for TSP solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            heuristic_values = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                heuristic_values[neighbor] = 0.8/(distance_matrix[current_node, neighbor]+1e-6) + 0.2*heuristics_matrix[current_node, neighbor]\n\n            next_node = np.argmax(heuristic_values)\n            \n            if next_node not in unvisited_nodes:\n                available_nodes = list(unvisited_nodes)\n                next_node = available_nodes[np.random.randint(len(available_nodes))]\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1\n            current_node = next_node\n\n        heuristics_matrix[current_node, tour[0]] += 1\n        heuristics_matrix[tour[0], current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.24736,
          "other_inf": null
     }
]