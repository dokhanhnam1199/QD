[
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.74068,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the tour length, favoring shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple 2-opt improved solutions based on the tour length, favoring shorter tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Weight based on inverse tour length (shorter tours have higher weight)\n        weight = 1.0 / tour_length\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.76276,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, weighting solutions by their inverse total length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, weighting solutions by their inverse total length.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    total_weights = 0.0\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0.0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Calculate weight (inverse of tour length)\n        weight = 1.0 / tour_length if tour_length > 0 else 0.0\n        total_weights += weight\n\n        # Update heuristics matrix with weight\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += weight\n            heuristics_matrix[node2, node1] += weight\n\n    # Normalize heuristics matrix\n    if total_weights > 0:\n        heuristics_matrix /= total_weights\n    return heuristics_matrix",
          "objective": 5.78552,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps, then applies a local search based on insertion moves, and records edge frequencies in the improved solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps, then applies a local search based on insertion moves, and records edge frequencies in the improved solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])  # Return to start\n\n        # Improve the tour using 2-opt swaps\n        improved_tour = tour.copy()\n        for i in range(n):\n            for j in range(i + 2, n + 1):\n                new_tour = np.concatenate((improved_tour[:i], improved_tour[i:j][::-1], improved_tour[j:]))\n                \n                current_cost = sum(distance_matrix[improved_tour[k], improved_tour[k+1]] for k in range(n))\n                new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n                \n                if new_cost < current_cost:\n                    improved_tour = new_tour\n\n        # Improve the tour using insertion\n        insertion_tour = improved_tour.copy()\n        for i in range(1, n):\n            for j in range(1, n):\n                if i == j:\n                    continue\n\n                temp_tour = insertion_tour.tolist()\n                node_to_move = temp_tour.pop(i)\n                temp_tour.insert(j, node_to_move)\n                temp_tour = np.array(temp_tour)\n\n                current_cost = sum(distance_matrix[insertion_tour[k], insertion_tour[k+1]] for k in range(n))\n                new_cost = sum(distance_matrix[temp_tour[k], temp_tour[k+1]] for k in range(n))\n                \n                if new_cost < current_cost:\n                    insertion_tour = temp_tour\n\n        # Update heuristics matrix\n        for i in range(n):\n            node1 = insertion_tour[i]\n            node2 = insertion_tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.79386,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 2-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random initial tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])\n\n        # Improve the tour using 2-opt swaps\n        improved = True\n        while improved:\n            improved = False\n            for i in range(1, n):\n                for j in range(i + 1, n + 1):\n                    if i != j:\n                        current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]]\n                        new_cost = distance_matrix[tour[i - 1], tour[j - 1]] + distance_matrix[tour[i], tour[j]]\n\n                        if new_cost < current_cost:\n                            tour[i:j] = tour[i:j][::-1]\n                            improved = True\n\n        # Calculate tour length\n        tour_length = 0\n        for i in range(n):\n            tour_length += distance_matrix[tour[i], tour[i+1]]\n\n        # Update heuristics matrix, weighting by inverse of tour length\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1.0 / tour_length\n            heuristics_matrix[node2, node1] += 1.0 / tour_length\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.80074,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge importance by iteratively constructing tours using a weighted combination of shortest edge selection and a Metropolis-Hastings-inspired acceptance criterion, favoring edges that consistently lead to shorter overall tour lengths while incorporating a local search component to refine tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge importance by iteratively constructing tours using a weighted combination of shortest edge selection and a Metropolis-Hastings-inspired acceptance criterion, favoring edges that consistently lead to shorter overall tour lengths while incorporating a local search component to refine tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n    temperature = 1.0  # Initial temperature for Metropolis-Hastings\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            # Calculate probabilities based on inverse distance and temperature\n            probabilities = np.zeros(n)\n            for neighbor in unvisited_nodes:\n                probabilities[neighbor] = np.exp(-distance_matrix[current_node, neighbor] / temperature)\n            probabilities /= np.sum(probabilities)  # Normalize\n\n            # Select the next node using the Metropolis-Hastings-inspired probabilities\n            next_node = np.random.choice(range(n), p=probabilities)\n            if next_node not in unvisited_nodes:\n               valid_neighbors = list(unvisited_nodes)\n               next_node = valid_neighbors[np.argmin([distance_matrix[current_node,neighbor] for neighbor in valid_neighbors])]\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        tour.append(start_node)  # Return to starting node\n\n        # 2-opt local search\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                new_tour = tour[:i] + tour[i:j][::-1] + tour[j:]\n                current_length = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n                original_length = sum(distance_matrix[tour[k], tour[k+1]] for k in range(n))\n                if current_length < original_length:\n                    tour = new_tour\n                    \n        # Update heuristics matrix based on tour edges\n        tour_length = 0\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n            tour_length += distance_matrix[node1, node2]\n\n        # Anneal the temperature (reduce it over time)\n        temperature *= 0.95\n\n    # Normalize heuristics matrix\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.81303,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies in the improved solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies in the improved solutions.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour = np.append(tour, tour[0])  # Return to start\n\n        # Improve the tour using 2-opt swaps\n        improved_tour = tour.copy()\n        for i in range(n):\n            for j in range(i + 2, n + 1):\n                new_tour = np.concatenate((improved_tour[:i], improved_tour[i:j][::-1], improved_tour[j:]))\n                \n                current_cost = sum(distance_matrix[improved_tour[k], improved_tour[k+1]] for k in range(n))\n                new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))\n                \n                if new_cost < current_cost:\n                    improved_tour = new_tour\n                    \n        # Update heuristics matrix\n        for i in range(n):\n            node1 = improved_tour[i]\n            node2 = improved_tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 5.8302,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by a random sampling approach with a nearest neighbor initialization and adaptive edge weights.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by a random sampling approach with a nearest neighbor initialization and adaptive edge weights.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    visibility_matrix = 1 / (distance_matrix + 1e-9)\n    alpha = 0.5  # Reduced influence of pheromones\n    beta = 3    # Increased influence of visibility (distance)\n    num_ants = n // 2 # Reduced number of ants\n    num_iterations = 50 # Reduced number of iterations\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    edge_weights = np.ones_like(distance_matrix) # Initialize edge weights\n\n    for _ in range(num_iterations):\n        tours = []\n        for ant in range(num_ants):\n            start_node = ant % n\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            tour = [start_node]\n            current_node = start_node\n\n            while unvisited_nodes:\n                probabilities = np.zeros(n)\n                for neighbor in unvisited_nodes:\n                    probabilities[neighbor] = (pheromone_matrix[current_node, neighbor]**alpha) * (visibility_matrix[current_node, neighbor]**beta) * edge_weights[current_node, neighbor]\n                probabilities /= np.sum(probabilities[list(unvisited_nodes)])\n\n                next_node = np.random.choice(n, p=probabilities)\n                tour.append(next_node)\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            tours.append(tour)\n\n        # Update pheromone matrix\n        pheromone_matrix *= 0.9  # Evaporation\n        for tour in tours:\n            tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                pheromone_matrix[node1, node2] += 1 / tour_length\n                pheromone_matrix[node2, node1] += 1 / tour_length\n        \n        for tour in tours:\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n                #Adaptive edge weight update\n                edge_weights[node1, node2] *= 1.1\n                edge_weights[node2, node1] *= 1.1\n        \n        edge_weights = np.clip(edge_weights, 0.1, 10) #Clip edge weights to prevent extreme values\n    \n    heuristics_matrix /= (num_ants * num_iterations)\n\n    return heuristics_matrix",
          "objective": 5.89005,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by an ant colony optimization approach with a nearest neighbor initialization.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by an ant colony optimization approach with a nearest neighbor initialization.}\"\"\"\n    n = distance_matrix.shape[0]\n    pheromone_matrix = np.ones_like(distance_matrix)\n    visibility_matrix = 1 / (distance_matrix + 1e-9)\n    alpha = 1\n    beta = 2\n    num_ants = n\n    num_iterations = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_iterations):\n        tours = []\n        for ant in range(num_ants):\n            start_node = ant % n\n            unvisited_nodes = set(range(n))\n            unvisited_nodes.remove(start_node)\n            tour = [start_node]\n            current_node = start_node\n\n            while unvisited_nodes:\n                probabilities = np.zeros(n)\n                for neighbor in unvisited_nodes:\n                    probabilities[neighbor] = (pheromone_matrix[current_node, neighbor]**alpha) * (visibility_matrix[current_node, neighbor]**beta)\n                probabilities /= np.sum(probabilities[list(unvisited_nodes)])\n\n                next_node = np.random.choice(n, p=probabilities)\n                tour.append(next_node)\n                unvisited_nodes.remove(next_node)\n                current_node = next_node\n\n            tour.append(start_node)\n            tours.append(tour)\n\n        # Update pheromone matrix\n        pheromone_matrix *= 0.9  # Evaporation\n        for tour in tours:\n            tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                pheromone_matrix[node1, node2] += 1 / tour_length\n                pheromone_matrix[node2, node1] += 1 / tour_length\n        \n        for tour in tours:\n            for i in range(n):\n                node1 = tour[i]\n                node2 = tour[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n    \n    heuristics_matrix /= (num_ants * num_iterations)\n\n    return heuristics_matrix",
          "objective": 5.91188,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            # Probabilistically choose between nearest neighbor and random selection\n            if np.random.rand() < 0.7:  # Favor nearest neighbor\n                nearest_neighbor = -1\n                min_distance = np.inf\n                for neighbor in unvisited_nodes:\n                    distance = distance_matrix[current_node, neighbor]\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_neighbor = neighbor\n                next_node = nearest_neighbor\n            else:  # Random selection\n                next_node = np.random.choice(list(unvisited_nodes))\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1 #symmetric\n            current_node = next_node\n        \n        # Complete the tour\n        heuristics_matrix[current_node, tour[0]] += 1\n        heuristics_matrix[tour[0], current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.01684,
          "other_inf": null
     }
]