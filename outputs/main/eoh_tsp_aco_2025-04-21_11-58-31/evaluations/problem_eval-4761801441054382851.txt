import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach, iteratively evolving a population of candidate tours through selection, crossover, and mutation, favoring tours with shorter lengths to estimate edge importance.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.01

    # Initialize population with random tours
    population = []
    for _ in range(population_size):
        tour = np.random.permutation(n)
        tour = np.append(tour, tour[0])
        population.append(tour)

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for generation in range(num_generations):
        # Calculate fitness (tour length) for each tour
        fitness = np.zeros(population_size)
        for i in range(population_size):
            tour = population[i]
            fitness[i] = sum(distance_matrix[tour[j], tour[j+1]] for j in range(n))

        # Selection (roulette wheel selection)
        probabilities = 1 / fitness  # Inverse of fitness (shorter is better)
        probabilities /= np.sum(probabilities)
        selected_indices = np.random.choice(population_size, size=population_size, replace=True, p=probabilities)
        selected_population = [population[i] for i in selected_indices]

        # Crossover (order crossover)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % population_size]

            start = np.random.randint(1, n)
            length = np.random.randint(1, n - start + 1)

            child1 = np.zeros(n + 1, dtype=int) - 1
            child2 = np.zeros(n + 1, dtype=int) - 1

            child1[start:start+length] = parent1[start:start+length]
            child2[start:start+length] = parent2[start:start+length]

            remaining1 = [node for node in parent2[1:n] if node not in child1]
            remaining2 = [node for node in parent1[1:n] if node not in child2]

            child1[0] = parent1[0]
            child2[0] = parent2[0]

            
            idx1 = 0
            idx2 = 0
            for j in range(1,n):
                if child1[j] == -1:
                   child1[j] = remaining1[idx1]
                   idx1 += 1
                if child2[j] == -1:
                   child2[j] = remaining2[idx2]
                   idx2 += 1
            child1[-1] = child1[0]
            child2[-1] = child2[0]

            new_population.append(child1)
            new_population.append(child2)
            if len(new_population)>population_size:
                new_population = new_population[:population_size]

        # Mutation (swap mutation)
        for i in range(population_size):
            if np.random.rand() < mutation_rate:
                tour = new_population[i]
                idx1 = np.random.randint(1, n)
                idx2 = np.random.randint(1, n)
                tour[idx1], tour[idx2] = tour[idx2], tour[idx1]
                new_population[i] = tour

        population = new_population

    # Update heuristics matrix based on final population
    for tour in population:
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= (population_size * num_generations)
    return heuristics_matrix
