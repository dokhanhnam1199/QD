import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix based on iteratively refining a probability matrix favoring edges used in shortest paths found using Dijkstra's algorithm from random starting nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    probability_matrix = np.ones_like(distance_matrix) / n  # Initialize with uniform probabilities

    num_iterations = 100

    for _ in range(num_iterations):
        for start_node in range(n):
            # Use Dijkstra's algorithm to find shortest paths from start_node
            distances = np.full(n, np.inf)
            distances[start_node] = 0
            visited = np.zeros(n, dtype=bool)
            previous = np.full(n, -1, dtype=int)

            for _ in range(n):
                # Find the unvisited node with the smallest distance
                min_distance = np.inf
                current_node = -1
                for node in range(n):
                    if not visited[node] and distances[node] < min_distance:
                        min_distance = distances[node]
                        current_node = node

                if current_node == -1:
                    break

                visited[current_node] = True

                # Update distances to neighbors
                for neighbor in range(n):
                    if distance_matrix[current_node, neighbor] != 0:
                        new_distance = distances[current_node] + distance_matrix[current_node, neighbor]
                        if new_distance < distances[neighbor]:
                            distances[neighbor] = new_distance
                            previous[neighbor] = current_node
            
            # Update probability matrix based on shortest paths
            for end_node in range(n):
                if end_node != start_node and previous[end_node] != -1:
                    path = []
                    current = end_node
                    while current != -1:
                        path.insert(0, current)
                        current = previous[current]

                    for i in range(len(path) - 1):
                        node1 = path[i]
                        node2 = path[i+1]
                        heuristics_matrix[node1, node2] += 1
                        heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= (num_iterations * n)
    return heuristics_matrix
