import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge probabilities by generating tours using a biased random walk guided by the distance matrix and pheromone trails, iteratively updating the trails based on tour lengths.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones_like(distance_matrix)  # Initialize pheromone trails
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 100
    alpha = 1.0  # Pheromone influence
    beta = 2.0   # Distance influence
    rho = 0.5    # Evaporation rate

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]
        tour_length = 0

        while unvisited_nodes:
            probabilities = np.array([(pheromone_matrix[current_node, neighbor]**alpha) * ((1.0 / distance_matrix[current_node, neighbor])**beta) if distance_matrix[current_node, neighbor] > 0 else 0 for neighbor in unvisited_nodes])
            probabilities /= np.sum(probabilities)
            
            next_node = np.random.choice(list(unvisited_nodes), p=probabilities)
            tour.append(next_node)
            tour_length += distance_matrix[current_node, next_node]
            unvisited_nodes.remove(next_node)
            current_node = next_node

        tour_length += distance_matrix[current_node, tour[0]]
        tour.append(tour[0])

        # Update pheromone trails
        delta_pheromone = 1.0 / tour_length
        for i in range(n):
            pheromone_matrix[tour[i], tour[i+1]] += delta_pheromone
            pheromone_matrix[tour[i+1], tour[i]] += delta_pheromone  # Symmetric

        pheromone_matrix *= (1 - rho)  # Evaporation

    # Normalize pheromone matrix to get heuristics matrix
    max_pheromone = np.max(pheromone_matrix)
    if max_pheromone > 0:
        heuristics_matrix = pheromone_matrix / max_pheromone
    else:
        heuristics_matrix = np.zeros_like(distance_matrix)
    
    return heuristics_matrix
