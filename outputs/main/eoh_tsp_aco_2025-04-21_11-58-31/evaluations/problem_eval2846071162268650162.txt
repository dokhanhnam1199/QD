import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively constructs solutions by probabilistically selecting edges based on their length and connectivity, refining the probabilities based on the best solutions found.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)
    
    num_iterations = 100
    num_samples = 50
    
    for _ in range(num_iterations):
        paths = []
        costs = []
        
        for _ in range(num_samples):
            unvisited = set(range(n))
            start_node = np.random.choice(list(unvisited))
            current_node = start_node
            unvisited.remove(current_node)
            path = [current_node]
            total_cost = 0
            
            while unvisited:
                probabilities = heuristics_matrix[current_node, :]
                probabilities[current_node] = 0  # Avoid self-loops
                
                valid_indices = list(unvisited)
                probabilities_subset = probabilities[valid_indices]
                
                if np.sum(probabilities_subset) == 0:
                    next_node = np.random.choice(valid_indices)
                else:
                    probabilities_subset = probabilities_subset / np.sum(probabilities_subset)  # Normalize
                    next_node = np.random.choice(valid_indices, p=probabilities_subset)
                
                next_node_index = valid_indices.index(next_node)
                next_node = valid_indices[next_node_index]
                
                total_cost += distance_matrix[current_node, next_node]
                current_node = next_node
                path.append(current_node)
                unvisited.remove(current_node)

            total_cost += distance_matrix[current_node, start_node]
            path.append(start_node)
            
            paths.append(path)
            costs.append(total_cost)
            
        best_path_index = np.argmin(costs)
        best_path = paths[best_path_index]
        
        # Update heuristics based on the best path
        for i in range(n):
            node1 = best_path[i]
            node2 = best_path[(i + 1) % n]
            heuristics_matrix[node1, node2] *= 1.1  # Increase probability for edges in the best path
            heuristics_matrix[node2, node1] *= 1.1
            
        # Decrease probability for edges not in good solutions - optional
        for i in range(n):
            for j in range(n):
                if i != j:
                    is_in_best_path = False
                    for k in range(n):
                        if (best_path[k] == i and best_path[(k+1)%n] == j) or \
                           (best_path[k] == j and best_path[(k+1)%n] == i):
                            is_in_best_path = True
                            break
                    if not is_in_best_path:
                        heuristics_matrix[i, j] *= 0.95
                        

        heuristics_matrix = np.clip(heuristics_matrix, 0.001, 1000) # prevent values to go to 0 or infinity
    
    return heuristics_matrix
