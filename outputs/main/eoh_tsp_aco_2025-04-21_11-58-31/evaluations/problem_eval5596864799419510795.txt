import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix based on shortest path lengths between all pairs of nodes, prioritizing shorter paths by penalizing longer ones in the heuristic value.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Dijkstra's algorithm to find shortest path from i to j
                dist = np.full(n, np.inf)
                dist[i] = 0
                visited = np.zeros(n, dtype=bool)

                for _ in range(n):
                    u = -1
                    min_dist = np.inf
                    for v in range(n):
                        if not visited[v] and dist[v] < min_dist:
                            min_dist = dist[v]
                            u = v

                    if u == -1:
                        break

                    visited[u] = True

                    for v in range(n):
                        if not visited[v] and distance_matrix[u, v] > 0:
                            new_dist = dist[u] + distance_matrix[u, v]
                            if new_dist < dist[v]:
                                dist[v] = new_dist

                heuristics_matrix[i, j] = 1.0 / (1.0 + dist[j])
                heuristics_matrix[j, i] = 1.0 / (1.0 + dist[j])

    return heuristics_matrix
