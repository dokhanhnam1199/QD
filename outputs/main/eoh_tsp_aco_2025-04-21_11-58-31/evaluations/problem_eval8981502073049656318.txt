import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by adaptively adjusting edge probabilities based on the frequency with which edges appear in solutions generated by a biased random walk, where the bias is determined by edge distance and the heuristic matrix itself.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_walks = 100
    alpha = 0.8 #Importance of the heuristics_matrix
    beta = 2.0 #Importance of the distance_matrix

    for _ in range(num_walks):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(start_node)
        tour = [start_node]

        while unvisited_nodes:
            probabilities = np.zeros(n)
            for neighbor in range(n):
                if neighbor in unvisited_nodes:
                    #Bias towards shorter edges, edges with high heuristic scores, and penalize self-loops
                    probabilities[neighbor] = (heuristics_matrix[current_node, neighbor]**alpha) * ((1 / (distance_matrix[current_node, neighbor] + 1e-9))**beta)
            
            #Normalize
            if np.sum(probabilities) > 0:
                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(n, p=probabilities)
            else:
                #If no valid neighbors (all probabilities are zero), choose a random unvisited node
                next_node = np.random.choice(list(unvisited_nodes))
                

            tour.append(next_node)
            unvisited_nodes.remove(next_node)

            #Update the heuristics matrix with the new edge.
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1

            current_node = next_node

        #Close the tour
        heuristics_matrix[current_node, start_node] +=1
        heuristics_matrix[start_node, current_node] +=1
    
    #Normalize to obtain the heuristic scores
    heuristics_matrix /= num_walks
    return heuristics_matrix
