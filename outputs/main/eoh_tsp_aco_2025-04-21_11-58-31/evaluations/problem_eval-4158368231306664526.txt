import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining edge frequencies from multiple solutions generated by a greedy nearest neighbor approach with a distance-based weighting.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    
    for _ in range(num_iterations):
        for start_node in range(n):
            tour = [start_node]
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(start_node)
            current_node = start_node
            
            while unvisited_nodes:
                nearest_neighbor = -1
                min_distance = float('inf')
                for neighbor in unvisited_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    if distance < min_distance:
                        min_distance = distance
                        nearest_neighbor = neighbor
                
                tour.append(nearest_neighbor)
                unvisited_nodes.remove(nearest_neighbor)
                current_node = nearest_neighbor
            
            tour.append(start_node)

            tour_length = sum(distance_matrix[tour[i], tour[i+1]] for i in range(n))

            for i in range(n):
                node1 = tour[i]
                node2 = tour[i+1]
                heuristics_matrix[node1, node2] += (1 / distance_matrix[node1, node2])
                heuristics_matrix[node2, node1] += (1 / distance_matrix[node2, node1])
    
    heuristics_matrix /= num_iterations * n
    return heuristics_matrix
