import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively samples solutions using a nearest neighbor heuristic with a stochastic element, evaluates their lengths, and updates a matrix indicating the frequency with which each edge appears in the shorter solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000

    for _ in range(num_iterations):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(start_node)
        tour = [start_node]
        tour_length = 0

        while unvisited_nodes:
            nearest_neighbor = None
            min_distance = float('inf')
            
            # Stochastic nearest neighbor
            distances = [distance_matrix[current_node, neighbor] for neighbor in unvisited_nodes]
            probabilities = np.exp(-np.array(distances) / np.mean(distances))
            probabilities /= np.sum(probabilities)
            
            
            try:
                nearest_neighbor = np.random.choice(list(unvisited_nodes), p=probabilities)
            except ValueError: # Handle potential probability issues (e.g., NaN)
                nearest_neighbor = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])

            tour.append(nearest_neighbor)
            tour_length += distance_matrix[current_node, nearest_neighbor]
            current_node = nearest_neighbor
            unvisited_nodes.remove(nearest_neighbor)

        tour_length += distance_matrix[current_node, start_node]
        tour.append(start_node)

        # Update heuristics based on tour length (favor shorter tours)
        if _ == 0:
            best_tour_length = tour_length
            best_tour = tour
        else:
            if tour_length < best_tour_length:
                best_tour_length = tour_length
                best_tour = tour

    for i in range(len(best_tour) - 1):
        u = best_tour[i]
        v = best_tour[i+1]
        heuristics_matrix[u, v] += 1
        heuristics_matrix[v, u] += 1  # Assuming symmetric TSP

    return heuristics_matrix
