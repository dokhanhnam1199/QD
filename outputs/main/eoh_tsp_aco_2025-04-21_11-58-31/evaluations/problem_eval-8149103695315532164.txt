import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a stochastic sampling approach based on a combination of farthest neighbor and biased random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            # Probabilistically choose between farthest neighbor and biased random selection
            if np.random.rand() < 0.3:  # Favor farthest neighbor
                farthest_neighbor = -1
                max_distance = -np.inf
                for neighbor in unvisited_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    if distance > max_distance:
                        max_distance = distance
                        farthest_neighbor = neighbor
                next_node = farthest_neighbor
            else:  # Biased random selection (favoring closer nodes)
                probabilities = []
                for neighbor in unvisited_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    probabilities.append(1 / (distance + 1e-6))  # Add a small constant to avoid division by zero
                probabilities = np.array(probabilities) / np.sum(probabilities)  # Normalize to probabilities
                next_node = np.random.choice(list(unvisited_nodes), p=probabilities)

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1 #symmetric
            current_node = next_node
        
        # Complete the tour
        heuristics_matrix[current_node, tour[0]] += 1
        heuristics_matrix[tour[0], current_node] += 1

    return heuristics_matrix
