import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a simulated annealing approach to explore the solution space and constructs the heuristics matrix based on the acceptance probability of different edges during the annealing process.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    temperature = 100.0
    cooling_rate = 0.95
    num_iterations = 1000

    current_path = np.random.permutation(n)
    current_cost = 0
    for i in range(n - 1):
        current_cost += distance_matrix[current_path[i], current_path[i+1]]
    current_cost += distance_matrix[current_path[-1], current_path[0]]

    for _ in range(num_iterations):
        i, j = np.random.choice(n, 2, replace=False)
        
        new_path = current_path.copy()
        new_path[i], new_path[j] = new_path[j], new_path[i]

        new_cost = 0
        for k in range(n - 1):
            new_cost += distance_matrix[new_path[k], new_path[k+1]]
        new_cost += distance_matrix[new_path[-1], new_path[0]]

        cost_difference = new_cost - current_cost

        if cost_difference < 0 or np.random.rand() < np.exp(-cost_difference / temperature):
            for k in range(n - 1):
                heuristics_matrix[current_path[k], current_path[k+1]] += 1
                heuristics_matrix[current_path[k+1], current_path[k]] += 1
            heuristics_matrix[current_path[-1], current_path[0]] += 1
            heuristics_matrix[current_path[0], current_path[-1]] += 1
            current_path = new_path
            current_cost = new_cost

        temperature *= cooling_rate

    return heuristics_matrix
