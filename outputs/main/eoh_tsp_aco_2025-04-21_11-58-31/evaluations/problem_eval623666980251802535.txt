import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristics matrix by combining shortest path information and edge lengths, penalizing longer edges on longer shortest paths.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Compute all-pairs shortest paths using Floyd-Warshall
    shortest_paths = np.copy(distance_matrix)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                shortest_paths[i, j] = min(shortest_paths[i, j], shortest_paths[i, k] + shortest_paths[k, j])

    # Heuristic: Inverse of shortest path length, penalized by direct edge length
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = 1.0 / (shortest_paths[i, j] * (1 + distance_matrix[i, j]))
            else:
                heuristics_matrix[i,j] = 0

    return heuristics_matrix
