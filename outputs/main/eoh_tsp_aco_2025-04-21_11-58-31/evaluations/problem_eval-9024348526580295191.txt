import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a combination of greedy construction, simulated annealing, and edge voting to build a heuristic matrix favoring edges in low-cost tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 50
    initial_temperature = 100
    cooling_rate = 0.95

    for _ in range(num_iterations):
        # 1. Greedy Tour Construction
        current_node = np.random.randint(n)
        tour = [current_node]
        unvisited = list(range(n))
        unvisited.remove(current_node)

        while unvisited:
            nearest_neighbor = min(unvisited, key=lambda x: distance_matrix[current_node, x])
            tour.append(nearest_neighbor)
            unvisited.remove(nearest_neighbor)
            current_node = nearest_neighbor

        tour.append(tour[0])  # Return to start
        current_cost = sum(distance_matrix[tour[i], tour[i + 1]] for i in range(n))

        # 2. Simulated Annealing
        temperature = initial_temperature
        for _ in range(100): # SA steps per iteration
            i = np.random.randint(1, n)  # Exclude the first and last node
            j = np.random.randint(1, n)
            if i >= j:
                i, j = j, i

            new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
            new_cost = sum(distance_matrix[new_tour[k], new_tour[k + 1]] for k in range(n))

            cost_diff = new_cost - current_cost
            if cost_diff < 0 or np.random.rand() < np.exp(-cost_diff / temperature):
                tour = new_tour
                current_cost = new_cost

            temperature *= cooling_rate

        # 3. Edge Voting
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
