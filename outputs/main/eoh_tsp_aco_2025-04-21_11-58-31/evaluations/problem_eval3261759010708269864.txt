import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm generates multiple random tours, iteratively improves them using a local search (2-opt swaps), and then calculates a heuristic matrix based on the frequency with which each edge appears in the improved tours.}"""
    num_nodes = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # Generate a random tour
        tour = np.random.permutation(num_nodes)

        # Improve the tour using 2-opt swaps
        improved_tour = two_opt(tour, distance_matrix)

        # Update the heuristic matrix
        for i in range(num_nodes):
            node1 = improved_tour[i]
            node2 = improved_tour[(i + 1) % num_nodes]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    # Normalize the heuristic matrix
    heuristics_matrix /= num_iterations
    return heuristics_matrix

def two_opt(tour, distance_matrix):
    """Implements the 2-opt local search algorithm."""
    best_tour = tour.copy()
    improved = True
    while improved:
        improved = False
        for i in range(1, len(tour) - 1):
            for k in range(i + 1, len(tour)):
                if two_opt_swap_cost(best_tour, i, k, distance_matrix) < 0:
                    best_tour = two_opt_swap(best_tour, i, k)
                    improved = True
        tour = best_tour.copy()
    return best_tour

def two_opt_swap_cost(tour, i, k, distance_matrix):
    """Calculates the cost change of a 2-opt swap."""
    n = len(tour)
    cost_change = (
        distance_matrix[tour[i - 1], tour[k]]
        + distance_matrix[tour[i], tour[(k + 1) % n]]
        - distance_matrix[tour[i - 1], tour[i]]
        - distance_matrix[tour[k], tour[(k + 1) % n]]
    )
    return cost_change

def two_opt_swap(tour, i, k):
    """Performs a 2-opt swap."""
    new_tour = tour[:i] + tour[i:k+1][::-1] + tour[k+1:]
    return heuristics_matrix
