import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm samples a set of candidate tours by iteratively adding edges with probability inversely proportional to their length, then updates edge inclusion probabilities based on how frequently each edge appears in the best sampled tours.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100
    best_tour_length = float('inf')
    best_tours = []

    for _ in range(num_samples):
        current_tour = []
        unvisited = list(range(n))
        start_node = np.random.choice(unvisited)
        current_tour.append(start_node)
        unvisited.remove(start_node)
        current_length = 0

        while unvisited:
            current_node = current_tour[-1]
            probabilities = 1.0 / (distance_matrix[current_node, unvisited] + 1e-6)  # Avoid division by zero
            probabilities /= np.sum(probabilities)
            next_node = np.random.choice(unvisited, p=probabilities)
            current_tour.append(next_node)
            current_length += distance_matrix[current_node, next_node]
            unvisited.remove(next_node)

        current_length += distance_matrix[current_tour[-1], current_tour[0]] # Return to start
        
        if current_length < best_tour_length:
            best_tour_length = current_length
            best_tours = [current_tour]
        elif current_length == best_tour_length:
            best_tours.append(current_tour)

    for tour in best_tours:
        for i in range(n):
            node1 = tour[i]
            node2 = tour[(i + 1) % n]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix = heuristics_matrix / len(best_tours) 
    return heuristics_matrix
