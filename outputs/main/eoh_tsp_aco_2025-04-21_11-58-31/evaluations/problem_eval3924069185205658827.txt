import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random tours, improving them with 2-opt swaps, and then calculates a heuristic matrix based on the frequency of edges appearing in the improved tours.}"""
    n = len(distance_matrix)
    num_samples = 100
    heuristics_matrix = np.zeros((n, n))
    
    for _ in range(num_samples):
        # 1. Generate a random tour
        tour = np.random.permutation(n)

        # 2. Improve the tour using 2-opt swaps
        improved_tour = two_opt(tour, distance_matrix)

        # 3. Update the heuristics matrix based on the improved tour
        for i in range(n):
            u = improved_tour[i]
            v = improved_tour[(i + 1) % n]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1
    
    return heuristics_matrix

def two_opt(tour, distance_matrix):
    """Improve a tour using 2-opt swaps."""
    n = len(tour)
    improved = True
    best_tour = tour[:]  # Create a copy to avoid modifying the original
    
    while improved:
        improved = False
        for i in range(1, n - 1):
            for k in range(i + 1, n):
                
                # Calculate current cost
                current_cost = (
                    distance_matrix[best_tour[i - 1], best_tour[i]]
                    + distance_matrix[best_tour[k], best_tour[(k + 1) % n]]
                )

                # Calculate cost after swap
                new_cost = (
                    distance_matrix[best_tour[i - 1], best_tour[k]]
                    + distance_matrix[best_tour[i], best_tour[(k + 1) % n]]
                )

                if new_cost < current_cost:
                    # Perform the 2-opt swap
                    best_tour[i:k+1] = best_tour[i:k+1][::-1]
                    improved = True
    return heuristics_matrix
