import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by weighting edge frequencies from multiple solutions generated by iterative improvement with 3-opt swaps starting from random initial tours, giving higher weight to edges present in shorter tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 50
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_samples):
        # Generate a random initial tour
        tour = np.random.permutation(n)
        tour = np.append(tour, tour[0])

        # Improve the tour using 3-opt swaps
        improved = True
        while improved:
            improved = False
            for i in range(1, n - 1):
                for j in range(i + 1, n):
                    for k in range(j + 1, n + 1):
                        if i != j and j != k and i != k:
                            # Original segment
                            current_cost = distance_matrix[tour[i - 1], tour[i]] + distance_matrix[tour[j - 1], tour[j]] + distance_matrix[tour[k - 1], tour[k%n]]
                            
                            # Possible 3-opt swap combinations
                            segments = [tour[i:j], tour[j:k]]
                            
                            # Reverse first segment
                            temp_tour = tour.copy()
                            temp_tour[i:j] = temp_tour[i:j][::-1]
                            new_cost = distance_matrix[temp_tour[i - 1], temp_tour[i]] + distance_matrix[temp_tour[j - 1], temp_tour[j]] + distance_matrix[temp_tour[k - 1], temp_tour[k%n]]
                            if new_cost < current_cost:
                                tour = temp_tour
                                improved = True
                                continue

                            # Reverse second segment
                            temp_tour = tour.copy()
                            temp_tour[j:k] = temp_tour[j:k][::-1]
                            new_cost = distance_matrix[temp_tour[i - 1], temp_tour[i]] + distance_matrix[temp_tour[j - 1], temp_tour[j]] + distance_matrix[temp_tour[k - 1], temp_tour[k%n]]
                            if new_cost < current_cost:
                                tour = temp_tour
                                improved = True
                                continue
                            
                            # Reverse both segments
                            temp_tour = tour.copy()
                            temp_tour[i:j] = temp_tour[i:j][::-1]
                            temp_tour[j:k] = temp_tour[j:k][::-1]
                            new_cost = distance_matrix[temp_tour[i - 1], temp_tour[i]] + distance_matrix[temp_tour[j - 1], temp_tour[j]] + distance_matrix[temp_tour[k - 1], temp_tour[k%n]]
                            if new_cost < current_cost:
                                tour = temp_tour
                                improved = True
                                continue

                            # Rotate segments
                            temp_tour = tour.copy()
                            temp_tour[i:k] = tour[j:k].tolist() + tour[i:j].tolist()
                            new_cost = distance_matrix[temp_tour[i - 1], temp_tour[i]] + distance_matrix[temp_tour[j - 1], temp_tour[j]] + distance_matrix[temp_tour[k - 1], temp_tour[k%n]]
                            if new_cost < current_cost:
                                tour = temp_tour
                                improved = True
                                continue

        # Calculate tour length
        tour_length = 0
        for i in range(n):
            tour_length += distance_matrix[tour[i], tour[i+1]]

        # Update heuristics matrix, weighting by inverse of tour length
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            heuristics_matrix[node1, node2] += 1.0 / tour_length
            heuristics_matrix[node2, node1] += 1.0 / tour_length

    heuristics_matrix /= num_samples
    return heuristics_matrix
