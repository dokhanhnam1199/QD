import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs solutions by iteratively adjusting edge selection probabilities based on the sampled path lengths, prioritizing shorter edges and penalizing longer ones, while also considering path diversity to avoid premature convergence.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)

    num_iterations = 100
    num_samples = 50

    for _ in range(num_iterations):
        paths = []
        costs = []

        for _ in range(num_samples):
            unvisited = set(range(n))
            start_node = np.random.choice(list(unvisited))
            current_node = start_node
            unvisited.remove(current_node)
            path = [current_node]
            total_cost = 0

            while unvisited:
                # Adjust probabilities based on edge lengths
                probabilities = heuristics_matrix[current_node, :] / distance_matrix[current_node, :]
                probabilities[current_node] = 0  # Avoid self-loops
                
                valid_indices = list(unvisited)
                probabilities_subset = probabilities[valid_indices]
                
                if np.sum(probabilities_subset) == 0:
                    next_node = np.random.choice(valid_indices)
                else:
                    probabilities_subset = probabilities_subset / np.sum(probabilities_subset)  # Normalize
                    next_node = np.random.choice(valid_indices, p=probabilities_subset)
                
                next_node_index = valid_indices.index(next_node)
                next_node = valid_indices[next_node_index]

                total_cost += distance_matrix[current_node, next_node]
                current_node = next_node
                path.append(current_node)
                unvisited.remove(current_node)

            total_cost += distance_matrix[current_node, start_node]
            path.append(start_node)

            paths.append(path)
            costs.append(total_cost)

        # Update heuristics based on path lengths and diversity
        avg_cost = np.mean(costs)
        for i in range(n):
            for j in range(n):
                if i != j:
                    # Prioritize shorter edges more strongly
                    heuristics_matrix[i, j] *= np.exp(-distance_matrix[i, j] / avg_cost)

                    # Encourage path diversity by penalizing frequently used edges
                    edge_count = sum(1 for path in paths for k in range(n) if (path[k] == i and path[(k + 1) % n] == j) or (path[k] == j and path[(k + 1) % n] == i))
                    heuristics_matrix[i, j] *= (1 - edge_count / num_samples * 0.5)  # Adjust factor as needed

        heuristics_matrix = np.clip(heuristics_matrix, 0.001, 1000)  # Prevent values to go to 0 or infinity

    return heuristics_matrix
