import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm adaptively adjusts edge selection probabilities based on the frequency with which edges appear in iteratively constructed tours, biasing selection towards edges that contribute to shorter overall tour lengths.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100
    edge_weights = np.ones((n, n))  # Initialize edge weights

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]
        tour_length = 0

        while unvisited_nodes:
            # Probabilistic selection based on edge weights
            probabilities = np.array([edge_weights[current_node, neighbor] for neighbor in unvisited_nodes])
            probabilities /= np.sum(probabilities)

            next_node = np.random.choice(list(unvisited_nodes), p=probabilities)
            tour.append(next_node)
            tour_length += distance_matrix[current_node, next_node]
            unvisited_nodes.remove(next_node)
            current_node = next_node

        # Complete the tour
        tour.append(tour[0])
        tour_length += distance_matrix[current_node, tour[0]]

        # Update edge weights based on tour length
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            if tour_length > 0:
                edge_weights[node1, node2] *= (1 - (1/tour_length))  # Shorter tours increase weights more
                edge_weights[node2, node1] *= (1 - (1/tour_length))
            else:
                 edge_weights[node1, node2] *= 0.9
                 edge_weights[node2, node1] *= 0.9
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
