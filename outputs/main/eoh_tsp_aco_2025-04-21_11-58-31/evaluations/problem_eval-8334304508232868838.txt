import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines ant colony optimization principles with local search to iteratively refine edge pheromone levels based on tour quality.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones_like(distance_matrix)
    alpha = 1
    beta = 2
    rho = 0.5
    Q = 100

    num_ants = n
    num_iterations = 50

    for iteration in range(num_iterations):
        all_tours = []
        all_tour_lengths = []

        for ant in range(num_ants):
            tour = [np.random.randint(n)]
            unvisited = list(range(n))
            unvisited.remove(tour[0])

            while unvisited:
                current_node = tour[-1]
                probabilities = np.zeros(len(unvisited))
                for i, neighbor in enumerate(unvisited):
                    probabilities[i] = (pheromone_matrix[current_node, neighbor]**alpha) * ((1 / (distance_matrix[current_node, neighbor] + 1e-9))**beta)

                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(unvisited, p=probabilities)

                tour.append(next_node)
                unvisited.remove(next_node)

            tour.append(tour[0])
            all_tours.append(tour)

            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]
            all_tour_lengths.append(tour_length)

        # Pheromone update
        pheromone_matrix *= (1 - rho)
        for ant in range(num_ants):
            tour = all_tours[ant]
            tour_length = all_tour_lengths[ant]
            for i in range(n):
                pheromone_matrix[tour[i], tour[i+1]] += Q / (tour_length + 1e-9)
                pheromone_matrix[tour[i+1], tour[i]] += Q / (tour_length + 1e-9)
                
        # Local Search (2-opt) on best tour
        best_tour_index = np.argmin(all_tour_lengths)
        best_tour = all_tours[best_tour_index]
        
        improved_tour = best_tour[:]  # Create a copy to avoid modifying the original
        
        for i in range(n):
            for j in range(i + 2, n + 1):
                new_tour = improved_tour[:i] + improved_tour[i:j][::-1] + improved_tour[j:]

                current_cost = sum(distance_matrix[improved_tour[k], improved_tour[k+1]] for k in range(n))
                new_cost = sum(distance_matrix[new_tour[k], new_tour[k+1]] for k in range(n))

                if new_cost < current_cost:
                    improved_tour = new_tour
                    
        # Update pheromone matrix based on improved tour
        improved_tour_length = sum(distance_matrix[improved_tour[k], improved_tour[k+1]] for k in range(n))
        for i in range(n):
             pheromone_matrix[improved_tour[i], improved_tour[i+1]] += Q / (improved_tour_length + 1e-9)
             pheromone_matrix[improved_tour[i+1], improved_tour[i]] += Q / (improved_tour_length + 1e-9)

    return heuristics_matrix
