import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a stochastic sampling approach with adaptive nearest neighbor probability and a decay factor for edge frequency updates to refine edge importance estimation.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100
    nearest_neighbor_prob = 0.8
    decay_factor = 0.95

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            if np.random.rand() < nearest_neighbor_prob:
                nearest_neighbor = -1
                min_distance = np.inf
                for neighbor in unvisited_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    if distance < min_distance:
                        min_distance = distance
                        nearest_neighbor = neighbor
                next_node = nearest_neighbor
            else:
                next_node = np.random.choice(list(unvisited_nodes))

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            heuristics_matrix[current_node, next_node] = decay_factor * heuristics_matrix[current_node, next_node] + 1
            heuristics_matrix[next_node, current_node] = decay_factor * heuristics_matrix[next_node, current_node] + 1
            current_node = next_node

        heuristics_matrix[current_node, tour[0]] = decay_factor * heuristics_matrix[current_node, tour[0]] + 1
        heuristics_matrix[tour[0], current_node] = decay_factor * heuristics_matrix[tour[0], current_node] + 1

        nearest_neighbor_prob *= 0.99 #Adaptive probability

    return heuristics_matrix
