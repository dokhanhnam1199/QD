import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively refining tours using a combination of greedy nearest neighbor selection, random perturbation, and a selection mechanism favoring edges present in shorter tours, while dynamically adjusting perturbation strength based on tour diversity.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    num_tours = 10
    perturbation_strength = 0.1

    tours = []
    tour_lengths = []

    for _ in range(num_tours):
        start_node = np.random.randint(n)
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            nearest_neighbor = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])
            tour.append(nearest_neighbor)
            unvisited_nodes.remove(nearest_neighbor)
            current_node = nearest_neighbor
        tour.append(start_node)
        tours.append(tour)
        tour_lengths.append(sum(distance_matrix[tours[-1][i], tours[-1][i+1]] for i in range(n)))

    for _ in range(num_iterations):
        for i in range(num_tours):
            #Perturbation
            if np.random.rand() < perturbation_strength:
                idx1, idx2 = np.random.choice(range(1,n), size=2, replace=False)
                tours[i][idx1], tours[i][idx2] = tours[i][idx2], tours[i][idx1]
            
            # Calculate tour length after perturbation
            new_tour_length = sum(distance_matrix[tours[i][k], tours[i][k+1]] for k in range(n))

            # Selection: Keep tour if it's better
            if new_tour_length < tour_lengths[i]:
                tour_lengths[i] = new_tour_length
            else:
                #Revert perturbation
                tours[i][idx1], tours[i][idx2] = tours[i][idx2], tours[i][idx1]

        # Update heuristics matrix
        for tour in tours:
            for j in range(n):
                node1 = tour[j]
                node2 = tour[j+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

        # Adjust perturbation strength
        tour_length_std = np.std(tour_lengths)
        perturbation_strength = np.clip(tour_length_std / np.mean(tour_lengths), 0.05, 0.2)


    heuristics_matrix /= (num_tours * num_iterations)
    return heuristics_matrix
