import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining a basic nearest neighbor approach with a penalty for edges that lead to long detours, effectively encouraging shorter, less circuitous routes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Basic nearest neighbor heuristic
                heuristics_matrix[i, j] = 1.0 / distance_matrix[i, j]

                # Penalty for detours: check distances from j to other nodes
                detour_penalty = 0.0
                for k in range(n):
                    if k != i and k != j:
                        detour_penalty += distance_matrix[j, k] - distance_matrix[i, k]
                
                heuristics_matrix[i, j] -= 0.01 * detour_penalty  # Adjust the penalty factor as needed
    
    heuristics_matrix = np.clip(heuristics_matrix, 0.001, 1000)  # Prevent non-positive values

    return heuristics_matrix
