import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses stochastic sampling to generate tours, favoring edges with lower distances and higher pheromone levels, updating pheromone trails based on tour quality, inspired by Ant Colony Optimization.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones((n, n))  # Initialize pheromone levels
    heuristic_matrix = np.zeros((n, n))
    alpha = 1.0  # Pheromone influence
    beta = 2.0  # Distance influence
    rho = 0.5  # Evaporation rate
    Q = 100.0  # Pheromone deposit constant
    num_ants = 50
    num_iterations = 100

    for _ in range(num_iterations):
        all_tours = []
        all_tour_lengths = []

        for _ in range(num_ants):
            current_node = np.random.randint(n)
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(current_node)
            tour = [current_node]
            tour_length = 0

            while unvisited_nodes:
                probabilities = np.zeros(n)
                for neighbor in unvisited_nodes:
                    probabilities[neighbor] = (pheromone_matrix[current_node, neighbor]**alpha) * ((1.0 / (distance_matrix[current_node, neighbor] + 1e-6))**beta)
                
                if np.sum(probabilities[list(unvisited_nodes)]) == 0:
                     available_nodes = list(unvisited_nodes)
                     next_node = available_nodes[np.random.randint(len(available_nodes))]

                else:
                    probabilities /= np.sum(probabilities[list(unvisited_nodes)])
                    next_node = np.random.choice(n, p=probabilities)
                    while next_node not in unvisited_nodes:
                         probabilities[next_node] = 0
                         if np.sum(probabilities[list(unvisited_nodes)]) == 0:
                            available_nodes = list(unvisited_nodes)
                            next_node = available_nodes[np.random.randint(len(available_nodes))]
                            break;
                         probabilities /= np.sum(probabilities[list(unvisited_nodes)])
                         next_node = np.random.choice(n, p=probabilities)
                
                tour.append(next_node)
                tour_length += distance_matrix[current_node, next_node]
                unvisited_nodes.remove(next_node)
                current_node = next_node

            tour_length += distance_matrix[current_node, tour[0]]
            all_tours.append(tour)
            all_tour_lengths.append(tour_length)

        # Update pheromone trails
        pheromone_matrix *= (1 - rho)
        for i in range(num_ants):
            tour = all_tours[i]
            tour_length = all_tour_lengths[i]
            for j in range(n - 1):
                pheromone_matrix[tour[j], tour[j+1]] += Q / tour_length
                pheromone_matrix[tour[j+1], tour[j]] += Q / tour_length
            pheromone_matrix[tour[-1], tour[0]] += Q / tour_length
            pheromone_matrix[tour[0], tour[-1]] += Q / tour_length
    
    heuristic_matrix = pheromone_matrix #Return pheromone matrix as the heuristic matrix

    return heuristics_matrix
