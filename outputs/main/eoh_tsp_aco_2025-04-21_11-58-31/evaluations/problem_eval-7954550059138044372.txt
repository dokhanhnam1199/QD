import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines edge probabilities by iteratively constructing tours using a combination of greedy edge selection weighted by historical edge usage and a stochastic element to promote exploration, then updating edge probabilities based on tour quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)

    num_iterations = 50
    num_tours = 20

    for _ in range(num_iterations):
        for _ in range(num_tours):
            current_node = np.random.randint(n)
            tour = [current_node]
            remaining_nodes = list(range(n))
            remaining_nodes.remove(current_node)

            while remaining_nodes:
                probabilities = np.zeros(len(remaining_nodes))
                for i, neighbor in enumerate(remaining_nodes):
                    probabilities[i] = heuristics_matrix[current_node, neighbor] / (distance_matrix[current_node, neighbor] + 1e-6)
                
                probabilities = probabilities / np.sum(probabilities)
                
                next_node = np.random.choice(remaining_nodes, p=probabilities)
                tour.append(next_node)
                remaining_nodes.remove(next_node)
                current_node = next_node

            # Complete the tour by returning to the start
            tour.append(tour[0])
            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]

            # Update the heuristics matrix based on tour length
            for i in range(n):
                heuristics_matrix[tour[i], tour[i+1]] += 1 / (tour_length + 1e-6)
                heuristics_matrix[tour[i+1], tour[i]] += 1 / (tour_length + 1e-6)

    return heuristics_matrix
