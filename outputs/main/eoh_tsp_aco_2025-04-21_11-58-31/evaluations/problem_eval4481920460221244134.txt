import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm employs stochastic sampling to construct tours by iteratively adding the edge with a probability proportional to a heuristic value derived from distance and edge frequency, thereby estimating edge importance for TSP solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            heuristic_values = np.zeros(n)
            probabilities = np.zeros(n)
            for neighbor in unvisited_nodes:
                heuristic_values[neighbor] = (1/(distance_matrix[current_node, neighbor]+1e-6)) + heuristics_matrix[current_node, neighbor]

            sum_heuristic = np.sum(heuristic_values[list(unvisited_nodes)])
            if sum_heuristic > 0:
                for neighbor in unvisited_nodes:
                    probabilities[neighbor] = heuristic_values[neighbor] / sum_heuristic
            else:
                for neighbor in unvisited_nodes:
                    probabilities[neighbor] = 1 / len(unvisited_nodes)


            next_node = np.random.choice(n, p=probabilities)

            if next_node not in unvisited_nodes:
                available_nodes = list(unvisited_nodes)
                next_node = available_nodes[np.random.randint(len(available_nodes))]

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1
            current_node = next_node

        heuristics_matrix[current_node, tour[0]] += 1
        heuristics_matrix[tour[0], current_node] += 1

    return heuristics_matrix
