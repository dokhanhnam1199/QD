import numpy as np

def heuristics_v2(distance_matrix):
  """{This algorithm estimates edge inclusion probabilities by sampling random paths, favoring shorter edges, and updating edge counts based on path length and edge proximity to the shortest sampled path.}"""
  n = distance_matrix.shape[0]
  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
  num_samples = 1000

  for _ in range(num_samples):
    # Sample a random path
    path = np.random.permutation(n)
    path_length = 0
    for i in range(n - 1):
      path_length += distance_matrix[path[i], path[i+1]]
    path_length += distance_matrix[path[-1], path[0]]

    # Update edge counts based on path length
    for i in range(n - 1):
      heuristics_matrix[path[i], path[i+1]] += 1.0 / path_length
      heuristics_matrix[path[i+1], path[i]] += 1.0 / path_length
    heuristics_matrix[path[-1], path[0]] += 1.0 / path_length
    heuristics_matrix[path[0], path[-1]] += 1.0 / path_length
      
  # Normalize the matrix
  heuristics_matrix = (heuristics_matrix + 1e-9) / np.max(heuristics_matrix + 1e-9)

  return heuristics_matrix
