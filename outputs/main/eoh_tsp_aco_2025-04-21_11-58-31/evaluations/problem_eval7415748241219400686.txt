import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm learns edge importance by iteratively constructing tours with a bias towards edges frequently present in shorter tours found through a combination of nearest neighbor search and random edge swaps.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)

    num_iterations = 50
    num_tours = 20

    for _ in range(num_iterations):
        for _ in range(num_tours):
            # Construct an initial tour using nearest neighbor
            start_node = np.random.randint(n)
            tour = [start_node]
            remaining_nodes = list(range(n))
            remaining_nodes.remove(start_node)
            current_node = start_node

            while remaining_nodes:
                nearest_neighbor = -1
                min_distance = np.inf
                for neighbor in remaining_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    if distance < min_distance:
                        min_distance = distance
                        nearest_neighbor = neighbor

                tour.append(nearest_neighbor)
                remaining_nodes.remove(nearest_neighbor)
                current_node = nearest_neighbor

            tour.append(start_node)
            original_tour = tour[:]
            # Improve the tour with random edge swaps
            for _ in range(n):
                i = np.random.randint(1, n)
                j = np.random.randint(1, n)
                if i == j:
                    continue
                
                if i > j:
                    i, j = j, i
                
                new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
                
                original_tour_length = 0
                for k in range(n):
                    original_tour_length += distance_matrix[original_tour[k], original_tour[k+1]]
                
                new_tour_length = 0
                for k in range(n):
                    new_tour_length += distance_matrix[new_tour[k], new_tour[k+1]]
                
                if new_tour_length < original_tour_length:
                    tour = new_tour
                    original_tour = tour[:]

            # Update heuristics based on tour edges
            tour_length = 0
            for i in range(n):
                heuristics_matrix[tour[i], tour[i+1]] += 1
                heuristics_matrix[tour[i+1], tour[i]] += 1
                tour_length += distance_matrix[tour[i], tour[i+1]]
    return heuristics_matrix
