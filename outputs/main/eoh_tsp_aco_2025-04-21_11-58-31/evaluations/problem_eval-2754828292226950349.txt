import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge probabilities by combining shortest path lengths between nodes with a penalty based on the average distance to their nearest neighbors, using multiple random node orderings.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100

    # Calculate nearest neighbor distances for penalty
    nearest_neighbor_distances = np.zeros(n)
    for i in range(n):
        distances = distance_matrix[i, :]
        nearest_neighbor_distances[i] = np.partition(distances, 1)[1] # Second smallest distance (excluding distance to self)

    for _ in range(num_samples):
        node_order = np.random.permutation(n)
        
        # Calculate shortest path lengths based on current permutation
        path_lengths = np.zeros_like(distance_matrix)
        for i in range(n):
            for j in range(n):
                if i != j:
                    path = []
                    current = i
                    visited = {i}
                    while current != j:
                        min_dist = np.inf
                        next_node = -1
                        for neighbor in range(n):
                            if neighbor not in visited and distance_matrix[current, neighbor] < min_dist:
                                min_dist = distance_matrix[current, neighbor]
                                next_node = neighbor
                        if next_node == -1: #No path found in this permutation, mark as inf
                            path_lengths[i, j] = np.inf
                            break;

                        path.append(next_node)
                        visited.add(next_node)
                        current = next_node
                    if path_lengths[i, j] != np.inf:
                        path_lengths[i, j] = sum(distance_matrix[path[k-1], path[k]] if k > 0 else distance_matrix[i,path[0]] for k in range(len(path))) + (0 if len(path) == 0 else 0)

        # Combine shortest path lengths with nearest neighbor penalty
        for i in range(n):
            for j in range(n):
                if i != j:
                    penalty = (nearest_neighbor_distances[i] + nearest_neighbor_distances[j])
                    heuristics_matrix[i, j] += 1 / (path_lengths[i, j] + penalty + 1e-9)  # Avoid division by zero

    heuristics_matrix = heuristics_matrix / num_samples
    return heuristics_matrix
