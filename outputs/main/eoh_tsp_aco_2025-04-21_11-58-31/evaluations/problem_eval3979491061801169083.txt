import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a stochastic sampling approach biased towards shorter edges to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            # Probabilistically choose the next node based on edge distances
            probabilities = np.array([1.0 / (distance_matrix[current_node, neighbor] + 1e-6) for neighbor in unvisited_nodes])  # Add a small constant to avoid division by zero
            probabilities /= np.sum(probabilities)  # Normalize to create a probability distribution

            next_node = np.random.choice(list(unvisited_nodes), p=probabilities)

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1 #symmetric
            current_node = next_node
        
        # Complete the tour
        heuristics_matrix[current_node, tour[0]] += 1
        heuristics_matrix[tour[0], current_node] += 1

    return heuristics_matrix
