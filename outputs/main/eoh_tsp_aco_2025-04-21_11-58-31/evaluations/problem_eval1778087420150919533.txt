import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 100

    for _ in range(num_samples):
        current_node = np.random.randint(n)
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            # Probabilistically choose between nearest neighbor and random selection
            if np.random.rand() < 0.7:  # Favor nearest neighbor
                nearest_neighbor = -1
                min_distance = np.inf
                for neighbor in unvisited_nodes:
                    distance = distance_matrix[current_node, neighbor]
                    if distance < min_distance:
                        min_distance = distance
                        nearest_neighbor = neighbor
                next_node = nearest_neighbor
            else:  # Random selection
                next_node = np.random.choice(list(unvisited_nodes))

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1 #symmetric
            current_node = next_node
        
        # Complete the tour
        heuristics_matrix[current_node, tour[0]] += 1
        heuristics_matrix[tour[0], current_node] += 1

    return heuristics_matrix
