import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs tours by iteratively adding the shortest available edge that doesn't create a cycle, prioritizing edges that connect nodes with high degrees in the partially constructed tour, and uses a randomized restart mechanism to escape local optima.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 100

    for _ in range(num_samples):
        # Initialize tour
        tour = []
        unvisited_nodes = set(range(n))
        edge_count = 0
        
        while unvisited_nodes:
            # Calculate node degrees in the current tour
            node_degrees = np.zeros(n, dtype=int)
            for i in range(len(tour) - 1):
                node1 = tour[i]
                node2 = tour[i+1]
                node_degrees[node1] += 1
                node_degrees[node2] += 1
            
            # Prioritize edges based on length and node degrees
            edge_priorities = np.zeros_like(distance_matrix, dtype=float)
            for i in range(n):
                for j in range(i + 1, n):
                    if i in unvisited_nodes or j in unvisited_nodes:
                        edge_priorities[i, j] = (1 / distance_matrix[i, j]) * (node_degrees[i] + node_degrees[j] + 1)
                        edge_priorities[j, i] = edge_priorities[i, j]

            # Select the best edge to add (without creating a cycle)
            best_edge = None
            best_priority = -1

            for i in range(n):
                for j in range(i + 1, n):
                    if (i in unvisited_nodes or j in unvisited_nodes):
                        if edge_priorities[i, j] > best_priority:

                            # Check for cycle creation. If it's the first edge, or either node isn't in the tour.
                            
                            creates_cycle = False
                            if len(tour) > 0:
                                if i in tour and j in tour:
                                    
                                    node1_index = -1
                                    node2_index = -1

                                    try:
                                        node1_index = tour.index(i)
                                        node2_index = tour.index(j)
                                    except ValueError:
                                        creates_cycle = False
                                    
                                    if node1_index != -1 and node2_index != -1:
                                        if abs(node1_index-node2_index) == 1 or abs(node1_index-node2_index) == len(tour)-1 :
                                            creates_cycle = False # if adjacent, then it's fine

                                        else:
                                            creates_cycle = True
                            
                            if not creates_cycle:
                                best_edge = (i, j)
                                best_priority = edge_priorities[i, j]

            # If a suitable edge is found, add it to the tour
            if best_edge:
                node1, node2 = best_edge

                if len(tour) == 0:
                    tour = [node1, node2]
                elif node1 in tour:
                    tour.insert(tour.index(node1)+1, node2)
                elif node2 in tour:
                    tour.insert(tour.index(node2)+1, node1)
                else: 
                    # Handle disconnected component (randomly add)
                    tour.append(node1)
                    tour.append(node2)

                unvisited_nodes.discard(node1)
                unvisited_nodes.discard(node2)
                edge_count +=1
            else:
                # Restart if no suitable edge is found
                start_node = unvisited_nodes.pop() if unvisited_nodes else np.random.randint(n) # if unvisited_nodes is empty then randomly select any node

                tour.append(start_node)
                unvisited_nodes = set(range(n))
                for node in tour:
                    if node in unvisited_nodes:
                        unvisited_nodes.remove(node)
        
        # Complete the tour by returning to the start node.
        tour.append(tour[0])

        # Update heuristics matrix based on tour edges
        for i in range(n):
            node1 = tour[i]
            node2 = tour[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1
            
    # Normalize heuristics matrix
    heuristics_matrix /= num_samples
    return heuristics_matrix
