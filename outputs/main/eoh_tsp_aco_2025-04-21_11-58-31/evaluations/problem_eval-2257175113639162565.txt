import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples a large number of random paths, evaluates their lengths, and assigns higher probabilities to edges frequently appearing in shorter paths, inversely weighted by path length, to generate a heuristic matrix favoring edges from better solutions.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_samples):
        path = np.random.permutation(n)
        path_length = 0
        for i in range(n - 1):
            path_length += distance_matrix[path[i], path[i+1]]
        path_length += distance_matrix[path[n-1], path[0]]
        
        weight = 1.0 / path_length 
        
        for i in range(n - 1):
            heuristics_matrix[path[i], path[i+1]] += weight
            heuristics_matrix[path[i+1], path[i]] += weight
        heuristics_matrix[path[n-1], path[0]] += weight
        heuristics_matrix[path[0], path[n-1]] += weight
    
    return heuristics_matrix
