importance.

{This algorithm generates multiple tours by iteratively adding the edge with the highest pheromone value (initialized randomly and updated based on tour quality) while ensuring tour validity, then uses the edge frequencies across tours to create the heuristics matrix.}

```python
import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm generates multiple tours by iteratively adding the edge with the highest pheromone value (initialized randomly and updated based on tour quality) while ensuring tour validity, then uses the edge frequencies across tours to create the heuristics matrix.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.random.rand(n, n)
    np.fill_diagonal(pheromone_matrix, 0)
    heuristics_matrix = np.zeros((n, n))
    num_tours = 100

    for _ in range(num_tours):
        tour = []
        unvisited = set(range(n))
        start_node = np.random.choice(list(unvisited))
        current_node = start_node
        tour.append(current_node)
        unvisited.remove(current_node)
        
        while unvisited:
            
            probabilities = pheromone_matrix[current_node, :]
            
            # Mask already visited nodes
            mask = np.ones(n, dtype=bool)
            mask[list(tour)] = False
            probabilities = probabilities * mask
            
            if np.sum(probabilities) == 0:
              # If no valid edges exist, choose a random unvisited node
              next_node = np.random.choice(list(unvisited))
            else:
              probabilities = probabilities / np.sum(probabilities)  # Normalize
              next_node = np.random.choice(n, p=probabilities)

            tour.append(next_node)
            unvisited.remove(next_node)
            heuristics_matrix[current_node, next_node] += 1
            heuristics_matrix[next_node, current_node] += 1
            current_node = next_node

        heuristics_matrix[current_node, start_node] += 1
        heuristics_matrix[start_node, current_node] += 1
        
        # Update pheromone (simplified - reward edges in the tour)
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        
        pheromone_deposit = 1 / tour_length
        
        for i in range(n - 1):
            pheromone_matrix[tour[i], tour[i+1]] += pheromone_deposit
            pheromone_matrix[tour[i+1], tour[i]] += pheromone_deposit
        pheromone_matrix[tour[-1], tour[0]] += pheromone_deposit
        pheromone_matrix[tour[0], tour[-1]] += pheromone_deposit
        
    return heuristics_matrix
