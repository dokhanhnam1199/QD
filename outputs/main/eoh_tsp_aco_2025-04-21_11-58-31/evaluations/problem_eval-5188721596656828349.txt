import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively improving a random tour using 2-opt swaps, prioritizing edges frequently involved in successful swaps.}"""
    n = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # Initialize a random tour
        tour = np.random.permutation(n)
        best_tour = tour.copy()
        best_tour_length = calculate_tour_length(distance_matrix, best_tour)

        # Perform 2-opt swaps
        for i in range(n):
            for j in range(i + 2, n):
                new_tour = two_opt_swap(tour, i, j)
                new_tour_length = calculate_tour_length(distance_matrix, new_tour)

                if new_tour_length < best_tour_length:
                    best_tour = new_tour.copy()
                    best_tour_length = new_tour_length
                    #update heuristics matrix
                    for k in range(n-1):
                        heuristics_matrix[best_tour[k], best_tour[k+1]] += 1
                        heuristics_matrix[best_tour[k+1], best_tour[k]] += 1
                    heuristics_matrix[best_tour[-1], best_tour[0]] += 1
                    heuristics_matrix[best_tour[0], best_tour[-1]] += 1

    return heuristics_matrix

def calculate_tour_length(distance_matrix, tour):
    length = 0
    for i in range(len(tour) - 1):
        length += distance_matrix[tour[i], tour[i+1]]
    length += distance_matrix[tour[-1], tour[0]]
    return length

def two_opt_swap(tour, i, j):
    new_tour = tour.copy()
    new_tour[i:j+1] = tour[i:j+1][::-1]
    return heuristics_matrix
