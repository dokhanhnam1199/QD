import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach, iteratively evolving a population of tours based on their fitness (tour length) and using crossover and mutation operations to generate new candidate solutions, ultimately creating a heuristics matrix that reflects the frequency of edges in the best-performing tours.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.01

    # Initialize population
    population = []
    for _ in range(population_size):
        tour = np.random.permutation(n)
        population.append(tour)

    def calculate_fitness(tour):
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        return 1 / (tour_length + 1e-9)  # Invert for maximization

    def crossover(parent1, parent2):
        start = np.random.randint(n)
        end = np.random.randint(start + 1, n + 1) if start < n-1 else start + 1
        child = np.zeros(n, dtype=int) - 1

        child[start:end] = parent1[start:end]

        remaining_indices = np.where(child == -1)[0]
        parent2_indices = []
        for gene in parent2:
            if gene not in child[start:end]:
                parent2_indices.append(gene)

        child[remaining_indices] = parent2_indices

        return child

    def mutate(tour):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(n, 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]
        return tour
    
    for _ in range(num_generations):
        # Evaluate fitness
        fitness_scores = [calculate_fitness(tour) for tour in population]

        # Selection (roulette wheel selection)
        probabilities = fitness_scores / np.sum(fitness_scores)
        selected_indices = np.random.choice(population_size, size=population_size, p=probabilities)
        selected_population = [population[i] for i in selected_indices]

        # Crossover and Mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[i+1] if i+1 < population_size else selected_population[i]
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)

            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
        
        population = new_population

    # Create heuristics matrix from the best tour
    best_tour_index = np.argmax([calculate_fitness(tour) for tour in population])
    best_tour = population[best_tour_index]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n - 1):
        heuristics_matrix[best_tour[i], best_tour[i+1]] = 1
        heuristics_matrix[best_tour[i+1], best_tour[i]] = 1
    heuristics_matrix[best_tour[-1], best_tour[0]] = 1
    heuristics_matrix[best_tour[0], best_tour[-1]] = 1
    
    return heuristics_matrix
