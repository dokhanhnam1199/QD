import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random solutions to the TSP, evaluates their lengths, and uses the frequency of each edge appearing in good (short) solutions to construct a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    top_solutions_to_consider = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    all_solutions = []
    all_solution_lengths = []

    for _ in range(num_samples):
        permutation = np.random.permutation(n)
        solution = list(permutation)
        solution_length = 0
        for i in range(n - 1):
            solution_length += distance_matrix[solution[i], solution[i+1]]
        solution_length += distance_matrix[solution[-1], solution[0]]

        all_solutions.append(solution)
        all_solution_lengths.append(solution_length)

    # Find the top solutions
    sorted_indices = np.argsort(all_solution_lengths)
    top_solution_indices = sorted_indices[:top_solutions_to_consider]

    # Update heuristics matrix based on edge frequency in top solutions
    for index in top_solution_indices:
        solution = all_solutions[index]
        for i in range(n - 1):
            heuristics_matrix[solution[i], solution[i+1]] += 1
            heuristics_matrix[solution[i+1], solution[i]] += 1 # account for symmetry
        heuristics_matrix[solution[-1], solution[0]] += 1
        heuristics_matrix[solution[0], solution[-1]] += 1 # account for symmetry

    return heuristics_matrix
