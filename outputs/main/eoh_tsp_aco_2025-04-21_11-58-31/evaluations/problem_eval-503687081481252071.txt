import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm utilizes a genetic algorithm approach to evolve a population of tours and constructs a heuristics matrix based on the frequency of edges appearing in the best-performing tours across generations.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.01
    heuristics_matrix = np.zeros((n, n))

    def create_initial_population(size):
        population = []
        for _ in range(size):
            tour = np.random.permutation(n)
            population.append(tour)
        return population

    def calculate_fitness(tour):
        fitness = 0
        for i in range(n - 1):
            fitness += distance_matrix[tour[i], tour[i + 1]]
        fitness += distance_matrix[tour[-1], tour[0]]
        return fitness

    def crossover(parent1, parent2):
        start = np.random.randint(n)
        end = np.random.randint(start + 1, n + 1)
        child = np.zeros(n, dtype=int) - 1
        child[start:end] = parent1[start:end]
        
        remaining = [node for node in parent2 if node not in child[start:end]]
        
        child_idx = 0
        for i in range(n):
            if child[i] == -1:
                child[i] = remaining[child_idx]
                child_idx += 1
        
        return child
    

    def mutate(tour):
        for i in range(n):
            if np.random.rand() < mutation_rate:
                j = np.random.randint(n)
                tour[i], tour[j] = tour[j], tour[i]
        return tour

    population = create_initial_population(population_size)

    for _ in range(num_generations):
        fitness_scores = np.array([calculate_fitness(tour) for tour in population])
        
        # Selection (Roulette Wheel Selection)
        probabilities = 1 / (fitness_scores + 1e-6)  # Inverse fitness for minimization
        probabilities /= np.sum(probabilities)
        
        selected_indices = np.random.choice(population_size, size=population_size, replace=True, p=probabilities)
        selected_population = [population[i] for i in selected_indices]

        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[min(i + 1, population_size - 1)]
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
            
        population = new_population[:population_size] 
    
    best_fitness = np.inf
    best_tour = None
    for tour in population:
        fitness = calculate_fitness(tour)
        if fitness < best_fitness:
            best_fitness = fitness
            best_tour = tour

    # Update heuristics matrix based on the best tour from the last generation
    for i in range(n):
        node1 = best_tour[i]
        node2 = best_tour[(i + 1) % n]
        heuristics_matrix[node1, node2] += 1
        heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
