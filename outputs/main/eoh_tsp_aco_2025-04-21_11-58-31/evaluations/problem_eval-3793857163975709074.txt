import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix based on the ratio of shortest path distance to direct distance between nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate shortest path distance using Dijkstra's algorithm
                shortest_path_distance = float('inf')
                
                # Simplified Dijkstra (can be replaced with a proper implementation for larger graphs)
                unvisited = list(range(n))
                distances = {node: float('inf') for node in range(n)}
                distances[i] = 0
                
                while unvisited:
                    current_node = min(unvisited, key=distances.get)
                    unvisited.remove(current_node)
                    
                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] != 0:
                            alt_path = distances[current_node] + distance_matrix[current_node, neighbor]
                            if alt_path < distances[neighbor]:
                                distances[neighbor] = alt_path
                shortest_path_distance = distances[j]
                
                # Avoid division by zero
                if shortest_path_distance == 0:
                    heuristics_matrix[i, j] = 0
                    heuristics_matrix[j, i] = 0
                else:
                    heuristics_matrix[i, j] = distance_matrix[i, j] / shortest_path_distance
                    heuristics_matrix[j, i] = distance_matrix[j, i] / shortest_path_distance

    return heuristics_matrix
