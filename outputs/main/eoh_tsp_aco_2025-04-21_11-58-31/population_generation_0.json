[
     {
          "algorithm": "This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses a stochastic sampling approach based on a combination of nearest neighbor and random edge selection to generate multiple candidate TSP solutions, then averages the edge frequencies across these solutions to estimate the likelihood of each edge being part of an optimal tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 100\n\n    for _ in range(num_samples):\n        current_node = np.random.randint(n)\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            # Probabilistically choose between nearest neighbor and random selection\n            if np.random.rand() < 0.7:  # Favor nearest neighbor\n                nearest_neighbor = -1\n                min_distance = np.inf\n                for neighbor in unvisited_nodes:\n                    distance = distance_matrix[current_node, neighbor]\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_neighbor = neighbor\n                next_node = nearest_neighbor\n            else:  # Random selection\n                next_node = np.random.choice(list(unvisited_nodes))\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            heuristics_matrix[current_node, next_node] += 1\n            heuristics_matrix[next_node, current_node] += 1 #symmetric\n            current_node = next_node\n        \n        # Complete the tour\n        heuristics_matrix[current_node, tour[0]] += 1\n        heuristics_matrix[tour[0], current_node] += 1\n\n    return heuristics_matrix",
          "objective": 6.01684,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by assigning higher probabilities to shorter edges and edges connected to nodes with high degree, based on sampled solutions obtained by a nearest neighbor search.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm constructs a heuristics matrix by assigning higher probabilities to shorter edges and edges connected to nodes with high degree, based on sampled solutions obtained by a nearest neighbor search.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = -1\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                if distance_matrix[current_node, neighbor] < min_distance:\n                    min_distance = distance_matrix[current_node, neighbor]\n                    nearest_neighbor = neighbor\n\n            tour.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n\n        tour.append(start_node)\n\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n            \n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    # Incorporate distance information\n    heuristics_matrix = heuristics_matrix / (distance_matrix + 1e-9)  # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 6.055,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses stochastic sampling with a greedy nearest neighbor heuristic to generate multiple TSP solutions and then estimates the probability of each edge being present in an optimal solution.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm uses stochastic sampling with a greedy nearest neighbor heuristic to generate multiple TSP solutions and then estimates the probability of each edge being present in an optimal solution.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        unvisited_nodes = list(range(n))\n        unvisited_nodes.remove(start_node)\n        current_node = start_node\n        tour = [start_node]\n\n        while unvisited_nodes:\n            nearest_node = min(unvisited_nodes, key=lambda node: distance_matrix[current_node, node])\n            tour.append(nearest_node)\n            unvisited_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        tour.append(start_node)\n\n        for i in range(n):\n            heuristics_matrix[tour[i], tour[i+1]] += 1\n            heuristics_matrix[tour[i+1], tour[i]] += 1\n\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 6.26199,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively constructs solutions by probabilistically selecting edges based on their length and connectivity, refining the probabilities based on the best solutions found.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm iteratively constructs solutions by probabilistically selecting edges based on their length and connectivity, refining the probabilities based on the best solutions found.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones_like(distance_matrix)\n    \n    num_iterations = 100\n    num_samples = 50\n    \n    for _ in range(num_iterations):\n        paths = []\n        costs = []\n        \n        for _ in range(num_samples):\n            unvisited = set(range(n))\n            start_node = np.random.choice(list(unvisited))\n            current_node = start_node\n            unvisited.remove(current_node)\n            path = [current_node]\n            total_cost = 0\n            \n            while unvisited:\n                probabilities = heuristics_matrix[current_node, :]\n                probabilities[current_node] = 0  # Avoid self-loops\n                \n                valid_indices = list(unvisited)\n                probabilities_subset = probabilities[valid_indices]\n                \n                if np.sum(probabilities_subset) == 0:\n                    next_node = np.random.choice(valid_indices)\n                else:\n                    probabilities_subset = probabilities_subset / np.sum(probabilities_subset)  # Normalize\n                    next_node = np.random.choice(valid_indices, p=probabilities_subset)\n                \n                next_node_index = valid_indices.index(next_node)\n                next_node = valid_indices[next_node_index]\n                \n                total_cost += distance_matrix[current_node, next_node]\n                current_node = next_node\n                path.append(current_node)\n                unvisited.remove(current_node)\n\n            total_cost += distance_matrix[current_node, start_node]\n            path.append(start_node)\n            \n            paths.append(path)\n            costs.append(total_cost)\n            \n        best_path_index = np.argmin(costs)\n        best_path = paths[best_path_index]\n        \n        # Update heuristics based on the best path\n        for i in range(n):\n            node1 = best_path[i]\n            node2 = best_path[(i + 1) % n]\n            heuristics_matrix[node1, node2] *= 1.1  # Increase probability for edges in the best path\n            heuristics_matrix[node2, node1] *= 1.1\n            \n        # Decrease probability for edges not in good solutions - optional\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    is_in_best_path = False\n                    for k in range(n):\n                        if (best_path[k] == i and best_path[(k+1)%n] == j) or \\\n                           (best_path[k] == j and best_path[(k+1)%n] == i):\n                            is_in_best_path = True\n                            break\n                    if not is_in_best_path:\n                        heuristics_matrix[i, j] *= 0.95\n                        \n\n        heuristics_matrix = np.clip(heuristics_matrix, 0.001, 1000) # prevent values to go to 0 or infinity\n    \n    return heuristics_matrix",
          "objective": 11.3397,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates a set of random tours, evaluates them, and assigns higher probabilities to edges appearing in better tours, iteratively refining the probability matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates a set of random tours, evaluates them, and assigns higher probabilities to edges appearing in better tours, iteratively refining the probability matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.ones_like(distance_matrix)\n    \n    num_iterations = 100\n    num_tours = 50\n    \n    for _ in range(num_iterations):\n        tours = []\n        tour_lengths = []\n        \n        for _ in range(num_tours):\n            tour = np.random.permutation(n)\n            tour_length = 0\n            for i in range(n - 1):\n                tour_length += distance_matrix[tour[i], tour[i+1]]\n            tour_length += distance_matrix[tour[-1], tour[0]]\n            \n            tours.append(tour)\n            tour_lengths.append(tour_length)\n        \n        best_tours_indices = np.argsort(tour_lengths)[:num_tours // 5] \n        \n        for index in best_tours_indices:\n            tour = tours[index]\n            for i in range(n - 1):\n                heuristics_matrix[tour[i], tour[i+1]] += 1\n                heuristics_matrix[tour[i+1], tour[i]] += 1\n            heuristics_matrix[tour[-1], tour[0]] += 1\n            heuristics_matrix[tour[0], tour[-1]] += 1\n\n    return heuristics_matrix",
          "objective": 12.84294,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random tours, scores each edge based on how frequently it appears in the best tours, and returns a matrix representing the heuristic scores for each edge.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n  \"\"\"{This algorithm generates multiple random tours, scores each edge based on how frequently it appears in the best tours, and returns a matrix representing the heuristic scores for each edge.}\"\"\"\n  num_nodes = distance_matrix.shape[0]\n  num_tours = 1000\n  top_tours = 100\n  \n  all_tours = []\n  all_tour_lengths = []\n\n  for _ in range(num_tours):\n    tour = np.random.permutation(num_nodes)\n    tour_length = 0\n    for i in range(num_nodes - 1):\n      tour_length += distance_matrix[tour[i], tour[i+1]]\n    tour_length += distance_matrix[tour[-1], tour[0]] \n    all_tours.append(tour)\n    all_tour_lengths.append(tour_length)\n  \n  ranked_tours_indices = np.argsort(all_tour_lengths)\n  top_tours_indices = ranked_tours_indices[:top_tours]\n  top_tours_set = [all_tours[i] for i in top_tours_indices]\n  \n  heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n  \n  for tour in top_tours_set:\n    for i in range(num_nodes - 1):\n      heuristics_matrix[tour[i], tour[i+1]] += 1\n      heuristics_matrix[tour[i+1], tour[i]] += 1\n    heuristics_matrix[tour[-1], tour[0]] += 1\n    heuristics_matrix[tour[0], tour[-1]] += 1\n  \n  return heuristics_matrix",
          "objective": 14.15513,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm generates multiple random TSP solutions using a nearest neighbor heuristic with a stochastic element, and then averages the edge frequencies across all solutions to create a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm generates multiple random TSP solutions using a nearest neighbor heuristic with a stochastic element, and then averages the edge frequencies across all solutions to create a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        path = [current_node]\n\n        while unvisited_nodes:\n            distances = distance_matrix[current_node, :]\n            \n            # Apply stochastic nearest neighbor with a chance to explore\n            probabilities = np.zeros(n)\n            for i in unvisited_nodes:\n                probabilities[i] = np.exp(-distance_matrix[current_node, i]) # adjust randomness here\n\n            probabilities /= np.sum(probabilities)\n\n            next_node = np.random.choice(n, p=probabilities)\n\n            if next_node not in unvisited_nodes:\n                distances_unvisited = [distance_matrix[current_node, i] for i in unvisited_nodes]\n                next_node = list(unvisited_nodes)[np.argmin(distances_unvisited)]\n                \n\n            path.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        path.append(start_node)  # Return to the starting node\n        \n        # Update heuristics matrix based on the sampled path\n        for i in range(len(path) - 1):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n    \n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 14.38232,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random paths, scores them by length, and then creates a heuristic matrix based on how frequently each edge appears in the shortest paths.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple random paths, scores them by length, and then creates a heuristic matrix based on how frequently each edge appears in the shortest paths.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    shortest_paths_count = 100\n\n    paths = []\n    path_lengths = []\n    for _ in range(num_samples):\n        path = np.random.permutation(n)\n        path_length = 0\n        for i in range(n - 1):\n            path_length += distance_matrix[path[i], path[i+1]]\n        path_length += distance_matrix[path[-1], path[0]]\n        paths.append(path)\n        path_lengths.append(path_length)\n    \n    sorted_indices = np.argsort(path_lengths)\n    \n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    for i in range(shortest_paths_count):\n        best_path = paths[sorted_indices[i]]\n        for j in range(n - 1):\n            u = best_path[j]\n            v = best_path[j+1]\n            heuristics_matrix[u, v] += 1\n            heuristics_matrix[v, u] += 1\n        heuristics_matrix[best_path[-1], best_path[0]] += 1\n        heuristics_matrix[best_path[0], best_path[-1]] += 1\n\n    return heuristics_matrix",
          "objective": 14.42496,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random solutions to the TSP, evaluates their lengths, and uses the frequency of each edge appearing in good (short) solutions to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple random solutions to the TSP, evaluates their lengths, and uses the frequency of each edge appearing in good (short) solutions to construct a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    top_solutions_to_consider = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    all_solutions = []\n    all_solution_lengths = []\n\n    for _ in range(num_samples):\n        permutation = np.random.permutation(n)\n        solution = list(permutation)\n        solution_length = 0\n        for i in range(n - 1):\n            solution_length += distance_matrix[solution[i], solution[i+1]]\n        solution_length += distance_matrix[solution[-1], solution[0]]\n\n        all_solutions.append(solution)\n        all_solution_lengths.append(solution_length)\n\n    # Find the top solutions\n    sorted_indices = np.argsort(all_solution_lengths)\n    top_solution_indices = sorted_indices[:top_solutions_to_consider]\n\n    # Update heuristics matrix based on edge frequency in top solutions\n    for index in top_solution_indices:\n        solution = all_solutions[index]\n        for i in range(n - 1):\n            heuristics_matrix[solution[i], solution[i+1]] += 1\n            heuristics_matrix[solution[i+1], solution[i]] += 1 # account for symmetry\n        heuristics_matrix[solution[-1], solution[0]] += 1\n        heuristics_matrix[solution[0], solution[-1]] += 1 # account for symmetry\n\n    return heuristics_matrix",
          "objective": 14.544,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a set of candidate tours by iteratively adding edges with probability inversely proportional to their length, then updates edge inclusion probabilities based on how frequently each edge appears in the best sampled tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples a set of candidate tours by iteratively adding edges with probability inversely proportional to their length, then updates edge inclusion probabilities based on how frequently each edge appears in the best sampled tours.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 100\n    best_tour_length = float('inf')\n    best_tours = []\n\n    for _ in range(num_samples):\n        current_tour = []\n        unvisited = list(range(n))\n        start_node = np.random.choice(unvisited)\n        current_tour.append(start_node)\n        unvisited.remove(start_node)\n        current_length = 0\n\n        while unvisited:\n            current_node = current_tour[-1]\n            probabilities = 1.0 / (distance_matrix[current_node, unvisited] + 1e-6)  # Avoid division by zero\n            probabilities /= np.sum(probabilities)\n            next_node = np.random.choice(unvisited, p=probabilities)\n            current_tour.append(next_node)\n            current_length += distance_matrix[current_node, next_node]\n            unvisited.remove(next_node)\n\n        current_length += distance_matrix[current_tour[-1], current_tour[0]] # Return to start\n        \n        if current_length < best_tour_length:\n            best_tour_length = current_length\n            best_tours = [current_tour]\n        elif current_length == best_tour_length:\n            best_tours.append(current_tour)\n\n    for tour in best_tours:\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[(i + 1) % n]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix = heuristics_matrix / len(best_tours) \n    return heuristics_matrix",
          "objective": 15.26047,
          "other_inf": null
     }
]