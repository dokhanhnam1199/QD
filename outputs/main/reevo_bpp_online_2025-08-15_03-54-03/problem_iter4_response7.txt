```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined First Fit strategy.

    This strategy prioritizes bins that can accommodate the item and among those,
    favors bins that are "more full" (i.e., have less remaining capacity). This
    aims to leave larger capacity bins available for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority indicates a more suitable bin. Bins that cannot fit
        the item are given a priority of -1. Bins that can fit are scored
        based on their remaining capacity, with smaller remaining capacities
        receiving higher scores.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority for non-fitting bins

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign a priority score.
    # We want to prioritize bins with LESS remaining capacity.
    # A simple way to achieve this is to assign a score that is the negative
    # of the remaining capacity. The smaller the remaining capacity, the
    # less negative (i.e., higher) the score will be.
    # We add the item size to the remaining capacity calculation to
    # reflect how "full" the bin becomes *after* packing.
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]

    if fitting_bins_capacities.size > 0:
        # Calculate the remaining capacity *after* placing the item.
        # Smaller values here are better.
        remaining_after_fit = fitting_bins_capacities - item

        # To make smaller remaining capacities have higher priority,
        # we can use a transformation. A simple one is:
        # max_possible_capacity - remaining_after_fit.
        # We use a value slightly larger than any possible remaining capacity
        # to ensure all fitting bins have positive and distinct priorities
        # relative to the -1 baseline.
        # A reasonable upper bound for remaining capacity could be the bin's original capacity.
        # If we don't know original capacity, a sufficiently large number will do.
        # Let's use the max of current remaining capacities plus the item size as a proxy for a "large enough" value.
        large_constant = np.max(bins_remain_cap) + item if bins_remain_cap.size > 0 else item

        priorities[can_fit_mask] = large_constant - remaining_after_fit

    return priorities
```
