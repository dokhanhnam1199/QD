```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy
    that prioritizes bins with minimal *relative* remaining capacity after packing.

    This version aims to differentiate "good" fits by considering the proportion
    of remaining capacity relative to the bin's original capacity (approximated by
    current remaining capacity + item size). It favors bins that are filled
    more completely in proportion to their available space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1. Bins that can fit are scored based on
        the *relative* remaining capacity after packing, favoring those that
        are more "tightly" filled.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* packing
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if fitting_bins_indices.size > 0:
        fitting_bins_capacities = bins_remain_cap[fitting_bins_indices]
        resulting_remain_cap = fitting_bins_capacities - item

        # To prioritize tighter fits, we want to favor bins where `resulting_remain_cap`
        # is small relative to the bin's capacity before packing.
        # The "capacity before packing" can be approximated by `fitting_bins_capacities`.
        # A score that is inversely proportional to `resulting_remain_cap / fitting_bins_capacities`
        # would favor smaller relative remaining space.
        # To avoid division by zero or near-zero capacities, we can use:
        # 1 / (resulting_remain_cap + epsilon) as a base score,
        # and then potentially scale it by the proportion filled.

        # A simpler approach to prioritize smaller *absolute* remaining capacity,
        # while differentiating:
        # Consider the "tightness" as (bin_capacity_before_item - resulting_remain_cap) / bin_capacity_before_item
        # which simplifies to `item / fitting_bins_capacities`.
        # This favors bins where the item takes up a larger proportion of the current space.
        # To ensure higher score for better fit (larger proportion), we use this value directly.
        # We still want to prefer bins that result in *less* remaining space overall if proportions are equal.
        # Let's combine these: prioritize by (1 - proportion of remaining space).
        # Proportion of remaining space = resulting_remain_cap / fitting_bins_capacities
        # So, priority = 1 - (resulting_remain_cap / fitting_bins_capacities)
        # = (fitting_bins_capacities - resulting_remain_cap) / fitting_bins_capacities
        # = item / fitting_bins_capacities

        # To ensure higher values are better, we can use a large constant minus this proportion,
        # or directly use the proportion if we invert the logic and say smaller proportion is worse.
        # Let's aim for higher score = better fit.
        # Good fit means small `resulting_remain_cap`.
        # So, a priority score like `1.0 / (resulting_remain_cap + epsilon)` is good.
        # To incorporate the "relative" aspect, we can penalize bins that leave a lot of space relatively.
        # Consider the "waste" as `resulting_remain_cap`. We want to minimize this waste.
        # Prioritize by `large_value - resulting_remain_cap`.
        # To make it relative, we can consider `large_value - resulting_remain_cap / fitting_bins_capacities`
        # This still might not differentiate enough.

        # Let's go back to prioritizing smaller *absolute* remaining capacity after packing,
        # but also consider the original capacity available.
        # A bin that is almost full is good. `fitting_bins_capacities - resulting_remain_cap` is `item`.
        # We want to maximize `item / fitting_bins_capacities`.
        # However, if two bins have the same `item / fitting_bins_capacities`, we should
        # prefer the one with less `resulting_remain_cap`.

        # A heuristic: priority = C - resulting_remain_cap.
        # To make it relative, and ensure higher is better:
        # Score = (fitting_bins_capacities - resulting_remain_cap) / fitting_bins_capacities
        # = item / fitting_bins_capacities.
        # This score is between 0 and 1. Higher means better fit.
        # To make it more discriminating and always positive, and larger for better fits:
        # Use `1 / (resulting_remain_cap + epsilon)` as in v0, but refine.
        # Or use `fitting_bins_capacities - resulting_remain_cap`.

        # Let's try to score based on how "full" the bin becomes relative to its initial state.
        # A bin that is already very full is more likely to be a "tight" fit.
        # Priority = `fitting_bins_capacities` - `resulting_remain_cap`
        # This is `item`. So, this prioritizes larger items when fitting tightly.
        # This doesn't account for the proportion.

        # Consider the inverse of the *proportion* of remaining capacity.
        # Proportion remaining = `resulting_remain_cap / fitting_bins_capacities`
        # We want to minimize this proportion. So, priority is inversely related to it.
        # Priority = `fitting_bins_capacities / (resulting_remain_cap + epsilon)`

        epsilon = 1e-9
        # This prioritizes bins where the remaining capacity is small *relative* to its current capacity.
        # E.g., if bin has 10 capacity, item is 7, resulting cap is 3. Ratio = 3/10 = 0.3. Score = 1/0.3 = 3.33
        # If bin has 100 capacity, item is 7, resulting cap is 93. Ratio = 93/100 = 0.93. Score = 1/0.93 = 1.07
        # This clearly favors the first case (tighter fit).
        priorities[fitting_bins_indices] = fitting_bins_capacities / (resulting_remain_cap + epsilon)

    return priorities
```
