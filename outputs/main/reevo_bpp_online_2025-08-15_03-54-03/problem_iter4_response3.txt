```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy,
    prioritizing minimizing waste.

    This heuristic prioritizes bins that, after placing the item, will have the least
    remaining capacity. This aims to minimize wasted space within each bin,
    potentially leading to fewer bins being used overall. Bins that cannot fit
    the item are assigned a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority indicates a more suitable bin according to the Best Fit strategy.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the residual capacity after placement
    residuals = bins_remain_cap[can_fit_mask] - item

    # Assign priority: higher priority for smaller residuals (tighter fits).
    # We use a large constant minus the residual. This way, smaller residuals
    # result in higher priority scores. A perfect fit (residual = 0) gets the
    # highest score.
    # Adding 1e-9 to the residual before inversion (as in v1) can lead to very large
    # scores for near-perfect fits, potentially overshadowing other considerations.
    # A simple approach is to directly use the negative residual, which means
    # less negative (closer to zero) is better, or a transformation like
    # `max_possible_residual - residual`.
    # Let's use `1 / (residual + epsilon)` for directness, similar to v1, but
    # conceptually understanding that we want to minimize `residual`.
    # The key idea is that smaller residuals mean a better fit.
    # We'll use `1 / (residual + a_small_constant)` to keep it simple and
    # prioritize smaller residuals. A perfect fit (residual = 0) will yield
    # the highest priority.

    # A very small epsilon to prevent division by zero if residual is exactly 0.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (residuals + epsilon)

    return priorities
```
