```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin where it fits
    most snugly, leaving the smallest remaining capacity. This often leads
    to better packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a better fit.
    """
    # We want to prioritize bins where the item fits snugly.
    # A good measure of snugness is how much capacity is left AFTER placing the item.
    # We prefer bins that result in a smaller remaining capacity, but only if the item fits.

    # Calculate potential remaining capacity if the item is placed in each bin.
    # If the item doesn't fit, the remaining capacity is considered infinity (or a very large number).
    potential_remaining_cap = np.where(bins_remain_cap >= item,
                                       bins_remain_cap - item,
                                       np.inf)

    # We want to maximize the priority for bins with the smallest *positive* remaining capacity.
    # If potential_remaining_cap is 0, it's a perfect fit and should have high priority.
    # If potential_remaining_cap is positive, smaller values are better.
    # If potential_remaining_cap is inf, it means the item doesn't fit, so it should have very low priority.

    # A common heuristic is to use the inverse of the remaining capacity.
    # To handle the case where remaining capacity is zero (perfect fit), we can add a small epsilon or
    # use a strategy that maps 0 to a very high value.
    # For 'Best Fit', we want to prioritize bins that have just enough capacity, or a bit more.
    # The difference (bins_remain_cap - item) represents the 'waste' if the item fits. We want to minimize waste.

    # Let's define priority as the negative of the remaining capacity if it fits.
    # The highest priority will be for the smallest negative number (closest to zero),
    # which corresponds to the smallest positive remaining capacity.
    # For bins where the item doesn't fit (np.inf), we'll assign a very low priority.

    priorities = np.zeros_like(bins_remain_cap)

    # For bins where the item fits
    fits_mask = bins_remain_cap >= item
    if np.any(fits_mask):
        remaining_after_fit = bins_remain_cap[fits_mask] - item
        # We want to prioritize bins with smaller remaining capacity.
        # So, we use the negative of the remaining capacity.
        # The most negative value corresponds to the smallest remaining capacity, hence the best fit.
        # Adding a small constant to the remaining capacity ensures that the minimum remaining capacity (0)
        # gets a higher score than larger remaining capacities, but avoids division by zero issues
        # if we were to use 1 / (remaining_capacity + epsilon).
        # Here, we'll simply use the negative remaining capacity directly.
        priorities[fits_mask] = -remaining_after_fit

    # For bins where the item doesn't fit, assign a very low priority (large negative number)
    # This ensures they are selected only if no other bins are available.
    # A large negative number like -infinity will be correctly handled by argmax.
    priorities[~fits_mask] = -np.inf

    return priorities
```
