[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using a sigmoid-based function that favors bins with small positive residuals.\n\n    This heuristic prioritizes bins where the remaining capacity (`r`) after placing the item\n    is as close to zero as possible, but still non-negative. The sigmoid function\n    `1 / (1 + exp(k * r))` is used, where `k` is a sensitivity parameter.\n    A higher `k` makes the priority drop faster as `r` increases.\n    Bins where the item does not fit (i.e., `r < 0`) receive a priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Sensitivity parameter for the sigmoid function.\n    # A higher k means a sharper drop in priority as the remaining capacity increases.\n    # This value can be tuned based on experimental results.\n    k = 15.0  # Increased sensitivity\n\n    # Initialize priorities to 0. Bins where the item cannot fit will keep this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    residuals = bins_remain_cap - item\n\n    # Identify bins where the item can fit (residual >= 0).\n    can_fit_mask = residuals >= 0\n\n    # For bins that can fit the item, calculate the priority score using the sigmoid function.\n    # The function 1 / (1 + exp(k * residual)) produces scores between 0 and 1.\n    # - When residual is 0 (perfect fit), score is 1 / (1 + exp(0)) = 0.5.\n    # - When residual is small positive (e.g., 0.01, k=15), arg is 0.15, score is ~0.53 (slightly higher priority).\n    # - When residual is large positive (e.g., 1.0, k=15), arg is 15.0, score is ~0.000003 (very low priority).\n    # This correctly prioritizes bins with the smallest positive residuals.\n    if np.any(can_fit_mask):\n        # Apply sigmoid to the residuals. Higher `k` will make the priority drop more sharply\n        # as the residual increases, effectively favoring bins with minimal remaining capacity.\n        priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(k * residuals[can_fit_mask]))\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using a strategy that favors bins with small positive residuals (Best Fit).\n\n    This heuristic prioritizes bins where the remaining capacity (`r`) after placing the item\n    is as close to zero as possible, but still non-negative. This is a direct implementation\n    of the Best Fit strategy. Bins where the item does not fit (i.e., `r < 0`) receive a\n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher priority indicates a better fit for the item.\n    \"\"\"\n    # Initialize priorities to 0. Bins where the item cannot fit will keep this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    residuals = bins_remain_cap - item\n\n    # Identify bins where the item can fit (residual >= 0).\n    can_fit_mask = residuals >= 0\n\n    # For bins that can fit the item, calculate the priority.\n    # The goal is to have the smallest non-negative residual.\n    # We can achieve this by taking the inverse of the residual.\n    # A small epsilon is added to avoid division by zero for bins with exact fits.\n    # A large value for exact fits ensures they are prioritized.\n    if np.any(can_fit_mask):\n        # Using 1 / (residual + epsilon) prioritizes smaller residuals.\n        # An exact fit (residual=0) will get a very high priority (1/epsilon).\n        priorities[can_fit_mask] = 1.0 / (residuals[can_fit_mask] + 1e-9)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 43.01955000865388,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Best Fit strategy.\n\n    The Best Fit strategy prioritizes bins that can accommodate the item and\n    leave the *least* amount of remaining capacity. This means we are looking\n    for bins where `bins_remain_cap - item` is minimized (but non-negative).\n    This function implements Best Fit by assigning a higher priority to bins\n    that result in a smaller non-negative residual.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the\n        item are given a priority of negative infinity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf)  # Initialize with a very low priority\n\n    # Calculate the remaining capacity if the item is placed in each bin\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item (remaining capacity is non-negative)\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # For bins that can fit the item, assign a priority score.\n    # The Best Fit strategy prioritizes bins with the smallest non-negative residual.\n    # To achieve this with a \"higher is better\" priority, we want to assign\n    # higher scores to smaller residuals. A simple linear mapping is to\n    # use the negative of the residual.\n    # E.g., if residuals are [0.1, 0.5, 1.0], the priorities will be [-0.1, -0.5, -1.0].\n    # Since -0.1 > -0.5 > -1.0, this correctly prioritizes the bin with the smallest residual.\n    if np.any(can_fit_mask):\n        priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 31.699250014423125,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit strategy,\n    prioritizing minimizing waste.\n\n    This heuristic prioritizes bins that, after placing the item, will have the least\n    remaining capacity. This aims to minimize wasted space within each bin,\n    potentially leading to fewer bins being used overall. Bins that cannot fit\n    the item are assigned a priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher priority indicates a more suitable bin according to the Best Fit strategy.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the residual capacity after placement\n    residuals = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority: higher priority for smaller residuals (tighter fits).\n    # We use a large constant minus the residual. This way, smaller residuals\n    # result in higher priority scores. A perfect fit (residual = 0) gets the\n    # highest score.\n    # Adding 1e-9 to the residual before inversion (as in v1) can lead to very large\n    # scores for near-perfect fits, potentially overshadowing other considerations.\n    # A simple approach is to directly use the negative residual, which means\n    # less negative (closer to zero) is better, or a transformation like\n    # `max_possible_residual - residual`.\n    # Let's use `1 / (residual + epsilon)` for directness, similar to v1, but\n    # conceptually understanding that we want to minimize `residual`.\n    # The key idea is that smaller residuals mean a better fit.\n    # We'll use `1 / (residual + a_small_constant)` to keep it simple and\n    # prioritize smaller residuals. A perfect fit (residual = 0) will yield\n    # the highest priority.\n\n    # A very small epsilon to prevent division by zero if residual is exactly 0.\n    epsilon = 1e-9\n    priorities[can_fit_mask] = 1.0 / (residuals + epsilon)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n\n    The Best Fit strategy prioritizes bins that can accommodate the item and\n    then selects the bin that results in the smallest remaining capacity after\n    packing. This version refines the scoring to more directly reflect the \"best fit\"\n    by minimizing the remaining capacity after placement.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the\n        item are given a score of -1. Bins that can fit the item are scored\n        based on the *remaining capacity after packing*, favoring smaller\n        remaining capacities. A lower remaining capacity after packing yields a higher score.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with a low priority score\n\n    # Calculate potential remaining capacity if the item fits in each bin\n    potential_remaining_caps = bins_remain_cap - item\n\n    # Identify bins that can accommodate the current item\n    can_fit_mask = potential_remaining_caps >= 0\n\n    # For bins that can fit the item, assign a priority score.\n    # The \"best fit\" is achieved when the remaining capacity after placing the item is minimized.\n    # To translate minimizing remaining capacity into maximizing priority score,\n    # we can use the negative of the potential remaining capacity.\n    # A smaller positive remaining capacity will result in a larger negative number,\n    # thus a higher score when we want to prioritize it.\n    fitting_bins_potential_remaining = potential_remaining_caps[can_fit_mask]\n\n    if fitting_bins_potential_remaining.size > 0:\n        # Assign priorities: -potential_remaining_caps.\n        # This way, a smaller potential_remaining_caps (meaning a better fit)\n        # will result in a larger (less negative) or positive value, hence higher priority.\n        priorities[can_fit_mask] = -fitting_bins_potential_remaining\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 44.97261104228487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, favoring tighter fits smoothly.\n\n    This heuristic prioritizes bins that can accommodate the item, and among those,\n    it favors bins that will have the smallest remaining capacity after packing.\n    This is a variation of the \"Best Fit\" strategy, but uses a smooth, graduated\n    priority based on the *gap* between the bin's remaining capacity and the item size.\n\n    Specifically, for bins where `bins_remain_cap >= item`:\n    - The priority is determined by the remaining capacity *after* packing (`bins_remain_cap - item`).\n    - Smaller positive gaps (tighter fits) receive higher priority.\n    - Larger gaps receive lower priority.\n    - Bins that cannot fit the item receive a priority of 0.\n\n    The priority score is calculated as:\n    `score = exp(-scale_factor * (bins_remain_cap - item))`\n    for valid bins. The negative exponential function ensures that as the\n    remaining capacity after packing decreases (i.e., the fit gets tighter),\n    the priority score increases smoothly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a small epsilon to avoid issues with near-zero gaps and ensure positive values for exp.\n    epsilon = 1e-9\n    \n    # Scale factor to control the steepness of the exponential decay.\n    # A higher value makes the priority drop off more quickly as the gap increases.\n    # Tune this value based on empirical performance.\n    scale_factor = 1.0\n\n    # Identify bins that have enough remaining capacity to fit the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the residual capacity after packing for bins that can fit the item.\n    fitting_bins_residual_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities using a negative exponential function on the residual capacity.\n    # This provides a smooth, graduated priority:\n    # - As residual capacity approaches 0 (tight fit), exp(-scale_factor * 0) = 1 (highest priority).\n    # - As residual capacity increases (loose fit), exp(-scale_factor * large_value) approaches 0 (low priority).\n    # We add epsilon to the residual capacity before exponentiation to avoid exp(0) precisely,\n    # and to ensure that bins with exactly zero residual capacity (perfect fits) get a score of 1.\n    # However, simply using the residual capacity directly is more aligned with the goal.\n    # The exponential function itself handles the smooth decay.\n    priorities[can_fit_mask] = np.exp(-scale_factor * fitting_bins_residual_cap)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 1.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a strategy\n    that prioritizes bins with minimal remaining capacity after packing (tighter fit).\n\n    This version uses an inverse relationship with the resulting remaining capacity\n    to strongly favor bins that will be almost full after packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the\n        item are given a score of -1. Bins that can fit the item are scored\n        based on the *resulting* remaining capacity after packing, favoring\n        those that leave minimal remaining capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity *after* packing\n    if np.any(can_fit_mask):\n        resulting_remain_cap = bins_remain_cap[can_fit_mask] - item\n\n        # Prioritize bins with the *least* resulting remaining capacity.\n        # Using `1 / (resulting_remain_cap + epsilon)` creates an inverse relationship,\n        # giving much higher scores to bins with smaller remaining capacities.\n        # An epsilon is added to avoid division by zero if remaining capacity is exactly 0.\n        # This also ensures that scores are positive, thus clearly higher than -1.\n        epsilon = 1e-9\n        priorities[can_fit_mask] = 1.0 / (resulting_remain_cap + epsilon)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 2.0,
    "halstead": 50.18947501009619,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a refined First Fit strategy.\n\n    This strategy prioritizes bins that can accommodate the item and among those,\n    favors bins that are \"more full\" (i.e., have less remaining capacity). This\n    aims to leave larger capacity bins available for potentially larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher priority indicates a more suitable bin. Bins that cannot fit\n        the item are given a priority of -1. Bins that can fit are scored\n        based on their remaining capacity, with smaller remaining capacities\n        receiving higher scores.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority for non-fitting bins\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, assign a priority score.\n    # We want to prioritize bins with LESS remaining capacity.\n    # A simple way to achieve this is to assign a score that is the negative\n    # of the remaining capacity. The smaller the remaining capacity, the\n    # less negative (i.e., higher) the score will be.\n    # We add the item size to the remaining capacity calculation to\n    # reflect how \"full\" the bin becomes *after* packing.\n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n\n    if fitting_bins_capacities.size > 0:\n        # Calculate the remaining capacity *after* placing the item.\n        # Smaller values here are better.\n        remaining_after_fit = fitting_bins_capacities - item\n\n        # To make smaller remaining capacities have higher priority,\n        # we can use a transformation. A simple one is:\n        # max_possible_capacity - remaining_after_fit.\n        # We use a value slightly larger than any possible remaining capacity\n        # to ensure all fitting bins have positive and distinct priorities\n        # relative to the -1 baseline.\n        # A reasonable upper bound for remaining capacity could be the bin's original capacity.\n        # If we don't know original capacity, a sufficiently large number will do.\n        # Let's use the max of current remaining capacities plus the item size as a proxy for a \"large enough\" value.\n        large_constant = np.max(bins_remain_cap) + item if bins_remain_cap.size > 0 else item\n\n        priorities[can_fit_mask] = large_constant - remaining_after_fit\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 3.0,
    "halstead": 76.14709844115208,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using First Fit strategy, favoring bins with minimal remaining capacity.\n\n    This heuristic prioritizes bins that can fit the item and among those,\n    prefers bins with the least remaining capacity. This is a direct implementation\n    of the First Fit strategy where the \"priority\" is simply a score that ranks\n    eligible bins by their remaining capacity. Bins that cannot fit the item\n    receive a score of -1, effectively excluding them from selection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins that can fit the item are\n        scored based on their remaining capacity, with smaller capacities being better.\n        Bins that cannot fit the item have a score of -1.\n    \"\"\"\n    # Initialize priorities to -1, indicating that the item cannot fit or it's the lowest priority.\n    priorities = np.full_like(bins_remain_cap, -1.0)\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, assign a priority score.\n    # We want to prioritize bins with *less* remaining capacity.\n    # A simple way to achieve this is to use the negative of the remaining capacity.\n    # This way, a bin with remaining capacity 'r' gets a score of '-r'.\n    # A smaller 'r' (e.g., 0.1) will result in a higher score (-0.1) than a larger 'r' (e.g., 1.0, score -1.0).\n    # This directly implements the First Fit logic of choosing the first available bin\n    # that can accommodate the item, effectively prioritizing those with less slack.\n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n    if fitting_bins_capacities.size > 0:\n        priorities[can_fit_mask] = -fitting_bins_capacities\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "cyclomatic_complexity": 2.0,
    "halstead": 31.699250014423125,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using a strategy that favors bins with minimal positive residuals.\n\n    This heuristic prioritizes bins where the remaining capacity after placing the item\n    is as close to zero as possible, but still non-negative. This aims to fill bins\n    more tightly. Bins where the item does not fit will have the lowest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value, so bins that cannot fit the item\n    # have the lowest priority.\n    priorities = np.full_like(bins_remain_cap, -float('inf'))\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    residuals = bins_remain_cap - item\n\n    # Identify bins where the item can fit (residual >= 0).\n    can_fit_mask = residuals >= 0\n\n    # For bins that can fit the item, the priority is inversely proportional to the residual.\n    # We want to minimize the residual (residual >= 0), so a smaller residual means higher priority.\n    # Using `1 / (residual + epsilon)` ensures that bins with smaller positive residuals\n    # get higher scores. Adding epsilon avoids division by zero when residual is exactly 0.\n    epsilon = 1e-9\n    priorities[can_fit_mask] = 1.0 / (residuals[can_fit_mask] + epsilon)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.30296890880645,
    "exec_success": true
  }
]