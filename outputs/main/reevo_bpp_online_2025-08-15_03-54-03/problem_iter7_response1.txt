```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy
    that prioritizes bins with minimal *positive* residual capacity after packing.

    This version aims to differentiate "good" fits by favoring bins that result in
    a smaller remaining capacity. It uses a non-linear function to give higher
    priority to bins that are more "tightly" filled, without discarding bins
    that might be slightly larger but still offer a good fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1. Bins that can fit are scored based on
        the *inverse* of the remaining capacity after packing, favoring those
        that leave less space.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* packing
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if fitting_bins_indices.size > 0:
        fitting_bins_capacities = bins_remain_cap[fitting_bins_indices]
        resulting_remain_cap = fitting_bins_capacities - item

        # Prioritize bins with minimal *positive* residual capacity.
        # A simple inverse: 1 / (resulting_remain_cap + epsilon)
        # This gives higher scores to smaller remaining capacities.
        # Adding a term related to the original capacity could also be considered,
        # but for minimal positive residual capacity, the inverse is a good start.
        # To ensure larger scores are better, we use the inverse.
        # We can also add a small constant or scale it to make scores more spread out
        # if needed, but the core idea is inverse of remaining space.

        epsilon = 1e-9  # Small value to avoid division by zero
        # A higher score means a better fit (smaller remaining capacity)
        # This directly favors bins that are more tightly packed.
        priorities[fitting_bins_indices] = 1.0 / (resulting_remain_cap + epsilon)

    return priorities
```
