```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) strategy.

    The strategy prioritizes bins that are "closer" to fitting the item.
    Specifically, it calculates the "distance" as the remaining capacity minus the item size.
    A smaller positive distance indicates a better fit.
    To make it a priority score (higher is better), we use the inverse of (distance + a small epsilon to avoid division by zero)
    if the item fits, otherwise the priority is 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    # Find bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "distance" to fit for bins where the item can fit
    # Distance is defined as remaining capacity - item size
    distances = bins_remain_cap[can_fit_mask] - item

    # Use a small epsilon to avoid division by zero and handle perfect fits gracefully
    epsilon = 1e-6
    
    # Calculate inverse distance. Smaller distances (better fits) get higher priority.
    # We invert the distance + epsilon to ensure higher values for better fits.
    # Adding epsilon ensures we don't divide by zero for a perfect fit (remaining_cap == item).
    priorities[can_fit_mask] = 1.0 / (distances + epsilon)

    return priorities
```
