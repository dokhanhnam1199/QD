```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    This heuristic prioritizes bins that can accommodate the item and have the
    least remaining capacity *after* the item is placed. This aims to fill
    bins more tightly.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can actually fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit the item, assign a priority.
    # We want to prioritize bins that, after placing the item,
    # will have the *least* remaining capacity. This is equivalent to
    # prioritizing bins with the smallest current remaining capacity that can fit the item.
    #
    # The priority score will be the negative of the remaining capacity
    # if the item fits. This way, a smaller remaining capacity (more negative)
    # leads to a higher (less negative) priority score.
    #
    # For bins that cannot fit the item, their priority remains 0,
    # effectively making them unselectable.
    
    priorities[can_fit_mask] = -bins_remain_cap[can_fit_mask] + item
    
    return priorities
```
