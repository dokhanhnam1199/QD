```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    The Exact Fit First strategy prioritizes bins that can accommodate the item exactly.
    If multiple bins can fit the item exactly, the one with the least remaining capacity
    after placing the item is chosen (which is the same for all exact fits).
    If no bin can fit the item exactly, then it prioritizes bins that can fit the item,
    ranking them by how little space is left after fitting.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins that can exactly fit the item
    exact_fit_mask = (bins_remain_cap == item)
    
    # If there are exact fits, give them the highest priority (e.g., a large positive value)
    # and for all other bins, give a lower priority.
    if np.any(exact_fit_mask):
        priorities[exact_fit_mask] = 1.0
        # For non-exact fits, we can assign a slightly lower priority,
        # or even 0, as we prioritize exact fits first.
        # Here, we assign 0 to non-exact fits.
        priorities[~exact_fit_mask] = 0.0 
    else:
        # If no exact fit is found, consider all bins that can fit the item.
        # Prioritize bins where the remaining capacity after placing the item is minimal.
        # This is equivalent to prioritizing bins with the smallest remaining capacity
        # that is still greater than or equal to the item size.
        can_fit_mask = (bins_remain_cap >= item)
        
        if np.any(can_fit_mask):
            # For bins that can fit, the priority is inversely related to the
            # remaining capacity after placing the item. A smaller remaining
            # capacity is better. We can use 1 / (remaining_capacity - item + epsilon)
            # to ensure a higher value for bins that fit 'tighter'.
            # We add a small epsilon to avoid division by zero if remaining_capacity == item.
            # Since we've already handled the exact fit case, remaining_capacity will be > item here.
            # So, a simpler way is to rank by the negative of the remaining capacity.
            # The smaller the remaining capacity, the larger (less negative) the priority.
            priorities[can_fit_mask] = -bins_remain_cap[can_fit_mask]
            # Bins that cannot fit get a priority of 0 (or negative infinity if we wanted to be strict).
            # Since we initialized with zeros, they remain zero, effectively giving them lowest priority.
            
        # If no bin can fit the item, all priorities remain 0, indicating no valid placement.

    return priorities
```
