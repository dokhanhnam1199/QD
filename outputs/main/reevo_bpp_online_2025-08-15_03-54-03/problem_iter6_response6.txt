```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, favoring tighter fits smoothly.

    This heuristic prioritizes bins that can accommodate the item, and among those,
    it favors bins that will have the smallest remaining capacity after packing.
    This is a variation of the "Best Fit" strategy, using a smooth, graduated
    priority based on the *remaining capacity* directly, not the gap.

    Specifically, for bins where `bins_remain_cap >= item`:
    - The priority is determined by the remaining capacity *before* packing (`bins_remain_cap`).
    - Smaller remaining capacities (tighter fits) receive higher priority.
    - Larger remaining capacities receive lower priority.
    - Bins that cannot fit the item receive a priority of 0.

    The priority score is calculated as:
    `score = exp(-scale_factor * bins_remain_cap)`
    for valid bins. The negative exponential function ensures that as the
    remaining capacity decreases (i.e., the bin is fuller), the priority score
    increases smoothly.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Scale factor to control the steepness of the exponential decay.
    # A higher value makes the priority drop off more quickly as the remaining
    # capacity increases. Tune this value based on empirical performance.
    scale_factor = 0.1  # Adjusted scale_factor for smoother decay across typical remaining capacities

    # Identify bins that have enough remaining capacity to fit the item.
    can_fit_mask = bins_remain_cap >= item

    # Assign priorities using a negative exponential function on the remaining capacity.
    # This provides a smooth, graduated priority:
    # - As remaining capacity approaches 0 (bin is nearly full), exp(-scale_factor * 0) = 1 (highest priority).
    # - As remaining capacity increases (bin is emptier), exp(-scale_factor * large_value) approaches 0 (low priority).
    # This directly prioritizes bins that have less space available, encouraging tighter packing.
    priorities[can_fit_mask] = np.exp(-scale_factor * bins_remain_cap[can_fit_mask])

    return priorities
```
