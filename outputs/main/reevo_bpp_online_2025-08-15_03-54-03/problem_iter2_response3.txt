```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a sigmoid-based Best Fit score.

    This heuristic prioritizes bins that have the smallest remaining capacity while still being able to accommodate the item.
    This is the "Best Fit" strategy. The sigmoid function is used to translate this preference into a smooth priority score.

    Specifically, for bins where `bins_remain_cap >= item`:
    - Bins with `bins_remain_cap` closest to `item` (i.e., smallest positive gap) receive the highest scores.
    - Bins with `bins_remain_cap` much larger than `item` receive lower scores.
    - Bins where `bins_remain_cap < item` receive a score of 0, as they cannot fit the item.

    The priority score is calculated as:
    `score = sigmoid(scale_factor * (item / (bins_remain_cap + epsilon)))`
    for valid bins. A higher `item / bins_remain_cap` ratio implies a tighter fit (smaller remaining capacity relative to the item size).
    The sigmoid function then maps these ratios to a priority score between 0 and 1.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Define a small epsilon to avoid division by zero and to handle perfect fits gracefully.
    epsilon = 1e-6
    
    # Scale factor to control the steepness of the sigmoid.
    # A higher value makes the priority more sensitive to small differences in remaining capacity.
    # Tune this value based on empirical performance.
    scale_factor = 3.0 

    # Identify bins that have enough remaining capacity to fit the item.
    valid_indices = np.where(bins_remain_cap >= item)[0]

    if len(valid_indices) > 0:
        valid_capacities = bins_remain_cap[valid_indices]

        # Calculate a "fit metric": the ratio of item size to remaining capacity.
        # A higher ratio indicates a tighter fit (smaller remaining capacity relative to the item).
        # This metric is a proxy for how "good" a bin is according to the Best Fit strategy.
        fit_metric = item / (valid_capacities + epsilon)

        # Apply the sigmoid function to the scaled fit metric.
        # sigmoid(x) = 1 / (1 + exp(-x))
        # - If fit_metric is high (tight fit), scale_factor * fit_metric is large.
        #   exp(-(large positive)) is close to 0, so sigmoid is close to 1.
        # - If fit_metric is low (loose fit), scale_factor * fit_metric is smaller.
        #   exp(-(smaller positive)) is larger, so sigmoid is closer to 0.5.
        # This assigns higher priority to bins with tighter fits.
        priorities[valid_indices] = 1.0 / (1.0 + np.exp(-(scale_factor * fit_metric)))

    return priorities
```
