```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, using Best Fit strategy.

    The Best Fit strategy prioritizes bins that can accommodate the item and
    leave the *least* amount of remaining capacity. This means we are looking
    for bins where `bins_remain_cap - item` is minimized (but non-negative).
    This function implements Best Fit by assigning a higher priority to bins
    that result in a smaller non-negative residual.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a priority of negative infinity.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)  # Initialize with a very low priority

    # Calculate the remaining capacity if the item is placed in each bin
    potential_remaining_cap = bins_remain_cap - item

    # Identify bins that can accommodate the item (remaining capacity is non-negative)
    can_fit_mask = potential_remaining_cap >= 0

    # For bins that can fit the item, assign a priority score.
    # The Best Fit strategy prioritizes bins with the smallest non-negative residual.
    # To achieve this with a "higher is better" priority, we want to assign
    # higher scores to smaller residuals. A simple linear mapping is to
    # use the negative of the residual.
    # E.g., if residuals are [0.1, 0.5, 1.0], the priorities will be [-0.1, -0.5, -1.0].
    # Since -0.1 > -0.5 > -1.0, this correctly prioritizes the bin with the smallest residual.
    if np.any(can_fit_mask):
        priorities[can_fit_mask] = -potential_remaining_cap[can_fit_mask]

    return priorities
```
