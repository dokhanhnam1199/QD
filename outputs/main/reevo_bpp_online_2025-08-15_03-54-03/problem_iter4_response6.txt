```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy
    that prioritizes bins with minimal remaining capacity after packing (tighter fit).

    This version uses an inverse relationship with the resulting remaining capacity
    to strongly favor bins that will be almost full after packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1. Bins that can fit the item are scored
        based on the *resulting* remaining capacity after packing, favoring
        those that leave minimal remaining capacity.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* packing
    if np.any(can_fit_mask):
        resulting_remain_cap = bins_remain_cap[can_fit_mask] - item

        # Prioritize bins with the *least* resulting remaining capacity.
        # Using `1 / (resulting_remain_cap + epsilon)` creates an inverse relationship,
        # giving much higher scores to bins with smaller remaining capacities.
        # An epsilon is added to avoid division by zero if remaining capacity is exactly 0.
        # This also ensures that scores are positive, thus clearly higher than -1.
        epsilon = 1e-9
        priorities[can_fit_mask] = 1.0 / (resulting_remain_cap + epsilon)

    return priorities
```
