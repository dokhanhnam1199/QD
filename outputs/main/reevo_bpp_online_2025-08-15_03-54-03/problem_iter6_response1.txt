```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid approach.

    This heuristic combines aspects of Best Fit and First Fit. It prioritizes
    bins that can fit the item, favoring those with less remaining capacity (First Fit
    tendency) but also considering how tightly the item fits (Best Fit tendency).
    Specifically, it assigns a priority score that is higher for bins with less
    remaining capacity that can still accommodate the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority indicates a more suitable bin. Bins that cannot fit
        the item are assigned a priority of -1.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign a priority.
    # We want to prioritize bins that are "fuller" among those that can fit.
    # This means prioritizing bins with smaller remaining capacity.
    # A simple way to achieve this is to use a large value minus the remaining capacity.
    # This way, smaller remaining capacities (closer to fitting the item) get higher scores.
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]

    if fitting_bins_capacities.size > 0:
        # To prioritize smaller remaining capacities, we can invert the remaining capacities
        # or subtract them from a large number. Subtracting from a large number ensures
        # that smaller remaining capacities result in larger priority scores.
        # The maximum possible remaining capacity before fitting the item could be the
        # maximum original capacity. A safe upper bound for the priority can be
        # set by using a value larger than any possible remaining capacity after fitting.
        # Let's use a value that is guaranteed to be larger than any remaining capacity.
        # A simple approach is to use a large constant, or a value derived from the bins.
        # For simplicity and to ensure a clear hierarchy for fitting bins,
        # we use a large value minus the remaining capacity.
        large_constant = np.max(bins_remain_cap) + item + 1 # A value larger than any capacity
        priorities[can_fit_mask] = large_constant - fitting_bins_capacities

    return priorities
```
