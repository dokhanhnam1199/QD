```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid approach:
    Exact Fit First, then Best Fit, and finally First Fit for remaining capacity.

    This strategy aims to find the most suitable bin for the item.
    1. Exact Fit: Prioritize bins where the item fits exactly (remaining capacity == item size).
    2. Best Fit: If no exact fit, prioritize bins that can accommodate the item and minimize the remaining capacity after placement.
    3. First Fit (implicit): If multiple bins offer the same "best fit" or no exact fit exists, it will implicitly select the first one encountered due to how numpy indexing works if no further tie-breaking is applied. However, to make it more deterministic and to favor bins that have *some* remaining capacity but still fit, we'll assign a score based on the *amount* of remaining capacity that is *still greater than the item*.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item fits exactly
    exact_fit_indices = np.where(bins_remain_cap == item)[0]

    if len(exact_fit_indices) > 0:
        # Assign a very high priority to exact fits.
        # We can add the index in descending order to prefer earlier bins if multiple exact fits exist,
        # though for exact fits, it doesn't practically matter which exact fit is chosen first.
        # Using a large base value to clearly distinguish from other strategies.
        priorities[exact_fit_indices] = 1e6 + (len(bins_remain_cap) - 1 - exact_fit_indices)
    else:
        # Identify bins where the item can fit (remaining capacity >= item size)
        can_fit_mask = bins_remain_cap >= item
        can_fit_indices = np.where(can_fit_mask)[0]

        if len(can_fit_indices) > 0:
            # For bins that can fit, calculate the "waste" or remaining capacity after placement.
            # We want to minimize this waste (i.e., find the best fit).
            # The score should be higher for bins with less waste.
            # So, we can use a large value minus the waste.
            residual_capacities = bins_remain_cap[can_fit_mask] - item

            # Assign priorities: Higher score for smaller residual capacity.
            # Using a large base value to distinguish from exact fits.
            # The score is inversely proportional to residual_capacity, plus a term
            # to break ties (e.g., prefer bins with more total capacity if residual is the same, or just index).
            # A simple way is to use a large number minus the residual capacity.
            # Add a small epsilon to residual_capacities before inverse to avoid division by zero if not already handled,
            # but here we are doing subtraction.
            
            # The priority should be higher for smaller residuals.
            # Score = BaseValue - ResidualCapacity
            # This naturally prioritizes bins that leave less empty space.
            priorities[can_fit_indices] = 1e5 - residual_capacities

        # If no bins can fit, priorities remain 0, which is correct.

    return priorities
```
