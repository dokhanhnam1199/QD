{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a refined strategy.\n\n    This strategy prioritizes bins that can accommodate the item and then\n    selects bins with the *tightest fit* (smallest remaining capacity) but\n    also considers the *relative fullness* of the bin. Bins that cannot fit\n    the item are given a score of -1.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, assign a priority score.\n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n    \n    if fitting_bins_capacities.size > 0:\n        # Strategy: Prioritize bins with the tightest fit (smallest remaining capacity).\n        # To achieve this, we can use a score that is inversely related to the\n        # remaining capacity. A simple approach is to subtract the remaining\n        # capacity from a large constant or from the maximum possible remaining\n        # capacity to ensure smaller remaining capacities get higher scores.\n        # We also want to be sensitive to the *relative fullness*.\n        # A good heuristic might be to penalize bins that are *almost full*\n        # or *almost empty* relative to their capacity if they can fit the item.\n        # For this version, let's focus on the tightest fit with a positive residual.\n\n        # Calculate a score that favors smaller remaining capacities.\n        # A larger value means a tighter fit.\n        # We subtract remaining_capacity from a large enough number.\n        # A value like np.max(bins_remain_cap) + item ensures all fitting bins get a positive score.\n        # However, to make it more nuanced, we can consider the difference from the item size.\n        # A bin with remaining capacity R for an item I has a \"gap\" of R - I. We want to minimize this gap.\n        # So, we can use a score proportional to -(R - I), or equivalently, (I - R).\n        # However, a higher score is better. So, we want larger values for smaller R.\n        # Let's use a scaled inverse.\n        # Consider the \"waste\" if we put the item in: bins_remain_cap - item. We want to minimize waste.\n        # So, a higher priority should correspond to smaller waste.\n        # We can map waste `w` to a priority `p`.\n        # A simple mapping is `p = C - w`, where C is a large constant.\n        # Let's use a value that ensures all fitting bins have a priority higher than -1.\n        # The maximum possible remaining capacity can be around the bin capacity itself\n        # if we consider a newly opened bin. So, let's use a value derived from the item size and capacities.\n        \n        # Prioritize bins with less remaining capacity.\n        # We can achieve this by assigning a score that decreases as remaining capacity increases.\n        # A common approach is to use `1 / (remaining_capacity - item + epsilon)` or\n        # `(max_capacity_of_any_bin_ever_seen) - remaining_capacity`.\n        \n        # Let's try a score that is the negative of the remaining capacity plus a large offset.\n        # This prioritizes smaller remaining capacities.\n        # Adding the item size can also help differentiate bins for the same item.\n        # A score based on `remaining_capacity - item` would represent the 'slack' or 'waste'.\n        # We want to minimize slack, so a higher priority for smaller slack.\n        # Let's use a score proportional to the negative slack, scaled.\n        \n        # Positive residual strategy:\n        # For a bin with remaining capacity `r` and an item of size `i`:\n        # The \"fit difference\" is `r - i`. We want to minimize this non-negative difference.\n        # A score that is `- (r - i)` (i.e., `i - r`) would mean smaller `r` gives a larger score.\n        # However, we need to handle cases where `r - i` is small.\n        # A simple inverse of the remaining capacity can work, but might be too sensitive.\n        \n        # Let's try a simple approach: prioritize smaller remaining capacities.\n        # `max_capacity_for_scaling` should be larger than any `bins_remain_cap` value.\n        # A safe bet is the maximum possible capacity of a bin, or a reasonable upper bound.\n        # If we don't know the initial bin capacity, we can use `np.max(bins_remain_cap)`\n        # or a generous constant. Let's assume `bins_remain_cap` can be large.\n        # We want a higher score for smaller `fitting_bins_capacities`.\n        # The expression `max_val - x` results in higher scores for smaller `x`.\n        # Let's use a `max_val` that is sufficiently large.\n        # A value derived from the current `bins_remain_cap` can adapt.\n        \n        # Option 1: Inverse of remaining capacity (can be unstable if capacities are close to 0)\n        # `priorities[can_fit_mask] = 1.0 / (fitting_bins_capacities + 1e-6)` # add epsilon for stability\n        \n        # Option 2: Scaled difference to emphasize tight fits more.\n        # We want to prioritize bins with `r` such that `r` is small and `r >= item`.\n        # This means `r - item` (waste) is small.\n        # A good priority could be `- (r - item)`, so smaller waste gets higher priority.\n        # To make scores positive and distinct, we can add an offset.\n        # Let's try `offset - (r - item)`. A larger offset gives higher scores.\n        # The offset could be related to the maximum possible remaining capacity or item size.\n        \n        # Let's consider the \"goodness of fit\": `bins_remain_cap - item`. We want to minimize this.\n        # A higher priority should be assigned to a smaller `bins_remain_cap - item`.\n        # We can achieve this by using a score like `max_possible_slack - (bins_remain_cap - item)`.\n        # The `max_possible_slack` should be larger than any `bins_remain_cap - item`.\n        # A simple way is to use `bins_remain_cap` itself, but this is not ideal as\n        # it mixes capacity and slack.\n\n        # A robust strategy for prioritizing tighter fits is to use a large number minus\n        # the remaining capacity. This ensures that smaller remaining capacities get higher scores.\n        # Let's make the priority directly related to the \"closeness\" to the item size.\n        # The value `bins_remain_cap - item` is the slack. We want to minimize slack.\n        # A score of `C - slack` would work.\n        # Let's use `bins_remain_cap` as a basis, as it implicitly orders bins.\n        # By subtracting `bins_remain_cap` from a large constant, we reverse the order.\n        \n        # Let's use a score that is the negative of remaining capacity.\n        # This makes smaller remaining capacities have less negative (higher) scores.\n        # We can also add the item size to differentiate bins when remaining capacities are similar.\n        # `bins_remain_cap[can_fit_mask] - item` would be the slack.\n        # We want to prioritize smaller slack.\n        # A good priority could be `(max_val - item) - bins_remain_cap`.\n        # Or simply, higher priority for smaller `bins_remain_cap`.\n\n        # Let's use a score that prioritizes bins with less remaining capacity.\n        # A simple way is to use a large constant minus the remaining capacity.\n        # This ensures smaller remaining capacities get higher scores.\n        # The constant should be larger than any possible remaining capacity.\n        # `np.max(bins_remain_cap)` is a reasonable choice if we assume bins start from some capacity.\n        # To ensure scores are always positive and distinct, we can add a small epsilon.\n        \n        # Refined approach: prioritize bins with the smallest `bins_remain_cap` that fit.\n        # This is essentially First Fit. The priority should reflect this.\n        # The value `bins_remain_cap` itself can be used if we want to prioritize smaller values.\n        # However, higher score means higher priority.\n        # So, we want `bins_remain_cap` to be small.\n        # We can use `-(bins_remain_cap)` and add a large constant.\n        # Or, `max_capacity_value - bins_remain_cap`.\n\n        # Let's consider the difference from the item size, `bins_remain_cap - item`.\n        # We want to minimize this difference.\n        # A score `(bins_remain_cap - item)` would favor larger remaining capacities, which is wrong.\n        # A score `-(bins_remain_cap - item)` or `item - bins_remain_cap` would favor smaller remaining capacities.\n        # To make scores positive and ordered: `max_slack - (bins_remain_cap - item)`.\n        # The maximum possible slack could be related to the bin's initial capacity.\n        \n        # Let's simplify: a higher priority for a bin means it's a \"better\" fit.\n        # \"Better\" here means smaller remaining capacity.\n        # We can assign a score that is inversely proportional to the remaining capacity.\n        # To avoid division by zero and instability, we can use `C - bins_remain_cap`.\n        # Let C be a value larger than any remaining capacity.\n        # `np.max(bins_remain_cap)` is a good candidate if we assume bins start with some capacity.\n        # If we don't have an upper bound, we can use a sufficiently large number.\n\n        # For a tighter fit, we want `bins_remain_cap` to be close to `item`.\n        # This means `bins_remain_cap - item` should be small and non-negative.\n        # A priority could be `-(bins_remain_cap - item)`.\n        # To make these positive and distinct:\n        # `max_waste - (bins_remain_cap - item)`\n        # `max_waste` can be `np.max(bins_remain_cap) - item`.\n        # Let's set a scaling factor to control the sensitivity.\n        \n        # Simple inverse of remaining capacity, scaled and offset for positive values.\n        # Prioritize smaller `bins_remain_cap`.\n        # Let's consider `bins_remain_cap` as the primary indicator for tightness.\n        # A higher priority is given to smaller `bins_remain_cap`.\n        # We can achieve this with a score proportional to the negative of remaining capacity.\n        # `priorities[can_fit_mask] = -fitting_bins_capacities`\n        # To ensure positive and distinct scores:\n        # `priorities[can_fit_mask] = 1000.0 - fitting_bins_capacities`  (1000.0 is an arbitrary large constant)\n        # This prioritizes bins with the least remaining capacity.\n\n        # Alternative using slack: `slack = bins_remain_cap - item`. Minimize slack.\n        # Priority could be `1 / (slack + epsilon)`.\n        # Or `max_slack - slack`.\n        \n        # Let's go with a strategy that emphasizes smaller remaining capacities.\n        # We want a higher score for smaller `fitting_bins_capacities`.\n        # We can use a base value and subtract the remaining capacity.\n        # This directly implements the \"smaller remaining capacity is better\" logic.\n        # The base value should be large enough to ensure positive and distinct scores.\n        \n        # Using the inverse of the remaining capacity can be sensitive to small values.\n        # Using a large constant minus the remaining capacity is more stable.\n        # Let's use a score that is simply the negative of the remaining capacity.\n        # Smaller remaining capacity means a less negative score, which is higher priority.\n        # To ensure these are generally higher than the -1 default for non-fitting bins,\n        # we can add a sufficiently large constant.\n        \n        # Final refined strategy: Prioritize bins with the smallest remaining capacity.\n        # This is the core of First Fit.\n        # The priority score should reflect this: higher score for smaller remaining capacity.\n        # A simple and effective way is to use `C - remaining_capacity`.\n        # `C` should be a value greater than any possible `remaining_capacity`.\n        # `np.max(bins_remain_cap)` could be a baseline, but if a new bin is opened,\n        # its remaining capacity is the full bin capacity.\n        # Let's use a scaled inverse approach where we emphasize the tightness.\n        # Consider `(bins_remain_cap - item)` as slack. We want to minimize slack.\n        # A score of `1 / (bins_remain_cap - item + epsilon)` will rank bins by increasing slack.\n        # To get higher priority for smaller slack, we can use `1 / (slack + epsilon)` directly.\n        # Or, `max_slack - slack`.\n        \n        # Let's try a scaled inverse of the remaining capacity for prioritization.\n        # This emphasizes bins that are nearly full (small remaining capacity).\n        # `priorities[can_fit_mask] = 1.0 / (fitting_bins_capacities + 1e-9)`\n        # This gives higher scores to bins with smaller remaining capacities.\n        \n        # Let's consider the \"fit quality\" as `bins_remain_cap - item`.\n        # We want to minimize this.\n        # A score proportional to `-(bins_remain_cap - item)` is desired.\n        # To make these positive and distinguishable, we can use:\n        # `scaling_factor * (max_possible_remaining_capacity - (bins_remain_cap - item))`\n        # Where `max_possible_remaining_capacity` is the largest possible value `bins_remain_cap` can take.\n        \n        # A simpler approach that favors tighter fits:\n        # Assign a score inversely proportional to the remaining capacity.\n        # `priorities[can_fit_mask] = 1.0 / (fitting_bins_capacities + 1e-9)`\n        \n        # Let's try a slightly more nuanced approach, considering the *difference*\n        # from the item size. We want to minimize `bins_remain_cap - item`.\n        # A higher priority for smaller `bins_remain_cap - item`.\n        # So, a score that is `-(bins_remain_cap - item)` would work.\n        # To ensure positive and distinct scores, we can add a large constant.\n        # `priorities[can_fit_mask] = (np.max(fitting_bins_capacities) - fitting_bins_capacities) + item`\n        # This prioritizes bins where `fitting_bins_capacities` is smallest.\n\n        # Let's use a score that is simply the negative of the remaining capacity.\n        # This ensures smaller remaining capacities have less negative, thus higher scores.\n        # `priorities[can_fit_mask] = -fitting_bins_capacities`\n        # To make these scores positive and generally higher than -1, we can add a large offset.\n        # For example, an offset of `max(bins_remain_cap)` plus a margin.\n        # A simple approach: `max_val - fitting_bins_capacities`.\n        \n        # Let's define `max_val` to be larger than any current remaining capacity.\n        # This ensures higher scores for bins with less remaining capacity.\n        # We can pick a value that ensures positive and distinct scores.\n        # Using the maximum possible remaining capacity is a good strategy.\n        # If we don't know the initial bin capacity, we can use a large number.\n        \n        # A good heuristic is to prioritize bins with the smallest remaining capacity.\n        # This means a higher priority for bins where `bins_remain_cap` is smaller.\n        # We can use `max_possible_capacity - bins_remain_cap` to achieve this ordering.\n        # Let `max_possible_capacity` be a value larger than any expected `bins_remain_cap`.\n        # A simple choice is `np.max(bins_remain_cap) + item` or a fixed large number.\n        \n        # Let's use a score that is `1 / (bins_remain_cap - item + epsilon)`\n        # This emphasizes bins where the remaining capacity is just enough.\n        # smaller `bins_remain_cap - item` gives higher score.\n        priorities[can_fit_mask] = 1.0 / (fitting_bins_capacities - item + 1e-9)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin, favoring tighter fits smoothly.\n\n    This heuristic prioritizes bins that can accommodate the item, and among those,\n    it favors bins that will have the smallest remaining capacity after packing.\n    This is a variation of the \"Best Fit\" strategy, but uses a smooth, graduated\n    priority based on the *gap* between the bin's remaining capacity and the item size.\n\n    Specifically, for bins where `bins_remain_cap >= item`:\n    - The priority is determined by the remaining capacity *after* packing (`bins_remain_cap - item`).\n    - Smaller positive gaps (tighter fits) receive higher priority.\n    - Larger gaps receive lower priority.\n    - Bins that cannot fit the item receive a priority of 0.\n\n    The priority score is calculated as:\n    `score = exp(-scale_factor * (bins_remain_cap - item))`\n    for valid bins. The negative exponential function ensures that as the\n    remaining capacity after packing decreases (i.e., the fit gets tighter),\n    the priority score increases smoothly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a small epsilon to avoid issues with near-zero gaps and ensure positive values for exp.\n    epsilon = 1e-9\n    \n    # Scale factor to control the steepness of the exponential decay.\n    # A higher value makes the priority drop off more quickly as the gap increases.\n    # Tune this value based on empirical performance.\n    scale_factor = 1.0\n\n    # Identify bins that have enough remaining capacity to fit the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the residual capacity after packing for bins that can fit the item.\n    fitting_bins_residual_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities using a negative exponential function on the residual capacity.\n    # This provides a smooth, graduated priority:\n    # - As residual capacity approaches 0 (tight fit), exp(-scale_factor * 0) = 1 (highest priority).\n    # - As residual capacity increases (loose fit), exp(-scale_factor * large_value) approaches 0 (low priority).\n    # We add epsilon to the residual capacity before exponentiation to avoid exp(0) precisely,\n    # and to ensure that bins with exactly zero residual capacity (perfect fits) get a score of 1.\n    # However, simply using the residual capacity directly is more aligned with the goal.\n    # The exponential function itself handles the smooth decay.\n    priorities[can_fit_mask] = np.exp(-scale_factor * fitting_bins_residual_cap)\n\n    return priorities\n\n[Reflection]\nPrioritize smaller remaining capacities; use smooth, decreasing functions for better fit.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}