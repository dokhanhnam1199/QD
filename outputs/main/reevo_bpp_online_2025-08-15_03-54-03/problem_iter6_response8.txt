```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority using a strategy that balances First Fit with tighter packing.

    This heuristic prioritizes bins where the remaining capacity after placing the item
    is non-negative. Among bins that can fit the item, it favors those that result in
    a smaller residual (tighter fit), but also considers the order of bins as in
    First Fit by adding a small penalty to later bins. This aims to fill bins more
    tightly while still adhering to a sequential-like preference.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins where the item can fit (residual >= 0).
    residuals = bins_remain_cap - item
    can_fit_mask = residuals >= 0

    # For bins that can fit the item, calculate priorities.
    # We want to favor tighter fits (smaller residuals).
    # To incorporate a First Fit-like preference, we can add a small
    # penalty based on the bin's index. This ensures that if two bins
    # have the same residual, the one appearing earlier in the array
    # (lower index) gets a slightly higher priority.

    if np.any(can_fit_mask):
        fitting_residuals = residuals[can_fit_mask]
        # Calculate a score that prioritizes smaller residuals.
        # A simple way is to use a large constant minus the residual.
        # This makes smaller residuals result in larger scores.
        # We add a small value based on the index to break ties and favor earlier bins.
        # The index is normalized by adding 1 to avoid multiplying by zero for the first bin.
        # The `1.0 / (index + 1)` creates a decreasing penalty for later bins.
        # We invert this to add a smaller penalty for earlier bins.
        indices = np.where(can_fit_mask)[0]
        # Using a large base value to ensure these priorities are significantly higher than -1.
        # Maximize the score for minimum residual, and use index as a tie-breaker favoring smaller indices.
        # Score = (MaxPossibleResidual - residual) + (1.0 / (index + 1))
        # Or to make it simpler and directly favor smaller residuals:
        # Score = -(residual) + (1.0 / (index + 1))
        # To make the higher score truly mean better priority for tighter fit,
        # we can invert the residual and add a term for index.
        # Let's create a score that is high for small residuals.
        # Max residual + 1 - residual.
        # The index priority can be represented by a small fraction, where earlier indices are larger fractions.
        # e.g., N - residual + (N_bins - index) / N_bins.
        # Let's try: (a large number - residual) + (a small number * (N_bins - index))
        
        # Let's simplify the logic: prioritize smaller residuals.
        # For tie-breaking or adding a sequential preference, we can ensure that
        # when residuals are similar, earlier bins get a slight edge.
        # Score = -residual + (small_factor * (number_of_bins - index))
        # Or, to keep it straightforward: smaller residual is better.
        # We can use `1.0 / (residual + epsilon)` from v0, but add an index factor.
        # A smaller index should get a higher score if residuals are equal.
        
        # Strategy: maximize (1 / (residual + epsilon)) and add a bonus for lower index.
        epsilon = 1e-9
        base_priorities = 1.0 / (fitting_residuals + epsilon)
        
        # Add a bonus for earlier bins. A simple way is to add `(num_bins - index)`.
        # This adds a larger bonus to bins with smaller indices.
        num_bins = len(bins_remain_cap)
        index_bonus = (num_bins - indices) * 1e-6 # Small bonus, to not overpower residual preference
        
        priorities[can_fit_mask] = base_priorities + index_bonus
        
    return priorities
```
