{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin, favoring tighter fits.\n\n    This strategy prioritizes bins that can accommodate the item and, among those,\n    favors bins that will have the smallest remaining capacity after packing.\n    This encourages \"tighter\" fits, potentially leading to better packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the\n        item are given a score of -1. Bins that can fit the item are scored\n        inversely proportional to their remaining capacity after packing,\n        strongly favoring minimal remainders.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)\n    epsilon = 1e-9  # A small value to prevent division by zero and ensure positive priorities for fitting bins\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the residual capacity after packing\n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n    if fitting_bins_capacities.size > 0:\n        # Calculate the residual capacity for each fitting bin\n        residuals = fitting_bins_capacities - item\n\n        # Assign priorities inversely proportional to the residual capacity.\n        # Smaller residuals get higher scores.\n        # Add epsilon to avoid division by zero and ensure non-negative scores.\n        priorities[can_fit_mask] = 1.0 / (residuals + epsilon)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a sigmoid-based Best Fit score.\n\n    This heuristic prioritizes bins that have the smallest remaining capacity while still being able to accommodate the item.\n    This is the \"Best Fit\" strategy. The sigmoid function is used to translate this preference into a smooth priority score.\n\n    Specifically, for bins where `bins_remain_cap >= item`:\n    - Bins with `bins_remain_cap` closest to `item` (i.e., smallest positive gap) receive the highest scores.\n    - Bins with `bins_remain_cap` much larger than `item` receive lower scores.\n    - Bins where `bins_remain_cap < item` receive a score of 0, as they cannot fit the item.\n\n    The priority score is calculated as:\n    `score = sigmoid(scale_factor * (item / (bins_remain_cap + epsilon)))`\n    for valid bins. A higher `item / bins_remain_cap` ratio implies a tighter fit (smaller remaining capacity relative to the item size).\n    The sigmoid function then maps these ratios to a priority score between 0 and 1.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a small epsilon to avoid division by zero and to handle perfect fits gracefully.\n    epsilon = 1e-6\n    \n    # Scale factor to control the steepness of the sigmoid.\n    # A higher value makes the priority more sensitive to small differences in remaining capacity.\n    # Tune this value based on empirical performance.\n    scale_factor = 3.0 \n\n    # Identify bins that have enough remaining capacity to fit the item.\n    valid_indices = np.where(bins_remain_cap >= item)[0]\n\n    if len(valid_indices) > 0:\n        valid_capacities = bins_remain_cap[valid_indices]\n\n        # Calculate a \"fit metric\": the ratio of item size to remaining capacity.\n        # A higher ratio indicates a tighter fit (smaller remaining capacity relative to the item).\n        # This metric is a proxy for how \"good\" a bin is according to the Best Fit strategy.\n        fit_metric = item / (valid_capacities + epsilon)\n\n        # Apply the sigmoid function to the scaled fit metric.\n        # sigmoid(x) = 1 / (1 + exp(-x))\n        # - If fit_metric is high (tight fit), scale_factor * fit_metric is large.\n        #   exp(-(large positive)) is close to 0, so sigmoid is close to 1.\n        # - If fit_metric is low (loose fit), scale_factor * fit_metric is smaller.\n        #   exp(-(smaller positive)) is larger, so sigmoid is closer to 0.5.\n        # This assigns higher priority to bins with tighter fits.\n        priorities[valid_indices] = 1.0 / (1.0 + np.exp(-(scale_factor * fit_metric)))\n\n    return priorities\n\n[Reflection]\nFocus on smooth, graduated priorities, not just inverse proportionality.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}