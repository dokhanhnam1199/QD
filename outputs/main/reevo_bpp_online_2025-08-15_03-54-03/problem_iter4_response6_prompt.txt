{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a strategy\n    that prioritizes bins with minimal remaining capacity after packing (tighter fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the\n        item are given a score of -1. Bins that can fit the item are scored\n        based on their remaining capacity after packing, favoring those that\n        leave minimal remaining capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity *after* packing the item\n    remaining_after_packing = bins_remain_cap[can_fit_mask] - item\n\n    # We want to prioritize bins where remaining_after_packing is minimal (tighter fit).\n    # A simple way to achieve this is to sort by remaining_after_packing in ascending order.\n    # The priority score should be higher for smaller remaining capacities.\n    # We can achieve this by taking the negative of the remaining capacity\n    # and potentially shifting it to ensure it's higher than the default -1.\n    if remaining_after_packing.size > 0:\n        # Prioritize by minimal remaining capacity after packing.\n        # A larger score for smaller remaining capacity.\n        # Using the negative of remaining capacity: smaller remaining_after_packing -> less negative score.\n        # Adding a large constant to ensure positive scores and distinguish from non-fitting bins.\n        # The constant should be larger than any possible negative score.\n        # A safe bet is to use a value that's larger than the maximum possible\n        # negative remaining capacity, which is related to the bin size.\n        # Let's use a simple approach: a large multiplier for inverse proportion.\n        # Or even simpler, just the negative of the remaining capacity,\n        # and ensure it's greater than -1 by adding a sufficiently large value.\n        # Example: if remaining is 0.1, score is -0.1. If remaining is 0.01, score is -0.01. -0.01 > -0.1.\n        # To make it clearly higher than -1, we can add a large value.\n        # The maximum possible remaining capacity would be if we pack an item into a full bin.\n        # So, remaining_after_packing will be between 0 and (max_bin_cap - min_item_size).\n        # The most negative value it can take is when the bin is almost full and the item is small,\n        # leaving a large remainder. The most positive value is when the bin is just big enough.\n        # We want to prioritize bins with remainder close to 0.\n        # So, we can use `1 / (remaining_after_packing + epsilon)` or `max_val - remaining_after_packing`.\n        # Let's use the latter for simplicity and better control of scale.\n        # A large value for `max_val` ensures higher scores for smaller remainders.\n        # A safe `max_val` could be slightly larger than any possible remaining capacity.\n        # If bins have capacity up to `C`, and items are at least `m`, max remaining is `C-m`.\n        # Let's pick a value that's guaranteed to be larger than any potential remaining capacity.\n        # A value like `1000` or `np.max(bins_remain_cap) + 1` should be sufficient if capacities are not excessively large.\n        # Or, we can simply use the negative of the remaining capacity and add 1 to make it positive if needed.\n        # A simpler approach that maintains relative order and ensures higher priority for smaller remainders:\n        # Prioritize by `-(remaining_after_packing)`. For remaining=0.1, score=-0.1. For remaining=0.01, score=-0.01.\n        # We need these scores to be greater than -1.\n        # So, let's use `-(remaining_after_packing) + offset`. The offset needs to be large enough.\n        # A simple monotonic transformation: `1.0 / (remaining_after_packing + 1e-9)` would also work,\n        # prioritizing smaller positive values.\n        # Let's go with `max_possible_remaining - remaining_after_packing` for clarity.\n        # Max possible remaining capacity is max_initial_capacity - min_item_size.\n        # A simple approach is to take the negative of the remaining capacity.\n        # Bins with smaller remaining capacity will have scores closer to zero (less negative).\n        # We want these scores to be greater than -1.\n        # So, we can add a constant that ensures this.\n        # A simple proportional inverse relationship: a large constant minus the remaining capacity.\n        # This prioritizes smaller remaining capacities with higher scores.\n        # Let's use `max_initial_capacity - item` as a reference for a maximally \"bad\" fit.\n        # This logic seems to align with First Fit Decreasing's intuition of filling up bins efficiently.\n        # The goal is to have `remaining_after_packing` be as close to 0 as possible.\n        # So, `max_val - remaining_after_packing` prioritizes smaller `remaining_after_packing`.\n        # We can set `max_val` to a value larger than any possible `remaining_after_packing`.\n        # Example: if bins_remain_cap are [10, 5, 8] and item is 3.\n        # Fits: [10, 5, 8]. Remaining after packing: [7, 2, 5].\n        # We want to prioritize the bin with remaining capacity 2.\n        # Scores: Bin1: 10-3=7. Bin2: 5-3=2. Bin3: 8-3=5.\n        # The bin with remaining capacity 2 gets score 2. This is not higher priority.\n        # We want higher priority for smaller remaining capacity.\n        # So, the score should be inversely related to remaining capacity.\n        # Option 1: Use negative of remaining capacity.\n        # Remaining: [7, 2, 5]. Scores: [-7, -2, -5]. Highest is -2, which is correct.\n        # We need to ensure these are > -1. So add an offset.\n        # offset = 10 (or any value > 7). Scores: [3, 8, 5]. Highest is 8.\n        # Option 2: Use 1 / (remaining_capacity + epsilon)\n        # Remaining: [7, 2, 5]. Scores: [1/7, 1/2, 1/5]. Highest is 1/2, which is correct.\n        # Option 3: Use max_possible_value - remaining_capacity.\n        # max_possible_remaining could be considered the capacity of the largest bin minus the smallest item.\n        # Let's consider a large number for simplicity, like 1000, assuming bin capacities are reasonable.\n        # Remaining: [7, 2, 5]. Scores: [1000-7, 1000-2, 1000-5] = [993, 998, 995]. Highest is 998.\n        # This is equivalent to prioritizing smaller remaining capacities.\n        # The reflection mentions \"adjusting sensitivity to residual size\". This implies that the *difference*\n        # matters. The `max_val - remaining` approach reflects this directly.\n\n        # Let's use `max_val - remaining_after_packing`.\n        # A safe `max_val` could be related to the maximum bin capacity, ensuring it's larger than any possible remaining capacity.\n        # If we don't know the max capacity, a large constant is fine. Let's assume a typical range of capacities.\n        # Or, we can use the maximum *initial* remaining capacity as `max_val`.\n        # max_initial_remaining = np.max(bins_remain_cap[can_fit_mask])\n        # However, this can lead to values close to zero for the best fit.\n        # Let's stick to a fixed large offset for clear separation from -1.\n        # The negative of remaining capacity is directly proportional to how full the bin becomes.\n        # We want to maximize \"fullness\".\n        # Let's use `-remaining_after_packing`. To make it greater than -1, add a buffer.\n        # The minimum remaining capacity is 0, so the maximum negative score is 0.\n        # The maximum remaining capacity can be `max(bins_remain_cap) - min(item_sizes)`.\n        # So, the scores will range from -(max_initial_capacity) to 0.\n        # Adding a buffer ensures we are above -1.\n        # A buffer of 1 makes the range [0, max_initial_capacity - 1].\n        # This means smaller remaining capacities have higher (less negative) scores.\n        priorities[can_fit_mask] = -remaining_after_packing\n\n    # Now, ensure all fitting bins have a priority higher than non-fitting bins (-1).\n    # If any fitting bin has a score <= -1 (e.g., remaining_after_packing is very large, making -remaining_after_packing <= -1),\n    # we should adjust. However, remaining_after_packing will always be >= 0.\n    # So, -remaining_after_packing will always be <= 0.\n    # If we want strictly higher than -1, we can add a small epsilon or a constant.\n    # A simple way to prioritize smaller remaining capacities:\n    # Directly use `-remaining_after_packing`. The highest value here corresponds to the smallest `remaining_after_packing`.\n    # To ensure these are clearly higher than -1, we can add a value.\n    # Let's assign `1.0 / (remaining_after_packing + epsilon)` for a direct inverse relationship.\n    # Or, a large number minus the remaining capacity.\n    # `large_number - remaining_after_packing` -> prioritizing smaller `remaining_after_packing`.\n    # A suitable large number could be `np.max(bins_remain_cap) + 1`.\n    # Let's use a simpler form that still prioritizes smaller remainders:\n    # `1 / (remaining_after_packing + 1e-9)`\n    # This assigns a large score to small remainders and smaller scores to large remainders.\n    # And ensures these are positive, hence > -1.\n    epsilon = 1e-9\n    priorities[can_fit_mask] = 1.0 / (remaining_after_packing + epsilon)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a modified First Fit strategy.\n\n    This version aims to prioritize bins that, after packing the item,\n    will have the *least* remaining capacity. This is a common heuristic\n    for minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins that cannot fit the\n        item are given a score of -1. Bins that can fit the item are scored\n        based on the *resulting* remaining capacity after packing, favoring\n        bins with the smallest resulting capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity *after* packing\n    if np.any(can_fit_mask):\n        resulting_remain_cap = bins_remain_cap[can_fit_mask] - item\n\n        # We want to prioritize bins with the *least* resulting remaining capacity.\n        # This means a smaller `resulting_remain_cap` should have a higher priority.\n        # We can achieve this by using a transformation that maps smaller values\n        # to larger scores. A simple way is to use a large constant minus the\n        # resulting remaining capacity. This ensures that bins with very little\n        # space left after packing get the highest scores.\n        # We need a reference value that is guaranteed to be larger than any\n        # possible `resulting_remain_cap`. The maximum initial bin capacity plus\n        # the item size is a safe upper bound for the original capacity, so\n        # `max(bins_remain_cap) + item` is a safe upper bound for the original\n        # capacity, and thus `max(bins_remain_cap)` is a safe upper bound for\n        # `resulting_remain_cap`. Let's use `max(bins_remain_cap)` to scale.\n        # A more robust large number could be used, but this is generally sufficient.\n        # A very large constant ensures that these prioritized bins have scores\n        # significantly higher than the default -1.\n        large_constant = 1e9\n        priorities[can_fit_mask] = large_constant - resulting_remain_cap\n\n    return priorities\n\n[Reflection]\nPrioritize by **inverse of remaining capacity** or **scaled difference** for tighter fits.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}