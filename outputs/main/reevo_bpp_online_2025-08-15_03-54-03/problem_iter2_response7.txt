```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Sigmoid-based Best Fit strategy.

    This strategy prioritizes bins that are "almost full" by assigning higher
    priority scores to bins with a higher fill ratio (item size / remaining capacity),
    capped by the remaining capacity of the bin. A sigmoid function is used to
    smoothly transition these scores.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Mask for bins where the item can fit
    can_fit_mask = bins_remain_cap >= item

    # Calculate fill ratio for bins that can fit the item.
    # Fill ratio is item_size / bin_capacity. Since we don't have bin_capacity,
    # we use bins_remain_cap to imply how "full" the bin is relative to the item.
    # A higher fill ratio (item_size / bins_remain_cap) means bins_remain_cap is smaller relative to item_size.
    # This implies the bin is "closer" to being full with this item.
    # We want to prioritize bins where `item / bins_remain_cap` is high.

    # Handle item size of 0: A zero item can fit anywhere and doesn't fill anything.
    # We assign a neutral priority score (e.g., 0.5 via sigmoid(0)) to any bin it fits in.
    if item == 0:
        # If item is 0, it fits in all bins.
        # The fill ratio is effectively 0. Sigmoid(k*0) = 0.5.
        priorities[can_fit_mask] = 0.5
        return priorities

    # For item size > 0
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]

    # To avoid division by zero and ensure ratios are meaningful, we only consider bins with positive capacity.
    # `can_fit_mask` already ensures `bins_remain_cap >= item`.
    # If `item > 0`, then `fitting_bins_remain_cap` will be strictly positive.
    
    # Calculate fill ratio: item_size / remaining_capacity.
    # A smaller remaining_capacity (for a given item_size) means a higher fill ratio.
    # We want to prioritize bins with higher fill ratios.
    fill_ratios = item / fitting_bins_remain_cap

    # The fill_ratios are in the range (0, infinity) if item > 0 and bins_remain_cap can be anything.
    # However, our `can_fit_mask` ensures `bins_remain_cap >= item`.
    # So, `fill_ratios` are in the range (0, 1] if `bins_remain_cap >= item > 0`.
    # Specifically, if `bins_remain_cap == item`, fill_ratio = 1.
    # If `bins_remain_cap > item`, fill_ratio < 1.

    # Using sigmoid: `sigmoid(x) = 1 / (1 + exp(-x))`.
    # We want to maximize priority as `fill_ratio` approaches 1.
    # `sigmoid(k * fill_ratio)` will have higher values for higher `fill_ratio`.
    # Let `k` be a steepness parameter.
    k = 15.0 # Tuning parameter for sigmoid steepness. Adjust for desired behavior.

    # Apply sigmoid to the fill ratios.
    # Ensure input to exp is within reasonable bounds to avoid overflow.
    # Since fill_ratios are <= 1 and k is moderate, `k * fill_ratios` should be fine.
    sigmoid_input = k * fill_ratios
    
    # Calculate priorities for bins that can fit the item.
    # Scores will be in the range (0.5, ~1) because fill_ratios are >= 0.
    # Specifically, if fill_ratio is 0 (e.g., item=0, handled above) -> 0.5
    # If fill_ratio = 1 -> sigmoid(k) ~ 1.
    # If fill_ratio < 1 -> sigmoid(k * fill_ratio) < sigmoid(k).
    priorities[can_fit_mask] = 1 / (1 + np.exp(-sigmoid_input))

    return priorities
```
