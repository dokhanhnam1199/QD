```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    Exact Fit First prioritizes bins that can fit the item exactly.
    Among bins that can fit the item exactly, it prioritizes those with less remaining capacity (to minimize wasted space).
    If no exact fit is available, it will consider bins that can fit the item but might leave some remaining capacity,
    prioritizing those with the smallest remaining capacity that is still sufficient.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins where the item fits exactly
    exact_fit_indices = np.where(bins_remain_cap == item)[0]

    if len(exact_fit_indices) > 0:
        # Among exact fits, prioritize those with the least remaining capacity (which is 'item' itself in this case)
        # Since they are exact fits, their remaining capacity is already determined.
        # We can assign a high priority. Here, we'll give them a value based on their index to ensure
        # deterministic behavior if multiple exact fits exist (though it doesn't matter for exact fit logic itself).
        # A higher priority score indicates a better fit.
        priorities[exact_fit_indices] = 10000 - exact_fit_indices
    else:
        # If no exact fit, find bins that can accommodate the item
        can_fit_indices = np.where(bins_remain_cap >= item)[0]

        if len(can_fit_indices) > 0:
            # Among bins that can fit, prioritize those with the smallest remaining capacity
            # that is still sufficient for the item. This is a form of "best fit".
            # We want to maximize the priority for the bin that leaves the least
            # remaining space after adding the item.
            # So, we want to minimize (bins_remain_cap - item).
            # Assigning a priority based on this difference, but inversely (higher priority for smaller difference).
            # A common way is to use a large number minus the difference.
            relevant_bins_capacities = bins_remain_cap[can_fit_indices]
            # Calculate the difference for eligible bins
            differences = relevant_bins_capacities - item
            # Assign priorities: Higher values for smaller differences
            # We can use a large constant minus the difference to make it a "higher is better" score.
            # The constant should be large enough to separate these from non-fitting bins (which have 0 priority).
            priorities[can_fit_indices] = 1000 - differences
        else:
            # No bin can fit the item, priority remains 0 for all.
            pass # priorities is already initialized to zeros

    return priorities
```
