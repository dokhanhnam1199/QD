```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit.

    In Random Fit, we randomly select a bin among those that can accommodate the item.
    The priority function here aims to simulate this by giving a higher priority
    to bins that can fit the item, and then adding a random component to break ties
    and introduce the "randomness" aspect.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros (or handle as an error, but for priority, zeros is fine)
    if not np.any(can_fit_mask):
        return priorities

    # Assign a base priority to bins that can fit the item
    # A simple approach is to give a higher priority to bins with less remaining capacity
    # (First Fit Decreasing like idea, but Random Fit just picks one)
    # We can use the inverse of remaining capacity + 1 to avoid division by zero and penalize fuller bins.
    # For Random Fit, we also want to introduce randomness, so we add a small random number.

    # We can assign a base priority and then add noise.
    # Bins that can fit the item get a positive priority.
    # Bins that cannot fit get 0.

    # Let's try assigning a score based on how "tight" the fit is, plus randomness.
    # A tighter fit (less remaining capacity) could be preferred to minimize waste,
    # and then we randomize among these good fits.

    # Calculate potential "waste" if item is placed in the bin (remaining_capacity - item)
    # We want to minimize waste, so higher priority for smaller waste.
    # Let's use -(remaining_capacity - item) as a base for priority, so smaller remaining_capacity is better.
    # We also add a random value to make it "Random Fit".
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item) + np.random.rand(np.sum(can_fit_mask)) * 0.1 # Add small random noise

    # A simpler interpretation for "Random Fit" would be to give all eligible bins
    # an equal base priority and then add randomness.
    # In this interpretation, any bin that fits is equally likely.
    # priorities[can_fit_mask] = 1 + np.random.rand(np.sum(can_fit_mask)) * 0.01 # Give a base priority and small random noise

    # The prompt asks for a priority score for EACH bin.
    # The highest priority score bin will be selected.
    # So we should ensure that bins that *cannot* fit have a lower priority than those that *can*.

    # Let's refine the strategy:
    # 1. Bins that cannot fit the item get a priority of 0.
    # 2. Bins that *can* fit the item get a positive priority. To simulate randomness,
    #    we can assign a random priority to each eligible bin. A simple approach is
    #    to assign a uniformly random number within a small range.

    # Re-initializing priorities to zeros
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    eligible_bins_indices = np.where(bins_remain_cap >= item)[0]

    if eligible_bins_indices.size > 0:
        # Assign a random priority to each eligible bin.
        # A simple uniform random value between 0 and 1 is sufficient to make them
        # randomly chosen when selected using argmax.
        priorities[eligible_bins_indices] = np.random.rand(eligible_bins_indices.size)

    return priorities
```
