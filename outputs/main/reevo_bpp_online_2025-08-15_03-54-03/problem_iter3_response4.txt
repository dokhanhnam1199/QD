```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a strategy
    that prioritizes bins with minimal remaining capacity after packing (tighter fit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1. Bins that can fit the item are scored
        based on their remaining capacity after packing, favoring those that
        leave minimal remaining capacity.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity *after* packing the item
    remaining_after_packing = bins_remain_cap[can_fit_mask] - item

    # We want to prioritize bins where remaining_after_packing is minimal (tighter fit).
    # A simple way to achieve this is to sort by remaining_after_packing in ascending order.
    # The priority score should be higher for smaller remaining capacities.
    # We can achieve this by taking the negative of the remaining capacity
    # and potentially shifting it to ensure it's higher than the default -1.
    if remaining_after_packing.size > 0:
        # Prioritize by minimal remaining capacity after packing.
        # A larger score for smaller remaining capacity.
        # Using the negative of remaining capacity: smaller remaining_after_packing -> less negative score.
        # Adding a large constant to ensure positive scores and distinguish from non-fitting bins.
        # The constant should be larger than any possible negative score.
        # A safe bet is to use a value that's larger than the maximum possible
        # negative remaining capacity, which is related to the bin size.
        # Let's use a simple approach: a large multiplier for inverse proportion.
        # Or even simpler, just the negative of the remaining capacity,
        # and ensure it's greater than -1 by adding a sufficiently large value.
        # Example: if remaining is 0.1, score is -0.1. If remaining is 0.01, score is -0.01. -0.01 > -0.1.
        # To make it clearly higher than -1, we can add a large value.
        # The maximum possible remaining capacity would be if we pack an item into a full bin.
        # So, remaining_after_packing will be between 0 and (max_bin_cap - min_item_size).
        # The most negative value it can take is when the bin is almost full and the item is small,
        # leaving a large remainder. The most positive value is when the bin is just big enough.
        # We want to prioritize bins with remainder close to 0.
        # So, we can use `1 / (remaining_after_packing + epsilon)` or `max_val - remaining_after_packing`.
        # Let's use the latter for simplicity and better control of scale.
        # A large value for `max_val` ensures higher scores for smaller remainders.
        # A safe `max_val` could be slightly larger than any possible remaining capacity.
        # If bins have capacity up to `C`, and items are at least `m`, max remaining is `C-m`.
        # Let's pick a value that's guaranteed to be larger than any potential remaining capacity.
        # A value like `1000` or `np.max(bins_remain_cap) + 1` should be sufficient if capacities are not excessively large.
        # Or, we can simply use the negative of the remaining capacity and add 1 to make it positive if needed.
        # A simpler approach that maintains relative order and ensures higher priority for smaller remainders:
        # Prioritize by `-(remaining_after_packing)`. For remaining=0.1, score=-0.1. For remaining=0.01, score=-0.01.
        # We need these scores to be greater than -1.
        # So, let's use `-(remaining_after_packing) + offset`. The offset needs to be large enough.
        # A simple monotonic transformation: `1.0 / (remaining_after_packing + 1e-9)` would also work,
        # prioritizing smaller positive values.
        # Let's go with `max_possible_remaining - remaining_after_packing` for clarity.
        # Max possible remaining capacity is max_initial_capacity - min_item_size.
        # A simple approach is to take the negative of the remaining capacity.
        # Bins with smaller remaining capacity will have scores closer to zero (less negative).
        # We want these scores to be greater than -1.
        # So, we can add a constant that ensures this.
        # A simple proportional inverse relationship: a large constant minus the remaining capacity.
        # This prioritizes smaller remaining capacities with higher scores.
        # Let's use `max_initial_capacity - item` as a reference for a maximally "bad" fit.
        # This logic seems to align with First Fit Decreasing's intuition of filling up bins efficiently.
        # The goal is to have `remaining_after_packing` be as close to 0 as possible.
        # So, `max_val - remaining_after_packing` prioritizes smaller `remaining_after_packing`.
        # We can set `max_val` to a value larger than any possible `remaining_after_packing`.
        # Example: if bins_remain_cap are [10, 5, 8] and item is 3.
        # Fits: [10, 5, 8]. Remaining after packing: [7, 2, 5].
        # We want to prioritize the bin with remaining capacity 2.
        # Scores: Bin1: 10-3=7. Bin2: 5-3=2. Bin3: 8-3=5.
        # The bin with remaining capacity 2 gets score 2. This is not higher priority.
        # We want higher priority for smaller remaining capacity.
        # So, the score should be inversely related to remaining capacity.
        # Option 1: Use negative of remaining capacity.
        # Remaining: [7, 2, 5]. Scores: [-7, -2, -5]. Highest is -2, which is correct.
        # We need to ensure these are > -1. So add an offset.
        # offset = 10 (or any value > 7). Scores: [3, 8, 5]. Highest is 8.
        # Option 2: Use 1 / (remaining_capacity + epsilon)
        # Remaining: [7, 2, 5]. Scores: [1/7, 1/2, 1/5]. Highest is 1/2, which is correct.
        # Option 3: Use max_possible_value - remaining_capacity.
        # max_possible_remaining could be considered the capacity of the largest bin minus the smallest item.
        # Let's consider a large number for simplicity, like 1000, assuming bin capacities are reasonable.
        # Remaining: [7, 2, 5]. Scores: [1000-7, 1000-2, 1000-5] = [993, 998, 995]. Highest is 998.
        # This is equivalent to prioritizing smaller remaining capacities.
        # The reflection mentions "adjusting sensitivity to residual size". This implies that the *difference*
        # matters. The `max_val - remaining` approach reflects this directly.

        # Let's use `max_val - remaining_after_packing`.
        # A safe `max_val` could be related to the maximum bin capacity, ensuring it's larger than any possible remaining capacity.
        # If we don't know the max capacity, a large constant is fine. Let's assume a typical range of capacities.
        # Or, we can use the maximum *initial* remaining capacity as `max_val`.
        # max_initial_remaining = np.max(bins_remain_cap[can_fit_mask])
        # However, this can lead to values close to zero for the best fit.
        # Let's stick to a fixed large offset for clear separation from -1.
        # The negative of remaining capacity is directly proportional to how full the bin becomes.
        # We want to maximize "fullness".
        # Let's use `-remaining_after_packing`. To make it greater than -1, add a buffer.
        # The minimum remaining capacity is 0, so the maximum negative score is 0.
        # The maximum remaining capacity can be `max(bins_remain_cap) - min(item_sizes)`.
        # So, the scores will range from -(max_initial_capacity) to 0.
        # Adding a buffer ensures we are above -1.
        # A buffer of 1 makes the range [0, max_initial_capacity - 1].
        # This means smaller remaining capacities have higher (less negative) scores.
        priorities[can_fit_mask] = -remaining_after_packing

    # Now, ensure all fitting bins have a priority higher than non-fitting bins (-1).
    # If any fitting bin has a score <= -1 (e.g., remaining_after_packing is very large, making -remaining_after_packing <= -1),
    # we should adjust. However, remaining_after_packing will always be >= 0.
    # So, -remaining_after_packing will always be <= 0.
    # If we want strictly higher than -1, we can add a small epsilon or a constant.
    # A simple way to prioritize smaller remaining capacities:
    # Directly use `-remaining_after_packing`. The highest value here corresponds to the smallest `remaining_after_packing`.
    # To ensure these are clearly higher than -1, we can add a value.
    # Let's assign `1.0 / (remaining_after_packing + epsilon)` for a direct inverse relationship.
    # Or, a large number minus the remaining capacity.
    # `large_number - remaining_after_packing` -> prioritizing smaller `remaining_after_packing`.
    # A suitable large number could be `np.max(bins_remain_cap) + 1`.
    # Let's use a simpler form that still prioritizes smaller remainders:
    # `1 / (remaining_after_packing + 1e-9)`
    # This assigns a large score to small remainders and smaller scores to large remainders.
    # And ensures these are positive, hence > -1.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (remaining_after_packing + epsilon)

    return priorities
```
