```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Minimum Remaining Capacity Fit strategy.

    The Minimum Remaining Capacity Fit strategy aims to place the item into the bin
    that will have the least remaining capacity after the item is placed. This means
    prioritizing bins where the remaining capacity is just enough or slightly more
    than the item size. This aims to "fill up" bins more effectively.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very small negative number.
    # Bins that cannot accommodate the item will have the lowest priority.
    priorities = np.full_like(bins_remain_cap, -float('inf'))

    # Identify bins that can accommodate the current item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, the priority is determined by how much
    # capacity will be left after placing the item.
    # We want to minimize the remaining capacity, so higher priority should be given
    # to bins where `bins_remain_cap - item` is smaller.
    # A common way to achieve this is to use the inverse of the remaining capacity
    # after placing the item. To avoid division by zero and to give higher priority
    # to smaller positive remaining capacities, we can use `1 / (remaining_capacity + epsilon)`.
    # This ensures that bins with the smallest positive `bins_remain_cap - item` get the highest priority.

    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # Add a small epsilon to avoid division by zero, especially if remaining_after_fit is 0.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit + epsilon)

    return priorities
```
