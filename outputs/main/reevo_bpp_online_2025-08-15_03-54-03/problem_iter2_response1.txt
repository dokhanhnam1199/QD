```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    The Best Fit strategy aims to place the item into the bin that leaves the least
    remaining capacity after placement. This heuristic prioritizes bins that are
    "almost full" with the current item, aiming to minimize wasted space within each bin
    and thus potentially reduce the total number of bins used. Bins that cannot fit
    the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher priority means the bin is more suitable according to the Best Fit strategy.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after fitting
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # Assign priority. Higher priority for bins that result in the smallest remaining capacity.
    # We can invert the remaining capacity to make smaller remaining capacity higher priority.
    # A small epsilon is added to prevent division by zero if remaining_after_fit is exactly 0.
    # Using a large number for a perfect fit (remaining_after_fit == 0) can be beneficial.
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit + 1e-9)

    return priorities
```
