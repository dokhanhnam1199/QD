```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a modified First Fit strategy.

    This version aims to prioritize bins that, after packing the item,
    will have the *least* remaining capacity. This is a common heuristic
    for minimizing wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1. Bins that can fit the item are scored
        based on the *resulting* remaining capacity after packing, favoring
        bins with the smallest resulting capacity.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity *after* packing
    if np.any(can_fit_mask):
        resulting_remain_cap = bins_remain_cap[can_fit_mask] - item

        # We want to prioritize bins with the *least* resulting remaining capacity.
        # This means a smaller `resulting_remain_cap` should have a higher priority.
        # We can achieve this by using a transformation that maps smaller values
        # to larger scores. A simple way is to use a large constant minus the
        # resulting remaining capacity. This ensures that bins with very little
        # space left after packing get the highest scores.
        # We need a reference value that is guaranteed to be larger than any
        # possible `resulting_remain_cap`. The maximum initial bin capacity plus
        # the item size is a safe upper bound for the original capacity, so
        # `max(bins_remain_cap) + item` is a safe upper bound for the original
        # capacity, and thus `max(bins_remain_cap)` is a safe upper bound for
        # `resulting_remain_cap`. Let's use `max(bins_remain_cap)` to scale.
        # A more robust large number could be used, but this is generally sufficient.
        # A very large constant ensures that these prioritized bins have scores
        # significantly higher than the default -1.
        large_constant = 1e9
        priorities[can_fit_mask] = large_constant - resulting_remain_cap

    return priorities
```
