```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined strategy.

    This strategy prioritizes bins that can accommodate the item. Among those,
    it favors bins with the smallest remaining capacity (tightest fit).
    To achieve this, scores are calculated as (bin_capacity - item) for fitting bins,
    effectively prioritizing bins where the remaining capacity is just enough.
    A small offset is added to differentiate between bins with the same remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins that cannot fit the
        item are given a score of -1. Bins that can fit the item are scored
        based on how tightly they fit the item.
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with low priority (-1)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, assign a priority score.
    # We want to prioritize bins with the *least* remaining capacity that still fit the item.
    # This is equivalent to finding bins where (remaining_capacity - item) is minimized.
    # A smaller (remaining_capacity - item) means a tighter fit.
    # We want higher scores for tighter fits, so we use a large constant minus this difference.
    # Alternatively, we can simply use the negative of (remaining_capacity - item),
    # so the smallest positive residual gets the highest (least negative) score.
    # Let's use a strategy that prioritizes minimal *positive* residual capacity.
    # A simple way is to use -(remaining_capacity - item) which means the largest
    # negative residual (closest to 0) gets the highest score.
    # This implicitly prioritizes bins with smaller remaining capacities.

    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    if fitting_bins_capacities.size > 0:
        # Calculate the "slack" or remaining capacity after fitting the item
        slack = fitting_bins_capacities - item
        # We want to prioritize bins with minimal slack (tightest fit).
        # So, a smaller slack should result in a higher priority score.
        # We can achieve this by using a large number minus the slack.
        # Adding a small epsilon to the slack before negating can help distinguish
        # between bins with identical remaining capacities.
        epsilon = 1e-9 # A small value to differentiate
        priorities[can_fit_mask] = -(slack - epsilon) # Prioritize smaller slack

    return priorities
```
