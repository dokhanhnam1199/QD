```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority using First Fit strategy, favoring bins with minimal remaining capacity.

    This heuristic prioritizes bins that can fit the item and among those,
    prefers bins with the least remaining capacity. This is a direct implementation
    of the First Fit strategy where the "priority" is simply a score that ranks
    eligible bins by their remaining capacity. Bins that cannot fit the item
    receive a score of -1, effectively excluding them from selection.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority. Bins that can fit the item are
        scored based on their remaining capacity, with smaller capacities being better.
        Bins that cannot fit the item have a score of -1.
    """
    # Initialize priorities to -1, indicating that the item cannot fit or it's the lowest priority.
    priorities = np.full_like(bins_remain_cap, -1.0)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, assign a priority score.
    # We want to prioritize bins with *less* remaining capacity.
    # A simple way to achieve this is to use the negative of the remaining capacity.
    # This way, a bin with remaining capacity 'r' gets a score of '-r'.
    # A smaller 'r' (e.g., 0.1) will result in a higher score (-0.1) than a larger 'r' (e.g., 1.0, score -1.0).
    # This directly implements the First Fit logic of choosing the first available bin
    # that can accommodate the item, effectively prioritizing those with less slack.
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    if fitting_bins_capacities.size > 0:
        priorities[can_fit_mask] = -fitting_bins_capacities

    return priorities
```
