```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority using a sigmoid-based function that favors bins with small positive residuals.

    This heuristic prioritizes bins where the remaining capacity (`r`) after placing the item
    is as close to zero as possible, but still non-negative. The sigmoid function
    `1 / (1 + exp(k * r))` is used, where `k` is a sensitivity parameter.
    A higher `k` makes the priority drop faster as `r` increases.
    Bins where the item does not fit (i.e., `r < 0`) receive a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Sensitivity parameter for the sigmoid function.
    # A higher k means a sharper drop in priority as the remaining capacity increases.
    # This value can be tuned based on experimental results.
    k = 15.0  # Increased sensitivity

    # Initialize priorities to 0. Bins where the item cannot fit will keep this score.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the remaining capacity if the item were placed in each bin.
    residuals = bins_remain_cap - item

    # Identify bins where the item can fit (residual >= 0).
    can_fit_mask = residuals >= 0

    # For bins that can fit the item, calculate the priority score using the sigmoid function.
    # The function 1 / (1 + exp(k * residual)) produces scores between 0 and 1.
    # - When residual is 0 (perfect fit), score is 1 / (1 + exp(0)) = 0.5.
    # - When residual is small positive (e.g., 0.01, k=15), arg is 0.15, score is ~0.53 (slightly higher priority).
    # - When residual is large positive (e.g., 1.0, k=15), arg is 15.0, score is ~0.000003 (very low priority).
    # This correctly prioritizes bins with the smallest positive residuals.
    if np.any(can_fit_mask):
        # Apply sigmoid to the residuals. Higher `k` will make the priority drop more sharply
        # as the residual increases, effectively favoring bins with minimal remaining capacity.
        priorities[can_fit_mask] = 1.0 / (1.0 + np.exp(k * residuals[can_fit_mask]))

    return priorities
```
