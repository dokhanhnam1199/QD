```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Epsilon-Greedy priority function for Online Bin Packing Problem.

    This heuristic aims to balance exploration and exploitation.
    It primarily favors bins that can fit the item with the least remaining capacity
    (a "best fit" greedy approach). However, with a small probability (epsilon),
    it explores other options by assigning a small random positive value to all bins,
    encouraging the use of less-filled bins occasionally.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploration
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if np.any(can_fit_mask):
        # Greedy part: prioritize bins that fit the item with least remaining capacity
        # This is a "best fit" heuristic. Smaller remaining capacity means a better fit.
        # We subtract item from remaining capacity to get the 'waste' after placement.
        # We want to minimize this waste.
        fit_capacities = bins_remain_cap[can_fit_mask] - item
        priorities[can_fit_mask] = -fit_capacities # Negative because we want to minimize waste (maximize negative waste)

        # Exploration part: with probability epsilon, add random noise to explore
        if np.random.rand() < epsilon:
            # Add a small positive random value to all bins that can fit the item.
            # This allows less-preferred bins to sometimes be chosen.
            random_noise = np.random.rand(np.sum(can_fit_mask)) * 0.01 # Small noise to avoid drastic changes
            priorities[can_fit_mask] += random_noise

    else:
        # If no bin can fit the item, the priority is effectively the same for all.
        # In a real scenario, this might mean opening a new bin.
        # For the purpose of priority scores among existing bins, we can assign
        # a uniform (but low) priority, or indicate that no suitable bin exists.
        # Here, we assign a small negative value to all bins to signify no good fit.
        priorities[:] = -1.0 # Indicate no bin fits

    return priorities
```
