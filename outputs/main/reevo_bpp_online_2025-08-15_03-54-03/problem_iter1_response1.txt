```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy aims to minimize wasted space by placing the item in the bin
    that leaves the least remaining capacity. However, in an online setting, we need
    to ensure the item can actually fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more suitable bin. Bins that cannot accommodate
        the item are given a priority of -1.
    """
    # Initialize priorities to 0
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after packing
    # The best fit will have the smallest positive remaining capacity
    remaining_after_fit = bins_remain_cap[fit_mask] - item

    # Assign priorities. Higher priority for bins with less remaining capacity (best fit).
    # We use negative remaining capacity as a proxy for "goodness" of fit.
    # A smaller positive remaining capacity results in a larger negative value,
    # thus a higher priority.
    priorities[fit_mask] = -remaining_after_fit

    # Bins that cannot fit the item are assigned a very low priority (-1)
    priorities[~fit_mask] = -1.0

    return priorities
```
