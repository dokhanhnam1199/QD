```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an Epsilon-Greedy strategy.

    The strategy aims to balance exploration (trying less occupied bins) with exploitation
    (favoring bins that have a tight fit for the item).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploring a random bin

    # Identify feasible bins where the item can fit
    feasible_bins_mask = bins_remain_cap >= item
    
    # If no bins are feasible, return all zeros (no valid placement)
    if not np.any(feasible_bins_mask):
        return np.zeros_like(bins_remain_cap)

    # Initialize priorities for all bins
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Greedy (Exploitation) part: Prioritize bins that are a "tight fit"
    # We want bins where remaining capacity - item size is small.
    # To avoid division by zero or very small numbers, we can add a small constant.
    # Also, to make smaller remaining capacities more dominant, we can use the inverse.
    # However, a simple approach is to prioritize bins with the smallest remaining capacity
    # that can still fit the item. This is equivalent to prioritizing bins where the
    # residual capacity (after placing the item) is minimized.
    
    # Calculate the residual capacity if the item is placed in a feasible bin
    residual_capacities = bins_remain_cap[feasible_bins_mask] - item
    
    # For feasible bins, calculate a greedy score. Lower residual capacity is better.
    # We can use the inverse of (residual_capacity + 1) to ensure higher scores for better fits.
    # Add a small epsilon to avoid division by zero and to make smaller residuals more impactful.
    greedy_scores = 1.0 / (residual_capacities + 1e-6)

    # Apply the greedy scores to the feasible bins
    priorities[feasible_bins_mask] = greedy_scores

    # Epsilon-Greedy (Exploration) part: With probability epsilon, choose a random feasible bin
    # This helps to avoid getting stuck in local optima by sometimes trying bins
    # that are not the "best fit" according to the greedy strategy.

    # Generate random numbers for each bin
    random_values = np.random.rand(len(bins_remain_cap))

    # For feasible bins, if the random value is less than epsilon, give it a high exploration score.
    # We can assign a constant high score, or a score based on randomness.
    # Let's assign a score that makes it competitive but not necessarily dominant.
    # A simple approach is to assign a score that is slightly better than the "average"
    # greedy score or a random high value.
    
    # We want to randomly pick among the *feasible* bins.
    num_feasible_bins = np.sum(feasible_bins_mask)
    
    if num_feasible_bins > 0:
        # Get indices of feasible bins
        feasible_bin_indices = np.where(feasible_bins_mask)[0]
        
        # Determine how many bins to "explore" based on epsilon
        num_to_explore = int(np.floor(epsilon * num_feasible_bins))
        
        if num_to_explore > 0:
            # Randomly select indices of feasible bins to give an exploration boost
            exploration_indices = np.random.choice(feasible_bin_indices, num_to_explore, replace=False)
            
            # Assign a high exploration score to these bins.
            # A score that is slightly higher than the current best greedy score
            # would be reasonable. For simplicity, let's use a constant that ensures
            # it's considered.
            exploration_boost = np.max(greedy_scores) * 1.1 if np.any(greedy_scores) else 1.0
            priorities[exploration_indices] = exploration_boost

    return priorities
```
