```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic implements the "Exact Fit First" strategy.
    It prioritizes bins that can *exactly* fit the item. If multiple bins
    can exactly fit the item, it prioritizes the one with the least remaining
    capacity after fitting (to keep larger remaining capacities available for
    potentially larger future items).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can exactly fit the item
    exact_fit_bins_mask = (bins_remain_cap == item)

    # If there are exact fit bins, prioritize them.
    # Among exact fit bins, prefer those with less remaining capacity
    # (which after fitting the item, will have even less remaining capacity).
    # A higher priority score means more preferred.
    # We assign a high base score (e.g., 100) for exact fits.
    # To differentiate between exact fit bins, we can use the inverse
    # of their remaining capacity (larger capacity gets lower score,
    # smaller capacity gets higher score among exact fits).
    if np.any(exact_fit_bins_mask):
        priorities[exact_fit_bins_mask] = 100 + (1.0 / (bins_remain_cap[exact_fit_bins_mask] - item + 1e-6)) # Add small epsilon to avoid division by zero if item == bin_capacity

    # If no exact fit bins, consider bins that can fit the item.
    # For non-exact fits, we want to prioritize bins that leave the smallest
    # remaining capacity after placing the item. This is a "best fit" idea.
    # Bins that are "too large" are less preferred.
    # A common way to achieve this is to prioritize bins with the smallest
    # remaining capacity that is still greater than the item.
    # We assign a lower base score for these non-exact fits.
    else:
        can_fit_mask = (bins_remain_cap > item)
        if np.any(can_fit_mask):
            # Prioritize bins with the smallest remaining capacity that can fit the item
            # A higher priority for smaller remaining capacity.
            priorities[can_fit_mask] = 10 + (1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-6))

    return priorities
```
