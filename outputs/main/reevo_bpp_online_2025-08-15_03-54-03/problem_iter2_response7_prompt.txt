{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance strategy.\n\n    The priority is calculated as 1 / (remaining_capacity - item_size + epsilon)\n    for bins where the item can fit, and 0 otherwise. Epsilon is added to\n    avoid division by zero. A higher score means the bin is a better fit (closer to full after packing).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-9  # To prevent division by zero\n\n    # Find bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate priority only for bins where the item can fit\n    # Inverse distance to being full after placing the item\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + epsilon)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score strategy.\n\n    The Sigmoid Fit Score strategy prioritizes bins that are \"almost full\"\n    but can still accommodate the item. This aims to keep bins as full as possible\n    without causing immediate overflow.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # We only consider bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate a \"fit score\"\n    # A good score would be for bins that are nearly full, but not too full.\n    # We can use a sigmoid function to map the remaining capacity to a score.\n    # A smaller remaining capacity (closer to 'item') should have a higher score.\n    # Let's transform remaining capacity into a \"wastefulness\" metric: waste = bin_capacity - item_size\n    # So, bins_remain_cap - item are potential remaining capacities if the item fits.\n    # We want to maximize the likelihood of a good fit.\n    # A common approach for \"almost full\" is to look at the ratio of item size to remaining capacity,\n    # or conversely, remaining capacity to bin capacity (though bin capacity isn't given here, only remaining).\n    # A simpler heuristic is to consider the difference: `bins_remain_cap - item`.\n    # We want to prioritize bins where this difference is small (but non-negative).\n\n    # Let's normalize the potential remaining capacity after placing the item.\n    # A value close to 0 (but positive) is desirable.\n    # We can use the inverse of the potential remaining capacity.\n    # However, we must handle cases where potential remaining capacity is 0 or very small\n    # to avoid division by zero or extremely large numbers.\n\n    # A more robust approach using sigmoid:\n    # Consider the 'slack' or 'residual capacity' after placing the item: residual = bins_remain_cap - item\n    # We want to maximize the probability of fitting.\n    # Let's try to map `residual` to a score where smaller positive values get higher scores.\n    # The sigmoid function `1 / (1 + exp(-x))` maps values to (0, 1).\n    # If we use `-(residual)`, then `exp(-residual)` will be small for large residuals\n    # and large for small residuals.\n    # So, `1 / (1 + exp(-(residual)))` will be closer to 1 for small positive residuals and closer to 0 for large residuals.\n    # We want small positive residuals to have HIGH priority.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the residual capacity if the item fits\n    residual_capacities = bins_remain_cap[can_fit_mask] - item\n\n    # We want to give higher priority to smaller *positive* residuals.\n    # A residual of 0 is ideal (perfect fit).\n    # A small positive residual is good.\n    # A large positive residual is less ideal.\n\n    # Using sigmoid:\n    # The sigmoid function typically maps values from -inf to +inf to (0, 1).\n    # If we want small positive residuals to have high priority, we can map them\n    # to positive values and then apply sigmoid.\n    # Let's consider the \"efficiency\" of the fit: `item / bins_remain_cap`\n    # This ratio is high for full bins and low for empty bins.\n    # We want to prioritize bins where this ratio is high (but the item must fit).\n\n    # Alternative Sigmoid approach:\n    # Let's consider `bins_remain_cap - item`. We want this value to be small and non-negative.\n    # We can transform `bins_remain_cap - item` into a variable `x` such that\n    # `sigmoid(x)` is high for small non-negative `bins_remain_cap - item`.\n    # Consider `y = -(bins_remain_cap - item)`. If `bins_remain_cap - item` is small positive, `y` is small negative.\n    # `sigmoid(y)` will be close to 0.5. Not what we want.\n\n    # Let's try a different mapping.\n    # The goal is to find bins that are \"just right\".\n    # Consider the gap: `gap = bins_remain_cap - item` for bins that can fit.\n    # We want to maximize priority for `gap` close to 0.\n    # Let's define a scoring function that peaks at gap = 0 and decreases as gap increases.\n    # We can use a sigmoid centered around 0, but inverted.\n    # `sigmoid(-x)` where x is the gap.\n    # `sigmoid(-(bins_remain_cap[can_fit_mask] - item))`\n\n    # Let `gap = bins_remain_cap - item`.\n    # We are interested in `gap >= 0`.\n    # Let `x = -(gap) = item - bins_remain_cap`.\n    # We want to maximize priority when `item - bins_remain_cap` is close to 0 (i.e., `bins_remain_cap` close to `item`).\n    # Consider `x = -(bins_remain_cap[can_fit_mask] - item) = item - bins_remain_cap[can_fit_mask]`\n    # If `bins_remain_cap = item`, `x = 0`, `sigmoid(0) = 0.5`.\n    # If `bins_remain_cap > item`, `x < 0`, `sigmoid(x)` is < 0.5.\n    # If `bins_remain_cap < item`, `x > 0`, `sigmoid(x)` is > 0.5. This is for items that don't fit.\n\n    # The standard \"Sigmoid Fit\" or \"Best Fit Decreasing\" often aims to fill bins as much as possible.\n    # For online BPP, \"First Fit Decreasing\" prioritizes the first bin that fits.\n    # \"Best Fit\" would prioritize the bin with the smallest remaining capacity that can still fit the item.\n\n    # Let's re-evaluate the \"Sigmoid Fit Score\" strategy for online BPP.\n    # The idea is to prioritize bins that are \"almost full\" but can still accept the item.\n    # This implies we want to minimize `bins_remain_cap - item` (for bins where it's >= 0).\n    # Let `residual = bins_remain_cap[can_fit_mask] - item`.\n    # We want to give higher priority as `residual` approaches 0.\n\n    # Let's try to map the `residual` to a score using sigmoid.\n    # We want a high score for small `residual` (close to 0) and lower scores for larger `residual`.\n    # Consider a transformation `y = -(residual)`.\n    # `sigmoid(y) = 1 / (1 + exp(-y)) = 1 / (1 + exp(-(residual)))`.\n    # If `residual = 0`, `exp(0) = 1`, `sigmoid = 0.5`.\n    # If `residual` is small positive, `-(residual)` is small negative, `exp(-(residual))` is slightly less than 1, `sigmoid` is slightly less than 0.5.\n    # If `residual` is large positive, `-(residual)` is large negative, `exp(-(residual))` is close to 0, `sigmoid` is close to 1.\n\n    # This sigmoid `1 / (1 + exp(-(bins_remain_cap - item)))` actually prioritizes bins with *larger* remaining capacity after fitting the item.\n    # This is counter-intuitive for \"almost full\".\n\n    # Let's try a sigmoid where smaller values of `residual` yield higher scores.\n    # Consider `sigmoid(-k * residual)` for some `k > 0`.\n    # If `residual = 0`, `sigmoid(0) = 0.5`.\n    # If `residual` is small positive, `-k * residual` is small negative, `sigmoid` is < 0.5.\n    # If `residual` is large positive, `-k * residual` is large negative, `sigmoid` is close to 0.\n    # This gives higher scores to bins with *smaller* remaining capacity after fitting (i.e., more full bins).\n\n    # Let's use `k = 1` for simplicity.\n    # Score for fitting bins: `sigmoid(-(bins_remain_cap[can_fit_mask] - item))`\n\n    # We need to scale the `residual` to make the sigmoid curve steeper or shallower.\n    # A common approach is to scale `bins_remain_cap - item` by some factor.\n    # Let's use the item size itself as a scaling factor. Or the median remaining capacity?\n    # For simplicity, let's use a fixed steepness factor, say `alpha`.\n\n    alpha = 10  # Steepness parameter for the sigmoid\n\n    # Calculate the negative of the residual for sigmoid input\n    # We want to map `bins_remain_cap - item` to `x` such that `sigmoid(f(x))` is high for small `x`.\n    # If we use `f(x) = -x`, then `sigmoid(-x)` has higher values for smaller `x`.\n    # So, let `x = bins_remain_cap[can_fit_mask] - item`.\n    # The scores will be `np.exp(-(alpha * x))`. No, that's not sigmoid.\n\n    # Let's use the form: `1 / (1 + exp(-k * (target - value)))`\n    # We want high priority when `bins_remain_cap - item` is close to 0.\n    # So, let `target = 0`. Let `value = bins_remain_cap - item`.\n    # Priority for fitting bins: `1 / (1 + exp(-alpha * (0 - (bins_remain_cap[can_fit_mask] - item))))`\n    # = `1 / (1 + exp(alpha * (bins_remain_cap[can_fit_mask] - item)))`\n\n    # Let's test this:\n    # If `bins_remain_cap - item = 0` (perfect fit): `1 / (1 + exp(0)) = 0.5`\n    # If `bins_remain_cap - item = small positive` (e.g., 0.1): `exp(0.1 * alpha)` is > 1. Denominator > 2. Score < 0.5.\n    # If `bins_remain_cap - item = large positive` (e.g., 1.0): `exp(1.0 * alpha)` is very large. Score close to 0.\n    # This means bins with larger remaining capacity *after* fitting get lower scores. This is good.\n\n    # If `bins_remain_cap - item = small negative` (item doesn't fit): We are masking this out.\n\n    # The problem is that the sigmoid output for the \"best\" case (residual = 0) is 0.5.\n    # We want the highest priority to be close to 1.\n    # This sigmoid form maps values to (0, 1).\n    # Maybe the interpretation of \"Sigmoid Fit Score\" implies mapping the *degree of fit* to a score.\n    # A good fit is when `bins_remain_cap` is `item` or slightly larger.\n    # The degree of \"emptiness\" after fitting is `bins_remain_cap - item`.\n    # We want to penalize large \"emptiness\".\n\n    # Consider mapping `bins_remain_cap` directly.\n    # Bins that can fit the item are those where `bins_remain_cap >= item`.\n    # Among these, we want those that are closest to `item`.\n    # This means we want to maximize `1 / (1 + exp(-alpha * (bins_remain_cap - item)))` for `bins_remain_cap >= item`.\n    # If `bins_remain_cap = item`, `exp(0) = 1`, score is 0.5.\n    # If `bins_remain_cap` is slightly larger than `item`, `exp(positive)` is > 1, score is < 0.5.\n    # If `bins_remain_cap` is much larger than `item`, `exp(much positive)` is very large, score is close to 0.\n\n    # This actually seems to prioritize bins with *less* remaining capacity after fitting,\n    # which is what \"best fit\" does. However, the peak is at 0.5, not 1.\n\n    # Let's try to shift and scale the sigmoid.\n    # We want a peak at `bins_remain_cap = item`.\n    # Let `x = bins_remain_cap[can_fit_mask] - item`.\n    # We want a function `f(x)` such that `f(0)` is high, `f(small_positive)` is slightly lower,\n    # and `f(large_positive)` is low.\n\n    # What if we consider the *ratio* of remaining capacity to bin capacity (if we knew it)?\n    # Since we don't know bin capacity, let's focus on the `item` and `bins_remain_cap`.\n\n    # Let's try a different formulation for sigmoid: `sigmoid(x) = 1 / (1 + exp(-x))`.\n    # We want to maximize `f(bins_remain_cap)`.\n    # For bins that can fit, `bins_remain_cap >= item`.\n    # Consider `value = item / bins_remain_cap[can_fit_mask]`. This is the fill ratio.\n    # We want to prioritize higher fill ratios.\n    # `sigmoid(k * (item / bins_remain_cap[can_fit_mask]))`\n    # If `bins_remain_cap = item`, ratio is 1. Sigmoid is `1 / (1 + exp(-k))`.\n    # If `bins_remain_cap` is slightly larger, ratio is slightly less than 1. Sigmoid is slightly less.\n    # If `bins_remain_cap` is much larger, ratio is close to 0. Sigmoid is close to 0.5.\n    # This prioritizes bins that are almost full (high fill ratio).\n\n    # Let's use this. We need to handle potential division by zero if `bins_remain_cap` is 0,\n    # but our `can_fit_mask` already filters for `bins_remain_cap >= item`.\n    # If `item > 0`, then `bins_remain_cap` will be > 0.\n    # If `item = 0`, then `bins_remain_cap` can be 0, but `0/0` is NaN.\n    # If `item = 0`, it fits in any bin, and has ratio 0.\n\n    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate fill ratio for bins that can fit the item\n    # Avoid division by zero for bins with remaining capacity 0, although our mask should prevent this if item > 0.\n    # If item is 0, then the fill ratio is 0 for any bin that can fit it (all bins).\n    positive_capacities_mask = bins_remain_cap > 0\n    can_fit_and_positive_cap_mask = can_fit_mask & positive_capacities_mask\n\n    # For bins that can fit and have positive capacity, calculate the fill ratio.\n    # fill_ratio = item / bins_remain_cap\n    fill_ratios[can_fit_and_positive_cap_mask] = item / bins_remain_cap[can_fit_and_positive_cap_mask]\n\n    # If item is 0, it fits everywhere. The fill ratio is effectively 0.\n    # Our `fill_ratios` is initialized to 0, so this is handled.\n\n    # Apply sigmoid to the fill ratio to get priority scores.\n    # Higher fill ratios should result in higher scores.\n    # Sigmoid function: `1 / (1 + exp(-k * x))` where x is the fill ratio.\n    # A larger k makes the transition steeper.\n    k = 15  # Steepness factor for the sigmoid. Higher means it's more sensitive to small changes in fill ratio.\n\n    # The fill ratio is between 0 and 1.\n    # `sigmoid(k * fill_ratio)`:\n    # If fill_ratio = 0, sigmoid = 0.5\n    # If fill_ratio = 1, sigmoid = 1 / (1 + exp(-k)) which is close to 1 for large k.\n    # This prioritizes bins with higher fill ratios.\n\n    # Let's ensure we don't get NaN or Inf if `bins_remain_cap` is exactly 0 and `item` is > 0.\n    # `can_fit_mask` ensures `bins_remain_cap >= item`.\n    # If `item > 0`, then `bins_remain_cap` must be > 0.\n    # So `bins_remain_cap[can_fit_mask]` will not be zero.\n\n    # We need to apply sigmoid to the `fill_ratios`.\n    # For bins that *cannot* fit the item, their priority should be 0.\n    # The `fill_ratios` are already 0 for these bins due to initialization and mask logic.\n\n    # Calculate the priority using sigmoid\n    # For bins where `can_fit_mask` is True, the `fill_ratios` have been calculated.\n    # For bins where `can_fit_mask` is False, `fill_ratios` remain 0.\n    # Applying sigmoid to 0 gives 0.5. This is not desired for bins that cannot fit.\n    # We need to apply sigmoid *only* to the bins that can fit.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate fill ratios only for bins that can fit\n    if np.any(can_fit_mask):\n        # Ensure we only divide by positive capacities if item > 0\n        # If item is 0, fill ratio is 0 for any bin it fits in.\n        if item > 0:\n            valid_capacities_for_fit = bins_remain_cap[can_fit_mask]\n            # We already ensured valid_capacities_for_fit >= item > 0.\n            # So division by zero is not an issue here.\n            current_fill_ratios = item / valid_capacities_for_fit\n        else: # item is 0\n            current_fill_ratios = np.zeros(np.sum(can_fit_mask)) # Fill ratio is 0 for zero-sized items.\n\n        # Apply sigmoid to the fill ratios.\n        # `sigmoid(k * current_fill_ratios)`\n        # This maps fill_ratio (0 to 1) to sigmoid values (0.5 to ~1).\n        # We want higher scores for higher fill ratios.\n        # Let's use `sigmoid(k * (current_fill_ratios - offset))` to shift the peak or make it more sensitive.\n        # If we want the peak at fill_ratio = 1 (i.e., best fit), we need the sigmoid input to be large positive at fill_ratio = 1.\n        # `k * fill_ratio` achieves this.\n\n        # `sigmoid(k * x)` where `x` is the fill ratio.\n        # To make the 'peak' at fill_ratio = 1 more pronounced and the drop-off steeper for lower fill ratios,\n        # we can simply use a large `k`.\n\n        # Let's use `alpha * (item / bins_remain_cap)` as input to sigmoid.\n        # This results in scores between `sigmoid(0)` (0.5) and `sigmoid(alpha)` (~1).\n        # A slightly different strategy is to prioritize bins with *least* remaining capacity that *can* fit the item.\n        # This is the \"Best Fit\" strategy. How to achieve this with sigmoid?\n\n        # Let's try a different approach using sigmoid to emphasize \"almost full\".\n        # Consider the gap: `gap = bins_remain_cap - item`. We want small, non-negative gaps to have high priority.\n        # Let `x = -(gap) = item - bins_remain_cap`.\n        # For bins that can fit, `gap >= 0`, so `x <= 0`.\n        # `sigmoid(k * x)`:\n        # If `gap = 0`, `x = 0`, `sigmoid(0) = 0.5`.\n        # If `gap` is small positive, `x` is small negative, `sigmoid` < 0.5.\n        # If `gap` is large positive, `x` is large negative, `sigmoid` close to 0.\n        # This prioritizes bins with *larger* gaps (less full bins), which is NOT what we want.\n\n        # Let's invert the sigmoid input.\n        # `sigmoid(-k * x)` where `x = bins_remain_cap - item`.\n        # `sigmoid(-k * (bins_remain_cap[can_fit_mask] - item))`\n        # If `bins_remain_cap - item = 0`: `sigmoid(0) = 0.5`.\n        # If `bins_remain_cap - item = small positive`: `sigmoid(-k * small_positive)` is < 0.5.\n        # If `bins_remain_cap - item = large positive`: `sigmoid(-k * large_positive)` is close to 0.\n        # This means bins with larger remaining capacity after fitting get lower scores. This IS what we want!\n        # The priority scores will be in the range (0, 1), with the highest score being 0.5 for a perfect fit.\n        # To get scores closer to 1 for perfect fits, we can modify the sigmoid or the input.\n\n        # Let's refine the input:\n        # `value = (bins_remain_cap[can_fit_mask] - item)`\n        # We want `value=0` to give the highest score.\n        # We can use `sigmoid(k * (1 - normalized_value))`\n        # Normalization is tricky.\n\n        # Let's go back to the fill ratio: `fill_ratio = item / bins_remain_cap` for bins that can fit.\n        # We want to prioritize `fill_ratio` close to 1.\n        # Let `x = fill_ratio`. We want `sigmoid(k * x)` to be high for high `x`.\n        # If `fill_ratio` is always <= 1, then `sigmoid(k * fill_ratio)` has its highest value at `fill_ratio = 1`.\n        # `sigmoid(k)` which is close to 1.\n        # For `fill_ratio = 0`, `sigmoid(0) = 0.5`.\n        # This mapping is good: 0.5 for bins that are empty-ish after fitting, ~1 for bins that are full.\n\n        # Re-implementing the fill ratio approach:\n        fill_ratios_for_fitting = np.zeros(np.sum(can_fit_mask))\n        \n        # Case: item size is 0\n        if item == 0:\n            # A zero-sized item fits into any bin. It doesn't consume capacity.\n            # The \"fill ratio\" could be considered 0 as it doesn't fill anything.\n            # Or, perhaps it makes bins that *can* fit the item have a score.\n            # If we use the current sigmoid, 0 fill ratio maps to 0.5 priority.\n            # So, any bin that can fit a zero item would get a priority of 0.5.\n            # This seems reasonable: a zero item can be placed in any bin with equal preference based on capacity.\n            # Let's proceed with the fill ratio calculation as if item > 0, and handle the item=0 case gracefully.\n            # If item is 0, `current_fill_ratios = 0 / bins_remain_cap` (if bin_remain_cap > 0).\n            # If bin_remain_cap is also 0, it's 0/0. But can_fit_mask requires `bins_remain_cap >= 0`.\n            # If item is 0, it fits in any bin.\n            # Let's define fill ratio for item=0 as 0.\n            fill_ratios_for_fitting = np.zeros(np.sum(can_fit_mask)) # fill ratio is 0\n        else:\n            # Item size > 0\n            bins_with_positive_capacity_that_fit = bins_remain_cap[can_fit_mask]\n            \n            # Filter for positive remaining capacities to avoid division by zero.\n            # Our `can_fit_mask` ensures `bins_remain_cap >= item`.\n            # If `item > 0`, then `bins_remain_cap` must be > 0 for `can_fit_mask` to be true.\n            # So, `bins_with_positive_capacity_that_fit` is guaranteed to be > 0.\n            \n            fill_ratios_for_fitting = item / bins_with_positive_capacity_that_fit\n\n        # Now apply sigmoid to these fill ratios.\n        # `k` controls the steepness. A higher `k` means the priority rapidly increases as fill ratio approaches 1.\n        # This strategy \"Sigmoid Fit Score\" aims to pack items into bins that are almost full.\n        # So, we want higher priority for higher fill ratios.\n        # `sigmoid(k * fill_ratio)`\n        # fill_ratio is between 0 and 1.\n        # sigmoid(0) = 0.5\n        # sigmoid(k) is close to 1 for k large.\n        # This provides scores in the range (0.5, ~1) for fitting bins.\n\n        k = 10.0 # Tuning parameter for sigmoid steepness. Adjust this for desired behavior.\n\n        # Ensure the input to sigmoid is within reasonable bounds to avoid overflow/underflow of exp.\n        # fill_ratios are between 0 and 1. k=10 is fine.\n        # If k is very large, k*fill_ratio can exceed typical float limits.\n        # Clip k * fill_ratios to prevent overflow.\n        sigmoid_input = k * fill_ratios_for_fitting\n        \n        # To ensure that the output is always positive for fitting bins, and zero for non-fitting,\n        # we apply the sigmoid to `fill_ratios_for_fitting`.\n        # Bins that cannot fit the item will have their priority remain 0 from initialization.\n        priorities[can_fit_mask] = 1 / (1 + np.exp(-sigmoid_input))\n\n    return priorities\n\n[Reflection]\nPrioritize bins with less remaining capacity. Use sigmoid on fill ratio for a smoother approach.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}