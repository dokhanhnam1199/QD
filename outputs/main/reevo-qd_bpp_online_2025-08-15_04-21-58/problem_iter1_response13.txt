```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # The "Almost Full Fit" strategy aims to select a bin that is almost full,
    # but can still accommodate the item.
    # A good heuristic would be to prioritize bins where the remaining capacity
    # is slightly larger than the item's size. This minimizes wasted space
    # in the chosen bin while ensuring the item fits.

    # We want to find bins where bins_remain_cap[i] - item is small and positive.
    # A higher score means higher priority.

    # We can create a score that is high when (bins_remain_cap[i] - item) is close to zero
    # and positive.
    # If bins_remain_cap[i] < item, the bin cannot hold the item, so its priority should be 0.

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_accommodate_mask = bins_remain_cap >= item

    # For bins that can accommodate the item, calculate the "slack" (remaining capacity after placing the item)
    slack = bins_remain_cap[can_accommodate_mask] - item

    # We want to prioritize bins with minimal slack.
    # A simple way to create a priority score is to take the inverse of the slack + a small epsilon
    # to avoid division by zero if slack is exactly zero.
    # Alternatively, a negative of the slack can work if we sort in descending order.
    # Let's use the negative slack for simplicity in direct mapping to higher priority.
    # The more negative (closer to zero), the better.
    # To make it a positive priority score, we can transform it. A large negative number means
    # it's a "bad" fit (too much remaining space). A small negative number (close to zero) means
    # it's a "good" fit (almost full).

    # Let's define priority as a value that decreases as slack increases.
    # If slack is 0, priority is high. If slack is large, priority is low.
    # Consider priority = -slack. This gives higher values for smaller slacks.
    # We can add 1 to make all priorities non-positive to positive, ensuring higher means better.
    # Or, we can use a large constant minus slack.

    # Let's use a value that is inversely proportional to the slack.
    # A common approach for "best fit" like heuristics is to maximize `remaining_capacity - item_size`.
    # For "almost full fit", we want to MINIMIZE `remaining_capacity - item_size`, but only for valid fits.
    # So, we want `remaining_capacity - item_size` to be small and positive.
    # Let's try a priority that is high when `remaining_capacity - item_size` is small.
    # A possible transformation: 1 / (epsilon + remaining_capacity - item_size) for positive values.
    # Or, to avoid division by zero and keep it simpler, and to directly rank smaller remaining space higher:
    # priority = - (remaining_capacity - item_size)
    # Higher priority (less negative) means smaller remaining_capacity - item_size.

    # Let's try to make it simple: we want bins where bins_remain_cap is slightly greater than item.
    # So, we want bins_remain_cap - item to be small and positive.
    # Let's map this to a priority score.
    # If bin_remain_cap = item, slack = 0, priority is highest.
    # If bin_remain_cap = item + 1, slack = 1, priority is lower.
    # If bin_remain_cap = item - 1, not possible.

    # A potential function: prioritize bins where `bins_remain_cap[i]` is close to `item`.
    # We want to maximize `item - bins_remain_cap[i]` such that `bins_remain_cap[i] >= item`.
    # This is equivalent to minimizing `bins_remain_cap[i] - item` (the slack).
    # So, we can use `-(bins_remain_cap[i] - item)` as priority for valid bins.
    # Let's make the score directly represent the desirability, where higher is better.
    # This means smaller slack = higher priority.

    # A simple "almost full" priority could be `bins_remain_cap - item` where this difference is small.
    # For bins that *can* fit the item, a good priority would be high when the remaining capacity
    # after placing the item is minimized.
    # So, we want to maximize the value `M - (bins_remain_cap[i] - item)` where M is a large constant.
    # Or, simply use `- (bins_remain_cap[i] - item)` for valid bins and assign 0 to invalid bins.
    # To ensure higher means better, we can take the negative of this quantity.
    # If bins_remain_cap[i] - item = 0, priority is 0.
    # If bins_remain_cap[i] - item = 1, priority is -1.
    # If bins_remain_cap[i] - item = 5, priority is -5.

    # Let's try a different approach: we want bins with the smallest `bins_remain_cap[i]`
    # that is still greater than or equal to `item`.
    # So, sort by `bins_remain_cap[i]` and pick the first valid one.
    # This requires sorting and then picking. The priority function should assign a score to *each* bin.

    # Let's try a score that reflects "how close it is to being full with the item".
    # Consider the remaining capacity after placing the item: `bins_remain_cap[i] - item`.
    # We want this to be small and positive.
    # Priority score: A high score for small positive `bins_remain_cap[i] - item`.
    # If `bins_remain_cap[i] < item`, priority is 0.
    # For `bins_remain_cap[i] >= item`:
    # Let's try a score like: `1 / (1 + (bins_remain_cap[i] - item))`
    # If slack is 0, score is 1.
    # If slack is 1, score is 1/2.
    # If slack is 5, score is 1/6.
    # This gives higher scores for smaller slacks.

    # Apply the rule: only consider bins that can accommodate the item.
    # For these bins, compute the priority based on minimum remaining capacity after placement.
    # Let's use a scoring mechanism that penalizes large remaining capacities.
    # We want to maximize `some_large_value - (bins_remain_cap[i] - item)` for valid bins.
    # A simpler form is just `-(bins_remain_cap[i] - item)`, where higher values are better (less negative).
    # This means a slack of 0 gives priority 0, slack of 1 gives -1, etc.

    # Let's refine: We want to select a bin that, after placing the item, has the *least* remaining capacity,
    # but it must be non-negative.
    # So, for bins where `bins_remain_cap[i] >= item`:
    # Priority is related to `bins_remain_cap[i] - item`. We want to *minimize* this value.
    # If we want a higher score for better bins, we can use `-(bins_remain_cap[i] - item)`.
    # This way, a slack of 0 yields a priority of 0, and larger slacks yield more negative priorities.
    # Bins that cannot accommodate the item should have a priority of 0 or a very low negative number.

    # Let's try a score that directly measures how "almost full" it is relative to the item.
    # If bin_capacity = item, it's perfectly full. If bin_capacity = item + k, it has k space left.
    # We want to prioritize bins with k = 0, then k = 1, etc.
    # So, we want to maximize the negative of the slack.
    # `priority = -(bins_remain_cap[i] - item)`
    # For invalid bins (`bins_remain_cap[i] < item`), the priority should be very low, effectively making them undesirable.

    # Create scores for all bins.
    # Initialize all priorities to a very low value (e.g., negative infinity) to indicate unsuitability.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Find bins that can fit the item.
    valid_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(valid_bins_indices) > 0:
        # For valid bins, calculate the "slack" or remaining capacity after placing the item.
        slack = bins_remain_cap[valid_bins_indices] - item

        # We want to prioritize bins with the smallest non-negative slack.
        # A score of 0 for zero slack, -1 for slack of 1, -2 for slack of 2, etc.
        # This can be achieved by `priority = -slack`.
        # To make sure positive values are handled well or to avoid negative priorities if all are invalid:
        # Let's transform the slack. We want to maximize `C - slack` for some constant C.
        # A simple mapping: higher value for smaller slack.
        # Let's use a score that is higher for smaller slack.
        # `priorities[valid_bins_indices] = -slack`
        # Or, a value that is closer to zero for better fits.
        # Consider the capacity ratio: `item / bins_remain_cap[i]`.
        # This is good for First Fit Decreasing, not so much for "almost full".

        # Let's stick to minimizing `bins_remain_cap[i] - item`.
        # Priority = `k - (bins_remain_cap[i] - item)` for some large k.
        # A simpler approach: Assign a score that is high for small slack.
        # Example: If the bin capacity is exactly `item`, slack is 0, priority is high.
        # If the bin capacity is `item + 1`, slack is 1, priority is lower.
        # We can use a function like `1.0 / (1.0 + slack)` which maps slack 0 to 1, slack 1 to 0.5, etc.

        # Let's re-think "Almost Full Fit". It prioritizes bins that are ALMOST FULL.
        # This means bins with high `bins_remain_cap[i]` are generally good, but only if they can fit the item.
        # So, we are looking for bins where `bins_remain_cap[i]` is large, but `bins_remain_cap[i] - item` is small.
        # This suggests prioritizing bins where `bins_remain_cap[i]` is just enough.

        # A possible approach is to sort the valid bins by their remaining capacity in ascending order.
        # The first bin in this sorted list is the one with the least remaining capacity that can fit the item.
        # To represent this in a priority array:
        # Give the highest priority to this bin, then lower priorities to others.
        # However, the function needs to assign scores directly.

        # Let's try scoring based on the *difference* from the *maximum* possible remaining capacity for a valid bin.
        # This is getting complicated. Let's go back to minimizing slack.

        # The "Almost Full Fit" is essentially a form of "Best Fit".
        # For Best Fit, you want to minimize `bins_remain_cap[i] - item`.
        # So, for valid bins: `priority = - (bins_remain_cap[i] - item)`
        # This means a slack of 0 (perfect fit) gets a priority of 0.
        # A slack of 1 gets a priority of -1.
        # A slack of 5 gets a priority of -5.
        # This correctly ranks bins by having higher priority for smaller slacks.

        # Assign these priorities to the valid bins.
        priorities[valid_bins_indices] = -slack

    # Bins that could not accommodate the item (where bins_remain_cap < item)
    # already have a priority of -np.inf, which means they will never be chosen
    # if any valid bin exists.

    # To ensure the heuristic is "Almost Full Fit" and not just "Best Fit",
    # we might want to give a slight preference to bins that are "more full"
    # overall, provided they can fit the item.
    # However, the core of Best Fit and Almost Full Fit is minimizing slack.

    # Let's try to amplify the preference for smaller slacks.
    # Instead of linear `-(slack)`, use something like `1 / (1 + slack)`.
    # This maps slack=0 to 1, slack=1 to 0.5, slack=2 to 0.33, etc.
    # This is good, but what about bins that are very full but cannot fit the item?
    # Our current approach with -np.inf handles this.

    # Let's use the `1 / (1 + slack)` strategy for valid bins.
    # We need to handle the case where slack might be very small leading to large priorities.
    # Let's scale it or use a slightly different approach.

    # Another interpretation of "Almost Full Fit" could be to give priority to bins that have
    # the largest `bins_remain_cap` but *still can fit the item*.
    # This is contradictory with minimizing slack. "Almost Full" means little space left.

    # Let's consider the requirement: "bin with the highest priority score will be selected".
    # So, higher score is better.
    # For valid bins (`bins_remain_cap[i] >= item`):
    # We want to prioritize those where `bins_remain_cap[i]` is closest to `item`.
    # This means `bins_remain_cap[i] - item` should be small.
    # Let `slack = bins_remain_cap[i] - item`.
    # We want to maximize `-slack`.

    # A potential issue: if `item` is very small, and `bins_remain_cap` are all very large,
    # the `-slack` will be negative and similar for many bins.

    # Let's refine the "Almost Full Fit" concept. It's about fitting the item into a bin
    # such that the bin becomes as full as possible, without overflowing.
    # This is exactly what Best Fit does by minimizing `remaining_capacity - item_size`.

    # To make it *almost full fit* specifically, maybe we should penalize bins that are
    # already very empty, even if they can fit the item.
    # This is hard to capture in a single item-centric priority function.
    # Priority functions typically look at the state of the bin relative to the item.

    # Let's try to encode a preference for bins that have *less* total capacity remaining,
    # among those that can fit the item.
    # `priority = k - bins_remain_cap[i]` for valid bins.
    # This would favor bins with smaller remaining capacities.

    # Example: bins_remain_cap = [5, 10, 2, 7], item = 3
    # Valid bins: indices 0, 1, 3. Capacities: 5, 10, 7.
    # Slack: 5-3=2, 10-3=7, 7-3=4.
    # Priorities from `-slack`: [-2, -7, -4]
    # With `-np.inf` for bin 2: [-2, -7, -np.inf, -4]
    # The highest priority is -2, corresponding to bin 0 (remaining cap 5, slack 2).

    # What if we use `1 / (slack + epsilon)` for slack > 0, and a very high value for slack = 0?
    # `epsilon` is to prevent division by zero.

    # Let's consider the range of possible remaining capacities.
    # Suppose max_bin_capacity is 10.
    # bins_remain_cap = [3, 7, 10], item = 2
    # Valid bins: all of them.
    # Capacities: 3, 7, 10.
    # Slacks: 1, 5, 8.
    # Priorities `-slack`: [-1, -5, -8].
    # Highest priority is -1 for bin with remaining capacity 3. This is the "almost full" fit.

    # Let's make the "almost full" aspect more pronounced.
    # We are looking for `bins_remain_cap[i]` that is just above `item`.
    # So, `bins_remain_cap[i]` should be as small as possible while being `>= item`.
    # Consider priority = `bins_remain_cap[i]`. Among valid bins, this favors those with smaller remaining capacity.
    # If we want higher score for better fit, we should minimize `bins_remain_cap[i]`.
    # So, the priority should be *inversely* related to `bins_remain_cap[i]`.
    # This feels wrong. "Almost Full" implies the bin itself is almost full, i.e., `bins_remain_cap[i]` is small.

    # The most straightforward interpretation of "Almost Full Fit" for a given item
    # is to place the item into the bin that will leave the *least* amount of free space
    # in that bin after placement, provided the item fits.
    # This is precisely the "Best Fit" heuristic.

    # Let's implement "Best Fit" behavior for the priority function, which should
    # align with "Almost Full Fit" for a given item.

    # For valid bins, we want to maximize `-(bins_remain_cap[i] - item)`.
    # This means we want to minimize `bins_remain_cap[i] - item` (the slack).
    # Let `best_fit_score = -(bins_remain_cap[i] - item)`.
    # Higher value means better fit (smaller slack).

    # Initialize priorities to a very low value, so invalid bins are not chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Find indices of bins that can accommodate the item.
    can_fit_mask = bins_remain_cap >= item
    fitting_bin_indices = np.where(can_fit_mask)[0]

    if len(fitting_bin_indices) > 0:
        # Calculate the remaining capacity in these bins *after* placing the item.
        # This is the 'slack'. We want to minimize this slack.
        slacks = bins_remain_cap[fitting_bin_indices] - item

        # To create a priority score where higher is better, and smaller slacks are better:
        # We can use `-slacks`. A slack of 0 becomes priority 0. A slack of 1 becomes -1.
        # A larger positive slack becomes a larger negative priority.
        priorities[fitting_bin_indices] = -slacks

        # Alternative scoring to make the difference more pronounced or non-negative:
        # Let `max_slack = np.max(slacks)` if slacks exist.
        # `priorities[fitting_bin_indices] = max_slack - slacks`
        # This way, the best fit (smallest slack) gets `max_slack - min_slack`.
        # Example: slacks = [0, 2, 5]. max_slack = 5.
        # Scores: 5-0=5, 5-2=3, 5-5=0. Higher score is better.
        # This seems like a good interpretation of "almost full fit" within the context of best-fit strategy.

        # Let's try the `max_slack - slacks` approach.
        # If all slacks are 0, then max_slack - slacks will be 0 for all.
        # This is fine. The selection might be arbitrary among identical highest priorities.

        if len(slacks) > 0:
            max_possible_slack = np.max(slacks)
            priorities[fitting_bin_indices] = max_possible_slack - slacks

    # If no bins can fit the item, priorities remain -np.inf, indicating no solution.
    return priorities
```
