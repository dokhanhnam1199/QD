```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    The Exact Fit First strategy prioritizes bins that can accommodate the item
    with the least remaining capacity after packing. This aims to "fill" bins
    as much as possible before opening new ones.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value (or negative infinity)
    # to indicate that bins that cannot fit the item should have no priority.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can fit the current item
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity
    # if the item were placed in them. We want to find the bin where
    # remaining_capacity - item is minimized (i.e., closest to zero).
    # A higher priority is given to bins with smaller remaining capacity
    # *after* the item is placed.
    # So, priority is inversely related to (bins_remain_cap - item).
    # Maximizing (bins_remain_cap - item) would mean we prefer bins with more space left.
    # We want to minimize (bins_remain_cap - item), which means we prefer bins
    # that are a "tight fit". Therefore, we want to maximize the *negative*
    # of the remaining capacity after placement.
    # The score for a fitting bin will be -(bins_remain_cap - item).
    # The highest score will be for the smallest (bins_remain_cap - item).

    # Calculate the potential remaining capacity if the item fits
    potential_remaining_cap = bins_remain_cap[fit_mask] - item

    # Assign priorities: The higher the priority, the "better" the fit.
    # A perfect fit (remaining_capacity == item) would result in a score of 0.
    # A slightly larger remaining capacity would result in a negative score.
    # We want to maximize this score, meaning we prefer scores closer to 0.
    # Thus, we want to maximize -(bins_remain_cap[fit_mask] - item).
    priorities[fit_mask] = -potential_remaining_cap

    return priorities
```
