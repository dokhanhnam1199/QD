```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    The Epsilon-Greedy strategy balances exploration (trying less optimal bins)
    and exploitation (choosing the seemingly best bin).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Probability of exploration
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # Identify feasible bins (bins that can fit the item)
    feasible_bins_indices = np.where(bins_remain_cap >= item)[0]

    if len(feasible_bins_indices) == 0:
        # If no bin can fit the item, return all zeros (or handle as an error/new bin case)
        return np.zeros(num_bins)

    # Calculate exploitation scores: remaining capacity after packing the item
    # A smaller remaining capacity is better (greedy choice for minimal wasted space)
    exploitation_scores = bins_remain_cap[feasible_bins_indices] - item

    # We want higher priority for bins that leave less remaining capacity.
    # So, we'll invert the exploitation scores. A simple inversion might be
    # to subtract from a large number or take the negative.
    # Let's use the negative of the remaining capacity for simplicity.
    # Higher (less negative) values are preferred.
    exploitation_priorities = -exploitation_scores

    # Normalize exploitation priorities to be in a comparable range, e.g., [0, 1]
    # Handle the case where all exploitation priorities are the same to avoid division by zero.
    min_score = np.min(exploitation_priorities)
    max_score = np.max(exploitation_priorities)
    if max_score == min_score:
        normalized_exploitation_priorities = np.ones(len(exploitation_priorities)) * 0.5
    else:
        normalized_exploitation_priorities = (exploitation_priorities - min_score) / (max_score - min_score)

    # Epsilon-Greedy logic:
    # With probability epsilon, choose a random feasible bin (exploration).
    # With probability 1-epsilon, choose the bin with the best exploitation priority.

    # Generate random numbers for each feasible bin
    random_values = np.random.rand(len(feasible_bins_indices))

    # Decide for each bin whether to explore or exploit
    explore_mask = random_values < epsilon

    # Initialize exploration priorities (uniform across feasible bins)
    exploration_priorities = np.ones(len(feasible_bins_indices)) * 0.5 # Arbitrary moderate exploration value

    # Combine exploration and exploitation
    combined_priorities = np.where(
        explore_mask,
        exploration_priorities,
        normalized_exploitation_priorities
    )

    # Assign the combined priorities to the overall priorities array
    priorities[feasible_bins_indices] = combined_priorities

    return priorities
```
