```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    The Best Fit strategy prioritizes bins that have just enough capacity to fit the item.
    A perfect fit (remaining capacity exactly equals item size) gets the highest priority.
    Bins with less capacity than the item are given a priority of 0, as they cannot
    accommodate the item. Other bins are assigned a priority based on how close their
    remaining capacity is to the item size, favoring bins that leave less remaining
    space after packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after packing the item
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # Prioritize bins that are a perfect fit (remaining capacity is 0)
    # Assign a high priority to perfect fits to encourage minimizing wasted space
    perfect_fit_mask = remaining_after_fit == 0
    priorities[can_fit_mask][perfect_fit_mask] = 100  # High priority for perfect fit

    # For bins that are not a perfect fit, prioritize those that leave less remaining space.
    # We use the negative of the remaining space as a score, so smaller (less negative)
    # values are preferred, meaning less wasted space.
    non_perfect_fit_mask = ~perfect_fit_mask
    priorities[can_fit_mask][non_perfect_fit_mask] = -remaining_after_fit[non_perfect_fit_mask]

    # Normalize priorities to avoid extremely large negative numbers if needed,
    # or scale them in some way. For now, direct negative is fine for comparison.
    # If further scaling is desired, consider:
    # priorities[can_fit_mask][non_perfect_fit_mask] = np.clip(priorities[can_fit_mask][non_perfect_fit_mask], -1e6, 0)
    # Or a min-max scaling on the non-perfect fits.

    return priorities
```
