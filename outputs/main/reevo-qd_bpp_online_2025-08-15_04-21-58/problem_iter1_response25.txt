```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).

    The priority is higher for bins that have just enough space for the item,
    encouraging tighter packing. A small epsilon is added to the denominator
    to avoid division by zero for full bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the difference between remaining capacity and item size
    # This represents how much "slack" or remaining space there will be.
    slack = bins_remain_cap - item

    # Prioritize bins where the slack is zero or very small (good fit).
    # Using inverse of slack (plus a small epsilon to avoid division by zero)
    # ensures that bins with less slack get higher priority.
    # We only consider bins that can actually fit the item.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit the item, calculate priority as 1 / (slack + epsilon)
    # A smaller slack (closer to 0) means higher priority.
    # If slack is exactly 0, the priority is very high.
    # A very large slack means a low priority.
    epsilon = 1e-6  # Small constant to avoid division by zero
    priorities[can_fit_mask] = 1.0 / (slack[can_fit_mask] + epsilon)

    return priorities
```
