```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an Epsilon-Greedy strategy.

    The strategy balances exploring new bins with exploiting good bins.
    A random bin is chosen with probability epsilon, otherwise, the bin that
    best fits the item is chosen.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        The highest score indicates the preferred bin.
    """
    epsilon = 0.1  # Probability of exploring a random bin
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Check if the item can fit into any of the bins
    can_fit = bins_remain_cap >= item

    # If the item can fit into any bin
    if np.any(can_fit):
        # Epsilon-greedy: with probability epsilon, choose a random bin it can fit into
        if np.random.rand() < epsilon:
            possible_bins_indices = np.where(can_fit)[0]
            chosen_bin_index = np.random.choice(possible_bins_indices)
            priorities[chosen_bin_index] = 1.0  # Give highest priority to the randomly chosen bin
        else:
            # Otherwise, exploit by choosing the bin that best fits the item (minimum remaining capacity after packing)
            # Filter bins that can fit the item
            valid_bins_remain_cap = bins_remain_cap[can_fit]
            # Calculate the remaining capacity if the item is placed in each valid bin
            remaining_capacities_after_packing = valid_bins_remain_cap - item
            # Find the bin with the smallest remaining capacity (best fit)
            best_fit_bin_index_relative = np.argmin(remaining_capacities_after_packing)
            # Get the actual index in the original bins_remain_cap array
            best_fit_bin_index_absolute = np.where(can_fit)[0][best_fit_bin_index_relative]
            priorities[best_fit_bin_index_absolute] = 1.0 # Give highest priority to the best fit bin
    else:
        # If the item cannot fit into any existing bin, it needs a new bin.
        # This heuristic might still try to distribute some "chance" across all bins
        # to explore options, but in a practical scenario, a new bin would be opened.
        # For the purpose of returning priorities for existing bins, we can assign
        # a low or zero priority, or perhaps a small exploration value if there's
        # a notion of "future potential" for a bin to be useful.
        # Here, we'll assign a small uniform priority to indicate exploration
        # across all bins, as no bin currently can accommodate it.
        if num_bins > 0:
            priorities = np.ones_like(bins_remain_cap) * (epsilon / num_bins)
        # If there are no bins, this function won't be called in a way that makes sense
        # for selecting an existing bin.

    return priorities
```
