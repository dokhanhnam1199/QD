```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    The Exact Fit First strategy prioritizes bins that can perfectly fit the item.
    Among bins that can perfectly fit, it further prioritizes bins that will have
    the least remaining capacity after the item is placed (Best Fit). If no bin
    can perfectly fit the item, it falls back to a Best Fit approach for all
    available bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can exactly fit the item
    exact_fit_mask = (bins_remain_cap == item)

    if np.any(exact_fit_mask):
        # For exact fits, give a high priority (e.g., 1.0)
        priorities[exact_fit_mask] = 1.0

        # Among exact fits, prioritize those with the least remaining capacity
        # after placing the item (which means the bin had capacity equal to item).
        # This sub-priority might seem redundant with exact fit, but conceptually,
        # it's part of the Exact Fit First idea if we consider ties. Here, we'll
        # assign a secondary priority to make the ordering clear, but a simple 1.0
        # is usually sufficient for exact fits themselves. For this implementation,
        # let's assign a slightly higher score to the 'most exact' fit which is
        # the bin that will have 0 remaining capacity.
        # However, since we already marked them with 1.0, and the problem implies
        # we want to pick ONE, we need a way to differentiate. A simple way is
        # to assign a slightly higher value or a rank.
        # Let's refine: if multiple bins *exactly* fit, we'll prioritize the one
        # that leaves *least* remaining capacity (which is zero remaining capacity).
        # Since all exact fits have 0 remaining capacity after placement, this means
        # we'll give all exact fits the same high priority. To differentiate,
        # we can add a small bonus based on how much capacity is left in *other*
        # bins to ensure we don't pick a bin that was ALMOST an exact fit but slightly
        # larger.

        # Let's rethink the priority score assignment to ensure distinctness if needed.
        # A good strategy is to prioritize exact fits FIRST. If multiple exact fits,
        # we need a tie-breaker. The "least remaining capacity" after placing the item
        # is the same for all exact fits (0). So, a simple approach is:
        # 1. High score for exact fits.
        # 2. For bins that don't exactly fit, assign a score based on how close they are
        #    to fitting the item (Best Fit aspect). The smaller the remaining capacity
        #    after placing the item (but still positive), the higher the priority.

        # Let's try a scoring mechanism:
        # Exact fits: highest score.
        # Non-exact fits: score based on remaining capacity after placement, inverted.
        # The remaining capacity *after* placement would be `bin_remain_cap - item`.
        # We want smaller positive remaining capacities to be higher priority.
        # So, a good heuristic is `1 / (bin_remain_cap - item + epsilon)` for valid fits.

        # Let's create a new priority array to avoid modifying the original 'priorities'
        # in a way that breaks logic.
        scores = np.full_like(bins_remain_cap, -np.inf, dtype=float) # Initialize with very low scores

        # Case 1: Exact Fits
        can_fit_exact_mask = (bins_remain_cap == item)
        if np.any(can_fit_exact_mask):
            # Assign a high score for exact fits. For tie-breaking within exact fits,
            # we can slightly vary the score. For simplicity, let's give them all
            # the highest possible score.
            scores[can_fit_exact_mask] = 1.0 # High priority for exact fits

        # Case 2: Bins that can fit the item but not exactly
        can_fit_mask = (bins_remain_cap > item)
        if np.any(can_fit_mask):
            remaining_after_fit = bins_remain_cap[can_fit_mask] - item
            # Prioritize bins that leave minimum remaining capacity (Best Fit)
            # We want smaller `remaining_after_fit` to have higher scores.
            # A common way is to use `1 / (remaining_after_fit + epsilon)`.
            # We need to ensure these scores are lower than exact fits but higher than non-fits.
            # Let's assign scores in a range below 1.0.
            # Normalize remaining capacity to a small range, e.g., [0.1, 0.9]
            # This part needs careful scaling. A simpler approach for now:
            # Higher score for smaller `remaining_after_fit`.
            # Let's assign a score that is a function of the remaining capacity.
            # A large positive value for small remaining capacity.
            # For example, map remaining capacities to scores between 0 and 0.9.
            # Max possible remaining capacity (assuming bin size B) is B-item.
            # Smallest is 0 (for exact fit, handled above).
            # If max bin size is, say, 1.0 and item is 0.3, remaining capacity can be up to 0.7.
            # A simple scoring: score = 1 - (remaining_capacity / max_possible_remaining)
            # This would give priority to bins that are almost full.
            # Let's map remaining capacity `r` to score `1 - r` for `r > 0`.
            # We can also use `1 / (r + 1)` to avoid division by zero and give higher scores for smaller r.

            # Let's try assigning scores based on the *remaining capacity after placement*.
            # For bins `i` where `bins_remain_cap[i] > item`:
            #   The capacity *after* placing the item is `bins_remain_cap[i] - item`.
            #   We want to prioritize bins where this value is smallest.
            #   Let's assign a priority based on this residual capacity: `score = 1.0 - (bins_remain_cap[i] - item)`
            #   This might be problematic if capacities are very small or very large.
            #   A more robust way is `1 / (bins_remain_cap[i] - item + epsilon)` or
            #   a linear mapping.

            # Let's simplify: give a score proportional to `1.0 - item/bins_remain_cap[i]`.
            # This prioritizes bins that are 'more full' relative to their capacity, after fitting the item.
            # Or, simply prioritize smaller `bins_remain_cap[i] - item`.
            # Let's assign a score that is decreasing with `bins_remain_cap[i] - item`.
            # For example, `max_residual_capacity - (bins_remain_cap[i] - item)`
            # If all bins have a uniform maximum capacity `MAX_CAP`, then `max_residual_capacity` is `MAX_CAP - item`.
            # This isn't directly available.

            # Alternative: Score based on closeness to exact fit without exceeding.
            # For bins `i` where `bins_remain_cap[i] >= item`:
            #   Score = `bins_remain_cap[i]` itself.
            #   This prioritizes bins that are slightly larger than the item.
            #   This seems to capture the "Exact Fit First, then Best Fit" idea well.
            #   Exact fits will have `bins_remain_cap[i] = item`.

            # Let's try this approach:
            # Priority = `bins_remain_cap[i]` for bins where `bins_remain_cap[i] >= item`.
            # Among these, exact fits (`bins_remain_cap[i] == item`) will have the lowest priority if we use this directly.
            # This means we need to combine: exact fit gets highest priority.

            # Refined approach:
            # 1. Score for exact fits: a very high value (e.g., 1.0 + a tie-breaker if needed).
            # 2. Score for bins that can fit (`bins_remain_cap[i] > item`): prioritize those with smallest `bins_remain_cap[i]`.
            #    So, score proportional to `1 / bins_remain_cap[i]`.
            # 3. Bins that cannot fit (`bins_remain_cap[i] < item`): score of 0.

            # Let's use a multi-tiered scoring:
            # Tier 1: Exact fits (score = 2.0)
            # Tier 2: Can fit, but not exactly (score = 1.0 - (bins_remain_cap - item)) scaled appropriately.
            #         To ensure scores are less than 2.0, maybe scale by a factor of 0.5 or something similar.
            #         A simple way: `1.5 - (bins_remain_cap[i] - item)` and ensure it's <= 1.5.
            #         A better way: `1.0 + (max_capacity - bins_remain_cap[i]) / max_capacity`
            #         Let's stick to a simple linear scaling: assign score `1 - (bins_remain_cap[i] - item)`

            # Let's reconsider the core Exact Fit First strategy:
            # 1. Find all bins where `bins_remain_cap == item`.
            # 2. If any such bins exist, pick one of them (often the first one found or a Best Fit among them).
            # 3. If no exact fit exists, find all bins where `bins_remain_cap > item`.
            # 4. Among these, pick the one with the smallest `bins_remain_cap` (Best Fit).
            # 5. If no bin can fit, this item cannot be placed.

            # We need to translate this selection logic into priority scores.
            # The bin with the highest score should be selected.

            # Strategy:
            # Assign score = 2.0 to bins where `bins_remain_cap == item`.
            # Assign score = 1.0 - (bins_remain_cap - item) to bins where `bins_remain_cap > item`.
            # Assign score = 0.0 to bins where `bins_remain_cap < item`.

            # The range of `bins_remain_cap - item` needs consideration for scaling.
            # If `bins_remain_cap` can be very large, `1.0 - (large_value)` becomes negative.
            # We want scores for "can fit" bins to be between 0 and 1, lower than exact fits (2.0).
            # Best Fit means smallest positive `bins_remain_cap - item`.
            # So, score should be inversely related to `bins_remain_cap - item`.
            # Let `residual = bins_remain_cap - item`. For `residual > 0`.
            # Score = `1.0 / (residual + epsilon)`. Need to scale this to be < 2.0.

            # Let's try:
            # Priority = 2.0 for exact fits.
            # Priority = 1.0 + (MAX_CAP - bins_remain_cap) / MAX_CAP for bins that can fit but not exactly.
            # MAX_CAP is not known. Assume a large upper bound or use the maximum of existing bin capacities as a reference.
            # Or simply `1.0 / (bins_remain_cap - item)` for bins that can fit.

            # Let's simplify the priority assignment. We want to make sure exact fits are chosen.
            # If multiple exact fits, the specific heuristic would matter (e.g., which *exact* fit).
            # For Exact Fit First, any exact fit is preferred over any non-exact fit.

            # Let's make scores clearly hierarchical:
            # Score = 2 for exact fits.
            # Score = 1 for bins that can fit, prioritized by smallest capacity.
            # Score = 0 for bins that cannot fit.

            # Implementation:
            # Initialize all priorities to 0.
            priorities = np.zeros_like(bins_remain_cap, dtype=float)

            # Identify bins that can fit the item (including exact fits).
            can_fit_mask = (bins_remain_cap >= item)
            fitting_bins_capacities = bins_remain_cap[can_fit_mask]

            # If there are bins that can fit:
            if np.any(can_fit_mask):
                # Separate exact fits and near fits.
                exact_fit_mask_local = (fitting_bins_capacities == item)
                near_fit_mask_local = (fitting_bins_capacities > item)

                # Assign scores to the original array indices corresponding to these bins.
                # High priority for exact fits.
                exact_fit_indices = np.where(can_fit_mask)[0][exact_fit_mask_local]
                priorities[exact_fit_indices] = 2.0

                # For bins that can fit but not exactly, use Best Fit principle.
                # The lower the `bins_remain_cap`, the higher the priority among these.
                # Assign a score based on the remaining capacity after fitting the item.
                # Smaller `bins_remain_cap - item` should yield higher priority.
                # We want scores between 1.0 and 2.0 (but strictly less than 2.0).
                # Let's use a score of `1.0 + (max_capacity_minus_item - (bin_cap - item)) / max_capacity_minus_item`
                # This normalizes the residual capacity.
                # If no exact fits, max remaining capacity is `max(fitting_bins_capacities)`.
                # A simpler score: `1.0 - (bins_remain_cap[i] - item) / SOME_MAX_POSITIVE_DIFFERENCE`.
                # Let's try `1.0 - (bins_remain_cap[i] - item) * SCALING_FACTOR` where SCALING_FACTOR is small.

                # A robust way is to assign priority based on the rank.
                # For bins that can fit:
                # If exact fits exist, they get the highest rank.
                # If no exact fits, the one with smallest `bins_remain_cap` gets highest rank among these.

                # Let's use this scoring scheme:
                # Exact fits: 2.0
                # Non-exact fits: 1.0 / (bins_remain_cap - item + 1e-9)
                # This will give very high scores to near fits if the residual is tiny.
                # We need to scale this down so it's less than 2.0.

                # Let's try a simple approach:
                # - Exact fits get priority 1.
                # - Bins that can fit, ordered by `bins_remain_cap`: prioritize smaller `bins_remain_cap`.
                #   Score = `1 / (bins_remain_cap[i])`.
                # This would rank exact fits lower than bins that are almost full.

                # Correct interpretation of Exact Fit First:
                # The MOST preferred bin is one that EXACTLY fits.
                # If multiple EXACT fits, any of them is fine, or a tie-breaker like Best Fit among exact fits.
                # If NO EXACT fit, then the BEST FIT (smallest capacity > item) is preferred.

                # Final Proposed Logic for Scores:
                # 1. Bins where `bins_remain_cap == item`: Assign highest priority score (e.g., 2.0).
                # 2. Bins where `bins_remain_cap > item`: Assign a secondary priority score.
                #    Among these, pick the one with the smallest `bins_remain_cap`.
                #    So, a score inversely proportional to `bins_remain_cap`. For example, `1.0 / bins_remain_cap`.
                #    These scores should be lower than the exact fit scores.
                # 3. Bins where `bins_remain_cap < item`: Assign lowest priority (0.0).

                # Combine:
                # For bins `i` where `bins_remain_cap[i] >= item`:
                #   If `bins_remain_cap[i] == item`: score = 2.0
                #   If `bins_remain_cap[i] > item`: score = 1.0 / bins_remain_cap[i] (ensure scaling is appropriate)
                #      We want smaller `bins_remain_cap` to have higher scores in this category.
                #      So, `1.0 / bins_remain_cap[i]` works. To make them distinct from 2.0,
                #      let's adjust the range.
                #      If `bins_remain_cap` can be very large, `1/bins_remain_cap` will be very small.
                #      Let's use `1.0 - (bins_remain_cap[i] - item) / MAX_POSITIVE_DIFFERENCE`.
                #      If max possible bin capacity is `B_MAX`, then `MAX_POSITIVE_DIFFERENCE` could be `B_MAX - item`.

                # Let's use a simple score assignment to achieve the ranking:
                # Score = 2.0 for exact fits.
                # Score = 1.0 for bins that can fit, prioritizing smaller capacities.
                # If `bins_remain_cap` values are relatively close, `1.0 - bins_remain_cap[i]/MaxCap` could work.
                # Or simply `1.0 / bins_remain_cap[i]`. If `bins_remain_cap[i]` ranges from 0.1 to 1.0,
                # `1.0/0.1 = 10`, `1.0/1.0 = 1`. This is good for Best Fit.
                # We need these scores to be < 2.0.

                # Let's set a maximum possible bin capacity for scaling if not provided.
                # Assume max possible bin capacity is `max_overall_capacity`.
                # Let's consider the maximum remaining capacity among bins that can fit.
                # This is still tricky without knowing the universe of capacities.

                # Simpler approach: Use relative priorities.
                # Rank 0: Exact fits.
                # Rank 1: Best fit among non-exact fits.
                # Rank 2: Cannot fit.

                # Translate ranks to scores:
                # Priority = 2.0 for exact fits.
                # For bins that can fit but not exactly: Assign a score based on their ranking.
                # The bin with the smallest `bins_remain_cap` gets the highest score in this group.
                # Example: if the smallest fitting capacity is 0.6 and the item is 0.5, it's a 0.1 residual.
                # Another fitting capacity is 0.8, item 0.5, residual 0.3. We prefer 0.6.
                # Score = `1.0 - (bins_remain_cap[i] - item)`:
                # If bins_remain_cap = [0.5, 0.6, 0.8], item = 0.5
                # Exact fits: bin 0 (score 2.0)
                # Non-exact fits: bin 1 (0.6), bin 2 (0.8)
                # For bin 1: residual = 0.1. Score = 1.0 - 0.1 = 0.9
                # For bin 2: residual = 0.3. Score = 1.0 - 0.3 = 0.7
                # This order works: 2.0 (bin 0) > 0.9 (bin 1) > 0.7 (bin 2).

                # Let's apply this logic.
                # Prioritize bins by:
                # 1. Exact fit: highest priority.
                # 2. Best Fit (smallest remaining capacity > item): next highest.
                # 3. Otherwise: 0.

                scores = np.zeros_like(bins_remain_cap, dtype=float)

                # Case 1: Exact fits
                exact_fit_mask = (bins_remain_cap == item)
                if np.any(exact_fit_mask):
                    scores[exact_fit_mask] = 2.0 # Highest priority

                # Case 2: Bins that can fit, but not exactly.
                can_fit_mask = (bins_remain_cap > item)
                fitting_bins_capacities_non_exact = bins_remain_cap[can_fit_mask]

                if np.any(can_fit_mask):
                    # These bins need to have a priority lower than 2.0 but higher than 0.0.
                    # They should be prioritized by the smallest `bins_remain_cap` value.
                    # Let's assign a score proportional to `1 / bins_remain_cap` for these.
                    # Ensure `bins_remain_cap` are not zero, which is guaranteed by `> item`.
                    # We need to scale this so it's less than 2.0 and greater than 0.
                    # A common strategy is `max_score - (value - min_value) / range_of_values`.
                    # For Best Fit, we want smaller `bins_remain_cap` to have higher scores.
                    # Score = `k * (max_cap_among_fits - bins_remain_cap)` where k is a small constant.

                    # Let's simplify the assignment for non-exact fits:
                    # Assign score = `1.0 - (bins_remain_cap[i] - item)` as a placeholder,
                    # and ensure it's scaled appropriately.
                    # If `bins_remain_cap` values are diverse, a simple subtraction can lead to negative scores.
                    # A robust way: map `bins_remain_cap` of fitting bins to [0, 1) range, with inverse order.
                    # Let `relevant_caps = bins_remain_cap[can_fit_mask]`
                    # If `relevant_caps` is not empty:
                    #   `min_cap = np.min(relevant_caps)`
                    #   `max_cap = np.max(relevant_caps)`
                    #   If `min_cap == max_cap`: all fitting bins have the same capacity. Assign 1.0.
                    #   Else: score = `1.0 - (bins_remain_cap[i] - min_cap) / (max_cap - min_cap)`
                    #   This maps `min_cap` to 1.0 and `max_cap` to 0.0.
                    #   These scores would be in [0.0, 1.0], perfectly below the 2.0 for exact fits.

                    relevant_caps = bins_remain_cap[can_fit_mask]
                    min_cap_fit = np.min(relevant_caps)
                    max_cap_fit = np.max(relevant_caps)

                    indices_non_exact_fit = np.where(can_fit_mask)[0]

                    if min_cap_fit == max_cap_fit:
                        # All bins that can fit have the same capacity. Assign a uniform priority in the range.
                        scores[indices_non_exact_fit] = 1.0
                    else:
                        # Normalize scores for non-exact fits to be between 0 and 1, favoring smaller capacities.
                        # Score = `1.0 - (value - min) / (max - min)` maps min to 1.0 and max to 0.0.
                        normalized_scores_non_exact = 1.0 - (relevant_caps - min_cap_fit) / (max_cap_fit - min_cap_fit)
                        scores[indices_non_exact_fit] = normalized_scores_non_exact

                # Ensure that exact fits are indeed prioritized over non-exact fits.
                # The scores are: exact fits = 2.0, non-exact fits = in [0, 1.0].
                # This satisfies the Exact Fit First strategy.
                # If multiple exact fits, they all get 2.0. A secondary tie-breaker might be needed if strict ordering is essential among exact fits.
                # For simplicity, we return all exact fits with the same highest score.

                return scores

    # If no bin can fit the item at all, all priorities remain 0.
    return priorities
```
