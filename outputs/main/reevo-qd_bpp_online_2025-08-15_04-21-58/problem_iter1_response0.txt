```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    In the First Fit strategy, we prioritize bins that can accommodate the item
    and have the *least* remaining capacity after placing the item. This
    aims to pack items tightly, potentially leaving larger gaps in later bins
    for larger items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item get a priority of -1 (lowest).
        Bins that can fit the item get a priority based on their remaining
        capacity after packing. Higher remaining capacity after packing gets a
        lower priority (which means it's a better fit).
    """
    priorities = np.full_like(bins_remain_cap, -1.0)  # Initialize with a low priority
    
    # Find bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit the item, calculate the remaining capacity after placement
    remaining_caps_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # The priority is based on the remaining capacity after placing the item.
    # We want to minimize the remaining capacity (tightest fit), so higher
    # remaining capacity means lower priority (higher negative value).
    # We negate the remaining capacity to achieve this, as numpy.argsort
    # sorts in ascending order, and we want the smallest remaining capacity
    # to have the highest priority.
    priorities[can_fit_mask] = -remaining_caps_after_fit
    
    return priorities
```
