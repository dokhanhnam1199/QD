```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This 'Best Fit' heuristic prioritizes bins that have just enough capacity
    to fit the item. A bin is considered a good fit if its remaining capacity
    is exactly equal to the item's size. To differentiate between multiple
    exact fits, we can use a secondary criterion, such as the bin's index
    (though for a pure Best Fit, any exact fit is equally good).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # For bins that can fit the item (remaining capacity >= item size)
    # we assign a priority.
    # The best fit strategy aims to minimize the remaining capacity after packing.
    # A higher priority is given to bins where `remaining_capacity - item_size` is minimized.
    # This difference being zero (or close to zero) means the bin is a 'tight' fit.

    # Calculate the difference if the item is placed in the bin.
    # Only consider bins where the item can actually fit.
    fits = bins_remain_cap >= item

    # For bins that fit, calculate the 'slack' (remaining capacity after placing the item)
    # We want to minimize this slack. Higher priority means smaller slack.
    slack = bins_remain_cap - item

    # Assign priorities: higher priority for smaller slack.
    # We use a large constant and subtract the slack to ensure smaller slack gets higher values.
    # We also want to prioritize bins that *can* fit the item.
    # A simple way to achieve this is to set priority only for bins that fit.
    # To make it "Best Fit", we want the *smallest* non-negative slack.
    # Let's assign a very high priority to bins with exactly zero slack,
    # and progressively lower priorities for bins with positive slack.

    # Initialize all priorities to a very low value
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # For bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_slack = bins_remain_cap[can_fit_mask] - item

    # Assign priority based on slack. Smaller slack = higher priority.
    # To make slack values directly contribute to higher priority, we can
    # use a transformation like 1 / (1 + slack) for slack >= 0.
    # However, to strongly favor exact fits (slack = 0), we can assign a base
    # high priority and then reduce it based on slack.

    # Let's define a priority based on the negative slack.
    # Higher priority means smaller slack (closer to 0).
    # So, priority = -slack for bins that fit.
    priorities[can_fit_mask] = -fitting_bins_slack

    # We can also add a small bonus for being an exact fit.
    # For bins with slack exactly 0, give an additional boost.
    exact_fit_mask = can_fit_mask & (slack == 0)
    priorities[exact_fit_mask] += 1000.0 # A significant boost for exact fits

    # Alternatively, a common approach is to use the negative remaining capacity
    # itself as the primary sort key for best fit, but we need to ensure
    # the item fits first.
    # The goal is to find the bin `j` that minimizes `bins_remain_cap[j] - item`
    # among all `j` where `bins_remain_cap[j] >= item`.

    # A clearer way to represent "Best Fit" as a priority:
    # The most desirable bin is the one that, after packing the item,
    # has the *least* remaining capacity, *provided* it can fit the item.
    # So, the priority should be inversely related to `bins_remain_cap[j] - item`.
    # A negative value of `bins_remain_cap[j] - item` means the item doesn't fit.

    # Let's construct the priority so that higher values mean more preferred.
    # If an item fits, the priority is related to how little space is left.
    # A smaller `remaining_capacity - item` is better.
    # So, we can use `- (remaining_capacity - item)` as a score for bins that fit.
    # For bins that don't fit, their priority should be very low.

    priorities = np.full_like(bins_remain_cap, -np.inf) # Initialize with a very low priority

    for i, remaining_cap in enumerate(bins_remain_cap):
        if remaining_cap >= item:
            # Prioritize bins that leave the least remaining space after packing
            # We want to minimize (remaining_cap - item)
            # So, a higher priority score is given to smaller positive slack.
            # Let's use `-(remaining_cap - item)` as the score.
            # The closest `remaining_cap - item` is to 0 (from above), the higher the score.
            priorities[i] = -(remaining_cap - item)
        # If remaining_cap < item, priorities[i] remains -np.inf, correctly indicating it cannot fit.

    return priorities
```
