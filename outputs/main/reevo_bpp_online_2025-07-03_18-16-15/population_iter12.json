[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: Perfect Fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 20  # High priority for perfect fit\n\n    # Heuristic 2: Snug Fit (prioritize bins where remaining capacity is slightly larger than the item)\n    snug_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.2)\n    if np.any(snug_fit_mask):\n        slack = bins_remain_cap[snug_fit_mask] - item\n        priorities[snug_fit_mask] += 10 / (slack + 0.001)  # Smaller slack, higher priority\n\n    # Heuristic 3: Moderate Fill (reward bins that, after placing the item, have a reasonable fill level)\n    remaining_capacity = bins_remain_cap - item\n    moderate_fill_mask = (remaining_capacity >= 0) & (remaining_capacity <= max_cap * 0.8)\n    priorities[moderate_fill_mask] += 5\n\n    # Heuristic 4: Penalize Overflow (severely penalize bins that cannot fit the item)\n    overflow_mask = bins_remain_cap < item\n    priorities[overflow_mask] = -np.inf\n\n    # Heuristic 5: Penalize Fragmentation (penalize bins that, after placing the item, become almost empty)\n    fragmentation_mask = (remaining_capacity >= 0) & (remaining_capacity <= max_cap * 0.15)\n    priorities[fragmentation_mask] -= 7\n\n    # Heuristic 6: Reward Partial Fills (give a small bonus to bins that are already partially filled)\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    priorities += 1.0 * occupied_ratio\n\n    # Heuristic 7: Item-Size Dependent Adjustment: Favor bins closer to item size\n    # The larger the item, the more we want a snug fit.\n    item_ratio = item / max_cap\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        priorities[feasible_bins] += 5 * item_ratio * (1 - ((bins_remain_cap[feasible_bins] - item) / max_cap))\n\n    # Heuristic 8: Encourage using emptier bins if item is small\n    if item_ratio < 0.2:\n        empty_bin_bonus = (max_cap - bins_remain_cap) / max_cap\n        priorities += 2 * (1 - item_ratio) * empty_bin_bonus\n    return priorities",
    "response_id": 0,
    "obj": 4.876346230554457,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Non-linear priority based on slack (smaller slack -> much higher priority)\n        priorities[fit_mask] = np.exp(-5 * slack / max_cap)\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Penalize bins that become too full or too empty after insertion to avoid fragmentation\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(-15 * (remaining_capacity / max_cap)) * (remaining_capacity >= 0) # Penalize nearly full\n    too_empty_penalty = np.exp(-15 * (bins_remain_cap / max_cap)) * (remaining_capacity >= 0) * (bins_remain_cap<max_cap/2) #penalize low fill\n\n    priorities = priorities - too_full_penalty - too_empty_penalty\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled (reduces number of partially-filled bins)\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    # Non-linear bonus: more reward for bins that are moderately filled\n    bonus = 0.2 * (occupied_ratio**2) \n    priorities = priorities + bonus\n\n    #Heuristic 4: Moderate Capacity Bonus (more targeted)\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < max_cap*0.75)\n    priorities[moderate_capacity] += 0.1\n\n    #Heuristic 5: Item Size Adjustment: Scale priority boost by item size (more impactful)\n    priorities[fit_mask] *= (1 + 2 * item / max_cap)\n\n    return priorities",
    "response_id": 1,
    "obj": 9.842441164738737,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tighter Slack Penalization and Item Size Adjustment\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Exponential penalization of slack, scaled by item size\n        priorities[fit_mask] = np.exp(-50 * slack / bin_capacity) * (1 + 0.6 * item / bin_capacity)  # Tighter slack, higher item influence\n    else:\n        priorities[:] = -np.inf  # Cannot fit\n\n    # 2. Refined Fill Thresholds and Penalties\n    remaining_capacity = bins_remain_cap - item\n    nearly_full_penalty = np.exp(-20 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0) # even stronger penalty when close to being full\n    nearly_empty_penalty = np.exp(-7 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap > 0) * (bins_remain_cap > (2 * item)) # slightly stronger penalty for being nearly empty\n    priorities -= nearly_full_penalty + nearly_empty_penalty\n\n    # 3. Direct Occupancy Reward\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.3 * occupied_ratio # stronger bonus\n    priorities += bonus\n\n    # 4. Moderate Occupancy Preference\n    moderate_occupancy = np.logical_and(remaining_capacity/bin_capacity > 0.25, remaining_capacity/bin_capacity < 0.75) & (remaining_capacity >= 0)\n    priorities[moderate_occupancy] += 0.1 # stronger preference for this range\n\n    # 5. Larger Item, Larger Bin Preference (refined)\n    priorities[fit_mask] *= (1 + 0.2 * item / bin_capacity) # increase influence for large item\n\n    return priorities",
    "response_id": 2,
    "obj": 1.4858396489828571,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n        priorities[fit_mask] *= (1 + item / bin_capacity)  # Item size scaling\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Penalize bins that become too full or too empty after insertion to avoid fragmentation\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(10 * (remaining_capacity[remaining_capacity>=0] / bin_capacity - 0.1))\n    priorities[remaining_capacity>=0] -= too_full_penalty # Penalize nearly full\n    too_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap<bin_capacity/2) #penalize low fill\n\n\n    priorities[remaining_capacity>=0] -= too_empty_penalty\n\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled (reduces number of partially-filled bins)\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.1 * occupied_ratio\n    priorities = priorities + bonus\n\n    # Heuristic 4: Moderate Capacity Bonus\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < bin_capacity * 0.75)\n    priorities[moderate_capacity] += 0.05\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tight Fit Priority\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n        priorities[fit_mask] *= (1 + item / bin_capacity)  # Scale by item size. Big item prefers less slack\n    else:\n        priorities[:] = -np.inf  # Item cannot fit; force new bin\n\n    # 2. Penalize Extreme Fills Sharply and exponentially\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(10 * (remaining_capacity / bin_capacity - 0.1)) * (remaining_capacity >= 0) * (remaining_capacity < bin_capacity * 0.1) # only penalize bins near full\n    too_empty_penalty = np.exp(-10 * (bins_remain_cap / bin_capacity + 0.1)) * (remaining_capacity >= 0) * (bins_remain_cap > bin_capacity * 0.9) # only penalize bins near empty\n\n    priorities -= (too_full_penalty + too_empty_penalty)\n\n    # 3. Reward Moderate Occupancy with Bonuses\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    moderate_capacity_bonus = 0.2 * occupied_ratio * (occupied_ratio < 0.8) # scale bonus according to occupied ratio and truncate\n    priorities += moderate_capacity_bonus\n\n    # 4. Added encouragement for bins that are already significantly filled\n    filled_threshold = 0.3 * bin_capacity\n    already_filled = (bin_capacity - bins_remain_cap) > filled_threshold\n    priorities[already_filled] += 0.1\n\n    # 5. Reward bins that has capacity greater than item and is closest to half full\n    half_full = np.logical_and(bins_remain_cap >= item, np.abs(bins_remain_cap - bin_capacity/2) == np.min(np.abs(bins_remain_cap[bins_remain_cap >= item] - bin_capacity/2)) )\n\n    priorities[half_full] += 0.15\n\n\n    return priorities",
    "response_id": 4,
    "obj": 3.3905065815716,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior (Snug Fit)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n\n        # Scale snug fit reward based on item size and remaining capacity\n        priorities[fit_mask] *= (1 + item / bin_capacity)\n    else:\n        priorities[:] = -np.inf  # Item cannot fit, force new bin\n\n    # Heuristic 2: Sharply Penalize Fragmentation (Exponentially)\n    remaining_capacity = bins_remain_cap - item\n    \n    # Calculate penalties only for bins where the item can fit\n    fragmentation_penalty_mask = remaining_capacity >= 0\n\n    if np.any(fragmentation_penalty_mask):\n        remaining_capacity_norm = remaining_capacity[fragmentation_penalty_mask] / bin_capacity\n\n        # Sharply penalize bins that become too full\n        too_full_penalty = np.zeros_like(bins_remain_cap)\n        too_full_penalty[fragmentation_penalty_mask] = np.exp(10 * (remaining_capacity_norm - 0.1)) * (remaining_capacity_norm <= 0.1)\n        priorities -= too_full_penalty\n        \n        # Sharply penalize bins that become too empty (fragmented)\n        too_empty_penalty = np.zeros_like(bins_remain_cap)\n        too_empty_penalty[fragmentation_penalty_mask] = np.exp(-10 * (bins_remain_cap[fragmentation_penalty_mask] / bin_capacity)) * (bins_remain_cap[fragmentation_penalty_mask] > bin_capacity * 0.7)\n        priorities -= too_empty_penalty\n\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.1 * occupied_ratio\n    priorities += bonus\n\n    # Heuristic 4: Moderate Capacity Bonus (balance fill)\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < bin_capacity * 0.75)\n    priorities[moderate_capacity] += 0.05\n\n    return priorities",
    "response_id": 5,
    "obj": 3.9090546469884373,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0\n\n    # 1. Feasibility Check and Slack Minimization:\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] = 10.0 / (slack + 1e-6)  # Higher priority for smaller slack\n\n    # 2. Fragmentation Control: Penalize excessive remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    frag_mask = (remaining_capacity > 0) & (remaining_capacity > 0.7 * max_cap)\n    priorities[frag_mask] -= 0.5 * (remaining_capacity[frag_mask] / max_cap) # Scale penalty by fragmentation level\n\n    # 3. Fill Level Optimization: Reward bins with good fill levels\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    good_fill = (occupied_ratio > 0.2) & (occupied_ratio < 0.8)\n    priorities[good_fill] += 0.3 * occupied_ratio[good_fill] # Scale bonus by fill level\n\n    # 4. Adaptive Scaling based on Item Size Ratio:\n    item_ratio = item / max_cap\n    priorities[fit_mask] *= (1 + 0.7 * item_ratio)  # Stronger scaling for larger items relative to bin size\n\n    # 5. Near Perfect Fit Bonus:\n    near_perfect_fit = np.isclose(bins_remain_cap, item, rtol=1e-05, atol=0.01 * max_cap) & fit_mask #tolerate upto 1% of max_cap difference\n    priorities[near_perfect_fit] += 5.0\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Snug Fit Priority: Prioritize bins with minimal slack, adjusted by item size.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        snug_fit_priority = np.exp(-5 * slack / bin_capacity)  # Exponentially decreasing priority with slack\n        priorities[fit_mask] = snug_fit_priority * (1 + 0.3 * item / bin_capacity)  # Larger items get higher priority for snug fits\n    else:\n        priorities[:] = -np.inf  # Cannot fit, so strongly discourage\n\n    # 2. Penalize Extreme Fills: Discourage bins that become nearly full or nearly empty. Use stronger penalties.\n    remaining_capacity = bins_remain_cap - item\n    nearly_full_penalty = np.exp(-20 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)  # Stronger penalty for nearly full\n    nearly_empty_penalty = np.exp(-8 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap > 0) * (bins_remain_cap > (1.5 * item))  # Moderate penalty for low fill, avoid emptying bins completely\n    priorities -= nearly_full_penalty + nearly_empty_penalty\n\n    # 3. Reward Partially Filled Bins: Encourage filling bins that are already partially used. More emphasis.\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.3 * occupied_ratio * (occupied_ratio < 0.9) # cap bonus at 90% full\n    priorities += bonus\n\n    # 4. Item Size Adjustment: Preferentially use larger bins for larger items (helps packing better overall).\n    priorities[fit_mask] *= (1 + 0.15 * item / bin_capacity)\n\n    # 5. Moderate Capacity Bonus: slight preference to bins between 0.25 and 0.75 fill, adjusted by item size.\n    moderate_capacity = np.logical_and(remaining_capacity/bin_capacity > 0.25, remaining_capacity/bin_capacity < 0.75) & (remaining_capacity >= 0)\n    priorities[moderate_capacity] += 0.07 * (1 - item/bin_capacity) # Give higher bonus if the item is small\n\n    return priorities",
    "response_id": 7,
    "obj": 7.8579976067012325,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # 1. Snug Fit Reward: Prioritize bins where the item fits snugly\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Reward smaller slack, scaled by item size and bin capacity\n        priorities[fit_mask] += (item / max_cap) / (slack + 1e-6)  # Adjust scaling\n    else:\n        priorities[:] = -np.inf  # Cannot fit\n\n    # 2. Fragmentation Penalty: Sharply penalize bins leading to extreme fill levels\n    remaining_capacity = bins_remain_cap - item\n    \n    # Penalize near-full bins exponentially, scaling by item size and remaining cap\n    too_full_mask = remaining_capacity >= 0\n    if np.any(too_full_mask):\n         fill_ratio = remaining_capacity[too_full_mask] / max_cap\n         penalty_full = np.exp(5 * (fill_ratio - 1)) * (item / max_cap) #adjust constant here\n         priorities[too_full_mask] -= penalty_full\n\n    #Penalize nearly empty bins\n    too_empty_mask = remaining_capacity >= 0\n    if np.any(too_empty_mask):\n        empty_ratio = bins_remain_cap[too_empty_mask] / max_cap\n        penalty_empty = np.exp(-5* empty_ratio) * (item / max_cap)\n        priorities[too_empty_mask] -= penalty_empty\n\n    # 3. Moderate Fill Bonus: Reward bins with moderate occupancy after insertion\n    moderate_mask = np.logical_and(remaining_capacity >= 0, remaining_capacity <= 0.75 * max_cap)\n    priorities[moderate_mask] += 0.05 * (item / max_cap)  # Adjust reward\n\n    # 4. Item size adjustment: Give a bonus to bins with larger remaining capacity, scaled by the item size\n    priorities[fit_mask] += (bins_remain_cap[fit_mask] / max_cap) * (item / max_cap)\n\n    return priorities",
    "response_id": 8,
    "obj": 51.68528121260471,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n    item_ratio = item / max_cap\n\n    # 1. Feasibility Check\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    # 2. Snug Fit Reward\n    slack = bins_remain_cap[fit_mask] - item\n    slack_ratio = slack / max_cap\n    priorities[fit_mask] += item_ratio / (slack_ratio + 0.001) #scaled by item size and scaled slack\n\n    # 3. Fragmentation Penalty (Exponential)\n    remaining_capacity = bins_remain_cap - item\n    remaining_mask = remaining_capacity >= 0\n\n    if np.any(remaining_mask):\n        remaining_ratio = remaining_capacity[remaining_mask] / max_cap\n        priorities[remaining_mask] -= item_ratio * np.exp(-50 * remaining_ratio) # exponentially decaying penalty for small remaining cap\n\n    # 4. Moderate Fill Bonus\n    occupied_space = max_cap - bins_remain_cap\n    occupied_ratio = occupied_space / max_cap\n    moderate_fill_mask = np.logical_and(occupied_ratio > 0.2, occupied_ratio < 0.8) & fit_mask  # Only give bonus to bins where item can fit and are moderately filled\n    priorities[moderate_fill_mask] += 0.5 * item_ratio\n\n    # 5. Item Size Scaling - removed duplication of item ratio\n    priorities[fit_mask] *= (1 + 0.5 * item_ratio)\n\n    # 6. Remaining capacity bonus - scale by item size too\n    bonus_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < 0.75 * max_cap)\n    priorities[bonus_capacity] += 0.1 * item_ratio\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]