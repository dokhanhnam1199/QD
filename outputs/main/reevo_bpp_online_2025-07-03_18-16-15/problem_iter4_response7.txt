```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Combines best-fit, first-fit, and nearly-full bin prioritization with adaptive penalties for unfit items.
    It also includes a small randomization for tie-breaking and exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_capacity = np.max(bins_remain_cap)

    # First Fit Decreasing heuristic component: prefer bins that can fit the item
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] += 1.0  # Give a base priority to bins that can fit

    # Best Fit heuristic component: prioritize bins with smallest remaining space *after* adding the item.
    remaining_space_after_fit = bins_remain_cap[fit_mask] - item

    if remaining_space_after_fit.size > 0:
        best_fit_priority = 1 / (remaining_space_after_fit + 1e-9)  # avoid division by zero.  Inverse of space, higher value == smaller space left after adding.
        indices_fit = np.where(fit_mask)[0]  # get indices to update
        priorities[indices_fit] += best_fit_priority

    # Introduce a "nearly full" bonus - prioritizes filling bins that are mostly full *before* addition.
    nearly_full_threshold = 0.75  # Threshold as a fraction of total bin size
    nearly_full_mask = bins_remain_cap > 0
    ratio = (max_capacity - bins_remain_cap) / max_capacity # Current occupancy
    near_full_bonus = (ratio > nearly_full_threshold) * fit_mask  # Only consider nearly full if item fits
    priorities += near_full_bonus * 2  # Arbitrary magnitude 2, tuned. Added only if item can fit.

    # Adaptive penalty for unfit items
    if not np.any(fit_mask):
        # Penalize based on how much the item exceeds capacity, but favor bins with some capacity
        penalty = -(item - bins_remain_cap) / max_capacity #normalized
        penalty[bins_remain_cap <= 0] = -np.inf  # Avoid empty bins unless absolutely necessary
        priorities = penalty

    # Introduce a small random factor to break ties and explore different bin assignments.
    priorities = priorities + 0.001 * np.random.rand(len(bins_remain_cap))

    return priorities
```
