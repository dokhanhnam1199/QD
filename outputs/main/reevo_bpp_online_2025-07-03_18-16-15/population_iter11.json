[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: Snug Fit Priority\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n        priorities[fit_mask] *= (1 + item / bin_capacity) #item size bonus\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins\n\n    # Heuristic 2: Fragmentation Penalty (Exponential)\n    remaining_capacity = bins_remain_cap - item\n    too_full = (remaining_capacity >= 0) & (remaining_capacity < 0.1 * bin_capacity)\n    too_empty = (remaining_capacity >= 0) & (bins_remain_cap < 0.2 * bin_capacity)  # Adjust threshold as needed\n    \n    priorities[too_full] -= np.exp(5 * (remaining_capacity[too_full] / bin_capacity - 0.1)) #More aggressive penalty\n    priorities[too_empty] -= np.exp(5 * (bins_remain_cap[too_empty] / bin_capacity - 0.2)) #More aggressive penalty\n\n    # Heuristic 3: Reward Partially Filled Bins\n    fill_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    partially_filled = (fill_ratio > 0) & (bins_remain_cap >= item) # Only reward for bins where the item fits\n    priorities[partially_filled] += 0.1 * fill_ratio[partially_filled]\n\n    # Heuristic 4: Moderate Capacity Bonus\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap < 0.75 * bin_capacity)\n    priorities[moderate_capacity] += 0.05\n\n    return priorities",
    "response_id": 0,
    "obj": 5.175508575987245,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tight Fit Priority, Scaled by Item Size\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)\n        priorities[fit_mask] *= (1 + 0.75 * item / bin_capacity)\n    else:\n        priorities[:] = -np.inf\n\n    # 2. Refined Fill Level Penalties\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp( -5 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)\n    too_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap > bin_capacity * 0.35) \n    \n    priorities -= (too_full_penalty + too_empty_penalty)\n\n    # 3. Dynamic Occupancy-Based Reward\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    moderate_occupancy = np.logical_and(occupied_ratio > 0.15, occupied_ratio < 0.85)\n    priorities[moderate_occupancy] += 0.15 * (1 - np.abs(occupied_ratio[moderate_occupancy] - 0.5) / 0.5)\n\n    # 4. Encourage Filling Partially Full Bins (Dynamically Scaled)\n    filled_threshold = 0.2 * bin_capacity\n    already_filled = (bin_capacity - bins_remain_cap) > filled_threshold\n    priorities[already_filled] += 0.05 * (item / bin_capacity)\n\n    return priorities",
    "response_id": 1,
    "obj": 19.794575189469487,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: Perfect Fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 10  # High priority for perfect fit\n\n    # Heuristic 2: Snug Fit (prioritize bins where remaining capacity is slightly larger than the item)\n    snug_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.1)\n    if np.any(snug_fit_mask):\n        slack = bins_remain_cap[snug_fit_mask] - item\n        priorities[snug_fit_mask] += 5 / (slack + 0.001)  # Smaller slack, higher priority\n\n    # Heuristic 3: Moderate Fill (reward bins that, after placing the item, have a reasonable fill level)\n    remaining_capacity = bins_remain_cap - item\n    moderate_fill_mask = (remaining_capacity >= 0) & (remaining_capacity <= max_cap * 0.75)\n    priorities[moderate_fill_mask] += 2\n\n    # Heuristic 4: Penalize Overflow (severely penalize bins that cannot fit the item)\n    overflow_mask = bins_remain_cap < item\n    priorities[overflow_mask] = -np.inf\n\n    # Heuristic 5: Penalize Fragmentation (penalize bins that, after placing the item, become almost empty)\n    fragmentation_mask = (remaining_capacity >= 0) & (remaining_capacity <= max_cap * 0.1)\n    priorities[fragmentation_mask] -= 3\n\n    # Heuristic 6: Reward Partial Fills (give a small bonus to bins that are already partially filled)\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    priorities += 0.5 * occupied_ratio\n\n    # Heuristic 7: Item-Size Dependent Adjustment: Favor bins closer to item size\n    # The larger the item, the more we want a snug fit.\n    item_ratio = item / max_cap\n    priorities[(bins_remain_cap >= item)] += 2 * item_ratio * (1 - ((bins_remain_cap[(bins_remain_cap >= item)] - item) / max_cap))\n\n    return priorities",
    "response_id": 2,
    "obj": 4.726765057838063,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Snug Fit Priority: Prioritize bins with minimal slack, adjusted by item size.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        snug_fit_priority = 1 / (slack + 1e-6)\n        priorities[fit_mask] = snug_fit_priority * (1 + 0.5 * item / bin_capacity)  # Larger items get higher priority for snug fits\n    else:\n        priorities[:] = -np.inf  # Cannot fit, so strongly discourage\n\n    # 2. Penalize Extreme Fills: Discourage bins that become nearly full or nearly empty.\n    remaining_capacity = bins_remain_cap - item\n    nearly_full_penalty = np.exp(-10 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)  # Stronger penalty for nearly full\n    nearly_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap > 0) * (bins_remain_cap > (2 * item))  # Moderate penalty for low fill, avoid emptying bins completely\n    priorities -= nearly_full_penalty + nearly_empty_penalty\n\n    # 3. Reward Partially Filled Bins: Encourage filling bins that are already partially used.\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.2 * occupied_ratio\n    priorities += bonus\n\n    # 4. Item Size Adjustment: Preferentially use larger bins for larger items (helps packing better overall).\n    priorities[fit_mask] *= (1 + 0.1 * item / bin_capacity)\n\n    # 5. Moderate Capacity Bonus: slight preference to bins between 0.25 and 0.75 fill\n    moderate_capacity = np.logical_and(remaining_capacity/bin_capacity > 0.25, remaining_capacity/bin_capacity < 0.75) & (remaining_capacity >= 0)\n    priorities[moderate_capacity] += 0.05\n\n    return priorities",
    "response_id": 3,
    "obj": 0.7479058635819705,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # 1. Essential Fit Prioritization: Highest priority to bins that can accommodate the item.\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)  # Item doesn't fit in any bin\n\n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] = 1.0 / (slack + 1e-6)  # Smaller slack -> higher priority, crucial scaling\n\n    # 2. Fragmentation Penalty: Penalize bins that would become too empty after placing item.\n    remaining_capacity = bins_remain_cap - item\n    frag_mask = (remaining_capacity > 0) & (remaining_capacity / max_cap < 0.2)\n    priorities[frag_mask] -= 0.2 * (1 - remaining_capacity[frag_mask] / (0.2 * max_cap)) # Scale penalty based on level of fragmentation.\n\n    # 3. Fill Level Bonus: Reward bins that are already reasonably filled.\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    good_fill = (occupied_ratio > 0.1) & (occupied_ratio < 0.9) # Adjust fill range\n    priorities[good_fill] += 0.1 * occupied_ratio[good_fill]  #Scale bonus by occupied ratio\n\n    # 4. Item Size Adaptive Scaling: Adjust based on the proportion of item size to bin capacity.\n    priorities[fit_mask] *= (1 + 0.5 * (item / max_cap)) # Stronger scaling for larger items.\n\n    return priorities",
    "response_id": 4,
    "obj": 3.490227363382529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tight Fit Priority with Scaling\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Inverse slack, scaled by item size and bin capacity\n        priorities[fit_mask] = (item / bin_capacity) / (slack + 1e-6)\n\n        # Encourage use of bins which are already filled to some extent\n        filled_amount = bin_capacity - bins_remain_cap[fit_mask]\n        priorities[fit_mask] += 0.1 * (filled_amount / bin_capacity)\n\n    else:\n        priorities[:] = -np.inf  # Item cannot fit; force new bin\n\n    # 2. Penalize Extreme Fill Levels with Exponential Decay\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(10 * (remaining_capacity[fit_mask] / bin_capacity)) if np.any(fit_mask) else 0\n    too_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity))\n\n    if np.any(fit_mask):\n        priorities[fit_mask] -= 0.1 * too_full_penalty # Reduce value if it leads to almost full state\n    priorities[fit_mask] -= 0.01* too_empty_penalty[fit_mask] if np.any(fit_mask) else 0\n\n    # 3. Moderate Fill Bonus (Scaled)\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.05 * occupied_ratio # Previously 0.1 - scaled down\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # 1. Fit Prioritization: Highest priority to bins that can accommodate the item.\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)  # Item doesn't fit in any bin\n\n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack -> higher priority\n\n    # 2. Fragmentation Penalty: Penalize bins that would become nearly full.\n    remaining_capacity = bins_remain_cap - item\n    too_full = (remaining_capacity / max_cap) < 0.1\n    priorities[fit_mask & too_full] -= 0.3  # Increased penalty if almost full.\n\n    # 3. Fill Level Bonus: Reward bins that are already somewhat filled (but not too full).\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    good_fill = (occupied_ratio > 0.2) & (occupied_ratio < 0.8)\n    priorities[good_fill] += 0.2  # Increased bonus\n\n    # 4. Item size adjustment: Prefer to put larger items in bins with available capacity and adjust priority based on the item's relative size.\n    priorities[fit_mask] += 0.5 * (item / max_cap)  # Scale priority boost by item size\n\n    return priorities",
    "response_id": 6,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility Mask\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    # 2. Scaled Near-Fit Reward\n    slack = bins_remain_cap - item\n    near_fit_reward = np.exp(-5 * np.abs(slack) / bin_capacity) * feasible_bins\n    priorities[feasible_bins] += 0.7 * item * near_fit_reward[feasible_bins]\n\n    # 3. Target Fill Level Reward (Gaussian)\n    target_fill = 0.75 * bin_capacity\n    fill_level = bin_capacity - bins_remain_cap\n    fill_level_reward = np.exp(-((fill_level - target_fill) ** 2) / (2 * (bin_capacity * 0.2) ** 2)) * feasible_bins\n    priorities[feasible_bins] += 0.3 * fill_level_reward[feasible_bins]\n\n    # 4. Scaled Fragmentation Penalty\n    remaining_capacity = bins_remain_cap - item\n    frag_mask = (remaining_capacity > 0) & (remaining_capacity < 0.1 * bin_capacity) & feasible_bins\n    priorities[frag_mask] -= 0.5 * item\n\n    # 5. Controlled Randomness (Exploration)\n    priorities[feasible_bins] += 0.01 * item * np.random.randn(np.sum(feasible_bins))\n\n    return priorities",
    "response_id": 7,
    "obj": 5.025927403270851,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tight Fit Priority\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n        priorities[fit_mask] *= (1 + item / bin_capacity)  # Scale by item size. Big item prefers less slack\n    else:\n        priorities[:] = -np.inf  # Item cannot fit; force new bin\n\n    # 2. Penalize Extreme Fills Exponentially\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(-20 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)\n    too_empty_penalty = np.exp(-20 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap < bin_capacity / 4)\n\n    priorities -= (too_full_penalty + too_empty_penalty)\n\n    # 3. Reward Moderate Occupancy with Bonuses\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    moderate_capacity_bonus = 0.15 * occupied_ratio\n    priorities += moderate_capacity_bonus\n\n    # 4. Added encouragement for bins that are more than one item filled\n    filled_threshold = 0.25 * bin_capacity\n    already_filled = (bin_capacity - bins_remain_cap) > filled_threshold\n    priorities[already_filled] += 0.05\n    \n    return priorities",
    "response_id": 8,
    "obj": 3.9190267251695206,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0  # Avoid division by zero if bins_remain_cap is empty\n\n    # Heuristic 1: Perfect Fit - Highest priority for bins that fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0 * item\n\n    # Heuristic 2: Remaining Space - Prioritize bins with minimal remaining space after packing, scaled by item size.\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += item / (remaining_space + 1e-6)\n\n    # Heuristic 3: Moderate Capacity - Encourage using bins with moderate capacity relative to item size.\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap <= (item * 3)) & (~perfect_fit) & can_fit\n    priorities[moderate_capacity] += 10.0 * item\n\n    # Heuristic 4: Large Capacity Penalty - Discourage using bins with significantly more capacity than needed, scaled by item size.\n    large_capacity = (bins_remain_cap > item * 5) & can_fit\n    priorities[large_capacity] -= item * 0.2  # Penalty scaled by item size\n\n    # Heuristic 5: Infeasible Allocation Penalty: Massive negative priority.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # Heuristic 6: Prioritize more filled bins.\n    fill_level = (max_cap - bins_remain_cap) / max_cap\n    priorities[can_fit] += 5 * fill_level[can_fit] * item\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Snug Fit Reward: Prioritize bins where the item fits snugly\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Reward smaller slack, scaled by item size and bin capacity\n        priorities[fit_mask] += (item / np.max(bins_remain_cap)) / (slack + 1e-6)  # Adjust scaling\n    else:\n        priorities[:] = -np.inf  # Cannot fit\n\n    # 2. Fragmentation Penalty: Sharply penalize bins leading to extreme fill levels\n    remaining_capacity = bins_remain_cap - item\n    \n    # Penalize near-full bins exponentially, scaling by item size and remaining cap\n    too_full_mask = remaining_capacity >= 0\n    if np.any(too_full_mask):\n         fill_ratio = remaining_capacity[too_full_mask] / np.max(bins_remain_cap)\n         penalty_full = np.exp(5 * (fill_ratio - 1)) * (item / np.max(bins_remain_cap)) #adjust constant here\n         priorities[too_full_mask] -= penalty_full\n\n    #Penalize nearly empty bins\n    too_empty_mask = remaining_capacity >= 0\n    if np.any(too_empty_mask):\n        empty_ratio = bins_remain_cap[too_empty_mask] / np.max(bins_remain_cap)\n        penalty_empty = np.exp(-5* empty_ratio) * (item / np.max(bins_remain_cap))\n        priorities[too_empty_mask] -= penalty_empty\n\n    # 3. Moderate Fill Bonus: Reward bins with moderate occupancy after insertion\n    moderate_mask = np.logical_and(remaining_capacity >= 0, remaining_capacity <= 0.75 * np.max(bins_remain_cap))\n    priorities[moderate_mask] += 0.05 * (item / np.max(bins_remain_cap))  # Adjust reward\n\n    # 4. Item size adjustment\n    priorities[fit_mask] *= (1 + item / np.max(bins_remain_cap))\n\n    return priorities",
    "response_id": 0,
    "obj": 3.609892301555649,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Penalize bins that become too full or too empty after insertion to avoid fragmentation\n    remaining_capacity = bins_remain_cap - item\n    #sharply penalize extreme fills\n    too_full_mask = remaining_capacity >= 0\n    if np.any(too_full_mask):\n          remaining_ratio = remaining_capacity[too_full_mask]/max_cap\n          too_full_penalty = np.exp(5*(10*remaining_ratio-10))*(remaining_capacity[too_full_mask]>=0) #sharply penalize nearly full\n\n          priorities[too_full_mask] -= too_full_penalty\n\n    too_empty_penalty = np.exp(-10 * (bins_remain_cap / max_cap)) * (remaining_capacity >= 0) * (bins_remain_cap<max_cap/2) #penalize low fill\n\n    priorities = priorities - too_empty_penalty\n\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled (reduces number of partially-filled bins)\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    bonus = 0.1 * occupied_ratio\n    priorities = priorities + bonus\n\n    #Heuristic 4: Moderate Capacity Bonus\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < max_cap*0.75)\n    priorities[moderate_capacity] += 0.05\n\n    #Heuristic 5: Item Size Adjustment\n    priorities[fit_mask] *= (1 + item/max_cap)\n\n    #Heuristic 6: Dynamic Slack Reward\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        slack_reward = np.exp(-5 * slack/max_cap)\n        priorities[fit_mask] += slack_reward\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n\n        # Scale snug fit reward based on item size\n        priorities[fit_mask] *= (1 + item)\n\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Penalize bins that become too full or too empty after insertion to avoid fragmentation\n    remaining_capacity = bins_remain_cap - item\n    bin_capacity = np.max(bins_remain_cap)\n    \n    # Sharply Penalize Fragmentation exponentially\n    too_full_penalty = np.exp(5 * (remaining_capacity / bin_capacity - 1)) * (remaining_capacity >= 0) # increased impact\n    too_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap<bin_capacity/2) # increased impact\n\n    priorities = priorities - too_full_penalty - too_empty_penalty\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled (reduces number of partially-filled bins)\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.1 * occupied_ratio\n    priorities = priorities + bonus\n\n    #Heuristic 4: Moderate Capacity Bonus\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < bin_capacity*0.75)\n    priorities[moderate_capacity] += 0.05\n\n    #Heuristic 5: Near Full Bin Penalty (Dynamic Scaling)\n    near_full = np.logical_and(remaining_capacity > 0 , remaining_capacity < bin_capacity * 0.1)\n    if np.any(near_full):\n         near_full_penalty = np.exp(10*(remaining_capacity[near_full]/bin_capacity - 0.1 ))\n         priorities[near_full] -= near_full_penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility Check\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    # Snug Fit Reward\n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1.0 / (slack + 0.001)  # Inverse slack, avoid division by zero\n\n    # Fragmentation Penalty (Exponential)\n    remaining_capacity = bins_remain_cap - item\n    frac_penalty_mask = remaining_capacity >= 0\n    remaining_capacity_norm = remaining_capacity[frac_penalty_mask] / np.max(bins_remain_cap)\n    priorities[frac_penalty_mask] -= np.exp(-50 * remaining_capacity_norm) # exponential penalty for small remaining cap\n    #Extreme Fill Penalty\n    almost_full = np.logical_and(remaining_capacity >=0, remaining_capacity <= 0.1 * np.max(bins_remain_cap)) #extremely high fill levels\n    priorities[almost_full] -= 5\n\n\n    # Moderate Fill Bonus\n    occupied_space = np.max(bins_remain_cap) - bins_remain_cap\n    occupied_ratio = occupied_space / np.max(bins_remain_cap)\n\n    moderate_fill_mask = np.logical_and(occupied_ratio > 0.2, occupied_ratio < 0.8) & fit_mask #Only give bonus to bins where item can fit and are moderately filled\n    priorities[moderate_fill_mask] += 0.5\n\n\n    # Item Size Scaling\n    priorities[fit_mask] *= (1 + 0.5 * (item / np.max(bins_remain_cap))) #scale priorities with item size\n\n\n    # Remaining capacity bonus\n    bonus_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap< 0.75 * np.max(bins_remain_cap)) #bins which can hold item and is less than 75% full\n    priorities[bonus_capacity] += 0.1\n\n\n\n    return priorities",
    "response_id": 3,
    "obj": 6.8807339449541285,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: Snug Fit - Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = np.exp(-5 * slack / bin_capacity) # Exponential reward for small slack\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Fragmentation Penalty - Sharply penalize bins that become too full or too empty after insertion\n    remaining_capacity = bins_remain_cap - item\n    \n    # Penalty for bins that become nearly full (exponential penalty)\n    too_full_mask = np.logical_and(remaining_capacity >= 0, remaining_capacity / bin_capacity < 0.1)\n    priorities[too_full_mask] -= 5 * np.exp(10 * (remaining_capacity[too_full_mask] / bin_capacity - 0.1))\n\n    # Penalty for bins that become mostly empty (exponential penalty)\n    too_empty_mask = np.logical_and(remaining_capacity >= 0, (bins_remain_cap / bin_capacity) > 0.75)\n    priorities[too_empty_mask] -= np.exp(-5*(bins_remain_cap[too_empty_mask]- item)/bin_capacity)*item/bin_capacity\n\n\n    # Heuristic 3: Moderate Fill Reward - Reward bins that are moderately filled.\n    moderate_fill_mask = np.logical_and(remaining_capacity >= 0, remaining_capacity / bin_capacity >= 0.2, remaining_capacity/bin_capacity <= 0.6)\n    priorities[moderate_fill_mask] += 0.5 * (1-np.abs(remaining_capacity[moderate_fill_mask]/bin_capacity-0.4)/0.2)\n\n    # Heuristic 4: Item Size Adjustment - Scale priorities based on item size.\n    priorities[fit_mask] *= (1 + 0.5* item / bin_capacity)\n    \n\n    return priorities",
    "response_id": 4,
    "obj": 14.190267251695248,
    "exec_success": true
  }
]