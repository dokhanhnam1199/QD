```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # 1. Feasibility: Infeasible bins get -inf priority
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf
    
    feasible_mask = ~infeasible_mask
    
    # 2. Tight Fit: Prioritize bins that result in smaller remaining capacity
    remaining_capacity = bins_remain_cap[feasible_mask] - item
    priorities[feasible_mask] = -remaining_capacity
    
    # 3. Prevent Near-Empty Bins:
    #   Slightly penalize bins that would become almost empty after placing the item.
    almost_empty_threshold = 0.2  # As a ratio of the bin capacity.  Adjust as needed.
    bin_capacity = np.max(bins_remain_cap) # Assume all bins have the same capacity, take max as the capacity
    almost_empty_mask = feasible_mask & (remaining_capacity < almost_empty_threshold * bin_capacity)
    priorities[almost_empty_mask] -= 0.1  # Small penalty

    # 4. Discourage Nearing-Full Capacity:
    #   Penalize bins that are close to full *before* placing the item
    nearing_full_threshold = 0.9
    nearing_full_mask = feasible_mask & (bins_remain_cap / bin_capacity > nearing_full_threshold)
    priorities[nearing_full_mask] -= 0.5 # Medium penalty

    # 5. Bonus for almost full bins before placing the item
    almost_full_before_place = 0.8
    almost_full_before_mask = feasible_mask & (bins_remain_cap / bin_capacity > almost_full_before_place) & (bins_remain_cap / bin_capacity <= nearing_full_threshold)
    priorities[almost_full_before_mask] +=0.3

    return priorities
```
