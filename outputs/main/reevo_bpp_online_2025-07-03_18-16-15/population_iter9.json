[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect Fit: Highest priority if the bin fits perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0\n\n    # 2. First Fit: Give a base priority to all bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1.0\n\n    # 3. Best Fit: Prioritize bins with the least remaining space after packing.\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        min_remaining_space_mask = remaining_space == np.min(remaining_space)\n        priorities[can_fit][min_remaining_space_mask] += 50.0\n\n    # 4. Moderate Waste: Add a bonus if the remaining capacity is not too large relative to the item.\n    moderate_waste = can_fit & (bins_remain_cap <= 2 * item)\n    priorities[moderate_waste] += 20.0\n\n    # 5. Avoid Overfilling: Heavily penalize bins that cannot fit the item.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # 6. Prioritize Occupied Bins: Add priority based on how full the bin is.\n    max_capacity = np.max(bins_remain_cap)\n    fill_ratio = (max_capacity - bins_remain_cap) / max_capacity\n    priorities[can_fit] += 10 * fill_ratio[can_fit]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Snug Fit Priority: Prioritize bins with minimal slack.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # Cannot fit, so strongly discourage\n\n    # 2. Penalize Extreme Fills: Discourage bins that become nearly full or nearly empty.\n    remaining_capacity = bins_remain_cap - item\n    nearly_full_penalty = np.exp(-5 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)  # Strong penalty for nearly full\n    nearly_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap < bin_capacity / 3)  # Moderate penalty for low fill\n    priorities -= nearly_full_penalty + nearly_empty_penalty\n\n    # 3. Reward Partially Filled Bins: Encourage filling bins that are already partially used.\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.15 * occupied_ratio\n    priorities += bonus\n\n    # 4. Item Size Adjustment: Preferentially use larger bins for larger items (helps packing better overall).\n    priorities[fit_mask] *= (1 + 0.2 * item / bin_capacity)\n\n    # 5. Moderate Capacity Bonus: slight preference to bins between 0.25 and 0.75 fill\n    moderate_capacity = np.logical_and(remaining_capacity/bin_capacity > 0.25, remaining_capacity/bin_capacity < 0.75) & (remaining_capacity >= 0)\n    priorities[moderate_capacity] += 0.05\n\n    #6. Adjust snug fit priority based on item size. larger item gets higher priority for snug fit\n    if np.any(fit_mask):\n        priorities[fit_mask] += 0.1 * item / bin_capacity\n        \n    return priorities",
    "response_id": 1,
    "obj": 28.390506581571607,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Exponential penalties for bins that become too full or too empty after insertion to avoid fragmentation\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(5 * (remaining_capacity / max_cap - 1)) * (remaining_capacity >= 0)  # More aggressive penalty\n    too_empty_penalty = np.exp(5 * ((bins_remain_cap - max_cap/2) / max_cap)) * (remaining_capacity >= 0) * (bins_remain_cap > max_cap/2) #Only penalize empty if original bin is empty\n\n    priorities = priorities - too_full_penalty - too_empty_penalty\n\n    # Heuristic 3: Moderate occupancy bonus\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    moderate_occupancy = np.logical_and(occupied_ratio > 0.2, occupied_ratio < 0.8)\n    priorities[moderate_occupancy & fit_mask] += 0.1\n\n    #Heuristic 4: Item Size Adjustment\n    priorities[fit_mask] *= (1 + 0.5 * item / max_cap) #Increased importance\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    \n    # 1. Perfect Fit: Highest priority for bins that fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] += 1000.0\n\n    # 2. Moderate Capacity: Prioritize bins with moderate capacity relative to item size.\n    #    Also avoid bins that are already almost full.\n    can_fit = bins_remain_cap >= item\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap <= (item * 3)) & (~perfect_fit) & (bins_remain_cap > 1.1 * item)\n    priorities[moderate_capacity] += 50.0\n\n    # 3. Remaining Space: Prioritize bins with minimal remaining space after packing, but only if it's not a perfect fit or moderate capacity.\n    if np.any(can_fit & ~perfect_fit & ~moderate_capacity):\n        remaining_space = bins_remain_cap[can_fit & ~perfect_fit & ~moderate_capacity] - item\n        priorities[can_fit & ~perfect_fit & ~moderate_capacity] += item / (remaining_space + 1e-6)  # Scale priority by item size\n\n    # 4. Fragmentation Penalty: Penalize creating very small remaining space in bins.\n    remaining_after_fill = bins_remain_cap - item\n    fragmentation = (remaining_after_fill > 0) & (remaining_after_fill < 0.1 * bin_capacity)\n    priorities[fragmentation] -= 50.0\n\n    # 5. Large Capacity Penalty: Discourage using bins with significantly more capacity than needed.\n    large_capacity = (bins_remain_cap > item * 5) & can_fit\n    priorities[large_capacity] -= 5.0\n\n    # 6. Infeasible Allocation Penalty: Massive negative priority if item doesn't fit.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # 7. Prioritize more filled bins (encourage using partially filled bins before empty ones).\n    fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities[can_fit] += 10 * fill_level[can_fit]\n\n    return priorities",
    "response_id": 3,
    "obj": 6.382130035899482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # 1. Fit Prioritization: Highest priority to bins that can accommodate the item.\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)  # Item doesn't fit in any bin\n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack -> higher priority\n\n    # 2. Fragmentation Penalty: Penalize bins that would become nearly full.\n    remaining_capacity = bins_remain_cap - item\n    too_full = (remaining_capacity / max_cap) < 0.1\n    priorities[fit_mask & too_full] -= 0.25 # Reduce priority if almost full.\n\n    # 3. Fill Level Bonus: Reward bins that are already somewhat filled (but not too full).\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    good_fill = (occupied_ratio > 0.2) & (occupied_ratio < 0.8)\n    priorities[good_fill] += 0.15 # Increased bonus\n\n    # 4. Moderate Capacity Bonus\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < max_cap * 0.75)\n    priorities[moderate_capacity] += 0.05\n\n    # 5. Item size adjustment: Prefer to put larger items in bins with available capacity\n    priorities[fit_mask] *= (1 + item / max_cap)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.178300757877951,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility Mask: Filter out bins that cannot fit the item\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Set priority to -inf for infeasible bins\n\n    # 2. Near-Fit Reward: Exponential reward for bins with remaining capacity close to item size\n    slack = bins_remain_cap - item\n    near_fit = np.exp(-5 * np.abs(slack) / bin_capacity) * feasible_bins # Ensure only feasible bins are considered\n    priorities[feasible_bins] += 0.8 * item * near_fit[feasible_bins]  # Scale reward by item size and reduce magnitude\n\n    # 3. Target Fill Level: Gaussian distribution centered around the optimal fill level (75%)\n    target_fill = 0.75 * bin_capacity\n    fill_level = bin_capacity - bins_remain_cap\n    priorities[feasible_bins] += 0.2 * np.exp(-((fill_level[feasible_bins] - target_fill) ** 2) / (2 * (bin_capacity * 0.2) ** 2))  #Smaller magnitude to avoid dominating near-fit\n\n    # 4. Fragmentation Penalty: Apply a negative reward if remaining capacity is very small\n    remaining_capacity = bins_remain_cap - item\n    frag_mask = (remaining_capacity > 0) & (remaining_capacity < 0.1 * bin_capacity) & feasible_bins  # Consider fragmentation only on feasible bins\n    priorities[frag_mask] -= 0.6 * item  # Scale penalty by item size; tuned magnitude\n\n    # 5. Controlled Randomness: Add a small amount of noise to the priorities for exploration\n    priorities[feasible_bins] += 0.005 * item * np.random.randn(np.sum(feasible_bins)) # Scale randomness with item size; further reduced magnitude\n\n    return priorities",
    "response_id": 5,
    "obj": 5.055843637814125,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tight Fit Priority\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n        priorities[fit_mask] *= (1 + item / bin_capacity)  # Scale by item size\n    else:\n        priorities[:] = -np.inf  # Item cannot fit; force new bin\n\n    # 2. Avoid Extreme Fill Levels\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(-10 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)\n    too_empty_penalty = np.exp(-10 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap < bin_capacity / 2)\n\n    priorities -= (too_full_penalty + too_empty_penalty)\n\n    # 3. Reward Moderately Filled Bins\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    moderate_capacity_bonus = 0.1 * occupied_ratio\n    priorities += moderate_capacity_bonus\n\n    # 4. Added encouragement for bins that are more than one item filled\n    filled_threshold = 0.25 * bin_capacity\n    already_filled = (bin_capacity - bins_remain_cap) > filled_threshold\n    priorities[already_filled] += 0.025\n    \n    return priorities",
    "response_id": 6,
    "obj": 0.8077383326685305,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect Fit: Huge Reward\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6  # Tolerance for floating-point comparisons\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 1000 * item  # Huge reward scaled by item size\n\n    # 2. Near Fit: Moderate Reward, scaled by item size and remaining capacity\n    near_fit = (bins_remain_cap >= item) & (~perfect_fit)\n    if np.any(near_fit):\n        slack = bins_remain_cap[near_fit] - item\n        priorities[near_fit] += (item / bin_capacity) * (10 / (slack + 1e-6)) # Scale reward by slack\n\n    # 3. Penalize Overflow: Very Harsh Penalty\n    overflow = bins_remain_cap < item\n    priorities[overflow] = -np.inf\n\n    # 4. Target Fill Level: Reward bins closest to a target fill\n    target_fill_ratio = 0.75\n    current_fill_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    potential_fill_ratio = (bin_capacity - (bins_remain_cap - item)) / bin_capacity\n    \n    # Only apply if the item fits\n    can_fit = bins_remain_cap >= item\n    \n    # distance to target fill\n    dist_before = np.abs(current_fill_ratio - target_fill_ratio)\n    dist_after  = np.abs(potential_fill_ratio - target_fill_ratio)\n    \n    # Prioritize bins that bring fill ratio closer to target\n    improvement = dist_before - dist_after\n    priorities[can_fit] += 10 * improvement[can_fit] * item  # Scale reward by improvement and item size\n\n    # 5. Fragmentation Penalty: Exponential decay\n    remaining_capacity = bins_remain_cap - item\n    fragmentation_penalty = np.exp(-10 * np.abs(remaining_capacity / bin_capacity)) * (remaining_capacity >= 0) #only if the item can fit in bin.\n    priorities -= fragmentation_penalty * item * 0.3 # Increased Impact\n\n    # 6. Small Randomness\n    priorities += np.random.normal(0, 0.001, size=bins_remain_cap.shape) * item # Smaller randomness\n    \n    return priorities",
    "response_id": 7,
    "obj": 82.28958915037894,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Perfect Fit - Highest priority for bins that fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0\n\n    # Heuristic 2: Remaining Space - Prioritize bins with minimal remaining space after packing, scaled by item size.\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += item / (remaining_space + 1e-6)\n\n    # Heuristic 3: Moderate Capacity - Encourage using bins with moderate capacity relative to item size.\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap <= (item * 3)) & (~perfect_fit)\n    priorities[moderate_capacity] += 10.0\n\n    # Heuristic 4: Large Capacity Penalty - Discourage using bins with significantly more capacity than needed, scaled by item size.\n    large_capacity = (bins_remain_cap > item * 5) & can_fit\n    priorities[large_capacity] -= item * 0.2  # Penalty scaled by item size\n\n    # Heuristic 5: Infeasible Allocation Penalty: Massive negative priority.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # Heuristic 6: Prioritize more filled bins.\n    max_capacity = np.max(bins_remain_cap)\n    fill_level = (max_capacity - bins_remain_cap) / max_capacity\n    priorities[can_fit] += 5 * fill_level[can_fit]\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect Fit: Huge Reward, scaled by item size\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 1000 * item\n\n    # 2. Near Fit: Moderate Reward, scaled by item size and inverse slack\n    near_fit = (bins_remain_cap >= item) & (~perfect_fit)\n    if np.any(near_fit):\n        slack = bins_remain_cap[near_fit] - item\n        priorities[near_fit] += (item**2 / (slack + 1e-6))\n\n    # 3. Overflow Penalty: Very harsh penalty\n    overflow = bins_remain_cap < item\n    priorities[overflow] = -np.inf\n\n    # 4. Target Fill Ratio: Gaussian preference\n    fill_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    target_ratio = 0.7  # Encourage bins to be around 70% full\n    gaussian_preference = np.exp(-((fill_ratio - target_ratio)**2) / (2 * 0.15**2))\n    priorities += gaussian_preference * item * 0.2\n\n    # 5. Fragmentation Penalty: Exponential decay based on remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    can_fit = bins_remain_cap >= item\n    fragmentation_penalty = np.exp(-5 * (remaining_capacity / bin_capacity)) * can_fit\n    priorities -= fragmentation_penalty * item * 0.1\n\n    # 6. Capacity usage reward: the more capacity used, the better\n    capacity_used_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += capacity_used_ratio * item * 0.05\n\n    # 7. Small Randomness\n    priorities += np.random.normal(0, 0.005 * item, size=bins_remain_cap.shape)\n\n    # 8. Prioritize bins with higher remaining capacity (Encourage to use empty bin quickly)\n    priorities += bins_remain_cap / bin_capacity * item * 0.01\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: Perfect/Snug Fit: Huge reward for perfect fit, good reward for snug fit\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        perfect_fit = np.isclose(slack, 0)\n        priorities[fit_mask] = 0.0\n        priorities[fit_mask][perfect_fit] = 10.0  # Huge reward for perfect fit\n        priorities[fit_mask][~perfect_fit] = 5.0 / (slack[~perfect_fit] + 0.01)  # Smaller slack, higher priority\n\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Moderate Fill: Reward bins with remaining capacity in moderate range AFTER insertion\n    remaining_capacity = bins_remain_cap - item\n    moderate_fill = np.logical_and(remaining_capacity >= 0, remaining_capacity <= 0.75 * max_cap)\n    priorities[moderate_fill] += 2.0\n\n    # Heuristic 3: Fragmentation Penalty: Sharply penalize bins leading to very small remaining capacity.\n    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_remaining = np.logical_and(remaining_capacity >= 0, remaining_capacity <= 0.1 * max_cap)\n    fragmentation_penalty[small_remaining] = -5.0 #Strong Penalty for small remaining bins\n    priorities += fragmentation_penalty\n\n    # Heuristic 4: Overflow Penalty: Ensure never put items in bins with too little capacity\n    overflow = remaining_capacity < 0\n    priorities[overflow] = -np.inf\n\n    # Heuristic 5: Item Size Dependent Adjustment: Promote insertion into moderately filled bins when item is large\n    if item > 0.5 * max_cap:\n        moderate_bins = np.logical_and(bins_remain_cap >= item, bins_remain_cap <= 0.9 * max_cap)\n        priorities[moderate_bins] += 1.0\n\n    return priorities",
    "response_id": 0,
    "obj": 16.982449142401272,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: Perfect/Snug Fit\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        perfect_fit_mask = slack == 0\n        if np.any(perfect_fit_mask):\n            priorities[fit_mask][perfect_fit_mask] = 10  # High priority for perfect fit\n        else:\n            priorities[fit_mask] = 5 / (slack + 0.01)  # High priority for snug fit, scaled.\n    else:\n        priorities[:] = -np.inf  # Cannot fit.\n\n    # Heuristic 2: Moderate Fill (Avoid Fragmentation)\n    remaining_capacity = bins_remain_cap - item\n    valid_fill = remaining_capacity >= 0\n    moderate_fill_mask = np.logical_and(remaining_capacity >= 0.2 * max_cap, remaining_capacity <= 0.8 * max_cap)\n    priorities[moderate_fill_mask] += 2\n\n    # Heuristic 3: Penalize Overflow and Near-Full\n    overflow_penalty = -100 * (remaining_capacity < 0)\n    near_full_penalty = -5 * np.exp(-10 * remaining_capacity / max_cap) * valid_fill\n    priorities += overflow_penalty + near_full_penalty\n\n    # Heuristic 4: Bonus for Partially Filled Bins (Reduce Empty Bins)\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    partially_filled_bonus = 0.5 * occupied_ratio * valid_fill #only reward if valid\n\n    priorities += partially_filled_bonus\n    return priorities",
    "response_id": 1,
    "obj": 78.70961308336658,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Perfect/Snug Fit - High Priority\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        perfect_fit = np.isclose(slack, 0)\n        priorities[fit_mask] = np.where(perfect_fit, 10, 1 / (slack + 1e-6))  # Huge boost for perfect fit\n    else:\n        priorities[:] = -np.inf  # Cannot fit\n\n    # Heuristic 2: Moderate Fill Encouragement\n    remaining_capacity = bins_remain_cap - item\n    moderate_fill_mask = np.logical_and(remaining_capacity >= 0, remaining_capacity <= np.max(bins_remain_cap) * 0.5) # Prefer leave at least half capacity unused\n    priorities[moderate_fill_mask] += 2.0 # Significantly encourage this case\n\n    # Heuristic 3: Overflow Penalty (Severe)\n    overflow_mask = remaining_capacity < 0\n    priorities[overflow_mask] = -1000  # Extreme penalty\n\n    # Heuristic 4: Fragmentation Penalty (Size-Scaled)\n    fragmentation_penalty = np.zeros_like(bins_remain_cap)\n    valid_bins = remaining_capacity >= 0\n    fragmentation_penalty[valid_bins] = np.exp(-5 * (remaining_capacity[valid_bins] / np.max(bins_remain_cap)))  # Smaller remaining, bigger penalty.\n\n    priorities -= fragmentation_penalty\n\n    # Heuristic 5: Reward Partial Fills (Less Aggressively)\n    partial_fill_mask = np.logical_and(remaining_capacity >= 0, remaining_capacity > np.max(bins_remain_cap) * 0.5)\n    priorities[partial_fill_mask] += 0.5\n    \n    # Heuristic 6: Item Size Adjustment (Subtle, Only when it fits)\n    if np.any(fit_mask):\n         priorities[fit_mask] *= (1 + 0.1 * (item/np.max(bins_remain_cap))) # A small boost, proportional to item size\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: Perfect/Snug Fit - High Reward, scaled by item size\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        perfect_fit = np.isclose(slack, 0)\n        priorities[fit_mask] = (item / max_cap) / (slack + 0.01 * max_cap) #Scale priority by item size. Avoid zero div\n        priorities[fit_mask][perfect_fit] += 0.5 # Large bonus for perfect fit\n    else:\n        priorities[:] = -np.inf  # Cannot fit\n\n    # Heuristic 2: Moderate Fill - Reward partial filling\n    remaining_capacity = bins_remain_cap - item\n    moderate_fill = np.logical_and(remaining_capacity >= 0, remaining_capacity <= 0.75 * max_cap)\n    priorities[moderate_fill] += 0.2 * (1- remaining_capacity[moderate_fill]/max_cap) #Reward moderate fill\n\n    # Heuristic 3: Fragmentation Penalty - Sharply penalize near full and near empty\n    nearly_full = np.logical_and(remaining_capacity >= 0, remaining_capacity < 0.1 * max_cap)\n    nearly_empty = np.logical_and(remaining_capacity >= 0, bins_remain_cap < 0.2 * max_cap)\n    priorities[nearly_full] -= 0.4\n    priorities[nearly_empty] -= 0.3 #Slightly less penalty for nearly empty than nearly full\n\n\n    # Heuristic 4: Item Size Dependent Randomness (Cautious)\n    if item > 0.5 * max_cap: #Larger items get less randomness\n        randomness = 0.01 * np.random.rand(len(bins_remain_cap))\n    else:\n         randomness = 0.02 * np.random.rand(len(bins_remain_cap))\n    priorities += randomness\n\n    return priorities",
    "response_id": 3,
    "obj": 13.611886717191862,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Perfect Fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 10  # High priority for perfect fit\n\n    # Heuristic 2: Snug Fit (prioritize bins where remaining capacity is slightly larger than the item)\n    snug_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.2)\n    if np.any(snug_fit_mask):\n        slack = bins_remain_cap[snug_fit_mask] - item\n        priorities[snug_fit_mask] += 5 / (slack + 0.001)  # Smaller slack, higher priority\n\n    # Heuristic 3: Moderate Fill (reward bins that, after placing the item, have a reasonable fill level)\n    remaining_capacity = bins_remain_cap - item\n    moderate_fill_mask = (remaining_capacity >= 0) & (remaining_capacity <= np.max(bins_remain_cap) * 0.75)\n    priorities[moderate_fill_mask] += 2\n\n    # Heuristic 4: Penalize Overflow (severely penalize bins that cannot fit the item)\n    overflow_mask = bins_remain_cap < item\n    priorities[overflow_mask] = -np.inf\n\n    # Heuristic 5: Penalize Fragmentation (penalize bins that, after placing the item, become almost empty)\n    fragmentation_mask = (remaining_capacity >= 0) & (remaining_capacity <= np.max(bins_remain_cap) * 0.1)\n    priorities[fragmentation_mask] -= 3\n\n    # Heuristic 6: Reward Partial Fills (give a small bonus to bins that are already partially filled)\n    occupied_ratio = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)\n    priorities += 0.5 * occupied_ratio\n\n    # Heuristic 7: Item-Size Dependent Adjustment\n    priorities[(bins_remain_cap >= item)] += 0.1 * (item / np.max(bins_remain_cap))\n\n    return priorities",
    "response_id": 4,
    "obj": 5.155564419625055,
    "exec_success": true
  }
]