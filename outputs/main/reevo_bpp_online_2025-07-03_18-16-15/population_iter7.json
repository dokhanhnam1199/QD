[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect Fit: Huge Reward, scaled by item size\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 100 * item\n\n    # 2. Near Fit: Moderate Reward, scaled by item size and inverse slack\n    near_fit = (bins_remain_cap >= item) & (~perfect_fit)\n    if np.any(near_fit):\n        slack = bins_remain_cap[near_fit] - item\n        priorities[near_fit] += (item / (slack + 1e-6))\n\n    # 3. Overflow Penalty: Very harsh penalty\n    overflow = bins_remain_cap < item\n    priorities[overflow] = -np.inf\n\n    # 4. Target Fill Ratio: Gaussian preference\n    fill_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    target_ratio = 0.7  # Encourage bins to be around 70% full\n    gaussian_preference = np.exp(-((fill_ratio - target_ratio)**2) / (2 * 0.15**2)) # wider std\n    priorities += gaussian_preference * item * 0.5 #reduced magnitude\n\n    # 5. Fragmentation Penalty: Exponential decay based on remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    can_fit = bins_remain_cap >= item\n    fragmentation_penalty = np.exp(-5 * (remaining_capacity / bin_capacity)) * can_fit #only if the item can fit in bin.\n    priorities -= fragmentation_penalty * item * 0.2 #reduced magnitude\n\n    # 6. Capacity usage reward: the more capacity used, the better\n    capacity_used_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += capacity_used_ratio * item * 0.1 #small magnitude\n\n    # 7. Small Randomness\n    priorities += np.random.normal(0, 0.01 * item, size=bins_remain_cap.shape)\n\n    return priorities",
    "response_id": 0,
    "obj": 4.108496210610296,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # 1. Feasibility Check\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return np.full_like(bins_remain_cap, -np.inf)  # No fit, no priority\n\n    # 2. Tight Fit Priority\n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1 / (slack + 1e-6)\n\n    # 3. Fragmentation Penalty (Focus on bins nearing full)\n    remaining_capacity = bins_remain_cap - item\n    nearly_full = remaining_capacity < 0.1 * max_cap\n    priorities[fit_mask & nearly_full] -= 0.5 #High penalty\n\n    # 4. Occupancy Reward (Moderate Occupancy)\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    moderate_occupancy = np.logical_and(occupied_ratio > 0.2, occupied_ratio < 0.8) #Target moderate occupancy, less sensitive\n    priorities[moderate_occupancy & fit_mask] += 0.2\n\n    # 5. Item Size Adjustment\n    priorities[fit_mask] *= (1 + 0.2 * item / max_cap) #Smaller items preferred\n\n    return priorities",
    "response_id": 1,
    "obj": 4.876346230554457,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Perfect Fit - Highest priority for bins that fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0\n\n    # Heuristic 2: Remaining Space - Prioritize bins with minimal remaining space after packing.\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += item / (remaining_space + 1e-6)  # Scale priority by item size\n\n    # Heuristic 3: Moderate Capacity - Encourage using bins with moderate capacity relative to item size.\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap <= (item * 3)) & (~perfect_fit)\n    priorities[moderate_capacity] += 10.0\n\n    # Heuristic 4: Large Capacity Penalty - Discourage using bins with significantly more capacity than needed.\n    large_capacity = (bins_remain_cap > item * 5) & can_fit\n    priorities[large_capacity] -= 1.0\n\n    # Heuristic 5: Infeasible Allocation Penalty: Massive negative priority.\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # Heuristic 6: Prioritize more filled bins.\n    max_capacity = np.max(bins_remain_cap)\n    fill_level = (max_capacity - bins_remain_cap) / max_capacity\n    priorities[can_fit] += 5 * fill_level[can_fit]\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Snug Fit Priority: Prioritize bins with minimal slack.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # Cannot fit, so strongly discourage\n\n    # 2. Penalize Extreme Fills: Discourage bins that become nearly full or nearly empty.\n    remaining_capacity = bins_remain_cap - item\n    nearly_full_penalty = np.exp(-5 * (remaining_capacity / bin_capacity)) * (remaining_capacity >= 0)  # Strong penalty for nearly full\n    nearly_empty_penalty = np.exp(-5 * (bins_remain_cap / bin_capacity)) * (remaining_capacity >= 0) * (bins_remain_cap < bin_capacity / 3)  # Moderate penalty for low fill\n    priorities -= nearly_full_penalty + nearly_empty_penalty\n\n    # 3. Reward Partially Filled Bins: Encourage filling bins that are already partially used.\n    occupied_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    bonus = 0.15 * occupied_ratio  # Increased bonus compared to v1\n    priorities += bonus\n\n    # 4. Item Size Adjustment: Preferentially use larger bins for larger items (helps packing better overall).\n    priorities[fit_mask] *= (1 + 0.2 * item / bin_capacity)  # Increased scaling factor\n\n    # 5. Moderate Capacity Bonus: slight preference to bins between 0.25 and 0.75 fill\n    moderate_capacity = np.logical_and(remaining_capacity/bin_capacity > 0.25, remaining_capacity/bin_capacity < 0.75) & (remaining_capacity >= 0)\n    priorities[moderate_capacity] += 0.05\n\n    return priorities",
    "response_id": 3,
    "obj": 28.390506581571607,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n    epsilon = 1e-6\n\n    # Heuristic 1: Feasibility Mask\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(priorities)\n\n    # Heuristic 2: Tight Fit with Normalized Slack\n    slack = bins_remain_cap[fit_mask] - item\n    normalized_slack = slack / max_cap\n    priorities[fit_mask] += 1 / (normalized_slack + epsilon)\n\n    # Heuristic 3: Adaptive Fragmentation Penalty\n    remaining_capacity = bins_remain_cap - item\n    overfill = remaining_capacity < 0\n    remaining_capacity[overfill] = 0 # avoid negative capacity\n    \n    normalized_remaining = remaining_capacity / max_cap\n    fragmentation_penalty = np.exp(-5 * normalized_remaining) \n    priorities -= fragmentation_penalty\n\n    # Heuristic 4: Fill Level Bonus - Synergistic with Item Size\n    fill_level = (max_cap - bins_remain_cap) / max_cap\n    item_size_ratio = item / max_cap\n    fill_bonus = fill_level * (1 - item_size_ratio)  # Smaller items favor fuller bins\n    priorities += 0.2 * fill_bonus\n\n    # Heuristic 5: Moderate Capacity Sweet Spot\n    moderate_mask = np.logical_and(bins_remain_cap >= item, bins_remain_cap <= 0.75 * max_cap)\n    priorities[moderate_mask] += 0.1\n\n    # Heuristic 6: Item Size Specific Adjustments\n    if item_size_ratio > 0.7: # Large items, avoid almost full bins\n        almost_full = np.logical_and(bins_remain_cap >= item, remaining_capacity < 0.1 * max_cap)\n        priorities[almost_full] -= 0.3\n    elif item_size_ratio < 0.2: # Smaller items, prefer to consolidate\n        priorities[fit_mask] += 0.1 * fill_level[fit_mask]\n\n    # Heuristic 7: Capacity Utilization\n    capacity_utilization = (max_cap - bins_remain_cap) / max_cap\n    priorities += 0.05 * capacity_utilization\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect Fit: Huge reward, scaled by item size.\n    perfect_fit_mask = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit_mask):\n        priorities[perfect_fit_mask] += 10 * item / bin_capacity\n\n    # 2. Near Fit: Moderate reward, scaled by remaining capacity after placement.\n    near_fit_mask = (bins_remain_cap > item) & (bins_remain_cap <= item + 0.1 * bin_capacity)\n    if np.any(near_fit_mask):\n        slack = bins_remain_cap[near_fit_mask] - item\n        priorities[near_fit_mask] += 2 * (1 - slack / (0.1 * bin_capacity)) * item / bin_capacity\n\n    # 3. Gaussian-like reward for target fill level (60% full after placement).\n    remaining_capacity = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_capacity) / bin_capacity\n    gaussian_center = 0.6\n    gaussian_width = 0.3\n    gaussian_reward = np.exp(-((fill_level - gaussian_center)**2) / (2 * gaussian_width**2)) * item / bin_capacity\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += gaussian_reward[fit_mask]\n\n    # 4. Fragmentation penalty: Sharp penalty if remaining capacity is small but non-zero. Scaled by item size.\n    fragmentation_threshold = 0.1 * bin_capacity\n    fragmentation_mask = (remaining_capacity > 0) & (remaining_capacity < fragmentation_threshold)\n    priorities[fragmentation_mask] -= 5 * item / bin_capacity\n\n    # 5. Impossible fit: Large negative priority.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "obj": 0.9473474272038294,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect Fit: Big Reward\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6  # Tolerance for floating-point comparisons\n    if np.any(perfect_fit):\n        priorities[perfect_fit] += 100 * item  # Huge reward scaled by item size\n\n    # 2. Near Fit: Moderate Reward, scaled by item size and remaining capacity\n    near_fit = (bins_remain_cap >= item) & (~perfect_fit)\n    if np.any(near_fit):\n        slack = bins_remain_cap[near_fit] - item\n        priorities[near_fit] += (item / bin_capacity) * (1 / (slack + 1e-6))\n\n    # 3. Penalize Overflow: Very Harsh Penalty\n    overflow = bins_remain_cap < item\n    priorities[overflow] = -np.inf\n\n    # 4. Moderate Fills: Gaussian-like preference, focus on avoiding bins being too full/empty\n    fill_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    target_fill_ratio = 0.75  # Target fill ratio, a bit higher\n    gaussian_penalty = np.exp(-((fill_ratio - target_fill_ratio)**2) / (2 * 0.15**2)) # Wider std\n    priorities += gaussian_penalty * item * 0.5  # Reduced impact\n\n    # 5. Fragmentation Penalty: Exponential decay\n    remaining_capacity = bins_remain_cap - item\n    fragmentation_penalty = np.exp(-5 * np.abs(remaining_capacity / bin_capacity)) * (remaining_capacity >= 0) #only if the item can fit in bin.\n    priorities -= fragmentation_penalty * item * 0.2 # Reduced impact\n\n    # 6. Small Randomness\n    priorities += np.random.normal(0, 0.005, size=bins_remain_cap.shape) * item # Smaller randomness\n\n    return priorities",
    "response_id": 6,
    "obj": 18.019545273234947,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    relative_item_size = item / bin_capacity\n\n    # 1. Perfect Fit: Huge reward, scaled by item size.\n    perfect_fit_mask = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit_mask):\n        priorities[perfect_fit_mask] += 100 * relative_item_size  # Substantially increase the reward of perfect fit.\n\n    # 2. Near Fit: Moderate reward, scaled by remaining capacity after placement. Defined more strictly.\n    near_fit_threshold = 0.05  # Maximum allowed slack as a fraction of bin capacity\n    near_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap <= item + near_fit_threshold * bin_capacity)\n    if np.any(near_fit_mask):\n        slack = bins_remain_cap[near_fit_mask] - item\n        priorities[near_fit_mask] += 20 * (1 - slack / (near_fit_threshold * bin_capacity)) * relative_item_size\n\n    # 3. Gaussian-like reward for moderate fills (peaks at 60% full after placement).\n    remaining_capacity = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_capacity) / bin_capacity  # Ratio of fill level.\n    gaussian_center = 0.6  # Favor bins that will be 60% full.\n    gaussian_width = 0.2  # Standard deviation of gaussian\n    gaussian_reward = np.exp(-((fill_level - gaussian_center) ** 2) / (2 * gaussian_width ** 2)) * relative_item_size\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += gaussian_reward[fit_mask]\n\n    # 4. Fragmentation penalty: Sharp penalty if remaining capacity is small but non-zero.  Scaled by item size.\n    fragmentation_threshold = 0.1 * bin_capacity  # Small remaining capacity.\n    fragmentation_mask = (remaining_capacity > 0) & (remaining_capacity < fragmentation_threshold)\n    priorities[fragmentation_mask] -= 50 * relative_item_size\n\n    # 5. Impossible fit: Large negative priority.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf\n\n    # 6. Moderate Capacity Bonus: Small bonus for bins that are moderately filled before adding an item\n    moderate_capacity_lower = 0.25 * bin_capacity\n    moderate_capacity_upper = 0.75 * bin_capacity\n    moderate_capacity = np.logical_and(bins_remain_cap >= moderate_capacity_lower, bins_remain_cap <= moderate_capacity_upper) & fit_mask\n    priorities[moderate_capacity] += 0.01\n\n    # 7. Empty bin bonus: Prefer to fill empty bins up to a point\n    empty_bin_threshold = 0.99 * bin_capacity\n    nearly_empty = bins_remain_cap >= empty_bin_threshold\n    priorities[nearly_empty] += 0.02\n\n    return priorities",
    "response_id": 7,
    "obj": 0.9074591144794598,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # 1. Feasibility Check and Slack-Based Priority\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return -np.inf * np.ones_like(bins_remain_cap)  # No feasible bin\n    \n    slack = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n\n    # 2. Fill Ratio Optimization\n    fill_ratio = (max_cap - bins_remain_cap) / max_cap\n    \n    # 2.1 Reward bins that are not empty\n    priorities[fit_mask] += 0.1 * fill_ratio[fit_mask]\n\n    # 2.2 Penalize too empty bins\n    too_empty = bins_remain_cap > 0.75 * max_cap\n    priorities[too_empty] -= 0.05\n\n    # 3. Item Size Influence (Interaction with Fill Ratio)\n    # Favor smaller items for bins with moderate fill\n    moderate_fill = (fill_ratio > 0.25) & (fill_ratio < 0.75) & fit_mask\n    priorities[moderate_fill] += 0.2 * (1 - item / max_cap) # smaller item get higher priority if the bin is moderately filled.\n\n    # 4. Balance between Slack and Fill\n    # If slack is very small, we want to put this item in\n    small_slack = (slack / max_cap < 0.1) & fit_mask\n    priorities[small_slack] += 0.1\n\n    return priorities",
    "response_id": 8,
    "obj": 4.01874750698045,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Tight Fit Prioritization: Strong reward for small slack.  If it doesn't fit, negative infinity\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] += 50 / (slack + 0.0001)\n    else:\n        priorities[:] = -np.inf\n\n    # 2. Bin Filling: Reward bins that are already somewhat filled.\n    filled_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 10 * filled_ratio\n\n    # 3. Moderate Capacity: Gaussian-like function to favor moderate remaining capacity.\n    capacity_ratio = bins_remain_cap / bin_capacity\n    priorities += 8 * np.exp(-((capacity_ratio - 0.5) ** 2) / 0.08)\n\n    # 4. Fragmentation Penalty: Sharply penalize bins becoming near full.\n    near_full_threshold = 0.2 * bin_capacity\n    near_full_mask = (bins_remain_cap - item) < near_full_threshold\n    priorities[near_full_mask] -= 20\n\n    # 5. Empty Bin Preference (for larger items): Discourage filling near-empty bins with large items.\n    near_empty_threshold = 0.9 * bin_capacity\n    near_empty_mask = bins_remain_cap > near_empty_threshold\n    item_ratio = item / bin_capacity\n    if item_ratio > 0.5:\n        priorities[near_empty_mask] -= 15 * item_ratio  # Higher penalty for larger items\n\n    # 6. Item Size Adaptation: Adjust priorities based on item size.\n    if item_ratio > 0.7:\n        # Very large item: strongly prioritize almost full bins\n        almost_full_mask = filled_ratio > 0.7\n        priorities[almost_full_mask] += 30\n\n    elif item_ratio < 0.1:\n        # Very small item: avoid creating tiny fragments.  Slightly penalize bins with small remaining space *after* adding the item.\n        post_fill_remaining = bins_remain_cap - item\n        small_space_mask = (post_fill_remaining > 0) & (post_fill_remaining < 0.15 * bin_capacity)\n        priorities[small_space_mask] -= 12\n    elif item_ratio > 0.3 and item_ratio <=0.6:\n        priorities += 7 * np.exp(-((capacity_ratio - 0.5) ** 2) / 0.08) # Gaussian bonus\n\n    return priorities",
    "response_id": 9,
    "obj": 2.8320702034304044,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: Perfect/Near Fit Reward (scaled by item size)\n    slack = bins_remain_cap - item\n    perfect_fit_bonus = np.exp(-np.abs(slack) / (0.1 * bin_capacity)) * (slack >= 0) * item\n    priorities += 10 * perfect_fit_bonus\n\n    # Heuristic 2: Target Fill Level (Gaussian)\n    target_fill = 0.75 * bin_capacity  # Aim for 75% fill\n    fill_level = bin_capacity - bins_remain_cap\n    gaussian_reward = np.exp(-((fill_level - target_fill) ** 2) / (2 * (0.2 * bin_capacity) ** 2))\n    priorities += gaussian_reward\n\n    # Heuristic 3: Fragmentation Penalty (sharp)\n    remaining_capacity = bins_remain_cap - item\n    fragmentation_penalty = -100 * (remaining_capacity < 0.1 * bin_capacity) * (remaining_capacity >= 0)\n    priorities += fragmentation_penalty\n\n    # Heuristic 4: Controlled Randomness (proportional to item size)\n    randomness = np.random.rand(len(bins_remain_cap)) * 0.01 * item\n    priorities += randomness\n\n    # Heuristic 5: First-Fit consideration (avoid many almost empty bins)\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        priorities[~fit_mask] = -np.inf\n    else:\n        priorities[:] = -np.inf\n\n    # Heuristic 6: Prioritize item fitting if bin is below a threshold\n    threshold = bin_capacity * 0.25\n    priorities[bins_remain_cap < threshold] += 5.0\n\n    return priorities",
    "response_id": 0,
    "obj": 5.165536497806138,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response1.txt_stdout.txt",
    "code_path": "problem_iter7_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect/Near Fit Reward: Exponential function for near fit, scaled by item size\n    slack = bins_remain_cap - item\n    near_fit_mask = slack >= 0\n    if np.any(near_fit_mask):\n      priorities[near_fit_mask] += item * np.exp(-5 * slack[near_fit_mask] / bin_capacity)\n\n\n    # 2. Target Fill Level: Gaussian distribution around optimal fill level (e.g., 75%)\n    target_fill = 0.75 * bin_capacity\n    fill_level = bin_capacity - bins_remain_cap\n    priorities += np.exp(-((fill_level - target_fill) ** 2) / (2 * (bin_capacity * 0.2) ** 2))\n\n    # 3. Fragmentation Penalty: Sharp penalty for small remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    frag_mask = (remaining_capacity > 0) & (remaining_capacity < 0.1 * bin_capacity)\n    priorities[frag_mask] -= 0.5 * item #Significant penalty. Item size based to adjust penalty.\n\n    # 4. Controlled Randomness (Exploration): Add noise proportional to item size\n    priorities[near_fit_mask] += 0.01 * item * np.random.randn(np.sum(near_fit_mask))\n\n\n    # 5. Avoid placing items to bins that can't fit\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n\n    return priorities",
    "response_id": 1,
    "obj": 4.646988432389324,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response2.txt_stdout.txt",
    "code_path": "problem_iter7_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n    \n    # 1. Perfect/Near Fits: Gaussian centered around perfect fit\n    slack = bins_remain_cap - item\n    gaussian_fit = np.exp(-((slack) ** 2) / (2 * (0.1 * item) ** 2)) * (slack >= 0)\n    priorities += gaussian_fit * item * 2 # Scale by item size\n\n    # 2. Target Fill Level: Exponential penalty for deviating from target fill\n    target_fill = 0.75 * bin_capacity # Aim for 75% fill\n    remaining_after_fill = (bins_remain_cap - item) \n    fill_deviation = np.abs(remaining_after_fill - (bin_capacity - target_fill)) * (slack >= 0)\n    exponential_penalty = np.exp( - (fill_deviation / (0.2 * bin_capacity)))\n    priorities -= exponential_penalty * item # Scale by item size\n\n    # 3. Fragmentation Penalty: Sharp penalty for small remaining space\n    small_space = (remaining_after_fill > 0) & (remaining_after_fill < 0.1 * bin_capacity)\n    priorities[small_space] -= 5 * item  # Very high penalty to avoid fragments\n\n    # 4. Controlled Randomness (Exploration)\n    randomness = np.random.normal(0, 0.01 * item, size=bins_remain_cap.shape)\n    priorities += randomness\n\n    # 5. Item size bonus/penalty. Avoid placing large items into near full bin if possible.\n    near_full = (bins_remain_cap > item) & (bins_remain_cap < 1.2*item)\n    if item > 0.5 * bin_capacity:\n        priorities[near_full] -= item\n\n    #6. If item can't fit, apply negative infinity to prioritize creating a new bin\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 2,
    "obj": 79.18827283605904,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) #Assuming all bins have same capacity\n\n    # 1. Perfect/Near Fit Reward (Scaled by item size)\n    slack = bins_remain_cap - item\n    perfect_fit_bonus = np.exp(- (slack**2) / (2 * (0.05 * bin_capacity)**2)) * (slack >= 0) * item #Gaussian around 0, scaled by item size\n    priorities += perfect_fit_bonus\n\n    # 2. Target Fill Level (Gaussian Penalty) - avoid half empty bins\n    target_fill = 0.75 * bin_capacity # Fill bins until around 75%\n    remaining_after_fill = bins_remain_cap - item\n    fill_penalty = -np.exp(- ((target_fill - (bin_capacity - remaining_after_fill))**2) / (2 * (0.2 * bin_capacity)**2)) * (remaining_after_fill >= 0)\n    priorities += fill_penalty\n\n    # 3. Fragmentation Penalty (Sharp Penalty if remaining is less than some threshold)\n    frag_threshold = 0.1 * bin_capacity\n    fragmentation_penalty = -10 * (remaining_after_fill < frag_threshold) * (remaining_after_fill >=0) * item #Sharp penalty, scaled by item size\n\n    priorities += fragmentation_penalty\n\n    # 4. Controlled Randomness (Exploration)\n    randomness = np.random.normal(0, 0.01 * item, size=bins_remain_cap.shape)  # Small noise, scaled by item size\n    priorities += randomness\n\n    # 5. Infeasibility Mask\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities",
    "response_id": 3,
    "obj": 53.8193059433586,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Perfect/Near Fit: Gaussian centered around perfect fit. Scaled by item size.\n    perfect_fit_target = item\n    fit_deviation = np.abs(bins_remain_cap - perfect_fit_target)\n    priorities = item * np.exp(-0.5 * (fit_deviation / (0.1 * bin_capacity))**2)  # Gaussian, scaled by item\n\n    # 2. Fragmentation Penalty: Exponential penalty for small remaining capacity. Sharper penalty.\n    remaining_capacity = bins_remain_cap - item\n    fragmentation_penalty = np.zeros_like(bins_remain_cap)\n    fragmentation_mask = remaining_capacity > 0\n    fragmentation_penalty[fragmentation_mask] = np.exp(-10 * remaining_capacity[fragmentation_mask] / bin_capacity)\n    priorities -= fragmentation_penalty * item #scale penalty by item size\n\n    # 3. Controlled Randomness: Add noise proportional to item size for exploration.\n    noise = 0.01 * item * np.random.randn(len(bins_remain_cap))\n    priorities += noise\n\n    # 4. Infeasibility: Heavily penalize bins that cannot fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    #5. Prioritize bins that are somewhat occupied.\n    occupied_ratio = (bin_capacity - bins_remain_cap)/bin_capacity\n    priorities += 0.05 * occupied_ratio\n\n    return priorities",
    "response_id": 4,
    "obj": 5.115676106900674,
    "exec_success": true
  }
]