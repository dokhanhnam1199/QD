[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Penalize bins that become too full after insertion to avoid fragmentation\n    future_capacity = bins_remain_cap - item\n    penalty_mask = (future_capacity > 0)  # Only penalize if it fits\n    if np.any(penalty_mask):\n        fullness = future_capacity[penalty_mask] / np.max(bins_remain_cap)\n        penalty = np.exp(-10 * (1 - fullness))  # Exponential penalty as bins get fuller, centered around FULL\n        priorities[penalty_mask] = priorities[penalty_mask] - penalty\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled (reduces number of partially-filled bins)\n    occupied_ratio = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)\n    bonus = 0.1 * occupied_ratio\n    priorities = priorities + bonus\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit the item, return a very low priority for all bins.\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # 2. Calculate remaining capacity after placing the item (only for feasible bins)\n    remaining_capacity = bins_remain_cap - item\n\n    # 3. Reward bins with smaller remaining capacity (First-Fit Decreasing-like), but only if feasible\n    priorities[feasible_bins] = 1 / (remaining_capacity[feasible_bins] + 1e-9)  # Add small constant to avoid division by zero\n\n    # 4. Big reward for almost full bins if item fits. Make threshold relative to item size.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap <= item + item * 0.2)  # item+threshold, relative threshold\n    priorities[almost_full] = 1000\n\n    # 5. Negative reward for bins with capacity much larger than the item size,\n    #    trying to avoid spreading items too thin. Threshold also relative to item size.\n    wasteful = (bins_remain_cap > item * 2) & feasible_bins  # threshold * item, relative threshold\n    priorities[wasteful] = -1\n\n    return priorities",
    "response_id": 1,
    "obj": 4.317909852413238,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n    \n    feasible_mask = ~infeasible_mask\n    \n    # 2. Tight Fit: Prioritize bins that result in smaller remaining capacity\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -remaining_capacity\n    \n    # 3. Prevent Near-Empty Bins:\n    #   Slightly penalize bins that would become almost empty after placing the item.\n    almost_empty_threshold = 0.2  # As a ratio of the bin capacity.  Adjust as needed.\n    bin_capacity = np.max(bins_remain_cap) # Assume all bins have the same capacity, take max as the capacity\n    almost_empty_mask = feasible_mask & (remaining_capacity < almost_empty_threshold * bin_capacity)\n    priorities[almost_empty_mask] -= 0.1  # Small penalty\n\n    # 4. Discourage Nearing-Full Capacity:\n    #   Penalize bins that are close to full *before* placing the item\n    nearing_full_threshold = 0.9\n    nearing_full_mask = feasible_mask & (bins_remain_cap / bin_capacity > nearing_full_threshold)\n    priorities[nearing_full_mask] -= 0.5 # Medium penalty\n\n    # 5. Bonus for almost full bins before placing the item\n    almost_full_before_place = 0.8\n    almost_full_before_mask = feasible_mask & (bins_remain_cap / bin_capacity > almost_full_before_place) & (bins_remain_cap / bin_capacity <= nearing_full_threshold)\n    priorities[almost_full_before_mask] +=0.3\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, prioritize bins that can actually fit the item.\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        # If no bins can fit item, return negative infinity for all.\n        return np.full_like(bins_remain_cap, fill_value=-np.inf)\n\n    # For bins that can fit the item, calculate a score based on remaining capacity.\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n\n    # Higher priority to bins where the remaining capacity is small, but not too small.\n    # The inverse of remaining capacity encourages tighter packing.  Adding a small constant avoids division by zero.\n    priorities[valid_bins] = 1.0 / (remaining_after_fit + 0.0001)\n\n    # Also include bin utilization by incorporating the size of the item relative to capacity\n    # This encourages selecting bins where the item makes a significant contribution to filling.\n    priorities[valid_bins] += item / bins_remain_cap[valid_bins]\n\n    # Further improve packing by considering the initial fullness of the bin.\n    # A bin that is already relatively full might be a better candidate.  Scale down to make less significant than the others\n    initial_fullness = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)\n    priorities[valid_bins] += 0.05 * initial_fullness[valid_bins]\n\n    # Add a heuristic that attempts to balance the load across bins.\n    # Calculate the standard deviation of the remaining capacities.  Penalize bins that\n    # would increase the standard deviation too much, promoting more balanced use.\n\n    std_dev_before = np.std(bins_remain_cap)\n    temp_bins = bins_remain_cap.copy()\n    temp_bins[valid_bins] -= item\n    std_dev_after = np.std(temp_bins)\n    priorities[valid_bins] -= 0.001*(std_dev_after - std_dev_before) #subtract, we want smaller std_dev\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 43, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'subtract' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1:  Bins that can accommodate the item perfectly get highest priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000\n\n    # Heuristic 2: Bins where item fits with least remaining space get higher priority.\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += 1.0 / (remaining_space + 0.00001)\n\n    # Heuristic 3: Moderate capacity bins get higher priority if perfect fit isn't an option.\n    max_cap = np.max(bins_remain_cap)\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap < (max_cap * 0.75)) & (~perfect_fit)\n    priorities[moderate_capacity] += 10\n\n    # Heuristic 4: Give preference to bins that are already partially filled\n    already_filled = (bins_remain_cap < max_cap) & (bins_remain_cap >= item)\n    priorities[already_filled] += 5\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same max capacity\n\n    # Heuristic 1: First-Fit Decreasing-like behavior with a slight modification.\n    # Prioritize bins that can fit the item relatively snugly, but avoid overly tight fits.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Prioritize based on slack, but dampen the effect for very small slacks\n        priorities[fit_mask] = 1 / (slack + 0.01 * max_capacity)  # Adds a bit of tolerance\n    else:\n        priorities[:] = -np.inf  # Item cannot fit, force new bin opening\n\n    # Heuristic 2: Fragmentation avoidance using a sigmoid function.  Penalize bins\n    # that lead to small remaining capacity, but allow some small capacity remaining.\n    remaining_ratio = (bins_remain_cap - item) / max_capacity\n    remaining_ratio[remaining_ratio < 0] = -np.inf # can not fit\n\n    # sigmoid penalty\n    penalty = 1 / (1 + np.exp(-10 * (remaining_ratio - 0.1))) # try to make remaining ratio around 0.1\n\n    priorities = priorities - penalty\n\n\n    # Heuristic 3: Occupancy bonus.  Reward bins that are already partially full.\n    occupancy_ratio = (max_capacity - bins_remain_cap) / max_capacity\n    bonus = 0.2 * occupancy_ratio * (occupancy_ratio > 0) # only gives bonus for partially filled bins\n    priorities = priorities + bonus\n\n\n    # Heuristic 4: Introduce a small random factor to break ties and explore different bin assignments.\n    priorities = priorities + 0.01 * np.random.rand(len(bins_remain_cap))\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Identify bins that can fit the item.\n    fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, assign equal priority to all to allow placement in a new bin.\n    if not np.any(fit_mask):\n        return np.ones_like(bins_remain_cap)\n\n    # Rule 2: Base priority for bins that can fit the item.\n    priorities[fit_mask] = 1.0\n\n    # Rule 3: Prioritize bins that are already somewhat full. Higher fill level gets higher priority.\n    # This encourages using existing bins rather than opening new ones.\n    priorities[fit_mask] += (1 - bins_remain_cap[fit_mask] / np.max(bins_remain_cap))\n\n    # Rule 4: Penalize wasted space. Bins with remaining capacity close to the item size are preferred.\n    # This is similar to Best Fit, but implemented as a priority boost.\n    remaining_capacity_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1.0 / (remaining_capacity_after_fit + 0.00001)  # Avoid division by zero\n\n    # Rule 5: Further boost priority of bins that have been used before\n    used_mask = bins_remain_cap < np.max(bins_remain_cap)  # Assuming max capacity is the initial capacity\n    priorities[fit_mask & used_mask] += 0.5  # A small boost for used bins\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1:  Bins that can accommodate the item perfectly get highest priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # Arbitrarily high value for perfect fit\n\n    # Heuristic 2: Bins where item fits with least remaining space get higher priority.\n    # But only consider those bins where the item can fit.\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):  # Avoid division by zero\n      remaining_space = bins_remain_cap[can_fit] - item\n      # Use a more nuanced scoring based on remaining space.  Scale by item size.\n      priorities[can_fit] = item / (remaining_space + 0.00001)  # Smaller remainders get higher scores, scaled by item size.\n\n    # Heuristic 3: Moderate capacity bins get higher priority if perfect fit isn't an option.\n    # This is a bit of exploration: avoid filling very small and large capacity bins.\n    # Mod capacity defined relative to the item size, not the absolute max bin size.\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap < (item * 3)) & (~perfect_fit)\n    priorities[moderate_capacity] += 10  # Add a moderate amount to moderate capacity bins.\n\n    #Heuristic 4: Slightly penalize bins with *much* more capacity than needed.  This encourages filling bins more fully.\n    large_capacity = (bins_remain_cap > item * 5) & can_fit\n    priorities[large_capacity] -= 1 #Small penalty.\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Combines best-fit, first-fit, and nearly-full bin prioritization with adaptive penalties for unfit items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing heuristic component: prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority to bins that can fit\n\n    # Best Fit heuristic component: prioritize bins with smallest remaining space *after* adding the item.\n    remaining_space_after_fit = bins_remain_cap[fit_mask] - item\n\n    if remaining_space_after_fit.size > 0:\n        best_fit_priority = 1 / (remaining_space_after_fit + 1e-9)  # avoid division by zero.  Inverse of space, higher value == smaller space left after adding.\n        indices_fit = np.where(fit_mask)[0]  # get indices to update\n        priorities[indices_fit] += best_fit_priority\n\n    # Introduce a \"nearly full\" bonus - prioritizes filling bins that are mostly full *before* addition.\n    nearly_full_threshold = 0.75  # Threshold as a fraction of total bin size\n    nearly_full_mask = bins_remain_cap > 0\n    ratio = bins_remain_cap / (bins_remain_cap + item)\n    near_full_bonus = (ratio > nearly_full_threshold) * fit_mask #Only consider nearly full if item fits\n    priorities += near_full_bonus * 2 # Arbitrary magnitude 2, tuned. Added only if item can fit.\n\n    #Adaptive penalty for unfit items\n    if not np.any(fit_mask):\n        #Penalize based on how much the item exceeds capacity, but favor bins with some capacity\n        penalty = -(item - bins_remain_cap)\n        penalty[bins_remain_cap <= 0] = -np.inf  # Avoid empty bins unless absolutely necessary\n        priorities = penalty\n\n    return priorities",
    "response_id": 8,
    "obj": 2.911846828879143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: identify bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit the item, return all zeros, indicating no priority.\n        return priorities\n\n    # Calculate remaining capacity after placing the item in feasible bins\n    remaining_capacity_after_add = bins_remain_cap[feasible_bins] - item\n\n    # Assign priorities based on remaining capacity: lower remaining capacity gets higher priority.\n    # Use inverse of remaining capacity to prioritize bins with minimal waste\n    priorities[feasible_bins] = 1 / (remaining_capacity_after_add + 1e-9)\n\n    # Normalize priorities to make them more comparable\n    priorities[feasible_bins] /= np.sum(priorities[feasible_bins])\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]