```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First Fit Decreasing heuristic component: prefer bins that can fit the item
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] += 1  # Give a base priority to bins that can fit

    # Best Fit heuristic component: prioritize bins with smallest remaining space *after* adding the item.
    remaining_space_after_fit = bins_remain_cap[fit_mask] - item
    # If no bins can fit, the next part is skipped, priorities remain zero

    if remaining_space_after_fit.size > 0:
        best_fit_priority = 1 / (remaining_space_after_fit + 1e-9) # avoid division by zero.  Inverse of space, higher value == smaller space left after adding.
        indices_fit = np.where(fit_mask)[0]  #get indices to update
        priorities[indices_fit] += best_fit_priority  # add the best_fit priority to appropriate bins

    # Introduce a "nearly full" bonus - prioritizes filling bins that are mostly full *before* addition.
    nearly_full_threshold = 0.9 # Threshold as a fraction of total bin size, tuning parameter.

    nearly_full_mask = bins_remain_cap > 0 # bins must exist to calculate ratio
    ratio = (bins_remain_cap[nearly_full_mask] / (bins_remain_cap[nearly_full_mask] + item)) # capacity remaining/total capacity if packed.  Prioritize bigger changes
    near_full_bonus = (ratio > nearly_full_threshold)
    indices_nearly_full = np.where(nearly_full_mask)[0]

    priorities[indices_nearly_full] += near_full_bonus * 2   #arbitrary magnitude 2, tuned

    # Penalize bins where item is significantly larger than the available space if no suitable bin can fit
    if not np.any(fit_mask):
        priority_unfit = -(item - bins_remain_cap)
        priority_unfit[bins_remain_cap == 0] = -np.inf #never select empty bins when no fit is available
        priorities = priority_unfit

    return priorities
```
