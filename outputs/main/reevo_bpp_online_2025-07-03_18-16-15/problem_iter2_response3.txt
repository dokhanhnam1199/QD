```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First, prioritize bins that can actually fit the item.
    valid_bins = bins_remain_cap >= item
    if not np.any(valid_bins):
        # If no bins can fit item, return negative infinity for all.
        return np.full_like(bins_remain_cap, fill_value=-np.inf)

    # For bins that can fit the item, calculate a score based on remaining capacity.
    remaining_after_fit = bins_remain_cap[valid_bins] - item

    # Higher priority to bins where the remaining capacity is small, but not too small.
    # The inverse of remaining capacity encourages tighter packing.  Adding a small constant avoids division by zero.
    priorities[valid_bins] = 1.0 / (remaining_after_fit + 0.0001)

    # Also include bin utilization by incorporating the size of the item relative to capacity
    # This encourages selecting bins where the item makes a significant contribution to filling.
    priorities[valid_bins] += item / bins_remain_cap[valid_bins]

    # Further improve packing by considering the initial fullness of the bin.
    # A bin that is already relatively full might be a better candidate.  Scale down to make less significant than the others
    initial_fullness = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)
    priorities[valid_bins] += 0.05 * initial_fullness[valid_bins]

    # Add a heuristic that attempts to balance the load across bins.
    # Calculate the standard deviation of the remaining capacities.  Penalize bins that
    # would increase the standard deviation too much, promoting more balanced use.

    std_dev_before = np.std(bins_remain_cap)
    temp_bins = bins_remain_cap.copy()
    temp_bins[valid_bins] -= item
    std_dev_after = np.std(temp_bins)
    priorities[valid_bins] -= 0.001*(std_dev_after - std_dev_before) #subtract, we want smaller std_dev

    return priorities
```
