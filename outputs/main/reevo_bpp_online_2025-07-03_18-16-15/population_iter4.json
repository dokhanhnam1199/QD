[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: Tight Fit Prioritization\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] += 20 / (slack + 0.001)  # Higher priority for tighter fits - SHARPENED\n    else:\n        priorities[:] = -np.inf  # Cannot fit, assign lowest priority\n\n    # Heuristic 2: Filling Bins - Reward bins that are already somewhat filled\n    filled_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 7 * filled_ratio # SHARPENED\n\n    # Heuristic 3: Moderate Capacity - Prefer bins with moderate remaining capacity\n    capacity_ratio = bins_remain_cap / bin_capacity\n    priorities += 5 * np.exp(-((capacity_ratio - 0.5) ** 2) / 0.05) # Gaussian-like bonus - ADJUSTED WIDTH\n\n    # Heuristic 4: Penalty for Near-Full Bins (Avoid Excessive Fragmentation)\n    near_full_threshold = 0.15 * bin_capacity # Slightly increased threshold\n    near_full_mask = (bins_remain_cap - item) < near_full_threshold\n    priorities[near_full_mask] -= 12  # Substantial penalty for bins becoming near full - SHARPENED\n\n    # Heuristic 5: Penalty for Near-Empty Bins (Avoid Spreading Items Too Thinly)\n    near_empty_threshold = 0.85 * bin_capacity #Slightly decreased threshold\n    near_empty_mask = bins_remain_cap > near_empty_threshold\n    priorities[near_empty_mask] -= 5 # SHARPENED\n\n    # Heuristic 6: Item Size Adaptation\n    item_size_ratio = item / bin_capacity\n    if item_size_ratio > 0.6:  # Large item, prioritize partially filled bins more - ADJUSTED THRESHOLD\n        priorities += 6 * filled_ratio # SHARPENED\n    elif item_size_ratio < 0.15:  # Small item, penalize almost full bins - ADJUSTED THRESHOLD\n        near_full_mask = (bins_remain_cap - item) < 0.2 * bin_capacity\n        priorities[near_full_mask] -= 8 # SHARPENED\n    elif item_size_ratio > 0.3 and item_size_ratio <= 0.6: # Moderate Item, favor moderate capacity bins\n        priorities += 4 * np.exp(-((capacity_ratio - 0.5) ** 2) / 0.05)\n\n\n    return priorities",
    "response_id": 0,
    "obj": 3.490227363382529,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_cap = np.max(bins_remain_cap)\n\n    # Heuristic 1: Tight Fit Priority\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # If it doesn't fit, don't consider the bin\n\n    # Heuristic 2: Fragmentation Penalty\n    remaining_capacity = bins_remain_cap - item\n    too_full_penalty = np.exp(-10 * (remaining_capacity / max_cap)) * (remaining_capacity >= 0)  # Penalize bins that are nearly full after insertion\n    too_empty_penalty = np.exp(-10 * (bins_remain_cap / max_cap)) * (remaining_capacity >= 0) * (bins_remain_cap < max_cap / 2)  # Penalize bins with low fill\n\n    priorities -= too_full_penalty\n    priorities -= too_empty_penalty\n\n    # Heuristic 3: Reward Partially Filled Bins\n    occupied_ratio = (max_cap - bins_remain_cap) / max_cap\n    bonus = 0.1 * occupied_ratio\n    priorities += bonus\n\n    # Heuristic 4: Item Size Adjustment (favor using smaller items in partially filled bins)\n    priorities[fit_mask] *= (1 + 0.5*item / max_cap)\n\n    #Heuristic 5: Moderate Capacity Bonus\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < max_cap*0.75)\n    priorities[moderate_capacity] += 0.05\n\n    return priorities",
    "response_id": 1,
    "obj": 0.7578779417630658,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # Heuristic 1: Tight Fit - Prioritize bins where the item fits snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] += 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        return -np.inf * np.ones_like(priorities)\n\n\n    # Heuristic 2: Fill Bins - Reward bins that are already partially full.\n    occupancy = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.2 * occupancy\n\n    # Heuristic 3: Moderate Capacity - Prioritize bins with moderate remaining capacity. More Aggressive\n    moderate_mask = (bins_remain_cap > 0.3 * bin_capacity) & (bins_remain_cap < 0.7 * bin_capacity)\n    priorities[moderate_mask] += 0.4\n\n    # Heuristic 4: Penalize Near-Full - Heavily penalize bins that will become nearly full after adding the item. Sharper\n    remaining_after_add = bins_remain_cap - item\n    near_full_penalty = np.exp(-100 * (0.05 - remaining_after_add/bin_capacity)) # high penalty if remaining is less than 5%\n    near_full_penalty[remaining_after_add > 0.05 * bin_capacity] = 0\n    priorities -= near_full_penalty\n\n    # Heuristic 5: Penalize Near-Empty - Penalize bins that are almost empty. Sharper\n    near_empty_penalty = np.exp(-100 * (bins_remain_cap/bin_capacity - 0.95))\n    near_empty_penalty[bins_remain_cap/bin_capacity < 0.95] = 0\n    priorities -= near_empty_penalty\n\n    # Heuristic 6: Item Size Adaptation - Adjust penalties based on item size. More Aggressive\n    item_ratio = item / bin_capacity\n    if item_ratio > 0.5: # for big item, we want to fill any bin to reduce overall number of bins.\n        priorities += 0.2\n    elif item_ratio < 0.2: # smaller items, use tight fit more\n        priorities[fit_mask] += 0.2 / (slack + 1e-6)\n\n    # Heuristic 7: Inverse Capacity - Use inverse of remaining capacity as a finer selection mechanism.\n    priorities += 0.05 / (bins_remain_cap + 1e-6)\n\n    # Heuristic 8: Balance occupancy for larger items.\n    if item_ratio > 0.3:\n        occupancy_penalty = np.abs(occupancy - np.mean(occupancy))\n        priorities -= 0.1 * occupancy_penalty\n\n    return priorities",
    "response_id": 2,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same max capacity\n\n    # Heuristic 1: First-Fit Decreasing-like behavior with a slight modification.\n    # Prioritize bins that can fit the item relatively snugly, but avoid overly tight fits.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        # Prioritize based on slack, but dampen the effect for very small slacks\n        priorities[fit_mask] = 1 / (slack + 0.01 * max_capacity)  # Adds a bit of tolerance\n    else:\n        priorities[:] = -np.inf  # Item cannot fit, force new bin opening\n\n    # Heuristic 2: Fragmentation avoidance using a sigmoid function.  Penalize bins\n    # that lead to small remaining capacity, but allow some small capacity remaining.\n    remaining_ratio = (bins_remain_cap - item) / max_capacity\n    remaining_ratio[remaining_ratio < 0] = -np.inf # can not fit\n\n    # sigmoid penalty\n    penalty = 1 / (1 + np.exp(-10 * (remaining_ratio - 0.1))) # try to make remaining ratio around 0.1\n\n    priorities = priorities - penalty\n\n\n    # Heuristic 3: Occupancy bonus.  Reward bins that are already partially full.\n    occupancy_ratio = (max_capacity - bins_remain_cap) / max_capacity\n    bonus = 0.2 * occupancy_ratio * (occupancy_ratio > 0) # only gives bonus for partially filled bins\n    priorities = priorities + bonus\n\n\n    # Heuristic 4: Introduce a small random factor to break ties and explore different bin assignments.\n    priorities = priorities + 0.01 * np.random.rand(len(bins_remain_cap))\n\n    # Heuristic 5: Item size aware adjustment\n    item_ratio = item / max_capacity\n    if item_ratio > 0.5:\n        # Large item, slightly prefer more empty bins\n        priorities += 0.1 * (1 - occupancy_ratio)\n    else:\n        # Small item, slightly prefer more filled bins\n        priorities += 0.1 * occupancy_ratio\n    \n    # Normalize priorities to [0, 1] to ensure stability and prevent dominance\n    min_priority = np.min(priorities[priorities != -np.inf])\n    max_priority = np.max(priorities[priorities != -np.inf])\n    \n    if max_priority > min_priority:  # Avoid division by zero if all bins have -inf priority\n        priorities[priorities != -np.inf] = (priorities[priorities != -np.inf] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prioritize perfect fits\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000\n\n    # Heuristic 2: Reward bins where item fits with the least waste, scaled by item size\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] += item / (remaining_space + 1e-6)  # Add a small constant to avoid division by zero\n\n    # Heuristic 3: Encourage filling bins moderately (relative to item size)\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap < (3 * item)) & can_fit & (~perfect_fit)\n    priorities[moderate_capacity] += 10\n\n    # Heuristic 4: Penalize large waste\n    large_waste = (bins_remain_cap > 5 * item) & can_fit\n    priorities[large_waste] -= 5  # Moderate penalty\n\n    #Heuristic 5: Slightly reward bins that are close to being full after adding the item\n    almost_full = can_fit & (bins_remain_cap - item > 0) & (bins_remain_cap - item <= item * 0.2)\n    priorities[almost_full] += 20\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Perfect Fit - Highest priority for bins that fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000.0\n\n    # Heuristic 2: Remaining Space - Prioritize bins with minimal remaining space after packing.\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        priorities[can_fit] = item / (remaining_space + 1e-6)  # Scale priority by item size\n\n    # Heuristic 3: Moderate Capacity - Encourage using bins with moderate capacity relative to item size.\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap <= (item * 3)) & (~perfect_fit)\n    priorities[moderate_capacity] += 10.0\n\n    # Heuristic 4: Large Capacity Penalty - Discourage using bins with significantly more capacity than needed.\n    large_capacity = (bins_remain_cap > item * 5) & can_fit\n    priorities[large_capacity] -= 1.0\n\n    # Heuristic 5: Infeasible Allocation Penalty: Massive negative priority.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Feasibility: Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    feasible_mask = ~infeasible_mask\n\n    # 2. Tight Fit: Prioritize bins that result in smaller remaining capacity\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = bin_capacity - remaining_capacity # higher is better, scale to bin capacity\n\n    # 3. Prevent Near-Empty Bins:\n    almost_empty_threshold = 0.2\n    almost_empty_mask = feasible_mask & (remaining_capacity < almost_empty_threshold * bin_capacity)\n    priorities[almost_empty_mask] -= 1 # small penalty\n\n    # 4. Discourage Nearing-Full Capacity (before placing item):\n    nearing_full_threshold = 0.9\n    nearing_full_mask = feasible_mask & (bins_remain_cap / bin_capacity > nearing_full_threshold)\n    priorities[nearing_full_mask] -= 3 # medium penalty\n\n    # 5. Reward almost full (before placing item)\n    almost_full_threshold_lower = 0.75\n    almost_full_mask = feasible_mask & (bins_remain_cap / bin_capacity >= almost_full_threshold_lower) & (bins_remain_cap / bin_capacity <= nearing_full_threshold)\n    priorities[almost_full_mask] += 2\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Combines best-fit, first-fit, and nearly-full bin prioritization with adaptive penalties for unfit items.\n    It also includes a small randomization for tie-breaking and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    max_capacity = np.max(bins_remain_cap)\n\n    # First Fit Decreasing heuristic component: prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0  # Give a base priority to bins that can fit\n\n    # Best Fit heuristic component: prioritize bins with smallest remaining space *after* adding the item.\n    remaining_space_after_fit = bins_remain_cap[fit_mask] - item\n\n    if remaining_space_after_fit.size > 0:\n        best_fit_priority = 1 / (remaining_space_after_fit + 1e-9)  # avoid division by zero.  Inverse of space, higher value == smaller space left after adding.\n        indices_fit = np.where(fit_mask)[0]  # get indices to update\n        priorities[indices_fit] += best_fit_priority\n\n    # Introduce a \"nearly full\" bonus - prioritizes filling bins that are mostly full *before* addition.\n    nearly_full_threshold = 0.75  # Threshold as a fraction of total bin size\n    nearly_full_mask = bins_remain_cap > 0\n    ratio = (max_capacity - bins_remain_cap) / max_capacity # Current occupancy\n    near_full_bonus = (ratio > nearly_full_threshold) * fit_mask  # Only consider nearly full if item fits\n    priorities += near_full_bonus * 2  # Arbitrary magnitude 2, tuned. Added only if item can fit.\n\n    # Adaptive penalty for unfit items\n    if not np.any(fit_mask):\n        # Penalize based on how much the item exceeds capacity, but favor bins with some capacity\n        penalty = -(item - bins_remain_cap) / max_capacity #normalized\n        penalty[bins_remain_cap <= 0] = -np.inf  # Avoid empty bins unless absolutely necessary\n        priorities = penalty\n\n    # Introduce a small random factor to break ties and explore different bin assignments.\n    priorities = priorities + 0.001 * np.random.rand(len(bins_remain_cap))\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: identify bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit the item, return all zeros, indicating no priority.\n        return priorities\n\n    # Calculate remaining capacity after placing the item in feasible bins\n    remaining_capacity_after_add = bins_remain_cap[feasible_bins] - item\n\n    # Assign priorities based on minimizing waste\n    priorities[feasible_bins] = 1 / (remaining_capacity_after_add + 1e-9)\n\n    # Normalize priorities\n    priorities[feasible_bins] /= np.sum(priorities[feasible_bins])\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: identify bins that can accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit the item, return very negative priorities\n        return priorities - np.inf\n\n    # Heuristic 1: Snug Fit - prioritize bins where the item fits snugly\n    slack = bins_remain_cap - item\n    priorities[feasible_bins] += 1 / (slack[feasible_bins] + 1e-6)\n\n    # Heuristic 2: Fragmentation Penalty - Penalize bins that will become too empty or too full\n    remaining_capacity = bins_remain_cap - item\n    max_capacity = np.max(bins_remain_cap)\n\n    # Penalize bins becoming too full (high remaining capacity ratio)\n    too_full = remaining_capacity < 0.1 * max_capacity\n    priorities[feasible_bins & too_full] -= 0.2\n\n    # Penalize bins becoming too empty (low remaining capacity ratio but still feasible)\n    too_empty = (remaining_capacity > 0.75 * max_capacity) & feasible_bins\n    priorities[too_empty] -= 0.1\n\n    # Heuristic 3: Occupancy Bonus - Reward bins that are already somewhat occupied\n    occupancy = max_capacity - bins_remain_cap\n    normalized_occupancy = occupancy / max_capacity\n    priorities += 0.1 * normalized_occupancy\n\n    # Heuristic 4: Item Size Influence - Give higher priority to bins that can accommodate larger items,\n    # to pack smaller ones together and reduce fragmentation\n    priorities[feasible_bins] += 0.05 * (item / max_capacity)\n\n    # Heuristic 5: moderate fill bonus\n    moderate_capacity = np.logical_and(bins_remain_cap > item, bins_remain_cap < max_capacity * 0.75)\n    priorities[moderate_capacity] += 0.03\n\n    return priorities",
    "response_id": 9,
    "obj": 4.098524132429212,
    "exec_success": true
  }
]