[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing inspired approach: prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n\n    # Avoid bins that are too big, give some bonus to bins that fit reasonably well\n    priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask] # Smaller remaining space is better. Value range [0, 1]\n\n    # Give higher priority if a bin has enough space.\n    priorities[fit_mask] = 1 - priorities[fit_mask] # Invert to favor smaller remaining spaces\n\n    # Bonus to nearly full bins to maximize bin usage\n    nearly_full_mask = (bins_remain_cap >= item) & (bins_remain_cap <= item * 1.2)\n    priorities[nearly_full_mask] += 0.5\n\n    # Slightly penalize bins if the item is too small.\n    small_item_mask = bins_remain_cap >= (item * 5)\n    priorities[small_item_mask] -= 0.2\n\n    #Very small penalize bins nearing overfill\n    almost_full = (bins_remain_cap - item) <= 0.1\n    priorities[almost_full] -= 1\n\n    return priorities",
    "response_id": 0,
    "obj": 4.9760670123653865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit Decreasing heuristic inspiration\n    # Give higher priority to bins that can fit the item best (smallest waste)\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities[fit_mask] = -waste[fit_mask] # Smaller waste is better\n    \n    # If no bin fits perfectly, penalize significantly those which don't.\n    priorities[~fit_mask] = -np.inf\n\n    # Add a small random component to break ties\n    priorities += np.random.rand(len(bins_remain_cap)) * 1e-6 \n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    # For bins that can fit, prioritize based on remaining capacity after placing the item\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing inspired approach:\n    # Give preference to bins that can accommodate the item with minimal waste.\n    \n    # Give -inf priority to bins that can't fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n    \n    # For bins that can fit, prioritize based on remaining capacity after placing the item\n    feasible_mask = ~infeasible_mask\n    remaining_capacity = bins_remain_cap[feasible_mask] - item\n    \n    # Give higher priority to bins with smaller remaining capacity. Avoids creating nearly empty bins.\n    priorities[feasible_mask] = -remaining_capacity\n    \n    # Add a small bonus to bins that are very close to full before placing item, in order to fill them quickly\n    close_to_full_mask = feasible_mask & (bins_remain_cap >= item) & (bins_remain_cap < item * 1.2)\n    priorities[close_to_full_mask] += 1  # Arbitrary bonus, can be tuned\n\n    # Add a penalty for almost full, encouraging creation of a new bin if we're too close to the bin limit\n    almost_full_mask = feasible_mask & (bins_remain_cap > item* 0.95)\n    priorities[almost_full_mask] -=0.5\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Large items have higher priority to go to bins that can fit them closely\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask] # closeness metric, lower is better\n        priorities[fit_mask] = 1 - priorities[fit_mask]  # higher is better, prioritizes closer fits\n    else:\n        # if no bin fits, prioritize bins with largest remaining capacity to avoid creating too many almost empty bins\n        priorities = bins_remain_cap / np.max(bins_remain_cap)  # normalized to max cap\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Heuristic 1:  Bins that can accommodate the item perfectly get highest priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # Arbitrarily high value for perfect fit\n\n    # Heuristic 2: Bins where item fits with least remaining space get higher priority.\n    # But only consider those bins where the item can fit.\n    can_fit = bins_remain_cap >= item\n    \n    if np.any(can_fit):  # Avoid division by zero\n      remaining_space = bins_remain_cap[can_fit] - item\n      priorities[can_fit] = 1.0 / (remaining_space + 0.00001)  # Add small constant to prevent div by 0, avoids inf values. Reciprocal gives priority to bins with small remainders\n\n    # Heuristic 3: Moderate capacity bins get higher priority if perfect fit isn't an option.\n    # This is a bit of exploration: avoid filling very small and large capacity bins.\n    moderate_capacity = (bins_remain_cap > item) & (bins_remain_cap < (np.max(bins_remain_cap) * 0.75)) & (~perfect_fit)\n    priorities[moderate_capacity] += 10  # Add a moderate amount to moderate capacity bins.\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Remaining Capacity Optimization:\n    #   - Reward bins with tighter fit (minimize wasted space)\n    #   - Avoid bins that result in very small remaining capacity.\n    remaining_after_fit = bins_remain_cap - item\n    \n    #   Scale priorities based on the ratio of item size to remaining capacity.\n    #   Larger values mean a better fit. A higher value is good if its almost filled\n    priorities[feasible_bins] = item / (bins_remain_cap[feasible_bins] + 1e-9) # Add small value to avoid division by zero\n    \n    #   Penalize bins where very little capacity is remaining\n    very_small_threshold = 0.1  # Can be adjusted\n    priorities[feasible_bins] -= 10 * (remaining_after_fit[feasible_bins] < very_small_threshold)  # Large penalty\n    \n    # 3. Prioritize almost full bins\n    almost_full_threshold = 0.9 #Threshold can be changed\n    almost_full = bins_remain_cap / np.max(bins_remain_cap) > almost_full_threshold\n    \n    priorities[almost_full] += 5  #A small priority for almost full bins, could avoid spreading the items around if they could actually fit on the almost-full bins.\n    \n    return priorities",
    "response_id": 5,
    "obj": 146.94854407658556,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a very high priority to bins that can fit the item exactly.\n    exact_fit = np.isclose(bins_remain_cap, item)\n    priorities[exact_fit] = 1000  # Very high priority\n    \n    # Give higher priority to bins where the item fits, but not too much space is left.\n    fits = bins_remain_cap >= item\n    \n    # Calculate remaining space after placing the item.\n    remaining_space = bins_remain_cap[fits] - item\n    \n    # Prioritize bins where the remaining space is small.\n    # Avoid bins with large wasted space, which could be used to pack later items.\n    priorities[fits] = 100 / (remaining_space + 0.001) # Adding a small number for avoiding division by zero.\n    \n    # Penalize bins that don't fit.\n    priorities[bins_remain_cap < item] = -100  # Very low priority\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, prioritize bins that can actually fit the item.\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n      #If no bins can fit item, return negative infinity for all.\n      return np.full_like(bins_remain_cap, fill_value=-np.inf)\n\n    # For bins that can fit the item, calculate a score based on remaining capacity.\n    remaining_after_fit = bins_remain_cap[valid_bins] - item\n    \n    # Higher priority to bins where the remaining capacity is small\n    # but not too small (avoiding near-empty bins unless necessary). We will award bins with smaller space remaining more priority and vice-versa\n    priorities[valid_bins] = 1.0 / (remaining_after_fit + 0.0001)  # Add a small constant to avoid division by zero\n    \n    #Also include bin utilization by incorporating the size of the item relative to capacity\n    priorities[valid_bins] += item / bins_remain_cap[valid_bins]\n\n    # Optionally, add a small bias towards bins that are already somewhat full.\n    #This might help consolidating items. However, we are mainly interested in\n    # reducing bin numbers so lets give it very low importance\n    filled_ratio = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities[valid_bins] += 0.01 * filled_ratio[valid_bins]\n\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    # 2. Calculate remaining capacity after placing the item (only for feasible bins)\n    remaining_capacity = bins_remain_cap - item\n    \n    # 3. Reward bins with smaller remaining capacity (First-Fit Decreasing-like)\n    priorities[feasible_bins] = 1 / (remaining_capacity[feasible_bins] + 1e-9) # Add small constant to avoid division by zero\n    \n    # 4. Big reward for almost full bins if item fits.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap < item + 0.2) # item+threshold\n    priorities[almost_full] = 1000\n\n    # 5. Negative reward for bins with capacity much larger than the item size,\n    #    trying to avoid spreading items too thin.\n    wasteful = (bins_remain_cap > item * 2) & feasible_bins  # threshold * item\n    priorities[wasteful] = -1\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Large bins that can fit the item have higher priority.\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = bins_remain_cap[valid_bins] - item  # Remaining capacity after packing (higher is better). This favors bins that aren't filled too much\n\n    # If no bins can fit the item, penalize heavily.\n    if not np.any(valid_bins):\n        priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins with remaining capacity close to item size, but only if there are valid bins\n    if np.any(valid_bins):\n        diffs = np.abs(bins_remain_cap - item)\n        normalized_diffs = diffs / np.max(bins_remain_cap) # Normalized to bin size\n        priorities[valid_bins] += (1 - normalized_diffs[valid_bins])*10 #Add a value based on how close it is, scale by 10 so it outweighs base remaining capacity, make only valid_bins affect values.\n\n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            priorities[i] = (cap * item) / (waste + 0.000001) # Favor bins where item fits, and prefer those with less waste relative to remaining capacity * item\n            #priorities[i] =  1/(waste+0.0001) # Try to minize the remaining waste\n            #priorities[i] = cap - item # Minimize waste is equvalent to minimize remaining space\n        else:\n            priorities[i] = -100000 # Very low priority if item doesn't fit\n\n    return priorities",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999230998219 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing heuristic: Prefer bins with enough space, but not too much.\n    # Reward bins that are close to fitting the item perfectly\n    \n    #Option 1: Use exponential. Higher score if item almost fits in a bin\n    diff = bins_remain_cap - item\n    priorities = np.exp(-np.abs(diff)/(item + 1e-9))\n\n    #Option 2: If it can fit, compute difference.\n    # If it can not fit, make it close to negative infinity\n    can_fit = bins_remain_cap >= item\n    diff = bins_remain_cap - item\n    priorities = -np.abs(diff) * can_fit + (1-can_fit) * -1e9\n\n    # Option 3: Normalized capacity of bin after placing item. Prefer higher final capacity.\n    can_fit = bins_remain_cap >= item\n    final_capacity = (bins_remain_cap - item) * can_fit\n    priorities = final_capacity / (np.sum(bins_remain_cap) + 1e-9) * can_fit + (1 - can_fit) * -1e9\n    \n    #Option 4: Compute ratio between item and bin capacity. Closer to 1 gets more priority, only when it fits\n    ratio = item / (bins_remain_cap + 1e-9)\n    can_fit = bins_remain_cap >= item\n    priorities = np.exp(-np.abs(ratio - 1)) * can_fit + (1-can_fit) * -1e9\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Rule 1: Highest priority to bins where item fits best (smallest waste).\n    waste = bins_remain_cap - item\n    \n    # Smallest waste, but only if it fits\n    valid_waste = np.where(waste >= 0, waste, np.inf)\n    \n    # Inverse of valid waste becomes the priority. Add a small constant to avoid division by zero\n    priorities = 1.0 / (valid_waste + 1e-9)\n    \n    # Rule 2: Apply penalty if the waste is very high (to prevent large waste bins)\n    large_waste_threshold = np.mean(bins_remain_cap) * 0.8\n    waste_penalty = np.where(bins_remain_cap > item + large_waste_threshold, (bins_remain_cap - item - large_waste_threshold) / large_waste_threshold, 0.0)\n    \n    priorities -= waste_penalty\n    \n    # Rule 3: Slight boost to bins close to being full (minimize #bins)\n    full_threshold = np.mean(bins_remain_cap) * 0.2\n    full_boost = np.where((bins_remain_cap > item) & (bins_remain_cap - item < full_threshold), 1 - (bins_remain_cap - item) / full_threshold, 0)\n    \n    priorities += full_boost\n    \n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item fits.\n    fits = bins_remain_cap >= item\n    priorities[fits] += 1\n\n    # Heuristic 2: Fill bins as much as possible without exceeding capacity.\n    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    fill_ratios[fits] = item / bins_remain_cap[fits]\n    priorities[fits] += fill_ratios[fits]\n\n    # Heuristic 3: Smallest remaining capacity after adding the item. Avoid creating almost empty bins\n    remaining_capacity_after_addition = bins_remain_cap - item\n    almost_empty = (remaining_capacity_after_addition >= 0) & (remaining_capacity_after_addition <= 0.1)\n    priorities[almost_empty] -= 0.5  # Penalize making bins almost empty\n\n    # Heuristic 4: If the item doesn't fit in any bin, prioritize bins with maximum remaining cap\n    if not np.any(fits):\n        max_cap_index = np.argmax(bins_remain_cap)\n        priorities[max_cap_index] += 0.2\n    return priorities",
    "response_id": 13,
    "obj": 4.9760670123653865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Bins that can fit the item get a base priority.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1.0\n\n    # Rule 2: Prioritize bins with smaller remaining capacity after placing the item (First Fit Decreasing heuristic idea).\n    remaining_capacity_after_fit = bins_remain_cap[fit_mask] - item\n    priorities[fit_mask] += 1.0 / (remaining_capacity_after_fit + 0.00001) # Avoid division by zero\n\n    # Rule 3: Give a higher priority to bins which are already somewhat filled. Avoid opening new bins when possible\n    priorities[fit_mask] += (1 - bins_remain_cap[fit_mask]/np.max(bins_remain_cap))\n    # If there are no bins with enough capacity, return a flat priority array so the first available will be chosen\n    if np.sum(fit_mask) == 0:\n        return np.ones_like(bins_remain_cap)\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Reward bins that can fit the item.\n            remaining = cap - item\n            priorities[i] = (item / cap)  # Fill ratio\n            priorities[i] += (1 / (remaining + 0.0001)) #try to reduce fragmentation. avoid division by zero\n        else:\n            # Penalize bins that can't fit the item (but not too much).\n            priorities[i] = -100  # A negative score so as not to choose these.\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Very high priority if the item fits perfectly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # A large value for high priority\n\n    # High priority if the item fits with minimal waste\n    almost_fit = (bins_remain_cap > item) & (bins_remain_cap <= item * 1.1) # Waste <= 10% of item size\n    priorities[almost_fit] = 500\n\n    # Moderate priority if the item fits reasonably well\n    reasonable_fit = (bins_remain_cap > item) & (bins_remain_cap <= item * 1.5)  # Waste <= 50% of item size\n    priorities[reasonable_fit] = 100\n\n    # Low priority based on remaining capacity, but only if it fits\n    fits = bins_remain_cap >= item\n    priorities[fits] += bins_remain_cap[fits] - item\n\n    # Very low priority (or negative) if item does not fit\n    does_not_fit = bins_remain_cap < item\n    priorities[does_not_fit] = -1000 # Negative score discourage from ever using this bin\n\n    return priorities",
    "response_id": 16,
    "obj": 8.15715995213402,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            fill_ratio = item / cap\n            waste = cap - item\n\n            # Heuristic 1: Prefer bins where the item fits reasonably well.\n            priorities[i] += 1 / (1 + abs(fill_ratio - 0.75)) # Prefer filling around 75%\n\n            # Heuristic 2: Penalize small waste (but only when item fits)\n            if waste > 0:\n                priorities[i] +=  np.exp(-waste) #Smaller the waste larger priority\n\n            #Heuristic 3: Encourage filling up empty space; empty bins get high priority.\n            priorities[i] += 0.01 * cap  # slightly prefer less full bins, avoid putting things in bins nearly at capacity unless other options bad.\n\n        else:\n            priorities[i] = -np.inf  # Cannot add item to this bin\n\n    return priorities",
    "response_id": 17,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99998260001303 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing heuristic component: prefer bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1  # Give a base priority to bins that can fit\n\n    # Best Fit heuristic component: prioritize bins with smallest remaining space *after* adding the item.\n    remaining_space_after_fit = bins_remain_cap[fit_mask] - item\n    # If no bins can fit, the next part is skipped, priorities remain zero\n\n    if remaining_space_after_fit.size > 0:\n        best_fit_priority = 1 / (remaining_space_after_fit + 1e-9) # avoid division by zero.  Inverse of space, higher value == smaller space left after adding.\n        indices_fit = np.where(fit_mask)[0]  #get indices to update\n        priorities[indices_fit] += best_fit_priority  # add the best_fit priority to appropriate bins\n\n    # Introduce a \"nearly full\" bonus - prioritizes filling bins that are mostly full *before* addition.\n    nearly_full_threshold = 0.9 # Threshold as a fraction of total bin size, tuning parameter.\n\n    nearly_full_mask = bins_remain_cap > 0 # bins must exist to calculate ratio\n    ratio = (bins_remain_cap[nearly_full_mask] / (bins_remain_cap[nearly_full_mask] + item)) # capacity remaining/total capacity if packed.  Prioritize bigger changes\n    near_full_bonus = (ratio > nearly_full_threshold)\n    indices_nearly_full = np.where(nearly_full_mask)[0]\n\n    priorities[indices_nearly_full] += near_full_bonus * 2   #arbitrary magnitude 2, tuned\n\n    # Penalize bins where item is significantly larger than the available space if no suitable bin can fit\n    if not np.any(fit_mask):\n        priority_unfit = -(item - bins_remain_cap)\n        priority_unfit[bins_remain_cap == 0] = -np.inf #never select empty bins when no fit is available\n        priorities = priority_unfit\n\n    return priorities",
    "response_id": 18,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_capacity_after_add = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits and the remaining capacity is minimized, but still positive.\n    # Avoid fragmentation as much as possible.\n\n    fit_mask = remaining_capacity_after_add >= 0\n    if np.any(fit_mask):\n        priorities[fit_mask] = 1 / (remaining_capacity_after_add[fit_mask] + 1e-9)  # Add a small constant to avoid division by zero\n\n        # Prioritize bins with higher initial capacity if multiple bins can fit the item.\n        priorities[fit_mask] += bins_remain_cap[fit_mask] / np.max(bins_remain_cap)  # Add fraction of max bin capacity\n\n    # Give low priority (negative) to bins that cannot fit the item.\n    priorities[~fit_mask] = -1\n\n    return priorities",
    "response_id": 19,
    "obj": 84.7726366174711,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Very low priority for infeasible bins\n\n    # 2. Remaining capacity: Prioritize bins with smaller remaining capacity\n    #    after placing the item, but only if the item fits.\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[~feasible_bins] = np.inf\n\n    priorities[feasible_bins] = -remaining_capacity_after_placement[feasible_bins]\n\n    # 3. Try to avoid bins that are almost full or almost empty after the placement.\n\n    almost_full = (remaining_capacity_after_placement > 0) & (remaining_capacity_after_placement < 0.1) #tune threshold of 0.1\n\n    # Try to reduce number of bins with smaller capacity\n    almost_empty = (remaining_capacity_after_placement / np.max(bins_remain_cap) > 0.9)  #Tune this threshold\n\n    priorities[almost_full] -= 0.5 #de-prioritize\n    priorities[almost_empty] -= 0.3  #de-prioritize less compared to almost full\n\n    # 4. If there are several bins with the exact same fill, pick the earlier one\n\n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First Fit Decreasing heuristic inspiration\n    # Prioritize bins that can fit the item best (least wasted space)\n    \n    can_fit = bins_remain_cap >= item\n    \n    if not np.any(can_fit):\n        # if no bin can fit, give minimal priority, avoiding it, but still allowing filling if must create new bin\n        return priorities - 1e-9\n\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # mark bins that cannot fit\n    \n    # Assign high priority to bins that result in smallest waste.\n    priorities[can_fit] = -waste[can_fit]\n    \n    # Additional bias to fill already filled bins. Higher utilization.\n    bin_utilization = 1 - bins_remain_cap / np.max(bins_remain_cap) # Scaling capacity to a max bin size will influence bin utlization\n    priorities = priorities + bin_utilization * can_fit\n    \n    # A small randomness to avoid deterministic behavior for identical items\n    priorities = priorities + np.random.rand(len(bins_remain_cap))*0.001 * can_fit\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # 1. Feasibility: Assign -inf priority if the item doesn't fit.\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # 2. Remaining capacity: Prefer bins where the item fits best (smallest waste).\n    waste = bins_remain_cap - item\n    priorities[bins_remain_cap >= item] = -waste[bins_remain_cap >= item]\n    \n    # 3. Fill percentage: Prefer bins that are already somewhat full (avoid creating too many almost-empty bins).\n    fill_percentage = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Assumes bins are of equal max capacity\n    priorities[bins_remain_cap >= item] += fill_percentage[bins_remain_cap >= item] * 0.5 # Weigh this factor\n\n    # 4. Prioritize nearly full bins even more.\n    nearly_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= 0.1 * np.max(bins_remain_cap))\n    priorities[nearly_full] += 10 # Boost nearly full bins\n\n    return priorities",
    "response_id": 22,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16, in priority_v2\n    feasible_bins = bins_remain_cap >= item\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        return priorities # No bin can fit, so all priorities are 0\n\n    # 2. Remaining Capacity: Prioritize bins with less remaining capacity after packing\n    remaining_capacity_after_packing = np.clip(bins_remain_cap - item, a_min=0, a_max=None)\n\n    # 3. Fill Ratio: Calculate how full the bin would be after packing.\n    fill_ratio = (bins_remain_cap - remaining_capacity_after_packing) / (bins_remain_cap + 1e-9) # avoid divide by zero\n\n    # 4. Combination: Combine the above factors to create a priority score.  We prioritize bins that:\n    #    - Can fit the item (feasibility).\n    #    - Result in higher fill ratios (use bins efficiently).\n    #    - Leave less remaining capacity.\n    \n    priorities[feasible_bins] = (fill_ratio[feasible_bins]**2) / (remaining_capacity_after_packing[feasible_bins] + 0.01)\n    \n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired heuristic: Prioritize bins that can fit the item almost perfectly.\n    # Try to avoid creating too much wasted space.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        waste = bins_remain_cap[fit_mask] - item\n        # Prioritize bins with smallest waste\n        priorities[fit_mask] = 1.0 / (1e-6 + waste) #add small number to avoid division by zero\n    else:\n        # If the item doesn't fit in any bin, assign a low priority to all existing bins to promote new bins to be opened\n        priorities[:] = -1e9\n\n    # Boost the priority of bins that are already somewhat full, so we consolidate\n    # and open fewer bins in total\n    priorities += bins_remain_cap.max() - bins_remain_cap\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Rule 1: Bins that can't fit the item get a very low priority.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Rule 2: Maximize the used space while preventing overflow (First-Fit Decreasing heuristic inspired).\n    # Bins with remaining capacity closest to the item size get the highest priority.\n    # The closer the fit, the better (without overflowing).\n    fit_diff = bins_remain_cap - item\n    priorities[bins_remain_cap >= item] = -np.abs(fit_diff[bins_remain_cap >= item])\n\n    # Rule 3: If multiple bins have the same fit difference, prioritize those with smaller remaining capacity to prevent fragmentation. (Worst-Fit Decreasing heuristic inspired but adapted).\n    # This acts as a tie-breaker.\n    min_diff = np.min(np.abs(fit_diff[bins_remain_cap >= item]))\n    equal_fit_bins = np.isclose(np.abs(fit_diff), min_diff) & (bins_remain_cap >= item)\n    priorities[equal_fit_bins] += -bins_remain_cap[equal_fit_bins] / np.max(bins_remain_cap) if np.any(equal_fit_bins) else 0 # Normalize to range [-1, 0]\n    \n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Prioritize bins that can fit the item\n            remaining_space = cap - item\n            # A smaller remaining space gets a higher priority (First Fit Decreasing characteristic)\n            priorities[i] = 1.0 / (remaining_space + 0.00001)  # Avoid division by zero\n            # Give bonus for bins that are nearly full after packing\n            if remaining_space < 0.1:  #tuneable hyperparameter\n                priorities[i] += 10  #tuneable hyperparameter\n        else:\n            # Very low priority for bins that can't fit the item.\n            priorities[i] = -100 #tuneable hyperparameter\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: First-Fit Decreasing-like behavior. Prioritize bins that can fit the item snugly.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6)  # Smaller slack, higher priority\n    else:\n        priorities[:] = -np.inf  # item cannot fit in the bins, force new bins to open up\n\n    # Heuristic 2: Penalize bins that become too full after insertion to avoid fragmentation\n    fullness = (bins_remain_cap - item) / np.max(bins_remain_cap)\n    fullness[fullness < 0] = -np.inf  # Cannot fit\n    penalty = np.exp(-10 * fullness)  # Exponential penalty as bins get fuller\n    priorities = priorities - penalty\n\n    # Heuristic 3: Bonus for bins that are already somewhat filled (reduces number of partially-filled bins)\n    occupied_ratio = (np.max(bins_remain_cap) - bins_remain_cap) / np.max(bins_remain_cap)\n    bonus = 0.1 * occupied_ratio\n    priorities = priorities + bonus\n\n    return priorities",
    "response_id": 27,
    "obj": 0.8675708017550904,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # 1. Feasibility check: Only consider bins that can fit the item\n    feasible_bins = bins_remain_cap >= item\n\n    # 2. Remaining capacity after placing the item: prefer bins where little space will be wasted.\n    remaining_after_placement = bins_remain_cap - item\n    remaining_after_placement[remaining_after_placement < 0] = np.inf # if bin cannot fit item, then inf remaining capacity.\n\n    # 3. A small amount of bias\n    epsilon = 1e-6\n\n    # 4. Priority Score assignment. The bin that can fit the item, and has smallest capacity left after placement will be picked.\n    priorities = np.where(feasible_bins, 1 / (remaining_after_placement + epsilon), 0) # Assign small amount of score so we pick this bin.\n    \n    # Alternative prioritzation strategy: favor bins with fill level closer to 75%\n    # fill_levels = (bins_remain_cap - item) / bins_remain_cap\n    # target_fill = 0.25 # 1-0.75\n    # priorities = np.where(feasible_bins, 1 - np.abs(fill_levels - target_fill), 0)\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate how much space will be wasted if the item is placed in this bin\n            waste = cap - item\n\n            # Prioritize bins that can fit the item with minimal waste.\n            # Use a combination of factors to define priority:\n            #   - Inverse of waste: Smaller waste -> higher priority.  Add a small constant to avoid division by zero.\n            #   - Remaining capacity: Bins with smaller remaining capacity should be prioritized slightly to keep bins balanced\n\n            priorities[i] = 1 / (waste + 0.001) + (1 / (cap+0.001))\n\n            #Potentially a power law can be used. Let us see if it improves\n            #priorities[i] = (1/(waste+0.001))**0.5 + (1/ (cap +0.001))**0.5\n\n        else:\n            priorities[i] = -np.inf  # Bin cannot fit the item, so give it the lowest priority\n\n    return priorities",
    "response_id": 29,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999298900366 seconds"
  }
]