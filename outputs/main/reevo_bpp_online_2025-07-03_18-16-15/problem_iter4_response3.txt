```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    max_capacity = np.max(bins_remain_cap)  # Assuming all bins have the same max capacity

    # Heuristic 1: First-Fit Decreasing-like behavior with a slight modification.
    # Prioritize bins that can fit the item relatively snugly, but avoid overly tight fits.
    fit_mask = bins_remain_cap >= item
    if np.any(fit_mask):
        slack = bins_remain_cap[fit_mask] - item
        # Prioritize based on slack, but dampen the effect for very small slacks
        priorities[fit_mask] = 1 / (slack + 0.01 * max_capacity)  # Adds a bit of tolerance
    else:
        priorities[:] = -np.inf  # Item cannot fit, force new bin opening

    # Heuristic 2: Fragmentation avoidance using a sigmoid function.  Penalize bins
    # that lead to small remaining capacity, but allow some small capacity remaining.
    remaining_ratio = (bins_remain_cap - item) / max_capacity
    remaining_ratio[remaining_ratio < 0] = -np.inf # can not fit

    # sigmoid penalty
    penalty = 1 / (1 + np.exp(-10 * (remaining_ratio - 0.1))) # try to make remaining ratio around 0.1

    priorities = priorities - penalty


    # Heuristic 3: Occupancy bonus.  Reward bins that are already partially full.
    occupancy_ratio = (max_capacity - bins_remain_cap) / max_capacity
    bonus = 0.2 * occupancy_ratio * (occupancy_ratio > 0) # only gives bonus for partially filled bins
    priorities = priorities + bonus


    # Heuristic 4: Introduce a small random factor to break ties and explore different bin assignments.
    priorities = priorities + 0.01 * np.random.rand(len(bins_remain_cap))

    # Heuristic 5: Item size aware adjustment
    item_ratio = item / max_capacity
    if item_ratio > 0.5:
        # Large item, slightly prefer more empty bins
        priorities += 0.1 * (1 - occupancy_ratio)
    else:
        # Small item, slightly prefer more filled bins
        priorities += 0.1 * occupancy_ratio
    
    # Normalize priorities to [0, 1] to ensure stability and prevent dominance
    min_priority = np.min(priorities[priorities != -np.inf])
    max_priority = np.max(priorities[priorities != -np.inf])
    
    if max_priority > min_priority:  # Avoid division by zero if all bins have -inf priority
        priorities[priorities != -np.inf] = (priorities[priorities != -np.inf] - min_priority) / (max_priority - min_priority)
    
    return priorities
```
