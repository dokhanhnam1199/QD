[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1.0\n\n    # Then prioritize bins where the item fits with the least remaining space\n    fit_bins = bins_remain_cap >= item\n    if np.any(fit_bins):\n        remaining_space = bins_remain_cap[fit_bins] - item\n        priorities[fit_bins] = 1.0 / (remaining_space + 1e-6)  # Avoid division by zero\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Best Fit priority function.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diffs = bins_remain_cap - item\n    # Only consider bins that can accommodate the item.\n    valid_bins = diffs >= 0\n    # The bin with the smallest difference (i.e., the best fit) gets the highest priority.\n    if np.any(valid_bins):\n        min_diff = np.min(diffs[valid_bins])\n        priorities[valid_bins] = 1.0 / (diffs[valid_bins] - min_diff + 1e-6)  # Add small value to avoid division by zero\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, remain_cap in enumerate(bins_remain_cap):\n        if remain_cap >= item:\n            priorities[i] = remain_cap - item  # Prefer bins where the item fits almost fully\n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 12.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # High priority for exact fit\n\n    # Next best fits get the next priority (smallest waste)\n    waste = bins_remain_cap - item\n    valid_bins = waste >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1 / (waste[valid_bins] + 1e-9)  # Avoid division by zero\n\n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities  # No bin can fit the item\n\n    # Calculate the distance between item size and remaining capacity\n    distances = bins_remain_cap[valid_bins] - item\n\n    # Inverse Distance: Higher priority for smaller distances\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)  # Adding a small constant to avoid division by zero\n\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n    fit_scores[bins_remain_cap < item] = np.inf  # Assign infinity to bins that are too small\n\n    # Apply the sigmoid function to the fit scores\n    # The sigmoid function transforms the fit score into a priority score between 0 and 1.\n    # Bins with a lower fit score (better fit) will have a higher priority score.\n    priorities = 1 / (1 + np.exp(fit_scores))  # Sigmoid function\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 36.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'greedy' priority: how well the item fits\n    greedy_priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, -1)\n\n    # Exploration: Add a random value to each bin with probability epsilon\n    if np.random.rand() < epsilon:\n        priorities = np.random.rand(n_bins)\n    else:\n        priorities = greedy_priority\n    \n    return priorities",
    "response_id": 8,
    "obj": 138.50219385719984,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 34.86917501586544,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin (how well the item fits)\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Normalize fit scores using softmax to get probabilities (priorities)\n    # Add a small value to avoid division by zero and to stabilize softmax.\n    fit_scores = fit_scores + 1e-6\n    exp_fit_scores = np.exp(fit_scores)\n    priorities = exp_fit_scores / np.sum(exp_fit_scores)\n\n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n    \n    #Worst fit: Choose the bin with the most remaining capacity\n    priorities[valid_bins] = remaining_capacities\n    \n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Give highest priority to bins where the item fits exactly\n    exact_fit_mask = (bins_remain_cap == item)\n    priorities[exact_fit_mask] = 1\n\n    # If no exact fit, give priority to bins where item can fit (but not necessarily exactly)\n    if np.sum(exact_fit_mask) == 0:\n        fit_mask = bins_remain_cap >= item\n        priorities[fit_mask] = 0.5  # Lower priority than exact fit\n\n    return priorities",
    "response_id": 24,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 23.264662506490403,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the distance between the item size and the remaining capacity of each bin\n    distances = np.abs(bins_remain_cap - item)\n    # Avoid division by zero by adding a small constant\n    distances = np.where(distances == 0, 1e-6, distances)\n    # Calculate the inverse distance (proximity fit)\n    priorities = 1.0 / distances\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin using a sigmoid function.\n    # The sigmoid function maps the ratio of item size to remaining capacity\n    # to a value between 0 and 1, where a higher value indicates a better fit.\n\n    # Avoid division by zero\n    bins_remain_cap = np.where(bins_remain_cap == 0, 1e-6, bins_remain_cap)\n    fit_scores = 1 / (1 + np.exp(-5 * (bins_remain_cap - item)))\n\n    # Scale the fit scores to prioritize bins with a better fit.\n    priorities = fit_scores\n\n    return priorities",
    "response_id": 16,
    "obj": 13.40247307538892,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.41714012534482,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Find bins that can accommodate the item\n    eligible_bins = bins_remain_cap >= item\n    \n    # If no bins are eligible, return a zero priority array\n    if not np.any(eligible_bins):\n        return priorities\n    \n    # Assign random priorities to the eligible bins.\n    # Higher priority = more likely to be chosen.\n    \n    num_eligible_bins = np.sum(eligible_bins)\n    \n    # Assign priority 1.0 to all eligible bins for simple random fit.\n    priorities[eligible_bins] = 1.0\n    \n    \n    return priorities",
    "response_id": 17,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using a Softmax-Based Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the 'fit' of the item into each bin.  Higher fit = more suitable.\n    fit = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Normalize the fit values to be between 0 and 1. This helps with the softmax.\n    if np.sum(fit) > 0:\n        normalized_fit = fit / np.sum(fit)\n    else:\n        normalized_fit = np.zeros_like(fit) # If no bins can fit, all priorities are zero.\n\n    # Apply Softmax to get probabilities (priority scores).  A temperature parameter\n    # is used to control the 'sharpness' of the distribution. Higher temperature\n    # makes the probabilities more uniform.\n    temperature = 0.1\n    priorities = np.exp(normalized_fit / temperature) / np.sum(np.exp(normalized_fit / temperature))\n\n    return priorities",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 79.95445336320968,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using First Fit Decreasing approach.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin's remaining capacity and the item's size.\n    # Prioritize bins where the item fits with the smallest remaining space.  Bins with exactly the item size have the highest priority.\n    diffs = bins_remain_cap - item\n    # Assign priority: higher is better.  Use a large value for perfectly fitting bins.\n    # Also, prioritize bins that have some remaining capacity instead of bins where item doesn't fit.\n    \n    # Using a combination of fit and remaining capacity for refined First Fit\n    for i in range(len(bins_remain_cap)):\n        if diffs[i] >= 0:\n            priorities[i] = diffs[i]\n        else:\n            priorities[i] = -1  # Lower priority if item doesn't fit\n            \n    # Boost for perfectly fitting bins.\n    perfect_fit_indices = np.where(diffs == 0)[0]\n    if len(perfect_fit_indices) > 0:\n      priorities[perfect_fit_indices] = bins_remain_cap.max() + 1\n\n    return priorities",
    "response_id": 20,
    "obj": 86.58755484643,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 64.72503367497926,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    # We want to minimize this difference, so bins with smaller differences get higher priority.\n    diffs = bins_remain_cap - item\n\n    # If a bin is too small to fit the item, its priority is 0.\n    diffs[diffs < 0] = -np.inf\n\n    # Use the negative of the differences as priorities. Higher value (less negative) is better\n    priorities = diffs\n\n    return priorities",
    "response_id": 21,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Find bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        return priorities  # No bin can fit the item\n\n    # Calculate the remaining capacity after adding the item to each valid bin\n    remaining_after_placement = bins_remain_cap[valid_bins] - item\n    \n    # Calculate the \"waste\" or the remaining capacity after placing the item.\n    # Worst Fit prioritizes bins that have the MOST remaining capacity after placing the item.\n    priorities[valid_bins] = remaining_after_placement\n    \n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 22.458839376460833,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin using a sigmoid function\n    # The sigmoid function maps the remaining capacity to a value between 0 and 1\n    # A higher score indicates a better fit\n    fit_scores = 1 / (1 + np.exp(- (bins_remain_cap - item) / item))\n    \n    # Add a small bonus to bins that are almost full to encourage filling them up\n    # This can help reduce the number of bins used\n    bonus = np.exp(-(bins_remain_cap - item) / (item * 0.1)) if np.any(bins_remain_cap > item) else np.zeros_like(bins_remain_cap)\n    \n    priorities = fit_scores + 0.1 * bonus\n\n    # If the item doesn't fit in a bin, give it a score of 0\n    priorities[bins_remain_cap < item] = 0\n    \n    return priorities",
    "response_id": 26,
    "obj": 145.17351416035103,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 162.51574464281416,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1.0\n\n    # Then prioritize bins where the item fits and minimizes remaining space\n    fits = (bins_remain_cap >= item)\n    priorities[fits] = bins_remain_cap[fits] - item\n\n    # To handle the case when no bin has exact fit or even capacity greater than the item\n    priorities[bins_remain_cap < item] = -1.0\n    return priorities",
    "response_id": 27,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 44.37895002019238,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n\n    # Calculate greedy priority (best fit)\n    for i in range(n_bins):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item  # Smaller remaining space is better\n\n    # Exploration with probability epsilon\n    if np.random.rand() < epsilon:\n        # Assign random priorities to encourage exploration.\n        priorities = np.random.rand(n_bins)\n        \n    return priorities",
    "response_id": 28,
    "obj": 138.04347826086956,
    "SLOC": 9.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate fit score for each bin\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n\n    # Apply Softmax function to the fit scores\n    # This converts the fit scores into probabilities\n    # We add a small value to prevent division by zero and to ensure all probabilities are non-zero\n    temperature = 1.0  # Adjust temperature for exploration vs exploitation\n    max_score = np.max(fit_scores)\n    exponentiated_scores = np.exp((fit_scores - max_score) / temperature)\n    sum_exponentiated_scores = np.sum(exponentiated_scores)\n\n    if sum_exponentiated_scores == 0:\n       priorities = np.zeros_like(bins_remain_cap)\n       return priorities\n    \n    probabilities = exponentiated_scores / sum_exponentiated_scores\n    \n\n    return probabilities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 78.13781191217038,
    "exec_success": true
  }
]