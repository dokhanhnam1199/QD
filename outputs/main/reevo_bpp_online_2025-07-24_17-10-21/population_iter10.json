[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function prioritizes bins that can accommodate the item with the least remaining capacity.\n    It balances between exploitation and exploration by combining a fit score with random noise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and randomness.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins that can hold the item and have the least remaining capacity\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priorities for valid bins to be between 0 and 1\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priorities[valid_bins])\n        min_priority = np.min(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-10)\n    else:\n        return priorities  # If no bin can hold the item, return priorities as is\n    \n    # Add a small random noise for exploration\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1e-5, size=len(priorities))  # Reduced noise scale for more exploitation\n    noise[~valid_bins] = 0  \n    \n    # Combine the normalized priorities and noise\n    priorities = alpha * priorities + (1 - alpha) * noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a simplified priority function that directly uses \n    the normalized remaining capacity as priority scores for valid bins and \n    adds a small random noise for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Weight for the normalized remaining capacity.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.where(valid_bins, bins_remain_cap, np.inf)\n    min_cap = np.min(priorities[valid_bins]) if np.any(valid_bins) else np.inf\n    max_cap = np.max(priorities[valid_bins]) if np.any(valid_bins) else 1\n    priorities = np.where(valid_bins, (max_cap - priorities) / (max_cap - min_cap + 1e-9), -np.inf)\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  \n    priorities = alpha * priorities + (1 - alpha) * noise\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item, have the least remaining capacity after addition,\n    and balances between exploitation and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priorities[valid_bins])\n        min_priority = np.min(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-10)\n    \n    # Scale the noise to be comparable with the normalized priorities\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1, size=len(priorities))\n    noise[~valid_bins] = 0  \n    \n    # Combine the normalized priorities and noise with a more appropriate scaling for noise\n    priorities = alpha * priorities + (1 - alpha) * noise / (1 + np.sqrt(np.sum(valid_bins)))\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a simplified priority function that assigns higher priority to bins \n    that have just enough capacity to hold the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and randomness.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Add a small random noise to the priority scores for exploration\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1e-6, size=len(priorities))\n    noise[priorities == -np.inf] = 0  \n    \n    # Combine the priorities and noise, avoiding unnecessary normalization\n    priorities = np.where(priorities != -np.inf, alpha * priorities + (1 - alpha) * noise, -np.inf)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    It introduces a minimal random noise for better exploration-exploitation balance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign lowest priority to bins that cannot hold the item\n    priorities = np.where(remaining_after_addition >= 0, remaining_after_addition, np.inf)\n    \n    # Introduce a small random noise for exploration-exploitation balance\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[remaining_after_addition == np.inf] = 0  # Ensure bins that cannot hold the item have zero noise\n    \n    # Calculate the final priority score\n    priorities = priorities + noise\n    \n    return -priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item, have the least remaining capacity after addition,\n    and balances between exploitation and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priority scores for valid bins using a more numerically stable method\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1 - (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + 1e-10)\n        priorities[~valid_bins] = 0\n    \n    # Add a small random noise to the priority scores for exploration, scaled appropriately\n    noise = np.random.uniform(0, 1e-5, size=len(priorities))  # Reduced noise scale for more exploitation\n    noise[~valid_bins] = 0  \n    \n    # Combine the normalized priorities and noise, with alpha controlling the trade-off\n    priorities = alpha * priorities + (1 - alpha) * noise\n    \n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    A small random noise is added for exploration-exploitation balance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority directly based on remaining capacity after addition\n    priorities = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise for exploration-exploitation balance\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = 0  # Ensure bins that cannot hold the item have zero noise\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function prioritizes bins that can accommodate the item and have the least remaining capacity.\n    It directly incorporates exploration noise for better performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap >= item\n    priorities = np.where(valid_bins, bins_remain_cap, np.inf)\n    priorities = -priorities  # To prioritize bins with less remaining capacity\n    priorities += alpha * np.random.uniform(-1, 1, size=len(priorities))\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function prioritizes bins that can accommodate the item and have the least remaining capacity.\n    A small random noise is added for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: Small value added for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    priorities = np.where(bins_remain_cap >= item, -bins_remain_cap, -np.inf)\n    \n    # Add a small random noise for exploration\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, epsilon, size=len(priorities))\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.5, beta: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, \n    breaks ties by favoring bins with the least remaining capacity, and adds a small random noise for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and \"least remaining capacity\" score.\n        beta: Parameter controlling the trade-off between exploitation and exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n\n    # For valid bins, prioritize those with the least remaining capacity after adding the item\n    fit_score = np.where(valid_bins, 1 - (bins_remain_cap - item) / bins_remain_cap, -np.inf)\n\n    # Calculate the \"least remaining capacity\" score\n    remain_score = np.where(valid_bins, np.max(bins_remain_cap) - bins_remain_cap, 0)\n\n    # Normalize scores to be between 0 and 1 for valid bins\n    if np.any(valid_bins):\n        max_fit_score = np.max(fit_score[valid_bins])\n        min_fit_score = np.min(fit_score[valid_bins])\n        fit_score[valid_bins] = (fit_score[valid_bins] - min_fit_score) / (max_fit_score - min_fit_score + 1e-9)\n\n        max_remain_score = np.max(remain_score[valid_bins])\n        min_remain_score = np.min(remain_score[valid_bins])\n        remain_score[valid_bins] = (remain_score[valid_bins] - min_remain_score) / (max_remain_score - min_remain_score + 1e-9)\n    else:\n        return fit_score  # Return -inf for all bins if none can hold the item\n\n    # Calculate the exploitation score as a weighted sum of \"fit\" score and \"least remaining capacity\" score\n    exploitation_score = alpha * fit_score + (1 - alpha) * remain_score\n\n    # Add a small random noise to balance exploration and exploitation\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  # Ensure bins that cannot hold the item have zero noise\n\n    # Normalize the noise to be between 0 and 1 for valid bins\n    if np.any(valid_bins):\n        max_noise = np.max(noise[valid_bins])\n        min_noise = np.min(noise[valid_bins])\n        noise[valid_bins] = (noise[valid_bins] - min_noise) / (max_noise - min_noise + 1e-9)\n\n    # Calculate the final priority score as a weighted sum of exploitation score and random noise\n    priorities = (1 - beta) * exploitation_score + beta * noise\n\n    return priorities",
    "response_id": 9,
    "obj": 4.178300757877951,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 436.36139452850404,
    "mi": 75.99522886314415,
    "token_count": 351.0,
    "exec_success": true
  }
]