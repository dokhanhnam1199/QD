[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize the score to be between 0 and 1 for valid bins.\n\n    Args:\n        score: Score to be normalized.\n        valid_bins: Boolean array indicating valid bins.\n\n    Return:\n        Normalized score.\n    \"\"\"\n    if np.any(valid_bins):\n        max_score = np.max(score[valid_bins])\n        min_score = np.min(score[valid_bins])\n        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)\n    else:\n        score[:] = 0  # If no valid bins, set all scores to 0\n    return score\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function simplifies the priority calculation by directly using the remaining capacity after adding the item,\n    and introduces randomness for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate validity of bins\n    valid_bins = bins_remain_cap >= item\n\n    # Prioritize bins that can fit the item with the least remaining capacity\n    priorities = np.where(valid_bins, -(bins_remain_cap - item), -np.inf)\n    priorities = _normalize_score(priorities, valid_bins)\n\n    # Introduce randomness for exploration\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  # No noise for bins that cannot hold the item\n    noise = _normalize_score(noise, valid_bins)\n\n    # Combine priority and noise\n    priorities = priorities + noise\n\n    return priorities",
    "response_id": 0,
    "obj": 4.866374152373351,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize the score to be between 0 and 1 for valid bins.\n\n    Args:\n        score: Score to be normalized.\n        valid_bins: Boolean array indicating valid bins.\n\n    Return:\n        Normalized score.\n    \"\"\"\n    if np.any(valid_bins):\n        max_score = np.max(score[valid_bins])\n        min_score = np.min(score[valid_bins])\n        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)\n    else:\n        score[:] = 0  # If no valid bins, set all scores to 0\n    return score\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item with the least remaining capacity after addition.\n    It introduces scaled noise for better exploration-exploitation trade-off.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate validity of bins\n    valid_bins = bins_remain_cap >= item\n    \n    # Prioritize bins that can accommodate the item with the least remaining capacity after addition\n    priorities = np.where(valid_bins, bins_remain_cap - item, np.inf)\n    priorities = _normalize_score(-priorities, valid_bins)  # Negate to prioritize lower remaining capacity\n    \n    # Introduce scaled noise for exploration\n    noise = np.random.uniform(0, 1e-2, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  # Ensure bins that cannot hold the item have zero noise\n    priorities += noise\n    \n    # Ensure that bins that cannot hold the item have the lowest priority\n    priorities[~valid_bins] = -np.inf\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.01) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    It introduces a small random noise for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority based on how tightly bins can fit the item\n    priorities = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise for exploration\n    noise = np.random.uniform(-alpha, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = 0  # No noise for bins that cannot hold the item\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, \n    and introduces controlled randomness to balance exploitation and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - (remaining_after_addition / (bins_remain_cap + 1e-9)), 0)\n    \n    # Introduce controlled randomness to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))\n    noise[~valid_bins] = 0  \n    \n    # Combine the priorities and noise\n    priorities = (1 - alpha) * priorities + alpha * noise\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.108496210610296,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize the score to be between 0 and 1 for valid bins.\n\n    Args:\n        score: Score to be normalized.\n        valid_bins: Boolean array indicating valid bins.\n\n    Return:\n        Normalized score.\n    \"\"\"\n    if np.any(valid_bins):\n        max_score = np.max(score[valid_bins])\n        min_score = np.min(score[valid_bins])\n        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)\n    else:\n        score[:] = 0  # If no valid bins, set all scores to 0\n    return score\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a simplified priority function that prioritizes bins \n    that can accommodate the item with the least remaining capacity after addition, \n    and introduces a small amount of exploration noise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate validity of bins\n    valid_bins = bins_remain_cap >= item\n    \n    # Prioritize bins that can accommodate the item with the least remaining capacity after addition\n    priorities = np.where(valid_bins, bins_remain_cap - item, -np.inf)\n    priorities = _normalize_score(priorities, valid_bins)\n    \n    # Introduce a small amount of exploration noise\n    noise = np.random.uniform(0, 1e-2, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  # Ensure bins that cannot hold the item have zero noise\n    priorities += noise\n    \n    # Ensure bins that cannot hold the item have the lowest priority\n    priorities[~valid_bins] = -np.inf\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a simplified priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    priorities[valid_bins] = (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + 1e-9)\n    \n    # Introduce controlled randomness only for valid bins\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1, size=len(priorities))\n    priorities = alpha * priorities + (1 - alpha) * noise * valid_bins\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.238133226964499,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Introduce controlled randomness only to valid bins\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.01, size=len(priorities))  # Scaled noise for exploration\n    priorities = np.where(valid_bins, priorities + noise, -np.inf)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1, noise_scale: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the normalization and scaling.\n        noise_scale: Scale of the random noise for exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Normalize priorities to a suitable range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = alpha * (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, noise_scale, size=len(priorities))  \n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.4674910251296325,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, \n    and introduces controlled randomness to balance exploitation and exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, np.exp(-remaining_after_addition / item), 0)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.1, size=len(priorities))  \n    priorities = priorities * 0.9 + noise * 0.1  \n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-2) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    A small random noise is added for exploration-exploitation balance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority directly based on remaining capacity after addition\n    priorities = np.where(bins_remain_cap >= item, -bins_remain_cap + item, -np.inf)\n    \n    # Add a small random noise for exploration-exploitation balance, scaled by alpha\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = 0  # Ensure bins that cannot hold the item have zero noise\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 53.1508495181978,
    "mi": 71.2462873851019,
    "token_count": 105.0,
    "exec_success": true
  }
]