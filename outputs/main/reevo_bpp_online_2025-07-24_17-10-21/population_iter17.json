[
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    It introduces a small random noise for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority based on how tightly bins can fit the item\n    priorities = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    priorities = -priorities  # Higher priority for smaller remaining capacity\n    \n    # Add a small random noise for exploration, scaled by alpha\n    noise = np.random.uniform(-alpha, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = -np.inf  # Ensure bins that cannot hold the item have lowest priority\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response1.txt_stdout.txt",
    "code_path": "problem_iter16_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function directly rewards bins that are most suitable for the item.\n    It prioritizes bins that can accommodate the item and have the least remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Directly reward bins with the least remaining capacity that can fit the item\n    priorities = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise for exploration\n    noise = np.random.uniform(-alpha, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = 0  # No noise for bins that cannot hold the item\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response2.txt_stdout.txt",
    "code_path": "problem_iter16_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function focusing on the remaining capacity after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, directly use the negative remaining capacity after addition as priority\n    priorities = np.where(valid_bins, - (bins_remain_cap - item), -np.inf)\n    \n    # Introduce controlled randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.05, size=len(priorities))  \n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response3.txt_stdout.txt",
    "code_path": "problem_iter16_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that considers both the fit of the item to the bin and introduces controlled randomness for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Introduce controlled randomness directly\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))\n    priorities = alpha * priorities + (1 - alpha) * noise * valid_bins\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response4.txt_stdout.txt",
    "code_path": "problem_iter16_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function focusing on fit and scaled exploration noise.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Introduce scaled randomness directly for exploration\n    noise = np.random.uniform(0, 1, size=len(priorities))  # Uniform noise between 0 and 1\n    priorities += 1e-2 * noise * valid_bins  # Scaled noise for valid bins\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response5.txt_stdout.txt",
    "code_path": "problem_iter16_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function focusing on fit and controlled randomness for exploration.\n    It directly uses negative remaining capacity after adding the item and scales noise for better balance.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Introduce scaled randomness for exploration\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  \n    priorities = priorities + alpha * noise * valid_bins  \n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response6.txt_stdout.txt",
    "code_path": "problem_iter16_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements an improved priority function focusing on fit, \n    meaningful score differences, and controlled randomness for online Bin Packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Introduce controlled randomness directly, scaling it according to the range of priorities\n    np.random.seed(0)  # For reproducibility\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 0\n    noise_scale = (max_priority - min_priority) * 0.01  # Scale noise relative to priority range\n    noise = np.random.uniform(0, noise_scale, size=len(priorities))\n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response7.txt_stdout.txt",
    "code_path": "problem_iter16_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements an improved priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item relative to their original capacity, \n    with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assume the original capacity of bins is 1.0 for simplicity; adjust as necessary\n    original_capacity = 1.0\n    \n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity relative to their original capacity after addition\n    relative_remaining = remaining_after_addition / (bins_remain_cap + 1e-9)\n    priorities = np.where(valid_bins, -relative_remaining, -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.01, size=len(priorities))  # Reduced noise for more exploitation\n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response8.txt_stdout.txt",
    "code_path": "problem_iter16_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Clip priorities to avoid inf\n    priorities = np.clip(priorities, -1e9, 1e9)\n    \n    # Introduce controlled randomness only for valid bins using a weighted sum\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1, size=len(priorities))\n    priorities = alpha * (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9) + (1 - alpha) * noise * valid_bins\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.238133226964499,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response9.txt_stdout.txt",
    "code_path": "problem_iter16_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements an improved priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    The priorities are normalized and scored relative to the best and worst possible bins.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-9), -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins using relative scoring\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities_valid = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    priorities[valid_bins] = priorities_valid\n    \n    # Apply an exponential transformation to enhance discriminability among valid bins\n    priorities[valid_bins] = np.exp(priorities[valid_bins] / (np.max(priorities[valid_bins]) + 1e-9))\n    priorities[valid_bins] = priorities[valid_bins] / (np.sum(priorities[valid_bins]) + 1e-9)\n    \n    # Introduce controlled randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.01, size=len(priorities))  # Reduced noise for less exploration\n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    # Renormalize after adding noise\n    priorities[valid_bins] = priorities[valid_bins] / (np.sum(priorities[valid_bins]) + 1e-9)\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.487435181491823,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 262.3084942066396,
    "mi": 75.27171578985286,
    "token_count": 248.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, bins_remain_cap - remaining_after_addition, -np.inf)\n    \n    # Introduce controlled randomness directly without normalization\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.1 * np.max(bins_remain_cap), size=len(priorities))  # Scaled noise for exploration\n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 68.42175648563453,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response1.txt_stdout.txt",
    "code_path": "problem_iter17_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that directly uses the remaining capacity of the bins.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, prioritize those with the least remaining capacity\n    priorities = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Introduce controlled randomness, scaled appropriately for meaningful score differences\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(-1, 1, size=len(priorities))  # Scaled noise for exploration\n    priorities += noise * valid_bins * 1e-6  # Only add noise to valid bins, with a small scale\n    \n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 68.42175648563453,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response2.txt_stdout.txt",
    "code_path": "problem_iter17_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a simplified priority function that directly uses remaining capacity, \n    avoids unnecessary normalization, and scales noise appropriately for online Bin Packing Problem.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, prioritize those with the least remaining capacity\n    priorities = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Introduce controlled randomness with appropriately scaled noise\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, np.max(bins_remain_cap) * 0.01, size=len(priorities))  # Scaled noise for exploration\n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 68.42175648563453,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response3.txt_stdout.txt",
    "code_path": "problem_iter17_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a simplified priority function that directly uses remaining capacity and scales noise appropriately.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, prioritize those with the least remaining capacity\n    priorities = np.where(valid_bins, bins_remain_cap, -np.inf)\n    \n    # Introduce scaled noise for exploration, only to valid bins\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  # Scaled noise for exploration\n    priorities += noise * valid_bins * 0.1  # Scale noise to balance exploitation-exploration\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 68.42175648563453,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response4.txt_stdout.txt",
    "code_path": "problem_iter17_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that directly uses the remaining capacity of the bins.\n    It assigns higher priority to bins with just enough capacity, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, prioritize those with the least remaining capacity\n    priorities = np.where(valid_bins, bins_remain_cap, -1e9)\n    \n    # Introduce controlled randomness with appropriately scaled noise\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  # Scaled noise for exploration\n    priorities += noise * valid_bins * 1e-6  # Only add noise to valid bins with a small scale\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 51.80615605397529,
    "mi": 68.42175648563453,
    "token_count": 96.0,
    "exec_success": true
  }
]