[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item with the least remaining capacity.\n    It balances between exploitation and exploration by combining a fit score with random noise.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and randomness.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to bins that can hold the item and have the least remaining capacity\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priorities for valid bins to be between 0 and 1\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priorities[valid_bins])\n        min_priority = np.min(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-10)\n    \n    # Add a small random noise for exploration\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1e-3, size=len(priorities))  \n    noise[~valid_bins] = 0  \n    \n    # Combine the normalized priorities and noise\n    priorities = alpha * priorities + (1 - alpha) * noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that assigns higher priority to bins \n    that have just enough capacity to hold the item, balancing between \"fit\" score and randomness.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and randomness.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    remaining_after_addition = np.where(valid_bins, bins_remain_cap - item, np.inf)\n    priorities = -remaining_after_addition\n    \n    # Add a small random noise to the priority scores for exploration\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1, size=len(priorities))\n    noise[~valid_bins] = 0  \n    \n    # Combine the priorities and noise\n    priorities = alpha * priorities + (1 - alpha) * noise\n    \n    # Ensure bins that cannot hold the item have the lowest priority\n    priorities[~valid_bins] = -np.inf\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    It introduces a minimal random noise for better exploration-exploitation balance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign lowest priority to bins that cannot hold the item\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, np.inf)\n    \n    # Introduce a small random noise for exploration-exploitation balance\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[remaining_after_addition == np.inf] = 0  # Ensure bins that cannot hold the item have zero noise, but this line is redundant because remaining_after_addition will never be np.inf\n    \n    # Calculate the final priority score\n    priorities = priorities + noise\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    A small random noise is added for exploration-exploitation balance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate priority directly based on remaining capacity after addition\n    priorities = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise for exploration-exploitation balance, scaled by alpha\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = 0  # Ensure bins that cannot hold the item have zero noise\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item and have the least remaining capacity after addition.\n    It introduces a minimal random noise for better exploration-exploitation balance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign lowest priority to bins that cannot hold the item\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, np.inf)\n    \n    # Introduce a small random noise for exploration-exploitation balance\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[remaining_after_addition == np.inf] = 0  # Ensure bins that cannot hold the item have zero noise, but this line is not necessary because remaining_after_addition will never be inf\n    \n    # Calculate the final priority score\n    priorities = priorities + noise\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.5, beta: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function decomposes the priority into multiple scores: fit score, remaining capacity score, \n    and random noise for exploration. It normalizes these scores and combines them using weighted sums.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and \"least remaining capacity\" score.\n        beta: Parameter controlling the trade-off between exploitation and exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate validity of bins\n    valid_bins = bins_remain_cap >= item\n\n    # Fit score: prioritize bins that can accommodate the item with the least remaining capacity after addition\n    fit_score = np.where(valid_bins, bins_remain_cap - item, -np.inf)\n    fit_score = _normalize_score(fit_score, valid_bins)\n\n    # Remaining capacity score: prioritize bins with the least remaining capacity among valid bins\n    remain_score = np.where(valid_bins, -bins_remain_cap, 0)\n    remain_score = _normalize_score(remain_score, valid_bins)\n\n    # Exploitation score: weighted sum of fit score and remaining capacity score\n    exploitation_score = alpha * fit_score + (1 - alpha) * remain_score\n\n    # Exploration noise: random noise for valid bins\n    noise = np.random.uniform(0, 1, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  # Ensure bins that cannot hold the item have zero noise\n    noise = _normalize_score(noise, valid_bins)\n\n    # Final priority score: weighted sum of exploitation score and exploration noise\n    priorities = (1 - beta) * exploitation_score + beta * noise\n\n    return priorities\n\n\ndef _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Normalize the score to be between 0 and 1 for valid bins.\n\n    Args:\n        score: Score to be normalized.\n        valid_bins: Boolean array indicating valid bins.\n\n    Return:\n        Normalized score.\n    \"\"\"\n    if np.any(valid_bins):\n        max_score = np.max(score[valid_bins])\n        min_score = np.min(score[valid_bins])\n        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)\n    else:\n        score[:] = 0  # If no valid bins, set all scores to 0\n    return score",
    "response_id": 5,
    "obj": 149.25209413641804,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a simplified priority function that considers the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        epsilon: A small value added for numerical stability.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on remaining capacity after addition, with a very low priority for bins that cannot hold the item\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -1e10)\n    \n    # Add a small random noise for exploration\n    priorities += np.random.uniform(0, epsilon, size=len(priorities))\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function directly uses the negative remaining capacity after addition as priority scores \n    for valid bins and adds a small random noise for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Weight for the priority score.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    remaining_after_addition = bins_remain_cap - item\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    valid_bins = priorities != -np.inf\n    \n    # Directly use the calculated priorities for valid bins\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 0\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    priorities[~valid_bins] = 0\n    \n    # Adjust the noise scale for a better trade-off\n    noise = np.random.uniform(0, 1e-4, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  \n    \n    # Combine the priorities and noise with a weighted sum\n    priorities = alpha * priorities + (1 - alpha) * noise\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item, have the least remaining capacity after addition,\n    and introduces a controlled randomness for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that can accommodate the item get priority based on how tightly they can fit the item\n    priorities = np.where(bins_remain_cap >= item, -(bins_remain_cap - item), -np.inf)\n    \n    # Introduce controlled randomness for exploration\n    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))\n    noise[bins_remain_cap < item] = 0  # No noise for bins that cannot hold the item\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.9) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item, have the least remaining capacity after addition,\n    and balances between exploitation and exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the trade-off between \"fit\" score and random noise.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        max_priority = np.max(priorities[valid_bins])\n        min_priority = np.min(priorities[valid_bins])\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-10)\n    \n    # Scale the noise to be comparable with the normalized priorities\n    np.random.seed(0)  \n    noise = np.random.uniform(0, 1, size=len(priorities))\n    noise[~valid_bins] = 0  \n    \n    # Adaptively adjust alpha based on the number of valid bins\n    num_valid_bins = np.sum(valid_bins)\n    adaptive_alpha = alpha if num_valid_bins > 10 else alpha * (num_valid_bins / 10)\n    \n    # Combine the normalized priorities and noise with adaptive alpha\n    priorities = adaptive_alpha * priorities + (1 - adaptive_alpha) * noise\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.238133226964499,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 254.373142062517,
    "mi": 80.0250959609732,
    "token_count": 218.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and introduces controlled randomness.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / bins_remain_cap.max(), -1)\n    \n    # Normalize the priority scores to be between 0 and 1\n    priorities = (priorities - priorities.min()) / (priorities.max() - priorities.min() + 1e-9)\n    \n    # Introduce controlled randomness by adding a small scaled noise\n    np.random.seed(0)  # For reproducibility\n    noise_scale = 0.01  # Scale of the noise\n    priorities += np.random.uniform(-noise_scale, noise_scale, size=len(priorities))\n    \n    # Ensure priorities are still within [0, 1] after adding noise\n    priorities = np.clip(priorities, 0, 1)\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 188.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-9), -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.1, size=len(priorities))  # Scaled noise for exploration\n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.008775428799367,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 188.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and introduces controlled randomness.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # Normalize the remaining capacity after addition for valid bins\n    min_remaining = np.min(remaining_after_addition[valid_bins]) if np.any(valid_bins) else 0\n    max_remaining = np.max(remaining_after_addition[valid_bins]) if np.any(valid_bins) else 1  # Avoid division by zero\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - (remaining_after_addition - min_remaining) / (max_remaining - min_remaining + 1e-9), -np.inf)\n    \n    # Introduce controlled randomness by adding noise scaled to the priority range\n    noise_scale = 1e-2  # Scale of the noise relative to the priority range\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(-noise_scale, noise_scale, size=len(priorities))\n    priorities += noise\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.058635819704831,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 188.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, \n    and introduces controlled randomness to balance exploitation and exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - (remaining_after_addition / bins_remain_cap), 0)\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n    \n    # Introduce controlled randomness to balance exploitation and exploration\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 0.1, size=len(priorities))  # Scale noise to balance exploitation and exploration\n    priorities = priorities * 0.9 + noise * 0.1  # Mix the normalized priorities with noise\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 188.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and introduces controlled randomness.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - remaining_after_addition / (bins_remain_cap + 1e-9), 0)\n    \n    # Normalize the priority scores to be within [0, 1] range for valid bins\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 1\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness by adding a scaled noise to the priority scores\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1e-2, size=len(priorities))  # Scaled noise\n    priorities += noise\n    \n    # Ensure that bins that cannot hold the item still have the lowest priority\n    priorities[~valid_bins] = -np.inf\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 155.88872502451935,
    "mi": 76.54505240657787,
    "token_count": 188.0,
    "exec_success": true
  }
]