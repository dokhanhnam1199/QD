[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, (bins_remain_cap - remaining_capacities) / bin_capacity + remaining_capacities / bin_capacity, -1e10)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[valid_bins] = 1.0\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n2\n75.28421251514429\n87.94640401308628\n111\n"
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Priority is a combination of how well the item fits in the bin and whether it can fit\n    priorities = np.where(can_fit, \n                          # Prioritize bins that are filled to a higher level after adding the item\n                          (bins_remain_cap - remaining_after_addition) / bin_capacity + \n                          # Prioritize bins with less remaining capacity among those that can fit the item\n                          (1 - remaining_after_addition / bins_remain_cap), \n                          -np.inf)\n    \n    # Normalize the priorities to avoid overflow and ensure that the highest priority is 0\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # No bin can fit the item\n        priorities = np.zeros_like(priorities)\n    else:\n        priorities = priorities - max_priority\n    \n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n2\n75.28421251514429\n87.94640401308628\n111\n"
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a simple yet effective priority function that considers the remaining capacity of the bins.\n    It prioritizes bins that can accommodate the item and have the least remaining capacity.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can accommodate the item get priority based on their remaining capacity after addition\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 75.28421251514429,
    "mi": 87.94640401308628,
    "token_count": 111.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The maximum capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_add >= 0\n    \n    # For bins with enough capacity, priority is a balance between minimizing remaining capacity and not being too full\n    # For bins without enough capacity, priority is negatively large\n    priorities = np.where(valid_bins, (bins_remain_cap - remaining_after_add) / bin_capacity - remaining_after_add / bin_capacity, -1e6)\n    \n    # Normalize priorities for valid bins to be within [0,1] range\n    priorities_valid = priorities[valid_bins]\n    min_priority = np.min(priorities_valid) if len(priorities_valid) > 0 else 0\n    max_priority = np.max(priorities_valid) if len(priorities_valid) > 0 else 1\n    \n    if max_priority != min_priority:\n        priorities[valid_bins] = (priorities_valid - min_priority) / (max_priority - min_priority)\n    else:\n        priorities[valid_bins] = 1\n    \n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n2\n75.28421251514429\n87.94640401308628\n111\n"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: Capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize based on how full the bin will be after adding the item\n                          (bin_capacity - remaining_after_addition) / bin_capacity, \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n2\n75.28421251514429\n87.94640401308628\n111\n"
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on whether the bin can fit the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can fit the item, prioritize based on remaining capacity\n                          bins_remain_cap - item, \n                          # For bins that cannot fit the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 75.28421251514429,
    "mi": 87.94640401308628,
    "token_count": 111.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.5, beta: float = 2.0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        alpha: Parameter controlling the trade-off between remaining capacity and \"fit\".\n        beta: Parameter controlling the non-linearity of the scoring function.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priorities with negative infinity for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # Calculate the \"fit\" score for valid bins, balancing between remaining capacity and item size\n    fit_score = np.exp(-((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]) ** beta)\n    \n    # Calculate priorities for valid bins based on a combination of remaining capacity and \"fit\" score\n    priorities[valid_bins] = alpha * (bins_remain_cap[valid_bins] - item) + (1 - alpha) * fit_score\n    \n    return priorities",
    "response_id": 6,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 75.28421251514429,
    "mi": 87.94640401308628,
    "token_count": 111.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign priority based on the remaining capacity after adding the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          -remaining_after_addition, \n                          -np.inf)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 75.28421251514429,
    "mi": 87.94640401308628,
    "token_count": 111.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priorities with negative infinity for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # Calculate the \"best fit\" score, which is a combination of the remaining capacity after adding the item and the proportion of the bin that will be filled\n    remaining_after_addition = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] = -0.7 * (remaining_after_addition / bin_capacity) ** 2 - 0.3 * np.abs(remaining_after_addition / (bins_remain_cap[valid_bins] - item / 2))\n    \n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n2\n75.28421251514429\n87.94640401308628\n111\n"
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can fit the item, prioritize those with the least remaining capacity\n                          bins_remain_cap - remaining_after_addition, \n                          # For bins that cannot fit the item, assign a very low priority\n                          -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # If all bins are too small, consider opening a new bin\n        priorities = np.where(bins_remain_cap == bin_capacity, 1.0, -np.inf)\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n2\n75.28421251514429\n87.94640401308628\n111\n"
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and normalizes the priority scores.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - (remaining_after_addition / bins_remain_cap), 0)\n    \n    # To balance exploration and exploitation, we can add a small random noise to the priority scores\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 151.6206750336681,
    "mi": 76.0192027678051,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and normalizes the priority scores.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - remaining_after_addition / (bins_remain_cap + 1e-12), 0)\n    \n    # Normalize the priority scores to be within [0, 1]\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority + 1e-12)\n    \n    # To balance exploration and exploitation, add a small random noise to the priority scores\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 151.6206750336681,
    "mi": 76.0192027678051,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and normalizes the priority scores.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, 1 - remaining_after_addition / (bins_remain_cap + 1e-9), 0)\n    \n    # Normalize the priority scores to be within [0, 1]\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    priorities = (priorities - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # To balance exploration and exploitation, add a small random noise to the priority scores\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-3, size=len(priorities)) * (1 - priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 151.6206750336681,
    "mi": 76.0192027678051,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and normalizes the priority scores.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / bins_remain_cap, -1)\n    \n    # Normalize the priority scores to be within [0, 1] range for valid bins\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 0\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Invalid bins should have priority 0\n    priorities[~valid_bins] = 0\n    \n    # To balance exploration and exploitation, add a small noise to the priorities\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 151.6206750336681,
    "mi": 76.0192027678051,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item and normalizes the priority scores.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-10), -np.inf)\n    \n    # Normalize the priority scores for valid bins\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 0\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-10) if max_priority != min_priority else 1\n    \n    # To balance exploration and exploitation, add a small random noise to the priority scores\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 151.6206750336681,
    "mi": 76.0192027678051,
    "token_count": 177.0,
    "exec_success": true
  }
]