```python
import numpy as np

def _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:
    """
    Normalize the score to be between 0 and 1 for valid bins.

    Args:
        score: Score to be normalized.
        valid_bins: Boolean array indicating valid bins.

    Return:
        Normalized score.
    """
    if np.any(valid_bins):
        max_score = np.max(score[valid_bins])
        min_score = np.min(score[valid_bins])
        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)
    else:
        score[:] = 0  # If no valid bins, set all scores to 0
    return score

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This function prioritizes bins that can accommodate the item with the least remaining capacity after addition.
    It introduces scaled noise for better exploration-exploitation trade-off.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate validity of bins
    valid_bins = bins_remain_cap >= item
    
    # Prioritize bins that can accommodate the item with the least remaining capacity after addition
    priorities = np.where(valid_bins, bins_remain_cap - item, np.inf)
    priorities = _normalize_score(-priorities, valid_bins)  # Negate to prioritize lower remaining capacity
    
    # Introduce scaled noise for exploration
    noise = np.random.uniform(0, 1e-2, size=len(bins_remain_cap))
    noise[~valid_bins] = 0  # Ensure bins that cannot hold the item have zero noise
    priorities += noise
    
    # Ensure that bins that cannot hold the item have the lowest priority
    priorities[~valid_bins] = -np.inf
    
    return priorities
```
