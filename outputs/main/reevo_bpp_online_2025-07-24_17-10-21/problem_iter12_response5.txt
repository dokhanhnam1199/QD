```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.5, beta: float = 0.1) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This function decomposes the priority into multiple scores: fit score, remaining capacity score, 
    and random noise for exploration. It normalizes these scores and combines them using weighted sums.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        alpha: Parameter controlling the trade-off between "fit" score and "least remaining capacity" score.
        beta: Parameter controlling the trade-off between exploitation and exploration.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate validity of bins
    valid_bins = bins_remain_cap >= item

    # Fit score: prioritize bins that can accommodate the item with the least remaining capacity after addition
    fit_score = np.where(valid_bins, bins_remain_cap - item, -np.inf)
    fit_score = _normalize_score(fit_score, valid_bins)

    # Remaining capacity score: prioritize bins with the least remaining capacity among valid bins
    remain_score = np.where(valid_bins, -bins_remain_cap, 0)
    remain_score = _normalize_score(remain_score, valid_bins)

    # Exploitation score: weighted sum of fit score and remaining capacity score
    exploitation_score = alpha * fit_score + (1 - alpha) * remain_score

    # Exploration noise: random noise for valid bins
    noise = np.random.uniform(0, 1, size=len(bins_remain_cap))
    noise[~valid_bins] = 0  # Ensure bins that cannot hold the item have zero noise
    noise = _normalize_score(noise, valid_bins)

    # Final priority score: weighted sum of exploitation score and exploration noise
    priorities = (1 - beta) * exploitation_score + beta * noise

    return priorities


def _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:
    """
    Normalize the score to be between 0 and 1 for valid bins.

    Args:
        score: Score to be normalized.
        valid_bins: Boolean array indicating valid bins.

    Return:
        Normalized score.
    """
    if np.any(valid_bins):
        max_score = np.max(score[valid_bins])
        min_score = np.min(score[valid_bins])
        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)
    else:
        score[:] = 0  # If no valid bins, set all scores to 0
    return score
```
