[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with scaled exploration noise.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Scale priorities to avoid extreme values and add noise for exploration\n    max_priority = np.max(priorities[valid_bins]) if np.any(valid_bins) else 0\n    min_priority = np.min(priorities[valid_bins]) if np.any(valid_bins) else 0\n    priority_range = max_priority - min_priority + 1e-9\n    \n    # Introduce scaled randomness for exploration relative to priority range\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))\n    priorities = np.where(valid_bins, (priorities - min_priority) / priority_range + alpha * noise, -np.inf)\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.2580773833266905,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with adaptive and controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-9), -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priority_range = max_priority - min_priority\n    if priority_range > 0:\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / priority_range\n    \n    # Introduce adaptive and controlled randomness relative to the priority range\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  \n    noise = (noise - np.min(noise)) / (np.max(noise) - np.min(noise) + 1e-9)  # Normalize noise\n    noise *= priority_range  # Scale noise by the priority range for adaptiveness\n    priorities += alpha * noise * valid_bins  \n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function rewards bins that are closest to being full and can fit the item, \n    and adds controlled noise relative to the problem scale for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the scale of random noise relative to the item size.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = bins_remain_cap >= item\n    \n    # Reward bins that are closest to being full and can fit the item\n    priorities = np.where(valid_bins, bins_remain_cap - item, -np.inf)\n    \n    # Introduce controlled randomness relative to the item size for exploration\n    noise = np.random.uniform(-alpha * item, alpha * item, size=len(bins_remain_cap))\n    noise[~valid_bins] = 0  # No noise for bins that cannot hold the item\n    \n    priorities += noise\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.25209413641804,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    valid_priorities = priorities[valid_bins]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        priorities[valid_bins] = (valid_priorities - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled randomness scaled with the maximum remaining capacity\n    max_remain_cap = np.max(bins_remain_cap)\n    if max_remain_cap > 0:\n        noise_scale = 0.1 * max_remain_cap / (1 + max_remain_cap)\n    else:\n        noise_scale = 0.01  # default noise scale when max_remain_cap is 0\n    \n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, noise_scale, size=len(priorities))  \n    priorities += noise * valid_bins  # Only add noise to valid bins\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.268049461507774,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function focusing on the remaining capacity after adding the item \n    and scales noise relative to a tunable parameter (`alpha`) for better balance between exploration and exploitation.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Normalize priorities to a suitable range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priority_range = max_priority - min_priority\n    if priority_range > 0:\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / priority_range\n    \n    # Introduce scaled randomness for exploration\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  \n    priorities = priorities + alpha * noise * valid_bins  \n    \n    return priorities",
    "response_id": 4,
    "obj": 4.2580773833266905,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-9), -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priority_range = max_priority - min_priority\n    if priority_range > 0:\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / priority_range\n    else:\n        priorities[valid_bins] = 1.0  # When all valid bins have the same priority, set to max\n    \n    # Introduce controlled randomness relative to the priority range, ensuring it's smaller than the range\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(-0.01, 0.01, size=len(priorities))  # Smaller scaled noise for exploration\n    priorities = np.clip(priorities + noise * valid_bins, 0, 1)  # Only add noise to valid bins and clip to [0,1]\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-9), -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled and normalized randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  \n    priorities += alpha * noise * valid_bins  \n    \n    # Ensure priorities are within [0, 1] after adding noise\n    priorities = np.clip(priorities, 0, 1)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.11846828879138,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition / (bins_remain_cap + 1e-9), -np.inf)\n    \n    # Normalize priorities to [0, 1] range for valid bins\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    # Introduce controlled and normalized randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))  \n    noise = np.where(valid_bins, noise, 0)  # Zero noise for invalid bins\n    \n    # Ensure that the noise is in the same range as priorities\n    priorities = priorities + alpha * noise\n    \n    # Re-normalize priorities to maintain the range [0, 1] after adding noise\n    min_priority = np.min(priorities[valid_bins])\n    max_priority = np.max(priorities[valid_bins])\n    priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.008775428799367,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that prioritizes bins with just enough capacity to hold the item and introduces tunable randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration. Defaults to 0.1.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Introduce controlled randomness for exploration directly to valid bins\n    np.random.seed(0)  # For reproducibility\n    priorities_valid = priorities[valid_bins]\n    noise = np.random.uniform(0, alpha * (np.max(priorities_valid) - np.min(priorities_valid)), size=np.sum(valid_bins))\n    priorities[valid_bins] += noise\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.168328679696844,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item, with controlled randomness for exploration.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        alpha: Parameter controlling the level of exploration.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # Normalize priorities to [0, 1] range\n    valid_priorities = priorities[valid_bins]\n    if len(valid_priorities) > 0:\n        min_priority, max_priority = np.min(valid_priorities), np.max(valid_priorities)\n        priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority + 1e-9)\n    else:\n        priorities = np.zeros_like(priorities)\n    \n    # Introduce controlled and normalized randomness\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1, size=len(priorities))\n    \n    # Scale the noise by alpha and add it to the priorities\n    priorities = priorities * (1 - alpha) + noise * alpha\n    \n    # Set invalid bins to -inf\n    priorities = np.where(valid_bins, priorities, -np.inf)\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.238133226964499,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 185.4406125843753,
    "mi": 78.7511774954567,
    "token_count": 215.0,
    "exec_success": true
  }
]