```python
import numpy as np

def _normalize_score(score: np.ndarray, valid_bins: np.ndarray) -> np.ndarray:
    """
    Normalize the score to be between 0 and 1 for valid bins.

    Args:
        score: Score to be normalized.
        valid_bins: Boolean array indicating valid bins.

    Return:
        Normalized score.
    """
    if np.any(valid_bins):
        max_score = np.max(score[valid_bins])
        min_score = np.min(score[valid_bins])
        score[valid_bins] = (score[valid_bins] - min_score) / (max_score - min_score + 1e-9)
    else:
        score[:] = 0  # If no valid bins, set all scores to 0
    return score

def priority_v2(item: float, bins_remain_cap: np.ndarray, alpha: float = 0.1) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This function simplifies the priority calculation by directly using the remaining capacity after adding the item,
    and introduces randomness for exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        alpha: Parameter controlling the scale of random noise.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate validity of bins
    valid_bins = bins_remain_cap >= item

    # Prioritize bins that can fit the item with the least remaining capacity
    priorities = np.where(valid_bins, -(bins_remain_cap - item), -np.inf)
    priorities = _normalize_score(priorities, valid_bins)

    # Introduce randomness for exploration
    noise = np.random.uniform(0, alpha, size=len(bins_remain_cap))
    noise[~valid_bins] = 0  # No noise for bins that cannot hold the item
    noise = _normalize_score(noise, valid_bins)

    # Combine priority and noise
    priorities = priorities + noise

    return priorities
```
