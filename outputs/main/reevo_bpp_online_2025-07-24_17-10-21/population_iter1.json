[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # For bins that have enough capacity, prioritize those with less remaining capacity\n    enough_capacity = bins_remain_cap >= item\n    priorities_enough = -remaining_after_addition\n    \n    # For bins without enough capacity, assign a very low priority\n    priorities_not_enough = np.full_like(bins_remain_cap, -1e9)\n    priorities_not_enough[enough_capacity] = priorities_enough[enough_capacity]\n    \n    # Add a small random noise to break ties\n    np.random.seed(0)  # For reproducibility\n    priorities_not_enough += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities_not_enough",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\n    # To make the priority scores more distinguishable, we can add a small random noise\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n2\n66.60791492653966\n86.62739134690779\n114\n"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function that considers both the remaining capacity of the bins and the size of the item.\n    It assigns higher priority to bins that have just enough capacity to hold the item.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # For valid bins, prioritize those with the least remaining capacity after addition\n    priorities = np.where(valid_bins, -remaining_after_addition, -np.inf)\n    \n    # To make the priority scores more distinguishable, we can add a small random noise\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_add >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(valid_bins, -remaining_after_add, -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, remaining_capacities, -1e9)\n    \n    # To avoid selecting the bin with the least remaining capacity when multiple bins have enough capacity,\n    # we add a small random noise to the priorities\n    priorities += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remaining_cap_after_addition >= 0, \n                          bins_remain_cap - item,  # Priority is the remaining capacity after addition\n                          -1e10)  # A very low priority for bins that are too small\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = remaining_cap_after_addition >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 4,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity after addition\n                          -remaining_after_addition / bins_remain_cap, \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item should have the lowest priority\n    valid_bins = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item (First-Fit Decreasing inspiration)\n    priorities = np.where(valid_bins, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero and to make the priority more nuanced, we use a combination of the remaining capacity and a \"fullness\" measure\n    fullness_measure = bins_remain_cap / (bins_remain_cap.max() + 1e-6)  # Adding a small value to avoid division by zero\n    \n    # Give higher priority to bins that are more full but still can accommodate the item\n    priorities = np.where(valid_bins, priorities + fullness_measure, priorities)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize those with less remaining capacity\n                          -np.abs(remaining_after_addition - item / 2), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 7,
    "obj": 9.254088552054245,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition < 0, -np.inf, \n                          # Prioritize bins with less remaining capacity after addition (tighter fit)\n                          -np.abs(remaining_after_addition))\n    \n    # Add a small noise to the priority to avoid tie-breaking issues\n    np.random.seed(0)  # For reproducibility\n    priorities += np.random.uniform(-1e-6, 1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask out bins that cannot hold the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # For valid bins, prioritize those with less remaining capacity after addition\n    # For invalid bins, assign a very low priority\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -1e10)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Give high priority to bins that will have the least remaining capacity after adding the item\n    # This is to pack the bins as tightly as possible\n    tightness = -np.abs(remaining_after_addition)\n    \n    # Also consider the bins that are almost full, give them higher priority\n    # But penalize bins that can't fit the item\n    valid_bins = np.where(bins_remain_cap >= item, 1, 0)\n    priorities = tightness * valid_bins + np.where(bins_remain_cap >= item, 0, -1e6)\n    \n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can fit the item, prioritize those with the least remaining capacity\n                          -np.abs(remaining_after_addition), \n                          # For bins that cannot fit the item, assign a very low priority\n                          -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # If all bins are too small\n        priorities = np.zeros_like(priorities)\n    else:\n        priorities = priorities - max_priority  # Shift to start from 0\n    \n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Further prioritize bins that are almost full after adding the item\n    priorities = np.where((remaining_capacities >= 0) & (remaining_capacities <= item), priorities + 1, priorities)\n    \n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_cap_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    # To avoid division by zero, replace zero remaining capacity with a small value\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-9)\n    \n    # Also consider the ratio of item size to bin remaining capacity\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    ratio_priorities = -log_ratios\n    \n    # Combine the two priorities\n    priorities = np.where(can_fit, priorities + ratio_priorities, -np.inf)\n    \n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, prioritize based on how much capacity is left after addition\n    # and penalize bins that are too empty (to avoid fragmentation)\n    priorities[valid_bins_mask] = remaining_after_addition[valid_bins_mask] / bins_remain_cap[valid_bins_mask]\n    \n    # Further penalize bins that are almost empty to encourage packing items tightly\n    too_empty_bins_mask = (bins_remain_cap > item) & (bins_remain_cap < 2*item)\n    priorities[too_empty_bins_mask] -= 0.5\n    \n    return priorities",
    "response_id": 14,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 28, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'subtract' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n10\n2\n66.60791492653966\n86.62739134690779\n114\n"
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priorities with negative infinity for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # Calculate priorities for valid bins based on a combination of remaining capacity and \"fit\"\n    priorities[valid_bins] = -((bins_remain_cap[valid_bins] - item) ** 2) + 0.1 * bins_remain_cap[valid_bins]\n    \n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize those with the least remaining capacity\n                          -np.abs(remaining_after_addition), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -1e10)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    priorities = np.where(priorities == -1e10, priorities, priorities - max_priority)\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, we check if the item can fit into each bin\n    mask = bins_remain_cap >= item\n    \n    # For bins that can fit the item, we prefer the bin with the least remaining capacity\n    priorities = np.where(mask, bins_remain_cap.max() - bins_remain_cap, -np.inf)\n    \n    # To avoid division by zero, we add a small value to the denominator\n    eps = 1e-8\n    ratio_priorities = item / (bins_remain_cap + eps)\n    \n    # We combine the two priorities: the remaining capacity and the ratio of item size to remaining capacity\n    priorities = np.where(mask, priorities + ratio_priorities, priorities)\n    \n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # For bins that have enough capacity, prioritize the ones with the least remaining capacity after adding the item\n    enough_capacity = bins_remain_cap >= item\n    priorities = np.where(enough_capacity, -remaining_cap_after_add, -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities += np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    enough_cap_mask = remain_cap_after_add >= 0\n    \n    # Assign high priority to bins with enough capacity and low priority to others\n    priorities = np.where(enough_cap_mask, -remain_cap_after_add, -np.inf)\n    \n    # To differentiate bins with enough capacity, use the ratio of item size to bin capacity\n    ratios = item / bins_remain_cap\n    priorities_enough_cap = -ratios[enough_cap_mask]\n    priorities[enough_cap_mask] = priorities_enough_cap\n    \n    # Normalize priorities to avoid overflow\n    priorities = priorities - np.max(priorities)\n    \n    # Apply softmax to convert priorities into a probability distribution\n    exp_priorities = np.exp(priorities)\n    priorities = exp_priorities / np.sum(exp_priorities)\n    \n    return priorities",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Mask to identify bins that have enough capacity for the item\n    valid_bins = remaining_capacities >= 0\n    \n    # Initialize priorities with negative infinity for bins that can't fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, priority is a combination of the remaining capacity and the item size\n    # Here, we use a simple heuristic: prioritize bins with less remaining capacity after adding the item\n    # and also consider the ratio of the item size to the bin's remaining capacity before adding the item\n    priorities[valid_bins] = -(remaining_capacities[valid_bins] / bins_remain_cap[valid_bins])\n    \n    return priorities",
    "response_id": 20,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize based on remaining capacity\n                          -np.abs(remaining_after_addition - item / 2), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 21,
    "obj": 9.254088552054245,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that can't fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority as a combination of \n    # the remaining capacity and the ratio of item size to remaining capacity\n    priorities[valid_bins_mask] = remaining_cap_after_addition[valid_bins_mask] / (1 + np.log(item / bins_remain_cap[valid_bins_mask] + 1))\n    \n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities**2 + bins_remain_cap, -1e10)\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    valid_bins = remaining_capacities >= 0\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 23,
    "obj": 4.11846828879138,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item should have the lowest priority\n    priorities = np.where(remaining_after_addition >= 0, \n                           1 / (1 + np.abs(remaining_after_addition)), \n                           -np.inf)\n    \n    # To avoid division by zero and to make the priority of full bins the lowest\n    priorities = np.where(bins_remain_cap == 0, -np.inf, priorities)\n    \n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remain_cap_after_add = bins_remain_cap - item\n    \n    # Create a mask to identify bins that have enough capacity for the item\n    valid_bins = remain_cap_after_add >= 0\n    \n    # For bins with enough capacity, priority is inversely proportional to the remaining capacity after adding the item\n    # This encourages packing items tightly\n    priorities_valid = 1 / (remain_cap_after_add[valid_bins] + 1e-6)\n    \n    # For bins without enough capacity, assign a very low priority\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = priorities_valid\n    \n    # Normalize the priorities to be between 0 and 1 for valid bins\n    if np.any(valid_bins):\n        priorities[valid_bins] = (priorities[valid_bins] - np.min(priorities[valid_bins])) / (np.max(priorities[valid_bins]) - np.min(priorities[valid_bins]) + 1e-6)\n    \n    return priorities",
    "response_id": 25,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_add = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity for the item\n    valid_bins = remaining_after_add >= 0\n    \n    # For bins with enough capacity, priority is inversely proportional to the remaining capacity after adding the item\n    # For bins without enough capacity, priority is negatively large\n    priorities = np.where(valid_bins, -remaining_after_add, -1e6)\n    \n    # Normalize priorities for valid bins to be within a certain range to avoid extreme values\n    min_remaining = np.min(remaining_after_add[valid_bins]) if np.any(valid_bins) else 0\n    max_remaining = np.max(remaining_after_add[valid_bins]) if np.any(valid_bins) else 1\n    \n    if max_remaining != min_remaining:\n        priorities[valid_bins] = (priorities[valid_bins] - min_remaining) / (max_remaining - min_remaining)\n    else:\n        priorities[valid_bins] = 1\n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, -remaining_capacities + bins_remain_cap / np.sum(bins_remain_cap), -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    priorities = priorities - np.max(priorities)\n    priorities = np.exp(priorities) / np.sum(np.exp(priorities))\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity\n                          -np.abs(remaining_after_addition), \n                          # For bins that cannot accommodate the item, \n                          # assign a very low priority\n                          -np.inf)\n    \n    # Normalize the priorities to avoid very large numbers\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  # Check if at least one bin can accommodate the item\n        priorities = np.where(priorities != -np.inf, priorities - max_priority, -np.inf)\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Priority is a combination of how well the item fits in the bin and whether it can fit\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # Normalize the priorities to avoid overflow when item size is close to bin capacity\n    max_priority = np.max(priorities)\n    if max_priority == -np.inf:  # No bin can fit the item\n        priorities = np.zeros_like(priorities)\n    else:\n        priorities = priorities - max_priority\n    \n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 66.60791492653966,
    "mi": 86.62739134690779,
    "token_count": 114.0,
    "exec_success": true
  }
]