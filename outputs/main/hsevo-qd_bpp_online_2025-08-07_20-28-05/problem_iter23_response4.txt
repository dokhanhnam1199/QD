```python
# Adaptive priority combining inverse slack and rule weighting
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive epsilon-greedy inverse‑slack with rule‑based weighting.
    """
    import numpy as np
    if not hasattr(priority_v2, "initialized"):
        priority_v2.num_rules = 5
        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)
        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)
        priority_v2.epsilon_random = 0.1
        priority_v2.epsilon_w = 1e-9
        priority_v2.beta = 0.02
        priority_v2.initialized = True
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)
    leftovers = bins_remain_cap - item
    num_bins = bins_remain_cap.size
    scores = np.full((priority_v2.num_rules, num_bins), -np.inf, dtype=float)
    # base inverse‑slack score
    scores[0, feasible] = 1.0 / (leftovers[feasible] + 1.0) - priority_v2.beta * leftovers[feasible]**2
    # best‑fit
    scores[1, feasible] = -leftovers[feasible]
    # worst‑fit
    scores[2, feasible] = leftovers[feasible]
    # first‑fit
    idx = np.arange(num_bins)
    scores[3, feasible] = -idx[feasible]
    # fill‑balance
    mean_remain = np.mean(bins_remain_cap[feasible])
    scores[4, feasible] = -np.abs(leftovers[feasible] - mean_remain)
    # update rule‑based waste statistics
    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)
    for i in range(priority_v2.num_rules):
        if np.isfinite(scores[i]).any():
            best_idx = np.argmax(scores[i])
            waste_per_rule[i] = bins_remain_cap[best_idx] - item
        else:
            waste_per_rule[i] = np.inf
    for i, w in enumerate(waste_per_rule):
        if np.isfinite(w):
            priority_v2.sum_waste[i] += w
            priority_v2.count[i] += 1
    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)
    inv = 1.0 / (avg_waste + priority_v2.epsilon_w)
    total = inv.sum()
    weights = inv / total if total > 0 else np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)
    combined_scores = np.sum(weights[:, None] * scores, axis=0)
    rand_part = np.random.rand(num_bins)
    final_scores = (1 - priority_v2.epsilon_random) * combined_scores + priority_v2.epsilon_random * rand_part
    final_scores[~feasible] = -np.inf
    priority_v2.step = getattr(priority_v2, "step", 0) + 1
    return final_scores
```
