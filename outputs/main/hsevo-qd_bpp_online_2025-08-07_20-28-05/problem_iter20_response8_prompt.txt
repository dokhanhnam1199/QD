{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Combine inverse\u2011slack and linear\u2011slack with \u03b5\u2011greedy randomness.\n    \"\"\"\n    \u03b5\u2011greedy scoring: weighted sum of inverse slack and negative slack, with random tie\u2011breaker.\n    \"\"\"\n    epsilon = 0.15          # exploration factor\n    w_inv = 0.6             # weight for reciprocal slack\n    w_lin = 0.4             # weight for linear slack penalty\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    slack = bins_remain_cap[feasible] - item\n    base = w_inv * (1.0 / (slack + 1.0)) + w_lin * (-slack)\n    scores[feasible] = base\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    # softmax scaling for probability\u2011like priorities\n    finite_mask = np.isfinite(scores)\n    if not np.any(finite_mask):\n        return scores\n    max_score = np.max(scores[finite_mask])\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~finite_mask] = 0.0\n    probabilities = exp_scores / exp_scores.sum()\n    return probabilities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    if not hasattr(priority_v2, \"initialized\"):\n        priority_v2.num_rules = 4\n        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)\n        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)\n        priority_v2.step = 0\n        priority_v2.epsilon = 1e-9\n        priority_v2.initialized = True\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap - item\n    best_fit_score = np.where(feasible, -leftovers, -np.inf)\n    worst_fit_score = np.where(feasible, leftovers, -np.inf)\n    indices = np.arange(bins_remain_cap.shape[0] if hasattr(bins_remain_cap, \"shape\") else len(bins_remain_cap))\n    first_fit_score = np.where(feasible, -indices, -np.inf)\n    target = bins_remain_cap.mean()\n    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)\n    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]\n    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)\n    for i, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            waste_per_rule[i] = np.inf\n        else:\n            idx = np.argmax(scores)\n            waste_per_rule[i] = bins_remain_cap[idx] - item\n    for i in range(priority_v2.num_rules):\n        w = waste_per_rule[i]\n        if np.isfinite(w):\n            priority_v2.sum_waste[i] += w\n            priority_v2.count[i] += 1\n    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)\n    inv = 1.0 / (avg_waste + priority_v2.epsilon)\n    boost = np.zeros(priority_v2.num_rules, dtype=float)\n    boost_idx = priority_v2.step % priority_v2.num_rules\n    boost[boost_idx] = 1.0 / (priority_v2.step + 1)\n    raw_weights = inv + boost\n    total = raw_weights.sum()\n    if total > 0:\n        weights = raw_weights / total\n    else:\n        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)\n    combined_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    for w, scores in zip(weights, rule_scores):\n        combined_scores += w * scores\n    combined_scores[~feasible] = -np.inf\n    priority_v2.step += 1\n    return combined_scores\n\n### Analyze & experience\n- Comparing **(best)**\u202f(#1) vs **(worst)**\u202f(#20), we see the best heuristic maintains global state (`_selection_counts`, `_total_rewards`) to learn per\u2011bin rewards, combines deterministic inverse\u2011slack with an \u03b5\u2011greedy random term, and updates the reward after each placement. The worst heuristic merely computes inverse\u2011slack, applies a temperature\u2011scaled softmax, adds \u03b5\u2011noise, and never learns or adapts.  \n\n**(second best)**\u202f(#2) vs **(second worst)**\u202f(#19), both contain a docstring\u2011free reward learning core, but #2 lacks any exploration beyond \u03b5\u2011greedy randomness. #19 enriches the base score with a UCB exploration bonus, a median\u2011based diversity term, and weighted blending, thereby balancing exploitation with more sophisticated exploration.  \n\nComparing **(1st)**\u202f(#1) vs **(2nd)**\u202f(#2), the code is virtually identical: both initialize global counters, compute the same deterministic\u202f+\u202f\u03b5\u2011random base, add a small reward\u2011weight term (`reward_weight = 0.1`), and update the same global statistics after the chosen bin. No functional difference is evident.  \n\n**(3rd)**\u202f(#3) vs **(4th)**\u202f(#4), #3 retains the reward learning machinery, raises `reward_weight` to\u202f0.3, tracks `_total_calls`, and still returns raw scores. #4 abandons all learning, instead normalizing scores with a softmax (probability) transform and returning probabilities, making it a pure static scoring rule.  \n\nComparing **(second worst)**\u202f(#19) vs **(worst)**\u202f(#20), #19 blends deterministic inverse\u2011slack, \u03b5\u2011randomness, UCB, and diversity, and updates per\u2011bin reward statistics. #20 reduces everything to an inverse\u2011slack softmax with \u03b5\u2011noise, with no history, no UCB, and no diversity term.  \n\n**Overall:** The top heuristics consistently (i) use inverse\u2011slack as a deterministic fit measure, (ii) augment it with learned per\u2011bin reward signals, (iii) control exploration via \u03b5\u2011greedy, UCB, or diversity weighting, and (iv) keep state lightweight. Lower\u2011ranked versions strip away learning and exploration, relying on static transforms (softmax, random tie\u2011breakers) that cannot adapt to instance dynamics.\n- \n- **Keywords:** adaptive scoring, multi\u2011feature state, Thompson sampling, constraint\u2011aware learning.  \n- **Advice:** Build a lightweight feature vector (slack, item size, bin fill ratio, historical success) and train an online linear model or bandit; use Thompson sampling for exploration; update only with sufficient data; keep the model stateless between episodes.  \n- **Avoid:** Pure inverse\u2011slack baselines, fixed \u03b5\u2011greedy, heavy per\u2011bin state, ad\u2011hoc softmax, duplicated logic, and unchecked randomness.  \n- **Explanation:** A principled, data\u2011driven score balances feasibility and utilization, explores efficiently, and stays computationally cheap without over\u2011parameterizing or fragile heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}