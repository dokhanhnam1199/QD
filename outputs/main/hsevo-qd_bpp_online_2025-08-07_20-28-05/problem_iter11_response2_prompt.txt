{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\n    global _selection_counts, _total_rewards, _total_calls\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n    scores = np.full(n, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward_feas = np.zeros_like(base_score)\n    mask_counts_feas = _selection_counts[feasible] > 0\n    avg_reward_feas[mask_counts_feas] = _total_rewards[feasible][mask_counts_feas] / _selection_counts[feasible][mask_counts_feas]\n    reward_weight = 0.3\n    combined_feas = base_score + reward_weight * avg_reward_feas\n    scores[feasible] = combined_feas\n    best = np.argmax(scores)\n    _total_calls += 1\n    leftover = bins_remain_cap[best] - item\n    reward = -leftover\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    return scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Combines multiple slack components with epsilon\u2011greedy exploration and softmax scaling.\n                epsilon: float = 0.1, w_inv: float = 0.5,\n                w_lin: float = 0.3, w_sq: float = 0.2,\n                temperature: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy softmax priority blending inverse slack, linear slack penalty,\n    and squared slack penalty for balanced tight fits and exploration.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        base = w_inv * (1.0 / (slack + 1.0)) - w_lin * slack - w_sq * slack**2\n        scores[feasible] = base\n    if epsilon > 0:\n        scores += epsilon * np.random.rand(bins_remain_cap.size)\n    finite_mask = np.isfinite(scores)\n    if not np.any(finite_mask):\n        return scores\n    exp_scores = np.exp((scores[finite_mask] / temperature) -\n                        np.max(scores[finite_mask] / temperature))\n    probs = np.zeros_like(scores)\n    probs[finite_mask] = exp_scores / exp_scores.sum()\n    return probs\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see the best heuristic (#1) uses a lightweight deterministic inverse\u2011slack score with a simple epsilon\u2011greedy reward adjustment and clear state updates, whereas the worst (#20) blends UCB, temperature decay, noise, and multiple slack metrics, adding unnecessary complexity and risk of overfitting;  \n(Second best) vs (second worst), we see #2 (identical to #1) again shows the simplicity advantage, while #19 (UCB\u2011based) mirrors the worst in complexity, reinforcing that added components do not necessarily improve outcomes;  \nComparing (1st) vs (2nd), we see they are functionally identical, exposing duplicate implementation and a maintainability issue;  \n(3rd) vs (4th), the two are identical as well, again highlighting redundant code;  \nComparing (second worst) vs (worst), we see no difference\u2014they implement the same UCB/temperature logic\u2014illustrating lack of diversity in the lower\u2011ranked heuristics;  \nOverall: The top heuristics are simple, score\u2011direct, and learn from empirical reward; the bottom heuristics over\u2011engineer with multi\u2011metric blending and hidden selection logic, leading to reduced clarity and potential performance loss.\n- \n- **Keywords:** simplicity, modularity, deterministic, explainability, balanced scoring.  \n- **Advice:** Build a single, stateless scoring function that linearly combines normalized slack and empirical reward, separate feature extraction, and enforce explicit infeasibility handling.  \n- **Avoid:** Random \u03b5\u2011greedy tweaks, softmax probability layers, hidden state, duplicated code, and excess hyper\u2011parameters.  \n- **Explanation:** A deterministic, modular pipeline yields transparent heuristics that are easy to maintain, debug, and compose while still capturing key trade\u2011offs.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}