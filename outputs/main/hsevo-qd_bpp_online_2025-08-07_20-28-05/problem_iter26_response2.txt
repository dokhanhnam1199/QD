```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Inverse‑slack scoring with epsilon exploration and per‑bin learning."""
    global _selection_counts, _total_rewards, _total_calls
    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.size
    if n == 0:
        return np.array([], dtype=float)
    if '_selection_counts' not in globals() or _selection_counts.shape[0] != n:
        _selection_counts = np.zeros(n, dtype=int)
        _total_rewards = np.zeros(n, dtype=float)
        _total_calls = 0
    feasible = caps >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        return scores
    slack = caps - item
    det = 1.0 / (slack + 1.0)
    avg_reward = np.zeros(n, dtype=float)
    mask = _selection_counts > 0
    avg_reward[mask] = _total_rewards[mask] / _selection_counts[mask]
    reward_weight = 0.1
    if _total_calls > 0:
        ucb = np.zeros(n, dtype=float)
        ucb[mask] = np.sqrt(2 * np.log(_total_calls) / _selection_counts[mask])
        ucb_weight = 0.3
    else:
        ucb = np.zeros(n, dtype=float)
        ucb_weight = 0.0
    median_slack = np.median(slack[feasible]) if np.any(feasible) else 0.0
    diversity = np.zeros(n, dtype=float)
    diversity[feasible] = median_slack - slack[feasible]
    diversity_weight = 0.1
    combined = det + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity
    epsilon = 0.15
    rand = np.random.rand(n)
    scores[feasible] = (1 - epsilon) * combined[feasible] + epsilon * rand[feasible]
    best = int(np.argmax(scores))
    if feasible[best]:
        reward = -(caps[best] - item)
        _selection_counts[best] += 1
        _total_rewards[best] += reward
    _total_calls += 1
    return scores
```
