```python
def priority_v2(item, bins_remain_cap):
    """
    Combines inverse slack, UCB, reward learning, and diversity for adaptive bin selection.
    """
    import numpy as np
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n = bins_remain_cap.size
    if n == 0:
        return np.array([], dtype=float)
    if not hasattr(priority_v2, "_selection_counts") or priority_v2._bins_len != n:
        priority_v2._selection_counts = np.zeros(n, dtype=int)
        priority_v2._total_rewards = np.zeros(n, dtype=float)
        priority_v2._bins_len = n
    epsilon = 0.05
    offset = 1e-6
    score_scale = 1.0
    reward_weight = 0.1
    ucb_weight = 1.0
    diversity_weight = 0.1
    slack = bins_remain_cap - item
    feasible = slack >= 0
    det = np.zeros(n, dtype=float)
    det[feasible] = 1.0 / (slack[feasible] + offset)
    avg_reward = np.zeros(n, dtype=float)
    nonzero = priority_v2._selection_counts > 0
    avg_reward[nonzero] = priority_v2._total_rewards[nonzero] / priority_v2._selection_counts[nonzero]
    total_counts = np.sum(priority_v2._selection_counts)
    if total_counts == 0:
        base = 1.0
    else:
        base = np.sqrt(2 * np.log(total_counts + 1))
    ucb = np.zeros(n, dtype=float)
    ucb[nonzero] = np.sqrt(2 * np.log(total_counts + 1) / priority_v2._selection_counts[nonzero])
    ucb[~nonzero] = base
    if feasible.any():
        median_slack = np.median(slack[feasible])
    else:
        median_slack = 0.0
    diversity = np.zeros(n, dtype=float)
    diversity[feasible] = median_slack - slack[feasible]
    combined = score_scale * det + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity
    combined[~feasible] = -np.inf
    random_term = np.random.rand(n)
    scores = (1 - epsilon) * combined + epsilon * random_term
    return scores
```
