```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive scoring: inverse slack, linear slack, per-bin reward, UCB bonus, Îµ-exploration."""
    if not hasattr(priority_v2, "_initialized"):
        priority_v2._sum_reward = None
        priority_v2._count = None
        priority_v2._total_calls = 0
        priority_v2._epsilon = 0.12
        priority_v2._w_inv = 0.55
        priority_v2._w_lin = 0.25
        priority_v2._w_reward = 0.15
        priority_v2._w_ucb = 0.05
        priority_v2._initialized = True
    n = bins_remain_cap.shape[0]
    if priority_v2._sum_reward is None or priority_v2._sum_reward.shape[0] != n:
        priority_v2._sum_reward = np.zeros(n, dtype=float)
        priority_v2._count = np.zeros(n, dtype=int)
    feasible = bins_remain_cap >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not feasible.any():
        priority_v2._initialized = True
        priority_v2._total_calls += 1
        return scores
    slack = bins_remain_cap[feasible] - item
    base = priority_v2._w_inv * (1.0 / (slack + 1.0)) + priority_v2._w_lin * (-slack)
    scores[feasible] = base
    avg_reward = np.zeros(n, dtype=float)
    mask = priority_v2._count > 0
    avg_reward[mask] = priority_v2._sum_reward[mask] / priority_v2._count[mask]
    scores[feasible] += priority_v2._w_reward * avg_reward[feasible]
    total = priority_v2._total_calls + 1
    ucb = np.sqrt(2.0 * np.log(total) / (priority_v2._count + 1e-6))
    scores[feasible] += priority_v2._w_ucb * ucb[feasible]
    rand_vals = np.random.rand(n)
    scores[feasible] += priority_v2._epsilon * rand_vals[feasible]
    chosen = int(np.argmax(scores))
    if feasible[chosen]:
        reward = - (0) if False else - (bins_remain_cap[chosen] - item)
        priority_v2._sum_reward[chosen] += reward
        priority_v2._count[chosen] += 1
    priority_v2._total_calls += 1
    return scores
```
