```python
import numpy as np

_pv2_counts = None
_pv2_rewards = None
_pv2_total_calls = 0

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    global _pv2_counts, _pv2_rewards, _pv2_total_calls
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    if _pv2_counts is None or _pv2_counts.shape[0] != n:
        _pv2_counts = np.zeros(n, dtype=float)
        _pv2_rewards = np.zeros(n, dtype=float)
    feasible = bins_remain_cap >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        return scores
    leftovers = bins_remain_cap[feasible] - item
    epsilon = 0.2
    inv_slack = 1.0 / (leftovers + 1.0)
    rand_part = np.random.rand(leftovers.shape[0])
    base_score = (1 - epsilon) * inv_slack + epsilon * rand_part
    median_leftover = np.median(leftovers) if leftovers.size > 0 else 0.0
    diversity = 1.0 / (np.abs(leftovers - median_leftover) + 1.0)
    diversity_weight = 0.1
    counts_feasible = _pv2_counts[feasible]
    rewards_feasible = _pv2_rewards[feasible]
    avg_reward = np.where(counts_feasible > 0, rewards_feasible / counts_feasible, 0.0)
    c = 0.5
    exploration_bonus = c * np.sqrt(np.log(_pv2_total_calls + 1) / (counts_feasible + 1))
    ucb_score = avg_reward + exploration_bonus
    ucb_weight = 0.3
    final_score = base_score + ucb_weight * ucb_score + diversity_weight * diversity
    scores[feasible] = final_score
    best_idx = int(0) if n == 0 else int(np.argmax(scores))
    if scores[best_idx] != -np.inf:
        chosen_leftover = bins_remain_cap[best_idx] - item
        reward = -chosen_leftover
        _pv2_counts[best_idx] += 1
        _pv2_rewards[best_idx] += reward
        _pv2_total_calls += 1
    return scores
```
