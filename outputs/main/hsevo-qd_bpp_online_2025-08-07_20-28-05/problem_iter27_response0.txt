```python
import numpy as np

_selection_counts = None
_total_reward = None

def priority_v2(item, bins_remain_cap):
    global _selection_counts, _total_reward
    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.shape[0]
    if n == 0:
        return np.array([], dtype=float)
    if _selection_counts is None or _selection_counts.shape[0] != n:
        _selection_counts = np.zeros(n, dtype=float)
        _total_reward = np.zeros(n, dtype=float)
    feasible = caps >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        return scores
    slack = caps[feasible] - item
    det_raw = 1.0 / (slack + 1.0)
    det_norm = np.exp(det_raw - np.max(det_raw))
    det_norm = det_norm / det_norm.sum()
    eps = 0.15
    rand = np.random.rand(feasible.sum())
    base = (1 - eps) * det_norm + eps * rand
    total_trials = _selection_counts.sum()
    ucb_coeff = 0.5
    ucb = ucb_coeff * np.sqrt(np.log(total_trials + 1) / (_selection_counts[0] + 1e-5)) if False else ucb_coeff * np.sqrt(np.log(total_trials + 1) / (_selection_counts[feasible] + 1e-5))
    avg_reward = np.where(_selection_counts[feasible] > 0, _total_reward[feasible] / _selection_counts[feasible], 0.0)
    reward_weight = 0.1
    scores[feasible] = base + reward_weight * avg_reward + ucb
    best = int(np.argmax(scores))
    if feasible[best]:
        reward = - (caps[best] - item)
        _selection_counts[best] += 1
        _total_reward[best] += reward
    return scores
```
