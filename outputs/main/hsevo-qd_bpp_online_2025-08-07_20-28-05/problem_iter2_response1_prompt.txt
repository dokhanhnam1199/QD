{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    epsilon = 0.2\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    scores[feasible] = 1.0 / (leftovers + 1.0)\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    return scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Priority for Worst-Fit: higher value for bins leaving most empty after packing.\"\"\"\n    return np.where(bins_remain_cap >= item, (bins_remain_cap - item) ** 2, -np.inf)\n\n### Analyze & experience\n- - **Comparing (best) vs (worst):** The best heuristic (1st) uses an \u03b5\u2011greedy scheme with\u202f\u03b5\u202f=\u202f0.2 and a deterministic score `1/(leftover+1)`, favoring bins that leave little slack while still allowing randomness for tie\u2011breaking. The worst heuristic (20th) adopts a worst\u2011fit rule ` (leftover)\u00b2 `, explicitly rewarding large slack and thus driving waste.  \n- **(Second best) vs (second worst):** Heuristic\u202f2nd is a duplicate of the best, retaining the same inverse\u2011leftover scoring. Heuristic\u202f19th mirrors the worst\u2011fit rule of the 20th, again encouraging maximal leftover. The contrast is identical to the best\u2013worst pair, reinforcing that inverse\u2011slack scoring beats squared\u2011slack scoring.  \n- **Comparing (1st) vs (2nd):** Although the source code is identical, the ranking implies subtle implementation differences (e.g., randomness seed, integration context) that affect empirical performance; the core design\u2014\u03b5\u2011greedy with inverse slack\u2014remains the decisive factor.  \n- **(3rd) vs (4th):** Both are exact copies of the best heuristic, so any performance gap must stem from external factors (data ordering, random state) rather than code. This highlights the sensitivity of stochastic heuristics to randomness.  \n- **Comparing (second worst) vs (worst):** Heuristics\u202f19th and\u202f20th are byte\u2011for\u2011byte duplicates of the worst\u2011fit rule, confirming that identical worst\u2011fit logic consistently yields the lowest ranking.  \n- **Overall:** The ranking aligns with how closely each heuristic\u2019s deterministic component mirrors the bin\u2011packing objective (minimizing leftover). Inverse\u2011slack or negative\u2011slack scores combined with moderate \u03b5\u2011greedy randomness outperform raw worst\u2011fit or overly aggressive exploration.\n- \n- **Keywords:** slack minimization, \u03b5\u2011greedy, softmax scaling, infeasibility penalty, diversity.  \n- **Advice:** Score each bin by a normalized negative slack, add a small \u03b5 random perturbation, and apply a softmax to convert scores to selection probabilities.  \n- **Avoid:** Fixed deterministic ordering, overly large \u03b5 that drowns the signal, reward functions that reward waste or ignore infeasibility.  \n- **Explanation:** This mix preserves exploitation of tight fits while retaining exploration, stabilizes learning via bounded probabilities, and quickly rejects impossible placements.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}