import numpy as np
import random
import math
import scipy
import torch

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                temperature: float = 10.767930074918004,
                total_threshold: float = 0.653666204414959) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        temperature: Temperature controlling the softness of the exponential weighting.
        total_threshold: Minimum sum of exponential values required to assign nonâ€‘zero priorities.

    Returns:
        Array of same size as ``bins_remain_cap`` with priority score of each bin.
    """
    feasible = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(feasible):
        return priorities

    # Example core logic (the original numeric literals have been replaced by parameters)
    # Compute the exponential weighting for feasible bins
    exp_vals = np.exp((bins_remain_cap[feasible] - item) / temperature)

    # If the total weighted sum does not meet the threshold, keep priorities zero
    if exp_vals.sum() < total_threshold:
        return priorities

    # Normalize the exponential values to obtain priorities
    normalized = np.zeros_like(bins_remain_cap, dtype=float)
    normalized[feasible] = exp_vals / exp_vals.sum()
    priorities = normalized

    return priorities
