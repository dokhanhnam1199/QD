{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.3272578070972282,\n                offset: float = 3.6930496425184325,\n                score_scale: float = 1.8547777441606528) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins given an item size.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to place.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of bins.\n    epsilon : float, optional\n        Weight for the random exploration term (default 0.2).\n    offset : float, optional\n        Small constant added to leftover capacity to avoid division by zero\n        (default 1.0).\n    score_scale : float, optional\n        Scaling factor for the deterministic part of the score\n        (default 1.0).\n\n    Returns\n    -------\n    np.ndarray\n        Score for each bin; -inf for infeasible bins.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    scores[feasible] = score_scale / (leftovers + offset)\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    return scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combine inverse slack and negative squared slack with epsilon\u2011greedy randomness for balanced tight\u2011fit and exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftover = bins_remain_cap[feasible] - item\n    epsilon = 0.2\n    beta = 0.01\n    deterministic = 1.0 / (leftover + 1e-9) - beta * (leftover ** 2)\n    random_part = np.random.rand(feasible.sum())\n    scores = (1 - epsilon) * deterministic + epsilon * random_part\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[feasible] = scores\n    return priorities\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see the best heuristic (#1) uses a lightweight deterministic inverse\u2011slack score with a simple epsilon\u2011greedy reward adjustment and clear state updates, whereas the worst (#20) blends UCB, temperature decay, noise, and multiple slack metrics, adding unnecessary complexity and risk of overfitting;  \n(Second best) vs (second worst), we see #2 (identical to #1) again shows the simplicity advantage, while #19 (UCB\u2011based) mirrors the worst in complexity, reinforcing that added components do not necessarily improve outcomes;  \nComparing (1st) vs (2nd), we see they are functionally identical, exposing duplicate implementation and a maintainability issue;  \n(3rd) vs (4th), the two are identical as well, again highlighting redundant code;  \nComparing (second worst) vs (worst), we see no difference\u2014they implement the same UCB/temperature logic\u2014illustrating lack of diversity in the lower\u2011ranked heuristics;  \nOverall: The top heuristics are simple, score\u2011direct, and learn from empirical reward; the bottom heuristics over\u2011engineer with multi\u2011metric blending and hidden selection logic, leading to reduced clarity and potential performance loss.\n- \n- **Keywords:** simplicity, modularity, deterministic, explainability, balanced scoring.  \n- **Advice:** Build a single, stateless scoring function that linearly combines normalized slack and empirical reward, separate feature extraction, and enforce explicit infeasibility handling.  \n- **Avoid:** Random \u03b5\u2011greedy tweaks, softmax probability layers, hidden state, duplicated code, and excess hyper\u2011parameters.  \n- **Explanation:** A deterministic, modular pipeline yields transparent heuristics that are easy to maintain, debug, and compose while still capturing key trade\u2011offs.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}