```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, stats: dict = None, epsilon: float = 0.2, ucb_weight: float = 0.3) -> np.ndarray:
    """Combines inverse‑slack, ε‑greedy, and optional UCB bonus from prior usage."""
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n = bins_remain_cap.size
    if n == 0:
        return np.empty(0, dtype=float)
    feasible = bins_remain_cap >= item
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    if not np.any(feasible):
        return scores
    leftovers = bins_remain_cap[feasible] - item
    max_cap = bins_remain_cap.max()
    deterministic = 1.0 / (leftovers + 1.0)
    reward = 1.0 - leftovers / max_cap
    reward = np.clip(reward, 0.0, 1.0)
    weighted = deterministic * (1.0 + reward)
    random_part = np.random.rand(feasible.sum())
    base_score = (1.0 - epsilon) * weighted + epsilon * random_part
    if stats is not None:
        counts = stats.get('counts')
        rewards = stats.get('rewards')
        if counts is not None and rewards is not None and counts.shape == bins_remain_cap.shape:
            counts_feasible = counts[feasible]
            rewards_feasible = rewards[feasible]
            avg_reward = np.where(counts_feasible > 0, rewards_feasible / counts_feasible, 0.0)
            total_calls = counts.sum()
            exploration_bonus = np.sqrt(np.log(total_calls + 1) / (counts_feasible + 1))
            ucb_score = avg_reward + exploration_bonus
            base_score += ucb_weight * ucb_score
    scores[feasible] = base_score
    return scores
```
