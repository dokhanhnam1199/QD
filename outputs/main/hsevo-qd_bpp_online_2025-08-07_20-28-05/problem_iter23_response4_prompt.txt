{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                epsilon: float = 0.2, beta: float = 0.02) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy tight\u2011fit with squared\u2011slack penalty for waste reduction.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    det = 1.0/(leftovers + 1.0) - beta * leftovers**2\n    rand_part = np.random.rand(bins_remain_cap.size)\n    scores[feasible] = (1 - epsilon) * det + epsilon * rand_part[feasible]\n    return scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    if not hasattr(priority_v2, \"initialized\"):\n        priority_v2.num_rules = 4\n        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)\n        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)\n        priority_v2.step = 0\n        priority_v2.epsilon = 1e-9\n        priority_v2.initialized = True\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap - item\n    best_fit_score = np.where(feasible, -leftovers, -np.inf)\n    worst_fit_score = np.where(feasible, leftovers, -np.inf)\n    indices = np.arange(bins_remain_cap.shape[0] if hasattr(bins_remain_cap, \"shape\") else len(bins_remain_cap))\n    first_fit_score = np.where(feasible, -indices, -np.inf)\n    target = bins_remain_cap.mean()\n    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)\n    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]\n    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)\n    for i, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            waste_per_rule[i] = np.inf\n        else:\n            idx = np.argmax(scores)\n            waste_per_rule[i] = bins_remain_cap[idx] - item\n    for i in range(priority_v2.num_rules):\n        w = waste_per_rule[i]\n        if np.isfinite(w):\n            priority_v2.sum_waste[i] += w\n            priority_v2.count[i] += 1\n    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)\n    inv = 1.0 / (avg_waste + priority_v2.epsilon)\n    boost = np.zeros(priority_v2.num_rules, dtype=float)\n    boost_idx = priority_v2.step % priority_v2.num_rules\n    boost[boost_idx] = 1.0 / (priority_v2.step + 1)\n    raw_weights = inv + boost\n    total = raw_weights.sum()\n    if total > 0:\n        weights = raw_weights / total\n    else:\n        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)\n    combined_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    for w, scores in zip(weights, rule_scores):\n        combined_scores += w * scores\n    combined_scores[~feasible] = -np.inf\n    priority_v2.step += 1\n    return combined_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that Heuristics\u202f1\ufe0f\u20e3 (global\u202f_selection_counts/_total_rewards, \u03b5\u2011greedy inverse\u2011slack, reward weighting) adapts via per\u2011bin learning, while Heuristics\u202f20\ufe0f\u20e3 only applies inverse slack with softmax and \u03b5\u2011noise, lacking any feedback loop.  \n(second best) vs (second worst), Heuristics\u202f2\ufe0f\u20e3 (simple avg\u2011reward update, deterministic\u2011plus\u2011random score) beats Heuristics\u202f19\ufe0f\u20e3 (class with UCB, diversity term, temperature decay, many hyper\u2011parameters) \u2013 the leaner reward estimator is more stable than a heavily tuned UCB scheme.  \nComparing (1st) vs (2nd), the code is virtually identical (same global state, same scoring); the ranking difference likely stems from marginal documentation or initialization nuances rather than algorithmic change.  \n(3rd) vs (4th), Heuristics\u202f3\ufe0f\u20e3 returns softmax probabilities from inverse\u2011slack\u202f+\u202f\u03b5\u2011noise, whereas Heuristics\u202f4\ufe0f\u20e3 adds per\u2011bin avg\u2011reward and a UCB bonus. The extra UCB term can cause over\u2011exploration and noisy updates, making the simpler softmax version superior.  \n(second worst) vs (worst), Heuristics\u202f19\ufe0f\u20e3 (UCB, diversity, temperature decay, learning updates) outperforms Heuristics\u202f20\ufe0f\u20e3 (static inverse\u2011slack softmax) by retaining a modest adaptive component.  \nOverall: lightweight adaptive heuristics that blend deterministic fit with modest \u03b5\u2011exploration and a single reward statistic consistently beat overly complex designs with multiple bonuses, aggressive UCB terms, or excessive randomness.\n- \n- **Keywords**: inverse\u2011slack, \u03b5\u2011greedy, stateless; **Advice**: use inverse\u2011slack as core score with \u03b5\u2011randomness; **Avoid**: UCB or heavy tuning before data; **Explanation**: ensures fast, predictable decisions.  \n- **Keywords**: reward\u2011averaging, batch; **Advice**: accumulate rewards over a window then update average; **Avoid**: per\u2011step volatile updates; **Explanation**: lowers variance with minimal overhead.  \n- **Keywords**: softmax, probability; **Advice**: apply softmax only when downstream needs probabilities; **Avoid**: unconditional scaling that hides raw scores; **Explanation**: retains interpretability and proper distribution.  \n- **Keywords**: documentation, modular code; **Advice**: expose all hyper\u2011parameters and keep functions pure; **Avoid**: hidden state, duplicated logic, unused imports; **Explanation**: boosts maintainability and safe extension.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}