```python
import numpy as np

_initialized = False
_model_mu = None
_model_cov = None
_model_precision = None
_bin_capacity = 1.0
_noise_var = 0.5
_prior_var = 10.0

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    global _initialized, _model_mu, _model_cov, _model_precision, _bin_capacity, _noise_var, _prior_var
    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.shape[0]
    if n == 0:
        return np.array([], dtype=float)
    if not _initialized:
        _bin_capacity = np.max(caps) if caps.size > 0 else 1.0
        d = 3
        _model_mu = np.zeros(d)
        _model_cov = np.eye(d) * _prior_var
        _model_precision = np.linalg.inv(_model_cov)
        _initialized = True
    else:
        max_cap = np.max(caps)
        if max_cap > _bin_capacity:
            _bin_capacity = max_cap
    feasible = caps >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        return scores
    slack = caps[feasible] - item
    fill = 1.0 - slack / _bin_capacity
    X = np.column_stack((np.ones_like(slack), slack, fill))
    w = np.random.multivariate_normal(_model_mu, _model_cov)
    scores[feasible] = X @ w
    best = int(np.argmax(scores))
    if feasible[best]:
        slack_selected = caps[best] - item
        reward = -slack_selected
        x = np.array([1.0, slack_selected, 1.0 - slack_selected / _bin_capacity])
        precision_update = _model_precision + np.outer(x, x) / _noise_var
        cov_new = np.linalg.inv(precision_update)
        mu_new = cov_new @ (_model_precision @ _model_mu + x * reward / _noise_var)
        _model_cov = cov_new
        _model_precision = precision_update
        _model_mu = mu_new
    return scores
```
