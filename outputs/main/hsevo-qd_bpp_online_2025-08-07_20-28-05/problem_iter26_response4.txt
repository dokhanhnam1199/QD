```python
import numpy as np

_initialized = False
_model_mu = None
_model_cov = None
_model_precision = None
_bin_capacity = 1.0
_noise_var = 0.5
_prior_var = 10.0
_selection_counts = None
_total_rewards = None
_total_calls = 0

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Hybrid scoring: Bayesian model + inverse slack + perâ€‘bin reward and UCB."""
    global _initialized, _model_mu, _model_cov, _model_precision, _bin_capacity
    global _selection_counts, _total_rewards, _total_calls

    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.shape[0]
    if n == 0:
        return np.array([], dtype=float)

    if not _initialized:
        _bin_capacity = np.max(caps) if caps.size > 0 else 1.0
        d = 3
        _model_mu = np.zeros(d)
        _model_cov = np.eye(d) * _prior_var
        _model_precision = np.linalg.inv(_model_cov)
        _selection_counts = np.zeros(n, dtype=float)
        _total_rewards = np.zeros(n, dtype=float)
        _initialized = True
    else:
        max_cap = np.max(caps)
        if max_cap > _bin_capacity:
            _bin_capacity = max_cap
        if _selection_counts.shape[0] != n:
            _selection_counts = np.zeros(n, dtype=float)
            _total_rewards = np.zeros(n, dtype=float)

    feasible = caps >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        _total_calls += 1
        return scores

    slack = caps[feasible] - item
    fill = 1.0 - slack / _bin_capacity
    X = np.column_stack((np.ones_like(slack), slack, fill))
    w = np.random.multivariate_normal(_model_mu, _model_cov)
    model_score = X @ w
    inv_slack = 1.0 / (slack + 1e-6)
    avg_reward = np.where(_selection_counts > 0,
                          _total_rewards / _selection_counts,
                          0.0)
    ucb = np.sqrt(np.log(_total_calls + 1) / (_selection_counts + 1))
    combined_feas = (0.4 * model_score +
                    0.3 * inv_slack +
                    0.2 * avg_reward +
                    0.1 * ucb)
    scores[feasible] = combined_feas
    best = int(np.argmax(scores))
    if feasible[best]:
        slack_selected = caps[best] - item
        reward = -slack_selected
        _selection_counts[best] += 1
        _total_rewards[best] += reward
        x = np.array([1.0, slack_selected, 1.0 - slack_selected / _bin_capacity])
        precision_update = _model_precision + np.outer(x, x) / _noise_var
        cov_new = np.linalg.inv(precision_update)
        mu_new = cov_new @ (_model_precision @ _model_mu + x * reward / _noise_var)
        _model_cov = cov_new
        _model_precision = precision_update
        _model_mu = mu_new
    _total_calls += 1
    return scores
```
