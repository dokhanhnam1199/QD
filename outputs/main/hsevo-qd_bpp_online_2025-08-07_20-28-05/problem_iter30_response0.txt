```python
import numpy as np

def _feasibility_mask(caps: np.ndarray, item: float) -> np.ndarray:
    return caps >= item

def _leftover(caps: np.ndarray, item: float, mask: np.ndarray) -> np.ndarray:
    return caps[mask] - item

def _variance_after_placement(caps: np.ndarray, item: float, mask: np.ndarray) -> np.ndarray:
    n = caps.shape[0]
    total_sum = caps.sum()
    total_sq = (caps * caps).sum()
    mean_new = (total_sum - item) / n
    cap_masked = caps[mask]
    sum_sq_new = total_sq - cap_masked * cap_masked + (cap_masked - item) * (cap_masked - item)
    return sum_sq_new / n - mean_new * mean_new

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.shape[0]
    if n == 0:
        return np.empty(0, dtype=float)
    mask = _feasibility_mask(caps, item)
    scores = np.full(n, -np.inf, dtype=float)
    if not mask.any():
        return scores
    leftovers = _leftover(caps, item, mask)
    variances = _variance_after_placement(caps, item, mask)
    max_leftover = leftovers.max()
    combined = -(leftovers + variances * (max_leftover + 1.0))
    scores[mask] = combined
    return scores
```
