[
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    slack = bins_remain_cap - item\n    fits = slack >= 0\n    eps = np.finfo(slack.dtype).eps\n    return np.where(fits, -slack + eps, -np.inf)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.2\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    scores[feasible] = 1.0 / (leftovers + 1.0)\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    return scores",
    "response_id": 18,
    "tryHS": true,
    "obj": 3.370562425209409,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.2, beta: float = 0.02) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy tight\u2011fit with squared\u2011slack penalty for waste reduction.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    det = 1.0/(leftovers + 1.0) - beta * leftovers**2\n    rand_part = np.random.rand(bins_remain_cap.size)\n    scores[feasible] = (1 - epsilon) * det + epsilon * rand_part[feasible]\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.3272578070972282,\n                offset: float = 3.6930496425184325,\n                score_scale: float = 1.8547777441606528) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins given an item size.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to place.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of bins.\n    epsilon : float, optional\n        Weight for the random exploration term (default 0.2).\n    offset : float, optional\n        Small constant added to leftover capacity to avoid division by zero\n        (default 1.0).\n    score_scale : float, optional\n        Scaling factor for the deterministic part of the score\n        (default 1.0).\n\n    Returns\n    -------\n    np.ndarray\n        Score for each bin; -inf for infeasible bins.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    scores[feasible] = score_scale / (leftovers + offset)\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    return scores",
    "response_id": 2,
    "tryHS": true,
    "obj": 3.5500598324691004,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\nclass PriorityV2:\n    def __init__(self):\n        self.total_calls = 0\n        self.selection_counts = None\n        self.total_rewards = None\n        self.temperature = 1.0\n        self.decay = 0.995\n\n    def priority(self, item, bins_remain_cap):\n        n = bins_remain_cap.shape[0]\n        if self.selection_counts is None or self.selection_counts.shape[0] != n:\n            self.selection_counts = np.zeros(n, dtype=float)\n            self.total_rewards = np.zeros(n, dtype=float)\n        feasible = bins_remain_cap >= item\n        leftovers = np.where(feasible, bins_remain_cap - item, np.inf)\n        base_score = np.where(feasible, 1.0 / (leftovers + 1.0), 0.0)\n        median_leftover = np.median(leftovers[feasible]) if np.any(feasible) else 0.0\n        diversity = np.where(feasible, 1.0 / (np.abs(leftovers - median_leftover) + 1.0), 0.0)\n        avg_reward = np.where(self.selection_counts > 0, self.total_rewards / self.selection_counts, 0.0)\n        c = 1.0\n        ucb = avg_reward + c * np.sqrt(np.log(self.total_calls + 1) / (self.selection_counts + 1))\n        combined_feas = 0.5 * base_score + 0.3 * diversity + 0.2 * ucb\n        combined = np.full(n, -np.inf, dtype=float)\n        combined[feasible] = combined_feas[feasible]\n        noise = np.random.rand(n)\n        combined[feasible] = (1 - self.temperature) * combined[feasible] + self.temperature * noise[feasible]\n        self.total_calls += 1\n        self.temperature *= self.decay\n        if np.any(feasible):\n            chosen = np.argmax(combined)\n            reward = - (bins_remain_cap[chosen] - item)\n            self.selection_counts[chosen] += 1\n            self.total_rewards[chosen] += reward\n        return combined\n\n_priority_v2_instance = PriorityV2()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return _priority_v2_instance.priority(item, bins_remain_cap)",
    "response_id": 0,
    "tryHS": false,
    "obj": 59.57319505384924,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    temperature = 1.0\n    exp_vals = np.exp(-slack / temperature)\n    total = exp_vals.sum()\n    if total > 0:\n        priorities[feasible] = exp_vals / total\n    return priorities",
    "response_id": 19,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines inverse\u2011slack, \u03b5\u2011greedy exploration, and reward weighting for online bin packing.\"\"\"\n    epsilon = 0.2\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    max_cap = bins_remain_cap.max()\n    reward = 1.0 - leftovers / max_cap\n    reward = np.clip(reward, 0.0, 1.0)\n    weighted = deterministic * (1.0 + reward)\n    random_part = np.random.rand(feasible.sum())\n    combined = (1 - epsilon) * weighted + epsilon * random_part\n    scores[feasible] = combined\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    probabilities = exp_scores / exp_scores.sum()\n    return probabilities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.948942959712818,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.2\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    random_part = np.random.rand(feasible.sum())\n    combined = (1 - epsilon) * deterministic + epsilon * random_part\n    scores[feasible] = combined\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    probabilities = exp_scores / exp_scores.sum()\n    return probabilities",
    "response_id": 5,
    "tryHS": true,
    "obj": 3.4004786597527064,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine inverse slack and negative squared slack with epsilon\u2011greedy randomness for balanced tight\u2011fit and exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftover = bins_remain_cap[feasible] - item\n    epsilon = 0.2\n    beta = 0.01\n    deterministic = 1.0 / (leftover + 1e-9) - beta * (leftover ** 2)\n    random_part = np.random.rand(feasible.sum())\n    scores = (1 - epsilon) * deterministic + epsilon * random_part\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[feasible] = scores\n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.028719585161557,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\n# Combine tight\u2011fit incentive, slack penalty, random exploration, and softmax scaling.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse slack, squared\u2011slack penalty, \u03b5\u2011greedy noise, and softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    inv_slack = 1.0 / (slack + 1.0)\n    beta = 0.1\n    penalty = -beta * (slack ** 2)\n    deterministic = inv_slack + penalty\n    epsilon = 0.05\n    random_noise = epsilon * np.random.rand(deterministic.shape[0])\n    raw = deterministic + random_noise\n    temperature = 0.5\n    exp_vals = np.exp(raw / temperature)\n    total = exp_vals.sum()\n    if total > 0:\n        priorities[feasible] = exp_vals / total\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\n# Combines multiple slack components with epsilon\u2011greedy exploration and softmax scaling.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.1, w_inv: float = 0.5,\n                w_lin: float = 0.3, w_sq: float = 0.2,\n                temperature: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy softmax priority blending inverse slack, linear slack penalty,\n    and squared slack penalty for balanced tight fits and exploration.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        base = w_inv * (1.0 / (slack + 1.0)) - w_lin * slack - w_sq * slack**2\n        scores[feasible] = base\n    if epsilon > 0:\n        scores += epsilon * np.random.rand(bins_remain_cap.size)\n    finite_mask = np.isfinite(scores)\n    if not np.any(finite_mask):\n        return scores\n    exp_scores = np.exp((scores[finite_mask] / temperature) -\n                        np.max(scores[finite_mask] / temperature))\n    probs = np.zeros_like(scores)\n    probs[finite_mask] = exp_scores / exp_scores.sum()\n    return probs",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                temperature: float = 8.21777003404979,\n                total_threshold: float = 0.7518899527010219) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        temperature: Temperature controlling the softness of the exponential weighting.\n        total_threshold: Minimum sum of exponential values required to assign non\u2011zero priorities.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if not np.any(feasible):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.15\n    w_inv = 0.5\n    w_lin = 0.3\n    w_sq = 0.2\n    temperature = 1.0\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    slack = bins_remain_cap[feasible] - item\n    core = w_inv / (slack + 1.0) - w_lin * slack - w_sq * slack**2\n    rand = np.random.rand(feasible.sum())\n    scores_feasible = (1 - epsilon) * core + epsilon * rand\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[feasible] = scores_feasible\n    max_score = np.max(scores_feasible)\n    exp_scores = np.exp((scores_feasible - max_score) / temperature)\n    probs_feasible = exp_scores / exp_scores.sum()\n    probs = np.zeros_like(bins_remain_cap, dtype=float)\n    probs[feasible] = probs_feasible\n    return probs",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse slack + epsilon random + avg reward for online bin packing.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.3\n    combined = base_score + reward_weight * avg_reward\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    _total_calls += 1\n    reward = - (bins_remain_cap[best] - item)\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.380534503390516,
    "SLOC": 30.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if not hasattr(priority_v2, \"initialized\"):\n        priority_v2.num_rules = 4\n        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)\n        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)\n        priority_v2.step = 0\n        priority_v2.epsilon = 1e-9\n        priority_v2.initialized = True\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap - item\n    best_fit_score = np.where(feasible, -leftovers, -np.inf)\n    worst_fit_score = np.where(feasible, leftovers, -np.inf)\n    indices = np.arange(bins_remain_cap.shape[0] if hasattr(bins_remain_cap, \"shape\") else len(bins_remain_cap))\n    first_fit_score = np.where(feasible, -indices, -np.inf)\n    target = bins_remain_cap.mean()\n    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)\n    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]\n    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)\n    for i, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            waste_per_rule[i] = np.inf\n        else:\n            idx = np.argmax(scores)\n            waste_per_rule[i] = bins_remain_cap[idx] - item\n    for i in range(priority_v2.num_rules):\n        w = waste_per_rule[i]\n        if np.isfinite(w):\n            priority_v2.sum_waste[i] += w\n            priority_v2.count[i] += 1\n    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)\n    inv = 1.0 / (avg_waste + priority_v2.epsilon)\n    boost = np.zeros(priority_v2.num_rules, dtype=float)\n    boost_idx = priority_v2.step % priority_v2.num_rules\n    boost[boost_idx] = 1.0 / (priority_v2.step + 1)\n    raw_weights = inv + boost\n    total = raw_weights.sum()\n    if total > 0:\n        weights = raw_weights / total\n    else:\n        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)\n    combined_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    for w, scores in zip(weights, rule_scores):\n        combined_scores += w * scores\n    combined_scores[~feasible] = -np.inf\n    priority_v2.step += 1\n    return combined_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.3777423214998095,
    "SLOC": 48.0,
    "cyclomatic_complexity": 10.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item, bins_remain_cap):\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                beta: float = 0.01, temperature: float = 1.0,\n                total_threshold: float = 1e-6) -> np.ndarray:\n    \"\"\"Score bins by inverse slack minus slack\u00b2, softened with temperature.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    eps = 1e-9\n    raw = 1.0 / (slack + eps) - beta * slack**2\n    exp_scores = np.exp(raw / temperature)\n    if exp_scores.sum() < total_threshold:\n        return priorities\n    priorities[feasible] = exp_scores\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef _extract_features(item: float, bins_remain_cap: np.ndarray, capacity: float):\n    slack = bins_remain_cap - item\n    slack_norm = slack / capacity\n    used_ratio = (capacity - bins_remain_cap) / capacity\n    return slack_norm, used_ratio\n\ndef _combine_features(slack_norm: np.ndarray, used_ratio: np.ndarray):\n    return used_ratio - slack_norm\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    capacity = np.max(bins_remain_cap) if bins_remain_cap.size else 0.0\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if capacity > 0 and np.any(feasible):\n        slack_norm, used_ratio = _extract_features(item, bins_remain_cap, capacity)\n        combined = _combine_features(slack_norm, used_ratio)\n        scores[feasible] = combined[feasible]\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\n# Priority combines inverse slack, best\u2011fit, first\u2011fit, fill\u2011balance and simple reward learning.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using slack, fit, index and reward heuristics for online bin packing.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n    leftovers_all = caps - item\n    leftovers = leftovers_all[feasible]\n    inv_slack = 1.0 / (leftovers + 1.0)\n    best_fit = -leftovers\n    first_fit = -np.arange(n)[feasible]\n    target = caps.mean()\n    fill_bal = -np.abs(leftovers - target)\n    avg_reward = np.zeros_like(leftovers)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    w_inv, w_best, w_first, w_bal, w_rew = 0.4, 0.3, 0.1, 0.1, 0.1\n    combined = (w_inv * inv_slack + w_best * best_fit + w_first * first_fit +\n                w_bal * fill_bal + w_rew * avg_reward)\n    scores = np.full(n, -np.inf, dtype=float)\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    reward = -(caps[best] - item)\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    _total_calls += 1\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 33.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response2.txt_stdout.txt",
    "code_path": "problem_iter29_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins for online BPP using inverse slack, \u03b5\u2011greedy, avg reward, and UCB.\"\"\"\n    # Initialize static state on first call\n    if not hasattr(priority_v2, \"_init\"):\n        priority_v2._counts = None          # selection counts per bin\n        priority_v2._rewards = None         # cumulative rewards per bin\n        priority_v2._calls = 0              # total calls\n        priority_v2._epsilon = 0.1          # exploration rate\n        priority_v2._reward_weight = 0.3    # weight for avg reward term\n        priority_v2._ucb_weight = 0.05      # weight for UCB term\n        priority_v2._init = True\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n\n    # Resize state if number of bins changes\n    if priority_v2._counts is None or priority_v2._counts.shape[0] != n:\n        priority_v2._counts = np.zeros(n, dtype=float)\n        priority_v2._rewards = np.zeros(n, dtype=float)\n\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        priority_v2._calls += 1\n        return scores\n\n    # --- deterministic part: inverse slack (more remaining space \u2192 lower score) ---\n    leftover = caps[feasible] - item\n    inv_slack = 1.0 / (leftover + 1.0)\n\n    # --- exploration part: \u03b5\u2011greedy random noise ---\n    rand_part = np.random.rand(leftover.shape[0])\n    base_score = (1 - priority_v2._epsilon) * inv_slack + priority_v2._epsilon * rand_part\n\n    # --- average reward term (exploitation of learned bin quality) ---\n    idx_feas = np.where(feasible)[0]\n    counts_feas = priority_v2._counts[idx_feas]\n    rewards_feas = priority_v2._rewards[idx_feas]\n    avg_reward = np.zeros_like(base_score)\n    mask = counts_feas > 0\n    avg_reward[mask] = rewards_feas[mask] / counts_feas[mask]\n\n    # --- Upper Confidence Bound term (balance exploration/exploitation) ---\n    total_calls = priority_v2._calls + 1\n    ucb = np.sqrt(2.0 * np.log(total_calls) / (counts_feas + 1e-6))\n\n    # --- combine all components ---\n    scores_feas = base_score + priority_v2._reward_weight * avg_reward + priority_v2._ucb_weight * ucb\n    scores[idx_feas] = scores_feas\n\n    # Update online statistics for the selected bin\n    best = int(np.argmax(scores))\n    priority_v2._calls += 1\n    reward = - (caps[best] - item)          # negative leftover as reward\n    priority_v2._counts[best] += 1\n    priority_v2._rewards[best] += reward\n\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.8891104906262464,
    "SLOC": 41.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    global _selection_counts, _total_rewards\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.1\n    combined = base_score + reward_weight * avg_reward\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        reward = - (caps[best] - item)\n        _selection_counts[best] += 1\n        _total_rewards[best] += reward\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 3.3506182688472412,
    "SLOC": 30.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\n_pv2_counts = None\n_pv2_rewards = None\n_pv2_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    global _pv2_counts, _pv2_rewards, _pv2_total_calls\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    if _pv2_counts is None or _pv2_counts.shape[0] != n:\n        _pv2_counts = np.zeros(n, dtype=float)\n        _pv2_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    epsilon = 0.2\n    inv_slack = 1.0 / (leftovers + 1.0)\n    rand_part = np.random.rand(leftovers.shape[0])\n    base_score = (1 - epsilon) * inv_slack + epsilon * rand_part\n    median_leftover = np.median(leftovers) if leftovers.size > 0 else 0.0\n    diversity = 1.0 / (np.abs(leftovers - median_leftover) + 1.0)\n    diversity_weight = 0.1\n    counts_feasible = _pv2_counts[feasible]\n    rewards_feasible = _pv2_rewards[feasible]\n    avg_reward = np.where(counts_feasible > 0, rewards_feasible / counts_feasible, 0.0)\n    c = 0.5\n    exploration_bonus = c * np.sqrt(np.log(_pv2_total_calls + 1) / (counts_feasible + 1))\n    ucb_score = avg_reward + exploration_bonus\n    ucb_weight = 0.3\n    final_score = base_score + ucb_weight * ucb_score + diversity_weight * diversity\n    scores[feasible] = final_score\n    best_idx = int(0) if n == 0 else int(np.argmax(scores))\n    if scores[best_idx] != -np.inf:\n        chosen_leftover = bins_remain_cap[best_idx] - item\n        reward = -chosen_leftover\n        _pv2_counts[best_idx] += 1\n        _pv2_rewards[best_idx] += reward\n        _pv2_total_calls += 1\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 61.926605504587165,
    "SLOC": 38.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine inverse slack, quadratic penalty, reward weighting and \u03b5\u2011greedy, return softmax probabilities.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    epsilon = 0.15\n    beta = 0.01\n    inv_slack = 1.0 / (leftovers + 1e-9)\n    penalty = beta * (leftovers ** 2)\n    deterministic = inv_slack - penalty\n    max_cap = bins_remain_cap.max()\n    reward = 1.0 - leftovers / max_cap\n    reward = np.clip(reward, 0.0, 1.0)\n    deterministic = deterministic * (1.0 + reward)\n    random_part = np.random.rand(feasible.sum())\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[feasible] = (1 - epsilon) * deterministic + epsilon * random_part\n    max_score = np.max() if False else np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    probabilities = exp_scores / exp_scores.sum()\n    return probabilities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\n# Global state for learning per bin\n_selection_counts = None\n_total_rewards = None\n_total_calls = None\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive scorer: inverse slack, UCB, diversity, reward learning, \u03b5\u2011greedy.\n    \"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0.0\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.1\n    total_calls = _total_calls + 1e-6\n    ucb = np.sqrt(2 * np.log(total_calls) / (_selection_counts[feasible] + 1e-6))\n    ucb_weight = 0.05\n    median_leftover = np.median(leftovers)\n    diversity = 1.0 / (np.abs(leftovers - median_leftover) + 1.0)\n    diversity_weight = 0.05\n    combined = base_score + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        reward = -(caps[best] - item)\n        _selection_counts[best] += 1\n        _total_rewards[best] += reward\n        _total_calls += 1\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 21.788990825688074,
    "SLOC": 38.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011slack + \u03b5\u2011greedy + lightweight UCB, learns per\u2011bin reward.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.15\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.1\n    reward_component = reward_weight * avg_reward\n    c = 0.2\n    total = _total_calls + 1\n    sel_counts = _selection_counts[feasible] + 1e-9\n    ucb_bonus = c * np.sqrt(np.log(total) / sel_counts)\n    combined = base_score + reward_component + ucb_bonus\n    scores = np.full(n, -np.inf, dtype=float)\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    _total_calls += 1\n    reward = - (caps[best] - item)\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    return scores",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.6796968488233035,
    "SLOC": 36.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive hybrid scoring: combine inverse slack, learned waste, UCB exploration, and diversity with epsilon noise.\"\"\"\n    if not hasattr(priority_v2, \"initialized\"):\n        priority_v2.num_rules = 4\n        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)\n        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)\n        priority_v2.step = 0\n        priority_v2.epsilon = 1e-9\n        priority_v2.initialized = True\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap - item\n    indices = np.arange(bins_remain_cap.shape[0])\n    target = bins_remain_cap.mean()\n    best_fit_score = np.where(feasible, -leftovers, -np.inf)\n    worst_fit_score = np.where(feasible, leftovers, -np.inf)\n    first_fit_score = np.where(feasible, -indices, -np.inf)\n    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)\n    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]\n    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)\n    for i, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            waste_per_rule[i] = np.inf\n        else:\n            idx = np.argmax(scores)\n            waste_per_rule[i] = bins_remain_cap[idx] - item\n    for i in range(priority_v2.num_rules):\n        w = waste_per_rule[i]\n        if np.isfinite(w):\n            priority_v2.sum_waste[i] += w\n            priority_v2.count[i] += 1\n    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)\n    inv = 1.0 / (avg_waste + priority_v2.epsilon)\n    boost = np.zeros(priority_v2.num_rules, dtype=float)\n    boost_idx = priority_v2.step % priority_v2.num_rules\n    boost[boost_idx] = 1.0 / (priority_v2.step + 1)\n    raw_weights = inv + boost\n    total = raw_weights.sum()\n    if total > 0:\n        weights = raw_weights / total\n    else:\n        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)\n    total_calls = priority_v2.step + 1\n    ucb_bonus = np.empty(priority_v2.num_rules, dtype=float)\n    for r in range(priority_v2.num_rules):\n        if priority_v2.count[r] > 0:\n            ucb_bonus[r] = np.sqrt(2 * np.log(total_calls) / priority_v2.count[r])\n        else:\n            ucb_bonus[r] = np.sqrt(2 * np.log(total_calls))\n    median_slack = np.median(leftovers[feasible])\n    diversity_bonus = np.empty(priority_v2.num_rules, dtype=float)\n    for r, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            diversity_bonus[r] = 0.0\n        else:\n            idx = np.argmax(scores)\n            diversity_bonus[r] = np.abs(leftovers[idx] - median_slack)\n    combined_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    for w, scores, ub, db in zip(weights, rule_scores, ucb_bonus, diversity_bonus):\n        temp = np.where(feasible, scores, -np.inf)\n        temp += ub\n        temp += db\n        combined_scores += w * temp\n    rand_noise = np.random.rand(bins_remain_cap.shape[0])\n    rand_noise[~feasible] = 0.0\n    combined_scores += 0.05 * rand_noise\n    priority_v2.step += 1\n    return combined_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 68.0,
    "cyclomatic_complexity": 13.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item, bins_remain_cap):\n    if not hasattr(priority_v2, \"_init\"):\n        priority_v2._selection_counts = None\n        priority_v2._total_rewards = None\n        priority_v2._total_calls = 0\n        priority_v2._epsilon = 0.15\n        priority_v2._reward_weight = 0.3\n        priority_v2._ucb_weight = 0.05\n        priority_v2._init = True\n    bins_remain_cap = np.asarray(bins_v2, dtype=float) if False else np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if priority_v2._selection_counts is None or priority_v2._selection_counts.shape[0] != n:\n        priority_v2._selection_counts = np.zeros(n, dtype=float)\n        priority_v2._total_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        priority_v2._total_calls += 1\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - priority_v2._epsilon) * deterministic + priority_v2._epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = priority_v2._selection_counts[feasible] > 0\n    avg_reward[mask] = priority_v2._total_rewards[feasible][mask] / priority_v2._selection_counts[feasible][mask]\n    total = priority_v2._total_calls + 1\n    ucb = np.sqrt(2.0 * np.log(total) / (priority_v2._selection_counts + 1e-6))\n    ucb_feas = ucb[feasible]\n    combined = base_score + priority_v2._reward_weight * avg_reward + priority_v2._ucb_weight * ucb_feas\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    priority_v2._total_calls += 1\n    reward = - (bins_remain_cap[best] - item)\n    priority_v2._selection_counts[best] += 1\n    priority_v2._total_rewards[best] += reward\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.6796968488233035,
    "SLOC": 39.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    Combines inverse slack, UCB, reward learning, and diversity for adaptive bin selection.\n    \"\"\"\n    import numpy as np\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.array([], dtype=float)\n    if not hasattr(priority_v2, \"_selection_counts\") or priority_v2._bins_len != n:\n        priority_v2._selection_counts = np.zeros(n, dtype=int)\n        priority_v2._total_rewards = np.zeros(n, dtype=float)\n        priority_v2._bins_len = n\n    epsilon = 0.05\n    offset = 1e-6\n    score_scale = 1.0\n    reward_weight = 0.1\n    ucb_weight = 1.0\n    diversity_weight = 0.1\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    det = np.zeros(n, dtype=float)\n    det[feasible] = 1.0 / (slack[feasible] + offset)\n    avg_reward = np.zeros(n, dtype=float)\n    nonzero = priority_v2._selection_counts > 0\n    avg_reward[nonzero] = priority_v2._total_rewards[nonzero] / priority_v2._selection_counts[nonzero]\n    total_counts = np.sum(priority_v2._selection_counts)\n    if total_counts == 0:\n        base = 1.0\n    else:\n        base = np.sqrt(2 * np.log(total_counts + 1))\n    ucb = np.zeros(n, dtype=float)\n    ucb[nonzero] = np.sqrt(2 * np.log(total_counts + 1) / priority_v2._selection_counts[nonzero])\n    ucb[~nonzero] = base\n    if feasible.any():\n        median_slack = np.median(slack[feasible])\n    else:\n        median_slack = 0.0\n    diversity = np.zeros(n, dtype=float)\n    diversity[feasible] = median_slack - slack[feasible]\n    combined = score_scale * det + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity\n    combined[~feasible] = -np.inf\n    random_term = np.random.rand(n)\n    scores = (1 - epsilon) * combined + epsilon * random_term\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 42.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\n_initialized = False\n_model_mu = None\n_model_cov = None\n_model_precision = None\n_bin_capacity = 1.0\n_noise_var = 0.5\n_prior_var = 10.0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    global _initialized, _model_mu, _model_cov, _model_precision, _bin_capacity, _noise_var, _prior_var\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if not _initialized:\n        _bin_capacity = np.max(caps) if caps.size > 0 else 1.0\n        d = 3\n        _model_mu = np.zeros(d)\n        _model_cov = np.eye(d) * _prior_var\n        _model_precision = np.linalg.inv(_model_cov)\n        _initialized = True\n    else:\n        max_cap = np.max(caps)\n        if max_cap > _bin_capacity:\n            _bin_capacity = max_cap\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = caps[feasible] - item\n    fill = 1.0 - slack / _bin_capacity\n    X = np.column_stack((np.ones_like(slack), slack, fill))\n    w = np.random.multivariate_normal(_model_mu, _model_cov)\n    scores[feasible] = X @ w\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        slack_selected = caps[best] - item\n        reward = -slack_selected\n        x = np.array([1.0, slack_selected, 1.0 - slack_selected / _bin_capacity])\n        precision_update = _model_precision + np.outer(x, x) / _noise_var\n        cov_new = np.linalg.inv(precision_update)\n        mu_new = cov_new @ (_model_precision @ _model_mu + x * reward / _noise_var)\n        _model_cov = cov_new\n        _model_precision = precision_update\n        _model_mu = mu_new\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 38.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response6.txt_stdout.txt",
    "code_path": "problem_iter23_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid slack and reward scoring with \u03b5\u2011greedy exploration.\"\"\"\n    w_inv = 0.6\n    w_lin = 0.4\n    w_reward = 0.2\n    epsilon = 0.15\n    if not hasattr(priority_v2, \"selection_counts\") or priority_v2.selection_counts.shape != bins_remain_cap.shape:\n        priority_v2.selection_counts = np.zeros(bins_remain_cap.shape, dtype=float)\n        priority_v2.total_rewards = np.zeros(bins_remain_cap.shape, dtype=float)\n        priority_v2.total_calls = 0\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        base = w_inv * (1.0 / (slack + 1.0)) + w_lin * (-slack)\n        sel_counts_feas = priority_v2.selection_counts[feasible]\n        tot_rewards_feas = priority_v2.total_rewards[feasible]\n        avg_reward_feas = np.where(sel_counts_feas > 0, tot_rewards_feas / sel_counts_feas, 0.0)\n        base = base + w_reward * avg_reward_feas\n        rand = np.random.rand(feasible.sum())\n        scores[feasible] = 0.0\n        scores[feasible] = (1 - epsilon) * base + epsilon * rand\n        chosen = np.argmax(scores)\n        chosen_slack = bins_remain_cap[chosen] - item\n        priority_v2.selection_counts[chosen] += 1\n        priority_v2.total_rewards[chosen] += -chosen_slack\n        priority_v2.total_calls += 1\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 27.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response8.txt_stdout.txt",
    "code_path": "problem_iter23_code8.py",
    "code": "import numpy as np\n\n# Adaptive inverse\u2011slack priority with average reward and epsilon exploration\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse slack, average reward and epsilon noise; updates per\u2011bin reward after selection.\"\"\"\n    n = bins_remain_cap.shape[0]\n    if not hasattr(priority_v2, \"selection_counts\") or priority_v2.selection_counts.shape[0] != n:\n        priority_v2.selection_counts = np.zeros(n, dtype=float)\n        priority_v2.total_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    slack = bins_remain_cap - item\n    base = np.where(feasible, -slack, -np.inf)\n    avg_reward = np.where(priority_v2.selection_counts > 0,\n                          priority_v2.total_rewards / priority_v2.selection_counts,\n                          0.0)\n    alpha = 0.3\n    epsilon = 0.1\n    score = np.where(feasible, base + alpha * avg_reward, -np.inf)\n    noise = np.random.rand(n)\n    score = np.where(feasible, score + epsilon * noise, -np.inf)\n    if np.any(feasible):\n        chosen = np.argmax(score)\n        reward = -slack[chosen]\n        priority_v2.selection_counts[chosen] += 1\n        priority_v2.total_rewards[chosen] += reward\n    return score",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.008775428799367,
    "SLOC": 22.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response9.txt_stdout.txt",
    "code_path": "problem_iter23_code9.py",
    "code": "import numpy as np\n\n_epsilon = 0.2\n_beta = 0.01\n_gamma = 0.5\n_delta = 0.1\n_bin_capacity = None\n_avg_slack = None\n_slack_counts = None\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using inverse slack, fill bias, avg slack, and \u03b5\u2011exploration.\"\"\"\n    global _bin_capacity, _avg_slack, _slack_counts\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _bin_capacity is None:\n        _bin_capacity = caps.max() if caps.size > 0 else 1.0\n    elif caps.max() > _bin_capacity:\n        _bin_capacity = caps.max()\n    if _avg_slack is None or _avg_slack.shape[0] != n:\n        _avg_slack = np.zeros(n, dtype=float)\n        _slack_counts = np.zeros(n, dtype=int)\n    feasible = caps >= item\n    if not feasible.any():\n        return np.full_like(caps, -np.inf)\n    slack = caps[feasible] - item\n    inv_slack = 1.0 / (slack + 1e-9)\n    fill = 1.0 - slack / _bin_capacity\n    avg_slack = _avg_slack[feasible]\n    deterministic = inv_slack - _beta * slack**2 + _gamma * fill - _delta * avg_slack\n    random_part = np.random.rand(slack.size)\n    scores = (1 - _epsilon) * deterministic + _epsilon * random_part\n    priorities = np.full_like(caps, -np.inf)\n    priorities[feasible] = scores\n    idx = np.where(feasible)[0]\n    _avg_slack[idx] = (_avg_slack[idx] * _slack_counts[idx] + slack) / (_slack_counts[idx] + 1)\n    _slack_counts[idx] += 1\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse\u2011slack scoring with epsilon exploration and per\u2011bin learning.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.array([], dtype=float)\n    if '_selection_counts' not in globals() or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=int)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = caps - item\n    det = 1.0 / (slack + 1.0)\n    avg_reward = np.zeros(n, dtype=float)\n    mask = _selection_counts > 0\n    avg_reward[mask] = _total_rewards[mask] / _selection_counts[mask]\n    reward_weight = 0.1\n    if _total_calls > 0:\n        ucb = np.zeros(n, dtype=float)\n        ucb[mask] = np.sqrt(2 * np.log(_total_calls) / _selection_counts[mask])\n        ucb_weight = 0.3\n    else:\n        ucb = np.zeros(n, dtype=float)\n        ucb_weight = 0.0\n    median_slack = np.median(slack[feasible]) if np.any(feasible) else 0.0\n    diversity = np.zeros(n, dtype=float)\n    diversity[feasible] = median_slack - slack[feasible]\n    diversity_weight = 0.1\n    combined = det + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity\n    epsilon = 0.15\n    rand = np.random.rand(n)\n    scores[feasible] = (1 - epsilon) * combined[feasible] + epsilon * rand[feasible]\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        reward = -(caps[best] - item)\n        _selection_counts[best] += 1\n        _total_rewards[best] += reward\n    _total_calls += 1\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.9589150378939015,
    "SLOC": 42.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\n# Hyperparameters\n_EPSILON = 0.2\n_BETA = 0.01\n_GAMMA = 0.5\n_DELTA = 0.1\n_UCB_WEIGHT = 0.05\n\n# State\n_bin_capacity = None\n_avg_slack = None\n_slack_counts = None\n_total_calls = 0\n\n# Hybrid inverse\u2011slack + UCB with \u03b5\u2011greedy exploration.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic using inverse slack, UCB bonus, and \u03b5\u2011greedy noise to rank bins.\"\"\"\n    global _bin_capacity, _avg_slack, _slack_counts, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.array([], dtype=float)\n    if _bin_capacity is None:\n        _bin_capacity = caps.max() if caps.size > 0 else 1.0\n    else:\n        if caps.max() > _bin_capacity:\n            _bin_capacity = caps.max()\n    if _avg_slack is None or _avg_slack.shape[0] != n:\n        _avg_slack = np.zeros(n, dtype=float)\n        _slack_counts = np.zeros(n, dtype=int)\n    _total_calls += 1\n\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf)\n    slack = caps[feasible] - item\n    inv_slack = 1.0 / (slack + 1e-9)\n    fill = 1.0 - slack / _bin_capacity\n    avg_slack = _avg_slack[feasible]\n    counts = _slack_counts[feasible]\n    ucb_bonus = np.sqrt(2 * np.log(_total_calls) / (counts + 1e-9))\n    deterministic = inv_slack - _BETA * slack**2 + _GAMMA * fill - _DELTA * avg_slack + _UCB_WEIGHT * ucb_bonus\n    random_part = np.random.rand(slack.size)\n    scores = (1 - _EPSILON) * deterministic + _EPSILON * random_part\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n    priorities[feasible] = scores\n    idx = np.where(feasible)[0]\n    _avg_slack[idx] = (_avg_slack[idx] * _slack_counts[idx] + slack) / (_slack_counts[idx] + 1)\n    _slack_counts[idx] += 1\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 33.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\n_initialized = False\n_model_mu = None\n_model_cov = None\n_model_precision = None\n_bin_capacity = 1.0\n_noise_var = 0.5\n_prior_var = 10.0\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid scoring: Bayesian model + inverse slack + per\u2011bin reward and UCB.\"\"\"\n    global _initialized, _model_mu, _model_cov, _model_precision, _bin_capacity\n    global _selection_counts, _total_rewards, _total_calls\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n\n    if not _initialized:\n        _bin_capacity = np.max(caps) if caps.size > 0 else 1.0\n        d = 3\n        _model_mu = np.zeros(d)\n        _model_cov = np.eye(d) * _prior_var\n        _model_precision = np.linalg.inv(_model_cov)\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _initialized = True\n    else:\n        max_cap = np.max(caps)\n        if max_cap > _bin_capacity:\n            _bin_capacity = max_cap\n        if _selection_counts.shape[0] != n:\n            _selection_counts = np.zeros(n, dtype=float)\n            _total_rewards = np.zeros(n, dtype=float)\n\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        _total_calls += 1\n        return scores\n\n    slack = caps[feasible] - item\n    fill = 1.0 - slack / _bin_capacity\n    X = np.column_stack((np.ones_like(slack), slack, fill))\n    w = np.random.multivariate_normal(_model_mu, _model_cov)\n    model_score = X @ w\n    inv_slack = 1.0 / (slack + 1e-6)\n    avg_reward = np.where(_selection_counts > 0,\n                          _total_rewards / _selection_counts,\n                          0.0)\n    ucb = np.sqrt(np.log(_total_calls + 1) / (_selection_counts + 1))\n    combined_feas = (0.4 * model_score +\n                    0.3 * inv_slack +\n                    0.2 * avg_reward +\n                    0.1 * ucb)\n    scores[feasible] = combined_feas\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        slack_selected = caps[best] - item\n        reward = -slack_selected\n        _selection_counts[best] += 1\n        _total_rewards[best] += reward\n        x = np.array([1.0, slack_selected, 1.0 - slack_selected / _bin_capacity])\n        precision_update = _model_precision + np.outer(x, x) / _noise_var\n        cov_new = np.linalg.inv(precision_update)\n        mu_new = cov_new @ (_model_precision @ _model_mu + x * reward / _noise_var)\n        _model_cov = cov_new\n        _model_precision = precision_update\n        _model_mu = mu_new\n    _total_calls += 1\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.058635819704831,
    "SLOC": 58.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\n# Mix per\u2011bin reward learning, adaptive rule weighting, and UCB exploration.\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n_rule_waste_sum = None\n_rule_waste_count = None\n_epsilon = 1e-9\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Blend adaptive rule scores, per\u2011bin avg reward, and UCB for online BPP.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    global _rule_waste_sum, _rule_waste_count\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _rule_waste_sum = np.zeros(4, dtype=float)\n        _rule_waste_count = np.zeros(4, dtype=int)\n\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n\n    leftovers = caps - item\n    indices = np.arange(n)\n    target = caps.mean()\n\n    # Rule scores\n    best_fit = -leftovers\n    worst_fit = leftovers\n    first_fit = -indices\n    fill_bal = -np.abs(leftovers - target)\n    rule_scores = np.stack([best_fit, worst_fit, first_fit, fill_bal], axis=0)\n\n    # Update waste statistics for each rule\n    for i in range(4):\n        scores_i = rule_scores[i].copy()\n        scores_i[~feasible] = -np.inf\n        best_idx = int(np.argmax(scores_i))\n        if feasible[best_idx]:\n            waste = leftovers[best_idx]\n            _rule_waste_sum[i] += waste\n            _rule_waste_count[i] += 1\n\n    # Adaptive rule weights (inverse average waste)\n    avg_waste = np.where(_rule_waste_count > 0,\n                         _rule_waste_sum / _rule_waste_count,\n                         np.inf)\n    inv_waste = 1.0 / (avg_waste + _epsilon)\n    finite_mask = np.isfinite(inv_waste)\n    if np.any(finite_mask):\n        rule_weights = np.zeros_like(inv_waste)\n        rule_weights[finite_mask] = inv_waste[finite_mask] / np.sum(inv_waste[finite_mask])\n    else:\n        rule_weights = np.full_like(inv_waste, 1.0 / inv_waste.size)\n\n    # Combine rule scores\n    combined = np.zeros(n, dtype=float)\n    for i, w in enumerate(rule_weights):\n        combined += w * rule_scores[i]\n\n    # Per\u2011bin average reward (negative waste)\n    avg_reward = np.zeros(n, dtype=float)\n    mask = _selection_counts > 0\n    avg_reward[mask] = _total_rewards[mask] / _selection_counts[mask]\n\n    # UCB exploration term\n    ucb = np.sqrt(np.log(_total_calls + 1) / np.maximum(_selection_counts, 1.0))\n\n    # Final score mixture\n    w_rule = 0.7\n    w_reward = 0.15\n    w_ucb = 0.15\n    scores = combined * w_rule + avg_reward * w_reward + ucb * w_ucb\n    scores[~feasible] = -np.inf\n\n    # Update per\u2011bin stats after placement\n    best = int(np.argmax(scores))\n    reward = -(caps[best] - item)  # negative waste\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    _total_calls += 1\n\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 59.0,
    "cyclomatic_complexity": 9.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\n# Global per\u2011bin statistics for lightweight online learning.\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid scoring: inverse slack, penalty, \u03b5\u2011noise, avg reward, UCB, softmax.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    slack = caps[feasible] - item\n    inv_slack = 1.0 / (slack + 1.0)\n    beta = 0.1\n    penalty = -beta * (slack ** 2)\n    deterministic = inv_slack + penalty\n    avg_reward = np.zeros_like(deterministic)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.2\n    total_calls = _total_calls + 1e-6\n    ucb = np.sqrt(2 * np.log(total_calls) / (_selection_counts[feasible] + 1e-6))\n    ucb_weight = 0.05\n    combined = deterministic + reward_weight * avg_reward + ucb_weight * ucb\n    epsilon = 0.05\n    noise = epsilon * np.random.rand(combined.shape[0])\n    raw = combined + noise\n    temperature = 0.5\n    exp_vals = np.exp(raw / temperature)\n    total_exp = exp_vals.sum()\n    if total_exp > 0:\n        scores[feasible] = exp_vals / total_exp\n    best_idx = int(np.argmax(scores))\n    if feasible[best_idx]:\n        chosen_slack = caps[best_idx] - item\n        reward = -chosen_slack\n        _selection_counts[best_idx] += 1\n        _total_rewards[best_idx] += reward\n        _total_calls += 1\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.427602712405275,
    "SLOC": 43.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response1.txt_stdout.txt",
    "code_path": "problem_iter29_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, stats: dict = None, epsilon: float = 0.2, ucb_weight: float = 0.3) -> np.ndarray:\n    \"\"\"Combines inverse\u2011slack, \u03b5\u2011greedy, and optional UCB bonus from prior usage.\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    max_cap = bins_remain_cap.max()\n    deterministic = 1.0 / (leftovers + 1.0)\n    reward = 1.0 - leftovers / max_cap\n    reward = np.clip(reward, 0.0, 1.0)\n    weighted = deterministic * (1.0 + reward)\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1.0 - epsilon) * weighted + epsilon * random_part\n    if stats is not None:\n        counts = stats.get('counts')\n        rewards = stats.get('rewards')\n        if counts is not None and rewards is not None and counts.shape == bins_remain_cap.shape:\n            counts_feasible = counts[feasible]\n            rewards_feasible = rewards[feasible]\n            avg_reward = np.where(counts_feasible > 0, rewards_feasible / counts_feasible, 0.0)\n            total_calls = counts.sum()\n            exploration_bonus = np.sqrt(np.log(total_calls + 1) / (counts_feasible + 1))\n            ucb_score = avg_reward + exploration_bonus\n            base_score += ucb_weight * ucb_score\n    scores[feasible] = base_score\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.008775428799367,
    "SLOC": 30.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response0.txt_stdout.txt",
    "code_path": "problem_iter29_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse slack, a simple Bayesian linear model, and \u03b5\u2011greedy exploration.\"\"\"\n    # Initialize static state on first call\n    if not hasattr(priority_v2, \"_init\"):\n        priority_v2._selection_counts = None\n        priority_v2._total_rewards = None\n        priority_v2._total_calls = 0\n        priority_v2._epsilon = 0.1          # exploration probability\n        priority_v2._det_weight = 0.7    # weight for deterministic inverse\u2011slack term\n        priority_v2._noise_var = 0.5\n        priority_v2._prior_var = 10.0\n        priority_v2._bin_capacity = 1.0\n        priority_v2._model_mu = None\n        priority_v2._model_cov = None\n        priority_v2._model_precision = None\n        priority_v2._init = True\n\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n\n    # Resize per\u2011bin statistics if number of bins changed\n    if priority_v2._selection_counts is None or priority_v2._selection_counts.shape[0] != n:\n        priority_v2._selection_counts = np.zeros(n, dtype=float)\n        priority_v2._total_rewards = np.zeros(n, dtype=float)\n\n    # Initialise Bayesian linear model if needed\n    if priority_v2._model_mu is None:\n        d = 3\n        priority_v2._model_mu = np.zeros(d)\n        priority_v2._model_mu = priority_v2._model_mu\n        priority_v2._model_cov = np.eye(d) * priority_v2._prior_var\n        priority_v2._model_precision = np.linalg.inv(priority_v2._model_cov)\n\n    # Update known bin capacity (assumes uniform capacity across bins)\n    max_cap = caps.max()\n    if max_cap > priority_v2._bin_capacity:\n        priority_v2._bin_capacity = max_cap\n\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        priority_v2._total_calls += 1\n        return scores\n\n    # Deterministic inverse\u2011slack term\n    leftover = caps[feasible] - item\n    det_score = 1.0 / (leftover + 1.0)\n\n    # Features for Bayesian model: [1, slack, fill]\n    slack = leftover\n    fill = 1.0 - slack / priority_v2._bin_capacity\n    X = np.column_stack((np.ones_like(slack), slack, fill))\n    model_score = X @ priority_v2._model_mu\n\n    # Blend deterministic and model scores\n    combined = priority_v2._selection_counts\n    combined = priority_v2._det_weight * det_score + (1.0 - priority_v2._det_weight) * model_score\n\n    # \u03b5\u2011greedy random component\n    rand_part = np.random.rand(feasible.sum())\n    final = (1.0 - priority_v2._epsilon) * combined + priority_v2._epsilon * rand_part\n    scores[feasible] = final\n\n    # Choose best bin and update learning state\n    best = int(np.argmax(scores))\n    priority_v2._total_calls += 1\n    if feasible[best]:\n        reward = - (caps[best] - item)          # negative leftover (higher is better)\n        priority_v2._selection_counts[best] += 1\n        priority_v2._total_rewards[best] += reward\n\n        # Bayesian update with selected bin's feature vector\n        slack_best = caps[best] - item\n        fill_best = 1.0 - slack_best / priority_v2._bin_capacity\n        x = np.array([1.0, slack_best, fill_best])\n        precision_new = priority_v2._model_precision + np.outer(x, x) / priority_v2._noise_var\n        cov_new = priority_v2._model_cov\n        cov_new = np.linalg.inv(precision_new)\n        mu_new = cov_new @ (priority_v2._model_precision @ priority_v2._model_mu + x * reward / priority_v2._noise_var)\n        priority_v2._model_precision = precision_new\n        priority_v2._model_cov = cov_new\n        priority_v2._model_mu = mu_new\n\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 63.0,
    "cyclomatic_complexity": 9.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response3.txt_stdout.txt",
    "code_path": "problem_iter29_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon: float = 0.2,\n    utilization_weight: float = 0.2,\n    rng: np.random.Generator = None,\n) -> np.ndarray:\n    \"\"\"Score bins via inverse slack, epsilon\u2011greedy randomness, and utilization weight.\"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    rng: np.random.Generator = np.random.default_rng() if rng is None else rng\n    random_part = epsilon * rng.random(size=deterministic.shape)\n    base_score = (1 - epsilon) * deterministic + random_part\n    capacity = caps.max() if caps.size else 0.0\n    if capacity > 0:\n        used_ratio = (capacity - caps) / capacity\n    else:\n        used_ratio = np.zeros_like(caps)\n    base_score += utilization_weight * used_ratio[feasible]\n    scores[feasible] = base_score\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9190267251695206,
    "SLOC": 28.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response4.txt_stdout.txt",
    "code_path": "problem_iter29_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines inverse slack, fill bias, UCB, learning, and exploration to score bins for online BPP.\n    \"\"\"\n    global _selection_counts, _total_rewards, _total_calls, _bin_capacity\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.array([], dtype=float)\n    if '_selection_counts' not in globals() or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=int)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0\n        _bin_capacity = caps.max() if n > 0 else 1.0\n    elif caps.max() > _bin_capacity:\n        _bin_capacity = caps.max()\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf)\n    slack = caps - item\n    inv_slack = 1.0 / (slack + 1e-9)\n    fill = 1.0 - slack / _bin_capacity\n    median_slack = np.median(slack[feasible]) if np.any(feasible) else 0.0\n    diversity = median_slack - slack\n    ucb = np.zeros(n, dtype=float)\n    mask_ucb = _selection_counts > 0\n    if _total_calls > 0 and np.any(mask_ucb):\n        ucb[mask_ucb] = np.sqrt(2 * np.log(_total_calls) / _selection_counts[mask_ucb])\n    avg_reward = np.zeros(n, dtype=float)\n    mask_reward = _selection_counts > 0\n    if np.any(mask_reward):\n        avg_reward[mask_reward] = _total_rewards[mask_reward] / _selection_counts[mask_reward]\n    combined = (\n        1.0 * inv_slack\n        + 0.3 * fill\n        + 0.1 * diversity\n        + 0.1 * avg_reward\n        + 0.2 * ucb\n    )\n    epsilon = 0.15\n    rand = np.random.rand(n)\n    scores = np.full_like(caps, -np.inf, dtype=float)\n    scores[feasible] = (1 - epsilon) * combined[feasible] + epsilon * rand[feasible]\n    best_idx = int(np.argmax(scores))\n    if feasible[best_idx]:\n        reward = -(caps[best_idx] - item)\n        _selection_counts[best_idx] += 1\n        _total_rewards[best_idx] += reward\n    _total_calls += 1\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9788591942560925,
    "SLOC": 47.0,
    "cyclomatic_complexity": 12.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter29_response7.txt_stdout.txt",
    "code_path": "problem_iter29_code7.py",
    "code": "import numpy as np\n\n# priority_v2: hybrid inverse\u2011slack with \u03b5\u2011greedy and simple online statistics.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid inverse\u2011slack with epsilon\u2011greedy, using feasibility mask and optional avg\u2011slack.\n    \"\"\"\n    # Hyperparameters\n    _EPSILON = 0.15\n    _BETA = 0.02\n    _GAMMA = 0.5\n    _DELTA = 0.1\n    _UCB_WEIGHT = 0.03\n\n    # Initialize static state on first call\n    if not hasattr(priority_v2, \"_total_calls\"):\n        priority_v2._total_calls = 0\n        priority_v2._avg_slack = None\n        priority_v2._slack_counts = None\n        priority_v2._bin_capacity = None\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.array([], dtype=float)\n\n    # Update known maximum bin capacity\n    if priority_v2._bin_capacity is None:\n        priority_v2._bin_capacity = caps.max() if caps.size > 0 else 1.0\n    else:\n        max_cap = caps.max()\n        if max_cap > priority_v2._bin_capacity:\n            priority_v2._bin_capacity = max_cap\n\n    # Ensure average\u2011slack arrays match current number of bins\n    if priority_v2._avg_slack is None or priority_v2._avg_slack.shape[0] != n:\n        priority_v2._avg_slack = np.zeros(n, dtype=float)\n        priority_v2._slack_counts = np.zeros(n, dtype=int)\n\n    priority_v2._total_calls += 1\n\n    feasible = caps >= item\n    scores = np.full_like(caps, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n\n    slack = caps[feasible] - item\n    inv_slack = 1.0 / (slack + 1e-9)\n    fill = 1.0 - slack / priority_v2._bin_capacity\n\n    idx = np.where(feasible)[0]\n    avg_slack = priority_v2._avg_slack[idx]\n    counts = priority_v2._slack_counts[idx]\n    ucb_bonus = np.sqrt(2 * np.log(priority_v2._total_calls) / (counts + 1e-9))\n\n    deterministic = (\n        inv_slack\n        - _BETA * slack**2\n        + _GAMMA * fill\n        - _DELTA * avg_slack\n        + _UCB_WEIGHT * ucb_bonus\n    )\n    random_part = np.random.rand(deterministic.size)\n    scores_feas = (1 - _EPSILON) * deterministic + _EPSILON * random_part\n    scores[feasible] = scores_feas\n\n    # Update average slack and selection counts\n    new_counts = counts + 1\n    priority_v2._avg_slack[idx] = (avg_slack * counts + slack) / new_counts\n    priority_v2._slack_counts[idx] = new_counts\n\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 50.0,
    "cyclomatic_complexity": 9.0,
    "exec_success": true
  }
]