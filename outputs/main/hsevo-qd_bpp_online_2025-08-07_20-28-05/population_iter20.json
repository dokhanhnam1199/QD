[
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    slack = bins_remain_cap - item\n    fits = slack >= 0\n    eps = np.finfo(slack.dtype).eps\n    return np.where(fits, -slack + eps, -np.inf)",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.2\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    scores[feasible] = 1.0 / (leftovers + 1.0)\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    return scores",
    "response_id": 18,
    "tryHS": true,
    "obj": 3.370562425209409,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.2, beta: float = 0.02) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy tight\u2011fit with squared\u2011slack penalty for waste reduction.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    det = 1.0/(leftovers + 1.0) - beta * leftovers**2\n    rand_part = np.random.rand(bins_remain_cap.size)\n    scores[feasible] = (1 - epsilon) * det + epsilon * rand_part[feasible]\n    return scores",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.3272578070972282,\n                offset: float = 3.6930496425184325,\n                score_scale: float = 1.8547777441606528) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins given an item size.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to place.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of bins.\n    epsilon : float, optional\n        Weight for the random exploration term (default 0.2).\n    offset : float, optional\n        Small constant added to leftover capacity to avoid division by zero\n        (default 1.0).\n    score_scale : float, optional\n        Scaling factor for the deterministic part of the score\n        (default 1.0).\n\n    Returns\n    -------\n    np.ndarray\n        Score for each bin; -inf for infeasible bins.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    scores[feasible] = score_scale / (leftovers + offset)\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    return scores",
    "response_id": 2,
    "tryHS": true,
    "obj": 3.5500598324691004,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\nclass PriorityV2:\n    def __init__(self):\n        self.total_calls = 0\n        self.selection_counts = None\n        self.total_rewards = None\n        self.temperature = 1.0\n        self.decay = 0.995\n\n    def priority(self, item, bins_remain_cap):\n        n = bins_remain_cap.shape[0]\n        if self.selection_counts is None or self.selection_counts.shape[0] != n:\n            self.selection_counts = np.zeros(n, dtype=float)\n            self.total_rewards = np.zeros(n, dtype=float)\n        feasible = bins_remain_cap >= item\n        leftovers = np.where(feasible, bins_remain_cap - item, np.inf)\n        base_score = np.where(feasible, 1.0 / (leftovers + 1.0), 0.0)\n        median_leftover = np.median(leftovers[feasible]) if np.any(feasible) else 0.0\n        diversity = np.where(feasible, 1.0 / (np.abs(leftovers - median_leftover) + 1.0), 0.0)\n        avg_reward = np.where(self.selection_counts > 0, self.total_rewards / self.selection_counts, 0.0)\n        c = 1.0\n        ucb = avg_reward + c * np.sqrt(np.log(self.total_calls + 1) / (self.selection_counts + 1))\n        combined_feas = 0.5 * base_score + 0.3 * diversity + 0.2 * ucb\n        combined = np.full(n, -np.inf, dtype=float)\n        combined[feasible] = combined_feas[feasible]\n        noise = np.random.rand(n)\n        combined[feasible] = (1 - self.temperature) * combined[feasible] + self.temperature * noise[feasible]\n        self.total_calls += 1\n        self.temperature *= self.decay\n        if np.any(feasible):\n            chosen = np.argmax(combined)\n            reward = - (bins_remain_cap[chosen] - item)\n            self.selection_counts[chosen] += 1\n            self.total_rewards[chosen] += reward\n        return combined\n\n_priority_v2_instance = PriorityV2()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    return _priority_v2_instance.priority(item, bins_remain_cap)",
    "response_id": 0,
    "tryHS": false,
    "obj": 59.57319505384924,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    temperature = 1.0\n    exp_vals = np.exp(-slack / temperature)\n    total = exp_vals.sum()\n    if total > 0:\n        priorities[feasible] = exp_vals / total\n    return priorities",
    "response_id": 19,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\n# Combine inverse\u2011slack and linear\u2011slack with \u03b5\u2011greedy randomness.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    \u03b5\u2011greedy scoring: weighted sum of inverse slack and negative slack, with random tie\u2011breaker.\n    \"\"\"\n    epsilon = 0.15          # exploration factor\n    w_inv = 0.6             # weight for reciprocal slack\n    w_lin = 0.4             # weight for linear slack penalty\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    slack = bins_remain_cap[feasible] - item\n    base = w_inv * (1.0 / (slack + 1.0)) + w_lin * (-slack)\n    scores[feasible] = base\n    scores = (1 - epsilon) * scores + epsilon * np.random.rand(bins_remain_cap.shape[0])\n    # softmax scaling for probability\u2011like priorities\n    finite_mask = np.isfinite(scores)\n    if not np.any(finite_mask):\n        return scores\n    max_score = np.max(scores[finite_mask])\n    exp_scores = np.exp(scores - max_score)\n    exp_scores[~finite_mask] = 0.0\n    probabilities = exp_scores / exp_scores.sum()\n    return probabilities",
    "response_id": 3,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.2\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    random_part = np.random.rand(feasible.sum())\n    combined = (1 - epsilon) * deterministic + epsilon * random_part\n    scores[feasible] = combined\n    max_score = np.max(scores[feasible])\n    exp_scores = np.exp(scores - max_score)\n    probabilities = exp_scores / exp_scores.sum()\n    return probabilities",
    "response_id": 5,
    "tryHS": true,
    "obj": 3.4004786597527064,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine inverse slack and negative squared slack with epsilon\u2011greedy randomness for balanced tight\u2011fit and exploration.\"\"\"\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftover = bins_remain_cap[feasible] - item\n    epsilon = 0.2\n    beta = 0.01\n    deterministic = 1.0 / (leftover + 1e-9) - beta * (leftover ** 2)\n    random_part = np.random.rand(feasible.sum())\n    scores = (1 - epsilon) * deterministic + epsilon * random_part\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[feasible] = scores\n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 4.028719585161557,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\n# Combine tight\u2011fit incentive, slack penalty, random exploration, and softmax scaling.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins by inverse slack, squared\u2011slack penalty, \u03b5\u2011greedy noise, and softmax.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if not np.any(feasible):\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    inv_slack = 1.0 / (slack + 1.0)\n    beta = 0.1\n    penalty = -beta * (slack ** 2)\n    deterministic = inv_slack + penalty\n    epsilon = 0.05\n    random_noise = epsilon * np.random.rand(deterministic.shape[0])\n    raw = deterministic + random_noise\n    temperature = 0.5\n    exp_vals = np.exp(raw / temperature)\n    total = exp_vals.sum()\n    if total > 0:\n        priorities[feasible] = exp_vals / total\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\n# Combines multiple slack components with epsilon\u2011greedy exploration and softmax scaling.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.1, w_inv: float = 0.5,\n                w_lin: float = 0.3, w_sq: float = 0.2,\n                temperature: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy softmax priority blending inverse slack, linear slack penalty,\n    and squared slack penalty for balanced tight fits and exploration.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if np.any(feasible):\n        slack = bins_remain_cap[feasible] - item\n        base = w_inv * (1.0 / (slack + 1.0)) - w_lin * slack - w_sq * slack**2\n        scores[feasible] = base\n    if epsilon > 0:\n        scores += epsilon * np.random.rand(bins_remain_cap.size)\n    finite_mask = np.isfinite(scores)\n    if not np.any(finite_mask):\n        return scores\n    exp_scores = np.exp((scores[finite_mask] / temperature) -\n                        np.max(scores[finite_mask] / temperature))\n    probs = np.zeros_like(scores)\n    probs[finite_mask] = exp_scores / exp_scores.sum()\n    return probs",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                temperature: float = 8.21777003404979,\n                total_threshold: float = 0.7518899527010219) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        temperature: Temperature controlling the softness of the exponential weighting.\n        total_threshold: Minimum sum of exponential values required to assign non\u2011zero priorities.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    if not np.any(feasible):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    epsilon = 0.15\n    w_inv = 0.5\n    w_lin = 0.3\n    w_sq = 0.2\n    temperature = 1.0\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    slack = bins_remain_cap[feasible] - item\n    core = w_inv / (slack + 1.0) - w_lin * slack - w_sq * slack**2\n    rand = np.random.rand(feasible.sum())\n    scores_feasible = (1 - epsilon) * core + epsilon * rand\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    scores[feasible] = scores_feasible\n    max_score = np.max(scores_feasible)\n    exp_scores = np.exp((scores_feasible - max_score) / temperature)\n    probs_feasible = exp_scores / exp_scores.sum()\n    probs = np.zeros_like(bins_remain_cap, dtype=float)\n    probs[feasible] = probs_feasible\n    return probs",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Inverse slack + epsilon random + avg reward for online bin packing.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.3\n    combined = base_score + reward_weight * avg_reward\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    _total_calls += 1\n    reward = - (bins_remain_cap[best] - item)\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.380534503390516,
    "SLOC": 30.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    if not hasattr(priority_v2, \"initialized\"):\n        priority_v2.num_rules = 4\n        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)\n        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)\n        priority_v2.step = 0\n        priority_v2.epsilon = 1e-9\n        priority_v2.initialized = True\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap - item\n    best_fit_score = np.where(feasible, -leftovers, -np.inf)\n    worst_fit_score = np.where(feasible, leftovers, -np.inf)\n    indices = np.arange(bins_remain_cap.shape[0] if hasattr(bins_remain_cap, \"shape\") else len(bins_remain_cap))\n    first_fit_score = np.where(feasible, -indices, -np.inf)\n    target = bins_remain_cap.mean()\n    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)\n    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]\n    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)\n    for i, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            waste_per_rule[i] = np.inf\n        else:\n            idx = np.argmax(scores)\n            waste_per_rule[i] = bins_remain_cap[idx] - item\n    for i in range(priority_v2.num_rules):\n        w = waste_per_rule[i]\n        if np.isfinite(w):\n            priority_v2.sum_waste[i] += w\n            priority_v2.count[i] += 1\n    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)\n    inv = 1.0 / (avg_waste + priority_v2.epsilon)\n    boost = np.zeros(priority_v2.num_rules, dtype=float)\n    boost_idx = priority_v2.step % priority_v2.num_rules\n    boost[boost_idx] = 1.0 / (priority_v2.step + 1)\n    raw_weights = inv + boost\n    total = raw_weights.sum()\n    if total > 0:\n        weights = raw_weights / total\n    else:\n        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)\n    combined_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    for w, scores in zip(weights, rule_scores):\n        combined_scores += w * scores\n    combined_scores[~feasible] = -np.inf\n    priority_v2.step += 1\n    return combined_scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.3777423214998095,
    "SLOC": 48.0,
    "cyclomatic_complexity": 10.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item, bins_remain_cap):\n    feasible = bins_remain_cap >= item\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                beta: float = 0.01, temperature: float = 1.0,\n                total_threshold: float = 1e-6) -> np.ndarray:\n    \"\"\"Score bins by inverse slack minus slack\u00b2, softened with temperature.\"\"\"\n    feasible = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    if not feasible.any():\n        return priorities\n    slack = bins_remain_cap[feasible] - item\n    eps = 1e-9\n    raw = 1.0 / (slack + eps) - beta * slack**2\n    exp_scores = np.exp(raw / temperature)\n    if exp_scores.sum() < total_threshold:\n        return priorities\n    priorities[feasible] = exp_scores\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef _extract_features(item: float, bins_remain_cap: np.ndarray, capacity: float):\n    slack = bins_remain_cap - item\n    slack_norm = slack / capacity\n    used_ratio = (capacity - bins_remain_cap) / capacity\n    return slack_norm, used_ratio\n\ndef _combine_features(slack_norm: np.ndarray, used_ratio: np.ndarray):\n    return used_ratio - slack_norm\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    capacity = np.max(bins_remain_cap) if bins_remain_cap.size else 0.0\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if capacity > 0 and np.any(feasible):\n        slack_norm, used_ratio = _extract_features(item, bins_remain_cap, capacity)\n        combined = _combine_features(slack_norm, used_ratio)\n        scores[feasible] = combined[feasible]\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\n# Priority combines inverse slack, best\u2011fit, first\u2011fit, fill\u2011balance and simple reward learning.\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Score bins using slack, fit, index and reward heuristics for online bin packing.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n    leftovers_all = caps - item\n    leftovers = leftovers_all[feasible]\n    inv_slack = 1.0 / (leftovers + 1.0)\n    best_fit = -leftovers\n    first_fit = -np.arange(n)[feasible]\n    target = caps.mean()\n    fill_bal = -np.abs(leftovers - target)\n    avg_reward = np.zeros_like(leftovers)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    w_inv, w_best, w_first, w_bal, w_rew = 0.4, 0.3, 0.1, 0.1, 0.1\n    combined = (w_inv * inv_slack + w_best * best_fit + w_first * first_fit +\n                w_bal * fill_bal + w_rew * avg_reward)\n    scores = np.full(n, -np.inf, dtype=float)\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    reward = -(caps[best] - item)\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    _total_calls += 1\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 33.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\n_pv2_selection_counts = None\n_pv2_total_rewards = None\n_pv2_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive scoring: inverse slack + UCB + reward learning + diversity + epsilon noise.\"\"\"\n    global _pv2_selection_counts, _pv2_total_rewards, _pv2_total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    if _pv2_selection_counts is None or _pv2_selection_counts.shape[0] != n:\n        _pv2_selection_counts = np.zeros(n, dtype=float)\n        _pv2_total_rewards = np.zeros(n, dtype=float)\n        _pv2_total_calls = 0\n    feasible = caps >= item\n    if not np.any(feasible):\n        return np.full(n, -np.inf, dtype=float)\n    leftovers = caps[feasible] - item\n    inv_slack = 1.0 / (leftovers + 1.0)\n    eps = 0.2\n    random_term = np.random.rand(leftovers.size)\n    base = (1 - eps) * inv_slack + eps * random_term\n    indices = np.arange(n)[feasible]\n    best_fit = -leftovers\n    first_fit = -indices\n    selection_counts_feasible = _pv2_selection_counts[feasible]\n    avg_reward_feasible = np.where(selection_counts_feasible > 0,\n                                   _pv2_total_rewards[feasible] / selection_counts_feasible,\n                                   0.0)\n    c = 0.5\n    ucb_bonus = c * np.sqrt(np.log(_pv2_total_calls + 1) / (selection_counts_feasible + 1))\n    median_leftover = np.median(leftovers) if leftovers.size > 0 else 0.0\n    diversity = 1.0 / (np.abs(leftovers - median_leftover) + 1.0)\n    w_base, w_ucb, w_reward, w_div, w_best_fit, w_first_fit = 0.4, 0.2, 0.15, 0.1, 0.1, 0.05\n    score_feasible = (w_base * base + w_ucb * ucb_bonus + w_reward * avg_reward_feasible\n                      + w_div * diversity + w_best_fit * best_fit + w_first_fit * first_fit)\n    scores = np.full(n, -np.inf, dtype=float)\n    scores[feasible] = score_feasible\n    best = int(np.argmax(scores))\n    chosen_leftover = caps[best] - item\n    reward = -chosen_leftover\n    _pv2_selection_counts[best] += 1\n    _pv2_total_rewards[best] += reward\n    _pv2_total_calls += 1\n    return scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 41.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response6.txt_stdout.txt",
    "code_path": "problem_iter17_code6.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    global _selection_counts, _total_rewards\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.1\n    combined = base_score + reward_weight * avg_reward\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        reward = - (caps[best] - item)\n        _selection_counts[best] += 1\n        _total_rewards[best] += reward\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 3.3506182688472412,
    "SLOC": 30.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response7.txt_stdout.txt",
    "code_path": "problem_iter17_code7.py",
    "code": "import numpy as np\n\n_pv2_counts = None\n_pv2_rewards = None\n_pv2_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    global _pv2_counts, _pv2_rewards, _pv2_total_calls\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    if _pv2_counts is None or _pv2_counts.shape[0] != n:\n        _pv2_counts = np.zeros(n, dtype=float)\n        _pv2_rewards = np.zeros(n, dtype=float)\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    epsilon = 0.2\n    inv_slack = 1.0 / (leftovers + 1.0)\n    rand_part = np.random.rand(leftovers.shape[0])\n    base_score = (1 - epsilon) * inv_slack + epsilon * rand_part\n    median_leftover = np.median(leftovers) if leftovers.size > 0 else 0.0\n    diversity = 1.0 / (np.abs(leftovers - median_leftover) + 1.0)\n    diversity_weight = 0.1\n    counts_feasible = _pv2_counts[feasible]\n    rewards_feasible = _pv2_rewards[feasible]\n    avg_reward = np.where(counts_feasible > 0, rewards_feasible / counts_feasible, 0.0)\n    c = 0.5\n    exploration_bonus = c * np.sqrt(np.log(_pv2_total_calls + 1) / (counts_feasible + 1))\n    ucb_score = avg_reward + exploration_bonus\n    ucb_weight = 0.3\n    final_score = base_score + ucb_weight * ucb_score + diversity_weight * diversity\n    scores[feasible] = final_score\n    best_idx = int(0) if n == 0 else int(np.argmax(scores))\n    if scores[best_idx] != -np.inf:\n        chosen_leftover = bins_remain_cap[best_idx] - item\n        reward = -chosen_leftover\n        _pv2_counts[best_idx] += 1\n        _pv2_rewards[best_idx] += reward\n        _pv2_total_calls += 1\n    return scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 61.926605504587165,
    "SLOC": 38.0,
    "cyclomatic_complexity": 8.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response8.txt_stdout.txt",
    "code_path": "problem_iter17_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                epsilon: float = 0.2,\n                temperature: float = 1.0,\n                total_threshold: float = 0.0) -> np.ndarray:\n    \"\"\"Inverse slack scored, temperature\u2011scaled softmax, then blended with \u03b5\u2011noise for tie\u2011breaking.\"\"\"\n    feasible = bins_remain_cap >= item\n    scores = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = bins_remain_cap[feasible] - item\n    base = 1.0 / (leftovers + 1.0)\n    exp_input = base / temperature\n    exp_input = np.clip(exp_input, a_min=None, a_max=50.0)\n    exp_scores = np.exp(exp_input)\n    total = exp_scores.sum()\n    if total >= total_threshold:\n        scores[feasible] = exp_scores / total\n    else:\n        scores[feasible] = 0.0\n    rand = np.random.rand(bins_remain_cap.shape[0])\n    rand[~feasible] = 0.0\n    return (1.0 - epsilon) * scores + epsilon * rand",
    "response_id": 8,
    "tryHS": false,
    "obj": 63.98085360989232,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\n# Global state for learning per bin\n_selection_counts = None\n_total_rewards = None\n_total_calls = None\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive scorer: inverse slack, UCB, diversity, reward learning, \u03b5\u2011greedy.\n    \"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0.0\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.2\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.1\n    total_calls = _total_calls + 1e-6\n    ucb = np.sqrt(2 * np.log(total_calls) / (_selection_counts[feasible] + 1e-6))\n    ucb_weight = 0.05\n    median_leftover = np.median(leftovers)\n    diversity = 1.0 / (np.abs(leftovers - median_leftover) + 1.0)\n    diversity_weight = 0.05\n    combined = base_score + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    if feasible[best]:\n        reward = -(caps[best] - item)\n        _selection_counts[best] += 1\n        _total_rewards[best] += reward\n        _total_calls += 1\n    return scores",
    "response_id": 0,
    "tryHS": false,
    "obj": 21.788990825688074,
    "SLOC": 38.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\n_selection_counts = None\n_total_rewards = None\n_total_calls = 0\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combine inverse slack, \u03b5\u2011greedy noise, per\u2011bin reward, and UCB bonus.\"\"\"\n    global _selection_counts, _total_rewards, _total_calls\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.shape[0]\n    if n == 0:\n        return np.array([], dtype=float)\n    if _selection_counts is None or _selection_counts.shape[0] != n:\n        _selection_counts = np.zeros(n, dtype=float)\n        _total_rewards = np.zeros(n, dtype=float)\n        _total_calls = 0\n    feasible = caps >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return scores\n    leftovers = caps[feasible] - item\n    deterministic = 1.0 / (leftovers + 1.0)\n    epsilon = 0.15\n    random_part = np.random.rand(feasible.sum())\n    base_score = (1 - epsilon) * deterministic + epsilon * random_part\n    avg_reward = np.zeros_like(base_score)\n    mask = _selection_counts[feasible] > 0\n    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]\n    reward_weight = 0.1\n    reward_component = reward_weight * avg_reward\n    c = 0.2\n    total = _total_calls + 1\n    sel_counts = _selection_counts[feasible] + 1e-9\n    ucb_bonus = c * np.sqrt(np.log(total) / sel_counts)\n    combined = base_score + reward_component + ucb_bonus\n    scores[feasible] = combined\n    best = int(np.argmax(scores))\n    _total_calls += 1\n    reward = - (caps[best] - item)\n    _selection_counts[best] += 1\n    _total_rewards[best] += reward\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.689668927004388,
    "SLOC": 36.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive hybrid scoring: combine inverse slack, learned waste, UCB exploration, and diversity with epsilon noise.\"\"\"\n    if not hasattr(priority_v2, \"initialized\"):\n        priority_v2.num_rules = 4\n        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)\n        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)\n        priority_v2.step = 0\n        priority_v2.epsilon = 1e-9\n        priority_v2.initialized = True\n    feasible = bins_remain_cap >= item\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    leftovers = bins_remain_cap - item\n    indices = np.arange(bins_remain_cap.shape[0])\n    target = bins_remain_cap.mean()\n    best_fit_score = np.where(feasible, -leftovers, -np.inf)\n    worst_fit_score = np.where(feasible, leftovers, -np.inf)\n    first_fit_score = np.where(feasible, -indices, -np.inf)\n    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)\n    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]\n    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)\n    for i, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            waste_per_rule[i] = np.inf\n        else:\n            idx = np.argmax(scores)\n            waste_per_rule[i] = bins_remain_cap[idx] - item\n    for i in range(priority_v2.num_rules):\n        w = waste_per_rule[i]\n        if np.isfinite(w):\n            priority_v2.sum_waste[i] += w\n            priority_v2.count[i] += 1\n    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)\n    inv = 1.0 / (avg_waste + priority_v2.epsilon)\n    boost = np.zeros(priority_v2.num_rules, dtype=float)\n    boost_idx = priority_v2.step % priority_v2.num_rules\n    boost[boost_idx] = 1.0 / (priority_v2.step + 1)\n    raw_weights = inv + boost\n    total = raw_weights.sum()\n    if total > 0:\n        weights = raw_weights / total\n    else:\n        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)\n    total_calls = priority_v2.step + 1\n    ucb_bonus = np.empty(priority_v2.num_rules, dtype=float)\n    for r in range(priority_v2.num_rules):\n        if priority_v2.count[r] > 0:\n            ucb_bonus[r] = np.sqrt(2 * np.log(total_calls) / priority_v2.count[r])\n        else:\n            ucb_bonus[r] = np.sqrt(2 * np.log(total_calls))\n    median_slack = np.median(leftovers[feasible])\n    diversity_bonus = np.empty(priority_v2.num_rules, dtype=float)\n    for r, scores in enumerate(rule_scores):\n        if not np.isfinite(scores).any():\n            diversity_bonus[r] = 0.0\n        else:\n            idx = np.argmax(scores)\n            diversity_bonus[r] = np.abs(leftovers[idx] - median_slack)\n    combined_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    for w, scores, ub, db in zip(weights, rule_scores, ucb_bonus, diversity_bonus):\n        temp = np.where(feasible, scores, -np.inf)\n        temp += ub\n        temp += db\n        combined_scores += w * temp\n    rand_noise = np.random.rand(bins_remain_cap.shape[0])\n    rand_noise[~feasible] = 0.0\n    combined_scores += 0.05 * rand_noise\n    priority_v2.step += 1\n    return combined_scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 68.0,
    "cyclomatic_complexity": 13.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive scoring: inverse slack, linear slack, per-bin reward, UCB bonus, \u03b5-exploration.\"\"\"\n    if not hasattr(priority_v2, \"_initialized\"):\n        priority_v2._sum_reward = None\n        priority_v2._count = None\n        priority_v2._total_calls = 0\n        priority_v2._epsilon = 0.12\n        priority_v2._w_inv = 0.55\n        priority_v2._w_lin = 0.25\n        priority_v2._w_reward = 0.15\n        priority_v2._w_ucb = 0.05\n        priority_v2._initialized = True\n    n = bins_remain_cap.shape[0]\n    if priority_v2._sum_reward is None or priority_v2._sum_reward.shape[0] != n:\n        priority_v2._sum_reward = np.zeros(n, dtype=float)\n        priority_v2._count = np.zeros(n, dtype=int)\n    feasible = bins_remain_cap >= item\n    scores = np.full(n, -np.inf, dtype=float)\n    if not feasible.any():\n        priority_v2._initialized = True\n        priority_v2._total_calls += 1\n        return scores\n    slack = bins_remain_cap[feasible] - item\n    base = priority_v2._w_inv * (1.0 / (slack + 1.0)) + priority_v2._w_lin * (-slack)\n    scores[feasible] = base\n    avg_reward = np.zeros(n, dtype=float)\n    mask = priority_v2._count > 0\n    avg_reward[mask] = priority_v2._sum_reward[mask] / priority_v2._count[mask]\n    scores[feasible] += priority_v2._w_reward * avg_reward[feasible]\n    total = priority_v2._total_calls + 1\n    ucb = np.sqrt(2.0 * np.log(total) / (priority_v2._count + 1e-6))\n    scores[feasible] += priority_v2._w_ucb * ucb[feasible]\n    rand_vals = np.random.rand(n)\n    scores[feasible] += priority_v2._epsilon * rand_vals[feasible]\n    chosen = int(np.argmax(scores))\n    if feasible[chosen]:\n        reward = - (0) if False else - (bins_remain_cap[chosen] - item)\n        priority_v2._sum_reward[chosen] += reward\n        priority_v2._count[chosen] += 1\n    priority_v2._total_calls += 1\n    return scores",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 40.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    Combines inverse slack, UCB, reward learning, and diversity for adaptive bin selection.\n    \"\"\"\n    import numpy as np\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    n = bins_remain_cap.size\n    if n == 0:\n        return np.array([], dtype=float)\n    if not hasattr(priority_v2, \"_selection_counts\") or priority_v2._bins_len != n:\n        priority_v2._selection_counts = np.zeros(n, dtype=int)\n        priority_v2._total_rewards = np.zeros(n, dtype=float)\n        priority_v2._bins_len = n\n    epsilon = 0.05\n    offset = 1e-6\n    score_scale = 1.0\n    reward_weight = 0.1\n    ucb_weight = 1.0\n    diversity_weight = 0.1\n    slack = bins_remain_cap - item\n    feasible = slack >= 0\n    det = np.zeros(n, dtype=float)\n    det[feasible] = 1.0 / (slack[feasible] + offset)\n    avg_reward = np.zeros(n, dtype=float)\n    nonzero = priority_v2._selection_counts > 0\n    avg_reward[nonzero] = priority_v2._total_rewards[nonzero] / priority_v2._selection_counts[nonzero]\n    total_counts = np.sum(priority_v2._selection_counts)\n    if total_counts == 0:\n        base = 1.0\n    else:\n        base = np.sqrt(2 * np.log(total_counts + 1))\n    ucb = np.zeros(n, dtype=float)\n    ucb[nonzero] = np.sqrt(2 * np.log(total_counts + 1) / priority_v2._selection_counts[nonzero])\n    ucb[~nonzero] = base\n    if feasible.any():\n        median_slack = np.median(slack[feasible])\n    else:\n        median_slack = 0.0\n    diversity = np.zeros(n, dtype=float)\n    diversity[feasible] = median_slack - slack[feasible]\n    combined = score_scale * det + reward_weight * avg_reward + ucb_weight * ucb + diversity_weight * diversity\n    combined[~feasible] = -np.inf\n    random_term = np.random.rand(n)\n    scores = (1 - epsilon) * combined + epsilon * random_term\n    return scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 42.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  }
]