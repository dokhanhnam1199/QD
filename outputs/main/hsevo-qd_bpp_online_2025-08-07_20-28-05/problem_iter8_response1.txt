```python
import numpy as np

_selection_counts = None
_total_rewards = None
_total_calls = 0

def priority_v2(item, bins_remain_cap):
    global _selection_counts, _total_rewards, _total_calls
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n = bins_remain_cap.shape[0]
    if n == 0:
        return np.array([], dtype=float)
    if _selection_counts is None or _selection_counts.shape[0] != n:
        _selection_counts = np.zeros(n, dtype=float)
        _total_rewards = np.zeros(n, dtype=float)
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        return np.full(n, -np.inf, dtype=float)
    scores = np.full(n, -np.inf, dtype=float)
    leftovers = bins_remain_cap[feasible] - item
    deterministic = 1.0 / (leftovers + 1.0)
    epsilon = 0.2
    random_part = np.random.rand(feasible.sum())
    base_score = (1 - epsilon) * deterministic + epsilon * random_part
    avg_reward_feas = np.zeros_like(base_score)
    mask_counts_feas = _selection_counts[feasible] > 0
    avg_reward_feas[mask_counts_feas] = _total_rewards[feasible][mask_counts_feas] / _selection_counts[feasible][mask_counts_feas]
    reward_weight = 0.3
    combined_feas = base_score + reward_weight * avg_reward_feas
    scores[feasible] = combined_feas
    best = np.argmax(scores)
    _total_calls += 1
    leftover = bins_remain_cap[best] - item
    reward = -leftover
    _selection_counts[best] += 1
    _total_rewards[best] += reward
    return scores
```
