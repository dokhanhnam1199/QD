```python
import numpy as np

_selection_counts = None
_total_rewards = None
_total_calls = 0

# Adaptive priority: inverse slack, decaying epsilon noise, slack penalty, avg reward, softmax.
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combine inverse slack, decaying epsilon, slack penalty, avg reward, softmax scaling."""
    global _selection_counts, _total_rewards, _total_calls
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)
    n = bins_remain_cap.shape[0]
    if n == 0:
        return np.array([], dtype=float)
    if _selection_counts is None or _selection_counts.shape[0] != n:
        _selection_counts = np.zeros(n, dtype=float)
        _total_rewards = np.zeros(n, dtype=float)
    feasible = bins_remain_cap >= item
    scores = np.full(n, -np.inf, dtype=float)
    if not np.any(feasible):
        return scores
    slack = bins_remain_cap[feasible] - item
    inv_slack = 1.0 / (slack + 1.0)
    penalty_weight = 0.05
    penalty = -penalty_weight * (slack ** 2)
    deterministic = inv_slack + penalty
    epsilon_initial, epsilon_min, decay_rate = 0.2, 0.01, 0.999
    epsilon = max(epsilon_min, epsilon_initial * (decay_rate ** _total_calls))
    random_part = epsilon * np.random.rand(slack.shape[0])
    base_score = deterministic + random_part
    avg_reward = np.zeros_like(base_score)
    mask = _selection_counts[feasible] > 0
    avg_reward[mask] = _total_rewards[feasible][mask] / _selection_counts[feasible][mask]
    reward_weight = 0.3
    combined = base_score + reward_weight * avg_reward
    temperature = 0.5
    exp_vals = np.exp(combined / temperature)
    softmax_vals = exp_vals / exp_vals.sum()
    scores[feasible] = softmax_vals
    best = int(np.argmax(scores))
    _total_calls += 1
    reward = - (bins_remain_cap[best] - item)
    _selection_counts[best] += 1
    _total_rewards[best] += reward
    return scores
```
