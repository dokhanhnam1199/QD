```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    if not hasattr(priority_v2, "initialized"):
        priority_v2.num_rules = 4
        priority_v2.sum_waste = np.zeros(priority_v2.num_rules, dtype=float)
        priority_v2.count = np.zeros(priority_v2.num_rules, dtype=int)
        priority_v2.step = 0
        priority_v2.epsilon = 1e-9
        priority_v2.initialized = True
    feasible = bins_remain_cap >= item
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)
    leftovers = bins_remain_cap - item
    best_fit_score = np.where(feasible, -leftovers, -np.inf)
    worst_fit_score = np.where(feasible, leftovers, -np.inf)
    indices = np.arange(bins_remain_cap.shape[0] if hasattr(bins_remain_cap, "shape") else len(bins_remain_cap))
    first_fit_score = np.where(feasible, -indices, -np.inf)
    target = bins_remain_cap.mean()
    fill_bal_score = np.where(feasible, -np.abs(leftovers - target), -np.inf)
    rule_scores = [best_fit_score, worst_fit_score, first_fit_score, fill_bal_score]
    waste_per_rule = np.empty(priority_v2.num_rules, dtype=float)
    for i, scores in enumerate(rule_scores):
        if not np.isfinite(scores).any():
            waste_per_rule[i] = np.inf
        else:
            idx = np.argmax(scores)
            waste_per_rule[i] = bins_remain_cap[idx] - item
    for i in range(priority_v2.num_rules):
        w = waste_per_rule[i]
        if np.isfinite(w):
            priority_v2.sum_waste[i] += w
            priority_v2.count[i] += 1
    avg_waste = np.where(priority_v2.count > 0, priority_v2.sum_waste / priority_v2.count, np.inf)
    inv = 1.0 / (avg_waste + priority_v2.epsilon)
    boost = np.zeros(priority_v2.num_rules, dtype=float)
    boost_idx = priority_v2.step % priority_v2.num_rules
    boost[boost_idx] = 1.0 / (priority_v2.step + 1)
    raw_weights = inv + boost
    total = raw_weights.sum()
    if total > 0:
        weights = raw_weights / total
    else:
        weights = np.full(priority_v2.num_rules, 1.0 / priority_v2.num_rules)
    combined_scores = np.zeros_like(bins_remain_cap, dtype=float)
    for w, scores in zip(weights, rule_scores):
        combined_scores += w * scores
    combined_scores[~feasible] = -np.inf
    priority_v2.step += 1
    return combined_scores
```
