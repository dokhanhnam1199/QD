```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin based on the Best‑Fit strategy.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Array of remaining capacities of each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores; higher scores correspond to better bins.
        Bins that cannot accommodate the item receive ``-np.inf``.
    """
    bins = np.asarray(bins_remain_cap, dtype=float)

    # Initialize all priorities to -inf (infeasible bins)
    priorities = np.full(bins.shape, -np.inf, dtype=float)

    # Determine which bins can accommodate the item
    can_fit = bins >= item

    if np.any(can_fit):
        # Slack left after placing the item
        slack = bins[can_fit] - item

        # Best‑fit: less slack -> higher priority. Use negative slack.
        # Add a deterministic, tiny jitter to break ties.
        jitter = np.arange(len(slack)) * 1e-9
        priorities[can_fit] = -slack + jitter

    return priorities
```
