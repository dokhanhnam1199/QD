{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function:\n    1. Decays the exploration probability (epsilon) over successive calls.\n    2. Ranks feasible bins by the smallest residual capacity after packing the call.\n    3. Adds a tiny random jitter to break ties without creating large bonuses.\n    4. Guarantees infeasible bins receive the lowest possible score.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin.  Higher scores indicate more desirable bins.\n    \"\"\"\n    # --------------------------------------------------------------------- #\n    # 1. Call counter & epsilon decay\n    # --------------------------------------------------------------------- #\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    priority_v2._call_counter += 1\n\n    # Base epsilon and decay schedule (1/sqrt(t)). Keep a floor to stay exploratory.\n    eps0 = 0.30\n    eps_min = 0.01\n    epsilon = max(eps_min, eps0 / np.sqrt(priority_v2._call_counter))\n\n    # --------------------------------------------------------------------- #\n    # 2. Identify feasible bins (allow a tiny tolerance for floating\u2011point)\n    # --------------------------------------------------------------------- #\n    tolerance = 1e-12\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    feasible = caps + tolerance >= item   # bool mask\n\n    # If nothing fits, return the lowest possible scores (caller may open a new bin).\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # --------------------------------------------------------------------- #\n    # 3. Exploitation: best\u2011fit (smallest residual)\n    # --------------------------------------------------------------------- #\n    residual = caps - item                 # could be negative for infeasible bins\n    exploit_score = np.full_like(caps, -np.inf, dtype=float)\n    # Use negative residual: larger (less negative) = tighter fit.\n    exploit_score[feasible] = -residual[feasible]\n\n    # Tiny jitter to break ties without inflating scores.\n    jitter_scale = 1e-9\n    jitter = jitter_scale * np.random.rand(np.count_nonzero(feasible))\n    exploit_score[feasible] += jitter\n\n    # --------------------------------------------------------------------- #\n    # 4. Exploration: uniform random noise for each bin\n    # --------------------------------------------------------------------- #\n    exploration_noise = np.random.rand(caps.shape[0])\n\n    # epsilon\u2011greedy combination\n    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise\n\n    # Ensure infeasible bins stay below any feasible candidate.\n    priorities[~feasible] = -np.inf\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem (BPP).\n\n    The heuristic favours bins that become tightly packed after placing the\n    item. It uses a logistic transform of the normalised slack, adaptive to the\n    current set of feasible bins, a large bonus for exact fits, deterministic\n    jitter for tie\u2011breaking, and an \u03b5\u2011greedy exploration strategy with a decaying\n    \u03b5.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n    step : int, optional\n        Number of items already processed; used to decay \u03b5. Default is 0.\n    epsilon0 : float, optional\n        Initial exploration probability. Default is 0.20.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default is 0.01.\n    alpha : float, optional\n        Steepness of the logistic curve. Larger values give a sharper transition.\n        Default is 10.0.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee their selection.\n        Default is 1e6.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons.\n        Default is 1e-12.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for the random numbers used in \u03b5\u2011greedy exploration.\n        Default is None (uses NumPy's default RNG).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Convert to a float64 NumPy array\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Initialise priority vector with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space (allow tolerance)\n    feasible = caps >= (item - tolerance)\n\n    if not feasible.any():\n        # No bin can accommodate the item\n        return priority\n\n    # Slack after placing the item (meaningful only for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection (|slack| <= tolerance)\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n\n    if non_exact.any():\n        # Representative capacity: largest remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        capacity_est = max(capacity_est, tolerance)  # avoid division by zero\n\n        # Normalised slack \u2208 [0, 1] (0 = perfect fit, 1 = empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n\n        # Fit quality: larger when slack is smaller\n        fit_quality = 1.0 - norm_slack  # 1 = perfect fit, 0 = empty bin\n\n        # Adaptive midpoint: median fit quality of current feasible set\n        median_fit = np.median(fit_quality)\n\n        # Logistic transform: tighter fits get scores > 0.5\n        logistic_arg = alpha * (fit_quality - median_fit)\n        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n        # Deterministic jitter based on bin index to break ties\n        idx = np.where(non_exact)[0]\n        jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration (decaying \u03b5)\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Exploration: assign uniform random scores to feasible non\u2011exact bins\n        rand_vals = rng.random(non_exact.sum())\n        priority[non_exact] = rand_vals\n        # Preserve exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority\n\n[Reflection]\nUse logistic scoring, exact\u2011fit bonuses, deterministic jitter, adaptive \u03b5; prioritize tight fits, normalize slack.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}