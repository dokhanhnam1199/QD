```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Worst‑Fit priority for online bin packing.

    The worst‑fit heuristic selects the bin with the largest remaining capacity
    that can still accommodate the incoming item.  This implementation returns
    a priority score for each bin: feasible bins receive a score proportional to
    their remaining capacity (higher is better) while infeasible bins receive a
    very low score so they are never selected.  A tiny random jitter is added
    to break ties in a deterministic‑yet‑non‑biased way.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities for each bin.

    Returns:
        A 1‑D NumPy array of priority scores, same shape as ``bins_remain_cap``.
    """
    # Ensure the output is a floating point array (to allow -inf)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Bins that can accommodate the item
    feasible = bins_remain_cap >= item

    # Base priority: the larger the remaining capacity, the higher the priority
    base_priority = bins_remain_cap[feasible]

    # Add a minuscule random jitter to avoid exact ties (e.g., identical capacities)
    jitter = np.random.uniform(low=0.0, high=1e-12, size=base_priority.shape)

    # Assign the computed priorities to feasible bins
    priorities[feasible] = base_priority + jitter

    return priorities
```
