```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Decaying epsilon‑greedy priority for the online Bin Packing Problem.

    The function prefers bins that will be tightly filled after placing the
    item (i.e., minimal residual capacity).  A small amount of random
    exploration is mixed in, with an exploration probability (epsilon) that
    decays as more items are processed.  Tie‑breaking jitter and a tiny bonus
    for exact fits are added to improve numerical stability without using
    large artificial bonuses.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` containing a priority
        score for each bin.  Higher scores indicate more preferable bins.
        Infeasible bins receive ``-np.inf``.
    """
    # ----- 0. Constants ---------------------------------------------------------
    TOL = 1e-12                 # tolerance for floating‑point comparisons
    JITTER_SCALE = 1e-9         # magnitude of tie‑breaking jitter
    EXACT_FIT_BONUS = 1e-6      # tiny bonus for (near) exact fits

    # ----- 1. Decaying epsilon --------------------------------------------------
    # Initialise static attributes on first call.
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    if not hasattr(priority_v2, "_start_epsilon"):
        priority_v2._start_epsilon = 0.3
    if not hasattr(priority_v2, "_min_epsilon"):
        priority_v2._min_epsilon = 0.01

    priority_v2._call_counter += 1
    epsilon = max(priority_v2._min_epsilon,
                  priority_v2._start_epsilon / np.sqrt(priority_v2._call_counter))

    # ----- 2. Feasibility mask --------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float)
    feasible = caps + TOL >= item          # allow a tiny tolerance

    # If no bin can accommodate the item, return -inf for all bins.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # ----- 3. Exploitation: best‑fit score --------------------------------------
    residual = caps - item                 # capacity that would remain
    # Higher score for smaller residual => negative residual.
    exploit_score = np.full_like(caps, -np.inf, dtype=float)
    exploit_score[feasible] = -residual[feasible]

    # Tiny jitter to break exact ties.
    jitter = np.random.rand(caps.shape[0]) * JITTER_SCALE
    exploit_score[feasible] += jitter[feasible]

    # Small bonus for (near) exact fits.
    exact_fit = np.isclose(residual, 0.0, atol=TOL)
    exploit_score[feasible & exact_fit] += EXACT_FIT_BONUS

    # ----- 4. Exploration: random noise -----------------------------------------
    exploration_noise = np.random.rand(caps.shape[0])

    # ----- 5. Combine exploitation and exploration -------------------------------
    priorities = np.full_like(caps, -np.inf, dtype=float)
    priorities[feasible] = ((1.0 - epsilon) * exploit_score[feasible] +
                           epsilon * exploration_noise[feasible])

    return priorities
```
