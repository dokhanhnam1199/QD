```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 1e-6,
    jitter_scale: float = 1e-9,
    base_alpha: float = 10.0,
    tol: float = 1e-12,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing setting.

    The heuristic prefers bins that become as full as possible after placing the
    item. Scores are based on an exponential decay of the normalized slack.
    Exact fits receive the maximal deterministic score of 1.0. A tiny ε‑greedy
    random term and a jitter term are added to encourage exploration and break
    ties deterministically.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon : float, optional
        Weight of the random ε‑greedy component (default 1e-6).
    jitter_scale : float, optional
        Scale of the uniform jitter added for tie‑breaking (default 1e-9).
    base_alpha : float, optional
        Base steepness for the exponential decay (default 10.0).
    tol : float, optional
        Numerical tolerance for feasibility and exact‑fit detection
        (default 1e-12).

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Infeasible bins receive ``-np.inf``.
    """
    # Convert to NumPy array of floats.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: empty input.
    if caps.size == 0:
        return np.array([], dtype=float)

    # Estimate the uniform bin capacity as the largest remaining capacity observed.
    # If all bins are partially filled, this approximates the capacity of the
    # least‑filled bin, which still provides a sensible scaling factor.
    capacity = np.max(caps)
    if capacity <= 0:
        # No capacity to place any item.
        return np.full_like(caps, -np.inf, dtype=float)

    # Feasibility mask: bins that can accommodate the item within tolerance.
    can_fit = caps >= item - tol

    # Initialise all priorities with -inf (infeasible).
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(can_fit):
        # No feasible bins.
        return priorities

    # Slack after placing the item in feasible bins.
    slack = caps[can_fit] - item

    # Normalised slack in [0, 1].
    slack_norm = slack / capacity

    # Adaptive decay factor: larger items use a steeper decay.
    # Adding a small constant ensures alpha > 0 even for tiny items.
    alpha = base_alpha * (item / capacity + 0.1)

    # Deterministic component: exponential decay of slack.
    # Exact fits (slack <= tol) get the maximal score of 1.0.
    exact_fit = slack <= tol
    deterministic_score = np.empty_like(slack, dtype=float)
    deterministic_score[exact_fit] = 1.0
    deterministic_score[~exact_fit] = np.exp(-alpha * slack_norm[~exact_fit])

    # ε‑greedy random component.
    random_score = np.random.rand(deterministic_score.shape[0])
    combined_score = (1.0 - epsilon) * deterministic_score + epsilon * random_score

    # Tiny jitter for deterministic tie‑breaking.
    jitter = np.random.uniform(-jitter_scale, jitter_scale, size=combined_score.shape)
    combined_score += jitter

    # Assign scores back to the feasible bins.
    priorities[can_fit] = combined_score

    return priorities
```
