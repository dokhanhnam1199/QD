```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    bin_capacity: float,
    eps: float = 1e-8,
    steepness: float = 1.0,
    use_sigmoid: bool = False,
) -> np.ndarray:
    """
    Compute a priority score for each bin for an online bin‑packing decision.

    Parameters
    ----------
    item : float
        Size of the item to pack.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each open bin.
    bin_capacity : float
        Fixed capacity of each bin. Must be > 0.
    eps : float, default 1e-8
        Tiny positive value used for deterministic tie‑breaking.
    steepness : float, default 1.0
        Steepness parameter for the sigmoid variant (ignored if use_sigmoid is False).
    use_sigmoid : bool, default False
        If True, the priority is based on a decreasing sigmoid of the slack ratio,
        otherwise a linear negative ratio is used.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. The bin with the highest score is chosen.
        Bins that cannot accommodate the item receive a score of -np.inf.

    Notes
    -----
    * Exact fits first (slack == 0 gives the highest priority).
    * Scores are based on the negative slack ratio (or sigmoid thereof).
    * Infeasible bins are pruned by assigning -np.inf.
    * A tiny deterministic offset `eps * index / N` breaks ties without
      introducing randomness.
    * The function is fully vectorized and works with NumPy arrays.
    """
    if bin_capacity <= 0:
        raise ValueError("bin_capacity must be positive")

    # Ensure a NumPy array
    caps = np.asarray(bins_remain_cap, dtype=float)
    if caps.ndim != 1:
        raise ValueError("bins_remain_cap must be a 1‑D array")

    # Feasibility mask
    can_fit = caps >= item

    # Compute slack and its normalized ratio
    slack = caps - item
    ratio = slack / bin_capacity

    # Raw priority based on chosen scoring method
    if use_sigmoid:
        # Decreasing sigmoid: priority = -1 / (1 + exp(steepness * ratio))
        #   ratio ∈ [0, 1], larger ratio => smaller priority
        priority = -1.0 / (1.0 + np.exp(steepness * ratio))
    else:
        # Linear negative ratio: exact fit (ratio 0) gives 0, others negative
        priority = -ratio

    # Deterministic tie‑breaking offset
    n = caps.size
    tie_break = eps * np.arange(n) / n
    priority = np.where(can_fit, priority + tie_break, -np.inf)

    return priority
```
