```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    - Exact fits (remaining capacity == item) receive the highest possible priority.
    - Among feasible bins, a best‑fit score (negative residual capacity) is used.
    - An epsilon‑greedy exploration term with a decaying epsilon adds minimal random jitter.
    - Infeasible bins are assigned -inf so they are never selected.
    - If no bin can accommodate the item, all scores are -inf (caller may open a new bin).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` with a priority score for each bin.
    """
    # --- 1. Decaying epsilon (epsilon‑greedy) ---
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    priority_v2._call_counter += 1

    _initial_epsilon = 0.3
    _min_epsilon = 0.01
    epsilon = max(_min_epsilon, _initial_epsilon / np.sqrt(priority_v2._call_counter))

    # --- 2. Prepare inputs ---
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Slack after hypothetically placing the item.
    slack = caps - item

    # Feasibility mask (allow tiny negative tolerance for floating‑point noise).
    feasible
    feasible = slack >= -1e-12

    # If no bin can hold the item, return -inf for all.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # --- 3. Exact‑fit detection ---
    exact_fit = feasible & np.isclose(slack, 0.0, atol=1e-12)

    # Initialize all priorities as -inf.
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Give exact fits an infinite priority (guaranteed selection).
    priorities[exact_fit] = np.inf

    # --- 4. Best‑fit score for non‑exact feasible bins ---
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        # Base score: negative residual capacity (smaller residual → larger score)
        # slack >= 0 ⇒ -slack <= 0.
        base_score = -slack[non_exact]

        # Small random jitter scaled by epsilon (symmetric around zero).
        jitter = (np.random.rand(base_score.size) - 0.5) * 2.0 * epsilon

        priorities[non_exact] = -np.inf
        priorities[non_exact] = base_score + jitter

    # Infeasible bins already have -inf.
    return priorities
```
