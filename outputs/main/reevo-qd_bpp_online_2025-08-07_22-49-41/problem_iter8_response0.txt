```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    The function:
    1. Decays the exploration probability (epsilon) over successive calls.
    2. Ranks feasible bins by the smallest residual capacity after packing the call.
    3. Adds a tiny random jitter to break ties without creating large bonuses.
    4. Guarantees infeasible bins receive the lowest possible score.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` containing a priority
        score for each bin.  Higher scores indicate more desirable bins.
    """
    # --------------------------------------------------------------------- #
    # 1. Call counter & epsilon decay
    # --------------------------------------------------------------------- #
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    priority_v2._call_counter += 1

    # Base epsilon and decay schedule (1/sqrt(t)). Keep a floor to stay exploratory.
    eps0 = 0.30
    eps_min = 0.01
    epsilon = max(eps_min, eps0 / np.sqrt(priority_v2._call_counter))

    # --------------------------------------------------------------------- #
    # 2. Identify feasible bins (allow a tiny tolerance for floating‑point)
    # --------------------------------------------------------------------- #
    tolerance = 1e-12
    caps = np.asarray(bins_remain_cap, dtype=float)
    feasible = caps + tolerance >= item   # bool mask

    # If nothing fits, return the lowest possible scores (caller may open a new bin).
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # --------------------------------------------------------------------- #
    # 3. Exploitation: best‑fit (smallest residual)
    # --------------------------------------------------------------------- #
    residual = caps - item                 # could be negative for infeasible bins
    exploit_score = np.full_like(caps, -np.inf, dtype=float)
    # Use negative residual: larger (less negative) = tighter fit.
    exploit_score[feasible] = -residual[feasible]

    # Tiny jitter to break ties without inflating scores.
    jitter_scale = 1e-9
    jitter = jitter_scale * np.random.rand(np.count_nonzero(feasible))
    exploit_score[feasible] += jitter

    # --------------------------------------------------------------------- #
    # 4. Exploration: uniform random noise for each bin
    # --------------------------------------------------------------------- #
    exploration_noise = np.random.rand(caps.shape[0])

    # epsilon‑greedy combination
    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise

    # Ensure infeasible bins stay below any feasible candidate.
    priorities[~feasible] = -np.inf

    return priorities
```
