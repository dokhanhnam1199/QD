```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Return priority scores for each bin according to Exact Fit First.

    - Bins that can hold the item exactly (remaining capacity == item) get the highest priority.
    - Bins that can hold the item with leftover get a priority inversely proportional to the leftover,
      favouring tighter fits.
    - Bins that cannot accommodate the item receive a very low priority (negative infinity).

    The bin with the highest priority (e.g., via np.argmax) will be chosen.
    """
    # Compute slack: remaining capacity after hypothetically placing the item
    slack = bins_remain_cap - item

    # Initialise all priorities as -inf (i.e., infeasible)
    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)

    # Mask of bins that can actually accommodate the item (slack >= 0)
    feasible_mask = slack >= 0

    # If no bin can hold the item, return the all -inf array
    if not np.any(feasible_mask):
        return priorities

    # Exact fit bins (slack effectively zero) receive infinite priority
    exact_mask = feasible_mask & np.isclose(slack, 0.0)
    priorities[exact_mask] = np.inf

    # For other feasible bins, use inverse slack to favour tighter fits
    non_exact_mask = feasible_mask & (~exact_mask)
    epsilon = 1e-12  # safeguard against division by zero (exact fits already handled)
    priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + epsilon)

    return priorities
```
