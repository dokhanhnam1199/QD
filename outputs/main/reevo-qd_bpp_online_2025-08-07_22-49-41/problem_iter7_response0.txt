```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                tolerance: float = 1e-12,
                epsilon: float = 0.0,
                exact_bonus: float = 1e6) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online Bin Packing
    Problem (BPP). The bin with the highest score will be chosen for the
    incoming *item*.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of all currently open bins.
    tolerance : float, optional
        Tolerance for floating‑point comparisons.
    epsilon : float, optional
        Exploration probability.  With probability ``epsilon`` the scores
        of non‑exact feasible bins are replaced by random values to
        encourage exploration.
    exact_bonus : float, optional
        Large constant added to exact‑fit bins to guarantee their
        selection.

    Returns
    -------
    np.ndarray
        Priority scores, one per bin.  Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: bin must have enough free space.
    feasible = caps >= item - tolerance

    # Initialize all priorities to -inf (ensures infeasible bins are never chosen)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # No feasible bin -> return all -inf
    if not feasible.any():
        return priority

    # Slack after placing the item (only meaningful for feasible bins)
    slack = caps - item

    # Exact‑fit detection
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Compute median slack of non‑exact feasible bins to set steepness
        median_slack = np.median(slack[non_exact])
        # Avoid division by zero; use a default steepness if median slack is tiny
        eps_for_alpha = 1e-12
        alpha = 1.0 / (median_slack + eps_for_alpha) if median_slack > eps_for_alpha else 10.0

        # Compute logistic score: 1/(1+exp(alpha * slack / capacity))
        # Use current remaining capacity as the “capacity” for scaling
        cap_non_exact = caps[non_exact]
        slack_non_exact = slack[non_exact]
        # Avoid overflow in exp by clipping
        exp_argument = alpha * slack_non_exact / cap_non_exact
        exp_argument = np.clip(exp_argument, -700, 700)
        logistic_score = 1.0 / (1.0 + np.exp(exp_argument))

        # Deterministic jitter for tie‑break: proportional to bin index
        indices_non_exact = np.nonzero(non_exact)[0]
        jitter = 1e-9 * indices_non_exact.astype(np.float64) / np.max(caps) if np.max(caps) > 0 else 1e-9 * indices_non_exact.astype(np.float64)
        priority[non_exact] = logistic_score + jitter

    # ε‑greedy exploration (optional)
    if epsilon > 0.0 and np.random.rand() < epsilon:
        # Random scores for all feasible non‑exact bins
        feasible_idx = np.nonzero(feasible)[0]
        rand_vals = np.random.rand(feasible_idx.size)
        priority[feasible_idx] = rand_vals
        # Reinstate exact‑fit bonus
        priority[exact_fit] = exact_bonus

    return priority
```
