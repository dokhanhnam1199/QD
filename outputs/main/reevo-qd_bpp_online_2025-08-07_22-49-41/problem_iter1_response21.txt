```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin according to the Best‑Fit strategy.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Array of remaining capacities of each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores; higher scores correspond to better bins.
    """
    # Initialise with -∞ for bins that cannot accommodate the item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins are actually usable
    can_fit = bins_remain_cap >= item

    if np.any(can_fit):
        # Slack left after placing the item
        slack = bins_remain_cap[can_fit] - item
        # Best-fit => least slack => highest (least negative) priority
        # Add a tiny deterministic jitter to break ties deterministically.
        jitter = np.linspace(0, 1e-8, np.count_nonzero(can_fit))
        priorities[can_fit] = -slack + jitter

    return priorities
```
