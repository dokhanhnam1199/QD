```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority of placing `item` into each bin using the Inverse Distance (Proximity Fit) strategy.

    A tighter fit (smaller leftover capacity after insertion) receives a higher priority.
    Bins that cannot accommodate the item are assigned -inf priority.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: 1‑D array with remaining capacity of each bin.

    Returns:
        np.ndarray of the same shape as `bins_remain_cap` with a priority score for each bin.
    """
    # Ensure we are working with a = np.ndarray of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Compute the leftover capacity if the item were placed in each bin
    leftover = caps - item

    # Feasibility mask: only bins with non‑negative leftover can host the item
    feasible = leftover >= 0

    # Small epsilon to avoid division by zero for perfect fits (leftover == 0)
    eps = 1e-12

    # Initialise priorities: infeasible bins get very low score
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Inverse distance: the smaller the leftover, the larger the priority
    priorities[feasible] = 1.0 / (leftover[feasible] + eps)

    # Optional bias toward already partially filled bins (encourages reuse):
    # Uncomment and adjust alpha if desired.
    # alpha = 0.1  # 0 = no bias, 1 = strong bias toward bins with larger fill level
    # filled_fraction = 1.0 - caps / caps.max()  # fraction of bin already filled
    # priorities[feasible] *= (1.0 + alpha * filled_fraction[feasible])

    return priorities
```
