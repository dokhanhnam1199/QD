```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon0: float = 0.20,
    decay: float = 0.001,
    smoothing: float = 1e-6,
) -> np.ndarray:
    """
    Adaptive epsilon‑greedy priority for the online Bin Packing Problem.

    Bins that would leave the smallest remaining capacity after the item is
    placed receive higher priority (inverse slack).  To avoid premature
    convergence, an exploration component is blended in with a decaying
    epsilon.  Infeasible bins are penalised with ``-inf`` so they are never
    selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon0 : float, optional
        Initial exploration probability (default 0.20).
    decay : float, optional
        Decay rate of epsilon per call (default 0.001). Larger values reduce
        exploration faster.
    smoothing : float, optional
        Small constant added to the slack term to avoid division by zero
        and to smooth the inverse‑slack calculation.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` containing the priority
        score for each bin.  Bins that cannot accommodate ``item`` receive
        ``-inf``.
    """
    # Convert input to a NumPy float array for consistent operations
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Initialise all priorities to -inf (infeasible by default)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Slack after placing the item
    slack = bins_remain_cap - item
    feasible_mask = slack >= 0

    # No feasible bin → return all -inf
    if not np.any(feasible_mask):
        return priorities

    # ------------------------------------------------------------------
    # Adaptive epsilon: decays over the number of calls to this
    # function.  The counter is stored as a function attribute.
    # ------------------------------------------------------------------
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    step = priority_v2._call_counter
    priority_v2._call_counter += 1

    epsilon = epsilon0 / (1.0 + decay * step)
    # Keep epsilon within [0, epsilon0] bounds
    epsilon = max(0.0, min(epsilon0, epsilon))

    # ------------------------------------------------------------------
    # Compute the exploitation component: inverse slack, normalised.
    # ------------------------------------------------------------------
    inv_slack = 1.0 / (1.0 + slack[feasible_mask] + smoothing)  # >0
    inv_slack_norm = inv_slack / inv_slack.sum()

    # ------------------------------------------------------------------
    # Compute the exploration component: random scores, normalised.
    # ------------------------------------------------------------------
    rand_scores = np.random.rand(np.count_nonzero(feasible_mask))
    rand_norm = rand_scores / rand_scores.sum()

    # ------------------------------------------------------------------
    # Blend exploitation and exploration.
    # ------------------------------------------------------------------
    combined = (1.0 - epsilon) * inv_slack_norm + epsilon * rand_norm

    # Assign combined priorities to feasible bins
    priorities[feasible_mask] = combined

    return priorities
```
