```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a Best‑Fit priority score for each bin.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Array of the same shape as *bins_remain_cap* containing a
        score for each bin. A bin that can accommodate the item
        receives a score proportional to the negative of its
        remaining space after placement, i.e. higher score
        indicates a smaller leftover and thus a better fit.
        Bins that cannot accommodate the item get a score of
        `-np.inf`, guaranteeing that they are never selected.
    """
    # Identify bins that can accept the new item
    can_fit = bins_remain_cap >= item

    # Compute priority: negative leftover for feasible bins,
    # very negative (infinite low) for infeasible bins.
    priorities = np.where(can_fit,
                          -(bins_remain_cap - item),  # smallest leftover -> largest score
                          -np.inf)

    # Optional: add a tiny noise to break ties randomly without affecting
    # the relative ordering (use small values so they don't mask differences)
    if can_fit.any():
        rng_noise = np.random.uniform(low=-1e-10, high=1e-10, size=priorities.shape)
        priorities += rng_noise * can_fit.astype(priorities.dtype)

    return priorities
```
