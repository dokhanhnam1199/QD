```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic best‑fit priority for the online Bin Packing Problem.

    For each currently open bin the function computes the residual capacity
    after (hypothetically) placing the incoming item.  The priority is the
    negative residual, so a tighter fit yields a larger priority.  Infeasible
    bins receive ``-inf`` to exclude them from selection.  A tiny deterministic
    epsilon term proportional to the bin's current remaining capacity breaks
    ties in favour of bins that are already more filled (i.e., have smaller
    remaining capacity).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each open bin.

    Returns
    -------
    np.ndarray
        Array of priority scores, one per bin.  The bin with the highest score
        (e.g., via ``np.argmax``) should be selected for the item.
    """
    # Ensure a 1‑D float array for consistent calculations.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Residual capacity after placing the item.
    residual = caps - item

    # Feasibility mask: True where the item fits.
    feasible = residual >= 0

    # Initialise priorities with -inf for infeasible bins.
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Core best‑fit priority: tighter fit ⇒ larger priority.
    # Using -residual makes the smallest (tightest) residual the highest value.
    base_priority = -residual[feasible]

    # Deterministic epsilon tie‑breaker: prefer bins that are already more filled.
    # Smaller remaining capacity (caps) yields a slightly higher priority.
    epsilon = 1e-6
    tie_breaker = -epsilon * caps[feasible]  # subtract to favour smaller caps

    priorities[feasible] = base_priority + tie_breaker

    return priorities
```
