```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, temperature: float = 0.1) -> np.ndarray:
    """
    Softmax-based priority for each bin: favour bins that leave the least waste after insertion.
    The function returns a non‑negative priority array; the bin with the highest value will be chosen.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of existing bins.
    temperature : float, optional
        Temperature for the softmax; smaller values make the heuristic more deterministic.
        Must be strictly positive.

    Returns
    -------
    np.ndarray
        Same shape as ``bins_remain_cap`` containing priority scores.
    """
    # Ensure we work with a float array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)

    # Compute the capacity left if we place the item
    remaining_after = bins_remain_cap - item

    # Masks for bins that can fit the item
    fit_mask = remaining_after >= 0

    # If no bin can accommodate the item, return zeros
    if not np.any(fit_mask):
        return np.zeros_like(bins_remain_cap)

    # Reward: we want minimal leftover -> use negative remaining as reward
    reward = np.where(fit_mask, -remaining_after, -np.inf)

    # For numerical stability we shift by the maximum reward among fitting bins
    max_reward = np.max(reward[fit_mask])
    # Ensure temperature is positive to avoid division by zero
    eps = 1e-12
    temperature = max(temperature, eps)

    # Softmax over the reward
    exp_scores = np.exp((reward - max_reward) / temperature)

    # Bins that cannot fit get zero priority
    exp_scores[~fit_mask] = 0.0

    return exp_scores
```
