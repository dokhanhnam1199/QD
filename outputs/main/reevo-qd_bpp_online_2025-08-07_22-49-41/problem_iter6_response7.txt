```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin in an online bin‑packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Higher scores indicate higher preference.
        Infeasible bins (remaining capacity < item) receive -np.inf.
    """
    # Ensure array and float dtype
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=np.float64)
    n_bins = bins_remain_cap.size

    # Default priorities for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=np.float64)

    if n_bins == 0:
        return priorities

    # Estimate true bin capacity from the largest remaining capacity seen so far
    capacity_est = np.max(bins_remain_cap)
    if capacity_est <= 0:
        # No capacity left to pack any item
        return priorities

    # Tolerance for floating‑point comparison
    tol = 1e-12

    # Feasibility mask
    can_fit = bins_remain_cap >= item - tol
    if not np.any(can_fit):
        return priorities

    # Slack after placing the item
    slack = bins_remain_cap[can_fit] - item
    # Clip tiny negative values caused by rounding
    slack = np.maximum(slack, 0.0)

    # Normalized slack in [0, 1]
    slack_norm = slack / capacity_est

    # Base steepness: larger items yield steeper decay
    base_alpha = 10.0
    alpha = base_alpha * (item / capacity_est + 0.1)

    # Deterministic score: exponential decay of normalized slack
    exact_fit = slack <= tol
    deterministic_score = np.empty_like(slack)
    deterministic_score[exact_fit] = 1.0
    deterministic_score[~exact_fit] = np.exp(-alpha * slack_norm[~exact_fit])

    # Tiny epsilon‑greedy exploration to avoid deterministic ties
    eps_greedy = 1e-6
    random_score = np.random.rand(deterministic_score.size)
    combined_score = (1.0 - eps_greedy) * deterministic_score + eps_greedy * random_score

    # Minimal jitter for stable tie‑breaking
    jitter = np.random.uniform(-1e-9, 1e-9, size=combined_score.shape)
    combined_score += jitter

    # Assign computed scores to the feasible bins
    priorities[can_fit] = combined_score

    return priorities
```
