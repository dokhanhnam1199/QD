```python
import numpy as np
from typing import Union, Optional

def priority_v2(item: float, bins_remain_cap: Union[np.ndarray, list, tuple], *,
                step: int = 0,
                epsilon0: float = 0.20,
                decay_rate: float = 0.01,
                alpha: float = 10.0,
                exact_bonus: float = 1e9,
                tolerance: float = 1e-12,
                jitter_scale: float = 1e-9,
                random_state: Optional[Union[int, np.random.Generator]] = None
                ) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    The priority score is a combination of:
      • An exact‑fit bonus for bins that match the item size within a tolerance.
      • A logistic transform of the normalised slack (tight fit yields higher score).
      • A deterministic jitter based on the bin index to break ties.
      • An ε‑greedy exploration term with a decaying ε.

    Infeasible bins receive a priority of -∞ and are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like
        Remaining capacities of the currently open bins.
    step : int, optional
        Number of items processed so far (used for ε decay). Default ``0``.
    epsilon0 : float, optional
        Initial exploration probability. Default ``0.20``.
    decay_rate : float, optional
        Decay factor for ε (ε = ε₀ / (1 + decay_rate * step)). Default ``0.01``.
    alpha : float, optional
        Steepness of the logistic curve. Default ``10.0``.
    exact_bonus : float, optional
        Bonus added to exact‑fit bins to guarantee selection. Default ``1e9``.
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons. Default ``1e-12``.
    jitter_scale : float, optional
        Scale of deterministic jitter for tie‑breaking. Default ``1e-9``.
    random_state : int | np.random.Generator | None, optional
        Seed or generator for random numbers (used for exploration). Default ``None``.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    # Ensure the capacities are a NumPy array of type float64
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility: bin must have enough free space
    feasible = caps >= (item - tolerance)

    # Initialize priority with -∞ for all bins
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # If no bin can accommodate the item, return immediately
    if not feasible.any():
        return priority

    # Slack after placing the item (only meaningful for feasible bins)
    slack = caps - item

    # Detect exact fits within the tolerance
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Normalise slack: use the maximum remaining capacity among feasible bins
        # to obtain a dimensionless slack in [0, 1]
        cap_max = caps[feasible].max()
        # Guard against division by zero
        cap_max = max(cap_max, 1e-12)

        norm_slack = slack[non_exact] / cap_max
        norm_slack = np.clip(norm_slack, 0.0, 1.0)

        # Fit score: higher for tighter fit
        fit_score = 1.0 - norm_slack

        # Median pivot for logistic transform
        median_fit = np.median(fit_score)

        # Logistic transform with overflow protection
        arg = alpha * (fit_score - median_fit)
        arg = np.clip(arg, -50.0, 50.0)  # exp overflow protection
        logistic_score = 1.0 / (1.0 + np.exp(-arg))

        # Deterministic jitter based on bin index
        idx_non_exact = np.where(non_exact)[0]
        jitter = jitter_scale * (idx_non_exact.astype(np.float64) / (len(caps) + 1.0))

        priority[non_exact] = logistic_score + jitter

    # ε‑greedy exploration with decaying ε
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    # Initialise RNG
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    if rng.random() < epsilon:
        # Random scores for all feasible bins (uniform in [0, 1))
        rand_vals = rng.random(feasible.sum())
        priority[feasible] = rand_vals
        # Preserve the exact‑fit bonus
        priority[exact_fit] = exact_bonus

    return priority
```
