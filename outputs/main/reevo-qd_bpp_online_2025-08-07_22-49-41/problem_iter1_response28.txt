```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Epsilon‑greedy priority for the online Bin Packing Problem.

    The function favours the *best‑fit* bin (the one that leaves the smallest
    residual capacity after the item is placed) while occasionally exploring
    other feasible bins.  The exploration probability (epsilon) decays with
    the number of decisions made, making the algorithm increasingly greedy.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` with a priority score for
        each bin.  The bin with the highest score should be selected.
    """
    # ----- 1. Manage a decaying epsilon -----------------------------------------
    # Attach a call counter to the function object for epsilon decay.
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    priority_v2._call_counter += 1

    # Start with epsilon = 0.3 and shrink roughly as 1/sqrt(t)
    epsilon = max(0.01, 0.3 / np.sqrt(priority_v2._call_counter))

    # ----- 2. Identify feasible bins --------------------------------------------
    feasible = bins_remain_cap >= item                     # bool mask
    if not np.any(feasible):
        # Nothing fits; caller may decide to open a new bin.
        return np.zeros_like(bins_remain_cap, dtype=float)

    # ----- 3. Exploitation: Best‑Fit score ---------------------------------------
    # Residual capacity that would remain after packing the item.
    residual = bins_remain_cap - item                       # shape == bins_remain_cap
    # Higher score for tighter fit (i.e., smaller residual). Use negative residual.
    exploit_score = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    exploit_score[feasible] = -residual[feasible]

    # ----- 4. Exploration: Random noise -----------------------------------------
    # Uniform random noise in [0,1) for each bin.
    exploration_noise = np.random.rand(bins_remain_cap.shape[0])

    # ----- 5. Combine exploitation and exploration -------------------------------
    # Weighted sum: (1‑ε) * exploit + ε * exploration
    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise

    # Infeasible bins must stay below any feasible candidate.
    priorities[~feasible] = -np.inf

    return priorities
```
