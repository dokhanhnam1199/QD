```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Best‑Fit priority for the online Bin Packing Problem.

    For each bin we compute the leftover capacity after (hypothetically) placing the item.
    - If the item fits, the priority is the negative leftover (larger ⇒ smaller leftover).
    - If it does not fit, the bin receives a large negative penalty to exclude it.
    An epsilon term based on the current fill level breaks ties in favour of the more
    already‑filled bin, which is a common heuristic refinement.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of the remaining capacity of each bin.

    Returns:
        A 1‑D array of priority scores (same shape as `bins_remain_cap`).
    """
    # Ensure we work with a float array for precision.
    caps = bins_remain_cap.astype(float)

    # Remaining capacity if we were to put the item into each bin.
    residual = caps - item

    # Feasibility mask: True where the item fits.
    feasible = residual >= 0

    # Large negative constant to disqualify infeasible bins.
    penalty = -1e9
    priorities = np.full_like(caps, penalty, dtype=float)

    # Best‑Fit core: higher score for smaller residual (i.e., tighter fit).
    # Using negative residual makes the smallest residual the largest priority.
    priorities[feasible] = -residual[feasible]

    # Tie‑breaker: prefer bins that are already more filled (i.e., have smaller original cap).
    # Adding a tiny epsilon proportional to the current remaining capacity flips ties.
    epsilon = 1e-6
    priorities[feasible] += epsilon * caps[feasible]

    return priorities
```
