```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic priority function for the online bin‑packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array (float) with the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Bins that cannot accommodate
        the item receive a score of 0. The scores are constructed so that:
        * Exact fits (remaining capacity ≈ 0) obtain the maximum priority.
        * Among non‑exact feasible bins, those with the smallest slack (tightest fit)
          receive higher priority, using a normalized slack and a sigmoid transform.
        * Tie‑breaking is deterministic: lower‑index bins are favoured when scores
          are otherwise equal.
    """
    # ------------------- Configuration ------------------------------------
    tolerance = 1e-12       # tolerance for floating‑point exact‑fit detection
    alpha = 12.0            # steepness of the sigmoid transform
    mid_point = 0.5         # centre of the sigmoid (fit_score in [0, 1])
    epsilon_tie = 1e-12     # deterministic tie‑break term (scaled by bin index)
    # ---------------------------------------------------------------------

    # Ensure a NumPy array of float64
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Initialise priorities to zero (infeasible bins stay at zero)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # Feasibility mask: bin can accommodate the item (allowing a tiny tolerance)
    feasible = caps + tolerance >= item
    if not np.any(feasible):
        return priorities

    # Indices of feasible bins
    idx_feas = np.where(feasible)[0]

    # Slack after placing the item
    slack = caps[feasible] - item

    # Detect exact fits (slack within tolerance)
    exact_mask = np.abs(slack) <= tolerance
    idx_exact = idx_feas[exact_mask]

    # Assign maximum priority to exact fits, with deterministic tie‑break
    if idx_exact.size > 0:
        priorities[idx_exact] = 1.0 - epsilon_tie * idx_exact.astype(np.float64)

    # Non‑exact feasible bins
    non_exact_mask = ~exact_mask
    if np.any(non_exact_mask):
        idx_non = idx_feas[non_exact_mask]
        slack_non = slack[non_exact_mask]

        # Normalise slack by the largest slack among non‑exact bins
        max_slack = np.max(slack_non)
        if max_slack <= 0:
            # Numerical safeguard: treat as exact fits
            priorities[idx_non] = 1.0 - epsilon_tie * idx_non.astype(np.float64)
        else:
            norm_slack = slack_non / max_slack               # values in (0, 1]
            fit_score = 1.0 - norm_slack                      # larger = tighter fit

            # Sigmoid transform to sharpen preference for tighter fits
            sigmoid_arg = alpha * (fit_score - mid_point)
            sigmoid = 1.0 / (1.0 + np.exp(-sigmoid_arg))      # range ≈ (0, 1)

            # Apply deterministic tie‑break
            priorities[idx_non] = sigmoid - epsilon_tie * idx_non.astype(np.float64)

    return priorities
```
