```python
import numpy as np
from typing import Optional, Union

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha0: float = 10.0,
    alpha_decay: float = 0.0,
    slack_decay_beta: float = 0.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing Problem (BPP).

    The heuristic favours bins that become tightly packed after placing the
    item. It uses a logistic transform of the normalised slack relative to
    the largest remaining capacity among feasible bins, an exponential
    slack‑decay factor for tighter fits, a large bonus for exact fits, a
    deterministic jitter for tie‑breaking, and a decaying ε‑greedy exploration
    strategy.  Feasible bins are those that can accommodate the incoming
    item (within a tolerance).  Infeasible bins receive ``-np.inf``.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each currently open bin.
    step : int, optional
        Number of items already processed; used to decay ε. Default is 0.
    epsilon0 : float, optional
        Initial exploration probability. Default is 0.20.
    decay_rate : float, optional
        Decay factor for ε (ε = ε₀ / (1 + decay_rate * step)). Default is 0.01.
    alpha0 : float, optional
        Base steepness of the logistic curve. Default is 10.0.
    alpha_decay : float, optional
        Decay factor for α (α = α₀ / (1 + alpha_decay * step)). Default is 0.0.
    slack_decay_beta : float, optional
        Exponential slack‑decay coefficient; larger values penalise slack
        more heavily. Default is 0.0 (no additional decay).
    exact_bonus : float, optional
        Bonus added to exact‑fit bins to guarantee their selection.
        Default is 1e6.
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons.
        Default is 1e-12.
    random_state : int | np.random.Generator | None, optional
        Seed or generator for the random numbers used in ε‑greedy exploration.
        Default is None (uses NumPy's default RNG).

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=np.float64)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # Feasibility check
    feasible = caps >= (item - tolerance)
    if not feasible.any():
        return priority

    # Slack after placing the item
    slack = caps - item
    # Exact fit detection
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit
    if not non_exact.any():
        return priority

    # Normalise slack by the largest remaining capacity among feasible bins
    capacity_est = caps[feasible].max()
    capacity_est = max(capacity_est, tolerance)
    norm_slack = slack[non_exact] / capacity_est

    # Median of normalised slack for adaptive threshold
    median_norm_slack = np.median(slack[feasible] / capacity_est)

    # Logistic score favouring tighter fits
    alpha = alpha0 / (1.0 + alpha_decay * step) if alpha_decay else alpha0
    logistic_arg = alpha * (median_norm_slack - norm_slack)
    logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

    # Exponential slack decay for additional tightness penalty
    if slack_decay_beta > 0.0:
        logistic_score *= np.exp(-slack_decay_beta * norm_slack)

    # Deterministic jitter to break ties
    idx = np.where(non_exact)[0]
    jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))
    priority[non_exact] = logistic_score + jitter

    # ε‑greedy exploration with decaying ε
    epsilon = epsilon0 / (1.0 + decay_rate * step)
    rng = random_state if isinstance(random_state, np.random.Generator) else np.random.default_rng(random_state)
    if rng.random() < epsilon:
        rand_vals = rng.random(non_exact.sum())
        priority[non_exact] = rand_vals
        priority[exact_fit] = exact_bonus

    return priority
```
