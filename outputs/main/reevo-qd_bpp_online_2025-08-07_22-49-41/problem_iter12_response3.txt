```python
import numpy as np
from typing import Union

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha: float = 10.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    random_state: Union[int, np.random.Generator, None] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    The returned priority array can be used to select the bin with the highest
    score for the incoming ``item``.  The scoring combines several heuristics:

    * **Exact‑fit reward** – bins that would be perfectly filled receive a large
      constant ``exact_bonus``.
    * **Fit tightness** – for non‑exact feasible bins, slack is normalised by the
      maximum remaining capacity among all feasible bins and transformed with a
      logistic function.  The logistic midpoint adapts to the median fit score
      of the current feasible set.
    * **Deterministic jitter** – a tiny index‑based term breaks ties in a
      reproducible way.
    * **ε‑greedy exploration** – with a decaying probability
      ``ε = ε₀ / (1 + decay_rate * step)`` the scores of non‑exact feasible bins
      are replaced by random values, encouraging exploration early on.
    * **Infeasible bins** – receive ``-np.inf`` and can never be selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    step : int, optional
        Number of items processed so far (used for ε decay). Default is ``0``.
    epsilon0 : float, optional
        Initial exploration probability. Default is ``0.20``.
    decay_rate : float, optional
        Decay factor for ε. Default is ``0.01``.
    alpha : float, optional
        Steepness of the logistic curve. Default is ``10.0``.
    # higher values make the logistic sharper.
    exact_bonus : float, optional
        Bonus added to exact‑fit bins to guarantee their selection.
        Default is ``1e6``.
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons.
        Default is ``1e-12``.
    random_state : int | np.random.Generator | None, optional
        Seed or generator for random numbers (used for exploration).
        Default is ``None``.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins have ``-np.inf``.
    """
    # --------------------------------------------------------------------- #
    # 1. Prepare data ------------------------------------------------------ #
    # --------------------------------------------------------------------- #
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: bin must have enough space for the item (allowing tolerance)
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # Early exit if no bin can accommodate the item
    if not feasible.any():
        return priorities

    # --------------------------------------------------------------------- #
    # 2. Compute slack and identify exact fits ---------------------------- #
    # --------------------------------------------------------------------- #
    slack = caps - item

    # Exact fit detection (|slack| <= tolerance)
    exact_fit = np.abs(slack) <= tolerance
    priorities[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit

    # --------------------------------------------------------------------- #
    # 3. Score non‑exact feasible bins ------------------------------------- #
    # --------------------------------------------------------------------- #
    if non_exact.any():
        # Normalise slack by the largest remaining capacity among feasible bins
        max_cap = caps[feasible].max()
        max_cap = max(max_cap, tolerance)  # avoid division by zero

        norm_slack = slack[non_exact] / max_cap           # in [0, 1] roughly
        fit_score = 1.0 - norm_slack                       # tighter fit → larger

        # Adaptive logistic transform: median fit_score is the midpoint
        median_fit = np.median(fit_score)
        logistic_arg = alpha * (fit_score - median_fit)

        # Clip to avoid overflow in exp()
        logistic_arg = np.clip(logistic_arg, -np.inf, np.inf)
        logistic_arg = np.clip(logistic_arg, -50, 50)      # safe range for exp

        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Deterministic jitter to break ties (tiny, index‑based)
        idx_non_exact = np.nonzero(non_exact)[0]
        jitter = 1e-12 * (idx_non_exact / (len(caps) + 1.0))

        priorities[non_exact] = logistic_score + jitter

    # --------------------------------------------------------------------- #
    # 4. ε‑greedy exploration ------------------------------------------------ #
    # --------------------------------------------------------------------- #
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    # Resolve RNG (allow seed, Generator, or default)
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    if rng.random() < epsilon and non_exact.any():
        # Replace non‑exact feasible scores with uniform random values
        random_scores = rng.random(non_exact.sum())
        priorities[non_exact] = random_scores
        # Preserve exact‑fit bonuses (they should dominate)
        priorities[np.isinf(priorities)] = -np.inf  # sanity (should already hold)

    return priorities
```
