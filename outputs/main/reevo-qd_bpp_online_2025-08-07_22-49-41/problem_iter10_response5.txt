```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin packing setting.

    The heuristic prefers bins that will be near full after placing the item.
    It normalises the slack (remaining capacity after placement) by the bin
    capacity and applies an exponential decay. Exact fits receive the maximum
    score. A tiny ε‑greedy exploration term and a jitter are added for
    robustness and deterministic tie‑breaking.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Bins that cannot
        accommodate the item receive ``-np.inf``.
    """
    # Guard against empty input
    if bins_remain_cap.size == 0:
        return np.empty(0, dtype=float)

    # Ensure a floating‑point view
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Infer nominal bin capacity (maximum observed remaining capacity)
    capacity = np.max(caps)
    if capacity <= 0.0:
        # No capacity left anywhere
        return np.full_like(caps, -np.inf, dtype=float)

    # Tolerance for floating‑point comparisons
    TOL = 1e-12

    # Feasibility mask: bins that can accommodate the item (allow small tolerance)
    can_fit = caps + TOL >= item
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(can_fit):
        return priorities

    # Slack after placing the item (only for feasible bins)
    slack = caps[can_fit] - item

    # Normalised slack in [0, 1]
    slack_norm = np.clip(slack / capacity, 0.0, 1.0)

    # Adaptive steepness: larger items → steeper decay
    BASE_ALPHA = 10.0
    alpha = BASE_ALPHA * (item / capacity + 0.1)  # ensure >0

    # Exact‑fit detection
    exact_fit = slack <= TOL

    # Deterministic component: exponential decay of normalised slack
    deterministic_score = np.where(
        exact_fit,
        1.0,                     # perfect score for exact fits
        np.exp(-alpha * slack_norm)
    )

    # ε‑greedy exploration: mix a tiny random component
    EPSILON = 1e-6
    random_score = np.random.rand(deterministic_score.shape[0])
    mixed_score = (1.0 - EPSILON) * deterministic_score + EPSILON * random_score

    # Tiny jitter for deterministic tie‑breaking
    JITTER_SCALE = 1e-9
    jitter = np.random.uniform(-JITTER_SCALE, JITTER_SCALE, size=mixed_score.shape)
    final_score = mixed_score + jitter

    # Assign scores back to the original ordering
    priorities[can_fit] = final_score

    return priorities
```
