[
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing the Almost Full Fit heuristic.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin.  Higher priority means the bin is\n        chosen first.  For bins that cannot accommodate the item the\n        priority is set to -np.inf.\n\n    Notes\n    -----\n    In the almost full fit strategy we prefer bins that will be\n    almost filled after adding the item.  For a bin that can fit the\n    item, the \"after packing remaining capacity\" is computed as\n    `bins_remain_cap - item`.  The smaller this residual is, the higher\n    the priority.  The implementation translates this to a score of\n    `-(bins_remain_cap - item)`, so that a residual of 0 (perfect fit)\n    gives a score of 0, a residual of 0.2 gives -0.2, etc.  The\n    largest score is selected.\n    \"\"\"\n    # Safe boolean mask for feasible bins\n    can_fit = bins_remain_cap >= item\n    # Compute negative remaining after packing for applicable bins\n    # Unused bins get negative infinity to discourage selection.\n    priorities = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, higher values indicate higher preference.\n        Feasible bins have priority >= 0; infeasible bins receive -np.inf.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    slack = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return priorities\n\n    # Exact fit bins: slack effectively zero\n    exact_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    priorities[exact_mask] = np.inf\n\n    # Non-exact feasible bins: inverse slack to favor tighter fits\n    non_exact_mask = feasible & ~exact_mask\n    if np.any(non_exact_mask):\n        eps = 1e-12\n        priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + eps)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for the online Bin Packing Problem.\n\n    For each bin we compute the leftover capacity after (hypothetically) placing the item.\n    - If the item fits, the priority is the negative leftover (larger \u21d2 smaller leftover).\n    - If it does not fit, the bin receives a large negative penalty to exclude it.\n    An epsilon term based on the current fill level breaks ties in favour of the more\n    already\u2011filled bin, which is a common heuristic refinement.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacity of each bin.\n\n    Returns:\n        A 1\u2011D array of priority scores (same shape as `bins_remain_cap`).\n    \"\"\"\n    # Ensure we work with a float array for precision.\n    caps = bins_remain_cap.astype(float)\n\n    # Remaining capacity if we were to put the item into each bin.\n    residual = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = residual >= 0\n\n    # Large negative constant to disqualify infeasible bins.\n    penalty = -1e9\n    priorities = np.full_like(caps, penalty, dtype=float)\n\n    # Best\u2011Fit core: higher score for smaller residual (i.e., tighter fit).\n    # Using negative residual makes the smallest residual the largest priority.\n    priorities[feasible] = -residual[feasible]\n\n    # Tie\u2011breaker: prefer bins that are already more filled (i.e., have smaller original cap).\n    # Adding a tiny epsilon proportional to the current remaining capacity flips ties.\n    epsilon = 1e-6\n    priorities[feasible] += epsilon * caps[feasible]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for each bin according to Exact Fit First.\n\n    - Bins that can hold the item exactly (remaining capacity == item) get the highest priority.\n    - Bins that can hold the item with leftover get a priority inversely proportional to the leftover,\n      favouring tighter fits.\n    - Bins that cannot accommodate the item receive a very low priority (negative infinity).\n\n    The bin with the highest priority (e.g., via np.argmax) will be chosen.\n    \"\"\"\n    # Compute slack: remaining capacity after hypothetically placing the item\n    slack = bins_remain_cap - item\n\n    # Initialise all priorities as -inf (i.e., infeasible)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n\n    # Mask of bins that can actually accommodate the item (slack >= 0)\n    feasible_mask = slack >= 0\n\n    # If no bin can hold the item, return the all -inf array\n    if not np.any(feasible_mask):\n        return priorities\n\n    # Exact fit bins (slack effectively zero) receive infinite priority\n    exact_mask = feasible_mask & np.isclose(slack, 0.0)\n    priorities[exact_mask] = np.inf\n\n    # For other feasible bins, use inverse slack to favour tighter fits\n    non_exact_mask = feasible_mask & (~exact_mask)\n    epsilon = 1e-12  # safeguard against division by zero (exact fits already handled)\n    priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + epsilon)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority with Inverse Distance (Proximity Fit) strategy.\n\n    Bins that will have the smallest remaining capacity *after* the item is placed\n    receive the highest priority.  Inverse distance (1/(1+slack)) is used to\n    accentuate bins whose slack is close to zero.  Bins that cannot accommodate\n    the item are given a negative priority of -inf, ensuring they are never\n    selected.\n\n    Args:\n        item: Size of the item to be added.\n        bins_remain_cap: 1\u2011D array of remaining capacities of existing bins.\n\n    Returns:\n        A NumPy array of the same shape as `bins_remain_cap`, containing\n        the priority score for each bin.\n    \"\"\"\n    # Slack: remaining capacity after adding the item\n    slack = bins_remain_cap - item\n    # Boolean mask of bins that can accommodate the item\n    mask = slack >= 0\n\n    # If no bin can fit, return -inf for all bins\n    if not np.any(mask):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Priority: larger when slack is smaller\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Avoid division by zero by adding 1\n    priorities[mask] = 1.0 / (1.0 + slack[mask])\n\n    # For bins that cannot accommodate the item, set a large negative value\n    priorities[~mask] = -np.inf\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact\u2011Fit\u2011First priority for the online Bin Packing Problem.\n\n    A bin that can accommodate the item *exactly* receives the highest score.\n    Among the feasible bins, those that leave the smallest leftover capacity are\n    preferred.  Bins that cannot hold the item are assigned a very low priority.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of the current bins.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.  The bin with the highest score will be\n        selected for placement.\n    \"\"\"\n    # Ensure floating\u2011point arithmetic.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after hypothetically placing the item.\n    # Positive => feasible; negative => infeasible.\n    leftover = caps - item\n\n    # Initialise all priorities to a very low value (infeasible).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Mask of feasible bins.\n    feasible = leftover >= 0\n\n    # Exact fits (leftover == 0) should outrank any other feasible bin.\n    # Use -leftover as the base priority: exact fits get 0, others get a negative value.\n    # Since we pick the highest priority, 0 > any negative, achieving Exact\u2011Fit\u2011First.\n    priorities[feasible] = -leftover[feasible]\n\n    # Optional tweak: if you prefer a strictly larger value for exact fits\n    # (e.g., to avoid ties caused by floating\u2011point noise), you can add a tiny\n    # epsilon or set them to a large constant:\n    # exact_fit = np.isclose(leftover, 0, atol=1e-12)\n    # priorities[exact_fit] = np.inf\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return a priority score for each bin using an \u03b5\u2011greedy strategy.\n    The algorithm mixes a greedy best\u2011fit rule with random exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as `bins_remain_cap` containing the\n        priority of each bin.  The bin with the highest value will be chosen.\n    \"\"\"\n    n_bins = bins_remain_cap.size\n\n    # Base priority vector: assign -\u221e to all bins initially.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        # No bins available \u2013 the calling procedure should handle this\n        # by opening a new bin.  Returning an empty array keeps the API\n        # consistent with the input shape.\n        return priorities\n\n    # Determine which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # If no bin can fit the item, no viable actions.  Priorities stay -\u221e.\n    if not can_fit.any():\n        return priorities\n\n    # ----------------- Greedy component: Best\u2011fit heuristic -------------\n    # For feasible bins compute a score proportional to how full the bin\n    # would become after placing the item (smallest leftover \u2192 highest priority).\n    leftover = bins_remain_cap - item            # Remaining capacity after insertion\n    greedy_scores = -leftover                    # We invert so that smaller leftover => higher value\n    greedy_scores[~can_fit] = -np.inf            # Exclude infeasible bins\n\n    # ----------------- Random component: Exploration --------------------\n    # Probability of exploring a random feasible bin\n    # Decaying epsilon: encourages exploration early and exploitation later.\n    epsilon = max(0.01, min(0.3, 0.2 / np.sqrt(n_bins)))\n\n    if np.random.rand() < epsilon:\n        # Exploration: pick a random feasible bin and give it a very high priority.\n        random_idx = np.random.choice(np.where(can_fit)[0])\n        # Assign a large positive value that guarantees selection.\n        priorities = np.full(n_bins, -np.inf, dtype=float)\n        priorities[random_idx] = 1.0\n    else:\n        # Exploitation: use the best\u2011fit scores\n        priorities = greedy_scores\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute bin priorities using a Sigmoid Fit Score strategy.\n\n    The priority is based on the residual space after inserting the item\n    into a bin.  Bins that leave almost no slack (i.e., perfect fit)\n    obtain the highest score.  The decay of the score is governed by a\n    sigmoid (logistic) function over the relative residual\n    `r = (remaining - item) / remaining`.\n\n    Bins that cannot accommodate the item receive a very low priority\n    (``-np.inf``) so that they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the candidate bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores in the range [0, 1], with 1 corresponding to a perfect fit.\n    \"\"\"\n    # Ensure we work on a NumPy array of floats\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Bin can hold the item?\n    fits = bins >= item\n\n    # Residual space if item fits\n    residual = bins - item\n\n    # Relative residual: 0 when perfect fit, increasing with slack\n    rel_residual = np.zeros_like(bins)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        rel_residual = np.where(\n            fits & (bins > 0),\n            residual / bins,\n            0.0\n        )\n\n    # Sigmoid decay parameter \u2013 steeper values emphasize tight fits.\n    alpha = 10.0\n    scores = np.where(\n        fits,\n        1.0 / (1.0 + np.exp(alpha * rel_residual)),\n        -np.inf   # unfit bins get minimal score\n    )\n\n    # Scale to [0, 1] so perfect fit yields 1.0\n    scores *= 2.0\n    np.clip(scores, 0.0, 1.0, out=scores)\n\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin according to the Best\u2011Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; higher scores correspond to better bins.\n    \"\"\"\n    # Initialise with -\u221e for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins are actually usable\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Slack left after placing the item\n        slack = bins_remain_cap[can_fit] - item\n        # Best-fit => least slack => highest (least negative) priority\n        # Add a tiny deterministic jitter to break ties deterministically.\n        jitter = np.linspace(0, 1e-8, np.count_nonzero(can_fit))\n        priorities[can_fit] = -slack + jitter\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Sigmoid Fit Score priority for online Bin Packing.\n\n    For each currently open bin we compute a smooth priority that favours\n    *tight* fits (i.e., small remaining slack after placing the item).  The\n    raw slack is transformed by a logistic (sigmoid) function, producing a\n    value in ``[0, 1]`` \u2013 higher values indicate a more attractive bin.\n    Bins that cannot accommodate the item receive a priority of ``0``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. The bin with the highest score should be\n        selected for the item.\n    \"\"\"\n    # Convert to a NumPy array for vectorised work.\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # 1) Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n\n    #  (Will be overwritten with actual priorities later.)\n    priority = np.zeros_like(caps, dtype=np.float64)\n\n    if not feasible.any():\n        # No bin can accept the item \u2013 return all zeros.\n        return priority\n\n    # ------------------------------------------------------------------\n    # 2) Compute slack (remaining capacity after placing the item) for\n    #    feasible bins only.\n    # ------------------------------------------------------------------\n    slack = np.empty_like(caps)\n    slack[:] = np.nan\n    slack[feasible] = caps[feasible] - item\n\n    # ------------------------------------------------------------------\n    # 3) Estimate the (fixed) bin capacity.\n    #    All bins share the same total capacity C; the current maximum\n    #    remaining capacity is a safe estimator for C.\n    # ------------------------------------------------------------------\n    capacity_est = caps.max() if caps.size > 0 else 1.0\n    capacity_est = max(capacity_est, 1e-12)      # protect against division by zero\n\n    # ------------------------------------------------------------------\n    # 4) Normalise the slack to [0, 1] (0 = perfect fit, 1 = empty bin).\n    # ------------------------------------------------------------------\n    norm_slack = slack / capacity_est\n\n    # ------------------------------------------------------------------\n    # 5) Compute a \u201cfit score\u201d that is large when slack is small.\n    #    fit_score = 1 - norm_slack \u2208 [0, 1]  (1 = perfect fit).\n    # ------------------------------------------------------------------\n    fit_score = 1.0 - norm_slack\n\n    # ------------------------------------------------------------------\n    # 6) Apply a sigmoid to the fit score.\n    #\n    #    priority = 1 / (1 + exp(-\u03b1\u00b7(fit_score - mid_point)))\n    #\n    #    * \u03b1  \u2013 steepness (larger \u21d2 sharper distinction between tight\n    #            and loose fits).\n    #    * mid_point \u2013 sigmoid centre (fit_score at which priority = 0.5).\n    # ------------------------------------------------------------------\n    alpha = 12.0        # controls how aggressively we prefer tight fits\n    mid_point = 0.5    # centre of the logistic curve\n\n    sigmoid_arg = alpha * (fit_score - mid_point)\n    priority[feasible] = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n    # ------------------------------------------------------------------\n    # 7) Infeasible bins keep priority 0 (already set at initialisation).\n    # ------------------------------------------------------------------\n    return priority",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    The function favours the *best\u2011fit* bin (the one that leaves the smallest\n    residual capacity after the item is placed) while occasionally exploring\n    other feasible bins.  The exploration probability (epsilon) decays with\n    the number of decisions made, making the algorithm increasingly greedy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` with a priority score for\n        each bin.  The bin with the highest score should be selected.\n    \"\"\"\n    # ----- 1. Manage a decaying epsilon -----------------------------------------\n    # Attach a call counter to the function object for epsilon decay.\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    priority_v2._call_counter += 1\n\n    # Start with epsilon = 0.3 and shrink roughly as 1/sqrt(t)\n    epsilon = max(0.01, 0.3 / np.sqrt(priority_v2._call_counter))\n\n    # ----- 2. Identify feasible bins --------------------------------------------\n    feasible = bins_remain_cap >= item                     # bool mask\n    if not np.any(feasible):\n        # Nothing fits; caller may decide to open a new bin.\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    # ----- 3. Exploitation: Best\u2011Fit score ---------------------------------------\n    # Residual capacity that would remain after packing the item.\n    residual = bins_remain_cap - item                       # shape == bins_remain_cap\n    # Higher score for tighter fit (i.e., smaller residual). Use negative residual.\n    exploit_score = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exploit_score[feasible] = -residual[feasible]\n\n    # ----- 4. Exploration: Random noise -----------------------------------------\n    # Uniform random noise in [0,1) for each bin.\n    exploration_noise = np.random.rand(bins_remain_cap.shape[0])\n\n    # ----- 5. Combine exploitation and exploration -------------------------------\n    # Weighted sum: (1\u2011\u03b5) * exploit + \u03b5 * exploration\n    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise\n\n    # Infeasible bins must stay below any feasible candidate.\n    priorities[~feasible] = -np.inf\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute smooth bin priorities for online Bin Packing using a sigmoid\n    fit\u2011score.  Bins that leave very little slack after inserting the\n    item receive the highest scores.  The steepness of the sigmoid is\n    adapted online based on the typical relative slack of the feasible\n    bins, giving more emphasis to tight fits when bins are relatively\n    full.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; the bin with the largest score is chosen.\n        Bins that cannot accommodate the item receive ``-np.inf``.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Identify bins that can fit the item\n    fits = bins >= item\n\n    if not np.any(fits):\n        # No feasible bin\n        return np.full(bins.shape, -np.inf)\n\n    # Slack left after placing the item\n    slack = bins - item\n\n    # Relative slack (0 for perfect fit, \u22641 otherwise)\n    rel_slack = np.zeros_like(bins)\n    rel_slack[fits] = slack[fits] / bins[fits]\n\n    # Adapt the steepness parameter (alpha) based on typical slack\n    median_rel = np.median(rel_slack[fits])\n    # Base steepness: 5.0; scale so alpha \u2208 [5, 10] depending on median_rel.\n    alpha = 5.0 * (2.0 - median_rel)\n\n    # Sigmoid fit\u2011score: 0.5 when rel_slack==0, decreasing as slack grows\n    scores = np.full(bins.shape, -np.inf)\n    scores[fits] = 1.0 / (1.0 + np.exp(alpha * rel_slack[fits]))\n    # Scale to [0, 1] so perfect fit yields 1.0\n    scores[fits] *= 2.0\n    np.clip(scores, 0.0, 1.0, out=scores)\n\n    return scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function:\n    1. Decays the exploration probability (epsilon) over successive calls.\n    2. Ranks feasible bins by the smallest residual capacity after packing the call.\n    3. Adds a tiny random jitter to break ties without creating large bonuses.\n    4. Guarantees infeasible bins receive the lowest possible score.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin.  Higher scores indicate more desirable bins.\n    \"\"\"\n    # --------------------------------------------------------------------- #\n    # 1. Call counter & epsilon decay\n    # --------------------------------------------------------------------- #\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    priority_v2._call_counter += 1\n\n    # Base epsilon and decay schedule (1/sqrt(t)). Keep a floor to stay exploratory.\n    eps0 = 0.30\n    eps_min = 0.01\n    epsilon = max(eps_min, eps0 / np.sqrt(priority_v2._call_counter))\n\n    # --------------------------------------------------------------------- #\n    # 2. Identify feasible bins (allow a tiny tolerance for floating\u2011point)\n    # --------------------------------------------------------------------- #\n    tolerance = 1e-12\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    feasible = caps + tolerance >= item   # bool mask\n\n    # If nothing fits, return the lowest possible scores (caller may open a new bin).\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # --------------------------------------------------------------------- #\n    # 3. Exploitation: best\u2011fit (smallest residual)\n    # --------------------------------------------------------------------- #\n    residual = caps - item                 # could be negative for infeasible bins\n    exploit_score = np.full_like(caps, -np.inf, dtype=float)\n    # Use negative residual: larger (less negative) = tighter fit.\n    exploit_score[feasible] = -residual[feasible]\n\n    # Tiny jitter to break ties without inflating scores.\n    jitter_scale = 1e-9\n    jitter = jitter_scale * np.random.rand(np.count_nonzero(feasible))\n    exploit_score[feasible] += jitter\n\n    # --------------------------------------------------------------------- #\n    # 4. Exploration: uniform random noise for each bin\n    # --------------------------------------------------------------------- #\n    exploration_noise = np.random.rand(caps.shape[0])\n\n    # epsilon\u2011greedy combination\n    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise\n\n    # Ensure infeasible bins stay below any feasible candidate.\n    priorities[~feasible] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that:\n    - Prioritizes exact fits first.\n    - For remaining bins, prefers the smallest slack (closest to full).\n    - Randomly explores other bins with probability epsilon.\n    - Uses a tolerance to detect exact fits and to avoid floating\u2011point ties.\n    \"\"\"\n    eps = 0.15          # exploration probability\n    exact_bonus = 1e6   # high value to guarantee exact fit preference\n    tolerance = 1e-12   # tolerance for floating\u2011point comparison\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    leftover = caps - item\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = leftover >= -tolerance\n    if not np.any(feasible):\n        return priorities\n\n    # Exploration: assign random priorities to feasible bins\n    if np.random.rand() < eps:\n        rand_scores = np.random.rand(np.count_nonzero(feasible))\n        priorities[feasible] = rand_scores\n        return priorities\n\n    # Indices of feasible bins\n    idx = np.where(feasible)[0]\n    slack = leftover[feasible]\n\n    # Exact fit bins\n    exact_mask = np.isclose(slack, 0.0, atol=tolerance)\n    if np.any(exact_mask):\n        priorities[idx[exact_mask]] = exact_bonus\n\n    # Non\u2011exact feasible bins: prioritize smallest slack\n    non_exact_mask = ~exact_mask\n    if np.any(non_exact_mask):\n        jitter = 1e-12 * np.random.rand(np.count_nonzero(non_exact_mask))\n        priorities[idx[non_exact_mask]] = -slack[non_exact_mask] + jitter\n\n    return priorities",
    "response_id": 7,
    "obj": 4.168328679696844,
    "SLOC": 24.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon0: float = 0.20,\n    decay: float = 0.001,\n    smoothing: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    Bins that would leave the smallest remaining capacity after the item is\n    placed receive higher priority (inverse slack).  To avoid premature\n    convergence, an exploration component is blended in with a decaying\n    epsilon.  Infeasible bins are penalised with ``-inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon0 : float, optional\n        Initial exploration probability (default 0.20).\n    decay : float, optional\n        Decay rate of epsilon per call (default 0.001). Larger values reduce\n        exploration faster.\n    smoothing : float, optional\n        Small constant added to the slack term to avoid division by zero\n        and to smooth the inverse\u2011slack calculation.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing the priority\n        score for each bin.  Bins that cannot accommodate ``item`` receive\n        ``-inf``.\n    \"\"\"\n    # Convert input to a NumPy float array for consistent operations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Slack after placing the item\n    slack = bins_remain_cap - item\n    feasible_mask = slack >= 0\n\n    # No feasible bin \u2192 return all -inf\n    if not np.any(feasible_mask):\n        return priorities\n\n    # ------------------------------------------------------------------\n    # Adaptive epsilon: decays over the number of calls to this\n    # function.  The counter is stored as a function attribute.\n    # ------------------------------------------------------------------\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    step = priority_v2._call_counter\n    priority_v2._call_counter += 1\n\n    epsilon = epsilon0 / (1.0 + decay * step)\n    # Keep epsilon within [0, epsilon0] bounds\n    epsilon = max(0.0, min(epsilon0, epsilon))\n\n    # ------------------------------------------------------------------\n    # Compute the exploitation component: inverse slack, normalised.\n    # ------------------------------------------------------------------\n    inv_slack = 1.0 / (1.0 + slack[feasible_mask] + smoothing)  # >0\n    inv_slack_norm = inv_slack / inv_slack.sum()\n\n    # ------------------------------------------------------------------\n    # Compute the exploration component: random scores, normalised.\n    # ------------------------------------------------------------------\n    rand_scores = np.random.rand(np.count_nonzero(feasible_mask))\n    rand_norm = rand_scores / rand_scores.sum()\n\n    # ------------------------------------------------------------------\n    # Blend exploitation and exploration.\n    # ------------------------------------------------------------------\n    combined = (1.0 - epsilon) * inv_slack_norm + epsilon * rand_norm\n\n    # Assign combined priorities to feasible bins\n    priorities[feasible_mask] = combined\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Decaying epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    The function prefers bins that will be tightly filled after placing the\n    item (i.e., minimal residual capacity).  A small amount of random\n    exploration is mixed in, with an exploration probability (epsilon) that\n    decays as more items are processed.  Tie\u2011breaking jitter and a tiny bonus\n    for exact fits are added to improve numerical stability without using\n    large artificial bonuses.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin.  Higher scores indicate more preferable bins.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ----- 0. Constants ---------------------------------------------------------\n    TOL = 1e-12                 # tolerance for floating\u2011point comparisons\n    JITTER_SCALE = 1e-9         # magnitude of tie\u2011breaking jitter\n    EXACT_FIT_BONUS = 1e-6      # tiny bonus for (near) exact fits\n\n    # ----- 1. Decaying epsilon --------------------------------------------------\n    # Initialise static attributes on first call.\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    if not hasattr(priority_v2, \"_start_epsilon\"):\n        priority_v2._start_epsilon = 0.3\n    if not hasattr(priority_v2, \"_min_epsilon\"):\n        priority_v2._min_epsilon = 0.01\n\n    priority_v2._call_counter += 1\n    epsilon = max(priority_v2._min_epsilon,\n                  priority_v2._start_epsilon / np.sqrt(priority_v2._call_counter))\n\n    # ----- 2. Feasibility mask --------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    feasible = caps + TOL >= item          # allow a tiny tolerance\n\n    # If no bin can accommodate the item, return -inf for all bins.\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # ----- 3. Exploitation: best\u2011fit score --------------------------------------\n    residual = caps - item                 # capacity that would remain\n    # Higher score for smaller residual => negative residual.\n    exploit_score = np.full_like(caps, -np.inf, dtype=float)\n    exploit_score[feasible] = -residual[feasible]\n\n    # Tiny jitter to break exact ties.\n    jitter = np.random.rand(caps.shape[0]) * JITTER_SCALE\n    exploit_score[feasible] += jitter[feasible]\n\n    # Small bonus for (near) exact fits.\n    exact_fit = np.isclose(residual, 0.0, atol=TOL)\n    exploit_score[feasible & exact_fit] += EXACT_FIT_BONUS\n\n    # ----- 4. Exploration: random noise -----------------------------------------\n    exploration_noise = np.random.rand(caps.shape[0])\n\n    # ----- 5. Combine exploitation and exploration -------------------------------\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n    priorities[feasible] = ((1.0 - epsilon) * exploit_score[feasible] +\n                           epsilon * exploration_noise[feasible])\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be placed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; higher values indicate a more attractive bin.\n        Bins that cannot accommodate the item receive a score of 0.\n    \"\"\"\n    # Ensure we work with a NumPy array of float values\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Initialize all priorities to zero (for infeasible bins)\n    priorities = np.zeros_like(caps, dtype=np.float64)\n\n    # Feasibility mask: bin can accommodate the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities  # No bin can take the item\n\n    # Slack remaining after placing the item\n    slack = caps[feasible] - item\n\n    # Normalise slack by the maximum slack among feasible bins\n    max_slack = np.max(slack) if slack.size > 0 else 0.0\n    if max_slack > 0.0:\n        fit_score = 1.0 - slack / max_slack  # 0 <= fit_score <= 1\n    else:\n        # All feasible bins are perfectly tight\n        fit_score = np.ones_like(slack)\n\n    # Logistic transform to sharpen preference for tight fits\n    alpha = 12.0          # steepness of the sigmoid\n    mid_point = 0.5       # centre of the sigmoid\n    sigmoid_arg = alpha * (fit_score - mid_point)\n    priorities[feasible] = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin packing setting.\n\n    The heuristic prefers bins that will be nearly full after placing the item.\n    It uses an exponential decay of the normalized slack (deterministic score),\n    adds a tiny random jitter for deterministic tie\u2011breaking, and incorporates a\n    very small epsilon\u2011greedy random component for exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Higher scores indicate higher preference.\n        Infeasible bins (remaining capacity < item) receive -np.inf.\n    \"\"\"\n    # Guard against empty input\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n\n    # Estimate uniform bin capacity as the maximum remaining capacity observed.\n    # Works when at least one bin is empty; otherwise approximates the capacity\n    # of the least\u2011filled bin.\n    capacity = np.max(bins_remain_cap)\n    if capacity <= 0:\n        # No capacity to place any item.\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Tolerance for floating\u2011point comparisons\n    tol = 1e-12\n\n    # Feasibility mask: bins that can accommodate the item\n    can_fit = bins_remain_cap >= item - tol\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(can_fit):\n        # No feasible bin found\n        return priorities\n\n    # Slack after placing the item for feasible bins\n    slack = bins_remain_cap[can_fit] - item\n\n    # Normalized slack in [0, 1]\n    slack_norm = slack / capacity\n\n    # Adaptive steepness: larger items use a steeper decay\n    base_alpha = 10.0\n    alpha = base_alpha * (item / capacity + 0.1)  # ensure >0\n\n    # Deterministic score: exponential decay of slack.\n    # Exact fits (slack \u2264 tol) get the maximal score of 1.0.\n    exact_fit = slack <= tol\n    deterministic_score = np.where(\n        exact_fit,\n        1.0,\n        np.exp(-alpha * slack_norm)\n    )\n\n    # \u03b5\u2011greedy exploration (tiny random perturbation)\n    eps_greedy = 1e-6\n    random_score = np.random.rand(deterministic_score.shape[0])\n    combined_score = (1.0 - eps_greedy) * deterministic_score + eps_greedy * random_score\n\n    # Tiny jitter for deterministic tie\u2011breaking\n    eps_jitter = 1e-9\n    jitter = np.random.uniform(-eps_jitter, eps_jitter, size=combined_score.shape)\n    combined_score += jitter\n\n    # Assign computed scores to feasible bins\n    priorities[can_fit] = combined_score\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin packing setting.\n\n    This heuristic prioritises bins that will be nearly full after placing the\n    item.  The score is an exponential decay of the normalised slack\n    (`slack / capacity`).  Exact fits receive the maximum score of 1.0.\n    A tiny \u03b5\u2011greedy exploration and a minuscule jitter are added for\n    deterministic tie\u2011breaking.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Higher scores indicate higher preference.\n        Bins that cannot accommodate the item receive `-np.inf`.\n    \"\"\"\n    # Guard against empty input\n    if bins_remain_cap.size == 0:\n        return np.empty(0, dtype=float)\n\n    # Convert to float numpy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Determine bin capacity as the maximum remaining capacity observed\n    capacity = np.max(bins_remain_cap)\n    if capacity <= 0:\n        # No capacity left to place any item\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Small tolerance for floating\u2011point comparisons\n    tol = 1e-12\n\n    # Feasibility mask: bins that can accommodate the item\n    can_fit = bins_remain_cap + tol >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(can_fit):\n        return priorities\n\n    # Slack after placing the item for feasible bins\n    slack = bins_remain_cap[can_fit] - item\n    # Normalised slack in [0, 1]\n    slack_norm = slack / capacity\n\n    # Adaptive steepness: larger items \u2192 steeper decay\n    base_alpha = 10.0\n    alpha = base_alpha * (item / capacity + 0.1)  # ensure >0\n\n    # Deterministic score: exponential decay of slack\n    exact_fit = slack <= tol\n    deterministic_score = np.where(\n        exact_fit,\n        1.0,\n        np.exp(-alpha * slack_norm)\n    )\n\n    # \u03b5\u2011greedy exploration (tiny random perturbation)\n    eps_greedy = 1e-6\n    random_score = np.random.rand(deterministic_score.size)\n    combined_score = (1.0 - eps_greedy) * deterministic_score + eps_greedy * random_score\n\n    # Tiny jitter for deterministic tie\u2011breaking\n    eps_jitter = 1e-9\n    jitter = np.random.uniform(-eps_jitter, eps_jitter, size=combined_score.shape)\n    combined_score += jitter\n\n    # Assign scores to feasible bins\n    priorities[can_fit] = combined_score\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    alpha: float = 12.0,\n    mid_point: float = 0.5,\n    epsilon: float = 0.15,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function returns a score for each currently open bin. The bin with the\n    highest score should be selected for the incoming *item*.  Scores are\n    computed as follows:\n\n    1. **Feasibility** \u2013 only bins with enough remaining capacity are considered.\n    2. **Exact fit** \u2013 bins where the item exactly matches the remaining capacity\n       receive a very large bonus (`exact_bonus`) to guarantee selection.\n    3. **Smooth logistic fit** \u2013 for the remaining feasible bins a logistic\n       (sigmoid) transform of the normalized slack is used; tighter fits get\n       higher scores.\n    4. **Exploration** \u2013 with probability ``epsilon`` the scores of feasible\n       bins (except exact\u2011fit bins) are replaced by random values, encouraging\n       exploration of alternative placements.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the open bins.\n    alpha : float, optional\n        Steepness of the logistic curve (default 12.0).\n    mid_point : float, optional\n        Centre of the logistic curve; a fit_score equal to this value yields\n        a priority of 0.5 (default 0.5).\n    epsilon : float, optional\n        Exploration probability; when ``np.random.rand() < epsilon`` random\n        scores are used for feasible bins (default 0.15).\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to ensure they dominate (default 1e6).\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons (default 1e-12 * 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 0) Normalise input\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # 1) Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin -> return all -inf\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # 2) Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item\n\n    # ------------------------------------------------------------------\n    # 3) Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # 4) Logistic scoring for non\u2011exact feasible bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Estimate the (common) bin capacity.\n        # Using the current maximum remaining capacity is a safe upper bound.\n        capacity_est = caps.max()\n        capacity_est = max(capacity_est, 1e-12)  # protect against division by zero\n\n        # Normalise slack to [0, 1] (0 = perfect fit, 1 = completely empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n        fit_score = 1.0 - norm_slack  # larger => tighter fit\n\n        # Logistic transform\n        sigmoid_arg = alpha * (fit_score - mid_point)\n        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n        # Add a tiny jitter to break ties when scores are identical\n        jitter = 1e-9 * np.random.rand(logistic_score.size)\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # 5) \u03b5\u2011greedy exploration (random scores for feasible non\u2011exact bins)\n    # ------------------------------------------------------------------\n    if np.random.rand() < epsilon:\n        # Random scores in [0, *] for all feasible bins (excluding exact fits)\n        rand_vals = np.random.rand(feasible.sum())\n        feasible_idx = np.where(feasible)[0]\n\n        # Overwrite non\u2011exact feasible bins with random values\n        non_exact_idx = np.where(non_exact)[0]\n        # Map random values to feasible indices; preserve order\n        # The first len(feasible_idx) entries of rand_vals correspond to feasible bins\n        # in the order given by feasible_idx.\n        # Since exact\u2011fit bins also appear in feasible_idx, we replace all feasible,\n        # then re\u2011apply the exact bonus.\n        priority[feasible_idx] = rand_vals\n\n        # Reinstate the exact\u2011fit bonus (ensures they remain top priority)\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 6,
    "obj": 3.9190267251695206,
    "SLOC": 35.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Smooth adaptive sigmoid priority for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins receive -np.inf.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Identify bins that can accommodate the item\n    fits = bins >= item\n\n    # No feasible bin \u2192 all priorities are -inf\n    if not np.any(fits):\n        return np.full(bins.shape, -np.inf, dtype=np.float64)\n\n    # Slack left after placing the item\n    slack = bins - item\n\n    # Compute relative slack only for feasible bins\n    rel_slack = np.zeros_like(bins)\n    if np.any(fits):\n        denom = bins[fits]\n        denom_safe = np.where(denom == 0, np.finfo(np.float64).eps, denom)\n        rel_slack[fits] = slack[fits] / denom_safe\n\n    # Adaptive steepness: higher when bins are relatively full\n    median_rel = np.median(rel_slack[fits])\n    alpha = 5.0 * (2.0 - median_rel)          # 5 \u2264 alpha \u2264 10\n    alpha = np.clip(alpha, 5.0, 10.0)\n\n    # Sigmoid score: 1 at perfect fit, decreasing as slack grows\n    scores = np.full(bins.shape, -np.inf, dtype=np.float64)\n    if np.any(fits):\n        logits = alpha * rel_slack[fits]\n        logistic = 1.0 / (1.0 + np.exp(logits))\n        scores[fits] = logistic * 2.0          # perfect fit \u2192 1.0\n        np.clip(scores[fits], 0.0, 1.0, out=scores[fits])\n\n    return scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                tolerance: float = 1e-12,\n                epsilon: float = 0.0,\n                exact_bonus: float = 1e6) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing\n    Problem (BPP). The bin with the highest score will be chosen for the\n    incoming *item*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all currently open bins.\n    tolerance : float, optional\n        Tolerance for floating\u2011point comparisons.\n    epsilon : float, optional\n        Exploration probability.  With probability ``epsilon`` the scores\n        of non\u2011exact feasible bins are replaced by random values to\n        encourage exploration.\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee their\n        selection.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space.\n    feasible = caps >= item - tolerance\n\n    # Initialize all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin -> return all -inf\n    if not feasible.any():\n        return priority\n\n    # Slack after placing the item (only meaningful for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Compute median slack of non\u2011exact feasible bins to set steepness\n        median_slack = np.median(slack[non_exact])\n        # Avoid division by zero; use a default steepness if median slack is tiny\n        eps_for_alpha = 1e-12\n        alpha = 1.0 / (median_slack + eps_for_alpha) if median_slack > eps_for_alpha else 10.0\n\n        # Compute logistic score: 1/(1+exp(alpha * slack / capacity))\n        # Use current remaining capacity as the \u201ccapacity\u201d for scaling\n        cap_non_exact = caps[non_exact]\n        slack_non_exact = slack[non_exact]\n        # Avoid overflow in exp by clipping\n        exp_argument = alpha * slack_non_exact / cap_non_exact\n        exp_argument = np.clip(exp_argument, -700, 700)\n        logistic_score = 1.0 / (1.0 + np.exp(exp_argument))\n\n        # Deterministic jitter for tie\u2011break: proportional to bin index\n        indices_non_exact = np.nonzero(non_exact)[0]\n        jitter = 1e-9 * indices_non_exact.astype(np.float64) / np.max(caps) if np.max(caps) > 0 else 1e-9 * indices_non_exact.astype(np.float64)\n        priority[non_exact] = logistic_score + jitter\n\n    # \u03b5\u2011greedy exploration (optional)\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        # Random scores for all feasible non\u2011exact bins\n        feasible_idx = np.nonzero(feasible)[0]\n        rand_vals = np.random.rand(feasible_idx.size)\n        priority[feasible_idx] = rand_vals\n        # Reinstate exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem (BPP).\n\n    The heuristic favours bins that become tightly packed after placing the\n    item. It uses a logistic transform of the normalised slack, adaptive to the\n    current set of feasible bins, a large bonus for exact fits, deterministic\n    jitter for tie\u2011breaking, and an \u03b5\u2011greedy exploration strategy with a decaying\n    \u03b5.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n    step : int, optional\n        Number of items already processed; used to decay \u03b5. Default is 0.\n    epsilon0 : float, optional\n        Initial exploration probability. Default is 0.20.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default is 0.01.\n    alpha : float, optional\n        Steepness of the logistic curve. Larger values give a sharper transition.\n        Default is 10.0.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee their selection.\n        Default is 1e6.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons.\n        Default is 1e-12.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for the random numbers used in \u03b5\u2011greedy exploration.\n        Default is None (uses NumPy's default RNG).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Convert to a float64 NumPy array\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Initialise priority vector with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space (allow tolerance)\n    feasible = caps >= (item - tolerance)\n\n    if not feasible.any():\n        # No bin can accommodate the item\n        return priority\n\n    # Slack after placing the item (meaningful only for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection (|slack| <= tolerance)\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n\n    if non_exact.any():\n        # Representative capacity: largest remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        capacity_est = max(capacity_est, tolerance)  # avoid division by zero\n\n        # Normalised slack \u2208 [0, 1] (0 = perfect fit, 1 = empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n\n        # Fit quality: larger when slack is smaller\n        fit_quality = 1.0 - norm_slack  # 1 = perfect fit, 0 = empty bin\n\n        # Adaptive midpoint: median fit quality of current feasible set\n        median_fit = np.median(fit_quality)\n\n        # Logistic transform: tighter fits get scores > 0.5\n        logistic_arg = alpha * (fit_quality - median_fit)\n        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n        # Deterministic jitter based on bin index to break ties\n        idx = np.where(non_exact)[0]\n        jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration (decaying \u03b5)\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Exploration: assign uniform random scores to feasible non\u2011exact bins\n        rand_vals = rng.random(non_exact.sum())\n        priority[non_exact] = rand_vals\n        # Preserve exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 7,
    "obj": 3.7794176306342333,
    "SLOC": 42.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    alpha: float = 12.0,\n    mid_point: float = 0.5,\n    epsilon: float = 0.15,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    bin_capacity: Optional[float] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    For each open bin the function returns a score. The bin with the highest\n    score is selected to accommodate the incoming `item`.  The scoring\n    procedure is a combination of:\n\n    1. **Feasibility** \u2013 only bins with enough remaining capacity are considered.\n    2. **Exact fit** \u2013 bins whose remaining capacity matches the item size\n       exactly receive a large bonus (`exact_bonus`).\n    3. **Logistic fit** \u2013 the remaining slack is normalised with respect to an\n       estimated bin capacity and fed into a sigmoid.  Tighter fits get\n       higher scores.\n    4. **Jitter** \u2013 a tiny random noise is added to break ties.\n    5. **\u03b5\u2011greedy exploration** \u2013 with probability `epsilon` the scores of\n       feasible bins (excluding exact\u2011fit bins) are replaced by random values,\n       encouraging exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the currently open bins.\n    alpha : float, optional\n        Steepness of the sigmoid (default 12.0).\n    mid_point : float, optional\n        Centre of the sigmoid.  A fit_score equal to this value yields a\n        logistic output of 0.5 (default 0.5).\n    epsilon : float, optional\n        Exploration probability.  When ``np.random.rand() < epsilon`` the\n        scores of feasible bins are replaced by random values (default 0.15).\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee they are chosen\n        (default 1e6).\n    tolerance : float, optional\n        Tolerance for floating\u2011point comparisons (default 1e-12).\n    bin_capacity : float, optional\n        Known full capacity of a bin.  If ``None`` the maximum remaining\n        capacity of the open bins is used as an estimate.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough space\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible bins never selected)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin: return all -inf\n    if not feasible.any():\n        return priority\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Exact\u2011fit detection (within tolerance)\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n\n    if non_exact.any():\n        # Estimate the bin capacity\n        if bin_capacity is None:\n            capacity_est = caps.max()\n        else:\n            capacity_est = bin_capacity\n        capacity_est = max(capacity_est, tolerance)  # guard against zero\n\n        # Normalise slack to [0,1]\n        norm_slack = slack[non_exact] / capacity_est\n        fit_score = 1.0 - norm_slack  # higher -> tighter fit\n\n        # Logistic transform\n        logits = alpha * (fit_score - mid_point)\n        logistic = 1.0 / (1.0 + np.exp(-logits))\n\n        # Small jitter to break ties\n        jitter = 1e-9 * np.random.rand(logistic.size)\n        priority[non_exact] = logistic + jitter\n\n    # \u03b5\u2011greedy exploration: random scores for all feasible bins\n    if np.random.rand() < epsilon:\n        rand_vals = np.random.rand(feasible.sum())\n        feasible_idx = np.where(feasible)[0]\n        priority[feasible_idx] = rand_vals\n        # Reinstate exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 6,
    "obj": 3.9888312724371757,
    "SLOC": 38.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    epsilon: float = 0.0,\n    exact_bonus: float = 1e6,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing Problem (BPP).\n    The bin with the highest score will be chosen for the incoming *item*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all currently open bins.\n    tolerance : float, optional\n        Tolerance for floating\u2011point comparisons.\n    epsilon : float, optional\n        Exploration probability. With probability ``epsilon`` the scores of\n        non\u2011exact feasible bins are replaced by random values to encourage\n        exploration.\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee their selection.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space.\n    feasible = caps >= item - tolerance\n\n    # Initialize all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin -> return all -inf\n    if not feasible.any():\n        return priority\n\n    # Slack after placing the item (only meaningful for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Compute median slack of non\u2011exact feasible bins to set steepness\n        median_slack = np.median(slack[non_exact])\n        eps_for_alpha = 1e-12\n        alpha = 1.0 / (median_slack + eps_for_alpha) if median_slack > eps_for_alpha else 10.0\n\n        # Logistic score: 1/(1+exp(alpha * slack / cap))\n        cap_non_exact = caps[non_exact]\n        slack_non_exact = slack[non_exact]\n        exp_argument = alpha * slack_non_exact / cap_non_exact\n        exp_argument = np.clip(exp_argument, -700, 700)\n        logistic_score = 1.0 / (1.0 + np.exp(exp_argument))\n        # Scale to [0,1] range\n        logistic_score *= 2.0\n\n        # Deterministic jitter for tie\u2011break: proportional to bin index\n        indices_non_exact = np.nonzero(non_exact)[0]\n        jitter = 1e-9 * indices_non_exact.astype(np.float64) / (np.max(caps) if np.max(caps) > 0 else 1.0)\n        priority[non_exact] = logistic_score + jitter\n\n    # \u03b5\u2011greedy exploration (optional)\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        # Random scores for all feasible non\u2011exact bins\n        feasible_idx = np.nonzero(feasible)[0]\n        rand_vals = np.random.rand(feasible_idx.size)\n        priority[feasible_idx] = rand_vals\n        # Reinstate exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 36.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                tolerance: float = 1e-12,\n                epsilon: float = 0.0,\n                exact_bonus: float = 1e6,\n                alpha: float = 5.0) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing Problem (BPP).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all currently open bins.\n    tolerance : float, optional\n        Tolerance for floating\u2011point comparisons.\n    epsilon : float, optional\n        Exploration probability; with probability ``epsilon`` the scores of feasible\n        non\u2011exact bins are replaced by random values. Default is 0 (deterministic).\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee their selection.\n    alpha : float, optional\n        Decay rate used in the exponential scoring of non\u2011exact bins.\n        Larger values make the scoring steeper (stronger preference for tighter fits).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility: enough space (allowing small tolerance)\n    feasible = caps >= item - tolerance\n\n    # Initialize priorities to -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # If no bin can accommodate the item, return early\n    if not np.any(feasible):\n        return priority\n\n    # Slack after placing the item (relevant only for feasible bins)\n    slack = caps - item  # may be slightly negative within tolerance\n\n    # Detect exact fits within tolerance\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins (candidates for regular scoring)\n    non_exact = feasible & ~exact_fit\n    if np.any(non_exact):\n        # Normalized slack (fraction of bin that would remain empty)\n        # Avoid division by zero; feasible bins have caps > 0 for positive items.\n        norm_slack = slack[non_exact] / caps[non_exact]\n\n        # Exponential scoring: higher for smaller normalized slack.\n        # Clip to prevent overflow in exp().\n        exp_arg = -alpha * norm_slack\n        exp_arg = np.clip(exp_arg, -700, 700)\n        score = np.exp(exp_arg)  # range (0, 1], equals 1 for zero slack.\n\n        # Deterministic tie\u2011breaker: a vanishing offset based on bin index.\n        idx = np.nonzero(non_exact)[0]\n        tiny = np.finfo(np.float64).eps\n        offset = tiny * (idx.astype(np.float64) / (np.max(idx) + 1.0))\n        priority[non_exact] = score + offset\n\n    # \u03b5\u2011greedy exploration (optional)\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        # Random scores for all feasible (non\u2011exact_fit) bins.\n        rand_scores = np.random.rand(np.count_nonzero(feasible))\n        feasible_idx = np.nonzero(feasible)[0]\n        priority[feasible_idx] = rand_scores\n        # Preserve exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    epsilon: float = 0.0,\n    exact_bonus: float = 1e6,\n    jitter_scale: float = 1e-9,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing Problem (BPP).\n    The bin with the highest score will be chosen for the incoming *item*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all currently open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility and exact\u2011fit detection.\n    epsilon : float, optional\n        Exploration probability. With probability ``epsilon`` random scores are\n        assigned to feasible bins to encourage exploration.\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee their selection.\n    jitter_scale : float, optional\n        Scale of the deterministic index\u2011based jitter used for tie\u2011breaking.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask (allow a small tolerance)\n    feasible = caps >= item - tolerance\n\n    # Initialise priorities with -inf (infeasible bins)\n    priorities = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin => return all -inf\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Exact\u2011fit detection\n    exact_fit = np.abs(slack) <= tolerance\n    priorities[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n    if np.any(non_exact):\n        slack_n = slack[non_exact]  # positive slack values\n\n        # Determine scaling factor from median slack.\n        median_slack = np.median(slack_n)\n        # Ensure median_slack is positive to avoid division by zero.\n        median_slack = max(median_slack, tolerance)\n\n        # Choose alpha so that slack = median_slack yields score \u2248 0.5.\n        # Using exponential decay: score = exp(-alpha * slack).\n        alpha = np.log(2.0) / median_slack\n        # Clamp alpha to a reasonable range to avoid extreme exponents.\n        alpha = np.clip(alpha, 1e-6, 1e6)\n\n        # Exponential decay score (smooth, decreasing with slack)\n        exp_arg = -alpha * slack_n\n        # Clip exponent to avoid underflow/overflow in np.exp.\n        exp_arg = np.clip(exp_arg, -700, 0)\n        score = np.exp(exp_arg)  # in (0, 1]\n\n        # Deterministic tie\u2011breaker: small index\u2011based jitter.\n        idx_non_exact = np.nonzero(non_exact)[0]\n        max_cap = np.max(caps) if np.max(caps) > 0 else 1.0\n        jitter = jitter_scale * idx_non_exact.astype(np.float64) / max_cap\n\n        priorities[non_exact] = score + jitter\n\n    # Optional epsilon\u2011greedy exploration (random scores for feasible bins)\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        feasible_idx = np.nonzero(feasible)[0]\n        rand_scores = np.random.rand(feasible_idx.size)\n        priorities[feasible_idx] = rand_scores\n        # Preserve exact\u2011fit bonus after randomisation.\n        priorities[exact_fit] = exact_bonus\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 37.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\nfrom typing import Union, Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e9,\n    tolerance: float = 1e-12,\n    jitter_scale: float = 1e-9,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    This version implements an adaptive scoring scheme:\n      * Exact\u2011fit bins receive a large bonus.\n      * Non\u2011exact feasible bins are scored by a logistic transform of the\n        normalised slack, whose midpoint adapts to the median fit quality.\n      * Deterministic jitter based on bin index breaks ties.\n      * An \u03b5\u2011greedy exploration strategy with a decaying \u03b5 is applied.\n      * Infeasible bins are penalised with -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like\n        Remaining capacities of the currently open bins.\n    step : int, optional\n        Number of items processed so far (used for \u03b5 decay). Default ``0``.\n    epsilon0 : float, optional\n        Initial exploration probability. Default ``0.20``.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default ``0.01``.\n    alpha : float, optional\n        Steepness of the logistic curve. Default ``10.0``.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee selection. Default ``1e9``.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons. Default ``1e-12``.\n    jitter_scale : float, optional\n        Scale of deterministic jitter for tie\u2011breaking. Default ``1e-9``.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for exploration). Default ``None``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise input\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priority vector with -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # If no bin can accommodate the item, return the -inf vector immediately\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item\n\n    # ------------------------------------------------------------------\n    # Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # Adaptive logistic scoring for non\u2011exact feasible bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Estimate a characteristic capacity: the maximum remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        # Guard against pathological zero capacity\n        capacity_est = max(capacity_est, 1e-12)\n\n        # Normalised slack in [0, 1] (0 = perfect fit, 1 = completely empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n        norm_slack = np.clip(norm_slack, 0.0, 1.0)\n\n        # Fit score: larger values mean tighter fit\n        fit_score = 1.0 - norm_slack\n\n        # Adaptive midpoint: median of the fit scores for the current feasible set\n        median_fit = np.median(fit_score)\n\n        # Logistic transform (clamp argument to avoid overflow)\n        arg = alpha * (fit_score - median_fit)\n        arg = np.clip(arg, -50.0, 50.0)  # exp overflow protection\n        logistic_score = 1.0 / (1.0 + np.exp(-arg))\n\n        # Deterministic tiny jitter based on bin index to break ties\n        idx_non_exact = np.where(non_exact)[0]\n        jitter = jitter_scale * (idx_non_exact.astype(np.float64) / (len(caps) + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration with decaying \u03b5\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Random scores for all feasible bins (uniform in [0, 1])\n        rand_vals = rng.random(feasible.sum())\n        priority[feasible] = rand_vals\n        # Preserve the exact\u2011fit bonus (so exact fits remain dominant)\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 4,
    "obj": 3.8990825688073536,
    "SLOC": 45.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: int | np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    This implementation builds on the best\u2011fit idea by:\n\n    * rewarding **exact fits** with a huge constant `exact_bonus`;\n    * scoring feasible, non\u2011exact bins by a logistic transform of the *tightness*\n      of the fit, where tightness is 1\u2011slack/max(remaining_capacity);\n    * using the *median* tightness of the current feasible set as the logistic\n      midpoint, making the scoring adaptive to the current state of the bins;\n    * applying a tiny deterministic jitter based on bin index to guarantee\n      deterministic tie\u2011breaking;\n    * optionally performing a decaying \u03b5\u2011greedy exploration step, where \u03b5\n      decays as ``\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)``;\n    * ensuring infeasible bins receive ``-np.inf`` so they can never be\n      selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the currently open bins.\n    step : int, optional\n        Number of items processed so far (used for \u03b5 decay). Default ``0``.\n    epsilon0 : float, optional\n        Initial exploration probability. Default ``0.20``.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default ``0.01``.\n    alpha : float, optional\n        Steepness of the logistic curve. Default ``10.0``.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee selection. Default ``1e6``.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons. Default ``1e-12``.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for exploration). Default ``None``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Ensure a float64 numpy array\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask \u2013 bin must have enough free space.\n    feasible = caps >= (item - tolerance)\n\n    # All bins start with a low priority\n    priorities = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    if not feasible.any():\n        return priorities  # nothing can accommodate the item\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Detect exact\u2011fit bins\n    exact_fit = np.abs(slack) <= tolerance\n    priorities[exact_fit] = exact_bonus\n\n    # Non\u2011exact, feasible bins\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Normalise slack by the largest remaining capacity among feasible bins\n        max_cap = caps[feasible].max()\n        max_cap = max(max_cap, 1e-12)  # avoid division by zero\n        norm_slack = slack[non_exact] / max_cap  # \u2208 [0, 1]\n        fit_score = 1.0 - norm_slack  # tighter fit \u2192 larger score\n\n        # Adaptive logistic: median of current fit scores defines the midpoint\n        median_fit = np.median(fit_score)\n        logistic_arg = alpha * (fit_score - median_fit)\n        # Clip to avoid overflow in exp\n        logistic_arg = np.clip(logistic_arg, -50, 50)\n        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n        # Deterministic tiny jitter (based on bin index) to break ties\n        idx_non_exact = np.where(non_exact)[0]\n        jitter = 1e-12 * (idx_non_exact / (len(caps) + 1.0))\n\n        priorities[non_exact] = logistic_score + jitter\n\n    # \u03b5\u2011greedy exploration with decaying \u03b5\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # RNG\n    rng = random_state if isinstance(random_state, np.random.Generator) else np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Random scores for non\u2011exact feasible bins\n        rand_vals = rng.random(non_exact.sum())\n        priorities[non_exact] = rand_vals\n        # Preserve exact\u2011fit bonus\n        priorities[exact_fit] = exact_bonus\n\n    return priorities",
    "response_id": 8,
    "obj": 3.9090546469884373,
    "SLOC": 40.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\nfrom typing import Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: Union[int, np.random.Generator, None] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    The returned priority array can be used to select the bin with the highest\n    score for the incoming ``item``.  The scoring combines several heuristics:\n\n    * **Exact\u2011fit reward** \u2013 bins that would be perfectly filled receive a large\n      constant ``exact_bonus``.\n    * **Fit tightness** \u2013 for non\u2011exact feasible bins, slack is normalised by the\n      maximum remaining capacity among all feasible bins and transformed with a\n      logistic function.  The logistic midpoint adapts to the median fit score\n      of the current feasible set.\n    * **Deterministic jitter** \u2013 a tiny index\u2011based term breaks ties in a\n      reproducible way.\n    * **\u03b5\u2011greedy exploration** \u2013 with a decaying probability\n      ``\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)`` the scores of non\u2011exact feasible bins\n      are replaced by random values, encouraging exploration early on.\n    * **Infeasible bins** \u2013 receive ``-np.inf`` and can never be selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    step : int, optional\n        Number of items processed so far (used for \u03b5 decay). Default is ``0``.\n    epsilon0 : float, optional\n        Initial exploration probability. Default is ``0.20``.\n    decay_rate : float, optional\n        Decay factor for \u03b5. Default is ``0.01``.\n    alpha : float, optional\n        Steepness of the logistic curve. Default is ``10.0``.\n    # higher values make the logistic sharper.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee their selection.\n        Default is ``1e6``.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons.\n        Default is ``1e-12``.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for exploration).\n        Default is ``None``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Infeasible bins have ``-np.inf``.\n    \"\"\"\n    # --------------------------------------------------------------------- #\n    # 1. Prepare data ------------------------------------------------------ #\n    # --------------------------------------------------------------------- #\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough space for the item (allowing tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Early exit if no bin can accommodate the item\n    if not feasible.any():\n        return priorities\n\n    # --------------------------------------------------------------------- #\n    # 2. Compute slack and identify exact fits ---------------------------- #\n    # --------------------------------------------------------------------- #\n    slack = caps - item\n\n    # Exact fit detection (|slack| <= tolerance)\n    exact_fit = np.abs(slack) <= tolerance\n    priorities[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n\n    # --------------------------------------------------------------------- #\n    # 3. Score non\u2011exact feasible bins ------------------------------------- #\n    # --------------------------------------------------------------------- #\n    if non_exact.any():\n        # Normalise slack by the largest remaining capacity among feasible bins\n        max_cap = caps[feasible].max()\n        max_cap = max(max_cap, tolerance)  # avoid division by zero\n\n        norm_slack = slack[non_exact] / max_cap           # in [0, 1] roughly\n        fit_score = 1.0 - norm_slack                       # tighter fit \u2192 larger\n\n        # Adaptive logistic transform: median fit_score is the midpoint\n        median_fit = np.median(fit_score)\n        logistic_arg = alpha * (fit_score - median_fit)\n\n        # Clip to avoid overflow in exp()\n        logistic_arg = np.clip(logistic_arg, -np.inf, np.inf)\n        logistic_arg = np.clip(logistic_arg, -50, 50)      # safe range for exp\n\n        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n        # Deterministic jitter to break ties (tiny, index\u2011based)\n        idx_non_exact = np.nonzero(non_exact)[0]\n        jitter = 1e-12 * (idx_non_exact / (len(caps) + 1.0))\n\n        priorities[non_exact] = logistic_score + jitter\n\n    # --------------------------------------------------------------------- #\n    # 4. \u03b5\u2011greedy exploration ------------------------------------------------ #\n    # --------------------------------------------------------------------- #\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Resolve RNG (allow seed, Generator, or default)\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon and non_exact.any():\n        # Replace non\u2011exact feasible scores with uniform random values\n        random_scores = rng.random(non_exact.sum())\n        priorities[non_exact] = random_scores\n        # Preserve exact\u2011fit bonuses (they should dominate)\n        priorities[np.isinf(priorities)] = -np.inf  # sanity (should already hold)\n\n    return priorities",
    "response_id": 3,
    "obj": 3.7893897088153174,
    "SLOC": 44.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\nfrom typing import Union, Optional, Tuple\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Tuple[float, ...], list],\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e9,\n    tolerance: float = 1e-12,\n    jitter_scale: float = 1e-9,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive priority scoring for the online Bin Packing Problem (BPP).\n\n    The scoring combines several heuristics:\n      * Feasibility mask \u2013 only bins with enough remaining capacity are considered.\n      * Exact\u2011fit bonus \u2013 bins that fit the item perfectly receive a huge boost.\n      * Logistic slack scaling \u2013 non\u2011exact feasible bins are scored by a logistic\n        transform of their normalised slack, with the logistic midpoint adapting\n        to the median fit quality of the current feasible set.\n      * Deterministic jitter \u2013 tiny bin\u2011index\u2011based jitter breaks ties deterministically.\n      * \u03b5\u2011greedy exploration \u2013 with a decaying \u03b5, occasionally random scores are used\n        to encourage exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like\n        Remaining capacities of currently open bins.\n    step : int, default 0\n        Number of items processed so far (used for \u03b5 decay).\n    epsilon0 : float, default 0.20\n        Initial exploration probability.\n    decay_rate : float, default 0.01\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)).\n    alpha : float, default 10.0\n        Steepness of the logistic curve.\n    exact_bonus : float, default 1e9\n        Bonus added to exact\u2011fit bins to guarantee selection.\n    tolerance : float, default 1e-12\n        Numerical tolerance for floating\u2011point comparisons.\n    jitter_scale : float, default 1e-9\n        Scale of deterministic jitter for tie\u2011breaking.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for exploration).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise input\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Handle empty bin list gracefully\n    if caps.size == 0:\n        return np.empty_like(caps, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priority vector with -inf (infeasible bins stay -inf)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # If no bin can accommodate the item, return the -inf vector immediately\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item\n\n    # ------------------------------------------------------------------\n    # Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # Logistic scoring for non\u2011exact feasible bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Characteristic capacity: max remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        # Guard against pathological zero capacity (should not happen for feasible)\n        capacity_est = max(capacity_est, 1e-12)\n\n        # Normalised slack in [0, 1] (0 = perfect fit, 1 = completely empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n        norm_slack = np.clip(norm_slack, 0.0, 1.0)\n\n        # Fit score: higher means tighter fit\n        fit_score = 1.0 - norm_slack\n\n        # Adaptive median midpoint for logistic transform\n        median_fit = np.median(fit_score)\n\n        # Logistic transform (clamped to avoid overflow)\n        arg = alpha * (fit_score - median_fit)\n        arg = np.clip(arg, -50.0, 50.0)  # exp overflow protection\n        logistic_score = 1.0 / (1.0 + np.exp(-arg))\n\n        # Deterministic jitter based on bin index to break ties\n        idx_non_exact = np.where(non_exact)[0]\n        jitter = jitter_scale * (idx_non_exact.astype(np.float64) / (caps.size + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration with decaying \u03b5\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Random scores for all feasible bins (uniform in [0, 1])\n        rand_vals = rng.random(feasible.sum())\n        priority[feasible] = rand_vals\n        # Preserve exact\u2011fit bonus (exact fits dominate even during exploration)\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 0,
    "obj": 3.819305943358592,
    "SLOC": 47.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\nfrom typing import Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.15,\n    decay_rate: float = 0.01,\n    base_alpha: float = 10.0,\n    exact_bonus: float = 1e9,\n    tolerance: float = 1e-12,\n    jitter_scale: float = 1e-12,\n    random_state: Union[int, np.random.Generator, None] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    This version builds on the adaptive logistic scoring approach:\n      * exact\u2011fit bins receive a large constant bonus,\n      * non\u2011exact feasible bins are scored with a logistic transform of the\n        *tightness* of the fit (tightness = 1 \u2013 slack / max_remaining_capacity),\n        * median tightness of the current feasible set is used as the logistic\n          midpoint,\n        * the steepness (\u03b1) adapts to the spread of tightness values via the\n          inter\u2011quartile range,\n      * a deterministic jitter (scaled by ``jitter_scale``) breaks ties\n        reproducibly,\n      * an \u03b5\u2011greedy exploration step decays over time.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of currently open bins.\n    step : int, optional\n        Number of items processed so far (used for \u03b5 decay). Default ``0``.\n    epsilon0 : float, optional\n        Initial exploration probability. Default ``0.15``.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default ``0.01``.\n    base_alpha : float, optional\n        Base steepness for the logistic curve. Adapted by the IQR of tightness.\n        Default ``10.0``.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee selection. Default ``1e9``.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons. Default ``1e-12``.\n    jitter_scale : float, optional\n        Scale of deterministic jitter for tie\u2011breaking. Default ``1e-12``.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for \u03b5\u2011greedy exploration).\n        Default ``None``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # --------------------------------------------------------------------- #\n    # 1. Prepare data\n    # --------------------------------------------------------------------- #\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask \u2013 bin must have enough free space (with tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    if not feasible.any():\n        # No bin can accommodate the item \u2013 caller will need to open a new bin\n        return priorities\n\n    # --------------------------------------------------------------------- #\n    # 2. Compute slack and identify exact\u2011fit bins\n    # --------------------------------------------------------------------- #\n    slack = caps - item\n    exact_fit = np.abs(slack) <= tolerance\n    priorities[exact_fit] = exact_bonus\n\n    # --------------------------------------------------------------------- #\n    # 3. Score non\u2011exact feasible bins\n    # --------------------------------------------------------------------- #\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Normalise slack by the largest remaining capacity among feasible bins\n        max_cap = caps[feasible].max()\n        max_cap = max(max_cap, 1e-12)  # protect against division by zero\n\n        # Normalised slack \u2208 [0, 1]; tightness = 1 - normalized slack\n        norm_slack = slack[non_exact] / max_cap\n        tightness = 1.0 - norm_slack  # tighter fit \u2192 larger value\n\n        # Adaptive logistic midpoint: median tightness of current feasible set\n        median_tight = np.median(tightness)\n\n        # Adaptive steepness: increase \u03b1 when distribution is narrow,\n        # decrease when it is wide. Use IQR as a proxy for spread.\n        iqr = np.percentile(tightness, 75) - np.percentile(tightness, 25)\n        # Prevent division by zero; ensure \u03b1 stays within reasonable bounds\n        adaptive_alpha = base_alpha * (1.0 / (iqr + 1e-12))\n        adaptive_alpha = np.clip(adaptive_alpha, 1.0, 1e3)\n\n        # Logistic transform\n        logistic_arg = adaptive_alpha * (tightness - median_tight)\n        logistic_arg = np.clip(logistic_arg, -50, 50)  # avoid overflow\n        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n        # Deterministic jitter based on bin index (break ties reproducibly)\n        idx_non_exact = np.where(non_exact)[0]\n        jitter = jitter_scale * (idx_non_exact.astype(np.float64) / (len(caps) + 1.0))\n\n        priorities[non_exact] = logistic_score + jitter\n\n    # --------------------------------------------------------------------- #\n    # 4. \u03b5\u2011greedy exploration (decaying \u03b5)\n    # --------------------------------------------------------------------- #\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n    epsilon = min(max(epsilon, 0.0), 1.0)  # clamp to [0, 1]\n\n    # Prepare RNG (allow passing a Generator or a seed)\n    rng = (\n        random_state\n        if isinstance(random_state, np.random.Generator)\n        else np.random.default_rng(random_state)\n    )\n\n    if rng.random() < epsilon:\n        # Exploration: assign random scores to all feasible bins (except exact)\n        rand_vals = rng.random(non_exact.sum())\n        priorities[non_exact] = rand_vals\n        # Preserve exact\u2011fit bonus (they remain the highest)\n        priorities[exact_fit] = exact_bonus\n\n    return priorities",
    "response_id": 2,
    "obj": 4.038691663342641,
    "SLOC": 49.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: Union[np.ndarray, list, tuple],\n    *,\n    tolerance: float = 1e-12,\n    alpha: float = 12.0,\n    mid_point: float = 0.5,\n    epsilon: float = 0.1,\n    exact_bonus: float = 1e6,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    For each currently open bin this function returns a scalar score.\n    The bin with the highest score should be selected for the incoming *item*.\n    Scores are computed as follows:\n\n    1. **Feasibility** \u2013 only bins with enough remaining capacity are considered.\n    2. **Exact\u2011fit bonus** \u2013 bins where the item exactly matches the remaining\n       capacity receive a large constant ``exact_bonus``.\n    3. **Fit\u2011tightness** \u2013 for the remaining feasible bins a logistic\n       transformation of the normalized slack (how empty the bin would be)\n       is used; tighter fits obtain higher scores.\n    4. **Exploration** \u2013 with probability ``epsilon`` the scores of feasible\n       non\u2011exact bins are replaced by random values (\u03b5\u2011greedy exploration).\n    5. **Tie\u2011breaking jitter** \u2013 a tiny random jitter is added to break ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like\n        Remaining capacities of all open bins.\n    tolerance : float, default 1e-12\n        Numerical tolerance for feasibility and exact\u2011fit checks.\n    alpha : float, default 12.0\n        Steepness of the logistic curve; larger values make the score more\n        sensitive to the fit quality.\n    mid_point : float, default 0.5\n        Mid\u2011point of the logistic curve; a fit score equal to this value yields\n        a logistic output of 0.5.\n    epsilon : float, default 0.1\n        Exploration probability (\u03b5\u2011greedy). When ``rng.random() < epsilon`` the\n        scores of feasible non\u2011exact bins are replaced by uniform random numbers.\n    exact_bonus : float, default 1e6\n        Large constant added to exact\u2011fit bins to guarantee they dominate.\n    random_state : int or np.random.Generator, optional\n        Seed or random generator for reproducibility.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 0) Normalise input and initialise RNG\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    # ------------------------------------------------------------------\n    # 1) Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Early exit if nothing fits\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # 2) Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item  # may be negative for infeasible bins; we ignore those later\n\n    # ------------------------------------------------------------------\n    # 3) Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # 4) Logistic scoring for feasible, non\u2011exact bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Normalise slack by the bin's own capacity to obtain a value in [0, 1]\n        # (0 = perfect fit, 1 = completely empty bin)\n        cap_non_exact = caps[non_exact]\n        # Protect against division by zero (should not happen for feasible bins)\n        cap_non_exact = np.maximum(cap_non_exact, tolerance)\n\n        slack_non_exact = slack[non_exact]\n        norm_slack = slack_non_exact / cap_non_exact  # \u2208 [0, 1]\n\n        # Fit quality: higher when the slack is small\n        fit_score = 1.0 - norm_slack  # \u2208 [0, 1]; 1 = perfect fit\n\n        # Logistic transformation\n        # sigmoid(z) = 1 / (1 + exp(-z)), where z = alpha * (fit_score - mid_point)\n        sigmoid_arg = alpha * (fit_score - mid_point)\n        # Clip to avoid overflow in exp\n        sigmoid_arg = np.clip(sigmoid_arg, -700, 700)\n        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n        # Tiny random jitter for deterministic tie\u2011breaking\n        jitter = rng.uniform(0.0, 1e-9, size=logistic_score.shape)\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # 5) \u03b5\u2011greedy exploration (replace scores of feasible non\u2011exact bins)\n    # ------------------------------------------------------------------\n    if rng.random() < epsilon and non_exact.any():\n        # Draw uniform random scores in [0, 1) for each feasible non\u2011exact bin\n        rand_scores = rng.random(non_exact.sum())\n        priority[non_exact] = rand_scores\n        # Preserve the exact\u2011fit bonus (ensures exact fits still dominate)\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 8,
    "obj": 3.9988033506182825,
    "SLOC": 40.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha0: float = 10.0,\n    alpha_decay: float = 0.0,\n    slack_decay_beta: float = 0.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem (BPP).\n\n    The heuristic favours bins that become tightly packed after placing the\n    item. It uses a logistic transform of the normalised slack relative to\n    the largest remaining capacity among feasible bins, an exponential\n    slack\u2011decay factor for tighter fits, a large bonus for exact fits, a\n    deterministic jitter for tie\u2011breaking, and a decaying \u03b5\u2011greedy exploration\n    strategy.  Feasible bins are those that can accommodate the incoming\n    item (within a tolerance).  Infeasible bins receive ``-np.inf``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n    step : int, optional\n        Number of items already processed; used to decay \u03b5. Default is 0.\n    epsilon0 : float, optional\n        Initial exploration probability. Default is 0.20.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default is 0.01.\n    alpha0 : float, optional\n        Base steepness of the logistic curve. Default is 10.0.\n    alpha_decay : float, optional\n        Decay factor for \u03b1 (\u03b1 = \u03b1\u2080 / (1 + alpha_decay * step)). Default is 0.0.\n    slack_decay_beta : float, optional\n        Exponential slack\u2011decay coefficient; larger values penalise slack\n        more heavily. Default is 0.0 (no additional decay).\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee their selection.\n        Default is 1e6.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons.\n        Default is 1e-12.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for the random numbers used in \u03b5\u2011greedy exploration.\n        Default is None (uses NumPy's default RNG).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Feasibility check\n    feasible = caps >= (item - tolerance)\n    if not feasible.any():\n        return priority\n\n    # Slack after placing the item\n    slack = caps - item\n    # Exact fit detection\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n    if not non_exact.any():\n        return priority\n\n    # Normalise slack by the largest remaining capacity among feasible bins\n    capacity_est = caps[feasible].max()\n    capacity_est = max(capacity_est, tolerance)\n    norm_slack = slack[non_exact] / capacity_est\n\n    # Median of normalised slack for adaptive threshold\n    median_norm_slack = np.median(slack[feasible] / capacity_est)\n\n    # Logistic score favouring tighter fits\n    alpha = alpha0 / (1.0 + alpha_decay * step) if alpha_decay else alpha0\n    logistic_arg = alpha * (median_norm_slack - norm_slack)\n    logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n    # Exponential slack decay for additional tightness penalty\n    if slack_decay_beta > 0.0:\n        logistic_score *= np.exp(-slack_decay_beta * norm_slack)\n\n    # Deterministic jitter to break ties\n    idx = np.where(non_exact)[0]\n    jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))\n    priority[non_exact] = logistic_score + jitter\n\n    # \u03b5\u2011greedy exploration with decaying \u03b5\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n    rng = random_state if isinstance(random_state, np.random.Generator) else np.random.default_rng(random_state)\n    if rng.random() < epsilon:\n        rand_vals = rng.random(non_exact.sum())\n        priority[non_exact] = rand_vals\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 0,
    "obj": 3.9589150378939015,
    "SLOC": 44.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  }
]