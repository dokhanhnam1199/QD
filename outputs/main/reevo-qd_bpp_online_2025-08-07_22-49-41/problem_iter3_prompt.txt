{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Prior reflection]\nExact fits first, then smallest slack; score bins by negative residual (inverse slack or sigmoid); assign\u202f-\u221e to infeasible bins and prune them; add tiny\u202f\u03b5 for tie\u2011breaking, no large random\u202f\u03b5\u2011greedy; normalize by capacity; adapt steepness/\u03b5 online; keep vectorized.\n\n[Code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Priority function implementing the Almost Full Fit heuristic.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin.  Higher priority means the bin is\n        chosen first.  For bins that cannot accommodate the item the\n        priority is set to -np.inf.\n\n    Notes\n    -----\n    In the almost full fit strategy we prefer bins that will be\n    almost filled after adding the item.  For a bin that can fit the\n    item, the \"after packing remaining capacity\" is computed as\n    `bins_remain_cap - item`.  The smaller this residual is, the higher\n    the priority.  The implementation translates this to a score of\n    `-(bins_remain_cap - item)`, so that a residual of 0 (perfect fit)\n    gives a score of 0, a residual of 0.2 gives -0.2, etc.  The\n    largest score is selected.\n    \"\"\"\n    # Safe boolean mask for feasible bins\n    can_fit = bins_remain_cap >= item\n    # Compute negative remaining after packing for applicable bins\n    # Unused bins get negative infinity to discourage selection.\n    priorities = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priorities\n\n[Improved code]\nPlease write a mutated function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}