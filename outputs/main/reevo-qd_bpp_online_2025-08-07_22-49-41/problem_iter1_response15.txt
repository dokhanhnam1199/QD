```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for placing `item` into each bin using the Inverse Distance
    (Proximity Fit) strategy.

    Bins that would leave a smaller leftover capacity after the item is placed receive
    higher priority. The priority is the inverse of the residual capacity (i.e., 
    1 / (remaining_capacity - item)), with an exact fit receiving the maximal possible
    priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        One‑dimensional array of the current remaining capacities of bins.

    Returns
    -------
    np.ndarray
        Array of priority scores, same shape as ``bins_remain_cap``. Higher scores indicate
        more desirable bins. Infeasible bins (insufficient capacity) receive ``-np.inf``.
    """
    # Ensure a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Residual capacity if we hypothetically place the item in each bin
    residual = caps - item

    # Feasibility mask: only bins that can accommodate the item
    feasible = residual >= 0

    # Small epsilon to avoid division by zero
    eps = np.finfo(float).eps

    # Initialise all priorities to the lowest value (infeasible bins)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Inverse distance: bins that would leave less slack get larger scores
    priorities[feasible] = 1.0 / (residual[feasible] + eps)

    # Exact fits (zero residual) receive maximal priority
    exact_fit = feasible & (np.abs(residual) < eps)
    priorities[exact_fit] = np.finfo(float).max

    return priorities
```
