```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Return a priority score for each bin using an ε‑greedy strategy.
    The algorithm mixes a greedy best‑fit rule with random exploration.

    Parameters
    ----------
    item : float
        Size of the item to pack.
    bins_remain_cap : np.ndarray
        Remaining capacities of the existing bins.

    Returns
    -------
    np.ndarray
        An array of the same shape as `bins_remain_cap` containing the
        priority of each bin.  The bin with the highest value will be chosen.
    """
    n_bins = bins_remain_cap.size

    # Base priority vector: assign -∞ to all bins initially.
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if n_bins == 0:
        # No bins available – the calling procedure should handle this
        # by opening a new bin.  Returning an empty array keeps the API
        # consistent with the input shape.
        return priorities

    # Determine which bins can accommodate the item
    can_fit = bins_remain_cap >= item

    # If no bin can fit the item, no viable actions.  Priorities stay -∞.
    if not can_fit.any():
        return priorities

    # ----------------- Greedy component: Best‑fit heuristic -------------
    # For feasible bins compute a score proportional to how full the bin
    # would become after placing the item (smallest leftover → highest priority).
    leftover = bins_remain_cap - item            # Remaining capacity after insertion
    greedy_scores = -leftover                    # We invert so that smaller leftover => higher value
    greedy_scores[~can_fit] = -np.inf            # Exclude infeasible bins

    # ----------------- Random component: Exploration --------------------
    # Probability of exploring a random feasible bin
    # Decaying epsilon: encourages exploration early and exploitation later.
    epsilon = max(0.01, min(0.3, 0.2 / np.sqrt(n_bins)))

    if np.random.rand() < epsilon:
        # Exploration: pick a random feasible bin and give it a very high priority.
        random_idx = np.random.choice(np.where(can_fit)[0])
        # Assign a large positive value that guarantees selection.
        priorities = np.full(n_bins, -np.inf, dtype=float)
        priorities[random_idx] = 1.0
    else:
        # Exploitation: use the best‑fit scores
        priorities = greedy_scores

    return priorities
```
