```python
import numpy as np
from typing import Optional, Union

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha: float = 10.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing Problem (BPP).

    This heuristic favours bins that become tightly packed after placing the
    item. It incorporates:
      * an exact‑fit bonus,
      * a logistic transform of normalised slack,
      * the median fit quality of the current feasible set as an adaptive pivot,
      * deterministic jitter for reproducible tie‑breaking,
      * ε‑greedy exploration with a decaying ε,
      * robust tolerance checks to handle floating‑point inaccuracies.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.
    step : int, optional
        Number of items already processed (used for ε decay). Default: 0.
    epsilon0 : float, optional
        Initial exploration probability. Default: 0.20.
    decay_rate : float, optional
        Decay factor for ε (ε = ε₀ / (1 + decay_rate * step)). Default: 0.01.
    alpha : float, optional
        Steepness of the logistic curve; larger values give a sharper transition.
        Default: 10.0.
    exact_bonus : float, optional
        Bonus added to exact‑fit bins to guarantee their selection.
        Default: 1e6.
    tolerance : float, optional
        Numerical tolerance for feasibility and exact‑fit detection.
        Default: 1e-12.
    random_state : int | np.random.Generator | None, optional
        Seed or generator for random numbers used in ε‑greedy exploration.
        Default: None (uses NumPy's default RNG).

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    # Convert to float64 NumPy array for consistency
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Initialise priority vector with -inf (infeasible by default)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # Feasibility mask: bin must have enough capacity (allow tolerance)
    feasible = caps >= (item - tolerance)
    if not feasible.any():
        # No bin can accommodate the item
        return priority

    # Compute slack after placing the item (meaningful only for feasible bins)
    slack = caps - item

    # Exact‑fit detection (|slack| <= tolerance)
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Representative capacity for normalisation: largest remaining capacity among feasible bins
        capacity_est = caps[feasible].max()
        capacity_est = max(capacity_est, tolerance)  # safeguard against division by zero

        # Normalised slack ∈ [0, 1] (0 = perfect fit, 1 = empty bin)
        norm_slack = slack[non_exact] / capacity_est

        # Fit quality: larger when slack is smaller (1 = perfect fit, 0 = empty bin)
        fit_quality = 1.0 - norm_slack

        # Adaptive median pivot: median fit quality of all feasible bins (including exact fits)
        slack_feasible = slack[feasible]
        norm_slack_feasible = slack_feasible / capacity_est
        fit_quality_feasible = 1.0 - norm_slack_feasible
        median_fit = np.median(fit_quality_feasible)

        # Logistic transform: tighter fits get scores > 0.5
        logistic_arg = alpha * (fit_quality - median_fit)
        # Clip to avoid overflow in exp
        logistic_arg = np.clip(logistic_arg, -700, 700)
        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Deterministic jitter based on bin index (break ties reproducibly)
        idx = np.where(non_exact)[0]
        jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))

        priority[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # ε‑greedy exploration (decaying ε)
    # ------------------------------------------------------------------
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    # Initialise RNG
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    if rng.random() < epsilon:
        # Exploration: assign uniform random scores to feasible non‑exact bins
        rand_vals = rng.random(non_exact.sum())
        priority[non_exact] = rand_vals
        # Preserve exact‑fit bonus (ensures they remain top if present)
        priority[exact_fit] = exact_bonus

    return priority
```
