```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Computes a Softmax‐based priority for each bin given the incoming
    item size.  The key idea is to treat the *fit* – the residual
    capacity after placing the item – as a score and transform that
    score into a probability distribution via a temperature‐controlled
    softmax.  A small bonus factor is applied to bins that would be
    almost perfectly filled by the item.

    Args:
        item:   Size of the item to be placed.
        bins_remain_cap:  1‑D array containing the remaining capacity
                          of every bin (in the same order used by
                          the packing algorithm).

    Returns:
        An array of floats with the same shape as `bins_remain_cap`.
        The sum of the elements is 1.0.  The bin with the highest
        value will be chosen.
    """
    # Number of bins
    n_bins = bins_remain_cap.shape[0]
    if n_bins == 0:
        return np.array([])

    # -------- Fit score ----------
    # Relative slack after packing the item
    fits = bins_remain_cap - item
    # Bins that cannot accept the item are given a large negative
    # value so that their softmax probability becomes essentially 0
    fits[fits < 0] = -1e6

    # -------- Softmax ----------
    temperature = 10.0  # higher temperature -> sharper distribution
    # Subtract max to avoid numerical overflow in exp
    stable_fits = fits - fits.max()
    exp_values = np.exp(stable_fits * temperature)
    softmax = exp_values / np.sum(exp_values)

    # -------- Bonus for near‑full bins ----------
    # Encourage bins where the item would fill almost all the space
    bonus = np.exp(-np.abs(fits))
    priorities = softmax * bonus
    # Normalise to keep the result a probability distribution
    priorities /= np.sum(priorities)

    return priorities
```
