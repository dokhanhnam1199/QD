```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute deterministic priority scores for online bin packing.

    This implements a Best‑Fit rule with a tiny deterministic jitter for
    tie‑breaking. Bins that cannot accommodate the item receive a priority of
    -inf. Among feasible bins, those that leave the smallest slack (i.e., the
    tightest fit) obtain the highest score. Exact fits (slack within a small
    tolerance) are always preferred over non‑exact fits.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (higher is better). Infeasible bins are set
        to -inf.
    """
    # Floating‑point tolerance for feasibility and exact‑fit detection.
    tol = 1e-12

    # Ensure capacities are a NumPy float array.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialise priorities: -inf for infeasible bins.
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Identify bins that can accommodate the item (allowing a tiny tolerance).
    feasible = caps >= item - tol
    if not np.any(feasible):
        return priorities

    # Indices of feasible bins (sorted ascending, deterministic).
    # Slack after placing the item.
    idx = np.where(feasible)[0]
    slack = caps[feasible] - item

    # Treat slack within tolerance as an exact fit (zero slack).
    slack = np.where(np.abs(slack) <= tol, 0.0, slack)

    # Deterministic jitter for tie‑breaking:
    # linearly spaced values in [0, tol/2), never enough to outweigh a real slack.
    n = idx.size
    jitter = np.arange(n, dtype=float) * (tol / (2 * n)) if n > 0 else np.array([], dtype=float)

    # Priority = -slack + jitter (higher is better).
    priorities[feasible] = -slack + jitter

    return priorities
```
