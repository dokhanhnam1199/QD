{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Prior reflection]\nCompute feasibility mask; give exact\u2011fit items a huge bonus; score feasible bins by logistic((median\u2011slack\u2212slack)/\u03b1) normalized by capacity; penalize infeasibles\u202f\u2013\u221e; use tolerance for float compares; break ties with deterministic \u03b5\u2011jitter; decay \u03b5\u2011greedy exploration; adapt \u03b1/median online; use exponential slack decay for tightness; vectorize for speed.\n\n[Code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online Bin Packing Problem (BPP).\n\n    The heuristic favours bins that become tightly packed after placing the\n    item. It uses a logistic transform of the normalised slack, adaptive to the\n    current set of feasible bins, a large bonus for exact fits, deterministic\n    jitter for tie\u2011breaking, and an \u03b5\u2011greedy exploration strategy with a decaying\n    \u03b5.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n    step : int, optional\n        Number of items already processed; used to decay \u03b5. Default is 0.\n    epsilon0 : float, optional\n        Initial exploration probability. Default is 0.20.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default is 0.01.\n    alpha : float, optional\n        Steepness of the logistic curve. Larger values give a sharper transition.\n        Default is 10.0.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee their selection.\n        Default is 1e6.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons.\n        Default is 1e-12.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for the random numbers used in \u03b5\u2011greedy exploration.\n        Default is None (uses NumPy's default RNG).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # Convert to a float64 NumPy array\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Initialise priority vector with -inf for infeasible bins\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space (allow tolerance)\n    feasible = caps >= (item - tolerance)\n\n    if not feasible.any():\n        # No bin can accommodate the item\n        return priority\n\n    # Slack after placing the item (meaningful only for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection (|slack| <= tolerance)\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n\n    if non_exact.any():\n        # Representative capacity: largest remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        capacity_est = max(capacity_est, tolerance)  # avoid division by zero\n\n        # Normalised slack \u2208 [0, 1] (0 = perfect fit, 1 = empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n\n        # Fit quality: larger when slack is smaller\n        fit_quality = 1.0 - norm_slack  # 1 = perfect fit, 0 = empty bin\n\n        # Adaptive midpoint: median fit quality of current feasible set\n        median_fit = np.median(fit_quality)\n\n        # Logistic transform: tighter fits get scores > 0.5\n        logistic_arg = alpha * (fit_quality - median_fit)\n        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))\n\n        # Deterministic jitter based on bin index to break ties\n        idx = np.where(non_exact)[0]\n        jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration (decaying \u03b5)\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Exploration: assign uniform random scores to feasible non\u2011exact bins\n        rand_vals = rng.random(non_exact.sum())\n        priority[non_exact] = rand_vals\n        # Preserve exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority\n\n[Improved code]\nPlease write a mutated function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}