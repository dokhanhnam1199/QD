[
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing the Almost Full Fit heuristic.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin.  Higher priority means the bin is\n        chosen first.  For bins that cannot accommodate the item the\n        priority is set to -np.inf.\n\n    Notes\n    -----\n    In the almost full fit strategy we prefer bins that will be\n    almost filled after adding the item.  For a bin that can fit the\n    item, the \"after packing remaining capacity\" is computed as\n    `bins_remain_cap - item`.  The smaller this residual is, the higher\n    the priority.  The implementation translates this to a score of\n    `-(bins_remain_cap - item)`, so that a residual of 0 (perfect fit)\n    gives a score of 0, a residual of 0.2 gives -0.2, etc.  The\n    largest score is selected.\n    \"\"\"\n    # Safe boolean mask for feasible bins\n    can_fit = bins_remain_cap >= item\n    # Compute negative remaining after packing for applicable bins\n    # Unused bins get negative infinity to discourage selection.\n    priorities = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function that uses an \u03b5\u2011greedy strategy for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        The size of the item that is about to be inserted.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    priorities : np.ndarray\n        Array of the same shape as `bins_remain_cap`.  The bin with the\n        highest value will be selected by the caller.\n    \"\"\"\n    # Encourage explorations with a small fixed \u03b5.\n    epsilon = 0.15   # ~15% chance to explore a random bin\n\n    # Ensure we have a float array for consistent behaviour\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Start with very low priority for all bins; infeasible bins stay low\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Find indices of bins that can accommodate the item\n    fit_mask = bins_remain_cap >= item\n    if not np.any(fit_mask):\n        return priorities  # No bin can take the item; all are -inf\n\n    if np.random.rand() < epsilon:\n        # Exploration: assign random priorities to every feasible bin\n        # (uniform in [0, 1)) so the selection is effectively random\n        random_scores = np.random.rand(np.count_nonzero(fit_mask))\n        priorities[fit_mask] = random_scores\n    else:\n        # Greedy: best\u2011fit \u2013 choose the bin that leaves the smallest\n        # remaining capacity after placing the item\n        slack = bins_remain_cap[fit_mask] - item   # remaining capacity left after fit\n        # Smaller slack => higher priority (closer to being full)\n        # We use -slack to turn minimization of slack into maximization\n        priorities[fit_mask] = -slack\n\n    return priorities",
    "response_id": 18,
    "obj": 4.248105305145606,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for the online Bin Packing Problem.\n\n    For each bin we compute the leftover capacity after (hypothetically) placing the item.\n    - If the item fits, the priority is the negative leftover (larger \u21d2 smaller leftover).\n    - If it does not fit, the bin receives a large negative penalty to exclude it.\n    An epsilon term based on the current fill level breaks ties in favour of the more\n    already\u2011filled bin, which is a common heuristic refinement.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacity of each bin.\n\n    Returns:\n        A 1\u2011D array of priority scores (same shape as `bins_remain_cap`).\n    \"\"\"\n    # Ensure we work with a float array for precision.\n    caps = bins_remain_cap.astype(float)\n\n    # Remaining capacity if we were to put the item into each bin.\n    residual = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = residual >= 0\n\n    # Large negative constant to disqualify infeasible bins.\n    penalty = -1e9\n    priorities = np.full_like(caps, penalty, dtype=float)\n\n    # Best\u2011Fit core: higher score for smaller residual (i.e., tighter fit).\n    # Using negative residual makes the smallest residual the largest priority.\n    priorities[feasible] = -residual[feasible]\n\n    # Tie\u2011breaker: prefer bins that are already more filled (i.e., have smaller original cap).\n    # Adding a tiny epsilon proportional to the current remaining capacity flips ties.\n    epsilon = 1e-6\n    priorities[feasible] += epsilon * caps[feasible]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for each bin according to Exact Fit First.\n\n    - Bins that can hold the item exactly (remaining capacity == item) get the highest priority.\n    - Bins that can hold the item with leftover get a priority inversely proportional to the leftover,\n      favouring tighter fits.\n    - Bins that cannot accommodate the item receive a very low priority (negative infinity).\n\n    The bin with the highest priority (e.g., via np.argmax) will be chosen.\n    \"\"\"\n    # Compute slack: remaining capacity after hypothetically placing the item\n    slack = bins_remain_cap - item\n\n    # Initialise all priorities as -inf (i.e., infeasible)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n\n    # Mask of bins that can actually accommodate the item (slack >= 0)\n    feasible_mask = slack >= 0\n\n    # If no bin can hold the item, return the all -inf array\n    if not np.any(feasible_mask):\n        return priorities\n\n    # Exact fit bins (slack effectively zero) receive infinite priority\n    exact_mask = feasible_mask & np.isclose(slack, 0.0)\n    priorities[exact_mask] = np.inf\n\n    # For other feasible bins, use inverse slack to favour tighter fits\n    non_exact_mask = feasible_mask & (~exact_mask)\n    epsilon = 1e-12  # safeguard against division by zero (exact fits already handled)\n    priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + epsilon)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority with Inverse Distance (Proximity Fit) strategy.\n\n    Bins that will have the smallest remaining capacity *after* the item is placed\n    receive the highest priority.  Inverse distance (1/(1+slack)) is used to\n    accentuate bins whose slack is close to zero.  Bins that cannot accommodate\n    the item are given a negative priority of -inf, ensuring they are never\n    selected.\n\n    Args:\n        item: Size of the item to be added.\n        bins_remain_cap: 1\u2011D array of remaining capacities of existing bins.\n\n    Returns:\n        A NumPy array of the same shape as `bins_remain_cap`, containing\n        the priority score for each bin.\n    \"\"\"\n    # Slack: remaining capacity after adding the item\n    slack = bins_remain_cap - item\n    # Boolean mask of bins that can accommodate the item\n    mask = slack >= 0\n\n    # If no bin can fit, return -inf for all bins\n    if not np.any(mask):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Priority: larger when slack is smaller\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Avoid division by zero by adding 1\n    priorities[mask] = 1.0 / (1.0 + slack[mask])\n\n    # For bins that cannot accommodate the item, set a large negative value\n    priorities[~mask] = -np.inf\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact\u2011Fit\u2011First priority for the online Bin Packing Problem.\n\n    A bin that can accommodate the item *exactly* receives the highest score.\n    Among the feasible bins, those that leave the smallest leftover capacity are\n    preferred.  Bins that cannot hold the item are assigned a very low priority.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of the current bins.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.  The bin with the highest score will be\n        selected for placement.\n    \"\"\"\n    # Ensure floating\u2011point arithmetic.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after hypothetically placing the item.\n    # Positive => feasible; negative => infeasible.\n    leftover = caps - item\n\n    # Initialise all priorities to a very low value (infeasible).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Mask of feasible bins.\n    feasible = leftover >= 0\n\n    # Exact fits (leftover == 0) should outrank any other feasible bin.\n    # Use -leftover as the base priority: exact fits get 0, others get a negative value.\n    # Since we pick the highest priority, 0 > any negative, achieving Exact\u2011Fit\u2011First.\n    priorities[feasible] = -leftover[feasible]\n\n    # Optional tweak: if you prefer a strictly larger value for exact fits\n    # (e.g., to avoid ties caused by floating\u2011point noise), you can add a tiny\n    # epsilon or set them to a large constant:\n    # exact_fit = np.isclose(leftover, 0, atol=1e-12)\n    # priorities[exact_fit] = np.inf\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return a priority score for each bin using an \u03b5\u2011greedy strategy.\n    The algorithm mixes a greedy best\u2011fit rule with random exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as `bins_remain_cap` containing the\n        priority of each bin.  The bin with the highest value will be chosen.\n    \"\"\"\n    n_bins = bins_remain_cap.size\n\n    # Base priority vector: assign -\u221e to all bins initially.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        # No bins available \u2013 the calling procedure should handle this\n        # by opening a new bin.  Returning an empty array keeps the API\n        # consistent with the input shape.\n        return priorities\n\n    # Determine which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # If no bin can fit the item, no viable actions.  Priorities stay -\u221e.\n    if not can_fit.any():\n        return priorities\n\n    # ----------------- Greedy component: Best\u2011fit heuristic -------------\n    # For feasible bins compute a score proportional to how full the bin\n    # would become after placing the item (smallest leftover \u2192 highest priority).\n    leftover = bins_remain_cap - item            # Remaining capacity after insertion\n    greedy_scores = -leftover                    # We invert so that smaller leftover => higher value\n    greedy_scores[~can_fit] = -np.inf            # Exclude infeasible bins\n\n    # ----------------- Random component: Exploration --------------------\n    # Probability of exploring a random feasible bin\n    # Decaying epsilon: encourages exploration early and exploitation later.\n    epsilon = max(0.01, min(0.3, 0.2 / np.sqrt(n_bins)))\n\n    if np.random.rand() < epsilon:\n        # Exploration: pick a random feasible bin and give it a very high priority.\n        random_idx = np.random.choice(np.where(can_fit)[0])\n        # Assign a large positive value that guarantees selection.\n        priorities = np.full(n_bins, -np.inf, dtype=float)\n        priorities[random_idx] = 1.0\n    else:\n        # Exploitation: use the best\u2011fit scores\n        priorities = greedy_scores\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute bin priorities using a Sigmoid Fit Score strategy.\n\n    The priority is based on the residual space after inserting the item\n    into a bin.  Bins that leave almost no slack (i.e., perfect fit)\n    obtain the highest score.  The decay of the score is governed by a\n    sigmoid (logistic) function over the relative residual\n    `r = (remaining - item) / remaining`.\n\n    Bins that cannot accommodate the item receive a very low priority\n    (``-np.inf``) so that they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the candidate bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores in the range [0, 1], with 1 corresponding to a perfect fit.\n    \"\"\"\n    # Ensure we work on a NumPy array of floats\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Bin can hold the item?\n    fits = bins >= item\n\n    # Residual space if item fits\n    residual = bins - item\n\n    # Relative residual: 0 when perfect fit, increasing with slack\n    rel_residual = np.zeros_like(bins)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        rel_residual = np.where(\n            fits & (bins > 0),\n            residual / bins,\n            0.0\n        )\n\n    # Sigmoid decay parameter \u2013 steeper values emphasize tight fits.\n    alpha = 10.0\n    scores = np.where(\n        fits,\n        1.0 / (1.0 + np.exp(alpha * rel_residual)),\n        -np.inf   # unfit bins get minimal score\n    )\n\n    # Scale to [0, 1] so perfect fit yields 1.0\n    scores *= 2.0\n    np.clip(scores, 0.0, 1.0, out=scores)\n\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin according to the Best\u2011Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; higher scores correspond to better bins.\n    \"\"\"\n    # Initialise with -\u221e for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins are actually usable\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Slack left after placing the item\n        slack = bins_remain_cap[can_fit] - item\n        # Best-fit => least slack => highest (least negative) priority\n        # Add a tiny deterministic jitter to break ties deterministically.\n        jitter = np.linspace(0, 1e-8, np.count_nonzero(can_fit))\n        priorities[can_fit] = -slack + jitter\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Sigmoid Fit Score priority for online Bin Packing.\n\n    For each currently open bin we compute a smooth priority that favours\n    *tight* fits (i.e., small remaining slack after placing the item).  The\n    raw slack is transformed by a logistic (sigmoid) function, producing a\n    value in ``[0, 1]`` \u2013 higher values indicate a more attractive bin.\n    Bins that cannot accommodate the item receive a priority of ``0``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. The bin with the highest score should be\n        selected for the item.\n    \"\"\"\n    # Convert to a NumPy array for vectorised work.\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # 1) Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n\n    #  (Will be overwritten with actual priorities later.)\n    priority = np.zeros_like(caps, dtype=np.float64)\n\n    if not feasible.any():\n        # No bin can accept the item \u2013 return all zeros.\n        return priority\n\n    # ------------------------------------------------------------------\n    # 2) Compute slack (remaining capacity after placing the item) for\n    #    feasible bins only.\n    # ------------------------------------------------------------------\n    slack = np.empty_like(caps)\n    slack[:] = np.nan\n    slack[feasible] = caps[feasible] - item\n\n    # ------------------------------------------------------------------\n    # 3) Estimate the (fixed) bin capacity.\n    #    All bins share the same total capacity C; the current maximum\n    #    remaining capacity is a safe estimator for C.\n    # ------------------------------------------------------------------\n    capacity_est = caps.max() if caps.size > 0 else 1.0\n    capacity_est = max(capacity_est, 1e-12)      # protect against division by zero\n\n    # ------------------------------------------------------------------\n    # 4) Normalise the slack to [0, 1] (0 = perfect fit, 1 = empty bin).\n    # ------------------------------------------------------------------\n    norm_slack = slack / capacity_est\n\n    # ------------------------------------------------------------------\n    # 5) Compute a \u201cfit score\u201d that is large when slack is small.\n    #    fit_score = 1 - norm_slack \u2208 [0, 1]  (1 = perfect fit).\n    # ------------------------------------------------------------------\n    fit_score = 1.0 - norm_slack\n\n    # ------------------------------------------------------------------\n    # 6) Apply a sigmoid to the fit score.\n    #\n    #    priority = 1 / (1 + exp(-\u03b1\u00b7(fit_score - mid_point)))\n    #\n    #    * \u03b1  \u2013 steepness (larger \u21d2 sharper distinction between tight\n    #            and loose fits).\n    #    * mid_point \u2013 sigmoid centre (fit_score at which priority = 0.5).\n    # ------------------------------------------------------------------\n    alpha = 12.0        # controls how aggressively we prefer tight fits\n    mid_point = 0.5    # centre of the logistic curve\n\n    sigmoid_arg = alpha * (fit_score - mid_point)\n    priority[feasible] = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n    # ------------------------------------------------------------------\n    # 7) Infeasible bins keep priority 0 (already set at initialisation).\n    # ------------------------------------------------------------------\n    return priority",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    The function favours the *best\u2011fit* bin (the one that leaves the smallest\n    residual capacity after the item is placed) while occasionally exploring\n    other feasible bins.  The exploration probability (epsilon) decays with\n    the number of decisions made, making the algorithm increasingly greedy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` with a priority score for\n        each bin.  The bin with the highest score should be selected.\n    \"\"\"\n    # ----- 1. Manage a decaying epsilon -----------------------------------------\n    # Attach a call counter to the function object for epsilon decay.\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    priority_v2._call_counter += 1\n\n    # Start with epsilon = 0.3 and shrink roughly as 1/sqrt(t)\n    epsilon = max(0.01, 0.3 / np.sqrt(priority_v2._call_counter))\n\n    # ----- 2. Identify feasible bins --------------------------------------------\n    feasible = bins_remain_cap >= item                     # bool mask\n    if not np.any(feasible):\n        # Nothing fits; caller may decide to open a new bin.\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    # ----- 3. Exploitation: Best\u2011Fit score ---------------------------------------\n    # Residual capacity that would remain after packing the item.\n    residual = bins_remain_cap - item                       # shape == bins_remain_cap\n    # Higher score for tighter fit (i.e., smaller residual). Use negative residual.\n    exploit_score = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exploit_score[feasible] = -residual[feasible]\n\n    # ----- 4. Exploration: Random noise -----------------------------------------\n    # Uniform random noise in [0,1) for each bin.\n    exploration_noise = np.random.rand(bins_remain_cap.shape[0])\n\n    # ----- 5. Combine exploitation and exploration -------------------------------\n    # Weighted sum: (1\u2011\u03b5) * exploit + \u03b5 * exploration\n    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise\n\n    # Infeasible bins must stay below any feasible candidate.\n    priorities[~feasible] = -np.inf\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute smooth bin priorities for online Bin Packing using a sigmoid\n    fit\u2011score.  Bins that leave very little slack after inserting the\n    item receive the highest scores.  The steepness of the sigmoid is\n    adapted online based on the typical relative slack of the feasible\n    bins, giving more emphasis to tight fits when bins are relatively\n    full.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; the bin with the largest score is chosen.\n        Bins that cannot accommodate the item receive ``-np.inf``.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Identify bins that can fit the item\n    fits = bins >= item\n\n    if not np.any(fits):\n        # No feasible bin\n        return np.full(bins.shape, -np.inf)\n\n    # Slack left after placing the item\n    slack = bins - item\n\n    # Relative slack (0 for perfect fit, \u22641 otherwise)\n    rel_slack = np.zeros_like(bins)\n    rel_slack[fits] = slack[fits] / bins[fits]\n\n    # Adapt the steepness parameter (alpha) based on typical slack\n    median_rel = np.median(rel_slack[fits])\n    # Base steepness: 5.0; scale so alpha \u2208 [5, 10] depending on median_rel.\n    alpha = 5.0 * (2.0 - median_rel)\n\n    # Sigmoid fit\u2011score: 0.5 when rel_slack==0, decreasing as slack grows\n    scores = np.full(bins.shape, -np.inf)\n    scores[fits] = 1.0 / (1.0 + np.exp(alpha * rel_slack[fits]))\n    # Scale to [0, 1] so perfect fit yields 1.0\n    scores[fits] *= 2.0\n    np.clip(scores, 0.0, 1.0, out=scores)\n\n    return scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    Strategy\n    --------\n    1. **Exact fits** (remaining capacity == item) receive the highest possible\n       priority (`np.inf`), guaranteeing they are chosen first.\n    2. **Near fits** are scored by the inverse of the slack (remaining capacity\n       after placing the item).  Smaller slack \u21d2 larger base priority.\n    3. **Adaptive random exploration**: a small jitter proportional to an\n       exploration rate is added to the base priority of near\u2011fit bins.\n       The exploration rate grows when many bins can accommodate the item,\n       encouraging diversification when the choice is ambiguous.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as `bins_remain_cap` containing priority scores.\n        The bin with the highest score (e.g., via ``np.argmax``) should be selected.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure numpy array with float dtype for consistent calculations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all priorities as infeasible\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n\n    # Compute slack (remaining capacity after hypothetically placing the item)\n    slack = bins_remain_cap - item\n\n    # Feasible bins: slack >= 0\n    feasible_mask = slack >= 0\n    if not np.any(feasible_mask):\n        # No bin can accommodate the item\n        return priorities\n\n    # Exact\u2011fit bins: slack \u2248 0\n    exact_mask = feasible_mask & np.isclose(slack, 0.0, atol=1e-12)\n    priorities[exact_mask] = np.inf\n\n    # Non\u2011exact feasible bins\n    non_exact_mask = feasible_mask & ~exact_mask\n    if np.any(non_exact_mask):\n        # Base priority = 1 / (slack + \u03b5) \u2013 larger for tighter fits\n        eps = 1e-12\n        base_priority = 1.0 / (slack[non_exact_mask] + eps)\n\n        # Adaptive exploration factor:\n        #   More feasible bins \u21d2 higher exploration chance.\n        n_feasible = np.count_nonzero(feasible_mask)\n        n_total = bins_remain_cap.size\n        # Scale between 0.05 and 0.30\n        exploration_rate = 0.05 + 0.25 * (n_feasible - 1) / max(1, n_total - 1)\n        exploration_rate = min(exploration_rate, 0.30)\n\n        # Random jitter in [-1, 1] scaled by exploration_rate and base priority\n        jitter = (np.random.rand(base_priority.size) - 0.5) * 2.0\n        jitter_scaled = jitter * exploration_rate * base_priority\n\n        # Final priority with jitter added\n        final_priority = base_priority + jitter_scaled\n        priorities[non_exact_mask] = final_priority\n\n    return priorities",
    "response_id": 6,
    "obj": 4.058635819704831,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that:\n    - Prioritizes exact fits first.\n    - For remaining bins, prefers the smallest slack (closest to full).\n    - Randomly explores other bins with probability epsilon.\n    - Uses a tolerance to detect exact fits and to avoid floating\u2011point ties.\n    \"\"\"\n    eps = 0.15          # exploration probability\n    exact_bonus = 1e6   # high value to guarantee exact fit preference\n    tolerance = 1e-12   # tolerance for floating\u2011point comparison\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    leftover = caps - item\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = leftover >= -tolerance\n    if not np.any(feasible):\n        return priorities\n\n    # Exploration: assign random priorities to feasible bins\n    if np.random.rand() < eps:\n        rand_scores = np.random.rand(np.count_nonzero(feasible))\n        priorities[feasible] = rand_scores\n        return priorities\n\n    # Indices of feasible bins\n    idx = np.where(feasible)[0]\n    slack = leftover[feasible]\n\n    # Exact fit bins\n    exact_mask = np.isclose(slack, 0.0, atol=tolerance)\n    if np.any(exact_mask):\n        priorities[idx[exact_mask]] = exact_bonus\n\n    # Non\u2011exact feasible bins: prioritize smallest slack\n    non_exact_mask = ~exact_mask\n    if np.any(non_exact_mask):\n        jitter = 1e-12 * np.random.rand(np.count_nonzero(non_exact_mask))\n        priorities[idx[non_exact_mask]] = -slack[non_exact_mask] + jitter\n\n    return priorities",
    "response_id": 7,
    "obj": 4.168328679696844,
    "SLOC": 24.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon0: float = 0.20,\n    decay: float = 0.001,\n    smoothing: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    Bins that would leave the smallest remaining capacity after the item is\n    placed receive higher priority (inverse slack).  To avoid premature\n    convergence, an exploration component is blended in with a decaying\n    epsilon.  Infeasible bins are penalised with ``-inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon0 : float, optional\n        Initial exploration probability (default 0.20).\n    decay : float, optional\n        Decay rate of epsilon per call (default 0.001). Larger values reduce\n        exploration faster.\n    smoothing : float, optional\n        Small constant added to the slack term to avoid division by zero\n        and to smooth the inverse\u2011slack calculation.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing the priority\n        score for each bin.  Bins that cannot accommodate ``item`` receive\n        ``-inf``.\n    \"\"\"\n    # Convert input to a NumPy float array for consistent operations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Slack after placing the item\n    slack = bins_remain_cap - item\n    feasible_mask = slack >= 0\n\n    # No feasible bin \u2192 return all -inf\n    if not np.any(feasible_mask):\n        return priorities\n\n    # ------------------------------------------------------------------\n    # Adaptive epsilon: decays over the number of calls to this\n    # function.  The counter is stored as a function attribute.\n    # ------------------------------------------------------------------\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    step = priority_v2._call_counter\n    priority_v2._call_counter += 1\n\n    epsilon = epsilon0 / (1.0 + decay * step)\n    # Keep epsilon within [0, epsilon0] bounds\n    epsilon = max(0.0, min(epsilon0, epsilon))\n\n    # ------------------------------------------------------------------\n    # Compute the exploitation component: inverse slack, normalised.\n    # ------------------------------------------------------------------\n    inv_slack = 1.0 / (1.0 + slack[feasible_mask] + smoothing)  # >0\n    inv_slack_norm = inv_slack / inv_slack.sum()\n\n    # ------------------------------------------------------------------\n    # Compute the exploration component: random scores, normalised.\n    # ------------------------------------------------------------------\n    rand_scores = np.random.rand(np.count_nonzero(feasible_mask))\n    rand_norm = rand_scores / rand_scores.sum()\n\n    # ------------------------------------------------------------------\n    # Blend exploitation and exploration.\n    # ------------------------------------------------------------------\n    combined = (1.0 - epsilon) * inv_slack_norm + epsilon * rand_norm\n\n    # Assign combined priorities to feasible bins\n    priorities[feasible_mask] = combined\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]