```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    alpha: float = 12.0,
    mid_point: float = 0.5,
    epsilon: float = 0.15,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    The function returns a score for each currently open bin. The bin with the
    highest score should be selected for the incoming *item*.  Scores are
    computed as follows:

    1. **Feasibility** – only bins with enough remaining capacity are considered.
    2. **Exact fit** – bins where the item exactly matches the remaining capacity
       receive a very large bonus (`exact_bonus`) to guarantee selection.
    3. **Smooth logistic fit** – for the remaining feasible bins a logistic
       (sigmoid) transform of the normalized slack is used; tighter fits get
       higher scores.
    4. **Exploration** – with probability ``epsilon`` the scores of feasible
       bins (except exact‑fit bins) are replaced by random values, encouraging
       exploration of alternative placements.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the open bins.
    alpha : float, optional
        Steepness of the logistic curve (default 12.0).
    mid_point : float, optional
        Centre of the logistic curve; a fit_score equal to this value yields
        a priority of 0.5 (default 0.5).
    epsilon : float, optional
        Exploration probability; when ``np.random.rand() < epsilon`` random
        scores are used for feasible bins (default 0.15).
    exact_bonus : float, optional
        Large constant added to exact‑fit bins to ensure they dominate (default 1e6).
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons (default 1e-12 * 1e-12).

    Returns
    -------
    np.ndarray
        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 0) Normalise input
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # ------------------------------------------------------------------
    # 1) Feasibility mask – a bin must have enough free space.
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (ensures infeasible bins are never chosen)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # No feasible bin -> return all -inf
    if not feasible.any():
        return priority

    # ------------------------------------------------------------------
    # 2) Slack after placing the item (only meaningful for feasible bins)
    # ------------------------------------------------------------------
    slack = caps - item

    # ------------------------------------------------------------------
    # 3) Exact‑fit detection
    # ------------------------------------------------------------------
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # ------------------------------------------------------------------
    # 4) Logistic scoring for non‑exact feasible bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Estimate the (common) bin capacity.
        # Using the current maximum remaining capacity is a safe upper bound.
        capacity_est = caps.max()
        capacity_est = max(capacity_est, 1e-12)  # protect against division by zero

        # Normalise slack to [0, 1] (0 = perfect fit, 1 = completely empty bin)
        norm_slack = slack[non_exact] / capacity_est
        fit_score = 1.0 - norm_slack  # larger => tighter fit

        # Logistic transform
        sigmoid_arg = alpha * (fit_score - mid_point)
        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))

        # Add a tiny jitter to break ties when scores are identical
        jitter = 1e-9 * np.random.rand(logistic_score.size)
        priority[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # 5) ε‑greedy exploration (random scores for feasible non‑exact bins)
    # ------------------------------------------------------------------
    if np.random.rand() < epsilon:
        # Random scores in [0, *] for all feasible bins (excluding exact fits)
        rand_vals = np.random.rand(feasible.sum())
        feasible_idx = np.where(feasible)[0]

        # Overwrite non‑exact feasible bins with random values
        non_exact_idx = np.where(non_exact)[0]
        # Map random values to feasible indices; preserve order
        # The first len(feasible_idx) entries of rand_vals correspond to feasible bins
        # in the order given by feasible_idx.
        # Since exact‑fit bins also appear in feasible_idx, we replace all feasible,
        # then re‑apply the exact bonus.
        priority[feasible_idx] = rand_vals

        # Reinstate the exact‑fit bonus (ensures they remain top priority)
        priority[exact_fit] = exact_bonus

    return priority
```
