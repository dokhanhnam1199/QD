```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                epsilon0: float = 0.20,
                decay: float = 0.001,
                smoothing: float = 1e-6,
                exact_boost: float = 10.0) -> np.ndarray:
    """
    Adaptive epsilon‑greedy priority function for the online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    epsilon0 : float, optional
        Initial exploration probability (default 0.20).
    decay : float, optional
        Decay rate of epsilon per function call (default 0.001).
    smoothing : float, optional
        Small constant added to slack to avoid division by zero (default 1e-6).
    exact_boost : float, optional
        Multiplicative factor to boost exact‑fit bins (default 10.0).

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Infeasible bins receive ``-inf``.
    """
    # Ensure vectorised NumPy array.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Initialise priorities with -inf (infeasible by default).
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Compute slack after hypothetically placing the item.
    slack = bins_remain_cap - item

    # Feasible bins: slack >= 0
    feasible_mask = slack >= 0
    if not np.any(feasible_mask):
        return priorities

    # Exact‑fit bins: slack ≈ 0 (within tolerance)
    exact_mask = feasible_mask & np.isclose(slack, 0.0, atol=1e-12)

    # Slack values for feasible bins only.
    feasible_slack = slack[feasible_mask]                # shape (n_feasible,)

    # Exploitation component: inverse slack (larger for tighter fits).
    inv_slack = 1.0 / (feasible_slack + smoothing)

    # Boost exact‑fit bins to dominate the exploitation term.
    exact_feasible_mask = exact_mask[feasible_mask]      # bool mask over feasible bins
    if np.any(exact_feasible_mask):
        inv_slack[exact_feasible_mask] *= exact_boost

    # Normalise exploitation scores.
    exploitation_norm = inv_slack / inv_slack.sum()

    # Exploration component: random scores, also normalised.
    rand_scores = np.random.rand(inv_slack.size)
    exploration_norm = rand_scores / np.sum(rand_scores)

    # Adaptive epsilon that decays with the number of calls.
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    step = priority_v2._call_counter
    priority_v2._call_counter += 1

    epsilon = epsilon0 / (1.0 + decay * step)
    epsilon = np.clip(epsilon, 0.0, epsilon0)

    # Blend exploitation and exploration.
    combined = (1.0 - epsilon) * exploitation_norm + epsilon * exploration_norm

    # Assign blended scores back to the original bin ordering.
    priorities[feasible_mask] = combined

    return priorities
```
