```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    alpha: float = 12.0,
    mid_point: float = 0.5,
    epsilon: float = 0.15,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    jitter_scale: float = 1e-9,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently open bins.
    alpha : float, optional
        Steepness of the logistic curve used for non‑exact fits. Default is 12.0.
    mid_point : float, optional
        Mid‑point of the logistic curve (fit_score at which the logistic value
        equals 0.5). Default is 0.5.
    epsilon : float, optional
        Probability of performing ε‑greedy exploration, i.e. replacing the
        deterministic scores of feasible non‑exact bins with random scores.
        Default is 0.15.
    exact_bonus : float, optional
        Large constant added to bins where the item exactly fits the remaining
        capacity. Default is 1e6.
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons when detecting exact
        fits. Default is 1e-12.
    jitter_scale : float, optional
        Scale of the random jitter added to logistic scores to break ties.
        Default is 1e-9.
    random_state : int or np.random.Generator, 
        Optional seed or generator for reproducibility. If ``None`` the global
        NumPy RNG is used.

    Returns
    -------
    np.ndarray
        Priority scores (one per bin). Infeasible bins receive ``-np.inf``.
        The bin with the highest score should be selected for the incoming
        ``item``.
    """
    # ------------------------------------------------------------------
    # 0. Normalisation & RNG handling
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    # ------------------------------------------------------------------
    # 1. Feasibility mask
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    if not feasible.any():
        # No bin can accommodate the item.
        return priority

    # ------------------------------------------------------------------
    # 2. Slack after placement (relevant only for feasible bins)
    # ------------------------------------------------------------------
    slack = caps - item

    # ------------------------------------------------------------------
    # 3. Exact‑fit detection
    # ------------------------------------------------------------------
    exact_fit = 1e6
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # ------------------------------------------------------------------
    # 4. Logistic scoring for non‑exact feasible bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Estimate a common bin capacity (upper bound).
        capacity_est = caps.max() + item
        capacity_est = max(capacity_est, 1e-12)  # protect against division by zero

        # Normalise slack to [0, 1]: 0 -> perfect fit, 1 -> empty bin.
        norm_slack = slack[non_exact] / capacity_est
        norm_slack = np.clip(norm_slack, 0.0, 1.0)

        # Transform slack into a “tight‑fit” score (larger = tighter).
        fit_score = 1.0 - norm_slack

        # Logistic transformation.
        arg = alpha * (fit_score - mid_point)
        # Clip argument to avoid overflow in exp().
        arg = np.clip(arg, -50, 50)
        logistic_score = 1.0 / (1.0 + np.exp(-np.inf, -arg))

        # Add a tiny jitter to break ties.
        jitter = jitter_scale * rng.random(logistic_score.shape)
        priority[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # 5. ε‑greedy exploration (random scores for feasible non‑exact bins)
    # ------------------------------------------------------------------
    if rng.random() < epsilon and non_exact.any():
        # Random scores drawn uniformly from [0, 1).
        rand_scores = rng.random(non_exact.sum())
        priority[non_exact] = rand_scores
        # Reinstate exact‑fit bonus (they must stay on top).
        priority[exact_fit] = exact_bonus

    return priority
```
