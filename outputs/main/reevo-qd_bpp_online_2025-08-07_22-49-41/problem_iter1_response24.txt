```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Exact‑Fit‑First priority for the online Bin Packing Problem.

    A bin that can accommodate the item *exactly* receives the highest score.
    Among the feasible bins, those that leave the smallest leftover capacity are
    preferred.  Bins that cannot hold the item are assigned a very low priority.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities of the current bins.

    Returns:
        A NumPy array of the same shape as ``bins_remain_cap`` containing the
        priority score for each bin.  The bin with the highest score will be
        selected for placement.
    """
    # Ensure floating‑point arithmetic.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Remaining capacity after hypothetically placing the item.
    # Positive => feasible; negative => infeasible.
    leftover = caps - item

    # Initialise all priorities to a very low value (infeasible).
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Mask of feasible bins.
    feasible = leftover >= 0

    # Exact fits (leftover == 0) should outrank any other feasible bin.
    # Use -leftover as the base priority: exact fits get 0, others get a negative value.
    # Since we pick the highest priority, 0 > any negative, achieving Exact‑Fit‑First.
    priorities[feasible] = -leftover[feasible]

    # Optional tweak: if you prefer a strictly larger value for exact fits
    # (e.g., to avoid ties caused by floating‑point noise), you can add a tiny
    # epsilon or set them to a large constant:
    # exact_fit = np.isclose(leftover, 0, atol=1e-12)
    # priorities[exact_fit] = np.inf

    return priorities
```
