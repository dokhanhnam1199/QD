```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Computes priority scores for each bin using a Softmax‑based fitting strategy.
    Bins that can accommodate the item are ranked by how tightly the item fills them
    (smaller remaining capacity after placement => higher priority).  Bins that cannot
    fit the item are given a zero contribution (softmax weight zero).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Array of the same shape as bins_remain_cap with a non‑negative priority
        weight for each bin; the higher the value the more desirable the bin.
    """
    # Ensure numeric array of floats for stability
    remain = np.asarray(bins_remain_cap, dtype=np.float64)

    # Identify bins that can accommodate the item
    can_fit = remain >= item

    # Utility: lower remaining capacity after placement => higher priority
    # Use negative remaining to get this inversion
    # Assign -inf (so exp(-inf)=0) to bins that cannot fit
    utility = np.where(can_fit, -(remain - item), -np.inf)

    # Temperature controls softness; smaller => closer to argmax
    T = 0.1

    # Scale utilities for softmax and shift for numerical stability
    scaled = utility / T
    shift = scaled - np.max(scaled)

    # Compute softmax probabilities (zero for non‑fitting bins)
    probs = np.exp(shift)
    total = np.sum(probs)

    # If no bin can fit the item, fall back to zeros (outside logic will open a new bin)
    if total == 0:
        return np.zeros_like(remain)

    return probs / total
```
