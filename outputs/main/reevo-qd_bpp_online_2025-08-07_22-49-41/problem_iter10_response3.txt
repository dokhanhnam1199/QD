```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    tolerance: float = 1e-12,
    epsilon: float = 0.0,
    exact_bonus: float = 1e6,
    jitter_scale: float = 1e-9,
) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online Bin Packing Problem (BPP).
    The bin with the highest score will be chosen for the incoming *item*.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of all currently open bins.
    tolerance : float, optional
        Numerical tolerance for feasibility and exact‑fit detection.
    epsilon : float, optional
        Exploration probability. With probability ``epsilon`` random scores are
        assigned to feasible bins to encourage exploration.
    exact_bonus : float, optional
        Large constant added to exact‑fit bins to guarantee their selection.
    jitter_scale : float, optional
        Scale of the deterministic index‑based jitter used for tie‑breaking.

    Returns
    -------
    np.ndarray
        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask (allow a small tolerance)
    feasible = caps >= item - tolerance

    # Initialise priorities with -inf (infeasible bins)
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # No feasible bin => return all -inf
    if not np.any(feasible):
        return priorities

    # Slack after placing the item
    slack = caps - item

    # Exact‑fit detection
    exact_fit = np.abs(slack) <= tolerance
    priorities[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        slack_n = slack[non_exact]  # positive slack values

        # Determine scaling factor from median slack.
        median_slack = np.median(slack_n)
        # Ensure median_slack is positive to avoid division by zero.
        median_slack = max(median_slack, tolerance)

        # Choose alpha so that slack = median_slack yields score ≈ 0.5.
        # Using exponential decay: score = exp(-alpha * slack).
        alpha = np.log(2.0) / median_slack
        # Clamp alpha to a reasonable range to avoid extreme exponents.
        alpha = np.clip(alpha, 1e-6, 1e6)

        # Exponential decay score (smooth, decreasing with slack)
        exp_arg = -alpha * slack_n
        # Clip exponent to avoid underflow/overflow in np.exp.
        exp_arg = np.clip(exp_arg, -700, 0)
        score = np.exp(exp_arg)  # in (0, 1]

        # Deterministic tie‑breaker: small index‑based jitter.
        idx_non_exact = np.nonzero(non_exact)[0]
        max_cap = np.max(caps) if np.max(caps) > 0 else 1.0
        jitter = jitter_scale * idx_non_exact.astype(np.float64) / max_cap

        priorities[non_exact] = score + jitter

    # Optional epsilon‑greedy exploration (random scores for feasible bins)
    if epsilon > 0.0 and np.random.rand() < epsilon:
        feasible_idx = np.nonzero(feasible)[0]
        rand_scores = np.random.rand(feasible_idx.size)
        priorities[feasible_idx] = rand_scores
        # Preserve exact‑fit bonus after randomisation.
        priorities[exact_fit] = exact_bonus

    return priorities
```
