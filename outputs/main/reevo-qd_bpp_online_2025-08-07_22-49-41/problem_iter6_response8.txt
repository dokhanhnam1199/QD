```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Smooth adaptive sigmoid priority for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins receive -np.inf.
    """
    bins = np.asarray(bins_remain_cap, dtype=np.float64)

    # Identify bins that can accommodate the item
    fits = bins >= item

    # No feasible bin → all priorities are -inf
    if not np.any(fits):
        return np.full(bins.shape, -np.inf, dtype=np.float64)

    # Slack left after placing the item
    slack = bins - item

    # Compute relative slack only for feasible bins
    rel_slack = np.zeros_like(bins)
    if np.any(fits):
        denom = bins[fits]
        denom_safe = np.where(denom == 0, np.finfo(np.float64).eps, denom)
        rel_slack[fits] = slack[fits] / denom_safe

    # Adaptive steepness: higher when bins are relatively full
    median_rel = np.median(rel_slack[fits])
    alpha = 5.0 * (2.0 - median_rel)          # 5 ≤ alpha ≤ 10
    alpha = np.clip(alpha, 5.0, 10.0)

    # Sigmoid score: 1 at perfect fit, decreasing as slack grows
    scores = np.full(bins.shape, -np.inf, dtype=np.float64)
    if np.any(fits):
        logits = alpha * rel_slack[fits]
        logistic = 1.0 / (1.0 + np.exp(logits))
        scores[fits] = logistic * 2.0          # perfect fit → 1.0
        np.clip(scores[fits], 0.0, 1.0, out=scores[fits])

    return scores
```
