```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function for the Almost Full Fit strategy.

    The function prefers bins that will be closest to full after placing the
    given item. Bins that cannot accommodate the item receive a very low
    priority. A small epsilon tolerance is used to give a large bonus to
    bins that would become (almost) completely full.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities for each bin.

    Returns:
        A float array of the same shape as `bins_remain` containing the
        priority score for each bin; higher scores indicate a more desirable
        bin.
    """
    # Convert to float to avoid integer overflow issues
    caps = bins_remain_cap.astype(float, copy=False)

    # Residual capacity after hypothetically placing the item
    residual = caps - item

    # Define a very low priority for infeasible bins (cannot fit the item)
    # Using a large negative number rather than -inf to keep dtype float.
    low_priority = -1e12
    priorities = np.full_like(caps, low_priority, dtype=float)

    # Feasible bins have residual >= 0
    feasible = residual >= 0
    # For feasible bins, the priority is the negative residual:
    # smaller residual (i.e., bin becomes more full) yields a larger priority.
    priorities[feasible] = -residual[feasible]

    # Bonus for bins that become almost completely full.
    # epsilon accounts for floating‑point inaccuracies.
    epsilon = 1e-6
    almost_full = feasible & (residual <= epsilon)
    # Add a substantial boost to guarantee selection if such a bin exists.
    priorities[almost_full] += 1e6

    return priorities
```
