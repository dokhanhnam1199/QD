```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority with Inverse Distance (Proximity Fit) strategy.

    Bins that will have the smallest remaining capacity *after* the item is placed
    receive the highest priority.  Inverse distance (1/(1+slack)) is used to
    accentuate bins whose slack is close to zero.  Bins that cannot accommodate
    the item are given a negative priority of -inf, ensuring they are never
    selected.

    Args:
        item: Size of the item to be added.
        bins_remain_cap: 1â€‘D array of remaining capacities of existing bins.

    Returns:
        A NumPy array of the same shape as `bins_remain_cap`, containing
        the priority score for each bin.
    """
    # Slack: remaining capacity after adding the item
    slack = bins_remain_cap - item
    # Boolean mask of bins that can accommodate the item
    mask = slack >= 0

    # If no bin can fit, return -inf for all bins
    if not np.any(mask):
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Priority: larger when slack is smaller
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    # Avoid division by zero by adding 1
    priorities[mask] = 1.0 / (1.0 + slack[mask])

    # For bins that cannot accommodate the item, set a large negative value
    priorities[~mask] = -np.inf
    return priorities
```
