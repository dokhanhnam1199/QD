```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function that uses an ε‑greedy strategy for online bin packing.

    Parameters
    ----------
    item : float
        The size of the item that is about to be inserted.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each existing bin.

    Returns
    -------
    priorities : np.ndarray
        Array of the same shape as `bins_remain_cap`.  The bin with the
        highest value will be selected by the caller.
    """
    # Encourage explorations with a small fixed ε.
    epsilon = 0.15   # ~15% chance to explore a random bin

    # Ensure we have a float array for consistent behaviour
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Start with very low priority for all bins; infeasible bins stay low
    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)

    # Find indices of bins that can accommodate the item
    fit_mask = bins_remain_cap >= item
    if not np.any(fit_mask):
        return priorities  # No bin can take the item; all are -inf

    if np.random.rand() < epsilon:
        # Exploration: assign random priorities to every feasible bin
        # (uniform in [0, 1)) so the selection is effectively random
        random_scores = np.random.rand(np.count_nonzero(fit_mask))
        priorities[fit_mask] = random_scores
    else:
        # Greedy: best‑fit – choose the bin that leaves the smallest
        # remaining capacity after placing the item
        slack = bins_remain_cap[fit_mask] - item   # remaining capacity left after fit
        # Smaller slack => higher priority (closer to being full)
        # We use -slack to turn minimization of slack into maximization
        priorities[fit_mask] = -slack

    return priorities
```
