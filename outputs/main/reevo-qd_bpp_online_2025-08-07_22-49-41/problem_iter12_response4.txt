```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    The heuristic prefers bins that become as full as possible after placing the item.
    It uses an exponential decay of the normalized slack, adapts the decay steepness
    to the relative size of the item, guarantees exact fits the highest score,
    injects a tiny ε‑greedy random component for exploration, and adds a minuscule
    jitter for deterministic tie‑breaking.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher = more desirable). Infeasible bins
        (remaining capacity < item) receive ``-np.inf``.
    """
    # Guard against empty input
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Estimate the (common) bin capacity.
    # For a classic BPP all bins have the same capacity; we approximate it
    # with the maximum observed remaining capacity.
    capacity = np.max(bins_remain_cap)
    if capacity <= 0:
        # No capacity left in any bin.
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Tolerance for floating‑point comparisons
    tol = 1e-12

    # Feasibility mask: bins that can accommodate the item (allowing a tiny tolerance)
    can_fit = bins_remain_cap >= item - tol

    # Initialise priorities: infeasible bins get -inf
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early.
    if not np.any(can_fit):
        return priorities

    # Compute slack after placing the item for feasible bins
    slack = bins_remain_cap[can_fit] - item

    # Normalized slack in [0, 1] (capacity > 0 guaranteed)
    slack_norm = slack / capacity

    # Adaptive steepness: larger items receive a steeper decay.
    # base_alpha controls the overall sharpness; we shift by +0.1 to avoid zero.
    base_alpha = 12.0
    alpha = base_alpha * (item / capacity + 0.1)

    # Exact‑fit detection
    exact_fit = slack <= tol

    # Deterministic component: exponential decay of normalized slack.
    # Exact fits receive the maximal deterministic score of 1.0.
    deterministic_score = np.where(
        exact_fit,
        1.0,
        np.exp(-alpha * slack_norm)
    )

    # ε‑greedy exploration: blend a tiny random score.
    # eps_explore is set very low to keep the heuristic predominantly deterministic.
    eps_explore = 1e-6
    random_score = np.random.rand(deterministic_score.shape[0])
    combined_score = (1.0 - eps_explore) * deterministic_score + eps_explore * random_score

    # Jitter for tie‑breaking (uniform in a tiny symmetric interval)
    jitter_range = 1e-9
    jitter = np.random.uniform(-jitter_range, jitter_range, size=combined_score.shape)
    combined_score += jitter

    # Assign the computed scores back to the feasible positions
    priorities[can_fit] = combined_score

    return priorities
```
