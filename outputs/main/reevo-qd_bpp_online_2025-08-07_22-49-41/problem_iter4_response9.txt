```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the item to be placed.
    bins_remain_cap : np.ndarray
        1â€‘D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores; higher values indicate a more attractive bin.
        Bins that cannot accommodate the item receive a score of 0.
    """
    # Ensure we work with a NumPy array of float values
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Initialize all priorities to zero (for infeasible bins)
    priorities = np.zeros_like(caps, dtype=np.float64)

    # Feasibility mask: bin can accommodate the item
    feasible = caps >= item
    if not np.any(feasible):
        return priorities  # No bin can take the item

    # Slack remaining after placing the item
    slack = caps[feasible] - item

    # Normalise slack by the maximum slack among feasible bins
    max_slack = np.max(slack) if slack.size > 0 else 0.0
    if max_slack > 0.0:
        fit_score = 1.0 - slack / max_slack  # 0 <= fit_score <= 1
    else:
        # All feasible bins are perfectly tight
        fit_score = np.ones_like(slack)

    # Logistic transform to sharpen preference for tight fits
    alpha = 12.0          # steepness of the sigmoid
    mid_point = 0.5       # centre of the sigmoid
    sigmoid_arg = alpha * (fit_score - mid_point)
    priorities[feasible] = 1.0 / (1.0 + np.exp(-sigmoid_arg))

    return priorities
```
