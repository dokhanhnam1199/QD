```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority scores for the First-Fit strategy.

    Each bin that can accommodate the item receives a score that favours
    earlier bins (lower index). Infeasible bins are penalised with -inf.
    A strong index weight ensures that the first feasible bin always has
    the highest priority, while still allowing a small tie‑breaking component
    based on residual capacity.

    Parameters
    ----------
    item : float
        Size of the item to pack.
    bins_remain_cap : np.ndarray
        Remaining capacities of the existing bins.

    Returns
    -------
    np.ndarray
        Array of priority scores, one per bin. The bin with the largest score
        should be selected.
    """
    # priority with First-Fit ordering
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Determine which bins can fit the item
    feasible = bins_remain_cap >= item

    # No existing bin fits: return all -inf to signal opening a new bin
    if not feasible.any():
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Index weighting: a large constant that dominates any residual‑capacity term
    # Guarantees earlier bins outrank later ones regardless of waste.
    max_cap = bins_remain_cap.max() if bins_remain_cap.size > 0 else 1.0
    index_weight = max_cap + 1.0  # > any possible residual difference

    # Bin indices (0 = first bin)
    idx = np.arange(bins_remain_cap.shape[0])

    # Base priority: larger for earlier bins (higher index_weight * (N - idx))
    N = bins_remain_cap.shape[0]
    base = (N - idx) * index_weight

    # Residual capacity after placing the item (tiny tie‑breaker)
    residual = bins_remain_cap - float(item)

    # Combine base *and* residual, but only for feasible bins
    priorities = np.where(feasible, base + residual, -np.inf)

    return priorities
```
