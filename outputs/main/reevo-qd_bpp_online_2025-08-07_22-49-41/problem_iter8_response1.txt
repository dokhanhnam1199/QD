```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin packing setting.

    This heuristic prioritises bins that will be nearly full after placing the
    item.  The score is an exponential decay of the normalised slack
    (`slack / capacity`).  Exact fits receive the maximum score of 1.0.
    A tiny ε‑greedy exploration and a minuscule jitter are added for
    deterministic tie‑breaking.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Higher scores indicate higher preference.
        Bins that cannot accommodate the item receive `-np.inf`.
    """
    # Guard against empty input
    if bins_remain_cap.size == 0:
        return np.empty(0, dtype=float)

    # Convert to float numpy array
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Determine bin capacity as the maximum remaining capacity observed
    capacity = np.max(bins_remain_cap)
    if capacity <= 0:
        # No capacity left to place any item
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Small tolerance for floating‑point comparisons
    tol = 1e-12

    # Feasibility mask: bins that can accommodate the item
    can_fit = bins_remain_cap + tol >= item
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if not np.any(can_fit):
        return priorities

    # Slack after placing the item for feasible bins
    slack = bins_remain_cap[can_fit] - item
    # Normalised slack in [0, 1]
    slack_norm = slack / capacity

    # Adaptive steepness: larger items → steeper decay
    base_alpha = 10.0
    alpha = base_alpha * (item / capacity + 0.1)  # ensure >0

    # Deterministic score: exponential decay of slack
    exact_fit = slack <= tol
    deterministic_score = np.where(
        exact_fit,
        1.0,
        np.exp(-alpha * slack_norm)
    )

    # ε‑greedy exploration (tiny random perturbation)
    eps_greedy = 1e-6
    random_score = np.random.rand(deterministic_score.size)
    combined_score = (1.0 - eps_greedy) * deterministic_score + eps_greedy * random_score

    # Tiny jitter for deterministic tie‑breaking
    eps_jitter = 1e-9
    jitter = np.random.uniform(-eps_jitter, eps_jitter, size=combined_score.shape)
    combined_score += jitter

    # Assign scores to feasible bins
    priorities[can_fit] = combined_score

    return priorities
```
