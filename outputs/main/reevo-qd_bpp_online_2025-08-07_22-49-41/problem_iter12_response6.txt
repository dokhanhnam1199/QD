```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    alpha: float = 12.0,
    mid_point: float = 0.5,
    epsilon: float = 0.15,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    bin_capacity: Optional[float] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    For each open bin the function returns a score. The bin with the highest
    score is selected to accommodate the incoming `item`.  The scoring
    procedure is a combination of:

    1. **Feasibility** – only bins with enough remaining capacity are considered.
    2. **Exact fit** – bins whose remaining capacity matches the item size
       exactly receive a large bonus (`exact_bonus`).
    3. **Logistic fit** – the remaining slack is normalised with respect to an
       estimated bin capacity and fed into a sigmoid.  Tighter fits get
       higher scores.
    4. **Jitter** – a tiny random noise is added to break ties.
    5. **ε‑greedy exploration** – with probability `epsilon` the scores of
       feasible bins (excluding exact‑fit bins) are replaced by random values,
       encouraging exploration.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently open bins.
    alpha : float, optional
        Steepness of the sigmoid (default 12.0).
    mid_point : float, optional
        Centre of the sigmoid.  A fit_score equal to this value yields a
        logistic output of 0.5 (default 0.5).
    epsilon : float, optional
        Exploration probability.  When ``np.random.rand() < epsilon`` the
        scores of feasible bins are replaced by random values (default 0.15).
    exact_bonus : float, optional
        Large constant added to exact‑fit bins to guarantee they are chosen
        (default 1e6).
    tolerance : float, optional
        Tolerance for floating‑point comparisons (default 1e-12).
    bin_capacity : float, optional
        Known full capacity of a bin.  If ``None`` the maximum remaining
        capacity of the open bins is used as an estimate.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: bin must have enough space
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible bins never selected)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # No feasible bin: return all -inf
    if not feasible.any():
        return priority

    # Slack after placing the item
    slack = caps - item

    # Exact‑fit detection (within tolerance)
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit

    if non_exact.any():
        # Estimate the bin capacity
        if bin_capacity is None:
            capacity_est = caps.max()
        else:
            capacity_est = bin_capacity
        capacity_est = max(capacity_est, tolerance)  # guard against zero

        # Normalise slack to [0,1]
        norm_slack = slack[non_exact] / capacity_est
        fit_score = 1.0 - norm_slack  # higher -> tighter fit

        # Logistic transform
        logits = alpha * (fit_score - mid_point)
        logistic = 1.0 / (1.0 + np.exp(-logits))

        # Small jitter to break ties
        jitter = 1e-9 * np.random.rand(logistic.size)
        priority[non_exact] = logistic + jitter

    # ε‑greedy exploration: random scores for all feasible bins
    if np.random.rand() < epsilon:
        rand_vals = np.random.rand(feasible.sum())
        feasible_idx = np.where(feasible)[0]
        priority[feasible_idx] = rand_vals
        # Reinstate exact‑fit bonus
        priority[exact_fit] = exact_bonus

    return priority
```
