```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    alpha: float = 12.0,
    mid_point: float = 0.5,
    start_epsilon: float = 0.3,
    min_epsilon: float = 0.01,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
) -> np.ndarray:
    """
    Decaying epsilon‑greedy priority function for the online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    alpha : float, optional
        Steepness of the logistic transform (default 12.0).
    mid_point : float, optional
        Logistic curve midpoint; a fit_score equal to this yields a priority of 0.5
        (default 0.5).
    start_epsilon : float, optional
        Initial exploration probability (default 0.3).
    min_epsilon : float, optional
        Lower bound for the decaying epsilon (default 0.01).
    exact_bonus : float, optional
        Large constant added to exact‑fit bins to guarantee selection (default 1e6).
    tolerance : float, optional
        Numerical tolerance for exact‑fit detection (default 1e-12).

    Returns
    -------
    np.ndarray
        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 0) Normalise
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # ------------------------------------------------------------------
    # 1) Decaying epsilon (exploration probability)
    # ------------------------------------------------------------------
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    priority_v2._call_counter += 1
    epsilon = max(min_epsilon, start_epsilon / np.sqrt(priority_v2._call_counter))

    # ------------------------------------------------------------------
    # 2) Feasibility mask
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible bins never chosen)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # No feasible bin → return early
    if not feasible.any():
        return priority

    # ------------------------------------------------------------------
    # 3) Compute slack and detect exact fits
    # ------------------------------------------------------------------
    slack = caps - item
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # ------------------------------------------------------------------
    # 4) Logistic scoring for non‑exact feasible bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    # Equivalent mask: feasible & ~exact_fit
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Estimate bin capacity for normalisation (use max remaining capacity)
        capacity_est = caps.max()
        capacity_est = max(capacity_est, 1e-12)  # guard against division by zero

        # Normalised slack ∈ [0, 1] (0 = perfect fit, 1 = empty bin)
        norm_slack = slack[non_exact] / capacity_est
        norm_slack = np.clip(norm_slack, 0.0, 1.0)

        # Fit score: larger → tighter fit
        fit_score = 1.0 - norm_slack

        # Logistic transform
        logistic_arg = alpha * (fit_score - mid_point)
        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Tiny jitter to break ties
        jitter = 1e-9 * np.random.rand(logistic_score.size)

        base_score = logistic_score + jitter
        priority[non_exact] = base_score

        # ------------------------------------------------------------------
        # 5) ε‑greedy exploration (replace non‑exact scores with random values)
        # ------------------------------------------------------------------
        if np.random.rand() < epsilon:
            # Random scores in [0, 1) for the same bins
            random_scores = np.random.rand(base_score.size)
            priority[non_exact] = random_scores

            # Re‑apply exact‑fit bonus to keep those bins on top
            priority[exact_fit] = exact_bonus

    # Ensure infeasible bins stay -inf (safety)
    priority[~feasible] = -np.inf

    return priority
```
