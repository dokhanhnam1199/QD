```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, list, tuple],
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha: float = 10.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    For each open bin this function returns a scalar priority. The bin with the
    highest priority is selected for the incoming *item*.

    Features
    --------
    * **Exact‑fit bonus** – bins where the item exactly matches the remaining
      capacity receive a huge constant ``exact_bonus``.
    * **Fit‑tightness** – feasible, non‑exact bins are scored by a logistic
      transform of the tightness of the fit. Tightness is defined as
      ``1 - slack / max_feasible_capacity``.
    * **Adaptive midpoint** – the logistic midpoint is the median tightness of
      the current feasible set, making the scoring adaptive.
    * **Deterministic jitter** – a tiny deterministic jitter based on the bin
      index breaks ties without randomness.
    * **Decaying ε‑greedy exploration** – with probability
      ``ε = ε₀ / (1 + decay_rate * step)`` the scores of feasible non‑exact bins
      are replaced by uniform random values.
    * **Infeasible bins** receive ``-np.inf`` so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like
        Remaining capacities of the currently open bins.
    step : int, optional
        Number of items processed so far (used for ε decay). Default ``0``.
    epsilon0 : float, optional
        Initial exploration probability. Default ``0.20``.
    decay_rate : float, optional
        Decay factor for ε. Default ``0.01``.
    alpha : float, optional
        Steepness of the logistic curve. Default ``10.0``.
    exact_bonus : float, optional
        Bonus added to exact‑fit bins. Default ``1e6``.
    tolerance : float, optional
        Numerical tolerance for feasibility and exact‑fit checks.
        Default ``1e-12``.
    random_state : int or np.random.Generator, optional
        Seed or generator for random numbers (used for exploration).

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 0) Normalise input and initialise RNG
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    # ------------------------------------------------------------------
    # 1) Feasibility mask – a bin must have enough free space.
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible bins are never chosen)
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # Early exit if nothing fits
    if not feasible.any():
        return priorities

    # ------------------------------------------------------------------
    # 2) Slack after placing the item
    # ------------------------------------------------------------------
    slack = caps - item  # non‑negative for feasible bins (up to tolerance)

    # ------------------------------------------------------------------
    # 3) Exact‑fit detection
    # ------------------------------------------------------------------
    exact_fit = np.abs(slack) <= tolerance
    priorities[exact_fit] = exact_bonus

    # ------------------------------------------------------------------
    # 4) Scoring for feasible, non‑exact bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Normalise slack by the *maximum* remaining capacity among feasible bins
        max_cap = caps[feasible].max()
        max_cap = max(max_cap, tolerance)  # avoid division by zero

        norm_slack = slack[non_exact] / max_cap            # ∈ [0, 1]
        fit_score = 1.0 - norm_slack                        # tightness, ∈ [0, 1]

        # Adaptive logistic midpoint = median fit_score (tightness)
        median_fit = np.median(fit_score)

        logistic_arg = alpha * (fit_score - median_fit)
        # Clip to avoid overflow in exp
        logistic_arg = np.clip(logistic_arg, -50, 50)
        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Deterministic tiny jitter based on bin index to break ties
        idx_non_exact = np.where(non_exact)[0]
        jitter = 1e-12 * (idx_non_exact.astype(np.float64) / (len(caps) + 1.0))

        priorities[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # 5) ε‑greedy exploration with decaying ε
    # ------------------------------------------------------------------
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    if rng.random() < epsilon and non_exact.any():
        # Replace scores of feasible non‑exact bins with uniform random values
        rand_vals = rng.random(non_exact.sum())
        priorities[non_exact] = rand_vals
        # Preserve exact‑fit bonus (exact fits still dominate)
        priorities[exact_fit] = exact_bonus

    return priorities
```
