```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    min_explore: float = 0.05,
    max_explore: float = 0.30,
    random_state: Optional[int] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing setting.

    Strategy
    --------
    1. **Exact fits** (remaining capacity ≈ item) receive the highest possible
       priority, guaranteeing they are selected first.
    2. **Near fits** are scored by the inverse of the slack (remaining capacity
       after placing the item).  Smaller slack → larger base priority.
    3. **Adaptive exploration**: a jitter term is added to the base priority of
       near‑fit bins.  The magnitude of the jitter grows with the proportion of
       feasible bins, encouraging diversification when many choices are
       available.
    4. Infeasible bins receive ``-np.inf``.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.
    tolerance : float, optional
        Absolute tolerance for detecting exact fits (default 1e‑12).
    epsilon : float, optional
        Small constant added to slack to avoid division‑by‑zero (default 1e‑12).
    min_explore : float, optional
        Minimum exploration (jitter) rate (default 0.05).
    max_explore : float, optional
        Maximum exploration rate (default 0.30).
    random_state : int or None, optional
        Seed for reproducible jitter. If ``None``, NumPy's global RNG is used.

    Returns
    -------
    np.ndarray
        Array of priority scores; infeasible bins have ``-np.inf``.
    """
    # Ensure a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Early return for empty input
    if caps.size == 0:
        return np.array([], dtype=float)

    # Initialise all priorities as infeasible
    priorities = np.full(caps.shape, -np.inf, dtype=np.float64)

    # Slack after hypothetically placing the item
    slack = caps - item

    # Feasible bins (allow tiny negative slack due to rounding)
    feasible_mask = slack >= -tolerance
    if not np.any(feasible_mask):
        return priorities

    # Exact‑fit detection
    exact_mask = feasible_mask & np.isclose(slack, 0.0, atol=tolerance)
    # Use a very large finite value so that later jitter (if any) cannot overtake it
    exact_priority = np.finfo(np.float64).max / 2.0
    priorities[exact_mask] = exact_priority

    # Non‑exact feasible bins
    non_exact_mask = feasible_mask & ~exact_mask
    if np.any(non_exact_mask):
        # Base priority = 1 / (slack + epsilon); tighter fits get larger scores
        base_priority = 1.0 / (slack[non_exact_mask] + epsilon)

        # Adaptive exploration rate based on the proportion of feasible bins
        n_feasible = np.count_nonzero(feasible_mask)
        total_bins = caps.size
        # Linear interpolation between min_explore and max_explore
        explore_rate = min_explore + (max_explore - min_explore) * (n_feasible / total_bins)
        explore_rate = np.clip(explore_rate, min_explore, max_explore)

        rng = np.random.default_rng(random_state)

        # Jitter uniformly in [-1, 1] scaled by explore_rate and the magnitude of base priority
        jitter = (rng.random(base_priority.size) * 2.0 - 1.0) * explore_rate * base_priority

        final_priority = base_priority + jitter
        priorities[non_exact_mask] = final_priority

    return priorities
```
