```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Return priority scores for assigning *item* to each bin (Exact Fit First).

    This heuristic prefers bins where the item fits exactly (no leftover space).
    If no exact fit exists, bins with the smallest waste (i.e., smallest remaining
    capacity after the item is placed) receive higher scores. Bins that cannot
    accommodate the item receive a very low score.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Array of priority values, same shape as *bins_remain_cap*.
        The bin with the highest value should be selected.
    """
    # Initialise all priorities to -inf (infeasible bins)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Feasibility mask: bins that can accommodate the item
    feasible = bins_remain_cap >= item
    if not np.any(feasible):
        # No feasible bin – return all -inf priorities
        return priorities

    # Waste after placing the item
    waste = bins_remain_cap - item

    # Exact fit mask (allowing for floating‑point tolerance)
    exact_fit = feasible & np.isclose(waste, 0.0)
    priorities[exact_fit] = np.inf  # Exact fits get the highest possible score

    # For the remaining feasible bins, assign a score inversely proportional
    # to the waste (smaller waste → higher score). Adding a tiny epsilon prevents
    # division by zero, but exact fits are already handled.
    other_feasible = feasible & ~exact_fit
    eps = np.finfo(np.float64).eps
    priorities[other_feasible] = 1.0 / (waste[other_feasible] + eps)

    return priorities
```
