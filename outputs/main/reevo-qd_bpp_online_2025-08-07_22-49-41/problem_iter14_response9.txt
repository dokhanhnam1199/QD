```python
import numpy as np


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha: float = 10.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    random_state: int | np.random.Generator | None = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    Returns a priority score for each bin; infeasible bins receive ``-np.inf``.
    The bin with the highest score should be chosen for the incoming item.
    """
    # Ensure a 1‑D float64 array
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Bins that can accommodate the item (allow a tiny tolerance)
    feasible = caps >= (item - tolerance)

    # Initialise all priorities with -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # If no bin can hold the item, we are done
    if not feasible.any():
        return priorities

    # Slack after hypothetically placing the item
    slack = caps - item

    # Exact‑fit bins get a huge bonus
    exact_fit = np.abs(slack) <= tolerance
    priorities[exact_fit] = exact_bonus

    # Non‑exact but feasible bins
    non_exact = feasible & ~exact_fit
    # Vectorised handling of non‑exact bins
    if non_exact.any():
        # Normalise slack by the largest remaining capacity among feasible bins
        max_cap = caps[feasible].max()
        max_cap = max(max_cap, 1e-12)  # avoid division by zero
        norm_slack = slack[non_exact] / max_cap          # ∈ [0, 1]
        fit_score = 1.0 - norm_slack                     # tighter fit → larger

        # Adaptive logistic transform: median of fit scores is the midpoint
        median_fit = np.median(fit_score)
        logistic_arg = alpha * (fit_score - median_fit)
        logistic_arg = np.clip(logistic_arg, -50, 50)    # safe for exp
        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Deterministic jitter for tie‑breaking (tiny, index‑based)
        idx_non_exact = np.where(non_exact)[0]
        jitter = 1e-12 * (idx_non_exact / (len(caps) + 1.0))

        priorities[non_exact] = logistic_score + jitter

    # ε‑greedy exploration with decaying ε
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    # Initialise RNG (seeded or passed generator)
    rng = (
        random_state
        if isinstance(random_state, np.random.Generator)
        else np.random.default_rng(random_state)
    )

    if rng.random() < epsilon:
        # Replace scores of non‑exact feasible bins with random values
        rand_vals = rng.random(non_exact.sum())
        priorities[non_exact] = rand_vals
        # Preserve exact‑fit bonus
        priorities[exact_fit] = exact_bonus

    return priorities
```
