[
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing the Almost Full Fit heuristic.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority values for each bin.  Higher priority means the bin is\n        chosen first.  For bins that cannot accommodate the item the\n        priority is set to -np.inf.\n\n    Notes\n    -----\n    In the almost full fit strategy we prefer bins that will be\n    almost filled after adding the item.  For a bin that can fit the\n    item, the \"after packing remaining capacity\" is computed as\n    `bins_remain_cap - item`.  The smaller this residual is, the higher\n    the priority.  The implementation translates this to a score of\n    `-(bins_remain_cap - item)`, so that a residual of 0 (perfect fit)\n    gives a score of 0, a residual of 0.2 gives -0.2, etc.  The\n    largest score is selected.\n    \"\"\"\n    # Safe boolean mask for feasible bins\n    can_fit = bins_remain_cap >= item\n    # Compute negative remaining after packing for applicable bins\n    # Unused bins get negative infinity to discourage selection.\n    priorities = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, higher values indicate higher preference.\n        Feasible bins have priority >= 0; infeasible bins receive -np.inf.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n    slack = bins_remain_cap - item\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return priorities\n\n    # Exact fit bins: slack effectively zero\n    exact_mask = feasible & np.isclose(slack, 0.0, atol=1e-12)\n    priorities[exact_mask] = np.inf\n\n    # Non-exact feasible bins: inverse slack to favor tighter fits\n    non_exact_mask = feasible & ~exact_mask\n    if np.any(non_exact_mask):\n        eps = 1e-12\n        priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + eps)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for the online Bin Packing Problem.\n\n    For each bin we compute the leftover capacity after (hypothetically) placing the item.\n    - If the item fits, the priority is the negative leftover (larger \u21d2 smaller leftover).\n    - If it does not fit, the bin receives a large negative penalty to exclude it.\n    An epsilon term based on the current fill level breaks ties in favour of the more\n    already\u2011filled bin, which is a common heuristic refinement.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacity of each bin.\n\n    Returns:\n        A 1\u2011D array of priority scores (same shape as `bins_remain_cap`).\n    \"\"\"\n    # Ensure we work with a float array for precision.\n    caps = bins_remain_cap.astype(float)\n\n    # Remaining capacity if we were to put the item into each bin.\n    residual = caps - item\n\n    # Feasibility mask: True where the item fits.\n    feasible = residual >= 0\n\n    # Large negative constant to disqualify infeasible bins.\n    penalty = -1e9\n    priorities = np.full_like(caps, penalty, dtype=float)\n\n    # Best\u2011Fit core: higher score for smaller residual (i.e., tighter fit).\n    # Using negative residual makes the smallest residual the largest priority.\n    priorities[feasible] = -residual[feasible]\n\n    # Tie\u2011breaker: prefer bins that are already more filled (i.e., have smaller original cap).\n    # Adding a tiny epsilon proportional to the current remaining capacity flips ties.\n    epsilon = 1e-6\n    priorities[feasible] += epsilon * caps[feasible]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for each bin according to Exact Fit First.\n\n    - Bins that can hold the item exactly (remaining capacity == item) get the highest priority.\n    - Bins that can hold the item with leftover get a priority inversely proportional to the leftover,\n      favouring tighter fits.\n    - Bins that cannot accommodate the item receive a very low priority (negative infinity).\n\n    The bin with the highest priority (e.g., via np.argmax) will be chosen.\n    \"\"\"\n    # Compute slack: remaining capacity after hypothetically placing the item\n    slack = bins_remain_cap - item\n\n    # Initialise all priorities as -inf (i.e., infeasible)\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=np.float64)\n\n    # Mask of bins that can actually accommodate the item (slack >= 0)\n    feasible_mask = slack >= 0\n\n    # If no bin can hold the item, return the all -inf array\n    if not np.any(feasible_mask):\n        return priorities\n\n    # Exact fit bins (slack effectively zero) receive infinite priority\n    exact_mask = feasible_mask & np.isclose(slack, 0.0)\n    priorities[exact_mask] = np.inf\n\n    # For other feasible bins, use inverse slack to favour tighter fits\n    non_exact_mask = feasible_mask & (~exact_mask)\n    epsilon = 1e-12  # safeguard against division by zero (exact fits already handled)\n    priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + epsilon)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority with Inverse Distance (Proximity Fit) strategy.\n\n    Bins that will have the smallest remaining capacity *after* the item is placed\n    receive the highest priority.  Inverse distance (1/(1+slack)) is used to\n    accentuate bins whose slack is close to zero.  Bins that cannot accommodate\n    the item are given a negative priority of -inf, ensuring they are never\n    selected.\n\n    Args:\n        item: Size of the item to be added.\n        bins_remain_cap: 1\u2011D array of remaining capacities of existing bins.\n\n    Returns:\n        A NumPy array of the same shape as `bins_remain_cap`, containing\n        the priority score for each bin.\n    \"\"\"\n    # Slack: remaining capacity after adding the item\n    slack = bins_remain_cap - item\n    # Boolean mask of bins that can accommodate the item\n    mask = slack >= 0\n\n    # If no bin can fit, return -inf for all bins\n    if not np.any(mask):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Priority: larger when slack is smaller\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Avoid division by zero by adding 1\n    priorities[mask] = 1.0 / (1.0 + slack[mask])\n\n    # For bins that cannot accommodate the item, set a large negative value\n    priorities[~mask] = -np.inf\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact\u2011Fit\u2011First priority for the online Bin Packing Problem.\n\n    A bin that can accommodate the item *exactly* receives the highest score.\n    Among the feasible bins, those that leave the smallest leftover capacity are\n    preferred.  Bins that cannot hold the item are assigned a very low priority.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of the current bins.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin.  The bin with the highest score will be\n        selected for placement.\n    \"\"\"\n    # Ensure floating\u2011point arithmetic.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after hypothetically placing the item.\n    # Positive => feasible; negative => infeasible.\n    leftover = caps - item\n\n    # Initialise all priorities to a very low value (infeasible).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Mask of feasible bins.\n    feasible = leftover >= 0\n\n    # Exact fits (leftover == 0) should outrank any other feasible bin.\n    # Use -leftover as the base priority: exact fits get 0, others get a negative value.\n    # Since we pick the highest priority, 0 > any negative, achieving Exact\u2011Fit\u2011First.\n    priorities[feasible] = -leftover[feasible]\n\n    # Optional tweak: if you prefer a strictly larger value for exact fits\n    # (e.g., to avoid ties caused by floating\u2011point noise), you can add a tiny\n    # epsilon or set them to a large constant:\n    # exact_fit = np.isclose(leftover, 0, atol=1e-12)\n    # priorities[exact_fit] = np.inf\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return a priority score for each bin using an \u03b5\u2011greedy strategy.\n    The algorithm mixes a greedy best\u2011fit rule with random exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as `bins_remain_cap` containing the\n        priority of each bin.  The bin with the highest value will be chosen.\n    \"\"\"\n    n_bins = bins_remain_cap.size\n\n    # Base priority vector: assign -\u221e to all bins initially.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        # No bins available \u2013 the calling procedure should handle this\n        # by opening a new bin.  Returning an empty array keeps the API\n        # consistent with the input shape.\n        return priorities\n\n    # Determine which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # If no bin can fit the item, no viable actions.  Priorities stay -\u221e.\n    if not can_fit.any():\n        return priorities\n\n    # ----------------- Greedy component: Best\u2011fit heuristic -------------\n    # For feasible bins compute a score proportional to how full the bin\n    # would become after placing the item (smallest leftover \u2192 highest priority).\n    leftover = bins_remain_cap - item            # Remaining capacity after insertion\n    greedy_scores = -leftover                    # We invert so that smaller leftover => higher value\n    greedy_scores[~can_fit] = -np.inf            # Exclude infeasible bins\n\n    # ----------------- Random component: Exploration --------------------\n    # Probability of exploring a random feasible bin\n    # Decaying epsilon: encourages exploration early and exploitation later.\n    epsilon = max(0.01, min(0.3, 0.2 / np.sqrt(n_bins)))\n\n    if np.random.rand() < epsilon:\n        # Exploration: pick a random feasible bin and give it a very high priority.\n        random_idx = np.random.choice(np.where(can_fit)[0])\n        # Assign a large positive value that guarantees selection.\n        priorities = np.full(n_bins, -np.inf, dtype=float)\n        priorities[random_idx] = 1.0\n    else:\n        # Exploitation: use the best\u2011fit scores\n        priorities = greedy_scores\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute bin priorities using a Sigmoid Fit Score strategy.\n\n    The priority is based on the residual space after inserting the item\n    into a bin.  Bins that leave almost no slack (i.e., perfect fit)\n    obtain the highest score.  The decay of the score is governed by a\n    sigmoid (logistic) function over the relative residual\n    `r = (remaining - item) / remaining`.\n\n    Bins that cannot accommodate the item receive a very low priority\n    (``-np.inf``) so that they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the candidate bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores in the range [0, 1], with 1 corresponding to a perfect fit.\n    \"\"\"\n    # Ensure we work on a NumPy array of floats\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Bin can hold the item?\n    fits = bins >= item\n\n    # Residual space if item fits\n    residual = bins - item\n\n    # Relative residual: 0 when perfect fit, increasing with slack\n    rel_residual = np.zeros_like(bins)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        rel_residual = np.where(\n            fits & (bins > 0),\n            residual / bins,\n            0.0\n        )\n\n    # Sigmoid decay parameter \u2013 steeper values emphasize tight fits.\n    alpha = 10.0\n    scores = np.where(\n        fits,\n        1.0 / (1.0 + np.exp(alpha * rel_residual)),\n        -np.inf   # unfit bins get minimal score\n    )\n\n    # Scale to [0, 1] so perfect fit yields 1.0\n    scores *= 2.0\n    np.clip(scores, 0.0, 1.0, out=scores)\n\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin according to the Best\u2011Fit strategy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; higher scores correspond to better bins.\n    \"\"\"\n    # Initialise with -\u221e for bins that cannot accommodate the item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins are actually usable\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Slack left after placing the item\n        slack = bins_remain_cap[can_fit] - item\n        # Best-fit => least slack => highest (least negative) priority\n        # Add a tiny deterministic jitter to break ties deterministically.\n        jitter = np.linspace(0, 1e-8, np.count_nonzero(can_fit))\n        priorities[can_fit] = -slack + jitter\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Sigmoid Fit Score priority for online Bin Packing.\n\n    For each currently open bin we compute a smooth priority that favours\n    *tight* fits (i.e., small remaining slack after placing the item).  The\n    raw slack is transformed by a logistic (sigmoid) function, producing a\n    value in ``[0, 1]`` \u2013 higher values indicate a more attractive bin.\n    Bins that cannot accommodate the item receive a priority of ``0``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. The bin with the highest score should be\n        selected for the item.\n    \"\"\"\n    # Convert to a NumPy array for vectorised work.\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # 1) Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= item\n\n    #  (Will be overwritten with actual priorities later.)\n    priority = np.zeros_like(caps, dtype=np.float64)\n\n    if not feasible.any():\n        # No bin can accept the item \u2013 return all zeros.\n        return priority\n\n    # ------------------------------------------------------------------\n    # 2) Compute slack (remaining capacity after placing the item) for\n    #    feasible bins only.\n    # ------------------------------------------------------------------\n    slack = np.empty_like(caps)\n    slack[:] = np.nan\n    slack[feasible] = caps[feasible] - item\n\n    # ------------------------------------------------------------------\n    # 3) Estimate the (fixed) bin capacity.\n    #    All bins share the same total capacity C; the current maximum\n    #    remaining capacity is a safe estimator for C.\n    # ------------------------------------------------------------------\n    capacity_est = caps.max() if caps.size > 0 else 1.0\n    capacity_est = max(capacity_est, 1e-12)      # protect against division by zero\n\n    # ------------------------------------------------------------------\n    # 4) Normalise the slack to [0, 1] (0 = perfect fit, 1 = empty bin).\n    # ------------------------------------------------------------------\n    norm_slack = slack / capacity_est\n\n    # ------------------------------------------------------------------\n    # 5) Compute a \u201cfit score\u201d that is large when slack is small.\n    #    fit_score = 1 - norm_slack \u2208 [0, 1]  (1 = perfect fit).\n    # ------------------------------------------------------------------\n    fit_score = 1.0 - norm_slack\n\n    # ------------------------------------------------------------------\n    # 6) Apply a sigmoid to the fit score.\n    #\n    #    priority = 1 / (1 + exp(-\u03b1\u00b7(fit_score - mid_point)))\n    #\n    #    * \u03b1  \u2013 steepness (larger \u21d2 sharper distinction between tight\n    #            and loose fits).\n    #    * mid_point \u2013 sigmoid centre (fit_score at which priority = 0.5).\n    # ------------------------------------------------------------------\n    alpha = 12.0        # controls how aggressively we prefer tight fits\n    mid_point = 0.5    # centre of the logistic curve\n\n    sigmoid_arg = alpha * (fit_score - mid_point)\n    priority[feasible] = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n    # ------------------------------------------------------------------\n    # 7) Infeasible bins keep priority 0 (already set at initialisation).\n    # ------------------------------------------------------------------\n    return priority",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    The function favours the *best\u2011fit* bin (the one that leaves the smallest\n    residual capacity after the item is placed) while occasionally exploring\n    other feasible bins.  The exploration probability (epsilon) decays with\n    the number of decisions made, making the algorithm increasingly greedy.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` with a priority score for\n        each bin.  The bin with the highest score should be selected.\n    \"\"\"\n    # ----- 1. Manage a decaying epsilon -----------------------------------------\n    # Attach a call counter to the function object for epsilon decay.\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    priority_v2._call_counter += 1\n\n    # Start with epsilon = 0.3 and shrink roughly as 1/sqrt(t)\n    epsilon = max(0.01, 0.3 / np.sqrt(priority_v2._call_counter))\n\n    # ----- 2. Identify feasible bins --------------------------------------------\n    feasible = bins_remain_cap >= item                     # bool mask\n    if not np.any(feasible):\n        # Nothing fits; caller may decide to open a new bin.\n        return np.zeros_like(bins_remain_cap, dtype=float)\n\n    # ----- 3. Exploitation: Best\u2011Fit score ---------------------------------------\n    # Residual capacity that would remain after packing the item.\n    residual = bins_remain_cap - item                       # shape == bins_remain_cap\n    # Higher score for tighter fit (i.e., smaller residual). Use negative residual.\n    exploit_score = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    exploit_score[feasible] = -residual[feasible]\n\n    # ----- 4. Exploration: Random noise -----------------------------------------\n    # Uniform random noise in [0,1) for each bin.\n    exploration_noise = np.random.rand(bins_remain_cap.shape[0])\n\n    # ----- 5. Combine exploitation and exploration -------------------------------\n    # Weighted sum: (1\u2011\u03b5) * exploit + \u03b5 * exploration\n    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise\n\n    # Infeasible bins must stay below any feasible candidate.\n    priorities[~feasible] = -np.inf\n\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute smooth bin priorities for online Bin Packing using a sigmoid\n    fit\u2011score.  Bins that leave very little slack after inserting the\n    item receive the highest scores.  The steepness of the sigmoid is\n    adapted online based on the typical relative slack of the feasible\n    bins, giving more emphasis to tight fits when bins are relatively\n    full.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be inserted.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; the bin with the largest score is chosen.\n        Bins that cannot accommodate the item receive ``-np.inf``.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Identify bins that can fit the item\n    fits = bins >= item\n\n    if not np.any(fits):\n        # No feasible bin\n        return np.full(bins.shape, -np.inf)\n\n    # Slack left after placing the item\n    slack = bins - item\n\n    # Relative slack (0 for perfect fit, \u22641 otherwise)\n    rel_slack = np.zeros_like(bins)\n    rel_slack[fits] = slack[fits] / bins[fits]\n\n    # Adapt the steepness parameter (alpha) based on typical slack\n    median_rel = np.median(rel_slack[fits])\n    # Base steepness: 5.0; scale so alpha \u2208 [5, 10] depending on median_rel.\n    alpha = 5.0 * (2.0 - median_rel)\n\n    # Sigmoid fit\u2011score: 0.5 when rel_slack==0, decreasing as slack grows\n    scores = np.full(bins.shape, -np.inf)\n    scores[fits] = 1.0 / (1.0 + np.exp(alpha * rel_slack[fits]))\n    # Scale to [0, 1] so perfect fit yields 1.0\n    scores[fits] *= 2.0\n    np.clip(scores, 0.0, 1.0, out=scores)\n\n    return scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function:\n    1. Decays the exploration probability (epsilon) over successive calls.\n    2. Ranks feasible bins by the smallest residual capacity after packing the call.\n    3. Adds a tiny random jitter to break ties without creating large bonuses.\n    4. Guarantees infeasible bins receive the lowest possible score.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin.  Higher scores indicate more desirable bins.\n    \"\"\"\n    # --------------------------------------------------------------------- #\n    # 1. Call counter & epsilon decay\n    # --------------------------------------------------------------------- #\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    priority_v2._call_counter += 1\n\n    # Base epsilon and decay schedule (1/sqrt(t)). Keep a floor to stay exploratory.\n    eps0 = 0.30\n    eps_min = 0.01\n    epsilon = max(eps_min, eps0 / np.sqrt(priority_v2._call_counter))\n\n    # --------------------------------------------------------------------- #\n    # 2. Identify feasible bins (allow a tiny tolerance for floating\u2011point)\n    # --------------------------------------------------------------------- #\n    tolerance = 1e-12\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    feasible = caps + tolerance >= item   # bool mask\n\n    # If nothing fits, return the lowest possible scores (caller may open a new bin).\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # --------------------------------------------------------------------- #\n    # 3. Exploitation: best\u2011fit (smallest residual)\n    # --------------------------------------------------------------------- #\n    residual = caps - item                 # could be negative for infeasible bins\n    exploit_score = np.full_like(caps, -np.inf, dtype=float)\n    # Use negative residual: larger (less negative) = tighter fit.\n    exploit_score[feasible] = -residual[feasible]\n\n    # Tiny jitter to break ties without inflating scores.\n    jitter_scale = 1e-9\n    jitter = jitter_scale * np.random.rand(np.count_nonzero(feasible))\n    exploit_score[feasible] += jitter\n\n    # --------------------------------------------------------------------- #\n    # 4. Exploration: uniform random noise for each bin\n    # --------------------------------------------------------------------- #\n    exploration_noise = np.random.rand(caps.shape[0])\n\n    # epsilon\u2011greedy combination\n    priorities = (1.0 - epsilon) * exploit_score + epsilon * exploration_noise\n\n    # Ensure infeasible bins stay below any feasible candidate.\n    priorities[~feasible] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that:\n    - Prioritizes exact fits first.\n    - For remaining bins, prefers the smallest slack (closest to full).\n    - Randomly explores other bins with probability epsilon.\n    - Uses a tolerance to detect exact fits and to avoid floating\u2011point ties.\n    \"\"\"\n    eps = 0.15          # exploration probability\n    exact_bonus = 1e6   # high value to guarantee exact fit preference\n    tolerance = 1e-12   # tolerance for floating\u2011point comparison\n\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    leftover = caps - item\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    feasible = leftover >= -tolerance\n    if not np.any(feasible):\n        return priorities\n\n    # Exploration: assign random priorities to feasible bins\n    if np.random.rand() < eps:\n        rand_scores = np.random.rand(np.count_nonzero(feasible))\n        priorities[feasible] = rand_scores\n        return priorities\n\n    # Indices of feasible bins\n    idx = np.where(feasible)[0]\n    slack = leftover[feasible]\n\n    # Exact fit bins\n    exact_mask = np.isclose(slack, 0.0, atol=tolerance)\n    if np.any(exact_mask):\n        priorities[idx[exact_mask]] = exact_bonus\n\n    # Non\u2011exact feasible bins: prioritize smallest slack\n    non_exact_mask = ~exact_mask\n    if np.any(non_exact_mask):\n        jitter = 1e-12 * np.random.rand(np.count_nonzero(non_exact_mask))\n        priorities[idx[non_exact_mask]] = -slack[non_exact_mask] + jitter\n\n    return priorities",
    "response_id": 7,
    "obj": 4.168328679696844,
    "SLOC": 24.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon0: float = 0.20,\n    decay: float = 0.001,\n    smoothing: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    Bins that would leave the smallest remaining capacity after the item is\n    placed receive higher priority (inverse slack).  To avoid premature\n    convergence, an exploration component is blended in with a decaying\n    epsilon.  Infeasible bins are penalised with ``-inf`` so they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    epsilon0 : float, optional\n        Initial exploration probability (default 0.20).\n    decay : float, optional\n        Decay rate of epsilon per call (default 0.001). Larger values reduce\n        exploration faster.\n    smoothing : float, optional\n        Small constant added to the slack term to avoid division by zero\n        and to smooth the inverse\u2011slack calculation.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing the priority\n        score for each bin.  Bins that cannot accommodate ``item`` receive\n        ``-inf``.\n    \"\"\"\n    # Convert input to a NumPy float array for consistent operations\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Slack after placing the item\n    slack = bins_remain_cap - item\n    feasible_mask = slack >= 0\n\n    # No feasible bin \u2192 return all -inf\n    if not np.any(feasible_mask):\n        return priorities\n\n    # ------------------------------------------------------------------\n    # Adaptive epsilon: decays over the number of calls to this\n    # function.  The counter is stored as a function attribute.\n    # ------------------------------------------------------------------\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    step = priority_v2._call_counter\n    priority_v2._call_counter += 1\n\n    epsilon = epsilon0 / (1.0 + decay * step)\n    # Keep epsilon within [0, epsilon0] bounds\n    epsilon = max(0.0, min(epsilon0, epsilon))\n\n    # ------------------------------------------------------------------\n    # Compute the exploitation component: inverse slack, normalised.\n    # ------------------------------------------------------------------\n    inv_slack = 1.0 / (1.0 + slack[feasible_mask] + smoothing)  # >0\n    inv_slack_norm = inv_slack / inv_slack.sum()\n\n    # ------------------------------------------------------------------\n    # Compute the exploration component: random scores, normalised.\n    # ------------------------------------------------------------------\n    rand_scores = np.random.rand(np.count_nonzero(feasible_mask))\n    rand_norm = rand_scores / rand_scores.sum()\n\n    # ------------------------------------------------------------------\n    # Blend exploitation and exploration.\n    # ------------------------------------------------------------------\n    combined = (1.0 - epsilon) * inv_slack_norm + epsilon * rand_norm\n\n    # Assign combined priorities to feasible bins\n    priorities[feasible_mask] = combined\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Decaying epsilon\u2011greedy priority for the online Bin Packing Problem.\n\n    The function prefers bins that will be tightly filled after placing the\n    item (i.e., minimal residual capacity).  A small amount of random\n    exploration is mixed in, with an exploration probability (epsilon) that\n    decays as more items are processed.  Tie\u2011breaking jitter and a tiny bonus\n    for exact fits are added to improve numerical stability without using\n    large artificial bonuses.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin.  Higher scores indicate more preferable bins.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ----- 0. Constants ---------------------------------------------------------\n    TOL = 1e-12                 # tolerance for floating\u2011point comparisons\n    JITTER_SCALE = 1e-9         # magnitude of tie\u2011breaking jitter\n    EXACT_FIT_BONUS = 1e-6      # tiny bonus for (near) exact fits\n\n    # ----- 1. Decaying epsilon --------------------------------------------------\n    # Initialise static attributes on first call.\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    if not hasattr(priority_v2, \"_start_epsilon\"):\n        priority_v2._start_epsilon = 0.3\n    if not hasattr(priority_v2, \"_min_epsilon\"):\n        priority_v2._min_epsilon = 0.01\n\n    priority_v2._call_counter += 1\n    epsilon = max(priority_v2._min_epsilon,\n                  priority_v2._start_epsilon / np.sqrt(priority_v2._call_counter))\n\n    # ----- 2. Feasibility mask --------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    feasible = caps + TOL >= item          # allow a tiny tolerance\n\n    # If no bin can accommodate the item, return -inf for all bins.\n    if not np.any(feasible):\n        return np.full_like(caps, -np.inf, dtype=float)\n\n    # ----- 3. Exploitation: best\u2011fit score --------------------------------------\n    residual = caps - item                 # capacity that would remain\n    # Higher score for smaller residual => negative residual.\n    exploit_score = np.full_like(caps, -np.inf, dtype=float)\n    exploit_score[feasible] = -residual[feasible]\n\n    # Tiny jitter to break exact ties.\n    jitter = np.random.rand(caps.shape[0]) * JITTER_SCALE\n    exploit_score[feasible] += jitter[feasible]\n\n    # Small bonus for (near) exact fits.\n    exact_fit = np.isclose(residual, 0.0, atol=TOL)\n    exploit_score[feasible & exact_fit] += EXACT_FIT_BONUS\n\n    # ----- 4. Exploration: random noise -----------------------------------------\n    exploration_noise = np.random.rand(caps.shape[0])\n\n    # ----- 5. Combine exploitation and exploration -------------------------------\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n    priorities[feasible] = ((1.0 - epsilon) * exploit_score[feasible] +\n                           epsilon * exploration_noise[feasible])\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be placed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; higher values indicate a more attractive bin.\n        Bins that cannot accommodate the item receive a score of 0.\n    \"\"\"\n    # Ensure we work with a NumPy array of float values\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Initialize all priorities to zero (for infeasible bins)\n    priorities = np.zeros_like(caps, dtype=np.float64)\n\n    # Feasibility mask: bin can accommodate the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities  # No bin can take the item\n\n    # Slack remaining after placing the item\n    slack = caps[feasible] - item\n\n    # Normalise slack by the maximum slack among feasible bins\n    max_slack = np.max(slack) if slack.size > 0 else 0.0\n    if max_slack > 0.0:\n        fit_score = 1.0 - slack / max_slack  # 0 <= fit_score <= 1\n    else:\n        # All feasible bins are perfectly tight\n        fit_score = np.ones_like(slack)\n\n    # Logistic transform to sharpen preference for tight fits\n    alpha = 12.0          # steepness of the sigmoid\n    mid_point = 0.5       # centre of the sigmoid\n    sigmoid_arg = alpha * (fit_score - mid_point)\n    priorities[feasible] = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin packing setting.\n\n    The heuristic prefers bins that will be nearly full after placing the item.\n    It uses an exponential decay of the normalized slack (deterministic score),\n    adds a tiny random jitter for deterministic tie\u2011breaking, and incorporates a\n    very small epsilon\u2011greedy random component for exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Higher scores indicate higher preference.\n        Infeasible bins (remaining capacity < item) receive -np.inf.\n    \"\"\"\n    # Guard against empty input\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n\n    # Estimate uniform bin capacity as the maximum remaining capacity observed.\n    # Works when at least one bin is empty; otherwise approximates the capacity\n    # of the least\u2011filled bin.\n    capacity = np.max(bins_remain_cap)\n    if capacity <= 0:\n        # No capacity to place any item.\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Tolerance for floating\u2011point comparisons\n    tol = 1e-12\n\n    # Feasibility mask: bins that can accommodate the item\n    can_fit = bins_remain_cap >= item - tol\n\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(can_fit):\n        # No feasible bin found\n        return priorities\n\n    # Slack after placing the item for feasible bins\n    slack = bins_remain_cap[can_fit] - item\n\n    # Normalized slack in [0, 1]\n    slack_norm = slack / capacity\n\n    # Adaptive steepness: larger items use a steeper decay\n    base_alpha = 10.0\n    alpha = base_alpha * (item / capacity + 0.1)  # ensure >0\n\n    # Deterministic score: exponential decay of slack.\n    # Exact fits (slack \u2264 tol) get the maximal score of 1.0.\n    exact_fit = slack <= tol\n    deterministic_score = np.where(\n        exact_fit,\n        1.0,\n        np.exp(-alpha * slack_norm)\n    )\n\n    # \u03b5\u2011greedy exploration (tiny random perturbation)\n    eps_greedy = 1e-6\n    random_score = np.random.rand(deterministic_score.shape[0])\n    combined_score = (1.0 - eps_greedy) * deterministic_score + eps_greedy * random_score\n\n    # Tiny jitter for deterministic tie\u2011breaking\n    eps_jitter = 1e-9\n    jitter = np.random.uniform(-eps_jitter, eps_jitter, size=combined_score.shape)\n    combined_score += jitter\n\n    # Assign computed scores to feasible bins\n    priorities[can_fit] = combined_score\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin packing setting.\n\n    This heuristic prioritises bins that will be nearly full after placing the\n    item.  The score is an exponential decay of the normalised slack\n    (`slack / capacity`).  Exact fits receive the maximum score of 1.0.\n    A tiny \u03b5\u2011greedy exploration and a minuscule jitter are added for\n    deterministic tie\u2011breaking.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Higher scores indicate higher preference.\n        Bins that cannot accommodate the item receive `-np.inf`.\n    \"\"\"\n    # Guard against empty input\n    if bins_remain_cap.size == 0:\n        return np.empty(0, dtype=float)\n\n    # Convert to float numpy array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Determine bin capacity as the maximum remaining capacity observed\n    capacity = np.max(bins_remain_cap)\n    if capacity <= 0:\n        # No capacity left to place any item\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Small tolerance for floating\u2011point comparisons\n    tol = 1e-12\n\n    # Feasibility mask: bins that can accommodate the item\n    can_fit = bins_remain_cap + tol >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if not np.any(can_fit):\n        return priorities\n\n    # Slack after placing the item for feasible bins\n    slack = bins_remain_cap[can_fit] - item\n    # Normalised slack in [0, 1]\n    slack_norm = slack / capacity\n\n    # Adaptive steepness: larger items \u2192 steeper decay\n    base_alpha = 10.0\n    alpha = base_alpha * (item / capacity + 0.1)  # ensure >0\n\n    # Deterministic score: exponential decay of slack\n    exact_fit = slack <= tol\n    deterministic_score = np.where(\n        exact_fit,\n        1.0,\n        np.exp(-alpha * slack_norm)\n    )\n\n    # \u03b5\u2011greedy exploration (tiny random perturbation)\n    eps_greedy = 1e-6\n    random_score = np.random.rand(deterministic_score.size)\n    combined_score = (1.0 - eps_greedy) * deterministic_score + eps_greedy * random_score\n\n    # Tiny jitter for deterministic tie\u2011breaking\n    eps_jitter = 1e-9\n    jitter = np.random.uniform(-eps_jitter, eps_jitter, size=combined_score.shape)\n    combined_score += jitter\n\n    # Assign scores to feasible bins\n    priorities[can_fit] = combined_score\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    alpha: float = 12.0,\n    mid_point: float = 0.5,\n    epsilon: float = 0.15,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function returns a score for each currently open bin. The bin with the\n    highest score should be selected for the incoming *item*.  Scores are\n    computed as follows:\n\n    1. **Feasibility** \u2013 only bins with enough remaining capacity are considered.\n    2. **Exact fit** \u2013 bins where the item exactly matches the remaining capacity\n       receive a very large bonus (`exact_bonus`) to guarantee selection.\n    3. **Smooth logistic fit** \u2013 for the remaining feasible bins a logistic\n       (sigmoid) transform of the normalized slack is used; tighter fits get\n       higher scores.\n    4. **Exploration** \u2013 with probability ``epsilon`` the scores of feasible\n       bins (except exact\u2011fit bins) are replaced by random values, encouraging\n       exploration of alternative placements.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the open bins.\n    alpha : float, optional\n        Steepness of the logistic curve (default 12.0).\n    mid_point : float, optional\n        Centre of the logistic curve; a fit_score equal to this value yields\n        a priority of 0.5 (default 0.5).\n    epsilon : float, optional\n        Exploration probability; when ``np.random.rand() < epsilon`` random\n        scores are used for feasible bins (default 0.15).\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to ensure they dominate (default 1e6).\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons (default 1e-12 * 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 0) Normalise input\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # 1) Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin -> return all -inf\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # 2) Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item\n\n    # ------------------------------------------------------------------\n    # 3) Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # 4) Logistic scoring for non\u2011exact feasible bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Estimate the (common) bin capacity.\n        # Using the current maximum remaining capacity is a safe upper bound.\n        capacity_est = caps.max()\n        capacity_est = max(capacity_est, 1e-12)  # protect against division by zero\n\n        # Normalise slack to [0, 1] (0 = perfect fit, 1 = completely empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n        fit_score = 1.0 - norm_slack  # larger => tighter fit\n\n        # Logistic transform\n        sigmoid_arg = alpha * (fit_score - mid_point)\n        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n        # Add a tiny jitter to break ties when scores are identical\n        jitter = 1e-9 * np.random.rand(logistic_score.size)\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # 5) \u03b5\u2011greedy exploration (random scores for feasible non\u2011exact bins)\n    # ------------------------------------------------------------------\n    if np.random.rand() < epsilon:\n        # Random scores in [0, *] for all feasible bins (excluding exact fits)\n        rand_vals = np.random.rand(feasible.sum())\n        feasible_idx = np.where(feasible)[0]\n\n        # Overwrite non\u2011exact feasible bins with random values\n        non_exact_idx = np.where(non_exact)[0]\n        # Map random values to feasible indices; preserve order\n        # The first len(feasible_idx) entries of rand_vals correspond to feasible bins\n        # in the order given by feasible_idx.\n        # Since exact\u2011fit bins also appear in feasible_idx, we replace all feasible,\n        # then re\u2011apply the exact bonus.\n        priority[feasible_idx] = rand_vals\n\n        # Reinstate the exact\u2011fit bonus (ensures they remain top priority)\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 6,
    "obj": 3.9190267251695206,
    "SLOC": 35.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Smooth adaptive sigmoid priority for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins receive -np.inf.\n    \"\"\"\n    bins = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Identify bins that can accommodate the item\n    fits = bins >= item\n\n    # No feasible bin \u2192 all priorities are -inf\n    if not np.any(fits):\n        return np.full(bins.shape, -np.inf, dtype=np.float64)\n\n    # Slack left after placing the item\n    slack = bins - item\n\n    # Compute relative slack only for feasible bins\n    rel_slack = np.zeros_like(bins)\n    if np.any(fits):\n        denom = bins[fits]\n        denom_safe = np.where(denom == 0, np.finfo(np.float64).eps, denom)\n        rel_slack[fits] = slack[fits] / denom_safe\n\n    # Adaptive steepness: higher when bins are relatively full\n    median_rel = np.median(rel_slack[fits])\n    alpha = 5.0 * (2.0 - median_rel)          # 5 \u2264 alpha \u2264 10\n    alpha = np.clip(alpha, 5.0, 10.0)\n\n    # Sigmoid score: 1 at perfect fit, decreasing as slack grows\n    scores = np.full(bins.shape, -np.inf, dtype=np.float64)\n    if np.any(fits):\n        logits = alpha * rel_slack[fits]\n        logistic = 1.0 / (1.0 + np.exp(logits))\n        scores[fits] = logistic * 2.0          # perfect fit \u2192 1.0\n        np.clip(scores[fits], 0.0, 1.0, out=scores[fits])\n\n    return scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                tolerance: float = 1e-12,\n                epsilon: float = 0.0,\n                exact_bonus: float = 1e6) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing\n    Problem (BPP). The bin with the highest score will be chosen for the\n    incoming *item*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all currently open bins.\n    tolerance : float, optional\n        Tolerance for floating\u2011point comparisons.\n    epsilon : float, optional\n        Exploration probability.  With probability ``epsilon`` the scores\n        of non\u2011exact feasible bins are replaced by random values to\n        encourage exploration.\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee their\n        selection.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space.\n    feasible = caps >= item - tolerance\n\n    # Initialize all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin -> return all -inf\n    if not feasible.any():\n        return priority\n\n    # Slack after placing the item (only meaningful for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Compute median slack of non\u2011exact feasible bins to set steepness\n        median_slack = np.median(slack[non_exact])\n        # Avoid division by zero; use a default steepness if median slack is tiny\n        eps_for_alpha = 1e-12\n        alpha = 1.0 / (median_slack + eps_for_alpha) if median_slack > eps_for_alpha else 10.0\n\n        # Compute logistic score: 1/(1+exp(alpha * slack / capacity))\n        # Use current remaining capacity as the \u201ccapacity\u201d for scaling\n        cap_non_exact = caps[non_exact]\n        slack_non_exact = slack[non_exact]\n        # Avoid overflow in exp by clipping\n        exp_argument = alpha * slack_non_exact / cap_non_exact\n        exp_argument = np.clip(exp_argument, -700, 700)\n        logistic_score = 1.0 / (1.0 + np.exp(exp_argument))\n\n        # Deterministic jitter for tie\u2011break: proportional to bin index\n        indices_non_exact = np.nonzero(non_exact)[0]\n        jitter = 1e-9 * indices_non_exact.astype(np.float64) / np.max(caps) if np.max(caps) > 0 else 1e-9 * indices_non_exact.astype(np.float64)\n        priority[non_exact] = logistic_score + jitter\n\n    # \u03b5\u2011greedy exploration (optional)\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        # Random scores for all feasible non\u2011exact bins\n        feasible_idx = np.nonzero(feasible)[0]\n        rand_vals = np.random.rand(feasible_idx.size)\n        priority[feasible_idx] = rand_vals\n        # Reinstate exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 33.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e6,\n    tolerance: float = 1e-12,\n    random_state: int | np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    This version (v2) incorporates the ideas from the reflection:\n\n    * Exact\u2011fit bins receive a huge boost (`exact_bonus`).\n    * All other feasible bins are ranked by a logistic transform of the\n      normalized slack, where the midpoint of the logistic curve adapts to the\n      median fit quality of the current feasible bins.\n    * A deterministic tiny jitter (based on bin index) breaks ties.\n    * An \u03b5\u2011greedy exploration strategy with a *decaying* \u03b5 is applied.\n    * Infeasible bins are penalised with `-np.inf`.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the currently open bins.\n    step : int, optional\n        Number of items processed so far (used for \u03b5 decay). Default ``0``.\n    epsilon0 : float, optional\n        Initial exploration probability. Default ``0.20``.\n    decay_rate : float, optional\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)). Default ``0.01``.\n    alpha : float, optional\n        Steepness of the logistic curve. Default ``10.0``.\n    exact_bonus : float, optional\n        Bonus added to exact\u2011fit bins to guarantee selection. Default ``1e6``.\n    tolerance : float, optional\n        Numerical tolerance for floating\u2011point comparisons. Default ``1e-12``.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for exploration). Default ``None``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise inputs\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # If no bin can accommodate the item, return the -inf vector\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item\n\n    # ------------------------------------------------------------------\n    # Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # Logistic scoring for non\u2011exact feasible bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Estimate the (common) bin capacity as the maximum remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        capacity_est = max(capacity_est, 1e-12)  # protect against division by zero\n\n        # Normalised slack \u2208 [0,1] (0 = perfect fit, 1 = completely empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n        fit_score = 1.0 - norm_slack  # larger \u2192 tighter fit\n\n        # Adaptive midpoint: median of the fit scores for the current feasible set\n        median_fit = np.median(fit_score)\n\n        # Logistic transform: tighter fits get scores closer to 1\n        sigmoid_arg = alpha * (fit_score - median_fit)\n        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))\n\n        # Deterministic tiny jitter based on bin index to break exact ties\n        idx_non_exact = np.where(non_exact)[0]\n        jitter = 1e-12 * (idx_non_exact / (len(caps) + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration with decaying \u03b5\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Random scores for all feasible, non\u2011exact bins (uniform in [0,1])\n        rand_vals = rng.random(non_exact.sum())\n        priority[non_exact] = rand_vals\n\n        # Preserve exact\u2011fit bonus (they must stay on top)\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 0,
    "obj": 3.9289988033506273,
    "SLOC": 42.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    epsilon0: float = 0.20,\n    decay: float = 0.001,\n    smoothing: float = 1e-6,\n    exact_fit_bonus: float = 1.5,\n    tolerance: float = 1e-9,\n    rng: np.random.Generator | None = None,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive epsilon\u2011greedy priority for online Bin Packing.\n\n    The priority for each bin reflects how well the bin will be filled\n    after placing the item (inverse slack).  Feasible bins are blended with\n    a decaying exploration component.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the currently open bins.\n    epsilon0 : float, optional\n        Initial exploration probability (default 0.20).\n    decay : float, optional\n        Decay rate of epsilon per call (default 0.001).\n    smoothing : float, optional\n        Small constant to avoid division by zero in the inverse\u2011slack term.\n    exact_fit_bonus : float, optional\n        Multiplicative boost for bins that fit the item exactly (within tolerance).\n    tolerance : float, optional\n        Tolerance for detecting exact fits.\n    rng : np.random.Generator, optional\n        Random generator for reproducibility. If None, a new default RNG is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure input is a NumPy float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise priorities with -inf (infeasible by default)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Compute remaining capacity after placing the item\n    slack = caps - item\n    feasible_mask = slack >= -tolerance  # allow tiny negative due to floating\u2011point\n\n    # No feasible bin \u2192 return all -inf\n    if not np.any(feasible_mask):\n        return priorities\n\n    # ------------------------------------------------------------------\n    # Adaptive epsilon: decays over the number of calls to this function.\n    # ------------------------------------------------------------------\n    if not hasattr(priority_v2, \"_call_counter\"):\n        priority_v2._call_counter = 0\n    step = priority_v2._call_counter\n    priority_v2._call_counter += 1\n\n    epsilon = epsilon0 / (1.0 + decay * step)\n    epsilon = max(0.0, min(epsilon0, epsilon))  # keep within [0, epsilon0]\n\n    # ------------------------------------------------------------------\n    # Exploration component: random scores, normalized.\n    # ------------------------------------------------------------------\n    if rng is None:\n        rng = np.random.default_rng()\n    rand_scores = rng.random(np.count_nonzero(feasible_mask))\n    # Guard against sum == 0 (should not happen)\n    rand_norm = rand_scores / (rand_scores.sum() + 1e-12)\n\n    # ------------------------------------------------------------------\n    # Exploitation component: inverse slack, with exact\u2011fit boost.\n    # ------------------------------------------------------------------\n    feasible_slack = slack[feasible_mask]\n    # Inverse slack (higher when slack is smaller)\n    inv_slack = 1.0 / (feasible_slack + 1.0 + smoothing)  # add 1 to keep values bounded\n    # Apply exact\u2011fit boost\n    exact_fit = np.abs(feasible_slack) <= tolerance\n    if np.any(exact_fit):\n        inv_slack[exact_fit] *= exact_fit_bonus\n\n    inv_slack_norm = inv_slack / (inv_slack.sum() + 1e-12)\n\n    # ------------------------------------------------------------------\n    # Blend exploitation and exploration.\n    # ------------------------------------------------------------------\n    combined = (1.0 - epsilon) * inv_slack_norm + epsilon * rand_norm\n\n    # Small jitter to break ties deterministically\n    jitter = rng.random(combined.shape) * 1e-12\n    combined += jitter\n\n    # Assign combined priorities to feasible bins\n    priorities[feasible_mask] = combined\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 37.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    epsilon: float = 0.0,\n    exact_bonus: float = 1e6,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing Problem (BPP).\n    The bin with the highest score will be chosen for the incoming *item*.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of all currently open bins.\n    tolerance : float, optional\n        Tolerance for floating\u2011point comparisons.\n    epsilon : float, optional\n        Exploration probability. With probability ``epsilon`` the scores of\n        non\u2011exact feasible bins are replaced by random values to encourage\n        exploration.\n    exact_bonus : float, optional\n        Large constant added to exact\u2011fit bins to guarantee their selection.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Feasibility mask: bin must have enough free space.\n    feasible = caps >= item - tolerance\n\n    # Initialize all priorities to -inf (ensures infeasible bins are never chosen)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # No feasible bin -> return all -inf\n    if not feasible.any():\n        return priority\n\n    # Slack after placing the item (only meaningful for feasible bins)\n    slack = caps - item\n\n    # Exact\u2011fit detection\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # Non\u2011exact feasible bins\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Compute median slack of non\u2011exact feasible bins to set steepness\n        median_slack = np.median(slack[non_exact])\n        eps_for_alpha = 1e-12\n        alpha = 1.0 / (median_slack + eps_for_alpha) if median_slack > eps_for_alpha else 10.0\n\n        # Logistic score: 1/(1+exp(alpha * slack / cap))\n        cap_non_exact = caps[non_exact]\n        slack_non_exact = slack[non_exact]\n        exp_argument = alpha * slack_non_exact / cap_non_exact\n        exp_argument = np.clip(exp_argument, -700, 700)\n        logistic_score = 1.0 / (1.0 + np.exp(exp_argument))\n        # Scale to [0,1] range\n        logistic_score *= 2.0\n\n        # Deterministic jitter for tie\u2011break: proportional to bin index\n        indices_non_exact = np.nonzero(non_exact)[0]\n        jitter = 1e-9 * indices_non_exact.astype(np.float64) / (np.max(caps) if np.max(caps) > 0 else 1.0)\n        priority[non_exact] = logistic_score + jitter\n\n    # \u03b5\u2011greedy exploration (optional)\n    if epsilon > 0.0 and np.random.rand() < epsilon:\n        # Random scores for all feasible non\u2011exact bins\n        feasible_idx = np.nonzero(feasible)[0]\n        rand_vals = np.random.rand(feasible_idx.size)\n        priority[feasible_idx] = rand_vals\n        # Reinstate exact\u2011fit bonus\n        priority[exact_fit] = exact_bonus\n\n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 36.0,
    "cyclomatic_complexity": 7.0,
    "exec_success": true
  }
]