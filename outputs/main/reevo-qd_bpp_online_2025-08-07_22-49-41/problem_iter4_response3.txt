```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    bin_capacity: float,
    step: int = 0,
    eps_initial: float = 0.2,
    eps_min: float = 0.01,
    decay_rate: float = 1e-4,
    alpha: float = 10.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    beta: float = 0.5,          # density weighting coefficient
    gamma: float = 0.1,         # item‑size penalty coefficient
    random_state: np.random.Generator = None,
) -> np.ndarray:
    """
    Compute priority scores for each bin in an online Bin Packing problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the bins (same length as number of bins).
    bin_capacity : float
        Fixed capacity of each bin (all bins are assumed identical).
    step : int, optional
        Current time step or item index (used for adaptive epsilon). Default 0.
    eps_initial : float, optional
        Initial exploration probability. Default 0.2.
    eps_min : float, optional
        Minimum exploration probability after decay. Default 0.01.
    decay_rate : float, optional
        Exponential decay rate for epsilon. Default 1e-4.
    alpha : float, optional
        Steepness of the sigmoid slack weighting. Default 10.0.
    exact_bonus : float, optional
        Large bonus added to bins that achieve an exact fit. Default 1e6.
    tolerance : float, optional
        Numerical tolerance for detecting exact fits. Default 1e-12.
    beta : float, optional
        Weight for bin density (how full the bin already is). Default 0.5.
    gamma : float, optional
        Penalty factor for the item size relative to bin capacity. Default 0.1.
    random_state : np.random.Generator, optional
        Random generator for reproducibility. If None, a new default RNG is used.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Bins that cannot accommodate the highest
        (negative infinite) priority, ensuring they are never selected.
    """
    if random_state is None:
        rng = np.random.default_rng()
    else:
        rng = random_state

    # Convert to a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # Feasibility mask (allow a tiny tolerance)
    feasible = caps >= (item - tolerance)
    if not np.any(feasible):
        return priorities

    # Adaptive epsilon (exploration probability)
    eps = max(eps_min, eps_initial * np.exp(-decay_rate * step))

    # Random exploration: assign uniform random scores to feasible bins
    if rng.random() < eps:
        priorities[feasible] = rng.random(np.count_nonzero(feasible))
        return priorities

    # Compute slack for feasible bins
    slack = caps[feasible] - item  # always >= -tolerance
    # Relative slack w.r.t. full bin capacity (0 for perfect fit)
    rel_slack = slack / bin_capacity

    # Sigmoid slack weighting: higher score for tighter fits
    # Using 2/(1+exp(alpha*rel_slack)) maps rel_slack=0 -> score=1
    with np.errstate(over='ignore'):
        base_score = 2.0 / (1.0 + np.exp(alpha * rel_slack))
    # Clip to [0, 1] for numerical safety
    np.clip(base_score, 0.0, 1.0, out=base_score)

    # Bin density: fraction already used (higher = more filled)
    density = (bin_capacity - caps[feasible]) / bin_capacity
    density_factor = 1.0 + beta * density

    # Combine base score with density weighting
    score = base_score * density_factor

    # Item‑size penalty (same for all feasible bins)
    penalty = gamma * (item / bin_capacity)
    score -= penalty

    # Ensure non‑negative after penalty (negative scores are less attractive)
    np.maximum(score, 0.0, out=score)

    # Exact‑fit detection and bonus
    exact_fit = np.isclose(slack, 0.0, atol=tolerance)
    # Assign computed scores (with jitter for tie‑breaking)
    jitter = rng.random(score.shape) * 1e-12
    priorities[feasible] = score + jitter
    # Override exact‑fit bins with a huge bonus
    if np.any(exact_fit):
        exact_indices = np.where(feasible)[0][exact_fit]
        priorities[exact_indices] = exact_bonus

    return priorities
```
