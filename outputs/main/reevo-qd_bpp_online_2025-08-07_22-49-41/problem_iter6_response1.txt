```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Decaying epsilon‑greedy priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher = more desirable). Infeasible
        bins receive ``-np.inf``.
    """
    # ----- Constants ---------------------------------------------------------
    TOL = 1e-12                # tolerance for floating‑point comparisons
    JITTER_SCALE = 1e-9        # magnitude of tie‑breaking jitter
    EXACT_FIT_BONUS = 1e-6     # small boost for (near) exact fits

    # ----- Decaying epsilon (static across calls) ----------------------------
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    if not hasattr(priority_v2, "_start_epsilon"):
        priority_v2._start_epsilon = 0.3
    if not hasattr(priority_v2, "_min_epsilon"):
        priority_v2._min_epsilon = 0.01

    priority_v2._call_counter += 1
    epsilon = max(priority_v2._min_epsilon,
                  priority_v2._start_epsilon / np.sqrt(priority_v2._call_counter))

    # ----- Input handling ----------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # ----- Feasibility mask --------------------------------------------------
    feasible = caps + TOL >= item

    # Initialize all priorities to -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # If no bin can accommodate the item, return -inf for all bins.
    if not np.any(feasible):
        return priorities

    # ----- Exploitation score (best‑fit) --------------------------------------
    residual = caps - item                    # capacity left after placement
    exploit_score = -residual                 # higher score = smaller residual

    # Add tiny jitter to break exact ties
    jitter = np.random.rand(caps.shape[0]) * JITTER_SCALE
    exploit_score += jitter

    # Reward near‑exact fits with a tiny bonus
    exact_fit = np.isclose(residual, 0.0, atol=TOL)
    exploit_score[exact_fit] += EXACT_FIT_BONUS

    # ----- Exploration noise -------------------------------------------------
    exploration_noise = np.random.rand(caps.shape[0])

    # ----- Combine exploitation and exploration for feasible bins -----------
    priorities[feasible] = ((1.0 - epsilon) * exploit_score[feasible] +
                            epsilon * exploration_noise[feasible])

    return priorities
```
