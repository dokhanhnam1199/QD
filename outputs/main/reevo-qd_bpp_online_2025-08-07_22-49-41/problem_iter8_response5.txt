```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic priority scores for the online Bin Packing Problem.

    * Exact‑fit bins (remaining capacity == item) receive the highest priority
      (``np.inf``).
    * Feasible non‑exact bins receive a priority inversely proportional to the
      leftover capacity (slack).  Smaller slack ⇒ larger priority.
    * Infeasible bins receive ``-np.inf``.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``).  The bin with the
        highest score (e.g., via ``np.argmax``) should be selected for the item.
    """
    # Convert input to a NumPy array of floats for consistent arithmetic
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Slack after (hypothetically) placing the item in each bin
    slack = caps - item

    # Initialise all priorities as infeasible
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Feasible bins: slack >= 0
    feasible_mask = slack >= 0
    if not np.any(feasible_mask):
        return priorities  # no bin can accommodate the item

    # Tolerance for floating‑point comparison
    eps = 1e- the code cutoff. Wait, that's not correct. 

We need to correct: The code is incomplete. Let's rewrite carefully.

Actually the user wants only final code. The current answer is incomplete: It ends with "eps = 1e- the code cutoff". This is not correct. I need to produce correct code. Let's rewrite.

We need to be careful: The answer must be code only, within a Python code block. No extra commentary. Provide full function with proper imports and docstring.

Thus final code:

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic priority scores for the online Bin Packing Problem.

    * Exact‑fit bins (remaining capacity == item) receive the highest priority
      (``np.inf``).
    * Feasible non‑exact bins receive a priority inversely proportional to the
      leftover capacity (slack).  Smaller slack ⇒ larger priority.
    * Infeasible bins receive ``-np.inf``.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    #? Actually we need to finalize.

We must fix.

Let's generate final answer.

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic priority scores for the online Bin Packing Problem.

    * Exact‑fit bins (remaining capacity == item) receive the highest priority
      (``np.inf``).
    * Feasible non‑exact bins receive a priority inversely proportional to the
      leftover capacity (slack). Smaller slack ⇒ larger priority.
    * Infeasible bins receive ``-np.inf``.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``). The bin with the
        highest score (e.g., via ``np.argmax``) should be selected for the item.
    """
    # Ensure input is a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Compute slack (remaining capacity after placing the item)
    slack = caps - item

    # Initialise all priorities as infeasible
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Feasible bins: slack >= 0
    feasible_mask = slack >= 0
    if not np.any(feasible_mask):
        return priorities  # no bin can accommodate the item

    # Tolerance for floating‑point exactness
    eps = 1e-12

    # Exact‑fit bins: slack ≈ 0
    exact_mask = feasible_mask & (np.abs(slack) <= eps)
    priorities[exact_mask] = np.inf

    # Non‑exact feasible bins
    non_exact_mask = feasible_mask & ~exact_mask
    # Inverse‑slack scoring (larger priority for tighter fit)
    priorities[non_exact_mask] = 1.0 / (slack[non_exact_mask] + eps)

    return priorities
```
