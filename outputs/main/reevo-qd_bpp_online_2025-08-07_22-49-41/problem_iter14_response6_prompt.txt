{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Return a priority score for each bin using an \u03b5\u2011greedy strategy.\n    The algorithm mixes a greedy best\u2011fit rule with random exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to pack.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        An array of the same shape as `bins_remain_cap` containing the\n        priority of each bin.  The bin with the highest value will be chosen.\n    \"\"\"\n    n_bins = bins_remain_cap.size\n\n    # Base priority vector: assign -\u221e to all bins initially.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if n_bins == 0:\n        # No bins available \u2013 the calling procedure should handle this\n        # by opening a new bin.  Returning an empty array keeps the API\n        # consistent with the input shape.\n        return priorities\n\n    # Determine which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # If no bin can fit the item, no viable actions.  Priorities stay -\u221e.\n    if not can_fit.any():\n        return priorities\n\n    # ----------------- Greedy component: Best\u2011fit heuristic -------------\n    # For feasible bins compute a score proportional to how full the bin\n    # would become after placing the item (smallest leftover \u2192 highest priority).\n    leftover = bins_remain_cap - item            # Remaining capacity after insertion\n    greedy_scores = -leftover                    # We invert so that smaller leftover => higher value\n    greedy_scores[~can_fit] = -np.inf            # Exclude infeasible bins\n\n    # ----------------- Random component: Exploration --------------------\n    # Probability of exploring a random feasible bin\n    # Decaying epsilon: encourages exploration early and exploitation later.\n    epsilon = max(0.01, min(0.3, 0.2 / np.sqrt(n_bins)))\n\n    if np.random.rand() < epsilon:\n        # Exploration: pick a random feasible bin and give it a very high priority.\n        random_idx = np.random.choice(np.where(can_fit)[0])\n        # Assign a large positive value that guarantees selection.\n        priorities = np.full(n_bins, -np.inf, dtype=float)\n        priorities[random_idx] = 1.0\n    else:\n        # Exploitation: use the best\u2011fit scores\n        priorities = greedy_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: Union[np.ndarray, Tuple[float, ...], list],\n    *,\n    step: int = 0,\n    epsilon0: float = 0.20,\n    decay_rate: float = 0.01,\n    alpha: float = 10.0,\n    exact_bonus: float = 1e9,\n    tolerance: float = 1e-12,\n    jitter_scale: float = 1e-9,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive priority scoring for the online Bin Packing Problem (BPP).\n\n    The scoring combines several heuristics:\n      * Feasibility mask \u2013 only bins with enough remaining capacity are considered.\n      * Exact\u2011fit bonus \u2013 bins that fit the item perfectly receive a huge boost.\n      * Logistic slack scaling \u2013 non\u2011exact feasible bins are scored by a logistic\n        transform of their normalised slack, with the logistic midpoint adapting\n        to the median fit quality of the current feasible set.\n      * Deterministic jitter \u2013 tiny bin\u2011index\u2011based jitter breaks ties deterministically.\n      * \u03b5\u2011greedy exploration \u2013 with a decaying \u03b5, occasionally random scores are used\n        to encourage exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : array\u2011like\n        Remaining capacities of currently open bins.\n    step : int, default 0\n        Number of items processed so far (used for \u03b5 decay).\n    epsilon0 : float, default 0.20\n        Initial exploration probability.\n    decay_rate : float, default 0.01\n        Decay factor for \u03b5 (\u03b5 = \u03b5\u2080 / (1 + decay_rate * step)).\n    alpha : float, default 10.0\n        Steepness of the logistic curve.\n    exact_bonus : float, default 1e9\n        Bonus added to exact\u2011fit bins to guarantee selection.\n    tolerance : float, default 1e-12\n        Numerical tolerance for floating\u2011point comparisons.\n    jitter_scale : float, default 1e-9\n        Scale of deterministic jitter for tie\u2011breaking.\n    random_state : int | np.random.Generator | None, optional\n        Seed or generator for random numbers (used for exploration).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; infeasible bins have ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Normalise input\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Handle empty bin list gracefully\n    if caps.size == 0:\n        return np.empty_like(caps, dtype=np.float64)\n\n    # ------------------------------------------------------------------\n    # Feasibility mask \u2013 a bin must have enough free space.\n    # ------------------------------------------------------------------\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priority vector with -inf (infeasible bins stay -inf)\n    priority = np.full_like(caps, -np.inf, dtype=np.float64)\n\n    # If no bin can accommodate the item, return the -inf vector immediately\n    if not feasible.any():\n        return priority\n\n    # ------------------------------------------------------------------\n    # Slack after placing the item (only meaningful for feasible bins)\n    # ------------------------------------------------------------------\n    slack = caps - item\n\n    # ------------------------------------------------------------------\n    # Exact\u2011fit detection\n    # ------------------------------------------------------------------\n    exact_fit = np.abs(slack) <= tolerance\n    priority[exact_fit] = exact_bonus\n\n    # ------------------------------------------------------------------\n    # Logistic scoring for non\u2011exact feasible bins\n    # ------------------------------------------------------------------\n    non_exact = feasible & ~exact_fit\n    if non_exact.any():\n        # Characteristic capacity: max remaining capacity among feasible bins\n        capacity_est = caps[feasible].max()\n        # Guard against pathological zero capacity (should not happen for feasible)\n        capacity_est = max(capacity_est, 1e-12)\n\n        # Normalised slack in [0, 1] (0 = perfect fit, 1 = completely empty bin)\n        norm_slack = slack[non_exact] / capacity_est\n        norm_slack = np.clip(norm_slack, 0.0, 1.0)\n\n        # Fit score: higher means tighter fit\n        fit_score = 1.0 - norm_slack\n\n        # Adaptive median midpoint for logistic transform\n        median_fit = np.median(fit_score)\n\n        # Logistic transform (clamped to avoid overflow)\n        arg = alpha * (fit_score - median_fit)\n        arg = np.clip(arg, -50.0, 50.0)  # exp overflow protection\n        logistic_score = 1.0 / (1.0 + np.exp(-arg))\n\n        # Deterministic jitter based on bin index to break ties\n        idx_non_exact = np.where(non_exact)[0]\n        jitter = jitter_scale * (idx_non_exact.astype(np.float64) / (caps.size + 1.0))\n\n        priority[non_exact] = logistic_score + jitter\n\n    # ------------------------------------------------------------------\n    # \u03b5\u2011greedy exploration with decaying \u03b5\n    # ------------------------------------------------------------------\n    epsilon = epsilon0 / (1.0 + decay_rate * step)\n\n    # Initialise RNG\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    if rng.random() < epsilon:\n        # Random scores for all feasible bins (uniform in [0, 1])\n        rand_vals = rng.random(feasible.sum())\n        priority[feasible] = rand_vals\n        # Preserve exact\u2011fit bonus (exact fits dominate even during exploration)\n        priority[exact_fit] = exact_bonus\n\n    return priority\n\n[Reflection]\nCombine feasibility mask, exact\u2011fit bonus, adaptive logistic scoring, deterministic jitter, and decaying \u03b5\u2011greedy exploration.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}