```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                tolerance: float = 1e-12,
                epsilon: float = 0.0,
                exact_bonus: float = 1e6,
                alpha: float = 5.0) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online Bin Packing Problem (BPP).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of all currently open bins.
    tolerance : float, optional
        Tolerance for floating‑point comparisons.
    epsilon : float, optional
        Exploration probability; with probability ``epsilon`` the scores of feasible
        non‑exact bins are replaced by random values. Default is 0 (deterministic).
    exact_bonus : float, optional
        Large constant added to exact‑fit bins to guarantee their selection.
    alpha : float, optional
        Decay rate used in the exponential scoring of non‑exact bins.
        Larger values make the scoring steeper (stronger preference for tighter fits).

    Returns
    -------
    np.ndarray
        Priority scores, one per bin. Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility: enough space (allowing small tolerance)
    feasible = caps >= item - tolerance

    # Initialize priorities to -inf for infeasible bins
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # If no bin can accommodate the item, return early
    if not np.any(feasible):
        return priority

    # Slack after placing the item (relevant only for feasible bins)
    slack = caps - item  # may be slightly negative within tolerance

    # Detect exact fits within tolerance
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins (candidates for regular scoring)
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        # Normalized slack (fraction of bin that would remain empty)
        # Avoid division by zero; feasible bins have caps > 0 for positive items.
        norm_slack = slack[non_exact] / caps[non_exact]

        # Exponential scoring: higher for smaller normalized slack.
        # Clip to prevent overflow in exp().
        exp_arg = -alpha * norm_slack
        exp_arg = np.clip(exp_arg, -700, 700)
        score = np.exp(exp_arg)  # range (0, 1], equals 1 for zero slack.

        # Deterministic tie‑breaker: a vanishing offset based on bin index.
        idx = np.nonzero(non_exact)[0]
        tiny = np.finfo(np.float64).eps
        offset = tiny * (idx.astype(np.float64) / (np.max(idx) + 1.0))
        priority[non_exact] = score + offset

    # ε‑greedy exploration (optional)
    if epsilon > 0.0 and np.random.rand() < epsilon:
        # Random scores for all feasible (non‑exact_fit) bins.
        rand_scores = np.random.rand(np.count_nonzero(feasible))
        feasible_idx = np.nonzero(feasible)[0]
        priority[feasible_idx] = rand_scores
        # Preserve exact‑fit bonus
        priority[exact_fit] = exact_bonus

    return priority
```
