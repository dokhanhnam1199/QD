```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 0.1,
    alpha: float = 12.0,
    mid_point: float = 0.5,
    capacity_est: float | None = None,
    tolerance: float = 1e-12,
) -> np.ndarray:
    """
    Compute a smooth priority score for each bin in an online bin packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacity of each currently open bin.
    epsilon : float, optional
        Exploration factor. With probability `epsilon` the priority of each
        feasible bin is mixed with a uniform random value.
    alpha : float, optional
        Steepness of the logistic curve. Larger values give a sharper
        preference for tight fits.
    mid_point : float, optional
        The fitâ€‘score value at which the logistic output equals 0.5.
    capacity_est : float, optional
        Estimated total bin capacity. If None, the maximum remaining
        capacity in `bins_remain_cap` is used.
    tolerance : float, optional
        Tolerance for detecting exact fits.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; bins that cannot accommodate the item
        receive a priority of 0.
    """
    caps = np.asarray(bins_remain_cap, dtype=np.float64)
    feasible = caps >= item

    # If no bin can accept the item, return all zeros.
    if not feasible.any():
        return np.zeros_like(caps, dtype=np.float64)

    priority = np.zeros_like(caps, dtype=np.float64)

    # Determine capacity estimate for normalisation.
    if capacity_est is None:
        capacity_est = caps.max()
    capacity_est = max(capacity_est, tolerance)

    # Slack for feasible bins.
    slack_feasible = caps[feasible] - item

    # Normalised slack in [0, 1].
    norm_slack_feasible = slack_feasible / capacity_est

    # Fit score: 1.0 for perfect fit, 0.0 for empty bin.
    fit_score_feasible = 1.0 - norm_slack_feasible

    # Logistic transformation.
    sigmoid_arg = alpha * (fit_score_feasible - mid_point)
    logistic_feasible = 1.0 / (1.0 + np.exp(-sigmoid_arg))

    # Assign logistic priorities to feasible bins.
    priority[feasible] = logistic_feasible

    # Exact fits receive the maximum priority (1.0).
    exact_mask = np.isclose(slack_feasible, 0.0, atol=tolerance)
    if exact_mask.any():
        priority[feasible][exact_mask] = 1.0

    # Add uniform exploration noise if requested.
    if epsilon > 0.0:
        rand_noise = np.random.rand(np.count_nonzero(feasible))
        priority[feasible] = (1.0 - epsilon) * priority[feasible] + epsilon * rand_noise

    return priority
```
