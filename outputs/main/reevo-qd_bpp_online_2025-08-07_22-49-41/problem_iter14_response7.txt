```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha: float = 10.0,
    exact_bonus: float = 1e9,
    tolerance: float = 1e-12,
    jitter_scale: float = 1e-12,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Adaptive priority scoring for the online bin‑packing problem.

    The function assigns a numeric priority to each bin; the bin with the
    highest priority is selected for the incoming `item`.  Features:

    * **Exact fits** receive a huge constant ``exact_bonus`` guaranteeing they
      are chosen over any non‑exact bin.
    * For feasible non‑exact bins the *tightness* of the fit
      ``fit_score = 1 - slack / max_cap`` is transformed by a logistic
      function whose midpoint is the median fit score of the current feasible
      set (adaptive steepness controlled by ``alpha``).
    * A deterministic jitter proportional to the bin index (scaled by
      ``jitter_scale``) breaks ties in a reproducible way.
    * An ε‑greedy exploration step with decaying ε (``epsilon0 /
      (1 + decay_rate * step)``) occasionally replaces the deterministic scores
      with random values, encouraging exploration early on.
    * Infeasible bins receive ``-np.inf`` so they can never be selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently open bins.
    step : int, optional
        Number of items processed so far (used for ε decay). Default: 0.
    epsilon0 : float, optional
        Initial exploration probability. Default: 0.20.
    decay_rate : float, optional
        Decay factor for ε (ε = ε₀ / (1 + decay_rate * step)). Default: 0.01.
    alpha : float, optional
        Steepness of the logistic curve. Default: 10.0.
    exact_bonus : float, optional
        Bonus added to exact‑fit bins to guarantee selection. Default: 1e9.
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons. Default: 1e-12.
    jitter_scale : float, optional
        Scale of the deterministic jitter (tiny value). Default: 1e-12.
    random_state : int | np.random.Generator | None, optional
        Seed or generator for random numbers (used for exploration). Default: None.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    # Convert to a NumPy array of float64 for safety and speed.
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # ----------------------------------------------------------------------
    # 1. Feasibility mask
    # ----------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    # Initialise all priorities with -inf (infeasible bins stay -inf).
    priorities = np.full_like(caps, -np.inf, dtype=np.float64)

    # If no bin can accommodate the item, return early.
    if not feasible.any():
        return priorities

    # ----------------------------------------------------------------------
    # 2. Compute slack and detect exact fits
    # ----------------------------------------------------------------------
    slack = caps - item
    exact_fit = np.abs(slack) <= tolerance
    priorities[exact_fit] = exact_bonus

    # ----------------------------------------------------------------------
    # 3. Score non‑exact feasible bins
    # ----------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Normalise slack by the largest remaining capacity among feasible bins.
        max_cap = caps[feasible].max()
        max_cap = max(max_cap, 1e-12)  # safeguard against division by zero
        norm_slack = slack[non_exact] / max_cap               # ∈ [0, 1] approx.
        # Tightness of the fit: larger → tighter.
        fit_score = 1.0 - norm_slack

        # Adaptive logistic transformation.
        median_fit = np.median(fit_score)
        logistic_arg = alpha * (fit_score - median_fit)
        # Clip to avoid overflow in exp().
        logistic_arg = np.clip(logistic_arg, -50, 50)
        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Deterministic jitter for tie‑breaking.
        idx = np.where(non_exact)[0]
        jitter = jitter_scale * (idx / (len(caps) + 1.0))

        priorities[non_exact] = logistic_score + jitter

    # ----------------------------------------------------------------------
    # 4. ε‑greedy exploration (decaying ε)
    # ----------------------------------------------------------------------
    epsilon = epsilon0 / (1.0 + decay_rate * step)
    rng = (
        random_state
        if isinstance(random_state, np.random.Generator)
        else np.random.default_rng(random_state)
    )
    if rng.random() < epsilon:
        # Random scores in [0, 1) for all non‑exact feasible bins.
        rand_vals = rng.random(non_exact.sum())
        priorities[non_exact] = rand_vals
        # Preserve exact‑fit bonus (they must stay the best).
        priorities[exact_fit] = exact_bonus

    return priorities
```
