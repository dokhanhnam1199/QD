```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha: float = 10.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    random_state: int | np.random.Generator | None = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    This version (v2) incorporates the ideas from the reflection:

    * Exact‑fit bins receive a huge boost (`exact_bonus`).
    * All other feasible bins are ranked by a logistic transform of the
      normalized slack, where the midpoint of the logistic curve adapts to the
      median fit quality of the current feasible bins.
    * A deterministic tiny jitter (based on bin index) breaks ties.
    * An ε‑greedy exploration strategy with a *decaying* ε is applied.
    * Infeasible bins are penalised with `-np.inf`.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently open bins.
    step : int, optional
        Number of items processed so far (used for ε decay). Default ``0``.
    epsilon0 : float, optional
        Initial exploration probability. Default ``0.20``.
    decay_rate : float, optional
        Decay factor for ε (ε = ε₀ / (1 + decay_rate * step)). Default ``0.01``.
    alpha : float, optional
        Steepness of the logistic curve. Default ``10.0``.
    exact_bonus : float, optional
        Bonus added to exact‑fit bins to guarantee selection. Default ``1e6``.
    tolerance : float, optional
        Numerical tolerance for floating‑point comparisons. Default ``1e-12``.
    random_state : int | np.random.Generator | None, optional
        Seed or generator for random numbers (used for exploration). Default ``None``.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # Normalise inputs
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # ------------------------------------------------------------------
    # Feasibility mask – a bin must have enough free space.
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (ensures infeasible bins are never chosen)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # If no bin can accommodate the item, return the -inf vector
    if not feasible.any():
        return priority

    # ------------------------------------------------------------------
    # Slack after placing the item (only meaningful for feasible bins)
    # ------------------------------------------------------------------
    slack = caps - item

    # ------------------------------------------------------------------
    # Exact‑fit detection
    # ------------------------------------------------------------------
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # ------------------------------------------------------------------
    # Logistic scoring for non‑exact feasible bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Estimate the (common) bin capacity as the maximum remaining capacity among feasible bins
        capacity_est = caps[feasible].max()
        capacity_est = max(capacity_est, 1e-12)  # protect against division by zero

        # Normalised slack ∈ [0,1] (0 = perfect fit, 1 = completely empty bin)
        norm_slack = slack[non_exact] / capacity_est
        fit_score = 1.0 - norm_slack  # larger → tighter fit

        # Adaptive midpoint: median of the fit scores for the current feasible set
        median_fit = np.median(fit_score)

        # Logistic transform: tighter fits get scores closer to 1
        sigmoid_arg = alpha * (fit_score - median_fit)
        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))

        # Deterministic tiny jitter based on bin index to break exact ties
        idx_non_exact = np.where(non_exact)[0]
        jitter = 1e-12 * (idx_non_exact / (len(caps) + 1.0))

        priority[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # ε‑greedy exploration with decaying ε
    # ------------------------------------------------------------------
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    # Initialise RNG
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    if rng.random() < epsilon:
        # Random scores for all feasible, non‑exact bins (uniform in [0,1])
        rand_vals = rng.random(non_exact.sum())
        priority[non_exact] = rand_vals

        # Preserve exact‑fit bonus (they must stay on top)
        priority[exact_fit] = exact_bonus

    return priority
```
