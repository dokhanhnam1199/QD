```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon0: float = 0.20,
    decay: float = 0.001,
    smoothing: float = 1e-6,
    exact_fit_bonus: float = 1.5,
    tolerance: float = 1e-9,
    rng: np.random.Generator | None = None,
) -> np.ndarray:
    """
    Adaptive epsilon‑greedy priority for online Bin Packing.

    The priority for each bin reflects how well the bin will be filled
    after placing the item (inverse slack).  Feasible bins are blended with
    a decaying exploration component.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the currently open bins.
    epsilon0 : float, optional
        Initial exploration probability (default 0.20).
    decay : float, optional
        Decay rate of epsilon per call (default 0.001).
    smoothing : float, optional
        Small constant to avoid division by zero in the inverse‑slack term.
    exact_fit_bonus : float, optional
        Multiplicative boost for bins that fit the item exactly (within tolerance).
    tolerance : float, optional
        Tolerance for detecting exact fits.
    rng : np.random.Generator, optional
        Random generator for reproducibility. If None, a new default RNG is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf``.
    """
    # Ensure input is a NumPy float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialise priorities with -inf (infeasible by default)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Compute remaining capacity after placing the item
    slack = caps - item
    feasible_mask = slack >= -tolerance  # allow tiny negative due to floating‑point

    # No feasible bin → return all -inf
    if not np.any(feasible_mask):
        return priorities

    # ------------------------------------------------------------------
    # Adaptive epsilon: decays over the number of calls to this function.
    # ------------------------------------------------------------------
    if not hasattr(priority_v2, "_call_counter"):
        priority_v2._call_counter = 0
    step = priority_v2._call_counter
    priority_v2._call_counter += 1

    epsilon = epsilon0 / (1.0 + decay * step)
    epsilon = max(0.0, min(epsilon0, epsilon))  # keep within [0, epsilon0]

    # ------------------------------------------------------------------
    # Exploration component: random scores, normalized.
    # ------------------------------------------------------------------
    if rng is None:
        rng = np.random.default_rng()
    rand_scores = rng.random(np.count_nonzero(feasible_mask))
    # Guard against sum == 0 (should not happen)
    rand_norm = rand_scores / (rand_scores.sum() + 1e-12)

    # ------------------------------------------------------------------
    # Exploitation component: inverse slack, with exact‑fit boost.
    # ------------------------------------------------------------------
    feasible_slack = slack[feasible_mask]
    # Inverse slack (higher when slack is smaller)
    inv_slack = 1.0 / (feasible_slack + 1.0 + smoothing)  # add 1 to keep values bounded
    # Apply exact‑fit boost
    exact_fit = np.abs(feasible_slack) <= tolerance
    if np.any(exact_fit):
        inv_slack[exact_fit] *= exact_fit_bonus

    inv_slack_norm = inv_slack / (inv_slack.sum() + 1e-12)

    # ------------------------------------------------------------------
    # Blend exploitation and exploration.
    # ------------------------------------------------------------------
    combined = (1.0 - epsilon) * inv_slack_norm + epsilon * rand_norm

    # Small jitter to break ties deterministically
    jitter = rng.random(combined.shape) * 1e-12
    combined += jitter

    # Assign combined priorities to feasible bins
    priorities[feasible_mask] = combined

    return priorities
```
