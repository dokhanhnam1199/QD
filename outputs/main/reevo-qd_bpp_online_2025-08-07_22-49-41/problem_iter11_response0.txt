```python
import numpy as np
from typing import Optional, Union


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    step: int = 0,
    epsilon0: float = 0.20,
    decay_rate: float = 0.01,
    alpha_base: float = 10.0,
    alpha_scale: float = 5.0,
    exact_bonus: float = 1e6,
    tolerance: float = 1e-12,
    recent_items: Optional[np.ndarray] = None,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Compute priority scores for bins in an online Bin Packing Problem (BPP).

    The heuristic favours bins that produce tight packings after placing the
    item. It uses a logistic transform of the normalised slack, a huge bonus
    for exact fits, deterministic jitter for tie‑breaking, and a decaying
    ε‑greedy exploration scheme. The logistic steepness ``alpha`` adapts to
    the recent item‑size distribution.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each currently open bin.
    step : int, default 0
        Number of items already processed; used to decay ε.
    epsilon0 : float, default 0.20
        Initial exploration probability.
    decay_rate : float, default 0.01
        Decay factor for ε (ε = ε₀ / (1 + decay_rate * step)).
    alpha_base : float, default 10.0
        Base steepness of the logistic curve.
    alpha_scale : float, default 5.0
        Scaling factor that modulates ``alpha`` based on the recent item‑size
        distribution.
    exact_bonus : float, default 1e6
        Bonus added to exact‑fit bins to guarantee their selection.
    tolerance : float, default 1e-12
        Numerical tolerance for floating‑point comparisons.
    recent_items : np.ndarray or None, optional
        Array of previously seen item sizes (e.g., a sliding window). If
        provided, ``alpha`` is adapted to the ratio between the current item
        and the median of ``recent_items``.
    random_state : int, np.random.Generator, or None, optional
        Seed or generator for the random numbers used in ε‑greedy exploration.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins have ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # Normalise inputs
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Initialise priority vector: infeasible bins get -inf
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # ------------------------------------------------------------------
    # Feasibility mask (allow small tolerance)
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    if not feasible.any():
        # No bin can accommodate the item
        return priority

    # ------------------------------------------------------------------
    # Slack after placement and exact‑fit detection
    # ------------------------------------------------------------------
    slack = caps - item
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # Non‑exact feasible bins
    non_exact = feasible & ~exact_fit

    # ------------------------------------------------------------------
    # Adaptive logistic steepness (alpha)
    # ------------------------------------------------------------------
    if recent_items is not None and recent_items.size > 0:
        # Median of recent items as a robust central tendency
        median_recent = np.median(recent_items.astype(np.float64))
        if median_recent > tolerance:
            # Relative deviation of current item from recent median
            rel_dev = (item - median_recent) / median_recent
            alpha = alpha_base * (1.0 + alpha_scale * rel_dev)
            # Clamp alpha to a sensible positive range
            alpha = max(alpha, 1.0)
        else:
            alpha = alpha_base
    else:
        alpha = alpha_base

    # ------------------------------------------------------------------
    # Scoring for non‑exact feasible bins
    # ------------------------------------------------------------------
    if non_exact.any():
        # Representative capacity for normalisation (largest remaining capacity among feasible bins)
        capacity_est = caps[feasible].max()  # max remaining capacity among feasible bins
        capacity_est = max(capacity_est, tolerance)  # avoid division by zero

        # Normalised slack ∈ [0, 1] (0 = perfect fit, 1 = empty bin)
        norm_slack = slack[non_exact] / capacity_est

        # Fit quality: larger when slack is smaller (1 = perfect, 0 = empty)
        fit_quality = 1.0 - norm_slack

        # Adaptive midpoint: median fit quality of all feasible bins (including exact fits)
        # Exact fits have fit_quality ≈ 1, so they pull the median up if many exist.
        all_fit_quality = 1.0 - (slack[feasible] / capacity_est)
        median_fit = np.median(all_fit_quality)

        # Logistic transform: tighter fits (fit_quality > median) get scores > 0.5
        logistic_arg = alpha * (fit_quality - median_fit)
        logistic_score = 1.0 / (1.0 + np.exp(-logistic_arg))

        # Deterministic jitter based on bin index to break ties
        idx = np.where(non_exact)[0]
        jitter = 1e
        jitter = 1e-12 * (idx.astype(np.float64) / (len(caps) + 1.0))

        priority[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # ε‑greedy exploration (decaying ε)
    # ------------------------------------------------------------------
    epsilon = epsilon0 / (1.0 + decay_rate * step)

    # Initialise RNG
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    if rng.random() < epsilon:
        # Exploration: assign uniform random scores to all feasible bins (preserving exact‑fit bonus)
        rand_vals = rng.random(feasible.sum())
        # Map random values to the feasible positions
        feasible_idx = np.where(feasible)[0]
        priority[feasible_idx] = rand_vals
        # Ensure exact‑fit bins still dominate
        priority[exact_fit] = exact_bonus

    return priority
```
