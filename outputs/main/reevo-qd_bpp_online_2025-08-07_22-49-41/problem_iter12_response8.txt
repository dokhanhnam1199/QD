```python
import numpy as np
from typing import Optional, Union

def priority_v2(
    item: float,
    bins_remain_cap: Union[np.ndarray, list, tuple],
    *,
    tolerance: float = 1e-12,
    alpha: float = 12.0,
    mid_point: float = 0.5,
    epsilon: float = 0.1,
    exact_bonus: float = 1e6,
    random_state: Optional[Union[int, np.random.Generator]] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    For each currently open bin this function returns a scalar score.
    The bin with the highest score should be selected for the incoming *item*.
    Scores are computed as follows:

    1. **Feasibility** – only bins with enough remaining capacity are considered.
    2. **Exact‑fit bonus** – bins where the item exactly matches the remaining
       capacity receive a large constant ``exact_bonus``.
    3. **Fit‑tightness** – for the remaining feasible bins a logistic
       transformation of the normalized slack (how empty the bin would be)
       is used; tighter fits obtain higher scores.
    4. **Exploration** – with probability ``epsilon`` the scores of feasible
       non‑exact bins are replaced by random values (ε‑greedy exploration).
    5. **Tie‑breaking jitter** – a tiny random jitter is added to break ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : array‑like
        Remaining capacities of all open bins.
    tolerance : float, default 1e-12
        Numerical tolerance for feasibility and exact‑fit checks.
    alpha : float, default 12.0
        Steepness of the logistic curve; larger values make the score more
        sensitive to the fit quality.
    mid_point : float, default 0.5
        Mid‑point of the logistic curve; a fit score equal to this value yields
        a logistic output of 0.5.
    epsilon : float, default 0.1
        Exploration probability (ε‑greedy). When ``rng.random() < epsilon`` the
        scores of feasible non‑exact bins are replaced by uniform random numbers.
    exact_bonus : float, default 1e6
        Large constant added to exact‑fit bins to guarantee they dominate.
    random_state : int or np.random.Generator, optional
        Seed or random generator for reproducibility.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins receive ``-np.inf``.
    """
    # ------------------------------------------------------------------
    # 0) Normalise input and initialise RNG
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    # ------------------------------------------------------------------
    # 1) Feasibility mask – a bin must have enough free space.
    # ------------------------------------------------------------------
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible bins are never chosen)
    priority = np.full_like(caps, -np.inf, dtype=np.float64)

    # Early exit if nothing fits
    if not feasible.any():
        return priority

    # ------------------------------------------------------------------
    # 2) Slack after placing the item (only meaningful for feasible bins)
    # ------------------------------------------------------------------
    slack = caps - item  # may be negative for infeasible bins; we ignore those later

    # ------------------------------------------------------------------
    # 3) Exact‑fit detection
    # ------------------------------------------------------------------
    exact_fit = np.abs(slack) <= tolerance
    priority[exact_fit] = exact_bonus

    # ------------------------------------------------------------------
    # 4) Logistic scoring for feasible, non‑exact bins
    # ------------------------------------------------------------------
    non_exact = feasible & ~exact_fit
    if non_exact.any():
        # Normalise slack by the bin's own capacity to obtain a value in [0, 1]
        # (0 = perfect fit, 1 = completely empty bin)
        cap_non_exact = caps[non_exact]
        # Protect against division by zero (should not happen for feasible bins)
        cap_non_exact = np.maximum(cap_non_exact, tolerance)

        slack_non_exact = slack[non_exact]
        norm_slack = slack_non_exact / cap_non_exact  # ∈ [0, 1]

        # Fit quality: higher when the slack is small
        fit_score = 1.0 - norm_slack  # ∈ [0, 1]; 1 = perfect fit

        # Logistic transformation
        # sigmoid(z) = 1 / (1 + exp(-z)), where z = alpha * (fit_score - mid_point)
        sigmoid_arg = alpha * (fit_score - mid_point)
        # Clip to avoid overflow in exp
        sigmoid_arg = np.clip(sigmoid_arg, -700, 700)
        logistic_score = 1.0 / (1.0 + np.exp(-sigmoid_arg))

        # Tiny random jitter for deterministic tie‑breaking
        jitter = rng.uniform(0.0, 1e-9, size=logistic_score.shape)

        priority[non_exact] = logistic_score + jitter

    # ------------------------------------------------------------------
    # 5) ε‑greedy exploration (replace scores of feasible non‑exact bins)
    # ------------------------------------------------------------------
    if rng.random() < epsilon and non_exact.any():
        # Draw uniform random scores in [0, 1) for each feasible non‑exact bin
        rand_scores = rng.random(non_exact.sum())
        priority[non_exact] = rand_scores
        # Preserve the exact‑fit bonus (ensures exact fits still dominate)
        priority[exact_fit] = exact_bonus

    return priority
```
