```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute smooth priority scores for online bin packing.

    For each open bin the function evaluates how tightly the incoming item
    would fit.  The score is a logistic transformation of the normalized slack,
    favouring bins that would be left with little free space after insertion.
    Infeasible bins (insufficient remaining capacity) receive a priority of 0.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1â€‘D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores, one per bin. Higher scores indicate more attractive bins.
    """
    # Convert to a NumPy array (ensures vectorised operations and consistent dtype)
    caps = np.asarray(bins_remain_cap, dtype=np.float64)

    # Feasibility mask: only bins with enough free space can be used.
    feasible = caps >= item

    # Initialise priorities to zero (penalise infeasible bins).
    priorities = np.zeros_like(caps, dtype=np.float64)

    # Early exit if no bin can accommodate the item.
    if not feasible.any():
        return priorities

    # Estimate the (common) bin capacity.
    # Using the maximum remaining capacity provides a safe lower bound.
    capacity_est = caps.max()
    capacity_est = max(capacity_est, 1e-12)  # protect against division by zero

    # Slack after placing the item for feasible bins (>= 0 by construction).
    slack = caps[feasible] - item

    # Normalise slack to [0, 1] (0 = perfect fit, 1 = empty bin).
    norm_slack = slack / capacity_est

    # Fit score: larger when slack is smaller.
    fit_score = 1.0 - norm_slack  # 1 = perfect fit, 0 = worst fit

    # Logistic transformation parameters.
    alpha = 12.0   # steepness of the curve (larger => sharper distinction)
    mid_point = 0.5  # centre of the logistic curve in the fit_score domain

    # Compute the logistic argument and clip to avoid overflow in exp().
    logistic_arg = alpha * (fit_score - mid_point)
    logistic_arg = np.clip(logistic_arg, -50.0, 50.0)

    # Convert fit scores to smooth priorities in (0, 1].
    priorities[feasible] = 1.0 / (1.0 + np.exp(-logistic_arg))

    return priorities
```
