```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a Worst‑Fit priority for each bin.

    In the worst‑fit strategy we prefer the bin that will retain the most
    free space after the item is placed.  Bins that cannot accommodate the
    item receive a very low priority (‑inf) so they will never be selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the existing bins.

    Returns
    -------
    np.ndarray
        Array of priority scores with the same shape as `bins_remain_cap`.
        The bin with the highest score should be chosen for the item.
    """
    # Ensure we work with a float array for arithmetic safety.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Mask of bins that have enough room for the item.
    can_fit = caps >= item

    # Slack after insertion: the larger the slack, the better for worst‑fit.
    slack = caps - item

    # Small epsilon proportional to original capacity breaks ties
    # deterministically in favour of the truly larger bin.
    epsilon = 1e-9
    priorities = np.where(can_fit, slack + epsilon * caps, -np.inf)

    return priorities
```
