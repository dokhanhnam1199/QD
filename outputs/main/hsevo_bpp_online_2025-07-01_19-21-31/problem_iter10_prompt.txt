{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization, near-full bonuses, adaptive weighting,\n    and fill percentage, with robust infeasibility handling and calibrated weights.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    epsilon = 1e-9\n\n    # Strong infeasibility penalty\n    infeasible_mask = remaining_after_add < 0\n    priorities[infeasible_mask] = -1e9  # Significantly larger penalty\n\n    valid_mask = remaining_after_add >= 0\n\n    if np.any(valid_mask):\n        # Waste priority (reciprocal, stabilized)\n        waste = remaining_after_add[valid_mask]\n        waste_priority = 1.0 / (waste + 0.1 * item + epsilon)  # Stabilized by item size\n\n        # Near-full bonus (only when item fits reasonably well)\n        near_full_bonus = np.where(\n            (bins_remain_cap[valid_mask] > item) & (bins_remain_cap[valid_mask] <= 2 * item),\n            (item / bins_remain_cap[valid_mask])**2 * 5,  # Reduced magnitude, polynomial\n            0\n        )\n\n        # Fill percentage score\n        fill_percentage = item / bins_remain_cap[valid_mask]\n        fill_score = np.exp(-10 * np.abs(fill_percentage - 0.8)) #Stronger penalty\n\n        # Adaptive weighting based on remaining capacity distribution (dampened)\n        capacity_mean = np.mean(bins_remain_cap[valid_mask]) if np.any(valid_mask) else np.mean(bins_remain_cap)\n        capacity_std = np.std(bins_remain_cap[valid_mask]) if np.any(valid_mask) and len(bins_remain_cap[valid_mask]) > 1 else 0.1\n        capacity_normalized = (bins_remain_cap[valid_mask] - capacity_mean) / (capacity_std + epsilon)\n        capacity_weight = 0.5 + 0.5 * np.tanh(capacity_normalized)  # Scaled tanh for stability\n\n\n        # Calibrated weights (data-driven tuning is essential)\n        waste_weight = 1.0\n        near_full_weight = 0.75 # Reduced near-full weight\n        fill_weight = 0.6 # Reduced fill weight\n        capacity_weight_final = 0.25\n\n\n        priorities[valid_mask] = (\n            waste_weight * waste_priority\n            + near_full_weight * near_full_bonus\n            + fill_weight * fill_score\n            + capacity_weight_final*capacity_weight\n        )\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}