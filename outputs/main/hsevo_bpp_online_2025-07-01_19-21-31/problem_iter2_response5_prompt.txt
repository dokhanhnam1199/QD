{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving too much wasted space.  Bins that cannot accommodate the item\n    receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very low priority to bins that cannot accommodate the item\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # For feasible bins, calculate wasted space\n    waste = bins_remain_cap - item\n    feasible = bins_remain_cap >= item\n\n    # Prioritize bins with less wasted space, but also penalize nearly full bins\n    # to encourage consolidating smaller items into less-full bins.\n    priorities[feasible] = (bins_remain_cap[feasible] / (item + 1e-9)) - (waste[feasible]**2) #Adding small epsilon value to avoid potential divide by zero errors\n    #Boosting factor to prioritize near-fit bins:\n\n    near_fit = (bins_remain_cap >= item) & (waste < 0.1) # If waste is less than 0.1 capacity of bin.\n    priorities[near_fit] = priorities[near_fit] + 2  # Boost near-fit bins\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1.  Remaining capacity: Bins with capacity close to the item size are preferred (First-Fit Decreasing variant).\n    2.  Waste minimization: Penalize bins that will have significant waste after packing the item.\n    3.  Number of Items: Favors to add into the bin containing more items.\n    4.  Bin Utilization: Consider the fullness of each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Avoid division by zero and log(0)\n\n    # Factor 1: Remaining capacity matching the item size. Higher is better when close match.\n    capacity_match = np.exp(-np.abs(bins_remain_cap - item) / (item + epsilon))\n\n    # Factor 2: Waste minimization - penalize high waste. Lower waste gives higher priority.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    # Factor 3: Encourage filling partially full bins by bin utilization.\n    # (Assume bins initially have same max capacity)\n    # This would require you to know the initial max capacity, bin_max_cap\n    # But we are making it by making assumption that partially_full_bins exist\n    # in the bin cap, then pick these up. If bins_remain_cap is all zeros, this factor will have very little influence.\n    partially_full_bins = np.where((bins_remain_cap > item) & (bins_remain_cap < np.max(bins_remain_cap)), 1, 0)\n    fill_priority = partially_full_bins\n\n    # Combine the factors. Experiment with weights to adjust the influence of each factor.\n    priorities = 0.6 * capacity_match + 0.3 * waste_penalty + 0.1 * fill_priority\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic avoids division by zero errors and has a mechanism to discourage filling bins completely. The 20th heuristic, while considering waste minimization and future potential reward, lacks explicit handling of edge cases and complete filling.\n\nComparing (2nd) vs (19th), 2nd heuristic boosts priority when near full and adds ratio of item size, while 19th heuristic calculates waste penalty.\n\nComparing (3rd) vs (4th), the 3rd heuristic uses a Newtonian \"gravitational attraction\" analogy, penalizing bins that are too full with negative infinity. The 4th heuristic gives a negative priority to almost full bins.\n\nComparing (second worst) vs (worst), the 17th heuristic considers a balance between minimizing waste and future potential reward, incorporating an estimate of item size standard deviation, while 20th heuristic do the same as 17th heuristic.\n\nComparing (1st) vs (2nd), the 1st heuristic avoid division by zero by adding a small value while 2nd heuristic avoid division by zero in another way by adding small value to denominator.\n\nComparing (3rd) vs (4th), heuristic 3 uses -np.inf to penalize, while heuristic 4 uses -1000 value.\n\nOverall: The better heuristics appear to prioritize avoiding edge cases (division by zero), encourage fuller bins without completely filling them, consider waste minimization, and some mechanism to avoid extreme fragmentation. Simpler heuristics focusing on the core logic of fitting and waste performed better than complex analogies. Penalties for infeasible bins vary in magnitude, but large negative values are common. The better heuristics combined multiple factors, such as remaining capacity and waste, using weighted sums or other combination methods.\n- \nOkay, let's refine \"Current Self-Reflection\" to make it more effective for designing heuristics, steering clear of pitfalls.\n\nHere's a revised approach, focusing on a proactive and analytical mindset:\n\n*   **Keywords:** Robustness, Simplicity, Penalties, Critical Analysis, Iterative Refinement.\n*   **Advice:** Systematically test heuristic performance on diverse datasets, including edge cases. Analyze *why* failures occur. Prioritize ease of understanding and modification.\n*   **Avoid:** Solely focusing on initial success. Blindly applying penalties without understanding their impact on overall solution quality. Premature optimization.\n*   **Explanation:** Heuristics should be tested rigorously. Penalties help in exploration, but require careful calibration. Simple heuristics allow easier analysis. Iterative refinement is key to improvement.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}