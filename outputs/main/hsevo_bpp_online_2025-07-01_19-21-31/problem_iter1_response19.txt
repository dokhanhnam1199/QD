```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item without
    leaving too much wasted space.  Bins that cannot accommodate the item
    receive a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give very low priority to bins that cannot accommodate the item
    infeasible = bins_remain_cap < item
    priorities[infeasible] = -np.inf

    # For feasible bins, calculate wasted space
    waste = bins_remain_cap - item
    feasible = bins_remain_cap >= item

    # Prioritize bins with less wasted space, but also penalize nearly full bins
    # to encourage consolidating smaller items into less-full bins.
    priorities[feasible] = (bins_remain_cap[feasible] / (item + 1e-9)) - (waste[feasible]**2) #Adding small epsilon value to avoid potential divide by zero errors
    #Boosting factor to prioritize near-fit bins:

    near_fit = (bins_remain_cap >= item) & (waste < 0.1) # If waste is less than 0.1 capacity of bin.
    priorities[near_fit] = priorities[near_fit] + 2  # Boost near-fit bins

    return priorities
```
