```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal waste,
    while also considering the overall fullness of the bin. It introduces a penalty
    for bins that are either too full or have excessive remaining capacity after
    packing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9
    # Make sure no division by zero or negative values
    effective_capacities = np.maximum(bins_remain_cap, epsilon)

    # 1. Base Priority: Favor bins that can fit the item.  Set to negative infinity if it doesn't fit.
    priority = np.zeros_like(bins_remain_cap)
    priority[bins_remain_cap < item] = -np.inf
    
    # 2. Waste Optimization:  Minimize wasted space after packing. Higher priority for bins where the remaining space is minimal after adding the item.
    waste = effective_capacities - item
    waste = np.maximum(waste, 0)  # Ensure no negative waste

    # Use inverse of waste to boost priority - smaller waste, higher priority.  Add an epsilon to avoid division by zero.
    priority[bins_remain_cap >= item] += 1.0 / (waste[bins_remain_cap >= item] + epsilon)


    # 3. Fullness consideration: Moderate penalty for nearly empty bins
    # A bin that's mostly empty should be less appealing to place an item into
    # as we want to maximize use of bins
    bin_fullness = 1.0 - (effective_capacities / np.max(bins_remain_cap)) # Normalized Fullness (0 is empty, 1 is full)

    priority -= 0.1 * (1 - bin_fullness) # Apply a slight penalty based on emptiness

    return priority
```
