```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits, preferring bins with closer remaining capacity.
    If the item does not fit, it assigns a very low (negative) priority based on how much the bin would overflow.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find indices where the item fits
    fits = bins_remain_cap >= item

    # Calculate closeness for bins where the item fits
    if np.any(fits):
      closeness = bins_remain_cap[fits] - item
      priorities[fits] = 1.0 / (1e-6 + closeness)  # Prioritize smaller remaining space
      priorities[fits] = priorities[fits]/np.sum(priorities[fits])
    # Assign a negative priority proportional to overflow if the item doesn't fit
    overflow = item - bins_remain_cap[~fits]
    priorities[~fits] = -overflow  # Negative priority for bins that don't fit

    return priorities
```
