```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines best-fit and fill percentage, adaptively weights them based on problem state."""

    epsilon = 1e-9
    bins_remain_cap = np.maximum(bins_remain_cap, epsilon)

    # 1. Fit Score: Prioritize minimal waste.
    waste = bins_remain_cap - item
    fit_score = np.where(waste >= 0, np.exp(-waste), -np.inf)

    # 2. Fill Percentage: Target near full bins.
    fill_percentage = item / bins_remain_cap
    fill_score = np.where(bins_remain_cap >= item, np.exp(-np.abs(fill_percentage - 0.8)), -np.inf)

    # 3. Adaptive Weighting: Adjust based on item size.
    # Small items favor fill_score, large items favor fit_score.
    weight = np.clip(item, 0.3, 0.7)  # Item size determines fit importance
    priority = (1 - weight) * fit_score + weight * fill_score

    # 4. small_space_penalty for near-full bins
    post_fill = bins_remain_cap - item
    small_space_penalty = -10
    priority[bins_remain_cap >= item & (post_fill < 0.1)] += small_space_penalty

    return priority
```
