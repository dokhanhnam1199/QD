```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Employing Newtonian heuristics based on potential energy and a notion of
    "gravitational attraction" between the item and the bin.

    Args:
        item: Size of item to be added to the bin (representing mass).
        bins_remain_cap: Array of capacities for each bin (representing distance).

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure no division by zero or negative values. Add a small epsilon for stability.
    epsilon = 1e-9
    effective_capacities = np.maximum(bins_remain_cap, epsilon)

    # Newtonian "gravitational attraction" - Larger capacity, stronger attraction (higher priority).
    # Also favor bins where the item fills a significant portion of the remaining space.
    # A higher 'G' would signify our tendency towards packing fuller bins.

    G = 1.0 # Gravitational constant - tune this based on desired packing density. Higher G encourages fuller bins
    priority = G * (item / effective_capacities**2) * np.exp(-np.abs(item - effective_capacities)) # attraction is proportional to 1/(distance)^2 multiplied with exponentially reducing difference

    # Penalize bins that are too full (not enough space for the item) using a large negative value.
    priority[bins_remain_cap < item] = -np.inf

    return priority
```
