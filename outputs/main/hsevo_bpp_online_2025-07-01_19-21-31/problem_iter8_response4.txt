```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptively combines waste, fill ratio, and capacity."""

    epsilon = 1e-9
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Infeasible bins get strongly negative priority
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Fill ratio score, penalizing deviation from perfect fit
    ratios = item / (bins_remain_cap + epsilon)
    fill_score = np.exp(-np.abs(ratios - 1) * 5)

    # Waste priority: higher priority for less waste, exponential decay
    waste = bins_remain_cap - item
    waste_priority = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), 0)

    # Capacity based priority: favor bins with larger remaining capacity.  sqrt for diminishing returns
    capacity_priority = np.sqrt(bins_remain_cap) / (item + epsilon)

    # Adaptive weighting based on remaining capacities
    total_capacity = np.sum(bins_remain_cap)
    if total_capacity > 0:
        waste_weight = min(1.0, item / total_capacity) # Adjust waste importance based on item size
        fill_weight = 0.5 - waste_weight/2
        capacity_weight = 0.5 - waste_weight/2

        priorities = np.where(~infeasible_mask, waste_weight * waste_priority + fill_weight * fill_score + capacity_weight * capacity_priority, priorities)
    else:
        priorities = np.zeros_like(bins_remain_cap, dtype=float) # no bins to put the item

    return priorities
```
