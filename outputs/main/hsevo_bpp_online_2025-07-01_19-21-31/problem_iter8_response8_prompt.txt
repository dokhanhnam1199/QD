{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines waste minimization, near-full bonus, capacity consideration, and adaptive weighting.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    epsilon = 1e-9\n\n    # Infeasible bins get strongly negative priority\n    infeasible_mask = remaining_after_add < 0\n    priorities[infeasible_mask] = -np.inf\n\n    # Waste priority, use reciprocal of waste\n    waste = np.abs(remaining_after_add)\n    waste_priority = 1.0 / (waste + epsilon)\n\n    # Near-full bonus, give bonus to near full bins\n    near_full_bonus = np.where((bins_remain_cap > item) & (bins_remain_cap <= 2 * item), item / bins_remain_cap * 10, 0)\n    \n    # Capacity based priority, favor larger remaining capacity\n    capacity_priority = np.sqrt(bins_remain_cap) / (item + epsilon)\n\n    # Adaptive weighting based on remaining capacity\n    total_capacity = np.sum(bins_remain_cap)\n    waste_weight = 0.4\n    near_full_weight = 0.3\n    capacity_weight = 0.3\n    \n    if total_capacity < 5 * item:\n        waste_weight = 0.2\n        near_full_weight = 0.5\n        capacity_weight = 0.3\n    elif total_capacity > 20 * item:\n        waste_weight = 0.5\n        near_full_weight = 0.2\n        capacity_weight = 0.3\n    \n\n    # Combine all priorities with adaptive weights\n    priorities = np.where(~infeasible_mask, waste_weight * waste_priority + near_full_weight * near_full_bonus + capacity_weight * capacity_priority, priorities)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on waste, fill percentage, and infeasibility.\"\"\"\n    epsilon = 1e-9\n    bins_remain_cap = np.maximum(bins_remain_cap, epsilon)\n\n    # 1. Fit Score: Exponential decay for waste, -inf if item doesn't fit\n    waste = bins_remain_cap - item\n    fit_score = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    # 2. Fill Percentage: Encourage filling bins completely, target 80% fill\n    fill_percentage = item / bins_remain_cap\n    fill_score = np.where(bins_remain_cap >= item, np.exp(-np.abs(fill_percentage - 0.8)), -np.inf)\n\n    # 3. Combine the scores with weights.\n    priority = 0.7 * fit_score + 0.3 * fill_score\n\n    return priority\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic uses adaptive weighting based on the remaining capacity distribution, calculated by standardizing the remaining capacity. The 20th heuristic uses a fixed weighting of fill score, waste penalty and near-full penalty.\n(2nd best) vs (second worst) we see that the 2nd heuristic adapts weights based on total capacity relative to item size, using a rule-based system, while the 19th heuristic uses fixed weights combining fill score, waste penalty, and a near-full penalty. The 2nd heuristic is more complex in adapting the weights.\nComparing (1st) vs (2nd), we see the 1st uses mean and std of remaining capacity to adapt weights via tanh function. While the 2nd adapts weights based on total capacity with threshold.\n(3rd) vs (4th) they are identical.\nComparing (second worst) vs (worst), they are identical.\nOverall: The better heuristics tend to incorporate more sophisticated adaptive weighting schemes that consider the distribution of remaining capacities or item sizes. They dynamically adjust the weights given to waste minimization, near-full bonuses, and capacity considerations. Simpler heuristics rely on fixed weights or basic conditional logic based on total capacity. Exponential decays appear to be helpful for weighing the waste. Penalties for bins that are almost full, or almost empty, can also improve the results.\n- \nOkay, let's refine \"Current self-reflection\" to build better heuristics, avoiding the pitfalls of \"Ineffective self-reflection\".\n\nHere's a revised approach focusing on robust, adaptable, and well-grounded heuristic design:\n\n*   **Keywords:** Adaptive weighting, infeasibility penalties, factor combination, numerical stability, data-driven calibration.\n*   **Advice:** Design heuristics by combining relevant factors with adaptive weights and appropriate functional forms. Focus on clear, well-defined objectives.\n*   **Avoid:** Over-complication, excessive focus on edge cases at the expense of core performance, relying solely on intuition.\n*   **Explanation:** Create heuristics that are both adaptable to the problem's characteristics and robust against numerical issues, grounding design choices in data and experimentation. Prioritize penalties over bonuses.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}