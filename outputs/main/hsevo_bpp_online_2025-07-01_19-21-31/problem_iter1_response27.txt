```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version combines several heuristics inspired by physical principles:
    1. Energy Minimization: Prefers bins where the item fits with minimal wasted space.
    2. Quantum Tunneling: Introduces a small probability to consider bins that are almost full, 
       allowing for escape from local optima (analogous to tunneling through a potential barrier).
    3. Pauli Exclusion: Discourages filling bins completely to avoid ending up with bins that are difficult to fill later.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Energy Minimization: Reward fitting with minimal wasted space.
    waste = bins_remain_cap - item
    valid_bins = waste >= 0
    if np.any(valid_bins):
        priorities[valid_bins] += np.exp(-waste[valid_bins] / item)  # Exponentially prefer lower waste

    # 2. Quantum Tunneling: Give a small chance to almost-full bins.
    almost_full = (bins_remain_cap < item) & (bins_remain_cap > 0) #Consider only almost full bins which are not empty.
    if np.any(almost_full):
        priorities[almost_full] += 0.1 * np.exp(- (item - bins_remain_cap[almost_full])**2 / (0.1 * item)) #Gaussian weighting on almost full to bias to closer values.

    # 3. Pauli Exclusion: Discourage perfect fills. Add a penalty if this item will fill a bin perfectly
    perfect_fit = (waste == 0) & valid_bins
    if np.any(perfect_fit):
        priorities[perfect_fit] -= 0.2  # Slightly penalize perfect fits, but only if they fit.

    # Prioritize based on utilization ratio - favour bins which are already more used, but not close to full
    utilization = (1 - bins_remain_cap / 1.0)
    valid_bins_utilization = utilization > 0.0
    priorities[valid_bins_utilization] += 0.5 * utilization[valid_bins_utilization]  # Favor higher utilization, but not too close to capacity


    return priorities
```
