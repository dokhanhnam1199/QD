```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste, near-full bonus, fill ratio, and adaptive weighting."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Infeasible bins get strongly negative priority
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    valid_mask = ~infeasible_mask

    if np.any(valid_mask):
        # Waste priority: use reciprocal of waste.
        remaining_after_add = bins_remain_cap - item
        waste = np.abs(remaining_after_add)
        waste_priority = item / (waste + epsilon)  # Scale waste by item size

        # Near-full bonus
        near_full_bonus = np.where((bins_remain_cap[valid_mask] > item) & (bins_remain_cap[valid_mask] <= 2 * item), item / bins_remain_cap[valid_mask] * 10, 0)
        # Fill ratio score
        ratios = item / (bins_remain_cap[valid_mask] + epsilon)
        fill_score = np.exp(-np.abs(ratios - 0.8))

        # Adaptive Weighting
        total_capacity = np.sum(bins_remain_cap[valid_mask]) if np.any(valid_mask) else 0.0
        if total_capacity > 0:
            waste_weight = min(1.0, item / total_capacity * 5)
            fill_weight = 1.0 - waste_weight
        else:
            waste_weight = 0.5
            fill_weight = 0.5
        near_full_weight = 0.5  # Additional weight for near-full bins

        # Combine priorities with adaptive weights
        priorities[valid_mask] = (waste_weight * waste_priority[valid_mask] +
                                     fill_weight * fill_score +
                                     near_full_weight * near_full_bonus)

    return priorities
```
