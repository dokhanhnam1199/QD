```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Employing a heuristic inspired by the concept of spacetime curvature.
    Bins with remaining capacity close to the item size exert a higher "gravitational pull,"
    reflecting the higher chance of successful packing and minimizing wasted space.

    A potential energy approach is used: prioritize bins that have
    a remaining capacity slightly larger than the item to minimize
    empty spaces.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the "potential energy" difference: abs(remaining capacity - item size)
    potential_energies = np.abs(bins_remain_cap - item)

    # Invert the potential energy to represent priority: lower energy = higher priority.
    # Add a small constant to avoid division by zero and numerical instability.
    priorities = 1.0 / (potential_energies + 0.0001)

    # Further refine the priority: bins that cannot accommodate the item should have zero priority.
    priorities[bins_remain_cap < item] = 0.0

    # Add a term to favor bins that are not already too empty.
    # This encourages filling bins rather than spreading items too thinly.
    # Avoid division by zero by adding a tiny constant.
    fill_ratios = item / (bins_remain_cap + 0.0001)
    priorities = priorities + 0.5* fill_ratios

    # Scale priorities between 0-1
    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 0.0001)


    return priorities
```
