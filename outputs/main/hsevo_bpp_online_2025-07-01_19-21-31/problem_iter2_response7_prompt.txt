{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can fit the item with minimal waste\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap[fit_mask] - item\n    \n    # Prioritize bins where the item fits well (small waste)\n    if waste.size > 0:  # Avoid errors when waste is empty\n        priorities[fit_mask] = 1.0 / (waste + 0.00001)  # Avoid division by zero\n\n    # Slightly discourage almost full bins to potentially avoid fragmentation\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < item)\n\n    priorities[almost_full_mask] = -1000 # extreme negative priority as item does not fit\n\n    #Return priorities\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # First, consider only bins that can fit the item.\n        capacities = bins_remain_cap[valid_bins]\n        space_waste = capacities - item\n        # Prioritize bins that minimize space waste but not that small it ends up with empty space.\n        priorities[valid_bins] = (capacities**2) / (space_waste + 0.00001)  # avoid div by zero\n    else:\n        # If no bins can fit, perhaps we should minimize the \"overflow\"?\n        # This might depend on problem constraints.\n        priorities = -np.abs(bins_remain_cap - item) # try to add to smallest bin\n        # priorities = item / (bins_remain_cap + 0.0001)  # maybe smaller bins should take burden?\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic avoids division by zero errors and has a mechanism to discourage filling bins completely. The 20th heuristic, while considering waste minimization and future potential reward, lacks explicit handling of edge cases and complete filling.\n\nComparing (2nd) vs (19th), 2nd heuristic boosts priority when near full and adds ratio of item size, while 19th heuristic calculates waste penalty.\n\nComparing (3rd) vs (4th), the 3rd heuristic uses a Newtonian \"gravitational attraction\" analogy, penalizing bins that are too full with negative infinity. The 4th heuristic gives a negative priority to almost full bins.\n\nComparing (second worst) vs (worst), the 17th heuristic considers a balance between minimizing waste and future potential reward, incorporating an estimate of item size standard deviation, while 20th heuristic do the same as 17th heuristic.\n\nComparing (1st) vs (2nd), the 1st heuristic avoid division by zero by adding a small value while 2nd heuristic avoid division by zero in another way by adding small value to denominator.\n\nComparing (3rd) vs (4th), heuristic 3 uses -np.inf to penalize, while heuristic 4 uses -1000 value.\n\nOverall: The better heuristics appear to prioritize avoiding edge cases (division by zero), encourage fuller bins without completely filling them, consider waste minimization, and some mechanism to avoid extreme fragmentation. Simpler heuristics focusing on the core logic of fitting and waste performed better than complex analogies. Penalties for infeasible bins vary in magnitude, but large negative values are common. The better heuristics combined multiple factors, such as remaining capacity and waste, using weighted sums or other combination methods.\n- \nOkay, let's refine \"Current Self-Reflection\" to make it more effective for designing heuristics, steering clear of pitfalls.\n\nHere's a revised approach, focusing on a proactive and analytical mindset:\n\n*   **Keywords:** Robustness, Simplicity, Penalties, Critical Analysis, Iterative Refinement.\n*   **Advice:** Systematically test heuristic performance on diverse datasets, including edge cases. Analyze *why* failures occur. Prioritize ease of understanding and modification.\n*   **Avoid:** Solely focusing on initial success. Blindly applying penalties without understanding their impact on overall solution quality. Premature optimization.\n*   **Explanation:** Heuristics should be tested rigorously. Penalties help in exploration, but require careful calibration. Simple heuristics allow easier analysis. Iterative refinement is key to improvement.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}