```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers several factors:
    1.  Remaining capacity: Bins with capacity close to the item size are preferred (First-Fit Decreasing variant).
    2.  Waste minimization: Penalize bins that will have significant waste after packing the item.
    3.  Number of Items: Favors to add into the bin containing more items.
    4.  Bin Utilization: Consider the fullness of each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9  # Avoid division by zero and log(0)

    # Factor 1: Remaining capacity matching the item size. Higher is better when close match.
    capacity_match = np.exp(-np.abs(bins_remain_cap - item) / (item + epsilon))

    # Factor 2: Waste minimization - penalize high waste. Lower waste gives higher priority.
    waste = bins_remain_cap - item
    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)

    # Factor 3: Encourage filling partially full bins by bin utilization.
    # (Assume bins initially have same max capacity)
    # This would require you to know the initial max capacity, bin_max_cap
    # But we are making it by making assumption that partially_full_bins exist
    # in the bin cap, then pick these up. If bins_remain_cap is all zeros, this factor will have very little influence.
    partially_full_bins = np.where((bins_remain_cap > item) & (bins_remain_cap < np.max(bins_remain_cap)), 1, 0)
    fill_priority = partially_full_bins

    # Combine the factors. Experiment with weights to adjust the influence of each factor.
    priorities = 0.6 * capacity_match + 0.3 * waste_penalty + 0.1 * fill_priority

    return priorities
```
