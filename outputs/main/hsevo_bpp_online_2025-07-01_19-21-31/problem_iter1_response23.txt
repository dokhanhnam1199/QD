```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a low value.  This avoids assigning bins
    # that can't even fit the item in the first place.
    priorities = np.full(bins_remain_cap.shape, -np.inf)

    # Bins that *can* fit the item get priority boost:
    valid_bins = bins_remain_cap >= item
    if np.any(valid_bins): # if any valid bins exist
        # 1. Try to fill the bin as much as possible, prefer smaller gaps
        gap = bins_remain_cap[valid_bins] - item
        priorities[valid_bins] = -gap

        # 2. Use a tie-breaker when gap is the same; prefer bins with higher
        # remaining capacity overall. Helps with even item distribution.
        priorities[valid_bins] += bins_remain_cap[valid_bins] * 0.0001 #Small epsilon to ensure the original values are prioritized when all calculations remain equal

        # 3. A secondary heuristic may come to play if all the bins have the same gap:
        #    Let's give more priority to a bin if there exist another item with the same size.
        # priorities[valid_bins] += item * 0.00000001  This cannot be done in the online settings since items are received on by one.

    return priorities
```
