{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Adaptive weights based on item size and capacity distribution.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    epsilon = 1e-9\n\n    # Infeasible bins get strongly negative priority\n    infeasible_mask = remaining_after_add < 0\n    priorities[infeasible_mask] = -np.inf\n\n    # Waste priority, use reciprocal of waste\n    waste = np.abs(remaining_after_add)\n    waste_priority = 1.0 / (waste + epsilon)\n\n    # Near-full bonus, give bonus to near full bins\n    near_full_bonus = np.where((bins_remain_cap > item) & (bins_remain_cap <= 2 * item), item / bins_remain_cap * 10, 0)\n    \n    # Capacity based priority, favor larger remaining capacity\n    capacity_priority = np.sqrt(bins_remain_cap) / (item + epsilon)\n\n    # Adaptive weighting based on remaining capacity distribution\n    capacity_mean = np.mean(bins_remain_cap[bins_remain_cap >= item]) if np.any(bins_remain_cap >= item) else np.mean(bins_remain_cap) #Avoid empty array\n    capacity_std = np.std(bins_remain_cap[bins_remain_cap >= item]) if np.any(bins_remain_cap >= item) and len(bins_remain_cap[bins_remain_cap >= item]) > 1 else 0.1 # Avoid empty array and zero std\n    \n    #weights\n    waste_weight = 1.0\n    near_full_weight = 1.0\n    capacity_weight = 1.0\n    \n    if capacity_std > 0.0:\n        capacity_normalized = (bins_remain_cap - capacity_mean) / capacity_std #standardize remaining capacity\n        capacity_weight = 1.0 + np.tanh(capacity_normalized) #adaptive: favors bins more above the mean\n\n    # Adaptive weighting based on item size\n    if item > 0.5: # Large items, prioritize waste minimization and near-full\n        waste_weight = 0.6\n        near_full_weight = 0.3\n        capacity_weight = 0.1\n    else: # Small items, prioritize capacity and near-full\n        waste_weight = 0.2\n        near_full_weight = 0.4\n        capacity_weight = 0.4\n\n    # Combine all priorities with adaptive weights\n    valid_mask = remaining_after_add >= 0\n    priorities[valid_mask] = waste_weight * waste_priority[valid_mask] + near_full_weight * near_full_bonus[valid_mask] + capacity_weight * capacity_priority[valid_mask]\n\n    # Experiment with a different bonus structure for very small remaining capacity\n    very_small_bonus = np.where((remaining_after_add > 0) & (remaining_after_add < 0.1), 100/(remaining_after_add + epsilon), 0)\n\n    priorities[valid_mask] = priorities[valid_mask] + very_small_bonus[valid_mask]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines waste minimization, near-full bonuses, adaptive weighting,\n    and explicit penalties for creating small remaining gaps.\n\n    Prioritizes bins that:\n    1. Fit the item (strongly penalizes infeasible bins)\n    2. Minimize waste after packing\n    3. Avoid creating very small gaps which are hard to fill later\n    4. Adapts to capacity distribution.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_after_add = bins_remain_cap - item\n    epsilon = 1e-9\n\n    # --- Infeasibility Penalty ---\n    infeasible_mask = remaining_after_add < 0\n    priorities[infeasible_mask] = -1e9  # Very strong penalty\n\n    valid_mask = remaining_after_add >= 0\n\n    if np.any(valid_mask):\n        # --- Waste Minimization ---\n        waste = remaining_after_add[valid_mask]\n        waste_priority = -waste  # Lower waste is better (negative waste)\n\n        # --- Small Gap Penalty ---\n        small_gap_threshold = 0.1  #tunable, prevents creating small gaps\n        small_gap_penalty = np.where((remaining_after_add[valid_mask] > 0) & (remaining_after_add[valid_mask] < small_gap_threshold), -100, 0)  # Penalty for creating tiny gaps. tunable scalar\n       \n\n        # --- Adaptive Weighting based on Capacity Distribution ---\n        capacity_mean = np.mean(bins_remain_cap[valid_mask]) if np.any(valid_mask) else np.mean(bins_remain_cap)\n        capacity_std = np.std(bins_remain_cap[valid_mask]) if np.any(valid_mask) and len(bins_remain_cap[valid_mask]) > 1 else 0.1\n\n        capacity_normalized = (bins_remain_cap[valid_mask] - capacity_mean) / (capacity_std + epsilon)\n        capacity_priority = np.tanh(capacity_normalized) # Prioritize bins further from the mean, normalized\n        \n        # --- Near-Full Bonus (weaker)---\n        near_full_bonus = np.where((bins_remain_cap[valid_mask] > item) & (bins_remain_cap[valid_mask] <= 2 * item), item / bins_remain_cap[valid_mask] * 10, 0)\n\n        # --- Combine Priorities ---\n        waste_weight = 1.0\n        small_gap_weight = 1.0\n        capacity_weight = 0.5 # Lower importance\n        near_full_weight = 0.1\n\n        priorities[valid_mask] = (\n            waste_weight * waste_priority +\n            small_gap_weight * small_gap_penalty +\n            capacity_weight * capacity_priority +\n            near_full_weight * near_full_bonus\n        )\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates waste minimization, near-full bonuses, adaptive weighting based on capacity distribution, and a fill percentage score, whereas the worst only considers waste, near-full penalty, and capacity, with adaptive weighting based on total capacity. (2nd best) vs (second worst) reveals similar attributes. Comparing (1st) vs (2nd), no code differences between the two. (3rd) vs (4th), the 4th introduces a larger infeasibility penalty, adjusts the near-full bonus with power, reduces capacity weight, sharpens the fill percentage peak, and adds a penalty for bins with very little remaining capacity. (second worst) vs (worst), little change in functionality. Overall: The better performing heuristics combine multiple factors (waste, near-fullness, capacity distribution, fill percentage) with carefully tuned weights and penalties, while the worse performing ones use fewer factors and simpler weighting schemes. The best heuristics also show refinement in handling infeasibility and edge cases.\n- \nOkay, let's refine \"Current Self-Reflection\" for designing better heuristics. Aim for actionable insights that avoid the pitfalls of ineffective self-reflection.\n\nHere's a breakdown:\n\n*   **Keywords:** Adaptive weights, factor combination, infeasibility penalties, experimental calibration, numerical stability, problem context.\n\n*   **Advice:** Design heuristics that intelligently combine relevant factors using adaptive weighting schemes informed by data characteristics and problem context. Prioritize penalties for infeasibility.\n\n*   **Avoid:** Simple implementations that overlook problem nuances, relying solely on penalties, ignoring potential rewards, skipping data-driven parameter tuning.\n\n*   **Explanation:** Move beyond basic implementations. Adaptive weighting, calibrated by experimentation and problem context, allows for better heuristic performance. Consider rewards, not *just* penalties.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}