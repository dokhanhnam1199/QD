```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that are close to full after adding the item,
    but also penalizes bins where the item would cause significant wasted space.
    A balance is struck using a weighting factor.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    potential_remain_cap = bins_remain_cap - item
    fit_mask = potential_remain_cap >= 0

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Prioritize bins where the item fits
    if np.any(fit_mask):
        # Remaining capacity after fitting
        remaining_capacity = potential_remain_cap[fit_mask]
        
        # Score based on how full the bin becomes: closer to zero remaining, higher score
        fullness_score = 1.0 / (remaining_capacity + 1e-9)  # Adding a small constant for numerical stability
        
        # Penalize bins with very small remaining capacity to avoid fragmentation
        fragmentation_penalty = np.exp(-10 * remaining_capacity)
        
        # Weighting to balance fullness and fragmentation (experiment with this!)
        weighted_score = fullness_score - 0.5 * fragmentation_penalty  # Adjust 0.5

        priorities[fit_mask] = weighted_score


    return priorities
```
