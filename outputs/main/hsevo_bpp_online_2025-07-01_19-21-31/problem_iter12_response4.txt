```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines waste minimization, near-full bonuses, adaptive weighting,
    fragmentation penalty, and a global bin utilization target.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_after_add = bins_remain_cap - item
    epsilon = 1e-9

    # Infeasible bins get strongly negative priority, but with a decreasing penalty
    # as the item size approaches the bin capacity.
    infeasible_mask = remaining_after_add < 0
    priorities[infeasible_mask] = -1e9 * (1 + np.abs(remaining_after_add[infeasible_mask]) / (item + epsilon))

    valid_mask = remaining_after_add >= 0

    if np.any(valid_mask):
        # Waste priority, use reciprocal of waste, scaled by item size
        waste = np.abs(remaining_after_add[valid_mask])
        waste_priority = item / (waste + epsilon)

        # Near-full bonus, give a bonus to near-full bins, non-linear bonus
        near_full_bonus = np.where((bins_remain_cap[valid_mask] > item) & (bins_remain_cap[valid_mask] <= 2 * item),
                                    (item / bins_remain_cap[valid_mask])**2 * 10, 0)

        # Fragmentation penalty: penalize bins that will have small remaining space
        fragmentation_threshold = 0.1  #tunable parameter, relative to bin capacity
        fragmentation_penalty = np.where((remaining_after_add[valid_mask] > 0) & (remaining_after_add[valid_mask] < fragmentation_threshold),
                                        -10 * (fragmentation_threshold - remaining_after_add[valid_mask]), 0) #linear penalty


        # Global Bin Utilization Target
        target_utilization = 0.85  # Target utilization percentage. Tunable parameter
        utilization_deviation = np.abs(bins_remain_cap[valid_mask] - (1 - target_utilization)) #Distance from target
        utilization_score = np.exp(-utilization_deviation * 10) # High deviation -> low score


        # Adaptive weighting based on remaining capacity distribution
        capacity_mean = np.mean(bins_remain_cap[valid_mask]) if np.any(valid_mask) else np.mean(bins_remain_cap)
        capacity_std = np.std(bins_remain_cap[valid_mask]) if np.any(valid_mask) and len(bins_remain_cap[valid_mask]) > 1 else 0.1

        waste_weight = 1.0
        near_full_weight = 1.0
        fragmentation_weight = 1.0
        utilization_weight = 0.5 #Less weight than waste or near full weight

        capacity_weight = 1.0

        if capacity_std > 0.0:
            capacity_normalized = (bins_remain_cap[valid_mask] - capacity_mean) / capacity_std
            capacity_weight = 1.0 + np.tanh(capacity_normalized)

        priorities[valid_mask] = (waste_weight * waste_priority +
                                   near_full_weight * near_full_bonus +
                                   fragmentation_weight * fragmentation_penalty +
                                   utilization_weight * utilization_score +
                                   capacity_weight)
        #Fill Percentage Score is removed as it is similar to near_full_bonus, waste_priority, and bin_utilization target.

    return priorities
```
