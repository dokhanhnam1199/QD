```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, near-full bonus, capacity, and adaptive weights based on bin utilization."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Infeasible bins get strongly negative priority
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Waste priority, use exponential decay
    waste = bins_remain_cap - item
    feasible_mask = bins_remain_cap >= item
    priorities[feasible_mask] = np.exp(-waste[feasible_mask] / (item + epsilon))

    # Near-full bonus, give bonus to near full bins, scaled by item size
    near_full_mask = (bins_remain_cap >= item) & (waste < 0.1)
    priorities[near_full_mask] += 2

    # Capacity based priority, favor larger remaining capacity.
    capacity_priority = np.sqrt(bins_remain_cap) / (item + epsilon)
    priorities[feasible_mask] += 0.5 * capacity_priority[feasible_mask]

    # Adaptive Weighting based on bin utilization
    bin_utilization = (bins_remain_cap - waste) / (bins_remain_cap + epsilon)
    
    #Adaptive item size-related penalty on near full bins
    nearly_full_penalty = np.where((feasible_mask) & (waste < 0.1 * bins_remain_cap), -item, 0)
    priorities += nearly_full_penalty
    
    utilization_mean = np.mean(bin_utilization[feasible_mask]) if np.any(feasible_mask) else 0.5
    
    waste_weight = 0.4
    near_full_weight = 0.3
    capacity_weight = 0.3

    priorities[feasible_mask] = (waste_weight * np.exp(-waste[feasible_mask] / (item + epsilon)) +
                                 near_full_weight * near_full_mask[feasible_mask]*2 +
                                 capacity_weight * capacity_priority[feasible_mask])
    return priorities
```
