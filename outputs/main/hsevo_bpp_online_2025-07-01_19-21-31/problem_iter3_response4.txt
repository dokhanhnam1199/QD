```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that are a good fit for the item,
    while also considering the overall fill level of the bin.  It aims to
    avoid both overly empty bins and bins that are almost, but not quite,
    large enough.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of priority scores for each bin.
    """
    epsilon = 1e-9
    effective_capacities = np.maximum(bins_remain_cap, epsilon)

    # 1. Fit Score: How well the item fits relative to remaining capacity.
    fit_score = np.exp(-np.abs(effective_capacities - item) / (0.2 * item + epsilon))  # Favor closer fits.  Scale the exponent by item size
    # 2. Capacity Utilization:  Encourage filling bins reasonably well.
    utilization_score = effective_capacities / np.sum(bins_remain_cap + epsilon) #normalized remaining capacity - high remaining capacity reduces priority.

    # 3. Combine the scores
    priority = fit_score - 0.1 * utilization_score # subtract to increase priority for the ones with lowest remaining capacity, and balance between the two scores

    # 4. Strong penalty for bins that are too small.
    priority[bins_remain_cap < item] = -np.inf

    return priority
```
