```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version attempts to balance filling bins effectively
    while also trying to leave a bit of space for potential
    smaller items later.  We give higher priority to bins that
    can almost perfectly fit the item, but penalize bins that
    are either too small or have *much* more capacity than
    the item. It also adds some "quantum fluctuation" noise.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity < item:
            priorities[i] = -np.inf  # Can't fit, very low priority

        elif capacity == item:
            priorities[i] = 10.0 # Perfect fit!  High priority!

        else:
            # Capacity is larger than the item size.
            # Prioritize bins where item takes a significant fraction
            # but not too much
            fill_ratio = item / capacity
            if fill_ratio > 0.7:
              priorities[i] = 5 + (1 - fill_ratio)*5 # High Priority but decaying

            elif fill_ratio > 0.3 :
              priorities[i] = fill_ratio * 3 #Medium Priority, scaled fill
            else:
              priorities[i] = -fill_ratio  #Low Priority, discourage large difference


            # Quantum Noise - Small random fluctuations
            priorities[i] += np.random.normal(0, 0.1)

    return priorities
```
