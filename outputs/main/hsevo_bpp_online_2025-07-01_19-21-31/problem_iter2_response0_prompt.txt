{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins where the item fits and the remaining space is minimized (but not zero).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # Calculate waste if item is placed in each valid bin\n        waste = bins_remain_cap[valid_bins] - item\n        # Prioritize bins with smallest waste (but avoid 0 waste if possible)\n        priorities[valid_bins] = 1 / (waste + 0.0001) #Adding a small value to avoid division by zero errors\n\n        #Adjust to avoid filling the bin completely. A small penalty is added to bins where waste is below a thershold, if possible.\n\n        min_waste_val = np.min(waste)\n        waste_threshold = 0.1\n        small_waste_bins = waste < waste_threshold\n        if np.any(small_waste_bins):\n            priorities[valid_bins][small_waste_bins] -= 0.1 * priorities[valid_bins][small_waste_bins]\n    else:\n        # If no bin fits, penalize all bins severely\n        priorities = np.full_like(bins_remain_cap, -1000.0)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a more complex heuristic based on available capacity and a penalty\n    for bins that would become almost full (risk of future blockage).\n    Mimics accretion disk physics: favoring filling 'near-full' bins.\n    We want to penalize bins that filling them would leave them too full or nearly empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Base priority: higher for smaller remaining capacity (avoid opening new bins)\n            base_priority = 1 / (remaining_capacity + 1e-9) #avoid division by 0\n\n            # Capacity based heuristic.\n            new_capacity = remaining_capacity - item\n            \n            # Near full bin penalty (mimic singularity behavior - packing becomes harder).\n            if new_capacity < 0.1:  # If remaining capacity would be very low, greatly penalize\n                near_full_penalty = -100  # Big penalty\n            elif new_capacity < 0.3 : # Slightly full\n                near_full_penalty = -2 * (0.3 - new_capacity)**2 # Small Penalty\n            else:\n                near_full_penalty = 0\n\n            # Near empty bin penalty (penalize fragmenting bins).\n            if new_capacity > 0.7:\n                 near_empty_penalty = -0.5 * (new_capacity - 0.7)**2\n            else:\n                near_empty_penalty = 0\n\n            # Overall Priority score is balance of capacity and penalty\n            priorities[i] = base_priority + near_full_penalty + near_empty_penalty\n        else:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st heuristic avoids division by zero errors and has a mechanism to discourage filling bins completely. The 20th heuristic, while considering waste minimization and future potential reward, lacks explicit handling of edge cases and complete filling.\n\nComparing (2nd) vs (19th), 2nd heuristic boosts priority when near full and adds ratio of item size, while 19th heuristic calculates waste penalty.\n\nComparing (3rd) vs (4th), the 3rd heuristic uses a Newtonian \"gravitational attraction\" analogy, penalizing bins that are too full with negative infinity. The 4th heuristic gives a negative priority to almost full bins.\n\nComparing (second worst) vs (worst), the 17th heuristic considers a balance between minimizing waste and future potential reward, incorporating an estimate of item size standard deviation, while 20th heuristic do the same as 17th heuristic.\n\nComparing (1st) vs (2nd), the 1st heuristic avoid division by zero by adding a small value while 2nd heuristic avoid division by zero in another way by adding small value to denominator.\n\nComparing (3rd) vs (4th), heuristic 3 uses -np.inf to penalize, while heuristic 4 uses -1000 value.\n\nOverall: The better heuristics appear to prioritize avoiding edge cases (division by zero), encourage fuller bins without completely filling them, consider waste minimization, and some mechanism to avoid extreme fragmentation. Simpler heuristics focusing on the core logic of fitting and waste performed better than complex analogies. Penalties for infeasible bins vary in magnitude, but large negative values are common. The better heuristics combined multiple factors, such as remaining capacity and waste, using weighted sums or other combination methods.\n- \nOkay, let's refine \"Current Self-Reflection\" to make it more effective for designing heuristics, steering clear of pitfalls.\n\nHere's a revised approach, focusing on a proactive and analytical mindset:\n\n*   **Keywords:** Robustness, Simplicity, Penalties, Critical Analysis, Iterative Refinement.\n*   **Advice:** Systematically test heuristic performance on diverse datasets, including edge cases. Analyze *why* failures occur. Prioritize ease of understanding and modification.\n*   **Avoid:** Solely focusing on initial success. Blindly applying penalties without understanding their impact on overall solution quality. Premature optimization.\n*   **Explanation:** Heuristics should be tested rigorously. Penalties help in exploration, but require careful calibration. Simple heuristics allow easier analysis. Iterative refinement is key to improvement.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}