```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, near-full bonuses, adaptive weighting,
    bin uniformity and fill target, also addresses edge cases better.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_after_add = bins_remain_cap - item
    epsilon = 1e-9

    # Mark infeasible bins with a large negative priority
    infeasible_mask = remaining_after_add < 0
    priorities[infeasible_mask] = -np.inf

    valid_mask = remaining_after_add >= 0

    if np.any(valid_mask):
        # Waste priority: Favor bins that minimize wasted space
        waste = remaining_after_add[valid_mask]
        waste_priority = 1.0 / (waste + epsilon)

        # Near-full bonus: Reward bins that become near-full after adding the item.
        near_full_bonus = np.zeros_like(waste)
        near_full_mask = (remaining_after_add[valid_mask] >= 0) & (remaining_after_add[valid_mask] <= 0.2 * np.max(bins_remain_cap))  # Adjust 0.2 for sensitivity
        near_full_bonus[near_full_mask] = 5  # Increase bonus magnitude

        # Fill target: reward bins that achieve a specific fill ratio after addition
        fill_target = 0.8
        fill_percentage = (bins_remain_cap[valid_mask] - remaining_after_add[valid_mask]) / bins_remain_cap[valid_mask] if np.any(bins_remain_cap[valid_mask] > 0) else np.zeros_like(bins_remain_cap[valid_mask])
        fill_score = np.exp(-np.abs(fill_percentage - fill_target) / 0.1) # Adjust 0.1

        # Bin uniformity: Penalize bins if adding the item will make them significantly less uniform than others
        capacity_mean = np.mean(bins_remain_cap[valid_mask]) if np.any(valid_mask) else np.mean(bins_remain_cap)
        capacity_std = np.std(bins_remain_cap[valid_mask]) if np.any(valid_mask) and len(bins_remain_cap[valid_mask]) > 1 else 0.1

        uniformity_penalty = np.zeros_like(waste)
        if capacity_std > 0:
          normalized_capacities = (bins_remain_cap[valid_mask] - capacity_mean) / capacity_std
          new_normalized_capacities = (remaining_after_add[valid_mask] - capacity_mean) / capacity_std
          uniformity_penalty = np.abs(new_normalized_capacities - normalized_capacities) # Penalize significant changes

        # Adaptive weighting
        waste_weight = 0.5
        near_full_weight = 0.3
        fill_weight = 0.4
        uniformity_weight = 0.2

        priorities[valid_mask] = (waste_weight * waste_priority +
                                 near_full_weight * near_full_bonus +
                                 fill_weight * fill_score -
                                 uniformity_weight * uniformity_penalty)

    return priorities
```
