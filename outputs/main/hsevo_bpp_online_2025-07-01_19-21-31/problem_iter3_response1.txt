```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space,
    while also considering the overall fill level of the bin.  It uses a combination of
    space utilization and a fill-level bonus.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    epsilon = 1e-9  # Small constant for numerical stability

    # 1. Calculate wasted space if the item is placed in each bin.
    wasted_space = bins_remain_cap - item
    wasted_space = np.maximum(wasted_space, 0)  # Ensure no negative wasted space

    # 2. Calculate space utilization.  Higher utilization is generally better.
    utilization = item / (bins_remain_cap + epsilon)  # Avoid division by zero
    utilization[bins_remain_cap < item] = 0  # Zero utilization if the item doesn't fit.

    # 3. Calculate a fill-level bonus.  This encourages filling bins that are already relatively full.
    fill_level = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Normalize the bin sizes relative to the largest size and get fill level

    # 4. Combine the factors to create a priority score.
    #    - Invert wasted space (smaller wasted space = higher priority).
    #    - Add utilization (higher utilization = higher priority).
    #    - Add fill_level bonus (higher fill level = higher priority).
    priority = (1 / (wasted_space + epsilon)) + utilization + fill_level

    # 5. Heavily penalize bins that cannot accommodate the item.
    priority[bins_remain_cap < item] = -np.inf

    return priority
```
