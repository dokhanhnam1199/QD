```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by concepts of gravity and energy conservation,
    favors bins with remaining capacity close to the item size (resonance)
    but penalizes near-empty and over-full bins (stability).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Define constants for tuning the heuristics
    k_resonance = 2.0    # Strength of resonance effect (item fits well)
    k_empty = 0.5       # Penalty for nearly empty bins
    k_overfull = 1.0    # Penalty for item not fitting

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Resonance factor: higher if item size is close to remaining capacity
            resonance = np.exp(-k_resonance * np.abs(cap - item) / item)  # Gaussian-like
            priorities[i] = resonance

        else:
            # Significant penalty for not fitting
            priorities[i] = -k_overfull * (item - cap) # Negative priority
    
    # Further discourage near-empty bins. Heavier impact as the cap grows
    near_empty_penalty = np.exp(-k_empty * (bins_remain_cap / np.max(bins_remain_cap))) # Exponential
    priorities *= near_empty_penalty

    return priorities
```
