```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give high priority to bins that can fit the item relatively well,
    # but not perfectly. Avoid bins that are too full or too empty.
    # Use a Gaussian-like function centered around a good fit ratio.

    fit_ratio = item / bins_remain_cap
    
    # Standard deviation - tunes how picky we are about the "good fit".  A smaller value makes us more selective
    std_dev = 0.2

    #Gaussian-like prioritization
    priorities = np.exp(-0.5 * ((fit_ratio - 1) / std_dev)**2)

    # Reduce priority of bins that cannot fit the item
    priorities[bins_remain_cap < item] = -np.inf

    #Boost priority to bins that fits snugly (first-fit-decreasing-like behavior when several items has the same size
    snug_fit_threshold = 0.05 # tune to favor bins almost full (avoid fragmentation)
    snug_fit = (bins_remain_cap >= item) & (bins_remain_cap - item <= snug_fit_threshold)
    priorities[snug_fit] += 1.0 #add a bonus

    return priorities
```
