{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins where the item fits and the remaining space is minimized (but not zero).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # Calculate waste if item is placed in each valid bin\n        waste = bins_remain_cap[valid_bins] - item\n        # Prioritize bins with smallest waste (but avoid 0 waste if possible)\n        priorities[valid_bins] = 1 / (waste + 0.0001) #Adding a small value to avoid division by zero errors\n\n        #Adjust to avoid filling the bin completely. A small penalty is added to bins where waste is below a thershold, if possible.\n\n        min_waste_val = np.min(waste)\n        waste_threshold = 0.1\n        small_waste_bins = waste < waste_threshold\n        if np.any(small_waste_bins):\n            priorities[valid_bins][small_waste_bins] -= 0.1 * priorities[valid_bins][small_waste_bins]\n    else:\n        # If no bin fits, penalize all bins severely\n        priorities = np.full_like(bins_remain_cap, -1000.0)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item with minimal wasted space.\n    It uses a combination of factors including:\n    1. Whether the item fits in the bin.\n    2. The ratio of item size to remaining capacity (higher is better if it fits).\n    3. The absolute difference between item size and remaining capacity (lower is better).\n    4. A small bonus to bins that are nearly full to encourage their utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Item fits: prioritize based on closeness and fullness\n            ratio = item / remaining_capacity\n            difference = abs(item - remaining_capacity)\n            \n            # Give a base priority inversely proportional to wasted space\n            priorities[i] = 1.0 / (difference + 0.00001)  # Avoid division by zero\n\n            #Boost priority when near full\n            if remaining_capacity <= 2*item:\n                 priorities[i]+= ratio *10\n\n            priorities[i]+= ratio\n\n        else:\n            # Item does not fit: assign a very low priority\n            priorities[i] = -1000  # Extremely low priority\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing Newtonian heuristics based on potential energy and a notion of\n    \"gravitational attraction\" between the item and the bin.\n\n    Args:\n        item: Size of item to be added to the bin (representing mass).\n        bins_remain_cap: Array of capacities for each bin (representing distance).\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure no division by zero or negative values. Add a small epsilon for stability.\n    epsilon = 1e-9\n    effective_capacities = np.maximum(bins_remain_cap, epsilon)\n\n    # Newtonian \"gravitational attraction\" - Larger capacity, stronger attraction (higher priority).\n    # Also favor bins where the item fills a significant portion of the remaining space.\n    # A higher 'G' would signify our tendency towards packing fuller bins.\n\n    G = 1.0 # Gravitational constant - tune this based on desired packing density. Higher G encourages fuller bins\n    priority = G * (item / effective_capacities**2) * np.exp(-np.abs(item - effective_capacities)) # attraction is proportional to 1/(distance)^2 multiplied with exponentially reducing difference\n\n    # Penalize bins that are too full (not enough space for the item) using a large negative value.\n    priority[bins_remain_cap < item] = -np.inf\n\n    return priority\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can fit the item with minimal waste\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap[fit_mask] - item\n    \n    # Prioritize bins where the item fits well (small waste)\n    if waste.size > 0:  # Avoid errors when waste is empty\n        priorities[fit_mask] = 1.0 / (waste + 0.00001)  # Avoid division by zero\n\n    # Slightly discourage almost full bins to potentially avoid fragmentation\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < item)\n\n    priorities[almost_full_mask] = -1000 # extreme negative priority as item does not fit\n\n    #Return priorities\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving too much wasted space.  Bins that cannot accommodate the item\n    receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give very low priority to bins that cannot accommodate the item\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n\n    # For feasible bins, calculate wasted space\n    waste = bins_remain_cap - item\n    feasible = bins_remain_cap >= item\n\n    # Prioritize bins with less wasted space, but also penalize nearly full bins\n    # to encourage consolidating smaller items into less-full bins.\n    priorities[feasible] = (bins_remain_cap[feasible] / (item + 1e-9)) - (waste[feasible]**2) #Adding small epsilon value to avoid potential divide by zero errors\n    #Boosting factor to prioritize near-fit bins:\n\n    near_fit = (bins_remain_cap >= item) & (waste < 0.1) # If waste is less than 0.1 capacity of bin.\n    priorities[near_fit] = priorities[near_fit] + 2  # Boost near-fit bins\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can accommodate the item with minimal wasted space.\n    It uses a combination of factors including:\n    1. Whether the item fits in the bin.\n    2. The ratio of item size to remaining capacity (higher is better if it fits).\n    3. The absolute difference between item size and remaining capacity (lower is better).\n    4. A small bonus to bins that are nearly full to encourage their utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Item fits: prioritize based on closeness and fullness\n            ratio = item / remaining_capacity\n            difference = abs(item - remaining_capacity)\n            \n            # Give a base priority inversely proportional to wasted space\n            priorities[i] = 1.0 / (difference + 0.00001)  # Avoid division by zero\n\n            #Boost priority when near full\n            if remaining_capacity <= 2*item:\n                 priorities[i]+= ratio *10\n\n            priorities[i]+= ratio\n\n        else:\n            # Item does not fit: assign a very low priority\n            priorities[i] = -1000  # Extremely low priority\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins that can fit the item with minimal waste\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap[fit_mask] - item\n    \n    # Prioritize bins where the item fits well (small waste)\n    if waste.size > 0:  # Avoid errors when waste is empty\n        priorities[fit_mask] = 1.0 / (waste + 0.00001)  # Avoid division by zero\n\n    # Slightly discourage almost full bins to potentially avoid fragmentation\n    almost_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < item)\n\n    priorities[almost_full_mask] = -1000 # extreme negative priority as item does not fit\n\n    #Return priorities\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the event horizon of a black hole, where spacetime curvature\n    (or in this case, bin utilization) drastically alters the properties\n    of nearby objects (the item). We prioritize bins that are neither\n    too full nor too empty, maximizing the 'gravitational pull' while\n    avoiding 'spaghettification' (overflow).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Small constant to avoid division by zero and log(0)\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # 1. Prefer bins where the item nearly fills the remaining capacity, but doesn't overflow.\n    #    This encourages efficient packing.  Apply a scaling factor based on how close we are.\n    fill_score = np.exp(-np.abs(ratios - 1) * 5)  # Peak at ratio=1, decays exponentially.  Smaller values pack more optimally and not cause overflows\n\n    # 2. Penalize bins that are too full *after* adding the item to them\n    overfill_penalty = np.where(bins_remain_cap < item, -1e9, 0)  # Very large penalty to strongly discourage overfilling\n\n    # 3. Gently discourage extremely empty bins if other good options are available.\n    #    Avoid excessive fragmentation.  If an item occupies < 20% capacity we add a malus\n    fragmentation_penalty = np.where(item / (np.max(bins_remain_cap)+epsilon) < 0.2, -0.1, 0)  #Avoid one extremely oversized item being put where it makes the most sense, but causes other less efficient placings later.\n\n    #4. Prefer bins which are closer to the item size in terms of percentage (item/bin vs 1)\n    close_fit_score = np.exp(-np.abs(ratios - 1) * 5)\n\n    # Combine the scores and penalties\n    priorities = fill_score + overfill_penalty + fragmentation_penalty+ close_fit_score\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the celestial dance, where larger bodies exert greater influence.\n    A bin with capacity closest to the item size receives higher priority,\n    but also considering a penalty for near-overflow.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between the remaining capacity and the item size\n    diffs = bins_remain_cap - item\n\n    # Initialize priorities with a base score (e.g., inverse of absolute difference).\n    # We want bins where the remaining capacity is close to the item size.\n    priorities = 1.0 / (np.abs(diffs) + 0.000001) # Add small constant to prevent division by zero\n\n    # Apply a significant penalty for bins where adding the item would overflow.\n    overflow_penalty = 1000.0  # A high value to strongly discourage overflows.\n    priorities[diffs < 0] = -overflow_penalty\n\n    # Bins that fit perfectly are ideal, reward them.\n    perfect_fit_bonus = 10.0 # Give a sizable bonus for perfect fit\n    priorities[diffs == 0] += perfect_fit_bonus\n\n    # Slightly favor fuller bins to consolidate existing packing.\n    # This term is relatively small to not dominate the previous calculations.\n    capacity_utilization = (1 - bins_remain_cap / np.max(bins_remain_cap)) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * capacity_utilization\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1.  Remaining capacity: Bins with capacity close to the item size are preferred (First-Fit Decreasing variant).\n    2.  Waste minimization: Penalize bins that will have significant waste after packing the item.\n    3.  Number of Items: Favors to add into the bin containing more items.\n    4.  Bin Utilization: Consider the fullness of each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Avoid division by zero and log(0)\n\n    # Factor 1: Remaining capacity matching the item size. Higher is better when close match.\n    capacity_match = np.exp(-np.abs(bins_remain_cap - item) / (item + epsilon))\n\n    # Factor 2: Waste minimization - penalize high waste. Lower waste gives higher priority.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    # Factor 3: Encourage filling partially full bins by bin utilization.\n    # (Assume bins initially have same max capacity)\n    # This would require you to know the initial max capacity, bin_max_cap\n    # But we are making it by making assumption that partially_full_bins exist\n    # in the bin cap, then pick these up. If bins_remain_cap is all zeros, this factor will have very little influence.\n    partially_full_bins = np.where((bins_remain_cap > item) & (bins_remain_cap < np.max(bins_remain_cap)), 1, 0)\n    fill_priority = partially_full_bins\n\n    # Combine the factors. Experiment with weights to adjust the influence of each factor.\n    priorities = 0.6 * capacity_match + 0.3 * waste_penalty + 0.1 * fill_priority\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers several factors:\n    1.  Remaining capacity: Bins with capacity close to the item size are preferred (First-Fit Decreasing variant).\n    2.  Waste minimization: Penalize bins that will have significant waste after packing the item.\n    3.  Number of Items: Favors to add into the bin containing more items.\n    4.  Bin Utilization: Consider the fullness of each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Avoid division by zero and log(0)\n\n    # Factor 1: Remaining capacity matching the item size. Higher is better when close match.\n    capacity_match = np.exp(-np.abs(bins_remain_cap - item) / (item + epsilon))\n\n    # Factor 2: Waste minimization - penalize high waste. Lower waste gives higher priority.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    # Factor 3: Encourage filling partially full bins by bin utilization.\n    # (Assume bins initially have same max capacity)\n    # This would require you to know the initial max capacity, bin_max_cap\n    # But we are making it by making assumption that partially_full_bins exist\n    # in the bin cap, then pick these up. If bins_remain_cap is all zeros, this factor will have very little influence.\n    partially_full_bins = np.where((bins_remain_cap > item) & (bins_remain_cap < np.max(bins_remain_cap)), 1, 0)\n    fill_priority = partially_full_bins\n\n    # Combine the factors. Experiment with weights to adjust the influence of each factor.\n    priorities = 0.6 * capacity_match + 0.3 * waste_penalty + 0.1 * fill_priority\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # First, consider only bins that can fit the item.\n        capacities = bins_remain_cap[valid_bins]\n        space_waste = capacities - item\n        # Prioritize bins that minimize space waste but not that small it ends up with empty space.\n        priorities[valid_bins] = (capacities**2) / (space_waste + 0.00001)  # avoid div by zero\n    else:\n        # If no bins can fit, perhaps we should minimize the \"overflow\"?\n        # This might depend on problem constraints.\n        priorities = -np.abs(bins_remain_cap - item) # try to add to smallest bin\n        # priorities = item / (bins_remain_cap + 0.0001)  # maybe smaller bins should take burden?\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Best Fit heuristic component: Prioritize bins that can fit the item with the least remaining space.\n    fit_check = bins_remain_cap >= item\n    remaining_space = bins_remain_cap - item\n    remaining_space[~fit_check] = np.inf  # Penalize bins that can't fit the item\n\n    priorities = -remaining_space # Smaller remainders give higher priority\n\n    # Penalize near-empty bins after adding the item to avoid extreme fragmentation.\n    # If the bin's remaining capacity after adding the item is below a threshold, decrease priority\n    post_fill = bins_remain_cap - item\n    small_space_penalty = -10\n    priorities[fit_check & (post_fill < 0.1)] += small_space_penalty #If capacity after adding the item is too small, penalize it.\n\n    #Prioritize bins which have smallest difference with item size, but can still fit it.\n    difference = bins_remain_cap-item\n    difference[difference<0] = np.inf\n    priorities -= difference/np.max(bins_remain_cap)\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a more complex heuristic based on available capacity and a penalty\n    for bins that would become almost full (risk of future blockage).\n    Mimics accretion disk physics: favoring filling 'near-full' bins.\n    We want to penalize bins that filling them would leave them too full or nearly empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Base priority: higher for smaller remaining capacity (avoid opening new bins)\n            base_priority = 1 / (remaining_capacity + 1e-9) #avoid division by 0\n\n            # Capacity based heuristic.\n            new_capacity = remaining_capacity - item\n            \n            # Near full bin penalty (mimic singularity behavior - packing becomes harder).\n            if new_capacity < 0.1:  # If remaining capacity would be very low, greatly penalize\n                near_full_penalty = -100  # Big penalty\n            elif new_capacity < 0.3 : # Slightly full\n                near_full_penalty = -2 * (0.3 - new_capacity)**2 # Small Penalty\n            else:\n                near_full_penalty = 0\n\n            # Near empty bin penalty (penalize fragmenting bins).\n            if new_capacity > 0.7:\n                 near_empty_penalty = -0.5 * (new_capacity - 0.7)**2\n            else:\n                near_empty_penalty = 0\n\n            # Overall Priority score is balance of capacity and penalty\n            priorities[i] = base_priority + near_full_penalty + near_empty_penalty\n        else:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a more complex heuristic based on available capacity and a penalty\n    for bins that would become almost full (risk of future blockage).\n    Mimics accretion disk physics: favoring filling 'near-full' bins.\n    We want to penalize bins that filling them would leave them too full or nearly empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if item <= remaining_capacity:\n            # Base priority: higher for smaller remaining capacity (avoid opening new bins)\n            base_priority = 1 / (remaining_capacity + 1e-9) #avoid division by 0\n\n            # Capacity based heuristic.\n            new_capacity = remaining_capacity - item\n            \n            # Near full bin penalty (mimic singularity behavior - packing becomes harder).\n            if new_capacity < 0.1:  # If remaining capacity would be very low, greatly penalize\n                near_full_penalty = -100  # Big penalty\n            elif new_capacity < 0.3 : # Slightly full\n                near_full_penalty = -2 * (0.3 - new_capacity)**2 # Small Penalty\n            else:\n                near_full_penalty = 0\n\n            # Near empty bin penalty (penalize fragmenting bins).\n            if new_capacity > 0.7:\n                 near_empty_penalty = -0.5 * (new_capacity - 0.7)**2\n            else:\n                near_empty_penalty = 0\n\n            # Overall Priority score is balance of capacity and penalty\n            priorities[i] = base_priority + near_full_penalty + near_empty_penalty\n        else:\n            priorities[i] = -np.inf  # Cannot fit, lowest priority\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = (cap - item) / cap  # Remaining capacity ratio after placing the item\n        else:\n            priorities[i] = -1  # Assign a low priority if the item doesn't fit\n\n    # Apply a small bias to bins with larger remaining capacity (encourages using bins that are already somewhat full, but prefers larger available space)\n    priorities += 0.0001 * bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Uses a combination of remaining capacity and waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity *after* adding the item to each bin.\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign a low priority to bins that cannot fit the item.\n    priorities = np.where(remaining_after_add >= 0, 0.0, -np.inf)\n\n    # For bins that can fit the item, prioritize bins with\n    # small remaining capacity (minimize waste), but also with\n    # enough capacity left to potentially accommodate future larger items.\n    # A sweet spot is targeted. This is done through a weighted combination:\n    # waste_penalty favors less waste (lower remaining_after_add)\n    # future_potential_reward favors bins with more capacity to handle future jobs\n    waste_penalty = -np.abs(remaining_after_add)  # Prefer smaller remaining space.\n\n    #Calculate standard deviation for all items added so far\n    std_dev_estimated_item_size = 0.2  # Estimate based on previous runs\n\n    future_potential_reward = remaining_after_add/(np.sqrt(std_dev_estimated_item_size**2+0.001)) #avoid division by zero error\n\n    # Combine the waste penalty and future potential reward\n    priorities = np.where(remaining_after_add >= 0, waste_penalty + 0.5 *future_potential_reward, priorities)\n\n    # Give a slight bump to bins that are already somewhat full to avoid very sparse bins.\n    # full_bonus = np.where(bins_remain_cap < 0.8,0,1) #only applies when capacity less than .8\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Uses a combination of remaining capacity and waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity *after* adding the item to each bin.\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign a low priority to bins that cannot fit the item.\n    priorities = np.where(remaining_after_add >= 0, 0.0, -np.inf)\n\n    # For bins that can fit the item, prioritize bins with\n    # small remaining capacity (minimize waste), but also with\n    # enough capacity left to potentially accommodate future larger items.\n    # A sweet spot is targeted. This is done through a weighted combination:\n    # waste_penalty favors less waste (lower remaining_after_add)\n    # future_potential_reward favors bins with more capacity to handle future jobs\n    waste_penalty = -np.abs(remaining_after_add)  # Prefer smaller remaining space.\n\n    #Calculate standard deviation for all items added so far\n    std_dev_estimated_item_size = 0.2  # Estimate based on previous runs\n\n    future_potential_reward = remaining_after_add/(np.sqrt(std_dev_estimated_item_size**2+0.001)) #avoid division by zero error\n\n    # Combine the waste penalty and future potential reward\n    priorities = np.where(remaining_after_add >= 0, waste_penalty + 0.5 *future_potential_reward, priorities)\n\n    # Give a slight bump to bins that are already somewhat full to avoid very sparse bins.\n    # full_bonus = np.where(bins_remain_cap < 0.8,0,1) #only applies when capacity less than .8\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Uses a combination of remaining capacity and waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity *after* adding the item to each bin.\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign a low priority to bins that cannot fit the item.\n    priorities = np.where(remaining_after_add >= 0, 0.0, -np.inf)\n\n    # For bins that can fit the item, prioritize bins with\n    # small remaining capacity (minimize waste), but also with\n    # enough capacity left to potentially accommodate future larger items.\n    # A sweet spot is targeted. This is done through a weighted combination:\n    # waste_penalty favors less waste (lower remaining_after_add)\n    # future_potential_reward favors bins with more capacity to handle future jobs\n    waste_penalty = -np.abs(remaining_after_add)  # Prefer smaller remaining space.\n\n    #Calculate standard deviation for all items added so far\n    std_dev_estimated_item_size = 0.2  # Estimate based on previous runs\n\n    future_potential_reward = remaining_after_add/(np.sqrt(std_dev_estimated_item_size**2+0.001)) #avoid division by zero error\n\n    # Combine the waste penalty and future potential reward\n    priorities = np.where(remaining_after_add >= 0, waste_penalty + 0.5 *future_potential_reward, priorities)\n\n    # Give a slight bump to bins that are already somewhat full to avoid very sparse bins.\n    # full_bonus = np.where(bins_remain_cap < 0.8,0,1) #only applies when capacity less than .8\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Uses a combination of remaining capacity and waste minimization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity *after* adding the item to each bin.\n    remaining_after_add = bins_remain_cap - item\n\n    # Assign a low priority to bins that cannot fit the item.\n    priorities = np.where(remaining_after_add >= 0, 0.0, -np.inf)\n\n    # For bins that can fit the item, prioritize bins with\n    # small remaining capacity (minimize waste), but also with\n    # enough capacity left to potentially accommodate future larger items.\n    # A sweet spot is targeted. This is done through a weighted combination:\n    # waste_penalty favors less waste (lower remaining_after_add)\n    # future_potential_reward favors bins with more capacity to handle future jobs\n    waste_penalty = -np.abs(remaining_after_add)  # Prefer smaller remaining space.\n\n    #Calculate standard deviation for all items added so far\n    std_dev_estimated_item_size = 0.2  # Estimate based on previous runs\n\n    future_potential_reward = remaining_after_add/(np.sqrt(std_dev_estimated_item_size**2+0.001)) #avoid division by zero error\n\n    # Combine the waste penalty and future potential reward\n    priorities = np.where(remaining_after_add >= 0, waste_penalty + 0.5 *future_potential_reward, priorities)\n\n    # Give a slight bump to bins that are already somewhat full to avoid very sparse bins.\n    # full_bonus = np.where(bins_remain_cap < 0.8,0,1) #only applies when capacity less than .8\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}