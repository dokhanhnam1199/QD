```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines waste minimization, near-full bonuses, adaptive weighting,
    and explicit infeasibility penalties with more robust handling of edge cases
    and a stronger emphasis on waste minimization. Includes a minimum fill ratio constraint.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_after_add = bins_remain_cap - item
    epsilon = 1e-9

    # Strong Infeasibility penalty:
    infeasible_mask = remaining_after_add < 0
    priorities[infeasible_mask] = -1e9  # Significantly stronger penalty

    valid_mask = remaining_after_add >= 0

    if np.any(valid_mask):
        # Waste priority (reciprocal, scaled):
        waste = remaining_after_add[valid_mask]
        waste_priority = 10.0 / (waste + epsilon)  # Increased waste importance

        # Near-full bonus (only if waste is small relative to item):
        near_full_bonus = np.where(
            (bins_remain_cap[valid_mask] > item) & (bins_remain_cap[valid_mask] <= 2 * item) & (remaining_after_add[valid_mask] <= 0.5 * item),
            item / bins_remain_cap[valid_mask] * 5,  # Reduced bonus magnitude
            0
        )

        # Minimum fill ratio constraint: discourage bins that will be sparsely filled
        fill_ratio = item / bins_remain_cap[valid_mask]
        min_fill_penalty = np.where(fill_ratio < 0.1, -10, 0)  # Apply a penalty if fill is below 10%

        # Adaptive capacity weighting:
        capacity_mean = np.mean(bins_remain_cap[valid_mask]) if np.any(valid_mask) else np.mean(bins_remain_cap)
        capacity_std = np.std(bins_remain_cap[valid_mask]) if np.any(valid_mask) and len(bins_remain_cap[valid_mask]) > 1 else 0.1

        capacity_weight = 1.0 # Initialize default weight

        if capacity_std > 0.0:
            capacity_normalized = (bins_remain_cap[valid_mask] - capacity_mean) / capacity_std
            capacity_weight = 1.0 + np.tanh(capacity_normalized) # Weight towards bins with above-average capacity

        # Combine factors with adaptive weights:
        waste_weight = 1.0
        near_full_weight = 0.5 # Reduced near-full importance

        priorities[valid_mask] = waste_weight * waste_priority + near_full_weight * near_full_bonus + capacity_weight + min_fill_penalty # Stronger waste, capacity bonus, penalty fill

        # Prioritize almost full bins
        almost_full_bonus = np.where((bins_remain_cap[valid_mask] - item) < 0.1, 100, 0)
        priorities[valid_mask] += almost_full_bonus

    return priorities
```
