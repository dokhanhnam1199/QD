```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate savings for each pair of nodes (Clarke-Wright Savings Heuristic)
    savings_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j] # Make it symmetric
    
    # Demand factor
    demand_factor = np.outer(demands, demands)
    
    # Proximity factor
    proximity_factor = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Sparsify the matrix (remove edges that are too long or connect to very high demand nodes)
    distance_threshold = np.mean(distance_matrix) + np.std(distance_matrix)
    demand_threshold = np.mean(demands) + np.std(demands) # or use a fixed value like capacity /3

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Combine different factors
                heuristic_value = savings_matrix[i, j] * proximity_factor[i, j]  / (demand_factor[i,j] + 1e-9)
                #Sparsification
                if distance_matrix[i, j] > distance_threshold:
                    heuristic_value = 0
                if demands[i] > demand_threshold and demands[j] > demand_threshold :
                     heuristic_value = 0
                
                heuristic_matrix[i, j] = heuristic_value

    # Normalize the heuristic matrix
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic

    return heuristic_matrix
```
