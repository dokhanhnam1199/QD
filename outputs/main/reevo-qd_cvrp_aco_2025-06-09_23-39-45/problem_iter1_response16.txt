```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A heuristics function for solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Capacity of the vehicle.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge
                    in a solution. The return is of the same shape as the
                    distance_matrix.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate a combination of factors
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: shorter distances are more promising
                distance_factor = 1 / distance_matrix[i, j]

                # Demand factor: consider demands of the nodes
                demand_factor = 1 / (demands[i] + demands[j] + 1e-6)  # Avoid division by zero

                # Angle factor: penalize sharp turns (helps with route smoothness)
                if i != 0 and j != 0:
                    vector1 = coordinates[i] - coordinates[0]
                    vector2 = coordinates[j] - coordinates[i]
                    angle = np.arctan2(np.linalg.norm(np.cross(vector1, vector2)), np.dot(vector1, vector2))
                    angle_factor = 1 / (angle + 0.1)  # Penalize sharp turns more

                else:
                     angle_factor = 1  # Or another suitable default

                # Combine the factors
                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor

    # Sparsify the matrix (optional, but often helpful)
    # Keep only the top k promising edges for each node
    k = int(np.sqrt(n))  # Adjust k as needed

    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[::-1]  # Sort in descending order of heuristic value
        threshold = row[indices[k]] if k < n else 0
        heuristic_matrix[i, row < threshold] = 0
        heuristic_matrix[i,i] = 0

    # Normalize the matrix to be between 0 and 1
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        heuristic_matrix = heuristic_matrix / max_val
    else:
        heuristic_matrix = np.ones((n,n)) / n
    heuristic_matrix[np.diag_indices_from(heuristic_matrix)] = 0 #Zero diagonal

    return heuristic_matrix
```
