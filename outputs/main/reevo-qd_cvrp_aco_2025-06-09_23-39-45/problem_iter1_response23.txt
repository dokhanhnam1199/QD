```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP using a combination of factors and sparsification.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating how promising
        it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    alpha = 0.5  # Weight for distance
    beta = 0.3  # Weight for demand-related factors
    gamma = 0.2  # Weight for closeness to depot

    # Calculate depot distances
    depot_distances = distance_matrix[0, :]  # Distance from depot (node 0) to all other nodes.
    depot_distances[0] = np.inf # Avoid using distance depot to depot

    # Node Demand to Capacity Ratio
    demand_ratio = demands / capacity
    demand_ratio[0] = 0  # Set depot demand ratio to 0, so no influence from depot

    # Calculate heuristic values
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # Avoid self-loops
                continue

            # Combine distance, demand, and closeness to depot.
            # Penalize long distances, high demand ratio from i to j and larger distance to the depot from nodes i and j.

            heuristic_matrix[i, j] = (
                alpha * (1 / (distance_matrix[i, j] + 1e-6)) + # add a tiny term to avoid zero division
                beta * (1 - demand_ratio[i] - demand_ratio[j]) +
                gamma * (1 / (depot_distances[i] + depot_distances[j] + 1e-6))  # Proximity to depot

            )

            # Symmetry considerations
            heuristic_matrix[j, i] = heuristic_matrix[i, j]


    # Sparsify the matrix: only keep a few best neighbors for each node.
    # for i in range(n):
    #     # Find indices of the best 'k' neighbors for each node (excluding self).
    #     k = min(5, n - 1)  # limit the neighbors to 5 to maintain a sparse matrix, or total n-1 when nodes < 5.
    #     neighbors = np.argsort(heuristic_matrix[i, :])[::-1]  # sort neighbors descending, the larger, the better
    #     neighbors = neighbors[neighbors != i][:k]   # Ensure we exclude the node itself (i==j). Pick only k nodes

    #     # Set heuristic value to zero for all other edges.
    #     for j in range(n):
    #         if j not in neighbors:
    #             heuristic_matrix[i, j] = 0


    # Normalize values (0 to 1)
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        heuristic_matrix /= max_val

    return heuristic_matrix
```
