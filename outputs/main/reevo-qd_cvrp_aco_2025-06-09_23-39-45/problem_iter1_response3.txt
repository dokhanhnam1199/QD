```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function combines several factors to determine how promising it is to select an edge,
    including distance, demand, and angle between nodes. It also sparsifies the matrix by
    setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to tune
    distance_weight = 0.5  # Weight for the distance factor
    demand_weight = 0.3    # Weight for the demand factor
    angle_weight = 0.2     # Weight for the angle factor
    sparsification_threshold = 0.1 #Threshold for sparsification. Edges with heuristic values below this are set to zero

    # Calculate angle factors
    angle_factors = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate angle between vectors (depot -> i) and (depot -> j)
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]

                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    dot_product = np.dot(vector_i, vector_j)
                    cos_angle = dot_product / (norm_i * norm_j)
                    angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip to avoid potential errors from floating-point precision

                    angle_factors[i, j] = 1 - (angle / np.pi) # Normalize to [0, 1]

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero
                demand_factor = 1 - (demands[j] / capacity) if demands[j] <= capacity else 0 #How much of capacity it doesn't consume
                heuristic_matrix[i, j] = (distance_weight * distance_factor +
                                          demand_weight * demand_factor +
                                          angle_weight * angle_factors[i, j])

    # Sparsify the matrix
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        normalized_heuristic_matrix = heuristic_matrix / max_heuristic #Scale values between 0 and 1.
        heuristic_matrix[normalized_heuristic_matrix < sparsification_threshold] = 0  # Zero out unpromising edges


    return heuristic_matrix
```
