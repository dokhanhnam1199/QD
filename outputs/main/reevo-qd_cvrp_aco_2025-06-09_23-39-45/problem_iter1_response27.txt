```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the "promise" of each edge, including distance,
    demand considerations, and angular relationships (to encourage spatial clustering).  It also sparsifies
    the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A distance matrix (shape: n by n) representing the distances between nodes.
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): A vector of customer demands (shape: n).
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix (shape: n by n) of heuristics values, indicating how promising it is to include each edge in a solution.
                     Higher values indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    sparsification_threshold = 0.1  # Set fraction of lowest heuristics to zero.

    # Calculate angles between each node and the depot (node 0). This encourages angular relationships
    # and spatial clustering with the depot.
    depot_x, depot_y = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):
        x, y = coordinates[i]
        angle = np.arctan2(y - depot_y, x - depot_x)
        angles[i] = angle

    for i in range(n):
        for j in range(i + 1, n):  # Only consider upper triangle since the matrix is symmetric
            # Distance factor (shorter distances are better)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # avoid divide by zero

            # Demand factor (edges connecting nodes with small demand are better)
            demand_factor = 1 / (demands[i] + demands[j] + 1e-6)  # avoid divide by zero

            # Angle factor (encourages spatial coherence)
            angle_diff = abs(angles[i] - angles[j])
            angle_factor = 1 / (angle_diff + 1e-6) if i > 0 and j > 0 else 1.0  # avoid division by zero, depot edges keep 1.0

            # Combine the factors
            heuristic_value = (
                distance_weight * distance_factor +
                demand_weight * demand_factor +
                angle_weight * angle_factor
            )

            heuristic_matrix[i, j] = heuristic_value
            heuristic_matrix[j, i] = heuristic_value

    # Sparsify the matrix by zeroing out low-probability edges.  This reduces computation in stochastic sampling.
    threshold_value = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsification_threshold) # Avoid picking up zeros

    heuristic_matrix[heuristic_matrix < threshold_value] = 0

    return heuristic_matrix
```
