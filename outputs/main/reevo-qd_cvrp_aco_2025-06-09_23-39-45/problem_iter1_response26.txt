```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: A distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: A vector of customer demands (shape: n).
        capacity: The integer capacity of vehicle.

    Returns:
        A matrix of the same shape as the distance_matrix, representing prior indicators of how promising it is
        to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate savings for each pair of customers
    savings = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings[j, i] = savings[i, j]

    # Normalize distances and savings
    normalized_distances = distance_matrix / np.max(distance_matrix)
    normalized_savings = savings / np.max(savings)

    # Demand factor: penalize edges connecting nodes with large demands
    demand_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            demand_factor[i, j] = (demands[i] + demands[j]) / (2 * capacity)  # Ratio of combined demand to capacity.  Values > 1 problematic

    # Combine factors
    for i in range(n):
        for j in range(n):
            if i != j:
                # Heuristic is a combination of savings, distance and demand.
                heuristic_matrix[i, j] = normalized_savings[i, j] - normalized_distances[i, j] - demand_factor[i, j]
            else:
                heuristic_matrix[i, j] = 0 #Do not connect to self
    #Sparsify the matrix: Remove unpromising connections
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20) #Keep the best 80% of the heuristic values
    heuristic_matrix[heuristic_matrix < threshold] = 0
    #Ensure the depot is always connected
    for i in range(1,n):
        if heuristic_matrix[0,i]==0:
            heuristic_matrix[0,i] = np.max(heuristic_matrix[0,:]) * 0.1 if np.max(heuristic_matrix[0,:]) > 0 else 0.001
        if heuristic_matrix[i,0]==0:
            heuristic_matrix[i,0] = np.max(heuristic_matrix[:,0]) * 0.1 if np.max(heuristic_matrix[:,0]) > 0 else 0.001

    return heuristic_matrix
```
