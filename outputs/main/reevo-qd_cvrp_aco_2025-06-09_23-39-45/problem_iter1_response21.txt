```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) based on stochastic solution sampling principles.
    It combines distance, demand, and spatial dispersion factors to estimate the desirability of each edge.

    Args:
        distance_matrix (np.ndarray): A matrix of distances between all pairs of nodes.
        coordinates (np.ndarray): Coordinates of each node.
        demands (np.ndarray): Demand of each node.
        capacity (int): Capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the heuristic scores for each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    alpha = 1.0   # Weight for distance
    beta = 1.0    # Weight for demand
    gamma = 0.5  # Weight for spatial dispersion
    sparsity_threshold = 0.1 # Edges below this score will be set to zero

    # Node degree adjustment
    avg_degree = 5  # Aim for approximately avg_degree connections per node.

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (shorter distance is better)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6) # Add small constant to avoid division by zero

                # Demand factor (lower demand is better; penalize edges connecting high-demand nodes)
                demand_factor = 1 / (demands[i] + demands[j] + 1e-6)

                # Spatial dispersion factor (encourage connections that diversify route geographically)
                dx = coordinates[i, 0] - coordinates[j, 0]
                dy = coordinates[i, 1] - coordinates[j, 1]
                spatial_dispersion = np.sqrt(dx**2 + dy**2)
                spatial_factor = spatial_dispersion # Higher the dispersion, better the exploration

                # Combine factors
                heuristic_matrix[i, j] = (alpha * distance_factor +
                                         beta * demand_factor +
                                         gamma * spatial_factor)

    # Normalize
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
      heuristic_matrix = heuristic_matrix / max_heuristic

    # Sparsify: Remove less promising edges
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsity_threshold) # Only consider values greater than zero when calculating threshold

    heuristic_matrix[heuristic_matrix < threshold] = 0

    #Adjust the heuristic values by limiting the number of potential edges per node
    for i in range(n):
      row = heuristic_matrix[i, :]
      indices = np.argsort(row)[::-1]  # Sort in descending order and get indices
      k = min(avg_degree, np.sum(row > 0)) # Number of best edges to keep for each node

      mask = np.ones_like(row, dtype=bool)
      mask[indices[:k]] = False
      heuristic_matrix[i, mask] = 0 # Setting all elements other than top k to 0 in the row

    return heuristic_matrix
```
