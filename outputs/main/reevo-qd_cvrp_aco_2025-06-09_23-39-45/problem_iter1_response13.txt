```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for the Capacitated Vehicle Routing Problem (CVRP) using a combination of factors
    and sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge desirability matrix (n x n).
    """

    n = distance_matrix.shape[0]
    edge_desirability = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    alpha = 1.0  # Distance factor
    beta = 0.5 # Demand factor
    gamma = 0.2  # Depot proximity factor
    delta = 0.1 # Angle factor
    sparsity_threshold = 0.1  # Threshold for sparsification

    for i in range(n):
        for j in range(n):
            if i == j:
                edge_desirability[i, j] = 0.0  # No self-loops
                continue

            # Distance factor: shorter distance is more desirable
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero

            # Demand factor: prefer edges connecting to nodes with small demands to avoid exceeding capacity
            demand_factor = 1 / (demands[i] + demands[j] + 1e-6)

            # Depot proximity factor: Encourage connections to/from the depot
            depot_proximity_i = 1 / (distance_matrix[i, 0] + 1e-6) if i != 0 else 1.0
            depot_proximity_j = 1 / (distance_matrix[j, 0] + 1e-6) if j != 0 else 1.0
            depot_proximity_factor = (depot_proximity_i + depot_proximity_j) / 2.0

            # Angle factor: Prefer edges that minimize sharp turns (helps create smoother routes).
            # Compute angle between vectors (i -> j) and (j -> depot) or (depot -> i) and (i -> j)
            if i == 0:
                # depot to j
                v1 = coordinates[j] - coordinates[i]
                v2 = coordinates[j] - coordinates[0] # Redundant, but consistent
            elif j == 0:
                # i to depot
                v1 = coordinates[i] - coordinates[0]
                v2 = coordinates[i] - coordinates[i] # Zero vector which is not what we want

            else:
                v1 = coordinates[j] - coordinates[i]
                v2 = coordinates[0] - coordinates[j]  # vector from j to the depot


            if i != 0 and j != 0:
                dot_product = np.dot(v1, v2)
                magn_v1 = np.linalg.norm(v1)
                magn_v2 = np.linalg.norm(v2)
                if magn_v1 > 0 and magn_v2 > 0: #Avoid division by zero.
                    angle = np.arccos(dot_product / (magn_v1 * magn_v2 + 1e-6)) #add epsilon to avoid div by zero error
                    angle_factor = 1 - (angle / np.pi) # Normalize angle to [0, 1] where 1 is best
                else:
                    angle_factor = 0.0  # Very penalizing when i==j (handled outside)
            else:
                angle_factor = 0.5 #Give default values when i or j is the depot
            # Combine factors
            edge_desirability[i, j] = (
                alpha * distance_factor +
                beta * demand_factor +
                gamma * depot_proximity_factor +
                delta * angle_factor
            )


    # Sparsify the matrix: set less promising edges to zero
    threshold = np.quantile(edge_desirability[edge_desirability > 0], sparsity_threshold) # use quantile to filter less promising edge to zero
    edge_desirability[edge_desirability < threshold] = 0

    return edge_desirability
```
