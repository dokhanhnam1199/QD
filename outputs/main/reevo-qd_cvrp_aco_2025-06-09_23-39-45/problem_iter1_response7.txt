```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                  (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate savings for each pair of nodes
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Node proximity and demand compatibility
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0
            else:
                # Heuristic 1: Inverse distance
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero

                # Heuristic 2: Savings (higher savings = more promising)
                savings_factor = savings_matrix[i, j]

                # Heuristic 3: Demand compatibility (smaller combined demand = more promising)
                #   Penalize edges connecting nodes that would likely overload a vehicle quickly
                demand_penalty = (demands[i] + demands[j]) / (2*capacity) # Scale demand penalty
                demand_penalty = np.clip(demand_penalty,0,1) #Cap penalty value between 0 and 1.
                demand_factor = (1 - demand_penalty) # High demand penalty result in low demand factor

                # Heuristic 4: Angle to depot. Nodes that are "in the same direction" from the depot are likely candidates to be connected in routes
                depot_angle_penalty = 0.0 #Initialization
                if i != 0 and j != 0:
                    vector_i = coordinates[i] - coordinates[0]
                    vector_j = coordinates[j] - coordinates[0]
                    norm_i = np.linalg.norm(vector_i)
                    norm_j = np.linalg.norm(vector_j)
                    if norm_i > 0 and norm_j > 0:
                        dot_product = np.dot(vector_i, vector_j)
                        cosine_angle = dot_product / (norm_i * norm_j)
                        cosine_angle = np.clip(cosine_angle, -1, 1) #Clamp in range -1,1, avoids errors.
                        angle = np.arccos(cosine_angle)
                        angle_factor = 1- (angle / np.pi) # Normalizing angle between 0 and pi
                        depot_angle_penalty = 1-angle_factor # Penalize edges w/ big angles wrt depot
                    else:
                        depot_angle_penalty = 1.0
                else:
                    depot_angle_penalty = 0.0

                # Combine heuristics (weighted sum)
                heuristics_matrix[i, j] = 0.4 * distance_factor + 0.3 * savings_factor + 0.15 * demand_factor + 0.15 * (1 - depot_angle_penalty)


    # Sparsify the matrix (optional): remove less promising edges
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 40) #Keep top 60%
    heuristics_matrix[heuristics_matrix < threshold] = 0  # Zero out low-promise edges

    return heuristics_matrix
```
