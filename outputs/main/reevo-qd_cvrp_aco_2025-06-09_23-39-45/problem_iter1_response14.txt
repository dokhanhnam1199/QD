```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on distance, demand, and spatial clustering.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor
    distance_weight = 1.0
    demand_weight = 0.5
    cluster_weight = 0.5

    # Calculate a cluster density measure
    cluster_density = np.zeros((n,))
    for i in range(1, n): # skip depot
        distances_to_node = distance_matrix[i, 1:] # distances from i to all other nodes (excluding depot)
        distances_to_node_sorted_indices = np.argsort(distances_to_node)
        
        neighbor_count = 0
        total_demand = 0

        for neighbor_idx in distances_to_node_sorted_indices:
             neighbor_idx_original = neighbor_idx + 1 #shift back to original indices

             if neighbor_idx_original == i: #skip self-loop
                  continue

             total_demand += demands[neighbor_idx_original]
             neighbor_count+=1

             if total_demand > capacity/3 or neighbor_count > 5:
                break
        
        cluster_density[i] = neighbor_count #more neighbors indicates dense cluster


    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0
                continue
            
            # Distance factor: Inverse of distance
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Add a small constant to avoid division by zero

            # Demand factor: based on the demands of the nodes
            demand_factor = 1 / (demands[i] + demands[j] + 1e-6)  # Add a small constant to avoid division by zero

            # Cluster factor: High cluster density means that there are likely more customers nearby, making it better to explore.
            cluster_factor = 0.0
            if i!=0 and j!=0:
                 cluster_factor = cluster_density[i] + cluster_density[j]
            

            # Combine the factors
            heuristic_matrix[i, j] = (distance_weight * distance_factor +
                                     demand_weight * demand_factor +
                                     cluster_weight * cluster_factor)

    # Sparsify the matrix: Remove less promising edges
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 40)  # Keep top 60% of edges
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
