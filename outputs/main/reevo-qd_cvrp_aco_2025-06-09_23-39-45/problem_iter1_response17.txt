```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for the Capacitated Vehicle Routing Problem (CVRP) using a combination of factors.

    Args:
        distance_matrix: Distance matrix between nodes (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Demand of each node (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as the distance_matrix, indicating how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]

    # Initialize the heuristics matrix
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (tunable)
    alpha = 1.0  # Weight for distance
    beta = 0.5  # Weight for demand
    gamma = 0.2 # Weight for angle penalty (encourages turning)
    delta = 0.1  # Sparsity factor: only top delta% of edges are considered promising.

    # Calculate angular penalties
    angular_penalties = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate angle between edges (depot -> i) and (i -> j)
                depot = 0  # Index of the depot
                v1 = coordinates[i] - coordinates[depot]
                v2 = coordinates[j] - coordinates[i]
                
                # Normalize vectors to avoid large magnitude differences
                v1_norm = np.linalg.norm(v1)
                v2_norm = np.linalg.norm(v2)
                if v1_norm > 0 and v2_norm > 0:
                    v1 = v1 / v1_norm
                    v2 = v2 / v2_norm
                    dot_product = np.dot(v1, v2)
                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0)) #clip to avoid domain errors
                    angular_penalties[i, j] = angle
                else:
                    angular_penalties[i, j] = 0.0
                

    # Combine distance, demand, and angle information
    for i in range(n):
        for j in range(n):
            if i != j:
                # Heuristics calculation, discouraging edges that exceed capacity when including customer 'j' after customer 'i'.
                demand_factor = 1.0 #No penalty if its the depot or demand constraints don't get violated, large penalty if demands would add up above capacity.
                
                heuristics[i, j] = (
                    (1 / (distance_matrix[i, j] ** alpha))
                    * (demand_factor ** beta)
                    * (1 / (1 + angular_penalties[i, j]) ** gamma)
                )

    #Sparsify the matrix, only keep edges above a threshold.
    threshold = np.percentile(heuristics[heuristics > 0], 100 - (delta * 100))
    heuristics[heuristics < threshold] = 0
                
    return heuristics
```
