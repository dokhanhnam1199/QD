```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP that combines distance, demand, and angle considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of edge inclusion (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic 1: Distance-based
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # Heuristic 2: Demand-based (discourage edges connecting high-demand nodes far apart)
    demand_factor = np.outer(demands, demands)
    demand_heuristic = 1 / (demand_factor + 1e-6)

    # Heuristic 3: Angle-based (encourage edges that don't cause sharp turns)
    angle_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                # Calculate angle between edge (0, i) and (0, j) (depot is node 0)
                vector_i = coordinates[i] - coordinates[0]
                vector_j = coordinates[j] - coordinates[0]
                norm_i = np.linalg.norm(vector_i)
                norm_j = np.linalg.norm(vector_j)

                if norm_i > 0 and norm_j > 0:
                    dot_product = np.dot(vector_i, vector_j)
                    cosine_angle = dot_product / (norm_i * norm_j)
                    cosine_angle = np.clip(cosine_angle, -1.0, 1.0)  # Ensure within valid range
                    angle = np.arccos(cosine_angle) # angle in radians
                    angle_heuristic[i, j] = 1 - (np.abs(angle) / np.pi) # Value from 0 to 1, 1 being close to aligned and more preferable

    # Combine heuristics (weighted average)
    heuristic_matrix = (0.6 * distance_heuristic + 0.2 * demand_heuristic + 0.2 * angle_heuristic)

    # Sparsify the matrix: remove edges that are unlikely to be in the optimal solution
    # Keep only top k edges for each node based on heuristic value
    k = int(np.sqrt(n)) # Heuristically determine k

    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[-k:] # Indices of the top k largest element
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristic_matrix[i, mask] = 0.0


    return heuristic_matrix
```
