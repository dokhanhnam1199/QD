```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP)
    based on a combination of distance, demand, and angle considerations.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (adjust these to fine-tune the heuristic)
    distance_weight = 1.0
    demand_weight = 1.0
    angle_weight = 0.5
    sparsity_threshold = 0.1  # Percentage of least promising edges to set to zero

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (lower distance is better)
                distance_factor = distance_weight / (distance_matrix[i, j] + 1e-6)  # Add small constant to avoid division by zero

                # Demand factor (lower demand is better)
                demand_factor = demand_weight / (demands[j] + 1e-6) if j != 0 else 1.0

                # Angle factor (encourages smoother routes)
                angle_factor = 1.0
                if i != 0 and j != 0:
                    # Calculate angle between vectors (depot -> i) and (i -> j)
                    vector1 = coordinates[i] - coordinates[0]
                    vector2 = coordinates[j] - coordinates[i]
                    dot_product = np.dot(vector1, vector2)
                    magnitude1 = np.linalg.norm(vector1)
                    magnitude2 = np.linalg.norm(vector2)

                    if magnitude1 > 0 and magnitude2 > 0:
                        cosine_angle = dot_product / (magnitude1 * magnitude2)
                        cosine_angle = np.clip(cosine_angle, -1.0, 1.0)  # Clip to valid range
                        angle = np.arccos(cosine_angle)
                        angle_factor = angle_weight / (angle + 1e-6)  # Smaller angle is better
                    else:
                        angle_factor = angle_weight # if either vector has zero magnitude, penalize
                    

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor
    
    # Sparsify the matrix by setting a percentage of the least promising edges to zero
    flattened_matrix = heuristic_matrix.flatten()
    threshold_value = np.quantile(flattened_matrix[flattened_matrix > 0], sparsity_threshold) #Only consider values greater than zero, as zero indicates not promising.
    heuristic_matrix[heuristic_matrix < threshold_value] = 0

    return heuristic_matrix
```
