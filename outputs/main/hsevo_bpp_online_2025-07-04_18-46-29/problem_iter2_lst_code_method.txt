{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Encourage filling bins closer to full\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n      priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n\n    # Prioritize bins with smallest remaining capacity that can still fit the item.  This helps with the \"first fit decreasing\" concept if implemented online.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n      min_remaining = np.min(bins_remain_cap[eligible_bins])\n      priorities[bins_remain_cap == min_remaining] += 1\n\n    \n    # Einstein's Special Consideration: A touch of non-linearity to avoid local optima\n    priorities = priorities + np.exp(-np.abs(bins_remain_cap - item))  \n    \n    # Penalize near-full bins heavily to allow more flexibility for the next item, mitigating fragmentation.\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    if np.any(near_full):\n        priorities[near_full] -= 0.5 # A penalty score\n      \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the wasted space if the item is placed in the bin.\n    wasted_space = bins_remain_cap - item\n    \n    # High priority for bins where the item fits and minimizes wasted space.\n    # If the item doesn't fit, assign a low priority.\n    \n    fit_mask = wasted_space >= 0\n    \n    if np.any(fit_mask):  # Check if there are bins that can accommodate the item\n        # Rank bins based on how full they would be made *after* adding the item\n        # Higher remaining capacity (lower waste) means a better fit (higher score)\n        \n        #normalized_remain_cap = bins_remain_cap[fit_mask] / bins_remain_cap[fit_mask].max() # Normalize so that large differences don't overshadow\n\n        #priorities[fit_mask] = (1 / (wasted_space[fit_mask] + 0.000001)) # Avoid division by zero\n\n        # Calculate a score based on the fullness of the bin after packing.  A fully packed bin is best.\n        fullness_score = (bins_remain_cap[fit_mask] - wasted_space[fit_mask]) / bins_remain_cap[fit_mask]\n        priorities[fit_mask] = fullness_score\n\n        # Apply a stronger priority to bins that would be close to full\n        # Close-to-full is better than almost empty\n        close_to_full_threshold = 0.9\n        priorities[fit_mask] = priorities[fit_mask] + (fullness_score >= close_to_full_threshold) * 1.5 # Give strong bonus to close-to-full\n            \n    else: # if the item doesn't fit into any of bins\n        priorities = np.full(bins_remain_cap.shape, -np.inf)  # Set very low priority for those bins\n        # Choose bin that's closest in size to current item\n        closest_bin_index = np.argmin(bins_remain_cap)\n        priorities[closest_bin_index] = -1 # Ensure at least one option for packing, give close size higher priority than all others\n        \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics:\n    1.  Avoid bins that are too full (or will be too full) using a sigmoid function.\n    2.  Prefer bins that have space close to the item size (first-fit-decreasing heuristic inspired).\n    3.  Prioritize bins that are almost full after adding the item, but not overfull. This encourages bin completion.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Sigmoid function to penalize bins that are close to full.  Avoids excessive fragmentation.\n    sigmoid = 1 / (1 + np.exp(10 * (item - bins_remain_cap))) # Sharp sigmoid around item = remaining capacity\n\n    # Prioritize bins whose remaining capacity is close to the item size, but don't allow negatives\n    capacity_difference = np.maximum(0, 1 - np.abs(bins_remain_cap - item) / np.max([1e-6, np.mean(bins_remain_cap)])) # Avoid div by 0\n\n    # Boost priority for bins that become nearly full after packing the item.  Prioritize near-completion, not overflow.\n    completion_bonus = np.where((bins_remain_cap - item >= 0), np.exp(-10*(bins_remain_cap - item)), -np.inf)  # Heavily penalize overflow\n\n    priorities = sigmoid + 0.5 * capacity_difference + completion_bonus # Combine the heuristics.\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate waste if item is placed in each bin.  Bins with insufficient capacity get large negative priority\n    waste = bins_remain_cap - item\n    priorities[waste < 0] = -np.inf\n    waste[waste < 0] = np.inf  # Avoid further calculations for invalid bins\n\n    # Prioritize bins with least waste (First Fit heuristic-like)\n    priorities += 1.0 / (waste + 1e-6)  # Adding a small constant to avoid division by zero\n\n    # Prioritize bins where the item fills a significant portion (fraction) of bin capacity.\n    fill_fraction = item / bins_remain_cap\n    priorities += fill_fraction\n\n    # Slightly prioritize bins already containing items (reduces bin fragmentation, improves later packing)\n    # Assuming empty bins have initial remaining capacity (i.e. equal to the bin size).  High remain capacity indicate empty\n    # Prioritization increases as the bin becomes fuller\n    priorities += (1 - bins_remain_cap / np.max(bins_remain_cap)) * 0.5\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item relatively closely,\n    but also discourages using almost empty bins if others are available.\n    It incorporates both a capacity fit score and a residual capacity penalty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Capacity fit score: Higher if the item fits relatively snugly\n    fit_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n    fit_scores[can_fit] = (bins_remain_cap[can_fit] - item) / bins_remain_cap[can_fit]\n    fit_scores = 1 - fit_scores\n    fit_scores[~can_fit] = -1  # Assign negative score if item doesn't fit\n\n    # Residual capacity penalty: Lower if bin is mostly empty after adding item.\n\n    residual_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    bins_after_fit = bins_remain_cap - item\n    residual_penalty[can_fit] = np.abs(bins_after_fit[can_fit] / bins_remain_cap[can_fit])\n\n\n    # Combine fit score and residual capacity penalty\n    # Give fit a higher importance by scaling the penalty to have a minimal impact if the item does not fit.\n    priorities = fit_scores - 0.1*residual_penalty\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space.\n    If no bins can fit the item, it assigns the lowest priority to all bins to signal the need for a new bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    if not np.any(eligible_bins):\n        return np.full(bins_remain_cap.shape, -np.inf)  # No bin can fit, signal for new bin\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[~eligible_bins] = np.inf # Penalize ineligible bins to a huge wasted space\n\n    # Prioritize bins with minimal wasted space among the eligible bins.\n    priorities = -wasted_space\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can fit the item closely,\n    but also avoids bins that are too full after packing, creating \"almost full\" bins.\n    It combines several factors:\n    1.  Fit Score:  The closer the item's size is to the bin's remaining capacity, the better.\n    2.  Waste Penalty: Penalizes bins that would leave a significant amount of wasted space.\n    3.  Feasibility: Bins that cannot accommodate the item get a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Fit Score (higher is better): How well the item fits in the bin\n    fit_scores = 1 - np.abs(bins_remain_cap - item) / np.max(bins_remain_cap) # Normalize\n\n    # Waste Penalty (lower is better): Discourages leaving too much space.\n    waste = bins_remain_cap - item\n    waste_penalty = np.zeros_like(waste, dtype=float)\n    waste_penalty[waste > 0] = (waste[waste > 0] / np.max(bins_remain_cap))**2 #Squre it to heavily penalize large waste\n\n    # Combine fit and waste for initial priorities (only feasible bins)\n    priorities[feasible_bins] = fit_scores[feasible_bins] - waste_penalty[feasible_bins]\n\n    # Very small negative value if the bin is not feasible, to discourage the use of infeasible bin\n    priorities[~feasible_bins] = -1e9\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher priority means we want to add the item into that bin first.\n\n    This function considers a combination of factors to determine bin priority:\n    1. Remaining capacity relative to item size. Bins that have remaining\n       capacity close to item size are prioritized to avoid excessive fragmentation.\n    2. Avoid bins that are almost full (to prevent failed placements later).\n    3. If no bin is large enough, give a uniform small negative priority,\n       so that we prefer opening a new bin instead of a random assignment.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the space wasted if the item were added to the bin\n    waste = bins_remain_cap - item\n\n    # Identify bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n\n        # Prioritize bins where waste is minimized\n        priorities[valid_bins] = -np.abs(waste[valid_bins])\n\n        # If some bins are a *very* good fit (waste close to zero), boost those\n        close_fit = np.abs(waste[valid_bins]) < 0.1 * item  # Adjust threshold as needed\n        priorities[valid_bins][close_fit] += 1  # Add a bonus for good fits.  The magnitude here is key to the behaviour\n\n        # Penalize bins that are very full already\n        full_threshold = 0.1 # percentage of bin capacity below which it is considered almost full\n        almost_full = bins_remain_cap < (1 + full_threshold) * item\n        priorities[almost_full] -= 2  # Strong penalty: Opening new bin likely better\n    else:\n        #No bin fits: Small negative priority to discourage assigning to a random one\n        priorities[:] = -0.0001\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher priority means we want to add the item into that bin first.\n\n    This function considers a combination of factors to determine bin priority:\n    1. Remaining capacity relative to item size. Bins that have remaining\n       capacity close to item size are prioritized to avoid excessive fragmentation.\n    2. Avoid bins that are almost full (to prevent failed placements later).\n    3. If no bin is large enough, give a uniform small negative priority,\n       so that we prefer opening a new bin instead of a random assignment.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the space wasted if the item were added to the bin\n    waste = bins_remain_cap - item\n\n    # Identify bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n\n        # Prioritize bins where waste is minimized\n        priorities[valid_bins] = -np.abs(waste[valid_bins])\n\n        # If some bins are a *very* good fit (waste close to zero), boost those\n        close_fit = np.abs(waste[valid_bins]) < 0.1 * item  # Adjust threshold as needed\n        priorities[valid_bins][close_fit] += 1  # Add a bonus for good fits.  The magnitude here is key to the behaviour\n\n        # Penalize bins that are very full already\n        full_threshold = 0.1 # percentage of bin capacity below which it is considered almost full\n        almost_full = bins_remain_cap < (1 + full_threshold) * item\n        priorities[almost_full] -= 2  # Strong penalty: Opening new bin likely better\n    else:\n        #No bin fits: Small negative priority to discourage assigning to a random one\n        priorities[:] = -0.0001\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Focus on bins where the item *can* fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        \n        # Heuristic 1: Try to fill bins as much as possible (minimize remaining space)\n        #remaining_space_priority = 1 / (remaining_space + 1e-9) # Avoid division by zero, prioritize small remaining space\n\n        # Heuristic 2: Use Best-Fit Decreasing strategy. Select bin that minimizes the wasted space,\n        #but scaled by available bin size. Gives higher score to a better fit in a bigger bin, which should prevent\n        #overfilling the small ones.\n        remaining_space_priority = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins] \n        remaining_space_priority = 1 - remaining_space_priority  #Higher values mean less wasted space\n        \n        priorities[eligible_bins] = remaining_space_priority\n\n    else:\n        # No bin can fit. Give a slightly increasing score based on remaining capacity.\n        # This is a fallback so that we choose bin with slightly larger size. \n        # Prioritize bins with larger remaining capacity to avoid overly concentrating on small bins when new bins cannot be allocated.\n        priorities = bins_remain_cap #Prioritize the bin with the most remaining capacity\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Focus on bins that can accommodate the item.\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        # Prioritize bins that would be fullest after packing (smallest remaining space)\n        priorities[eligible_bins] = 1 / (remaining_space + 1e-9)  # Adding small value to avoid division by zero\n\n        #Boost priority to almost full bins.\n        almost_full_bins = (bins_remain_cap[eligible_bins] - item) < (0.1 * bins_remain_cap[eligible_bins])\n\n        priorities[np.where(eligible_bins)[0][almost_full_bins]] *= 2 #Double the priority\n\n\n    else:\n        #No bin is capable of containing item. Let's give them equal priority so a new bin will be open.\n        priorities = np.ones_like(bins_remain_cap) *0.1\n\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Focus on bins where the item *can* fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        \n        # Heuristic 1: Try to fill bins as much as possible (minimize remaining space)\n        #remaining_space_priority = 1 / (remaining_space + 1e-9) # Avoid division by zero, prioritize small remaining space\n\n        # Heuristic 2: Use Best-Fit Decreasing strategy. Select bin that minimizes the wasted space,\n        #but scaled by available bin size. Gives higher score to a better fit in a bigger bin, which should prevent\n        #overfilling the small ones.\n        remaining_space_priority = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins] \n        remaining_space_priority = 1 - remaining_space_priority  #Higher values mean less wasted space\n        \n        priorities[eligible_bins] = remaining_space_priority\n\n    else:\n        # No bin can fit. Give a slightly increasing score based on remaining capacity.\n        # This is a fallback so that we choose bin with slightly larger size. \n        # Prioritize bins with larger remaining capacity to avoid overly concentrating on small bins when new bins cannot be allocated.\n        priorities = bins_remain_cap #Prioritize the bin with the most remaining capacity\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Focus on bins that can accommodate the item.\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        # Prioritize bins that would be fullest after packing (smallest remaining space)\n        priorities[eligible_bins] = 1 / (remaining_space + 1e-9)  # Adding small value to avoid division by zero\n\n        #Boost priority to almost full bins.\n        almost_full_bins = (bins_remain_cap[eligible_bins] - item) < (0.1 * bins_remain_cap[eligible_bins])\n\n        priorities[np.where(eligible_bins)[0][almost_full_bins]] *= 2 #Double the priority\n\n\n    else:\n        #No bin is capable of containing item. Let's give them equal priority so a new bin will be open.\n        priorities = np.ones_like(bins_remain_cap) *0.1\n\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Immediate Fit: Highest priority for bins that can fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # High priority for perfect fit\n\n    # Next Fit Heuristic: If the last used bin can fit, give it a high priority.\n    # This encourages using the same bin repeatedly when possible.\n    if len(bins_remain_cap) > 0 and bins_remain_cap[0] >= item and not perfect_fit[0]:\n        priorities[0] = 500\n\n    # First Fit Decreasing (modified): Prioritize bins with enough space, but not too much\n    # Avoids leaving very small spaces.  Balances bin utilization.\n\n    enough_space = bins_remain_cap >= item\n    small_space_left = bins_remain_cap - item < 0.1  # Arbitrary small value relative to bin size\n\n    priorities[enough_space & ~perfect_fit] = (bins_remain_cap[enough_space & ~perfect_fit] - item) / np.max(bins_remain_cap)\n    priorities[enough_space & ~perfect_fit] = 1 - priorities[enough_space & ~perfect_fit] #Higher score given to those that are less empty after insertion\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: If the item doesn't fit, priority is -inf\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # 2. First Fit Decreasing-ish: Prioritize bins that are \"just big enough\".\n    #    We want to fill bins as much as possible to avoid fragmentation.\n    #    Use an exponential decay to heavily penalize larger bins.\n    feasible = ~infeasible\n    remaining_after_fit = bins_remain_cap[feasible] - item\n    priorities[feasible] = np.exp(-10 * remaining_after_fit / item)\n\n    # 3. Avoid Very Empty Bins (Except when necessary)\n    # If almost empty and item does not fill to over certain value, penalize.\n    almost_empty = bins_remain_cap > 0.9\n    will_not_fill = bins_remain_cap - item > 0.1\n    priorities[almost_empty & will_not_fill] -= 0.1 # small penalty\n\n    # 4. Give a tiny nudge for the fullest bin to break ties.\n    # This is like a 'best fit' tiebreaker\n    if np.any(feasible): # Only if there ARE feasible bins...\n        best_fit_idx = np.argmax(bins_remain_cap[feasible] - item)\n        indices = np.where(feasible)[0] # Get indices that are True\n        priorities[indices[best_fit_idx]] += 0.001 # very small bonus\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: If the item doesn't fit, priority is -inf\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # 2. First Fit Decreasing-ish: Prioritize bins that are \"just big enough\".\n    #    We want to fill bins as much as possible to avoid fragmentation.\n    #    Use an exponential decay to heavily penalize larger bins.\n    feasible = ~infeasible\n    remaining_after_fit = bins_remain_cap[feasible] - item\n    priorities[feasible] = np.exp(-10 * remaining_after_fit / item)\n\n    # 3. Avoid Very Empty Bins (Except when necessary)\n    # If almost empty and item does not fill to over certain value, penalize.\n    almost_empty = bins_remain_cap > 0.9\n    will_not_fill = bins_remain_cap - item > 0.1\n    priorities[almost_empty & will_not_fill] -= 0.1 # small penalty\n\n    # 4. Give a tiny nudge for the fullest bin to break ties.\n    # This is like a 'best fit' tiebreaker\n    if np.any(feasible): # Only if there ARE feasible bins...\n        best_fit_idx = np.argmax(bins_remain_cap[feasible] - item)\n        indices = np.where(feasible)[0] # Get indices that are True\n        priorities[indices[best_fit_idx]] += 0.001 # very small bonus\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Prioritize bins that can fit the item reasonably well, but avoid very tight fits or wasted space.\n    # We want bins where the item takes up a significant portion, but also leaves some room for future items.\n\n    fit_ratios = item / bins_remain_cap  # How much of the bin the item would fill\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a strong preference to bins that can fit the item (fit_ratio <= 1), penalize otherwise.\n    fit_penalty = 10.0  # A penalty value if the bin cannot fit\n    priorities[fit_ratios > 1] = -fit_penalty\n\n    # Among bins that fit, prioritize those where item fills reasonable amount\n    # i.e. not too empty, and not too tightly fit.\n    valid_bins = fit_ratios <= 1\n    if np.any(valid_bins):\n        priorities[valid_bins] = np.exp(-np.abs(fit_ratios[valid_bins] - 0.7)) # gaussian around 0.7\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Prioritize bins that can fit the item reasonably well, but avoid very tight fits or wasted space.\n    # We want bins where the item takes up a significant portion, but also leaves some room for future items.\n\n    fit_ratios = item / bins_remain_cap  # How much of the bin the item would fill\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a strong preference to bins that can fit the item (fit_ratio <= 1), penalize otherwise.\n    fit_penalty = 10.0  # A penalty value if the bin cannot fit\n    priorities[fit_ratios > 1] = -fit_penalty\n\n    # Among bins that fit, prioritize those where item fills reasonable amount\n    # i.e. not too empty, and not too tightly fit.\n    valid_bins = fit_ratios <= 1\n    if np.any(valid_bins):\n        priorities[valid_bins] = np.exp(-np.abs(fit_ratios[valid_bins] - 0.7)) # gaussian around 0.7\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins with sufficient remaining capacity, favoring those with slightly larger capacity than the item size\n    to reduce fragmentation. Avoids bins where the item nearly fills the bin.\n    Uses a combination of remaining capacity and a \"near-fit\" bonus/penalty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Capacity check: Disqualify bins that cannot fit the item.\n    eligible_bins = bins_remain_cap >= item\n\n    # Base priority: Remaining capacity (higher capacity generally preferred, within reason)\n    priorities[eligible_bins] = bins_remain_cap[eligible_bins]\n\n    # Near-fit bonus/penalty: Encourages good fits, discourages almost-full fits\n    near_fit_threshold_upper = item * 1.2  # slightly larger\n    near_fit_threshold_lower = item * 1.05 # avoid packing if only marginally bigger\n\n    near_fit_bins = (bins_remain_cap >= item) & (bins_remain_cap <= near_fit_threshold_upper) & (bins_remain_cap >= near_fit_threshold_lower)\n\n    nearly_full_bins = (bins_remain_cap >= item) & (bins_remain_cap < item * 1.05)\n\n    priorities[near_fit_bins] += bins_remain_cap[near_fit_bins] #give bonus for near fit.\n    priorities[nearly_full_bins] -= (item * 2)  # penalty if item nearly fills bin (creates fragmentation)\n\n    #Very large capacities are not good either. They are penalized.\n\n    large_cap_bins = bins_remain_cap > item * 2\n    priorities[large_cap_bins] -= bins_remain_cap[large_cap_bins] * 0.1\n\n    # If no bins can fit, return a low-priority score for all (should not happen in normal usage)\n    if not np.any(eligible_bins):\n        priorities[:] = -1e9  # Extremely low priority for all if item cannot fit in any bin\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates ideas of:\n    1. **First Fit Decreasing (FFD)-ish**: Prioritize bins that can fit the item snugly, but penalize bins that are almost full to avoid fragmentation\n    2. **Best Fit**: Prioritize bins that leave the least wasted space.\n    3. **Bin Level Aware**:  A slight bias towards filling \"more\" empty bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign large negative priority to bins that can't fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Prioritize bins that fit but penalize very full bins\n    feasible_mask = ~infeasible_mask\n\n    if np.any(feasible_mask):\n\n        # Reward \"snug\" fits, calculated by closeness of item to remaining capacity\n        fit_scores = np.exp(-(bins_remain_cap[feasible_mask] - item))\n\n        # Add bonus to \"almost empty\" bins - helps open new bins\n        empty_bin_bonus = bins_remain_cap[feasible_mask]\n\n        # Avoid bins almost full - higher number means lower priority. This should result in more even bin usage\n        almost_full_penalty =  np.exp(10 * (1 - (bins_remain_cap[feasible_mask] / np.max(bins_remain_cap))))\n\n        priorities[feasible_mask] =  fit_scores + 0.1*empty_bin_bonus - almost_full_penalty\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}