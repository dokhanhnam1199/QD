[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, first fit bias, near fit bonus, and dynamic fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # First Fit Preference with a slight bias for fuller bins.\n        priorities[eligible_bins] = 1 / (bins_remain_cap[eligible_bins] + 0.0001)\n\n        # Best Fit Encouragement\n        capacity_diff = np.abs(bins_remain_cap - item)\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = (capacity_diff == min_diff) & eligible_bins\n        priorities[best_fit_bins] += 2\n\n        # Near Fit bonus: Reward bins slightly larger than item\n        near_fit_threshold_upper = item * 1.2\n        near_fit_bins = (bins_remain_cap >= item) & (bins_remain_cap <= near_fit_threshold_upper)\n        priorities[near_fit_bins] += 0.5 * priorities[near_fit_bins]\n\n        # Adaptive Fragmentation Penalty: Penalize almost-full bins\n        near_full_threshold = 0.95\n        near_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= (1 - near_full_threshold) * bins_remain_cap)\n        if np.any(near_full):\n            priorities[near_full] -= 1 / (1 + np.exp(-100*(bins_remain_cap[near_full] - item - (1 - near_full_threshold) * bins_remain_cap[near_full])))\n\n    else:\n        priorities[:] = -1  # Item doesn't fit\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit component: prioritize bins with smallest waste\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        # Fill ratio component: encourage higher fill\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.4\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n        # Adaptive fragmentation penalty: penalize bins becoming almost full\n        almost_full_threshold = 0.1\n        almost_full = bins_remain_cap[valid_bins] < (1 + almost_full_threshold) * item\n        almost_full_penalty = 2.0 # Slightly reduced penalty from v1\n        priorities[valid_bins][almost_full] -= almost_full_penalty\n\n        # Non-linearity based on remaining capacity, gently encouraging tighter fits.\n        remaining_after_fit_scale = 5.0 # Adjusted scaling\n        remaining_after_fit_weight = 0.2\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n        # Prioritize bins with smallest remaining capacity slightly\n        min_remaining_cap = np.min(bins_remain_cap[valid_bins])\n        priorities[bins_remain_cap == min_remaining_cap] += 0.1 # Small boost\n        \n    else:\n        # Discourage placement if no bin fits.\n        discourage_placement_value = 0.0008\n        priorities[:] = -discourage_placement_value\n        \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    potential_bins = bins_remain_cap >= item\n\n    if np.any(potential_bins):\n        # Best fit component: Maximize bin utilization.\n        waste = bins_remain_cap[potential_bins] - item\n        priorities[potential_bins] = 1 - waste / bins_remain_cap[potential_bins]\n\n        # Fill ratio bonus\n        fill_fraction = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += 0.3 * fill_fraction  # Weight adjusted\n\n        # Adaptive fragmentation penalty: Penalize bins leaving small fragments\n        small_fragment_threshold = item * 0.6  # Adaptive threshold\n        remaining_after_pack = bins_remain_cap - item\n        too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n        if np.any(too_small_remaining):\n            priorities[too_small_remaining] -= 0.7  # Stronger penalty\n\n        #First fit tiebreaker.\n        eligible_bins = bins_remain_cap >= item\n        if np.any(eligible_bins):\n            first_eligible_index = np.argmax(eligible_bins) # Select the index of the first true value\n            priorities[first_eligible_index] += 0.01\n    else:\n        priorities[:] = -0.001  # Discourage if no suitable bin\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 5.055843637814125,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - scale by a factor\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio * 0.7\n\n        # Best Fit - encourage packing to tightest fitting bin\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-5 * remaining_space)\n\n        # Fragmentation Penalty-Adaptive-heavier penalty for very small remaining spaces\n        remaining_space = bins_remain_cap - item\n        nearly_empty = (remaining_space > 0) & (remaining_space < 0.1)\n        priorities[nearly_empty] -= 3.0 # stronger penality\n\n        #First fit preference\n        first_fit_index = np.argmax(eligible_bins)\n        priorities[first_fit_index] += 0.5\n\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        \n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.8\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2  \n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.3\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.520143597925803,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, best fit, bin balancing, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio (Encourage fuller bins)\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio\n\n        # Best Fit (Minimize wasted space)\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-remaining_space * 2)\n\n    # Bin Balancing (Distribute items across bins, avoid single bin domination)\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * bin_capacity_normalized\n\n    # Fragmentation Penalty (Discourage leaving small spaces)\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    if np.any(near_full):\n        priorities[near_full] -= 0.5\n\n    # Target fill bonus.\n    target_fill = 0.8\n    ideal_remaining = 1 - target_fill\n    distance_to_ideal = np.abs((bins_remain_cap - item) - ideal_remaining)\n\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += np.exp(-distance_to_ideal[eligible_bins] * 5)\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.9760670123653865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, target fill, and adaptive waste/fragmentation penalty with capacity weights.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Best Fit component\n        remaining_space = bins_remain_cap[can_fit] - item\n        fit_scores = 1 / (remaining_space + 1e-9)\n\n        # Target fill ratio component (around 70%)\n        fit_ratios = item / bins_remain_cap[can_fit]\n        target_priority = np.exp(-np.abs(fit_ratios - 0.7))\n\n        # Fragmentation Penalty: penalize leaving small space\n        waste_ratio = remaining_space / item\n        waste_penalty = np.exp( -waste_ratio)\n\n        # Capacity weights\n        capacity_weights = bins_remain_cap[can_fit]/np.max(bins_remain_cap)\n        \n        # Combined score with capacity weights for balancing\n        combined_priority = (capacity_weights * fit_scores + (1 - capacity_weights) * target_priority) - 0.2*waste_penalty # waste_penalty impact\n\n        #Adaptive Penalty for bin utilization > 90%\n        bin_utilization = 1 - bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        adaptive_penalty = np.exp(5 * (bin_utilization - 0.9))\n        combined_priority -= adaptive_penalty\n\n        priorities[can_fit] = combined_priority\n    else:\n        # Prioritize larger bins when no fit exists\n        priorities = bins_remain_cap\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.397686477862,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, and fragmentation penalty with tuning.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste)  # Lower waste is better\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)  # Closer to ideal is better\n        \n        # Fragmentation penalty (discourage near-full bins)\n        near_full_threshold = 0.1\n        near_full = (bins_remain_cap >= item) & (bins_remain_cap < (item * (1 + near_full_threshold)))\n        priorities[near_full] -= 1.2 #Increased Penalty\n        \n        # Encourage near-empty reuse\n        near_empty_threshold = 0.1\n        near_empty = bins_remain_cap > (1 - item * near_empty_threshold)\n        priorities[near_empty] -= 0.75\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n    \n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, best fit, fragmentation penalty and almost empty reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - adjusted for sensitivity\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += 0.8 * fill_ratio  #Reduced sensitivity\n\n        # Best Fit - with exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 1.2*np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0  #Slightly decreased penalty\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7 #almost empty reuse bonus.\n\n    #Balance the empty bins\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.05*bin_capacity_normalized\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 6.122856003191075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, bin balancing, and fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - encourages filling bins well\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += 0.5 * fill_ratio\n\n        # Best Fit - minimizes wasted space\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 0.6 * np.exp(-remaining_space) #Nonlinear best fit\n\n        # Fragmentation Penalty - discourages leaving small gaps\n        priorities[eligible_bins] -= 0.2 * (remaining_space / np.max(bins_remain_cap)) # Normalize penalty\n\n    # Bin Balancing - distributes items across bins\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * bin_capacity_normalized\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin-use count, \n    with adaptive weights based on item size.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n    # Adaptive Weighting based on item size\n    item_size_factor = min(1.0, item)  # Normalize item size (assuming bin size is 1)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.8 + 0.2 * item_size_factor)  # Adjust weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.7 + 0.3 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.05 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.2 + 0.1 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9 + 0.05 * item_size_factor\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.6 + 0.1 * item_size_factor\n    \n    #5.Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n          priorities[too_empty] -= 0.5 * item_size_factor\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.8492221779018885,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin utilization,\n    with adaptive components.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_size = 1.0 # Assuming bin size is 1\n\n    # 1. Fill Ratio Preference (Prioritize bins where item fits)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * 0.8  # Slightly reduced weight\n\n    # 2. Best Fit Encouragement (Focuses on minimizing wasted space)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.0  # Increased weight for best fit\n\n    # 3. Fragmentation Penalty (Adaptive based on item size)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * 0.3 #Adaptive threshold\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.5  #Increased penalty\n\n    # 4. Encourage Re-use of Almost Empty Bins (More aggressive reuse)\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > (bin_size * almost_empty_threshold)\n    if np.any(almost_empty):\n        priorities[almost_empty] += 1.0 # Increased incentive\n\n    # 5. Bin Utilization Preference (Encourage using bins with some content)\n    partially_full_threshold_lower = 0.2\n    partially_full_threshold_upper = 0.8\n    partially_full = (bins_remain_cap < bin_size * partially_full_threshold_upper) & (bins_remain_cap > bin_size * partially_full_threshold_lower)\n\n    if np.any(partially_full):\n        priorities[partially_full] += 0.5\n\n    # 6. Adaptive Adjustment for Large Items\n    large_item_threshold = 0.6\n    if item > large_item_threshold:\n        # Heavily penalize fragmentation for large items\n        fragmented_bins = remaining_space > 0 & remaining_space < bin_size*0.2\n        priorities[fragmented_bins] -= 2.0\n        # Favor almost empty bins even more for large items\n        if np.any(almost_empty):\n            priorities[almost_empty] += 1.5\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 49, in priority_v2\nTypeError: ufunc 'bitwise_and' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''\n"
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and bin-usage encouragement with adaptive weights.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference (Adjusted for bin fullness)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.5 * (1 - np.mean(bins_remain_cap)))  # Adaptive weight: favors bins when average fullness is low\n\n    # 2. Best Fit Encouragement (Stronger boost)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.2  # Stronger best-fit\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.1 * np.mean(bins_remain_cap))  # Adaptive threshold based on avg capacity\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.5 #Slightly increased penalty\n\n    # 4. Encourage re-use of almost empty bins (Adjusted boost)\n    almost_empty_threshold = 0.90 # Reduced Threshold\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.9  # Increased bonus\n\n    # 5. Bin usage encouragement. Give priority to bins that are already in use, to reduce number of open bins\n    used_bins = bins_remain_cap < 1.0 # bin size normalized to 1\n    if np.any(used_bins):\n        priorities[used_bins] += 0.4 # Small incentive to reuse\n\n    #6. Balancing term: Encourage using bins that will be filled more than a certain percentage\n\n    fill_percentage = item / (1 - bins_remain_cap)\n    high_fill_bins = (bins_remain_cap >= item) & (fill_percentage > 0.7) & (bins_remain_cap < 1)\n    if np.any(high_fill_bins):\n        priorities[high_fill_bins] += 0.6 # Incentive for filling greater than 70%\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin-usage encouragement\n    with adaptive weights and state-dependent logic.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights (based on item size and bin availability)\n    item_size_factor = min(1.0, item)  # Normalize item size\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    large_bin_bonus_weight = 0.3\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] += fill_ratio_weight * (item / bins_remain_cap[potential_bins])\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)  #Adaptive threshold\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95  # If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight\n\n    #5. Bonus for larger bins if item is small\n    if item_size_factor < 0.3:\n        large_bins = bins_remain_cap > 0.7\n        if np.any(large_bins):\n            priorities[large_bins] += large_bin_bonus_weight\n    \n    #6. Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and bin-emptiness with adaptive weights.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference (Weighted by remaining capacity)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.5 * bins_remain_cap[potential_bins])  # Weight fill ratio\n\n    # 2. Best Fit Encouragement (Adaptive Bonus)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        best_fit_bonus = 1.5 + 0.7 * (1 - (min_diff / item))  # Adaptive bonus based on how \"best\" it is\n        priorities[best_fit_bins] += best_fit_bonus\n\n    # 3. Fragmentation Penalty (Adaptive Threshold and Penalty)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.05 * (num_bins / (np.sum(bins_remain_cap) + 1e-9))) #threshold shrinks as bin space increases\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    fragmentation_penalty = 1.0 + 0.5 * (fragmentation_threshold - remaining_space[fragmented_bins]) / (fragmentation_threshold + 1e-9) #penalty increases as space remaining nears the threshold\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage re-use of almost empty bins (Adaptive Bonus)\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + 0.4 * (bins_remain_cap[almost_empty] - almost_empty_threshold) / (1 - almost_empty_threshold + 1e-9)\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Penalize bins that are too full to discourage overfill\n    too_full_threshold = item*1.1 # if bin is filled more than item size, penalize it.\n    overfilled_bins = (bins_remain_cap < item) & (bins_remain_cap > 0)\n    if np.any(overfilled_bins):\n        priorities[overfilled_bins] -= 0.8 #slight penality to encourage use of other viable bins\n        \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  }
]