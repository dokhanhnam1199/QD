[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation, and bin-use count adaptively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor)\n\n    # 2. Best Fit\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage almost empty bin usage.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n\n    # 5. Discourage too empty bins after packing.\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n\n    #6. Add small bonus to bins that can accommodate the item (tie breaker).\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += 0.01\n\n    else:\n       priorities[:] = -0.001 # Discourage if no suitable bin\n        \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and adaptive fragmentation/waste penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights (based on item size)\n    item_size_factor = min(1.0, item)\n    fill_ratio_weight = 0.6 + 0.2 * item_size_factor\n    best_fit_weight = 1.2 + 0.3 * (1-item_size_factor)\n    fragmentation_penalty_weight = 0.8 + 0.2 * item_size_factor\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] += fill_ratio_weight * (item / bins_remain_cap[potential_bins])\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n    # 4. Encourage utilization, discourage near-full but unusable bins\n    bin_utilization = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    too_full = (bins_remain_cap < item) & (bins_remain_cap > (item - 0.2))\n    priorities[too_full] -= 0.7\n\n    # 5. Slightly empty bin penalty\n    slightly_empty = (bins_remain_cap > item) & (bins_remain_cap < (item + 0.2))\n    priorities[slightly_empty] -= 0.3\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority: Best-fit, target fill, fragmentation, near-empty bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit: Minimize waste. Larger items get higher best-fit score\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + item) # Item size scaling\n\n        # Target fill: Encourage around 80% fill\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty: Discourage near-full bins, scaled by item size\n        near_full_threshold = 0.1\n        near_full = (bins_remain_cap[valid_bins] >= item) & (bins_remain_cap[valid_bins] < (item * (1 + near_full_threshold)))\n        priorities[valid_bins][near_full] -= 1.2 + item  # Item size scaling\n\n        # Encourage near-empty reuse with size condition\n        near_empty_threshold = 0.1\n        near_empty = bins_remain_cap > (1 - item * near_empty_threshold)\n        priorities[near_empty] -= 0.75 * (1-item)\n    else:\n        priorities[:] = -100  # Very low for invalid placements\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and adaptive fragmentation penalty.\n    State-aware and balances bin usage with fill efficiency.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n    potential_bins = bins_remain_cap >= item\n\n    # Fill Ratio Preference (Adjusted)\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.3 * (1 - np.mean(bins_remain_cap)))\n\n    # Best Fit Encouragement (Stronger boost)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.0\n\n    # Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.05 * np.mean(bins_remain_cap))\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.3\n\n    # Encourage re-use (Adjusted boost)\n    used_bins = bins_remain_cap < 1.0\n    if np.any(used_bins):\n        priorities[used_bins] += 0.3\n\n    # Fill percentage incentive\n    if np.any(potential_bins):\n        fill_percentage = item / (1 - bins_remain_cap[potential_bins]) if np.any(1-bins_remain_cap[potential_bins] > 0) else np.zeros_like(bins_remain_cap[potential_bins])\n        fill_percentage_filter = (1- bins_remain_cap[potential_bins]) > 0\n        high_fill_bins = fill_percentage > 0.7\n        \n        if np.any(high_fill_bins) and np.any(fill_percentage_filter):\n            eligible_bins_index = np.where(potential_bins)[0][high_fill_bins & fill_percentage_filter]\n            priorities[eligible_bins_index] += 0.5\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.14240127642603,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, fragmentation penalty, adaptive weighting.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    num_bins = len(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + 0.1 * item) # Adaptive based on item size\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty (discourage near-full bins)\n        fragmentation_threshold = item * 0.15\n        remaining_space = bins_remain_cap - item\n        fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n        fragmentation_penalty = 1.0 + 0.5 * (fragmentation_threshold - remaining_space[fragmented_bins]) / (fragmentation_threshold + 1e-9)\n        priorities[fragmented_bins] -= fragmentation_penalty * (1 + 0.05 * (num_bins / (np.sum(bins_remain_cap) + 1e-9))) # Adaptive penalty\n\n        # Encourage near-empty reuse\n        almost_empty_threshold = 0.9\n        almost_empty = bins_remain_cap > almost_empty_threshold\n        if np.any(almost_empty):\n            almost_empty_bonus = 0.5 + 0.4 * (bins_remain_cap[almost_empty] - almost_empty_threshold) / (1 - almost_empty_threshold + 1e-9)\n            priorities[almost_empty] += almost_empty_bonus\n\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 11.268448344635022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, adaptive fragmentation penalty, and empty bin reuse.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n\n    # Adaptive item size factor (normalized)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor) # Adaptive weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n        \n    # 5. Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n        \n    #6. If no suitable bin, slightly discourage all bins to allow new bin creation\n    if not np.any(potential_bins):\n        priorities[:] -= 0.001\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, adaptive fragmentation penalty, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # 1. Fill Ratio Preference\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += 0.5 * fill_ratio\n\n        # 2. Best Fit Encouragement (Nonlinear)\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 0.6 * np.exp(-remaining_space)\n\n        # 3. Adaptive Fragmentation Penalty\n        max_bin_cap = np.max(bins_remain_cap) if np.any(bins_remain_cap) else 1.0\n        fragmentation_penalty = 0.2 * (remaining_space / max_bin_cap)\n        priorities[eligible_bins] -= fragmentation_penalty\n\n    # 4. Bin Balancing (Encourage use of emptier bins)\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * (1-bin_capacity_normalized)\n\n    # 5. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority function balancing fill, waste, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Fill Ratio: Encourage higher fill\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_ratio * 0.5  # Reduced weight\n\n        # Best Fit: Prioritize tightest fit\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-5 * remaining_space) * 0.8 # Adjusted scaling & weight\n\n        # Adaptive Fragmentation Penalty: Avoid small remaining spaces\n        almost_empty_threshold = 0.2 # Increased threshold\n        nearly_empty = (bins_remain_cap[valid_bins] - item > 0) & (bins_remain_cap[valid_bins] - item < almost_empty_threshold)\n        priorities[valid_bins][nearly_empty] -= 2.5  # Reduced penalty\n\n        # Global Fill Level Consideration: Target around 75% fill\n        global_fill = np.sum((1 - bins_remain_cap/1)) / len(bins_remain_cap) # Assuming bin capacity is 1\n        target_fill = 0.75\n        distance_to_target = abs(global_fill - target_fill)\n        # Weight based on how far global fill is from target.  Less penalty if close.\n        priorities[valid_bins] -= distance_to_target * 0.3\n\n    else:\n        # Discourage if no bin fits\n        priorities[:] = -0.001\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty, & reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights\n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    \n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - Adaptive\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight #almost empty reuse bonus.\n\n    # Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 6.122856003191075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, adaptive fragmentation,\n    and a global bin state consideration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        # Fill ratio component (encourage high fill)\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.4\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n        # Adaptive fragmentation penalty\n        small_fragment_threshold = item * 0.6\n        remaining_after_pack = bins_remain_cap[valid_bins] - item\n        too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n        fragmentation_penalty = 0.7\n        priorities[valid_bins][too_small_remaining] -= fragmentation_penalty\n\n        # Global bin state: encourage using bins when *many* are empty\n        num_almost_empty = np.sum(bins_remain_cap > 0.9)  # Count nearly empty bins\n        if num_almost_empty > bins_remain_cap.size / 2: # if majority of bins are almost empty\n            priorities[valid_bins] += 0.2  # Boost the priority\n\n        # Nonlinearity to prefer slightly tighter fits\n        remaining_after_fit_scale = 5.0\n        remaining_after_fit_weight = 0.2\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n    else:\n        # Discourage placement if no bin fits\n        discourage_placement_value = 0.001\n        priorities[:] = -discourage_placement_value\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and adaptive elements.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] = fill_ratios\n\n    # 2. Best Fit Encouragement (Weighted)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        best_fit_weight = 1.5  # Static best-fit weight adjusted.\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    avg_bin_cap = np.mean(bins_remain_cap)  # Global state: average bin capacity\n    fragmentation_threshold_multiplier = 0.2 # Adjusted fragmentation threshold\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    fragmentation_penalty = 1.3 # Adjusted fragmentaion penalty\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage re-use of almost empty bins (Adaptive)\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold #bin size set to 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.8\n        priorities[almost_empty] += almost_empty_bonus\n    \n    # 5. Exploration Bonus: Prefer bins with higher remaining capacity when relatively full\n    global_fill_level = np.sum(1-bins_remain_cap) / num_bins #estimate the global fill level\n    if global_fill_level > 0.7: #If relatively full, try to pack to bins that have some space\n        exploration_bonus = 0.3 * bins_remain_cap #linear increasing to remaining capacity.\n        priorities += exploration_bonus # encourage packing where there is space\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 6.19266055045873,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_size: float = 1.0) -> np.ndarray:\n    \"\"\"\n    A more sophisticated priority function for online bin packing, incorporating adaptive weighting,\n    state awareness, and controlled exploration.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # --- State Awareness: Global Bin Fill Level ---\n    avg_fill = np.mean(bin_size - bins_remain_cap) / bin_size  # Average fill level across all bins\n\n    # --- Objective Function Components ---\n\n    # 1. Fill Rate: How much of the bin is filled by the new item?\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_rate = item / bin_size # Calculate fill rate as item/bin_size regardless of the target bin's capacity.\n        priorities[potential_bins] += fill_rate\n\n    # 2. Waste Minimization (Best Fit): Minimize remaining space\n    capacity_diff = bins_remain_cap - item\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_waste = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_waste\n        # Adaptive weight: Higher weight if bins are generally empty\n        waste_weight = 1.0 + (1.0 - avg_fill)  \n        priorities[best_fit_bins] += waste_weight * (1 - (min_waste / bin_size))  # Reward smaller waste\n\n    # 3. Fragmentation Penalty\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = 0.2 * bin_size # Fixed threshold relative to bin size\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    # Adaptive penalty: Higher penalty if bins are already highly filled\n    fragmentation_penalty = 0.5 + avg_fill  # Base penalty + fill level\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage Re-use of Near-Empty Bins\n    almost_empty_threshold = 0.9  # Threshold as a fraction of bin size\n    almost_empty = bins_remain_cap > (almost_empty_threshold * bin_size)\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.8 # fixed bonus\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration: Introduce controlled randomness, especially when bins are similar\n    if np.std(priorities) < 0.1:  # If priorities are close, add some noise\n        priorities += np.random.normal(0, 0.05, num_bins)  # Small Gaussian noise\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 7.66852812126048,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"A multi-objective priority function for online bin packing, incorporating adaptive weighting and state awareness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Priority (Normalized)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios\n\n    # 2. Best Fit Bonus (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        # Adaptive weight based on fill levels: Higher fill means a greater bonus\n        average_fill = np.mean(1 - bins_remain_cap)  # Average fill level of bins\n        best_fit_weight = 1.0 + (average_fill * 1.5) #Weight increases as bins become fuller\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (State-Aware)\n    remaining_space = bins_remain_cap - item\n    # Dynamically adjust fragmentation threshold based on the item size and number of bins\n    fragmentation_threshold_multiplier = 0.2 / np.sqrt(num_bins)  #Smaller bins more susceptible to fragmentation\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    # Penalize fragmented bins less as the bins get fuller\n    fragmentation_penalty = 1.0 - average_fill\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage Re-use of Almost Empty Bins (Dynamic Bonus)\n    almost_empty_threshold = 0.05 + (0.05 * average_fill) # More selective for almost empty as bins fill\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size is 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + average_fill * 0.5 #Bigger bonus as bins fill\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration: Add a small amount of randomness, scaled to the item size.\n    exploration_factor = 0.01 * item  # Scale randomness based on the item size\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 148.65376944555246,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and bin utilization awareness with adaptive weights.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # ----------------------------------------------------------------------\n    # --- Adaptive Weighting based on Bin Utilization ---\n    # ----------------------------------------------------------------------\n    avg_bin_utilization = np.mean(1 - bins_remain_cap)  # average fill level of bins\n    utilization_factor = 1.0 + (avg_bin_utilization - 0.5)  # Adjust around 0.5 utilization\n\n    # ----------------------------------------------------------------------\n    # --- 1. Fill Ratio Preference (Enhanced) ---\n    # ----------------------------------------------------------------------\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * utilization_factor\n\n    # ----------------------------------------------------------------------\n    # --- 2. Best Fit Encouragement (Adaptive) ---\n    # ----------------------------------------------------------------------\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        best_fit_weight = 1.5 * utilization_factor # Adaptive weight\n        priorities[best_fit_bins] += best_fit_weight\n\n    # ----------------------------------------------------------------------\n    # --- 3. Fragmentation Penalty (Adaptive) ---\n    # ----------------------------------------------------------------------\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold_multiplier = 0.2 - (avg_bin_utilization/5) #Dynamic Threshold\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    fragmentation_penalty = 1.3 * utilization_factor #Adaptive Penalty\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # ----------------------------------------------------------------------\n    # --- 4. Encourage re-use of almost empty bins (Adaptive) ---\n    # ----------------------------------------------------------------------\n    almost_empty_threshold = 0.9 + (avg_bin_utilization / 10)\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size set to 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.8 * utilization_factor\n        priorities[almost_empty] += almost_empty_bonus\n\n    # ----------------------------------------------------------------------\n    # --- 5. Penalize bins that are too full ---\n    # ----------------------------------------------------------------------\n    too_full_threshold = item > bins_remain_cap\n    priorities[too_full_threshold] = -np.inf\n\n    # ----------------------------------------------------------------------\n    # --- 6. Exploration: Add small random noise to encourage exploration ---\n    # ----------------------------------------------------------------------\n    noise = np.random.normal(0, 0.01, num_bins)  # Small Gaussian noise\n    priorities += noise\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 6.9405664140407,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_size: float = 1.0) -> np.ndarray:\n    \"\"\"\n    A more advanced priority function for online bin packing, incorporating:\n    - Fill ratio\n    - Best fit with adaptive weighting based on bin fill levels\n    - Fragmentation penalty, also adaptive\n    - Encouragement of almost-empty bins, adaptive too\n    - Global bin state awareness to balance exploration and exploitation\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        bin_size (float): The capacity of each bin (default 1.0).\n\n    Returns:\n        np.ndarray: Priority score for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratio = (bins_remain_cap[potential_bins] - item) / bin_size  # Use bin size for consistent ratio calculation\n        priorities[potential_bins] += fill_ratio\n\n    # 2. Best Fit Encouragement (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        \n        # Adaptive best-fit weight:  Higher weight when bins are relatively empty.\n        # This encourages filling up emptier bins more aggressively.\n        average_fill = np.mean((bin_size - bins_remain_cap) / bin_size) if num_bins > 0 else 0.0 #Global bin state\n        best_fit_weight = 1.0 + (1.0 - average_fill)  # Weight increases as bins are emptier.\n\n        priorities[best_fit_bins] += best_fit_weight\n        \n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    \n    #Adaptive fragmentation threshold based on global state.\n    average_remaining = np.mean(bins_remain_cap) if num_bins > 0 else 0.0 #Global bin state\n    fragmentation_threshold_multiplier = 0.2 * (1.0 - average_remaining/bin_size) #Higher penality when bins are full\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n\n    # Adaptive fragmentation penalty. Higher when items are small relative to bin size.\n    fragmentation_penalty = 0.5 + (item / bin_size)\n    priorities[fragmented_bins] -= fragmentation_penalty\n    \n\n    # 4. Encourage re-use of almost empty bins (Adaptive Bonus)\n    almost_empty_threshold = 0.1\n    almost_empty = bins_remain_cap > (bin_size * (1 - almost_empty_threshold))\n    if np.any(almost_empty):\n        #Adaptive bonus depends on how many bins are already almost empty\n        almost_empty_count = np.sum(bins_remain_cap > (bin_size * (1 - almost_empty_threshold)))\n        almost_empty_bonus = 0.8 / (1 + almost_empty_count) #Fewer bonus when there are many almost empty bins\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration Bonus:  Occasionally select less-filled bins. (Controlled Randomness)\n    if np.random.rand() < 0.05:  # 5% chance of exploration\n        exploration_bonus = (bin_size - bins_remain_cap) / bin_size # Prefer bins that are less filled\n        priorities += exploration_bonus * 0.2 #Reduce bonus influence\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.11846828879138,
    "exec_success": true
  }
]