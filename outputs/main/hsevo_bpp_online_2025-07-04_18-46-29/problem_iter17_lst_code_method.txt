{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, \n                bins_remain_cap: np.ndarray,\n                best_fit_weight: float = 1.4784374571582626,\n                fragmentation_threshold_multiplier: float = 0.17647801253530923,\n                fragmentation_penalty: float = 1.2890365111264535,\n                almost_empty_threshold: float = 0.9472202669971742,\n                almost_empty_bonus: float = 0.7797962606982891) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        \n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * fragmentation_threshold_multiplier  \n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += almost_empty_bonus\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, adaptive fragmentation penalty, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # 1. Fill Ratio Preference\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += 0.5 * fill_ratio\n\n        # 2. Best Fit Encouragement (Nonlinear)\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 0.6 * np.exp(-remaining_space)\n\n        # 3. Adaptive Fragmentation Penalty\n        max_bin_cap = np.max(bins_remain_cap) if np.any(bins_remain_cap) else 1.0\n        fragmentation_penalty = 0.2 * (remaining_space / max_bin_cap)\n        priorities[eligible_bins] -= fragmentation_penalty\n\n    # 4. Bin Balancing (Encourage use of emptier bins)\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * (1-bin_capacity_normalized)\n\n    # 5. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, adaptive fragmentation penalty, and empty bin reuse.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n\n    # Adaptive item size factor (normalized)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor) # Adaptive weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n        \n    # 5. Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n        \n    #6. If no suitable bin, slightly discourage all bins to allow new bin creation\n    if not np.any(potential_bins):\n        priorities[:] -= 0.001\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority function balancing fill, waste, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Fill Ratio: Encourage higher fill\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_ratio * 0.5  # Reduced weight\n\n        # Best Fit: Prioritize tightest fit\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-5 * remaining_space) * 0.8 # Adjusted scaling & weight\n\n        # Adaptive Fragmentation Penalty: Avoid small remaining spaces\n        almost_empty_threshold = 0.2 # Increased threshold\n        nearly_empty = (bins_remain_cap[valid_bins] - item > 0) & (bins_remain_cap[valid_bins] - item < almost_empty_threshold)\n        priorities[valid_bins][nearly_empty] -= 2.5  # Reduced penalty\n\n        # Global Fill Level Consideration: Target around 75% fill\n        global_fill = np.sum((1 - bins_remain_cap/1)) / len(bins_remain_cap) # Assuming bin capacity is 1\n        target_fill = 0.75\n        distance_to_target = abs(global_fill - target_fill)\n        # Weight based on how far global fill is from target.  Less penalty if close.\n        priorities[valid_bins] -= distance_to_target * 0.3\n\n    else:\n        # Discourage if no bin fits\n        priorities[:] = -0.001\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority: Best-fit, target fill, fragmentation, near-empty bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit: Minimize waste. Larger items get higher best-fit score\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + item) # Item size scaling\n\n        # Target fill: Encourage around 80% fill\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty: Discourage near-full bins, scaled by item size\n        near_full_threshold = 0.1\n        near_full = (bins_remain_cap[valid_bins] >= item) & (bins_remain_cap[valid_bins] < (item * (1 + near_full_threshold)))\n        priorities[valid_bins][near_full] -= 1.2 + item  # Item size scaling\n\n        # Encourage near-empty reuse with size condition\n        near_empty_threshold = 0.1\n        near_empty = bins_remain_cap > (1 - item * near_empty_threshold)\n        priorities[near_empty] -= 0.75 * (1-item)\n    else:\n        priorities[:] = -100  # Very low for invalid placements\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, adaptive fragmentation penalty, and empty bin reuse.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n\n    # Adaptive item size factor (normalized)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor) # Adaptive weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n        \n    # 5. Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n        \n    #6. If no suitable bin, slightly discourage all bins to allow new bin creation\n    if not np.any(potential_bins):\n        priorities[:] -= 0.001\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation, and bin-use count adaptively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor)\n\n    # 2. Best Fit\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage almost empty bin usage.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n\n    # 5. Discourage too empty bins after packing.\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n\n    #6. Add small bonus to bins that can accommodate the item (tie breaker).\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += 0.01\n\n    else:\n       priorities[:] = -0.001 # Discourage if no suitable bin\n        \n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation, and bin-use count adaptively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor)\n\n    # 2. Best Fit\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage almost empty bin usage.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n\n    # 5. Discourage too empty bins after packing.\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n\n    #6. Add small bonus to bins that can accommodate the item (tie breaker).\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += 0.01\n\n    else:\n       priorities[:] = -0.001 # Discourage if no suitable bin\n        \n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation, and bin-use count adaptively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor)\n\n    # 2. Best Fit\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage almost empty bin usage.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n\n    # 5. Discourage too empty bins after packing.\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n\n    #6. Add small bonus to bins that can accommodate the item (tie breaker).\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += 0.01\n\n    else:\n       priorities[:] = -0.001 # Discourage if no suitable bin\n        \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_size: float = 1.0) -> np.ndarray:\n    \"\"\"\n    A more advanced priority function for online bin packing, incorporating:\n    - Fill ratio\n    - Best fit with adaptive weighting based on bin fill levels\n    - Fragmentation penalty, also adaptive\n    - Encouragement of almost-empty bins, adaptive too\n    - Global bin state awareness to balance exploration and exploitation\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        bin_size (float): The capacity of each bin (default 1.0).\n\n    Returns:\n        np.ndarray: Priority score for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratio = (bins_remain_cap[potential_bins] - item) / bin_size  # Use bin size for consistent ratio calculation\n        priorities[potential_bins] += fill_ratio\n\n    # 2. Best Fit Encouragement (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        \n        # Adaptive best-fit weight:  Higher weight when bins are relatively empty.\n        # This encourages filling up emptier bins more aggressively.\n        average_fill = np.mean((bin_size - bins_remain_cap) / bin_size) if num_bins > 0 else 0.0 #Global bin state\n        best_fit_weight = 1.0 + (1.0 - average_fill)  # Weight increases as bins are emptier.\n\n        priorities[best_fit_bins] += best_fit_weight\n        \n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    \n    #Adaptive fragmentation threshold based on global state.\n    average_remaining = np.mean(bins_remain_cap) if num_bins > 0 else 0.0 #Global bin state\n    fragmentation_threshold_multiplier = 0.2 * (1.0 - average_remaining/bin_size) #Higher penality when bins are full\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n\n    # Adaptive fragmentation penalty. Higher when items are small relative to bin size.\n    fragmentation_penalty = 0.5 + (item / bin_size)\n    priorities[fragmented_bins] -= fragmentation_penalty\n    \n\n    # 4. Encourage re-use of almost empty bins (Adaptive Bonus)\n    almost_empty_threshold = 0.1\n    almost_empty = bins_remain_cap > (bin_size * (1 - almost_empty_threshold))\n    if np.any(almost_empty):\n        #Adaptive bonus depends on how many bins are already almost empty\n        almost_empty_count = np.sum(bins_remain_cap > (bin_size * (1 - almost_empty_threshold)))\n        almost_empty_bonus = 0.8 / (1 + almost_empty_count) #Fewer bonus when there are many almost empty bins\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration Bonus:  Occasionally select less-filled bins. (Controlled Randomness)\n    if np.random.rand() < 0.05:  # 5% chance of exploration\n        exploration_bonus = (bin_size - bins_remain_cap) / bin_size # Prefer bins that are less filled\n        priorities += exploration_bonus * 0.2 #Reduce bonus influence\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_size: float = 1.0) -> np.ndarray:\n    \"\"\"\n    A more advanced priority function for online bin packing, incorporating:\n    - Fill ratio\n    - Best fit with adaptive weighting based on bin fill levels\n    - Fragmentation penalty, also adaptive\n    - Encouragement of almost-empty bins, adaptive too\n    - Global bin state awareness to balance exploration and exploitation\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): Remaining capacity of each bin.\n        bin_size (float): The capacity of each bin (default 1.0).\n\n    Returns:\n        np.ndarray: Priority score for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratio = (bins_remain_cap[potential_bins] - item) / bin_size  # Use bin size for consistent ratio calculation\n        priorities[potential_bins] += fill_ratio\n\n    # 2. Best Fit Encouragement (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        \n        # Adaptive best-fit weight:  Higher weight when bins are relatively empty.\n        # This encourages filling up emptier bins more aggressively.\n        average_fill = np.mean((bin_size - bins_remain_cap) / bin_size) if num_bins > 0 else 0.0 #Global bin state\n        best_fit_weight = 1.0 + (1.0 - average_fill)  # Weight increases as bins are emptier.\n\n        priorities[best_fit_bins] += best_fit_weight\n        \n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    \n    #Adaptive fragmentation threshold based on global state.\n    average_remaining = np.mean(bins_remain_cap) if num_bins > 0 else 0.0 #Global bin state\n    fragmentation_threshold_multiplier = 0.2 * (1.0 - average_remaining/bin_size) #Higher penality when bins are full\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n\n    # Adaptive fragmentation penalty. Higher when items are small relative to bin size.\n    fragmentation_penalty = 0.5 + (item / bin_size)\n    priorities[fragmented_bins] -= fragmentation_penalty\n    \n\n    # 4. Encourage re-use of almost empty bins (Adaptive Bonus)\n    almost_empty_threshold = 0.1\n    almost_empty = bins_remain_cap > (bin_size * (1 - almost_empty_threshold))\n    if np.any(almost_empty):\n        #Adaptive bonus depends on how many bins are already almost empty\n        almost_empty_count = np.sum(bins_remain_cap > (bin_size * (1 - almost_empty_threshold)))\n        almost_empty_bonus = 0.8 / (1 + almost_empty_count) #Fewer bonus when there are many almost empty bins\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration Bonus:  Occasionally select less-filled bins. (Controlled Randomness)\n    if np.random.rand() < 0.05:  # 5% chance of exploration\n        exploration_bonus = (bin_size - bins_remain_cap) / bin_size # Prefer bins that are less filled\n        priorities += exploration_bonus * 0.2 #Reduce bonus influence\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty, & reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights\n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    \n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - Adaptive\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight #almost empty reuse bonus.\n\n    # Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty, & reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights\n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    \n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - Adaptive\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight #almost empty reuse bonus.\n\n    # Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and adaptive elements.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] = fill_ratios\n\n    # 2. Best Fit Encouragement (Weighted)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        best_fit_weight = 1.5  # Static best-fit weight adjusted.\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    avg_bin_cap = np.mean(bins_remain_cap)  # Global state: average bin capacity\n    fragmentation_threshold_multiplier = 0.2 # Adjusted fragmentation threshold\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    fragmentation_penalty = 1.3 # Adjusted fragmentaion penalty\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage re-use of almost empty bins (Adaptive)\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold #bin size set to 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.8\n        priorities[almost_empty] += almost_empty_bonus\n    \n    # 5. Exploration Bonus: Prefer bins with higher remaining capacity when relatively full\n    global_fill_level = np.sum(1-bins_remain_cap) / num_bins #estimate the global fill level\n    if global_fill_level > 0.7: #If relatively full, try to pack to bins that have some space\n        exploration_bonus = 0.3 * bins_remain_cap #linear increasing to remaining capacity.\n        priorities += exploration_bonus # encourage packing where there is space\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, fragmentation penalty, adaptive weighting.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    num_bins = len(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + 0.1 * item) # Adaptive based on item size\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty (discourage near-full bins)\n        fragmentation_threshold = item * 0.15\n        remaining_space = bins_remain_cap - item\n        fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n        fragmentation_penalty = 1.0 + 0.5 * (fragmentation_threshold - remaining_space[fragmented_bins]) / (fragmentation_threshold + 1e-9)\n        priorities[fragmented_bins] -= fragmentation_penalty * (1 + 0.05 * (num_bins / (np.sum(bins_remain_cap) + 1e-9))) # Adaptive penalty\n\n        # Encourage near-empty reuse\n        almost_empty_threshold = 0.9\n        almost_empty = bins_remain_cap > almost_empty_threshold\n        if np.any(almost_empty):\n            almost_empty_bonus = 0.5 + 0.4 * (bins_remain_cap[almost_empty] - almost_empty_threshold) / (1 - almost_empty_threshold + 1e-9)\n            priorities[almost_empty] += almost_empty_bonus\n\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, fragmentation penalty, adaptive weighting.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    num_bins = len(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + 0.1 * item) # Adaptive based on item size\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty (discourage near-full bins)\n        fragmentation_threshold = item * 0.15\n        remaining_space = bins_remain_cap - item\n        fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n        fragmentation_penalty = 1.0 + 0.5 * (fragmentation_threshold - remaining_space[fragmented_bins]) / (fragmentation_threshold + 1e-9)\n        priorities[fragmented_bins] -= fragmentation_penalty * (1 + 0.05 * (num_bins / (np.sum(bins_remain_cap) + 1e-9))) # Adaptive penalty\n\n        # Encourage near-empty reuse\n        almost_empty_threshold = 0.9\n        almost_empty = bins_remain_cap > almost_empty_threshold\n        if np.any(almost_empty):\n            almost_empty_bonus = 0.5 + 0.4 * (bins_remain_cap[almost_empty] - almost_empty_threshold) / (1 - almost_empty_threshold + 1e-9)\n            priorities[almost_empty] += almost_empty_bonus\n\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"A multi-objective priority function for online bin packing, incorporating adaptive weighting and state awareness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Priority (Normalized)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios\n\n    # 2. Best Fit Bonus (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        # Adaptive weight based on fill levels: Higher fill means a greater bonus\n        average_fill = np.mean(1 - bins_remain_cap)  # Average fill level of bins\n        best_fit_weight = 1.0 + (average_fill * 1.5) #Weight increases as bins become fuller\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (State-Aware)\n    remaining_space = bins_remain_cap - item\n    # Dynamically adjust fragmentation threshold based on the item size and number of bins\n    fragmentation_threshold_multiplier = 0.2 / np.sqrt(num_bins)  #Smaller bins more susceptible to fragmentation\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    # Penalize fragmented bins less as the bins get fuller\n    fragmentation_penalty = 1.0 - average_fill\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage Re-use of Almost Empty Bins (Dynamic Bonus)\n    almost_empty_threshold = 0.05 + (0.05 * average_fill) # More selective for almost empty as bins fill\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size is 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + average_fill * 0.5 #Bigger bonus as bins fill\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration: Add a small amount of randomness, scaled to the item size.\n    exploration_factor = 0.01 * item  # Scale randomness based on the item size\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"A multi-objective priority function for online bin packing, incorporating adaptive weighting and state awareness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Priority (Normalized)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios\n\n    # 2. Best Fit Bonus (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        # Adaptive weight based on fill levels: Higher fill means a greater bonus\n        average_fill = np.mean(1 - bins_remain_cap)  # Average fill level of bins\n        best_fit_weight = 1.0 + (average_fill * 1.5) #Weight increases as bins become fuller\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (State-Aware)\n    remaining_space = bins_remain_cap - item\n    # Dynamically adjust fragmentation threshold based on the item size and number of bins\n    fragmentation_threshold_multiplier = 0.2 / np.sqrt(num_bins)  #Smaller bins more susceptible to fragmentation\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    # Penalize fragmented bins less as the bins get fuller\n    fragmentation_penalty = 1.0 - average_fill\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage Re-use of Almost Empty Bins (Dynamic Bonus)\n    almost_empty_threshold = 0.05 + (0.05 * average_fill) # More selective for almost empty as bins fill\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size is 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + average_fill * 0.5 #Bigger bonus as bins fill\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration: Add a small amount of randomness, scaled to the item size.\n    exploration_factor = 0.01 * item  # Scale randomness based on the item size\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and adaptive fragmentation penalty.\n    State-aware and balances bin usage with fill efficiency.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n    potential_bins = bins_remain_cap >= item\n\n    # Fill Ratio Preference (Adjusted)\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.3 * (1 - np.mean(bins_remain_cap)))\n\n    # Best Fit Encouragement (Stronger boost)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.0\n\n    # Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.05 * np.mean(bins_remain_cap))\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.3\n\n    # Encourage re-use (Adjusted boost)\n    used_bins = bins_remain_cap < 1.0\n    if np.any(used_bins):\n        priorities[used_bins] += 0.3\n\n    # Fill percentage incentive\n    if np.any(potential_bins):\n        fill_percentage = item / (1 - bins_remain_cap[potential_bins]) if np.any(1-bins_remain_cap[potential_bins] > 0) else np.zeros_like(bins_remain_cap[potential_bins])\n        fill_percentage_filter = (1- bins_remain_cap[potential_bins]) > 0\n        high_fill_bins = fill_percentage > 0.7\n        \n        if np.any(high_fill_bins) and np.any(fill_percentage_filter):\n            eligible_bins_index = np.where(potential_bins)[0][high_fill_bins & fill_percentage_filter]\n            priorities[eligible_bins_index] += 0.5\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and adaptive fragmentation penalty.\n    State-aware and balances bin usage with fill efficiency.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n    potential_bins = bins_remain_cap >= item\n\n    # Fill Ratio Preference (Adjusted)\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.3 * (1 - np.mean(bins_remain_cap)))\n\n    # Best Fit Encouragement (Stronger boost)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.0\n\n    # Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.05 * np.mean(bins_remain_cap))\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.3\n\n    # Encourage re-use (Adjusted boost)\n    used_bins = bins_remain_cap < 1.0\n    if np.any(used_bins):\n        priorities[used_bins] += 0.3\n\n    # Fill percentage incentive\n    if np.any(potential_bins):\n        fill_percentage = item / (1 - bins_remain_cap[potential_bins]) if np.any(1-bins_remain_cap[potential_bins] > 0) else np.zeros_like(bins_remain_cap[potential_bins])\n        fill_percentage_filter = (1- bins_remain_cap[potential_bins]) > 0\n        high_fill_bins = fill_percentage > 0.7\n        \n        if np.any(high_fill_bins) and np.any(fill_percentage_filter):\n            eligible_bins_index = np.where(potential_bins)[0][high_fill_bins & fill_percentage_filter]\n            priorities[eligible_bins_index] += 0.5\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}