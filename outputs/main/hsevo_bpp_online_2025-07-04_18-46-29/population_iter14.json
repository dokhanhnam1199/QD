[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation, and bin-use count adaptively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor)\n\n    # 2. Best Fit\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage almost empty bin usage.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n\n    # 5. Discourage too empty bins after packing.\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n\n    #6. Add small bonus to bins that can accommodate the item (tie breaker).\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += 0.01\n\n    else:\n       priorities[:] = -0.001 # Discourage if no suitable bin\n        \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.068607897885915,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and adaptive fragmentation/waste penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights (based on item size)\n    item_size_factor = min(1.0, item)\n    fill_ratio_weight = 0.6 + 0.2 * item_size_factor\n    best_fit_weight = 1.2 + 0.3 * (1-item_size_factor)\n    fragmentation_penalty_weight = 0.8 + 0.2 * item_size_factor\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] += fill_ratio_weight * (item / bins_remain_cap[potential_bins])\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n    # 4. Encourage utilization, discourage near-full but unusable bins\n    bin_utilization = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    too_full = (bins_remain_cap < item) & (bins_remain_cap > (item - 0.2))\n    priorities[too_full] -= 0.7\n\n    # 5. Slightly empty bin penalty\n    slightly_empty = (bins_remain_cap > item) & (bins_remain_cap < (item + 0.2))\n    priorities[slightly_empty] -= 0.3\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority: Best-fit, target fill, fragmentation, near-empty bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit: Minimize waste. Larger items get higher best-fit score\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + item) # Item size scaling\n\n        # Target fill: Encourage around 80% fill\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty: Discourage near-full bins, scaled by item size\n        near_full_threshold = 0.1\n        near_full = (bins_remain_cap[valid_bins] >= item) & (bins_remain_cap[valid_bins] < (item * (1 + near_full_threshold)))\n        priorities[valid_bins][near_full] -= 1.2 + item  # Item size scaling\n\n        # Encourage near-empty reuse with size condition\n        near_empty_threshold = 0.1\n        near_empty = bins_remain_cap > (1 - item * near_empty_threshold)\n        priorities[near_empty] -= 0.75 * (1-item)\n    else:\n        priorities[:] = -100  # Very low for invalid placements\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and adaptive fragmentation penalty.\n    State-aware and balances bin usage with fill efficiency.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n    potential_bins = bins_remain_cap >= item\n\n    # Fill Ratio Preference (Adjusted)\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.3 * (1 - np.mean(bins_remain_cap)))\n\n    # Best Fit Encouragement (Stronger boost)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.0\n\n    # Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.05 * np.mean(bins_remain_cap))\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.3\n\n    # Encourage re-use (Adjusted boost)\n    used_bins = bins_remain_cap < 1.0\n    if np.any(used_bins):\n        priorities[used_bins] += 0.3\n\n    # Fill percentage incentive\n    if np.any(potential_bins):\n        fill_percentage = item / (1 - bins_remain_cap[potential_bins]) if np.any(1-bins_remain_cap[potential_bins] > 0) else np.zeros_like(bins_remain_cap[potential_bins])\n        fill_percentage_filter = (1- bins_remain_cap[potential_bins]) > 0\n        high_fill_bins = fill_percentage > 0.7\n        \n        if np.any(high_fill_bins) and np.any(fill_percentage_filter):\n            eligible_bins_index = np.where(potential_bins)[0][high_fill_bins & fill_percentage_filter]\n            priorities[eligible_bins_index] += 0.5\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.14240127642603,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, fragmentation penalty, adaptive weighting.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    num_bins = len(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste) * (1 + 0.1 * item) # Adaptive based on item size\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)\n\n        # Fragmentation penalty (discourage near-full bins)\n        fragmentation_threshold = item * 0.15\n        remaining_space = bins_remain_cap - item\n        fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n        fragmentation_penalty = 1.0 + 0.5 * (fragmentation_threshold - remaining_space[fragmented_bins]) / (fragmentation_threshold + 1e-9)\n        priorities[fragmented_bins] -= fragmentation_penalty * (1 + 0.05 * (num_bins / (np.sum(bins_remain_cap) + 1e-9))) # Adaptive penalty\n\n        # Encourage near-empty reuse\n        almost_empty_threshold = 0.9\n        almost_empty = bins_remain_cap > almost_empty_threshold\n        if np.any(almost_empty):\n            almost_empty_bonus = 0.5 + 0.4 * (bins_remain_cap[almost_empty] - almost_empty_threshold) / (1 - almost_empty_threshold + 1e-9)\n            priorities[almost_empty] += almost_empty_bonus\n\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 11.268448344635022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, adaptive fragmentation penalty, and empty bin reuse.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n\n    # Adaptive item size factor (normalized)\n    item_size_factor = min(1.0, item)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.7 + 0.3 * item_size_factor) # Adaptive weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 + 0.5 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.2 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 + 0.2 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.5 + 0.1 * item_size_factor\n        \n    # 5. Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n        priorities[too_empty] -= 0.4 * item_size_factor\n        \n    #6. If no suitable bin, slightly discourage all bins to allow new bin creation\n    if not np.any(potential_bins):\n        priorities[:] -= 0.001\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, adaptive fragmentation penalty, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # 1. Fill Ratio Preference\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += 0.5 * fill_ratio\n\n        # 2. Best Fit Encouragement (Nonlinear)\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 0.6 * np.exp(-remaining_space)\n\n        # 3. Adaptive Fragmentation Penalty\n        max_bin_cap = np.max(bins_remain_cap) if np.any(bins_remain_cap) else 1.0\n        fragmentation_penalty = 0.2 * (remaining_space / max_bin_cap)\n        priorities[eligible_bins] -= fragmentation_penalty\n\n    # 4. Bin Balancing (Encourage use of emptier bins)\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * (1-bin_capacity_normalized)\n\n    # 5. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive priority function balancing fill, waste, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Fill Ratio: Encourage higher fill\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_ratio * 0.5  # Reduced weight\n\n        # Best Fit: Prioritize tightest fit\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-5 * remaining_space) * 0.8 # Adjusted scaling & weight\n\n        # Adaptive Fragmentation Penalty: Avoid small remaining spaces\n        almost_empty_threshold = 0.2 # Increased threshold\n        nearly_empty = (bins_remain_cap[valid_bins] - item > 0) & (bins_remain_cap[valid_bins] - item < almost_empty_threshold)\n        priorities[valid_bins][nearly_empty] -= 2.5  # Reduced penalty\n\n        # Global Fill Level Consideration: Target around 75% fill\n        global_fill = np.sum((1 - bins_remain_cap/1)) / len(bins_remain_cap) # Assuming bin capacity is 1\n        target_fill = 0.75\n        distance_to_target = abs(global_fill - target_fill)\n        # Weight based on how far global fill is from target.  Less penalty if close.\n        priorities[valid_bins] -= distance_to_target * 0.3\n\n    else:\n        # Discourage if no bin fits\n        priorities[:] = -0.001\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty, & reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights\n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    \n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - Adaptive\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight #almost empty reuse bonus.\n\n    # Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 6.122856003191075,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, adaptive fragmentation,\n    and a global bin state consideration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        # Fill ratio component (encourage high fill)\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.4\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n        # Adaptive fragmentation penalty\n        small_fragment_threshold = item * 0.6\n        remaining_after_pack = bins_remain_cap[valid_bins] - item\n        too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n        fragmentation_penalty = 0.7\n        priorities[valid_bins][too_small_remaining] -= fragmentation_penalty\n\n        # Global bin state: encourage using bins when *many* are empty\n        num_almost_empty = np.sum(bins_remain_cap > 0.9)  # Count nearly empty bins\n        if num_almost_empty > bins_remain_cap.size / 2: # if majority of bins are almost empty\n            priorities[valid_bins] += 0.2  # Boost the priority\n\n        # Nonlinearity to prefer slightly tighter fits\n        remaining_after_fit_scale = 5.0\n        remaining_after_fit_weight = 0.2\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n    else:\n        # Discourage placement if no bin fits\n        discourage_placement_value = 0.001\n        priorities[:] = -discourage_placement_value\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]