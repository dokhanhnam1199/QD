[
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive bin packing heuristic combining fill ratio, best fit, and state-aware exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0\n\n    #Adaptive Item Size and Bin Availability\n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n    average_fill = np.mean(1 - bins_remain_cap)\n\n    #Fill Ratio (Weighted)\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n    #Best Fit (Weighted)\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    if np.any(eligible_bins):\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space)\n\n    #Fragmentation Penalty\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold_multiplier = 0.2 / np.sqrt(num_bins)\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor) * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    priorities[fragmented_bins] -= fragmentation_penalty_weight * (1-average_fill)\n\n    #Reuse Almost Empty Bins\n    almost_empty_threshold = 0.95 - (0.1 * average_fill)\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + average_fill * 0.5\n        reuse_weight = 0.6 + 0.4 * bin_availability_factor\n        priorities[almost_empty] += reuse_weight * almost_empty_bonus\n\n    #Bin Utilization\n    utilization = (bin_size - bins_remain_cap) / bin_size\n    fully_utilized_threshold = 0.8\n    highly_utilized = utilization > fully_utilized_threshold\n    utilization_bonus = 0.5\n    priorities[highly_utilized] += utilization_bonus\n\n    #State-Aware Exploration\n    exploration_rate = 0.05 * (1.0 - average_fill)\n    if np.random.rand() < exploration_rate:\n        exploration_bonus = (bin_size - bins_remain_cap) / bin_size\n        priorities += exploration_bonus * 0.2\n\n    # Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n\n    # Underutilization Penalty: Penalize creating almost empty bins with small items\n    new_remaining_space = bins_remain_cap - item\n    underutilization_threshold = 0.1 # Penalty for bins with low utilization after placement\n    underutilization_penalty = 0.6\n    underutilized_bins = (new_remaining_space > 0) & (new_remaining_space / bin_size > (1 - underutilization_threshold)) & (item < (bin_size * 0.5)) #Only penalize if item is small\n    priorities[underutilized_bins] -= underutilization_penalty\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive strategies, global awareness, and refined fragmentation handling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0\n    average_fill = np.mean(1 - bins_remain_cap)\n    \n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n    \n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4 * bin_availability_factor\n\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space)\n\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold_multiplier = 0.2 / np.sqrt(num_bins)\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor) * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight * (1-average_fill)\n\n    almost_empty_threshold = 0.95 - (0.1 * average_fill)\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + average_fill * 0.5\n        priorities[almost_empty] += reuse_weight * almost_empty_bonus\n\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n    \n    # Global Bin Balancing: Encourage filling emptier bins when average fill is high\n    if average_fill > 0.7:\n        empty_bin_bonus = (1-average_fill) * bins_remain_cap\n        priorities += 0.1*empty_bin_bonus # Bonus for packing into more empty bins\n\n    exploration_factor = 0.01 * item * (1-average_fill)\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    new_remaining_space = bins_remain_cap - item\n    underutilization_threshold = 0.1\n    underutilization_penalty = 0.6\n    underutilized_bins = (new_remaining_space > 0) & (new_remaining_space / bin_size > (1 - underutilization_threshold)) & (item < (bin_size * 0.5))\n    priorities[underutilized_bins] -= underutilization_penalty\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 11.547666533705621,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, best fit, frag. penalty with adaptive weights.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0\n\n    # Global State Awareness\n    average_fill = np.mean(1 - bins_remain_cap)\n\n    # Adaptive Weights - based on item size and global fill level\n    item_size_factor = min(0.74, item) # 0.74\n    bin_availability_factor = min(1.27, np.sum(bins_remain_cap >= item) / num_bins) # 1.27\n\n    fill_ratio_weight = 0.07 + 0.09 * item_size_factor #0.07, 0.09\n    best_fit_weight = 2.8 + 0.68 * bin_availability_factor #2.8, 0.68\n    fragmentation_penalty_weight = 1.47 + 0.82 * item_size_factor #1.47, 0.82\n    reuse_weight = 0.79 + 0.51 * bin_availability_factor #0.79, 0.51\n\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - Adaptive\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0008)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        best_fit_priority = np.exp(-2.7 * remaining_space) #2.7\n        priorities[eligible_bins] += best_fit_weight * best_fit_priority\n\n        # Small Item Best Fit Boost\n        if item < 0.2:\n            priorities[eligible_bins] += 0.1 * (1 - remaining_space / (bins_remain_cap[eligible_bins]+0.0008))#0.1\n\n    # Fragmentation Penalty - Dynamic threshold & Item Size Aware\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.45 + 0.04 * item_size_factor) * (0.2 / np.sqrt(num_bins)) #0.45, 0.04, 0.2\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n\n    fragmentation_penalty = fragmentation_penalty_weight * (1-average_fill)\n\n    # Large item penalty\n    if item > 0.8:\n        fragmentation_penalty *= 2.0 #2.0\n\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # Almost empty reuse\n    almost_empty_threshold = 0.93 - (0.2 * average_fill) #0.93, 0.2\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.09 + average_fill * 0.57 #0.09, 0.57\n        priorities[almost_empty] += reuse_weight * almost_empty_bonus\n\n    #Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.42))#0.42\n    priorities[too_full_bins] -= 0.08 #0.08\n\n    # Exploration: Add a small amount of randomness, scaled to the item size.\n    exploration_factor = 0.026 * item #0.026\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 2.2836059034702925,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining fill ratio, best fit, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0\n\n    # Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratio = (bins_remain_cap[potential_bins] - item) / bin_size\n        priorities[potential_bins] += 0.2 * fill_ratio\n\n    # Best Fit Encouragement (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        average_fill = np.mean((bin_size - bins_remain_cap) / bin_size) if num_bins > 0 else 0.0\n        best_fit_weight = 0.8 + (1.0 - average_fill)\n        priorities[best_fit_bins] += best_fit_weight\n\n    # Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    average_remaining = np.mean(bins_remain_cap) if num_bins > 0 else 0.0\n    fragmentation_threshold_multiplier = 0.2 * (1.0 - average_remaining / bin_size)\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    fragmentation_penalty = 0.5 + (item / bin_size)\n    priorities[fragmented_bins] -= 0.7 * fragmentation_penalty\n    \n    # Exploration Bonus (Adaptive probability)\n    exploration_prob = 0.01 * (1 + average_fill)\n    if np.random.rand() < exploration_prob:\n        exploration_bonus = (bin_size - bins_remain_cap) / bin_size\n        priorities += exploration_bonus * 0.05\n\n    # Target fill bonus, adaptive target\n    if np.any(potential_bins):\n        target_fill = 0.7 + 0.1 * average_fill\n        ideal_remaining = bin_size - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[potential_bins] - item) - ideal_remaining)\n        priorities[potential_bins] += 0.3 * np.exp(-distance_to_ideal * 6)\n        \n    #Encourage evening out the fill levels\n    std_fill = np.std(1 - bins_remain_cap)\n    fill_level_penalty = (1 - bins_remain_cap - average_fill) * std_fill * 0.1\n    priorities -= fill_level_penalty * 0.1\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, best fit, bin diversity, and adaptive exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    num_bins = len(bins_remain_cap)\n\n    if np.any(valid_bins):\n        # Fill Ratio with item size influence\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += fill_ratio * 0.6\n\n        # Best Fit with non-linear encouragement\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-4 * remaining_space) * 0.9\n\n        # Bin Diversity Bonus\n        if num_bins > 1:\n            bin_std = np.std(bins_remain_cap)\n            if bin_std > 0.1:\n                priorities[valid_bins] += 0.2\n\n        # Large item encouragement with adaptive threshold\n        if item > 0.7:\n             min_remaining = np.min(bins_remain_cap[valid_bins]-item)\n             tight_fit = (bins_remain_cap[valid_bins] - item) == min_remaining\n             priorities[valid_bins][tight_fit] += 0.5\n\n        # Adaptive exploration\n        exploration_factor = 0.05 * item  # Scale randomness based on item size\n        priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n\n    else:\n        priorities[:] = -0.001\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.028719585161557,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response5.txt_stdout.txt",
    "code_path": "problem_iter23_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining fill ratio, best fit, and bin diversity with global awareness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    num_bins = len(bins_remain_cap)\n\n    # Global fill level calculation\n    total_bin_capacity = num_bins\n    total_items_packed = total_bin_capacity - np.sum(bins_remain_cap)\n    average_fill = total_items_packed / total_bin_capacity if total_bin_capacity > 0 else 0.0\n\n    if np.any(valid_bins):\n        # Adaptive Fill Ratio\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        fill_ratio_weight = 0.6 * (1 - average_fill) # Decrease with higher fill\n        priorities[valid_bins] += fill_ratio * fill_ratio_weight\n\n        # Adaptive Best Fit\n        remaining_space = bins_remain_cap[valid_bins] - item\n        best_fit_weight = 0.9 * (1 + average_fill) # Increase with higher fill\n        priorities[valid_bins] += np.exp(-4 * remaining_space) * best_fit_weight\n\n        # Bin Diversity Bonus (adaptive)\n        if len(bins_remain_cap) > 1:\n            bin_std = np.std(bins_remain_cap)\n            if bin_std > 0.1:\n                diversity_bonus = 0.2 * (1 - average_fill) # Decrease with higher fill\n                priorities[valid_bins] += diversity_bonus\n\n        # Large item encouragement (adaptive)\n        if item > 0.7:\n            min_remaining = np.min(bins_remain_cap[valid_bins] - item)\n            tight_fit = (bins_remain_cap[valid_bins] - item) == min_remaining\n            tight_fit_bonus = 0.5 * (1 + average_fill) # Increase with higher fill\n            priorities[valid_bins][tight_fit] += tight_fit_bonus\n\n        # Fragmentation penalty\n        remaining_space_all = bins_remain_cap - item\n        fragmentation_threshold = 0.3\n        fragmented_bins = (remaining_space_all > 0) & (remaining_space_all < fragmentation_threshold)\n        fragmentation_penalty = 0.1 * average_fill  # Increase with higher fill\n        priorities[fragmented_bins] -= fragmentation_penalty\n        \n        # Over-utilization penalty\n        too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item - 0.4))\n        over_utilization_penalty = 0.05\n        priorities[too_full_bins] -= over_utilization_penalty\n\n    else:\n        priorities[:] = -0.001  # Very low priority if item doesn't fit\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 5.115676106900674,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response6.txt_stdout.txt",
    "code_path": "problem_iter23_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty & reuse, exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    bin_size = 1.0\n    average_fill = np.mean((bin_size - bins_remain_cap) / bin_size) if num_bins > 0 else 0.0\n\n    # Adaptive Fill Ratio\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 1e-6)\n        fill_ratio_weight = 0.7 + 0.1 * item * (1 + average_fill)\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n    # Best Fit with Exponential Decay\n    capacity_diff = bins_remain_cap - item\n    if np.any(eligible_bins):\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        best_fit_weight = 1.5 + 0.5 * (1 - average_fill)\n        priorities[eligible_bins] += best_fit_weight * np.exp(-3 * remaining_space)\n\n    # Adaptive Fragmentation Penalty\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.05 * item)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    fragmentation_penalty = 1.3 + 0.2 * average_fill\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # Reuse Almost Empty Bins\n    almost_empty_threshold = 0.9 - 0.1 * average_fill\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.2\n        priorities[almost_empty] += almost_empty_bonus\n\n    # State-Aware Exploration\n    exploration_probability = 0.05 * (1.0 - average_fill)\n    if np.random.rand() < exploration_probability:\n        exploration_bonus = (bin_size - bins_remain_cap) / bin_size\n        priorities += exploration_bonus * 0.1\n\n    # High fill incentive\n    if np.any(eligible_bins):\n        fill_percentage = item / (bin_size - bins_remain_cap[eligible_bins])\n        high_fill_bins = (fill_percentage > 0.7) & (fill_percentage <= 1.0) # Limit the value of fill_percentage to 1\n\n        if np.any(high_fill_bins):\n            eligible_bins_index = np.where(eligible_bins)[0][high_fill_bins]\n            priorities[eligible_bins_index] += 0.3 # smaller bonus than v1\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 135.02193857199842,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive weights, best fit, fragmentation, reuse, global fill awareness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    average_fill = np.mean(1 - bins_remain_cap)\n    std_fill = np.std(1 - bins_remain_cap)\n    \n    # 1. Adaptive Fill Ratio\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio * (0.7 + 0.3 * (1 - average_fill))\n\n    # 2. Enhanced Best Fit with exponential decay\n    if np.any(eligible_bins):\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 1.5 * np.exp(-2.0 * remaining_space / item)\n\n    # 3. Adaptive Fragmentation Penalty\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.03 * average_fill)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0 * (1+ std_fill)\n\n    # 4. Almost Empty Bonus\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.3\n\n    # 5. Global Fill Level Encouragement\n    global_fill_level = np.sum(1 - bins_remain_cap) / num_bins\n    if global_fill_level > 0.6:\n        exploration_bonus = 0.1 * bins_remain_cap\n        priorities += exploration_bonus\n\n    # 6. Discourage near empty early\n    if global_fill_level < 0.1:\n        near_empty_threshold = 0.95\n        near_empty = bins_remain_cap > near_empty_threshold\n        if np.any(near_empty):\n            priorities[near_empty] -= 0.2\n\n    # 7. State-aware Exploration\n    exploration_factor = 0.05 * item * (1 + std_fill)\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.2580773833266905,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response8.txt_stdout.txt",
    "code_path": "problem_iter23_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_size: float = 1.0) -> np.ndarray:\n    \"\"\"Adaptive heuristic combining fill ratio, best fit, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    average_fill = np.mean(1 - bins_remain_cap / bin_size) if num_bins > 0 else 0.0\n    item_size_factor = min(1.0, item)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # 1. Adaptive Fill Ratio: Encourage higher fill\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += (0.6 + 0.2 * item_size_factor) * fill_ratio\n\n        # 2. Best Fit: Reward tighter fits\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += (0.7 + 0.1 * item_size_factor) * np.exp(-2 * remaining_space)\n\n        # 3. Fragmentation Penalty: Discourage leaving small gaps\n        fragmentation_threshold = 0.2\n        fragmented_bins = remaining_space > 0.001 &(remaining_space <= fragmentation_threshold * item_size_factor)\n        priorities[eligible_bins][fragmented_bins] -= (0.3 + 0.1 * item_size_factor) * (remaining_space[fragmented_bins] / item)\n\n        # 4. Almost Empty Reuse: Prefer near-empty bins\n        almost_empty_threshold = 0.9\n        almost_empty = bins_remain_cap > (almost_empty_threshold * bin_size)\n        priorities[almost_empty] += 0.4  #flat bonus for now.\n\n    else:\n        priorities[:] = -0.001 #small penalty.\n\n    # 5. Exploration: Introduce controlled randomness\n    exploration_factor = 0.01 * item * (1 - average_fill)\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    # 6. Encourage utilization balancing:\n    bin_utilization = 1 - bins_remain_cap / bin_size\n    utilization_std = np.std(bin_utilization)\n    priorities += (1 - utilization_std) * 0.05\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 22, in priority_v2\n    fill_ratio = item / (bins_remain_cap[eligible_bins] + 1e-6)\nTypeError: ufunc 'bitwise_and' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''\n"
  },
  {
    "stdout_filepath": "problem_iter23_response9.txt_stdout.txt",
    "code_path": "problem_iter23_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty, reuse, and exploration, tuned.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    total_bin_capacity = num_bins\n    total_items_packed = total_bin_capacity - np.sum(bins_remain_cap)\n    average_fill = total_items_packed / total_bin_capacity if total_bin_capacity > 0 else 0.0\n    \n    item_size_factor = min(0.75, item)\n    bin_availability_factor = min(1.27, np.sum(bins_remain_cap >= item) / num_bins)\n    \n    fill_ratio_weight = 0.07 + 0.10 * item_size_factor * (1 + average_fill)\n    best_fit_weight = 2.81 + 0.68 * bin_availability_factor * (1 - average_fill)\n    fragmentation_penalty_weight = 1.47 + 0.82 * item_size_factor * (1 + average_fill)\n    reuse_weight = 0.79 + 0.51 * bin_availability_factor * (1 - average_fill)\n\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 1e-6)\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2.73 * remaining_space)\n\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.45 + 0.04 * item_size_factor) * (0.2 / np.sqrt(num_bins))\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight * (1-average_fill)**2\n\n    almost_empty_threshold = 0.93 - (0.20 * average_fill)\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.09 + average_fill * 0.57\n        priorities[almost_empty] += reuse_weight * almost_empty_bonus\n\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.42))\n    priorities[too_full_bins] -= 0.08\n\n    if average_fill > 0.7:\n        empty_bin_bonus = (1-average_fill) * bins_remain_cap\n        priorities += 0.1*empty_bin_bonus\n\n    exploration_factor = 0.026 * item * (1-average_fill)\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    # Stronger Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.5 # Boost best fit\n\n    # Discourage near empty for the first few items.\n    if average_fill < 0.1:\n        near_empty_threshold = 0.95\n        near_empty = bins_remain_cap > near_empty_threshold\n        if np.any(near_empty):\n            priorities[near_empty] -= 0.2 # Reduce near-empty bin priority.\n    \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 85.3111288392501,
    "exec_success": true
  }
]