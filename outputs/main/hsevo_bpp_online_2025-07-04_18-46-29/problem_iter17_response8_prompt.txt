{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty, & reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights\n    item_size_factor = min(1.0, item)\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    \n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - Adaptive\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight #almost empty reuse bonus.\n\n    # Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"A multi-objective priority function for online bin packing, incorporating adaptive weighting and state awareness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Priority (Normalized)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios\n\n    # 2. Best Fit Bonus (Adaptive Weight)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        # Adaptive weight based on fill levels: Higher fill means a greater bonus\n        average_fill = np.mean(1 - bins_remain_cap)  # Average fill level of bins\n        best_fit_weight = 1.0 + (average_fill * 1.5) #Weight increases as bins become fuller\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (State-Aware)\n    remaining_space = bins_remain_cap - item\n    # Dynamically adjust fragmentation threshold based on the item size and number of bins\n    fragmentation_threshold_multiplier = 0.2 / np.sqrt(num_bins)  #Smaller bins more susceptible to fragmentation\n    fragmentation_threshold = item * fragmentation_threshold_multiplier\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    # Penalize fragmented bins less as the bins get fuller\n    fragmentation_penalty = 1.0 - average_fill\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage Re-use of Almost Empty Bins (Dynamic Bonus)\n    almost_empty_threshold = 0.05 + (0.05 * average_fill) # More selective for almost empty as bins fill\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size is 1\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + average_fill * 0.5 #Bigger bonus as bins fill\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Exploration: Add a small amount of randomness, scaled to the item size.\n    exploration_factor = 0.01 * item  # Scale randomness based on the item size\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first heuristic uses carefully tuned constants and an almost-empty bonus with thresholds and weights. The 20th emphasizes fill ratio, best fit, adaptive fragmentation, reuse, and fill percentage incentive.\n(2nd) vs (19th): Heuristic 2 introduces a nonlinear best-fit encouragement and bin balancing, whereas heuristic 19 adjusts fill ratios, best fit, and fragmentation based on average bin capacity and provides fill percentage incentive, and gives stronger boost to best-fit encouragement.\n(3rd) vs (18th): Heuristic 3 uses an adaptive item size factor to adjust fill ratio, best fit, fragmentation penalty, empty bin reuse, and too-empty bin discouragement. Heuristic 18 introduces adaptive weighting based on state awareness, fill ratio priority, best-fit bonus, fragmentation penalty, and exploration randomness.\n(4th) vs (17th): Heuristic 4 adaptively balances fill, waste, and fragmentation and considers global fill levels, while Heuristic 17 uses adaptive weighting and state awareness for fill ratio, best-fit, fragmentation, almost empty reuse and exploration.\n(5th) vs (16th): Heuristic 5 is using adaptive best-fit, target fill and fragmentation penalty, near-empty bonus. The 16th does similar to 5th but without near-empty bonus scaling using remaining capacity.\nComparing (second worst) vs (worst), we see that the second worst (Heuristic 2) uses nonlinear encouragement and bin balancing, and an adaptive fragmentation penalty. The worst (Heuristic 1) relies on a fixed set of parameters.\nOverall: The better heuristics emphasize adaptivity, state awareness, and carefully combine various factors, adjusting weights and thresholds dynamically based on item size, bin availability, and global bin fill levels. The worse performing heuristics rely on static weights and less comprehensive combinations of factors. Better heuristics also appear to incorporate penalties for bins that are too full or likely to cause fragmentation.\n- \nOkay, let's refine \"Current Self-Reflection\" to build better heuristics, avoiding the pitfalls described in \"Ineffective Self-Reflection.\" Here's a focused approach:\n\n*   **Keywords:** Adaptivity, Multi-objective, Penalties/Bonuses, Global State, Parameter Tuning, Incremental Complexity.\n\n*   **Advice:** Design heuristics to adapt dynamically to item sizes, bin states (availability, fill level), and overall packing progress. Combine multiple factors (fill ratio, fragmentation) using weighted functions. Start simple and increase complexity, tracking effects.\n\n*   **Avoid:** Over-reliance on single factors. Unclear objective functions. Abrupt priority shifts. Untested complexity. Local optima traps.\n\n*   **Explanation:** Prioritize a balanced, adaptive approach to bin packing, considering both local bin states and the global packing context. Tune parameters systematically and iteratively validate the effect of new factors.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}