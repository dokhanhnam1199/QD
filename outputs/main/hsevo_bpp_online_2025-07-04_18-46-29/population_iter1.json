[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            priorities[i] = (cap - item) / cap  # Remaining capacity ratio, higher is better\n        else:\n            priorities[i] = -1  # Invalid bins get the lowest priority\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999960679999276 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Encourage filling bins closer to full\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n      priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n\n    # Prioritize bins with smallest remaining capacity that can still fit the item.  This helps with the \"first fit decreasing\" concept if implemented online.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n      min_remaining = np.min(bins_remain_cap[eligible_bins])\n      priorities[bins_remain_cap == min_remaining] += 1\n\n    \n    # Einstein's Special Consideration: A touch of non-linearity to avoid local optima\n    priorities = priorities + np.exp(-np.abs(bins_remain_cap - item))  \n    \n    # Penalize near-full bins heavily to allow more flexibility for the next item, mitigating fragmentation.\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    if np.any(near_full):\n        priorities[near_full] -= 0.5 # A penalty score\n      \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: \"Near Fit\" - Bins with remaining capacity closest to the item size get higher priority.\n    near_fit = np.abs(bins_remain_cap - item)\n    near_fit_priority = -near_fit  # Lower difference means higher priority\n\n    # Heuristic 2: \"Capacity Usage\" - Favor bins that can be filled reasonably well.\n    capacity_usage = item / bins_remain_cap\n    capacity_usage_priority = np.clip(capacity_usage, 0, 1) # Clip to avoid inf/NaN\n\n    # Heuristic 3: Avoid excessive fragmentation. Add a penalty to bins that will have too much space after packing\n    fragmentation_penalty = np.zeros_like(bins_remain_cap)\n    too_much_space_mask = (bins_remain_cap - item) > 0.75  # e.g. More than 75% remaining after packing\n    fragmentation_penalty[too_much_space_mask] = -1.0 # Penalize too much fragmentation\n    cannot_fit = item > bins_remain_cap\n    fragmentation_penalty[cannot_fit] = -np.inf\n\n    # Combine the heuristics\n    priorities = near_fit_priority + 0.5*capacity_usage_priority + fragmentation_penalty # tune the weights\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\n    # i.e. not too empty, and not too tightly fit.\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Prioritize bins that can fit the item reasonably well, but avoid very tight fits or wasted space.\n    # We want bins where the item takes up a significant portion, but also leaves some room for future items.\n\n    fit_ratios = item / bins_remain_cap  # How much of the bin the item would fill\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give a strong preference to bins that can fit the item (fit_ratio <= 1), penalize otherwise.\n    fit_penalty = 10.0  # A penalty value if the bin cannot fit\n    priorities[fit_ratios > 1] = -fit_penalty\n\n    # Among bins that fit, prioritize those where item fills reasonable amount\n    # i.e. not too empty, and not too tightly fit.\n    valid_bins = fit_ratios <= 1\n    if np.any(valid_bins):\n        priorities[valid_bins] = np.exp(-np.abs(fit_ratios[valid_bins] - 0.7)) # gaussian around 0.7\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 10.011966493817322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n      # Score bins that can fit the item higher, inversely proportional to wasted space\n      waste = bins_remain_cap - item\n      priorities[valid_bins] = 1.0 / (waste[valid_bins] + 0.000001) # avoid division by zero\n      # Also consider how full a bin becomes after adding the item. Favor bins\n      # that become relatively fuller, but not too full.\n      fullness = (item + (bins_remain_cap - item)) / 1.0 # assuming bin capacity is 1\n      priorities[valid_bins] += np.clip(fullness[valid_bins],0,1)\n\n\n    else:\n      # No bin can fit the item. Assign a very low priority.\n      priorities = -1e9 * np.ones_like(bins_remain_cap, dtype=float)\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Employs a heuristic that prioritizes bins with sufficient space to\n    minimize fragmentation while avoiding near-full bins to allow future flexibility.\n    It also incorporates a small random component to avoid getting stuck\n    in local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Encourage packing into bins that are large enough but not excessively large.\n            # Penalize bins that are only slightly larger than the item (risk of fragmentation).\n            slack = cap - item\n            if slack < 0.1: #Adjustable parameter for minimal slack (e.g. 10% of bin size). Avoid near-full.\n                priorities[i] = -np.inf # Very low priority, almost impossible\n\n            else:\n                priorities[i] = 1 / (slack + 0.01)  # Prioritize smaller slack\n                priorities[i] += 0.01 * np.random.rand() #Add small random number to encourage exploration\n\n        else:\n            priorities[i] = -np.inf  # Bin is not large enough. Set lowest possible priority.\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999992060000295 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the event horizon and information paradox, we want to balance\n    packing efficiency with preventing overly full bins (approaching singularity).\n    Uses a modified sigmoid function to prioritize bins based on remaining capacity\n    relative to item size, with a preference for bins slightly larger than the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero or negative values by adding a small epsilon.\n    epsilon = 1e-9\n    \n    # Calculate a ratio of item size to remaining bin capacity.\n    ratios = item / (bins_remain_cap + epsilon)\n\n    # Sigmoid-like function to prioritize bins:\n    #   - Near 1: Bin is only slightly larger than the item (high priority).\n    #   - Approaching 0: Bin is much larger than the item (lower priority).\n    #   - > 1: Item doesn't fit (very low priority).\n\n    priorities = 1 / (1 + np.exp(5 * (ratios - 1)))  # Steep sigmoid around ratio = 1.\n\n    # Add a small bonus to bins that *can* accommodate the item, but are not overflowing.\n    can_fit = (bins_remain_cap >= item)\n    priorities[can_fit] += 0.1 * (1 - ratios[can_fit]) #Smaller ratio gives bigger bonus for fitting bin. Ratio has to be smaller than 1.\n\n    # Apply heavy penalization when item doesn't fit\n    cannot_fit = (bins_remain_cap < item)\n    priorities[cannot_fit] -= 10 # Big Penalty\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 149.30195452732352,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates ideas of:\n    1. **First Fit Decreasing (FFD)-ish**: Prioritize bins that can fit the item snugly, but penalize bins that are almost full to avoid fragmentation\n    2. **Best Fit**: Prioritize bins that leave the least wasted space.\n    3. **Bin Level Aware**:  A slight bias towards filling \"more\" empty bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign large negative priority to bins that can't fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Prioritize bins that fit but penalize very full bins\n    feasible_mask = ~infeasible_mask\n\n    if np.any(feasible_mask):\n\n        # Reward \"snug\" fits, calculated by closeness of item to remaining capacity\n        fit_scores = np.exp(-(bins_remain_cap[feasible_mask] - item))\n\n        # Add bonus to \"almost empty\" bins - helps open new bins\n        empty_bin_bonus = bins_remain_cap[feasible_mask]\n\n        # Avoid bins almost full - higher number means lower priority. This should result in more even bin usage\n        almost_full_penalty =  np.exp(10 * (1 - (bins_remain_cap[feasible_mask] / np.max(bins_remain_cap))))\n\n        priorities[feasible_mask] =  fit_scores + 0.1*empty_bin_bonus - almost_full_penalty\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 149.2919824491424,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space.\n    If no bins can fit the item, it assigns the lowest priority to all bins to signal the need for a new bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    if not np.any(eligible_bins):\n        return np.full(bins_remain_cap.shape, -np.inf)  # No bin can fit, signal for new bin\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[~eligible_bins] = np.inf # Penalize ineligible bins to a huge wasted space\n\n    # Prioritize bins with minimal wasted space among the eligible bins.\n    priorities = -wasted_space\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First-Fit Decreasing inspired: prioritize bins where item fits best\n            space_utilization = item / cap\n            waste = cap - item\n\n            #Prioritize full bins if possible.\n            if waste == 0:\n                priorities[i] = 1000 #Max priority to indicate perfect fit\n\n            #Prioritize the almost full ones.\n            elif (waste / cap) < 0.1:\n                priorities[i] = 100\n                \n            # Base priority increases as space utilization increases but penalize wasted space significantly.\n            else:\n                priorities[i] = space_utilization * (1 - (waste / np.sum(bins_remain_cap)))\n\n        else:\n            # Item does not fit: priority = 0.\n            priorities[i] = -100 #Very Low prioirty.\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999211999966 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate waste if item is placed in each bin.  Bins with insufficient capacity get large negative priority\n    waste = bins_remain_cap - item\n    priorities[waste < 0] = -np.inf\n    waste[waste < 0] = np.inf  # Avoid further calculations for invalid bins\n\n    # Prioritize bins with least waste (First Fit heuristic-like)\n    priorities += 1.0 / (waste + 1e-6)  # Adding a small constant to avoid division by zero\n\n    # Prioritize bins where the item fills a significant portion (fraction) of bin capacity.\n    fill_fraction = item / bins_remain_cap\n    priorities += fill_fraction\n\n    # Slightly prioritize bins already containing items (reduces bin fragmentation, improves later packing)\n    # Assuming empty bins have initial remaining capacity (i.e. equal to the bin size).  High remain capacity indicate empty\n    # Prioritization increases as the bin becomes fuller\n    priorities += (1 - bins_remain_cap / np.max(bins_remain_cap)) * 0.5\n\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principle of least action and the warping of spacetime around mass,\n    this priority function prioritizes bins whose remaining capacity is \"close\" to the item size,\n    but also penalizes bins that are too full or too empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # A \"gravitational\" attraction towards bins that can fit the item, stronger when the item\n            # is a significant portion of the remaining capacity, but not too large, to encourage efficiency.\n            # Avoid division by zero\n            if cap == 0:\n                priorities[i] = -np.inf  # Very low priority if bin is full (shouldn't happen).\n            else:\n\n                # Attraction force. stronger as remaining capacity approaches item size.\n                # F = G * m1 * m2 / r^2; G = 1, m1= item, m2 = 1, r = abs(cap-item); or similair forms.\n                # A more damped version avoids huge fluctuations\n                priority = np.exp(-np.abs(cap - item) / item)  # Gaussian-like attraction. Damps differences.\n\n                # Additional reward for bins with utilization not too close to 1 after placement\n\n                new_cap = cap - item\n                new_utilization = 1- (new_cap / 1.0) #Assume a bin of size 1.0;\n\n                #avoid negative capacity\n                if new_cap < 0:\n                    priority = -np.inf\n                else:\n                    priority += 0.0*(new_utilization < 0.95) #slight encouragement\n\n                priorities[i] = priority\n        else:\n            priorities[i] = -np.inf  # Cannot fit. Low priority.\n\n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99999177000063 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the wasted space if the item is placed in the bin.\n    wasted_space = bins_remain_cap - item\n    \n    # High priority for bins where the item fits and minimizes wasted space.\n    # If the item doesn't fit, assign a low priority.\n    \n    fit_mask = wasted_space >= 0\n    \n    if np.any(fit_mask):  # Check if there are bins that can accommodate the item\n        # Rank bins based on how full they would be made *after* adding the item\n        # Higher remaining capacity (lower waste) means a better fit (higher score)\n        \n        #normalized_remain_cap = bins_remain_cap[fit_mask] / bins_remain_cap[fit_mask].max() # Normalize so that large differences don't overshadow\n\n        #priorities[fit_mask] = (1 / (wasted_space[fit_mask] + 0.000001)) # Avoid division by zero\n\n        # Calculate a score based on the fullness of the bin after packing.  A fully packed bin is best.\n        fullness_score = (bins_remain_cap[fit_mask] - wasted_space[fit_mask]) / bins_remain_cap[fit_mask]\n        priorities[fit_mask] = fullness_score\n\n        # Apply a stronger priority to bins that would be close to full\n        # Close-to-full is better than almost empty\n        close_to_full_threshold = 0.9\n        priorities[fit_mask] = priorities[fit_mask] + (fullness_score >= close_to_full_threshold) * 1.5 # Give strong bonus to close-to-full\n            \n    else: # if the item doesn't fit into any of bins\n        priorities = np.full(bins_remain_cap.shape, -np.inf)  # Set very low priority for those bins\n        # Choose bin that's closest in size to current item\n        closest_bin_index = np.argmin(bins_remain_cap)\n        priorities[closest_bin_index] = -1 # Ensure at least one option for packing, give close size higher priority than all others\n        \n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 3.9988033506182825,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that can fit the item closely,\n    but also avoids bins that are too full after packing, creating \"almost full\" bins.\n    It combines several factors:\n    1.  Fit Score:  The closer the item's size is to the bin's remaining capacity, the better.\n    2.  Waste Penalty: Penalizes bins that would leave a significant amount of wasted space.\n    3.  Feasibility: Bins that cannot accommodate the item get a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No bin can fit the item\n\n    # Fit Score (higher is better): How well the item fits in the bin\n    fit_scores = 1 - np.abs(bins_remain_cap - item) / np.max(bins_remain_cap) # Normalize\n\n    # Waste Penalty (lower is better): Discourages leaving too much space.\n    waste = bins_remain_cap - item\n    waste_penalty = np.zeros_like(waste, dtype=float)\n    waste_penalty[waste > 0] = (waste[waste > 0] / np.max(bins_remain_cap))**2 #Squre it to heavily penalize large waste\n\n    # Combine fit and waste for initial priorities (only feasible bins)\n    priorities[feasible_bins] = fit_scores[feasible_bins] - waste_penalty[feasible_bins]\n\n    # Very small negative value if the bin is not feasible, to discourage the use of infeasible bin\n    priorities[~feasible_bins] = -1e9\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Prioritize bins that can fit the item closely (minimize wasted space).\n    # Avoid bins that are too small or would be left with very little space.\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf  # Cannot fit\n        else:\n            wasted_space = capacity - item\n            if wasted_space < 0.1:  # Avoid leaving nearly empty space. This value could be tuned.\n                priorities[i] = -np.inf # Prefer other bins to fill them better\n\n            else:\n                # Prioritize bins where wasted space is relatively small but not trivial\n                # Inverse of wasted space favors tighter fits. Add capacity to favor bins with enough space.\n                priorities[i] = (1 / (wasted_space + 0.001)) + (capacity * 0.1) # added small value for handling wasted space 0\n\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 149.2022337455126,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Higher priority means we want to add the item into that bin first.\n\n    This function considers a combination of factors to determine bin priority:\n    1. Remaining capacity relative to item size. Bins that have remaining\n       capacity close to item size are prioritized to avoid excessive fragmentation.\n    2. Avoid bins that are almost full (to prevent failed placements later).\n    3. If no bin is large enough, give a uniform small negative priority,\n       so that we prefer opening a new bin instead of a random assignment.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the space wasted if the item were added to the bin\n    waste = bins_remain_cap - item\n\n    # Identify bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n\n        # Prioritize bins where waste is minimized\n        priorities[valid_bins] = -np.abs(waste[valid_bins])\n\n        # If some bins are a *very* good fit (waste close to zero), boost those\n        close_fit = np.abs(waste[valid_bins]) < 0.1 * item  # Adjust threshold as needed\n        priorities[valid_bins][close_fit] += 1  # Add a bonus for good fits.  The magnitude here is key to the behaviour\n\n        # Penalize bins that are very full already\n        full_threshold = 0.1 # percentage of bin capacity below which it is considered almost full\n        almost_full = bins_remain_cap < (1 + full_threshold) * item\n        priorities[almost_full] -= 2  # Strong penalty: Opening new bin likely better\n    else:\n        #No bin fits: Small negative priority to discourage assigning to a random one\n        priorities[:] = -0.0001\n\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.13841244515357,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: First-Fit Decreasing variant - Favor bins that can fit the item, with smaller remaining space preferred\n    # Gives a higher score to bins that can accommodate the item without much space left.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        priorities[fit_mask] = (bins_remain_cap[fit_mask] - item)**-1  # Inverse of the wasted space\n\n    # Heuristic 2: Avoid Fragmentation - Penalize bins where item leaves too little space\n    # Penalize if remaining capacity after adding item is below a threshold\n    remaining_after = bins_remain_cap - item\n    too_small_mask = (remaining_after > 0) & (remaining_after < 0.1) # Assuming bin size of 1; scale as necessary\n    priorities[too_small_mask] = -100  # High negative penalty\n\n    # Heuristic 3: Reward filling up more space in the bin.\n    fill_percentage = item / bins_remain_cap\n    priorities += np.clip(fill_percentage * 10, 0, 10) # scale reward to a reasonable range\n\n    #Heuristic 4: Give very small negative penalty if item cannot fit, to avoid overflow errors or undefined behavior\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -1 #ensure this bin is avoided somewhat.\n\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by quantum mechanics: Tunneling Probability and Fermi Level.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Immediate Fit Bonus: Bins where the item *almost* fits perfectly.\n    #   We're seeking minimal wasted space - an attempt to \"fill\" the bin like particles seek lowest energy states.\n    fit_diff = bins_remain_cap - item\n    immediate_fit = np.where(fit_diff >= 0, np.exp(-np.abs(fit_diff) / (item + 1e-9)), 0)  # Exponential decay of priority as wasted space grows\n    priorities += 2.0 * immediate_fit  #Double weighting.\n\n    # 2. \"Tunneling\" Factor: Even if item *doesn't* fit perfectly, bins *close* to fitting get a bonus.\n    #    Think of the item as a quantum particle \"tunneling\" through a small energy barrier (the lack of space).\n    tunneling_potential = np.where(fit_diff < 0, np.exp(fit_diff / (item + 1e-9)), 0) # exp of negative value if item too large\n    priorities += 0.5 * tunneling_potential\n    \n    # 3. Prevent excessive fragmentation:  Bins with a large remaining capacity get *penalized* if the item is relatively small\n    #   This is to avoid leaving very small scraps in many bins, encouraging full or almost full usage.\n    fragmentation_penalty = np.where((bins_remain_cap > 2 * item), - (item / bins_remain_cap)**0.5 , 0) #root to make values less aggressive\n    priorities += fragmentation_penalty\n\n    # 4. \"Fermi Level\" consideration: Bins that are nearly full are \"more desirable\"\n    #    as they represent a \"lower energy state\" for the overall system.\n    #   We want to \"fill\" levels as evenly as possible\n    fermi_level = (bins_remain_cap > 0) * (1 - (bins_remain_cap / np.max(bins_remain_cap))) #normalize cap to [0,1], larger cap equals lower fermi_level\n    priorities += fermi_level\n\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Focus on bins that can accommodate the item.\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        # Prioritize bins that would be fullest after packing (smallest remaining space)\n        priorities[eligible_bins] = 1 / (remaining_space + 1e-9)  # Adding small value to avoid division by zero\n\n        #Boost priority to almost full bins.\n        almost_full_bins = (bins_remain_cap[eligible_bins] - item) < (0.1 * bins_remain_cap[eligible_bins])\n\n        priorities[np.where(eligible_bins)[0][almost_full_bins]] *= 2 #Double the priority\n\n\n    else:\n        #No bin is capable of containing item. Let's give them equal priority so a new bin will be open.\n        priorities = np.ones_like(bins_remain_cap) *0.1\n\n\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities #No valid bin for the item\n\n    # Prioritize bins that have just enough space.\n    diffs = bins_remain_cap - item\n    diffs[diffs < 0 ] = np.inf #Mark invalid bins as infinity distance\n    priorities = -diffs\n    priorities[~possible_bins] = -np.inf\n\n    #Boosting Priorities for Almost Full Bins: Scale remaining capacity\n    almost_full_threshold = 0.1 #Threshold of capacity\n    almost_full_bins = bins_remain_cap <= (1+almost_full_threshold) * item  # Bins where remaining space is little more than the current item's size\n    priorities[almost_full_bins] += 1  # A nudge toward utilizing those spaces more optimally\n\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Large Negative if item doesn't fit\n    priorities[item > bins_remain_cap] = -np.inf\n    \n    # Calculate waste if item is added to each bin\n    waste = bins_remain_cap - item\n    \n    # Prioritize bins with smaller waste, but not zero (avoid full bins unless necessary)\n    priorities[item <= bins_remain_cap] = -np.abs(waste[item <= bins_remain_cap])\n    \n    # Small bonus to bins that get close to full, but not too close to avoid creating small wastes\n    close_to_full = (bins_remain_cap >= item) & (waste <= 0.2 * item) & (waste > 0)\n    priorities[close_to_full] += 0.1\n\n    # Bigger bonus for almost-full bins\n    very_close_to_full = (bins_remain_cap >= item) & (waste <= 0.05 * item) & (waste > 0)\n    priorities[very_close_to_full] += 0.2\n\n    # slight penalty to larger remaining capacities\n    priorities[item <= bins_remain_cap] -= 0.001 * bins_remain_cap[item <= bins_remain_cap]\n\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 16, in priority_v2\n    Array of same size as bins_remain_cap with priority score of each bin.\nOverflowError: cannot convert float infinity to integer\n"
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing a combination of factors to determine bin priority.\n    This function considers the remaining capacity, the wasted space\n    if the item is added to the bin, and a 'gravitational' pull\n    towards bins that are already somewhat full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-9)\n\n    # 1. Capacity Factor: Bins with capacity closer to the item size are preferred.\n    capacity_factor = np.exp(-np.abs(bins_remain_cap - item) / item)\n\n    # 2. Waste Factor: Minimize wasted space.  Heavily penalize bins that leave large gaps.\n    waste = bins_remain_cap - item\n    waste_factor = np.where(waste >= 0, np.exp(-waste / item), 0)  # Penalize positive waste, zero out negative waste (item too big)\n\n    # 3. Fullness Factor: 'Gravitational' pull towards bins that are already somewhat full.\n    fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fullness (0 to 1)\n    fullness_factor = np.power(fullness, 2) # increased nonlinearity\n    fullness_factor = np.nan_to_num(fullness_factor, nan=0.0)  #avoid NAN when all bins_remain_cap are zero.\n\n\n    # Combine the factors with appropriate weights.\n    priorities = 0.5 * capacity_factor + 0.4 * waste_factor + 0.1 * fullness_factor\n\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers the wasted space more explicitly, penalizing bins\n    that would have a large amount of remaining space after the item is added.\n    Also adds a boost for bins that have capacity close to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is feasible only if its remaining capacity is >= item size.\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # If no bin can fit the item, return very low priority for all bins.\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate remaining capacity after adding item, only for feasible bins.\n    remaining_after = bins_remain_cap[feasible_bins] - item\n\n    # Penalty for large remaining capacity (discourages excessive waste).\n    waste_penalty = -remaining_after\n\n    # Boost for bins whose capacity is close to the item size (encourages efficient packing).\n    size_diff = np.abs(bins_remain_cap[feasible_bins] - item)\n    proximity_boost = -size_diff # Smaller diff is better\n\n    # Combine waste penalty and proximity boost for feasible bins.\n    priorities[feasible_bins] = proximity_boost + waste_penalty\n\n    # Set very low priority for infeasible bins.\n    priorities[~feasible_bins] = -np.inf\n\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Immediate Fit: Highest priority for bins that can fit perfectly.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # High priority for perfect fit\n\n    # Next Fit Heuristic: If the last used bin can fit, give it a high priority.\n    # This encourages using the same bin repeatedly when possible.\n    if len(bins_remain_cap) > 0 and bins_remain_cap[0] >= item and not perfect_fit[0]:\n        priorities[0] = 500\n\n    # First Fit Decreasing (modified): Prioritize bins with enough space, but not too much\n    # Avoids leaving very small spaces.  Balances bin utilization.\n\n    enough_space = bins_remain_cap >= item\n    small_space_left = bins_remain_cap - item < 0.1  # Arbitrary small value relative to bin size\n\n    priorities[enough_space & ~perfect_fit] = (bins_remain_cap[enough_space & ~perfect_fit] - item) / np.max(bins_remain_cap)\n    priorities[enough_space & ~perfect_fit] = 1 - priorities[enough_space & ~perfect_fit] #Higher score given to those that are less empty after insertion\n\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item relatively closely,\n    but also discourages using almost empty bins if others are available.\n    It incorporates both a capacity fit score and a residual capacity penalty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Capacity fit score: Higher if the item fits relatively snugly\n    fit_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n    fit_scores[can_fit] = (bins_remain_cap[can_fit] - item) / bins_remain_cap[can_fit]\n    fit_scores = 1 - fit_scores\n    fit_scores[~can_fit] = -1  # Assign negative score if item doesn't fit\n\n    # Residual capacity penalty: Lower if bin is mostly empty after adding item.\n\n    residual_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    bins_after_fit = bins_remain_cap - item\n    residual_penalty[can_fit] = np.abs(bins_after_fit[can_fit] / bins_remain_cap[can_fit])\n\n\n    # Combine fit score and residual capacity penalty\n    # Give fit a higher importance by scaling the penalty to have a minimal impact if the item does not fit.\n    priorities = fit_scores - 0.1*residual_penalty\n\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Heuristic considers both remaining capacity and how full the bin will be after adding the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Prioritize bins that fit the item.\n            fill_ratio = item / cap  # ratio of item size to remaining capacity\n            future_fill = (cap - item) / cap  # remaining cap after insertion\n\n            # The higher the fill_ratio, and the lower the future fill, the better\n            priorities[i] = (1 - future_fill) - (fill_ratio*0.5)  # Balance near-full vs. almost empty (weighting fill_ratio to penalize large empty space)\n            if cap - item < 0.1:\n                priorities[i]+= 0.1 # slightly prioritise almost full bins\n        else:\n            priorities[i] = -1000  # Very low priority if the item doesn't fit. Make it way worse than any possible score from available capacity\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics:\n    1.  Avoid bins that are too full (or will be too full) using a sigmoid function.\n    2.  Prefer bins that have space close to the item size (first-fit-decreasing heuristic inspired).\n    3.  Prioritize bins that are almost full after adding the item, but not overfull. This encourages bin completion.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Sigmoid function to penalize bins that are close to full.  Avoids excessive fragmentation.\n    sigmoid = 1 / (1 + np.exp(10 * (item - bins_remain_cap))) # Sharp sigmoid around item = remaining capacity\n\n    # Prioritize bins whose remaining capacity is close to the item size, but don't allow negatives\n    capacity_difference = np.maximum(0, 1 - np.abs(bins_remain_cap - item) / np.max([1e-6, np.mean(bins_remain_cap)])) # Avoid div by 0\n\n    # Boost priority for bins that become nearly full after packing the item.  Prioritize near-completion, not overflow.\n    completion_bonus = np.where((bins_remain_cap - item >= 0), np.exp(-10*(bins_remain_cap - item)), -np.inf)  # Heavily penalize overflow\n\n    priorities = sigmoid + 0.5 * capacity_difference + completion_bonus # Combine the heuristics.\n\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: If the item doesn't fit, priority is -inf\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n\n    # 2. First Fit Decreasing-ish: Prioritize bins that are \"just big enough\".\n    #    We want to fill bins as much as possible to avoid fragmentation.\n    #    Use an exponential decay to heavily penalize larger bins.\n    feasible = ~infeasible\n    remaining_after_fit = bins_remain_cap[feasible] - item\n    priorities[feasible] = np.exp(-10 * remaining_after_fit / item)\n\n    # 3. Avoid Very Empty Bins (Except when necessary)\n    # If almost empty and item does not fill to over certain value, penalize.\n    almost_empty = bins_remain_cap > 0.9\n    will_not_fill = bins_remain_cap - item > 0.1\n    priorities[almost_empty & will_not_fill] -= 0.1 # small penalty\n\n    # 4. Give a tiny nudge for the fullest bin to break ties.\n    # This is like a 'best fit' tiebreaker\n    if np.any(feasible): # Only if there ARE feasible bins...\n        best_fit_idx = np.argmax(bins_remain_cap[feasible] - item)\n        indices = np.where(feasible)[0] # Get indices that are True\n        priorities[indices[best_fit_idx]] += 0.001 # very small bonus\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.497407259672929,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(eligible_bins):\n        # Focus on bins where the item *can* fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        \n        # Heuristic 1: Try to fill bins as much as possible (minimize remaining space)\n        #remaining_space_priority = 1 / (remaining_space + 1e-9) # Avoid division by zero, prioritize small remaining space\n\n        # Heuristic 2: Use Best-Fit Decreasing strategy. Select bin that minimizes the wasted space,\n        #but scaled by available bin size. Gives higher score to a better fit in a bigger bin, which should prevent\n        #overfilling the small ones.\n        remaining_space_priority = (bins_remain_cap[eligible_bins] - item) / bins_remain_cap[eligible_bins] \n        remaining_space_priority = 1 - remaining_space_priority  #Higher values mean less wasted space\n        \n        priorities[eligible_bins] = remaining_space_priority\n\n    else:\n        # No bin can fit. Give a slightly increasing score based on remaining capacity.\n        # This is a fallback so that we choose bin with slightly larger size. \n        # Prioritize bins with larger remaining capacity to avoid overly concentrating on small bins when new bins cannot be allocated.\n        priorities = bins_remain_cap #Prioritize the bin with the most remaining capacity\n    \n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins with sufficient remaining capacity, favoring those with slightly larger capacity than the item size\n    to reduce fragmentation. Avoids bins where the item nearly fills the bin.\n    Uses a combination of remaining capacity and a \"near-fit\" bonus/penalty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Capacity check: Disqualify bins that cannot fit the item.\n    eligible_bins = bins_remain_cap >= item\n\n    # Base priority: Remaining capacity (higher capacity generally preferred, within reason)\n    priorities[eligible_bins] = bins_remain_cap[eligible_bins]\n\n    # Near-fit bonus/penalty: Encourages good fits, discourages almost-full fits\n    near_fit_threshold_upper = item * 1.2  # slightly larger\n    near_fit_threshold_lower = item * 1.05 # avoid packing if only marginally bigger\n\n    near_fit_bins = (bins_remain_cap >= item) & (bins_remain_cap <= near_fit_threshold_upper) & (bins_remain_cap >= near_fit_threshold_lower)\n\n    nearly_full_bins = (bins_remain_cap >= item) & (bins_remain_cap < item * 1.05)\n\n    priorities[near_fit_bins] += bins_remain_cap[near_fit_bins] #give bonus for near fit.\n    priorities[nearly_full_bins] -= (item * 2)  # penalty if item nearly fills bin (creates fragmentation)\n\n    #Very large capacities are not good either. They are penalized.\n\n    large_cap_bins = bins_remain_cap > item * 2\n    priorities[large_cap_bins] -= bins_remain_cap[large_cap_bins] * 0.1\n\n    # If no bins can fit, return a low-priority score for all (should not happen in normal usage)\n    if not np.any(eligible_bins):\n        priorities[:] = -1e9  # Extremely low priority for all if item cannot fit in any bin\n\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 60.62026326286399,
    "exec_success": true
  }
]