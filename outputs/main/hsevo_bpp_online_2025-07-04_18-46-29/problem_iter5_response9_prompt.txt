{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid priority: balances wasted space, fullness, and fit.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap - item\n        priorities[valid_bins] = -np.abs(waste[valid_bins]) # Favors minimal waste\n\n        close_fit = np.abs(waste[valid_bins]) < close_fit_threshold * item\n        priorities[valid_bins][close_fit] += 1 # Bonus for very good fit\n\n        almost_full = bins_remain_cap < (1 + almost_full_threshold) * item\n        priorities[almost_full] -= almost_full_penalty # Penalty for nearly full\n\n        # First Fit Decreasing - ish component to avoid fragmentation\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_exponent_scale #Scale impact.\n    else:\n        priorities[:] = -discourage_random_placement_value # Discourage random placement\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines sigmoid-based bin fullness, capacity difference, and filling level.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility (same as v1)\n    infeasible = item > bins_remain_cap\n    priorities[infeasible] = -np.inf\n    feasible = ~infeasible\n\n    # 2. Sigmoid for bin fullness (similar to v0, but applied only to feasible bins)\n    sigmoid = np.zeros_like(bins_remain_cap, dtype=float)\n    sigmoid[feasible] = 1 / (1 + np.exp(10 * (item - bins_remain_cap[feasible])))\n\n    # 3. Capacity difference, focusing on feasible bins (similar to v0)\n    capacity_difference = np.zeros_like(bins_remain_cap, dtype=float)\n    if np.any(feasible):\n        capacity_difference[feasible] = np.maximum(0, 1 - np.abs(bins_remain_cap[feasible] - item) / np.max([1e-6, np.mean(bins_remain_cap[feasible])]))\n\n    # 4. Completion bonus, applied to only feasible bins (similar to v0)\n    completion_bonus = np.zeros_like(bins_remain_cap, dtype=float)\n    completion_bonus[feasible] = np.where((bins_remain_cap[feasible] - item >= 0), np.exp(-10 * (bins_remain_cap[feasible] - item)), -np.inf)\n\n    # Combine, adjusting weights based on what was learned in analysis\n    priorities = sigmoid + 0.6 * capacity_difference + 0.8 * completion_bonus\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic prioritizes filling bins closer to full while also considering the smallest remaining capacity. The worst heuristic uses a combination of fit scores, empty bin bonuses, almost full penalties, and tight fit bonuses. The best heuristic includes `np.exp(-np.abs(bins_remain_cap - item))` which provides a smooth, non-linear adjustment to priorities, and also penalizes near-full bins. In contrast, the worst heuristic includes an `almost_full_penalty` and `tight_fit_bonus`.\n\nComparing (2nd) vs (19th), the second best uses `waste` and `close_fit`, and it has the First Fit Decreasing component. The second worst combines best-fit and target fill ratio to prioritize bins. The second best gives bonuses for very good fit. The second worst penalizes the almost full bins.\n\nComparing (1st) vs (2nd), we observe that the best heuristic uses `bins_remain_cap >= item` multiple times. The second best gives bonus for close fit and applies penalty for nearly full. The best use `potential_bins = bins_remain_cap >= item` to filter before applying calculation.\n\nComparing (3rd) vs (4th), the only difference is that the (3rd) uses default arguments for parameters, so there is no significant difference in the algorithm.\n\nComparing (second worst) vs (worst), we see that the second worst prioritizes best fit, incorporating a target fill ratio. The worst combines fit scores, bonuses, and penalties, but the specific combination is not as effective. The key difference lies in the combination of features and the underlying weighting, where the second-worst places higher emphasis on the fill ratio.\n\nOverall:\nThe best heuristics prioritize a balance between minimizing waste, encouraging fuller bins, and penalizing near-full bins to avoid fragmentation. They also incorporate smooth, non-linear adjustments. The worst heuristics tend to have less effective combinations of bonuses and penalties, or lack a clear strategy for balancing different objectives.\n- \nOkay, let's refine \"Current self-reflection\" into a more effective approach for designing heuristics. Here's a breakdown designed to avoid the pitfalls of ineffective self-reflection and guide you towards better heuristics:\n\n*   **Keywords:** Objective Function, Multi-Criteria Optimization, Smoothing, Exploration, Penalties, State Evaluation, Adaptive Strategies.\n\n*   **Advice:** Design a well-defined objective function considering multiple interacting criteria. Employ smoothing techniques (e.g., sigmoid functions) for gradual adjustments. Use adaptive penalties.\n\n*   **Avoid:** Rigid, single-factor decision-making. Static weight assignments in objective function, lack of adaptive strategies based on previous state evaluation.\n\n*   **Explanation:** Effective heuristics require a holistic view. Instead of fixating on one aspect, build an objective function that balances multiple goals. Employ adaptive strategies based on previous results to guide exploration and dynamically adjust penalties/weights.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}