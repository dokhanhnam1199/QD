{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_size: float = 1.0) -> np.ndarray:\n    \"\"\"Combines adaptive fill ratio, best fit, frag. penalty & reuse, exploration with dynamic adjustments and lookahead.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # --- 1. Adaptive Weights (Item Size & Bin Availability) ---\n    item_size_factor = min(0.75, item)  # Capping item size factor\n    bin_availability_factor = min(1.27, np.sum(bins_remain_cap >= item) / (num_bins + 1e-6))  # Smooth availability factor\n\n    fill_ratio_weight = 0.07 + 0.1 * item_size_factor\n    best_fit_weight = 2.8 + 0.7 * bin_availability_factor\n    fragmentation_penalty_weight = 1.5 + 0.8 * item_size_factor\n    reuse_weight = 0.8 + 0.5 * bin_availability_factor\n\n    # --- 2. Fill Ratio (Eligible Bins) ---\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.001)  # Avoid division by zero\n        priorities[eligible_bins] += fill_ratio_weight * fill_ratio\n\n        # Best Fit - Exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += best_fit_weight * np.exp(-2.7 * remaining_space)\n\n    # --- 3. Fragmentation Penalty (Dynamic Threshold) ---\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * (0.45 + 0.04 * item_size_factor) * (0.2 / np.sqrt(num_bins + 1e-6))\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n\n    # Scale penalty based on fill level and item size\n    bin_fill_level = (bin_size - bins_remain_cap[fragmented_bins]) / bin_size\n    fragmentation_penalty_scaling = bin_fill_level * item_size_factor\n    priorities[fragmented_bins] -= fragmentation_penalty_weight * fragmentation_penalty_scaling\n\n    # --- 4. Almost Empty Reuse ---\n    average_fill = np.mean(1 - bins_remain_cap / bin_size)\n    almost_empty_threshold = 0.93 - (0.2 * average_fill)\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.09 + average_fill * 0.6\n        priorities[almost_empty] += reuse_weight * almost_empty_bonus\n\n    # --- 5. Too Full Penalty ---\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item - 0.42))\n    priorities[too_full_bins] -= 0.08\n\n    # --- 6. Exploration (Scaled Randomness) ---\n    exploration_factor = 0.026 * item\n    priorities += np.random.uniform(-exploration_factor, exploration_factor, size=num_bins)\n\n    # --- 7. Encourage Even Utilization (with stronger weighting) ---\n    bin_utilization = 1 - bins_remain_cap / bin_size\n    utilization_std = np.std(bin_utilization)\n    priorities += (1 - utilization_std) * 0.2  # Doubled the bonus\n\n    # --- 8. Lookahead (Simulated Placement) ---\n    # Penalize bins that, after placing the current item, would become difficult to fill later.\n    simulated_remaining_caps = bins_remain_cap - item\n    simulated_remaining_caps[simulated_remaining_caps < 0] = -1 # Mark that the item can't be added\n\n    small_space_penalty_threshold = 0.15 #bins with remaining capacity less than this gets penalized\n    difficult_to_fill = (simulated_remaining_caps > 0) & (simulated_remaining_caps <= small_space_penalty_threshold)\n\n    # Scale penalty by how much space is wasted and the size of the item\n    waste_amount = small_space_penalty_threshold - simulated_remaining_caps[difficult_to_fill]\n    waste_penalty = waste_amount/ small_space_penalty_threshold\n\n    priorities[difficult_to_fill] -= 0.05 * waste_penalty * item_size_factor\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}