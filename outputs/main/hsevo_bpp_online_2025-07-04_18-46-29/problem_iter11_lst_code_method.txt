{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Encourage filling bins closer to full\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n      priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n\n    # Prioritize bins with smallest remaining capacity that can still fit the item.  This helps with the \"first fit decreasing\" concept if implemented online.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n      min_remaining = np.min(bins_remain_cap[eligible_bins])\n      priorities[bins_remain_cap == min_remaining] += 1\n\n    \n    # Einstein's Special Consideration: A touch of non-linearity to avoid local optima\n    priorities = priorities + np.exp(-np.abs(bins_remain_cap - item))  \n    \n    # Penalize near-full bins heavily to allow more flexibility for the next item, mitigating fragmentation.\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    if np.any(near_full):\n        priorities[near_full] -= 0.5 # A penalty score\n      \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Encourage filling bins closer to full\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n      priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n\n    # Prioritize bins with smallest remaining capacity that can still fit the item.  This helps with the \"first fit decreasing\" concept if implemented online.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n      min_remaining = np.min(bins_remain_cap[eligible_bins])\n      priorities[bins_remain_cap == min_remaining] += 1\n\n    \n    # Einstein's Special Consideration: A touch of non-linearity to avoid local optima\n    priorities = priorities + np.exp(-np.abs(bins_remain_cap - item))  \n    \n    # Penalize near-full bins heavily to allow more flexibility for the next item, mitigating fragmentation.\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    if np.any(near_full):\n        priorities[near_full] -= 0.5 # A penalty score\n      \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fullest bin, near fit bonus, and dynamic fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fullest Bin: Prioritize smallest remaining space\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = 1 / (remaining_space + 1e-9)\n\n        # Near Fit bonus: Reward bins slightly larger than item\n        near_fit_threshold_upper = item * 1.2\n        near_fit_bins = (bins_remain_cap >= item) & (bins_remain_cap <= near_fit_threshold_upper)\n        priorities[near_fit_bins] += 0.5 * priorities[near_fit_bins]\n\n        # Adaptive Fragmentation Penalty: Penalize almost-full bins\n        near_full_threshold = 0.95\n        near_full = (bins_remain_cap >= item) & (bins_remain_cap - item <= (1 - near_full_threshold) * bins_remain_cap)\n        if np.any(near_full):\n            priorities[near_full] -= 1 / (1 + np.exp(-100*(bins_remain_cap[near_full] - item - (1 - near_full_threshold) * bins_remain_cap[near_full])))\n    else:\n        priorities[:] = -1  # Item doesn't fit\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. First Fit Preference with a slight bias for bins that are already somewhat full.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] = 1 / (bins_remain_cap[potential_bins] + 0.0001) # Avoid division by zero\n\n    # 2. Best Fit Encouragement: Reward bins with remaining capacity closest to the item size.\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2 # Give a higher priority to best fit\n\n    # 3. Fragmentation Penalty: Discourage placing items in bins that leave small remaining space.\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2  # Adjust this threshold as needed.  Penalize if remaining capacity < 20% item size\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.5 # Strong penalty to avoid small fragments\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.8\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill optimization with adaptive penalties.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        close_fit_threshold = 0.1\n        close_fit = np.abs(waste) < close_fit_threshold * item\n        priorities[valid_bins][close_fit] += 1\n\n        almost_full_threshold = 0.1\n        almost_full_penalty = 2.79\n        almost_full = bins_remain_cap[valid_bins] < (1 + almost_full_threshold) * item\n        priorities[valid_bins][almost_full] -= almost_full_penalty\n\n        remaining_after_fit_scale = 6.44\n        remaining_after_fit_weight = 0.25\n\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.39\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n    else:\n        discourage_placement_value = 0.0008\n        priorities[:] = -discourage_placement_value\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill optimization with adaptive penalties.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        close_fit_threshold = 0.1\n        close_fit = np.abs(waste) < close_fit_threshold * item\n        priorities[valid_bins][close_fit] += 1\n\n        almost_full_threshold = 0.1\n        almost_full_penalty = 2.79\n        almost_full = bins_remain_cap[valid_bins] < (1 + almost_full_threshold) * item\n        priorities[valid_bins][almost_full] -= almost_full_penalty\n\n        remaining_after_fit_scale = 6.44\n        remaining_after_fit_weight = 0.25\n\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.39\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n    else:\n        discourage_placement_value = 0.0008\n        priorities[:] = -discourage_placement_value\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. First Fit Preference: Add a base preference for the first bin that fits. This encourages initial packing.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        first_fit_index = np.argmax(potential_bins) # Finds the index of the first True value\n        priorities[first_fit_index] += 0.75\n\n\n    # 2. Best Fit Encouragement: Prioritize bins that are close to the item size, reducing fragmentation.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        diffs = bins_remain_cap[eligible_bins] - item\n        best_fit_index = np.argmin(diffs)\n        indices = np.where(eligible_bins)[0]\n        priorities[indices[best_fit_index]] += 1.0\n\n\n    # 3. Capacity Utilization: Reward bins that will be filled significantly by adding the item.  Avoid bins that will be left with tiny slivers.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        fill_ratios = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratios * 0.5  # Scale the reward\n\n    # 4. Avoidance of Small Remaining Space: Heavily penalize bins that will be left with very little space after adding the item.\n    remaining_space = bins_remain_cap - item\n    nearly_empty = (remaining_space > 0) & (remaining_space < 0.1)  # e.g., less than 10% remaining\n    priorities[nearly_empty] -= 2.0 # High penalty\n\n\n    # 5. Moderate penalty for almost full bins.\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap < item * 1.2)\n    if np.any(almost_full):\n        priorities[almost_full] -= 0.2\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. First Fit Preference with a slight bias for bins that are already somewhat full.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] = 1 / (bins_remain_cap[potential_bins] + 0.0001) # Avoid division by zero\n\n    # 2. Best Fit Encouragement: Reward bins with remaining capacity closest to the item size.\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2 # Give a higher priority to best fit\n\n    # 3. Fragmentation Penalty: Discourage placing items in bins that leave small remaining space.\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2  # Adjust this threshold as needed.  Penalize if remaining capacity < 20% item size\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.5 # Strong penalty to avoid small fragments\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.8\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. First Fit Preference with a slight bias for bins that are already somewhat full.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] = 1 / (bins_remain_cap[potential_bins] + 0.0001) # Avoid division by zero\n\n    # 2. Best Fit Encouragement: Reward bins with remaining capacity closest to the item size.\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2 # Give a higher priority to best fit\n\n    # 3. Fragmentation Penalty: Discourage placing items in bins that leave small remaining space.\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2  # Adjust this threshold as needed.  Penalize if remaining capacity < 20% item size\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.5 # Strong penalty to avoid small fragments\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.8\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining fill ratio, best fit, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio\n\n        # Best Fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-remaining_space)\n\n    # Bin Balancing\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*bin_capacity_normalized\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining fill ratio, best fit, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio\n\n        # Best Fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-remaining_space)\n\n    # Bin Balancing\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*bin_capacity_normalized\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining fill ratio, best fit, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio\n\n        # Best Fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-remaining_space)\n\n    # Bin Balancing\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*bin_capacity_normalized\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining fill ratio, best fit, and bin balancing.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio\n\n        # Best Fit\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-remaining_space)\n\n    # Bin Balancing\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1*bin_capacity_normalized\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Primary Objective: Maximize bin utilization\n    # Encourage filling bins as much as possible *without* overfilling.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        # Higher score for bins that leave less waste after packing.\n        priorities[potential_bins] = 1 - (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n\n    # 2. Adaptive Penalty: Fragmentation Mitigation\n    # Penalize bins that, after packing, leave a remaining capacity smaller than a threshold.\n    # This threshold is dynamically adjusted based on the average item size.\n    avg_item_size = item # assuming a single item.  If multiple items were considered, this should be the average size\n    small_fragment_threshold = avg_item_size * 0.5  # Adjust this factor as needed\n\n    remaining_after_pack = bins_remain_cap - item\n    too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n    if np.any(too_small_remaining):\n        priorities[too_small_remaining] -= 0.75  # Strong penalty for creating small fragments\n\n    # 3. Exploration Bonus: Occasionally try less-optimal bins\n    # Introduce a small probability of prioritizing a less-full bin to avoid local optima.\n    # This is done by adding a tiny random value to all priorities.  Adjust probability as needed.\n    if np.random.rand() < 0.05:\n        priorities += np.random.rand(len(bins_remain_cap)) * 0.1\n\n    # 4. Prioritize bins that are already reasonably full. Helps close them quickly\n    reasonably_full = (bins_remain_cap > item) & (bins_remain_cap < item * 2)  # Adjust as needed\n    if np.any(reasonably_full):\n        priorities[reasonably_full] += 0.25\n\n    # 5. First fit tiebreaker.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        first_eligible_index = np.argmax(eligible_bins) # Select the index of the first true value\n        priorities[first_eligible_index] += 0.01\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, target fill, and residual capacity with adaptive penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Best Fit component\n        remaining_space = bins_remain_cap[can_fit] - item\n        fit_scores = 1 / (remaining_space + 1e-9)\n\n        # Target fill ratio component (around 70%)\n        fit_ratios = item / bins_remain_cap[can_fit]\n        target_priority = np.exp(-np.abs(fit_ratios - 0.7))\n\n        # Residual Capacity Penalty: Avoid leaving tiny spaces\n        residual_penalty = np.abs(remaining_space / bins_remain_cap[can_fit])\n\n        # Capacity weights\n        capacity_weights = bins_remain_cap[can_fit]/np.max(bins_remain_cap)\n        \n        # Combined score with capacity weights for balancing\n        combined_priority = (capacity_weights * fit_scores + (1 - capacity_weights) * target_priority) - 0.1*residual_penalty\n\n        #Adaptive Penalty for bin utilization > 90%\n        bin_utilization = 1 - bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        adaptive_penalty = np.exp(5 * (bin_utilization - 0.9))\n        combined_priority -= adaptive_penalty\n\n        priorities[can_fit] = combined_priority\n    else:\n        # Prioritize larger bins when no fit exists\n        priorities = bins_remain_cap\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, target fill, and residual capacity with adaptive penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Best Fit component\n        remaining_space = bins_remain_cap[can_fit] - item\n        fit_scores = 1 / (remaining_space + 1e-9)\n\n        # Target fill ratio component (around 70%)\n        fit_ratios = item / bins_remain_cap[can_fit]\n        target_priority = np.exp(-np.abs(fit_ratios - 0.7))\n\n        # Residual Capacity Penalty: Avoid leaving tiny spaces\n        residual_penalty = np.abs(remaining_space / bins_remain_cap[can_fit])\n\n        # Capacity weights\n        capacity_weights = bins_remain_cap[can_fit]/np.max(bins_remain_cap)\n        \n        # Combined score with capacity weights for balancing\n        combined_priority = (capacity_weights * fit_scores + (1 - capacity_weights) * target_priority) - 0.1*residual_penalty\n\n        #Adaptive Penalty for bin utilization > 90%\n        bin_utilization = 1 - bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        adaptive_penalty = np.exp(5 * (bin_utilization - 0.9))\n        combined_priority -= adaptive_penalty\n\n        priorities[can_fit] = combined_priority\n    else:\n        # Prioritize larger bins when no fit exists\n        priorities = bins_remain_cap\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins balancing waste, fullness, and fit.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste) # Favors minimal waste\n\n        close_fit_threshold = 0.1\n        close_fit = np.abs(waste) < close_fit_threshold * item\n        priorities[valid_bins][close_fit] += 1  # Bonus for very good fit\n\n        almost_full_threshold = 0.1\n        almost_full_penalty = 10\n        almost_full = bins_remain_cap < (1 + almost_full_threshold) * item\n        priorities[almost_full] -= almost_full_penalty # Penalty for nearly full\n\n        sigmoid = 1 / (1 + np.exp(10 * (item - bins_remain_cap)))\n        priorities += 0.5 * sigmoid\n    else:\n        discourage_random_placement_value = 100\n        priorities[:] = -discourage_random_placement_value\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit with adaptive waste penalty and target fill.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        remaining_space = bins_remain_cap[can_fit] - item\n        # Best Fit: prioritize smaller remaining space\n        fit_scores = 1 / (remaining_space + 1e-9)\n\n        # Adaptive Waste Penalty: Larger penalty for bigger waste relative to item size\n        waste_ratio = remaining_space / item\n        waste_penalty = np.exp( -waste_ratio)\n\n        # Target fill ratio component (around 70%)\n        fit_ratios = item / bins_remain_cap[can_fit]\n        target_priority = np.exp(-np.abs(fit_ratios - 0.7))\n        priorities[can_fit] = fit_scores - 0.5*waste_penalty + 0.3*target_priority\n\n    else:\n        # Prioritize larger bins when no fit exists\n        priorities[:] = bins_remain_cap\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Encourage filling bins closer to full, scaled by item size.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n      priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins] * item\n\n    # Prioritize bins with smallest remaining capacity that can still fit the item.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n      min_remaining = np.min(bins_remain_cap[eligible_bins])\n      priorities[bins_remain_cap == min_remaining] += 1.5 # slightly increased priority for smallest\n\n    # Add a bonus for bins that would be filled to a \"good\" level. Target is 80% full.\n    target_fill = 0.8\n    ideal_remaining = 1 - target_fill # Assuming bin size is 1\n    \n    #Calculate the 'distance' to the ideal remaining capacity after placing the item\n    distance_to_ideal = np.abs((bins_remain_cap - item) - ideal_remaining)\n    \n    #Give a bonus inversely proportional to the distance, but only to eligible bins.\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += np.exp(-distance_to_ideal[eligible_bins] * 5) # Scale distance for better effect\n    \n    # Penalize near-full bins more heavily to allow more flexibility for the next item, mitigating fragmentation, and also bins that are almost empty.\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    near_empty = (bins_remain_cap > (1 - item * 0.1)) # Check if remaining capacity is close to full bin capacity after putting item\n    \n    if np.any(near_full):\n        priorities[near_full] -= 1.0 #increased penalty\n    \n    if np.any(near_empty):\n        priorities[near_empty] -= 0.75\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Encourage filling bins closer to full, scaled by item size.\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n      priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins] * item\n\n    # Prioritize bins with smallest remaining capacity that can still fit the item.\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n      min_remaining = np.min(bins_remain_cap[eligible_bins])\n      priorities[bins_remain_cap == min_remaining] += 1.5 # slightly increased priority for smallest\n\n    # Add a bonus for bins that would be filled to a \"good\" level. Target is 80% full.\n    target_fill = 0.8\n    ideal_remaining = 1 - target_fill # Assuming bin size is 1\n    \n    #Calculate the 'distance' to the ideal remaining capacity after placing the item\n    distance_to_ideal = np.abs((bins_remain_cap - item) - ideal_remaining)\n    \n    #Give a bonus inversely proportional to the distance, but only to eligible bins.\n    if np.any(eligible_bins):\n      priorities[eligible_bins] += np.exp(-distance_to_ideal[eligible_bins] * 5) # Scale distance for better effect\n    \n    # Penalize near-full bins more heavily to allow more flexibility for the next item, mitigating fragmentation, and also bins that are almost empty.\n    near_full = (bins_remain_cap < item * 1.1) & (bins_remain_cap >= item)\n    near_empty = (bins_remain_cap > (1 - item * 0.1)) # Check if remaining capacity is close to full bin capacity after putting item\n    \n    if np.any(near_full):\n        priorities[near_full] -= 1.0 #increased penalty\n    \n    if np.any(near_empty):\n        priorities[near_empty] -= 0.75\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}