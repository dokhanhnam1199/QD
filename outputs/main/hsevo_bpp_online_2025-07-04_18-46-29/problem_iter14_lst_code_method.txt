{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, and fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        \n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.8\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2  \n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.3\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95 #If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1-almost_empty_threshold) #bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin-use count, \n    with adaptive weights based on item size.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n    # Adaptive Weighting based on item size\n    item_size_factor = min(1.0, item)  # Normalize item size (assuming bin size is 1)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.8 + 0.2 * item_size_factor)  # Adjust weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.7 + 0.3 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.05 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.2 + 0.1 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9 + 0.05 * item_size_factor\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.6 + 0.1 * item_size_factor\n    \n    #5.Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n          priorities[too_empty] -= 0.5 * item_size_factor\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin-use count, \n    with adaptive weights based on item size.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_count = bins_remain_cap.size\n    # Adaptive Weighting based on item size\n    item_size_factor = min(1.0, item)  # Normalize item size (assuming bin size is 1)\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (0.8 + 0.2 * item_size_factor)  # Adjust weight\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 1.7 + 0.3 * item_size_factor\n\n    # 3. Fragmentation Penalty (Adaptive)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.05 * item_size_factor)\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.2 + 0.1 * item_size_factor\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.9 + 0.05 * item_size_factor\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.6 + 0.1 * item_size_factor\n    \n    #5.Discourage bins from being too empty after placing the item\n    too_empty_threshold = 0.75\n    too_empty = remaining_space > too_empty_threshold\n    if np.any(too_empty):\n          priorities[too_empty] -= 0.5 * item_size_factor\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, and fragmentation penalty with tuning.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste)  # Lower waste is better\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)  # Closer to ideal is better\n        \n        # Fragmentation penalty (discourage near-full bins)\n        near_full_threshold = 0.1\n        near_full = (bins_remain_cap >= item) & (bins_remain_cap < (item * (1 + near_full_threshold)))\n        priorities[near_full] -= 1.2 #Increased Penalty\n        \n        # Encourage near-empty reuse\n        near_empty_threshold = 0.1\n        near_empty = bins_remain_cap > (1 - item * near_empty_threshold)\n        priorities[near_empty] -= 0.75\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, target fill, and fragmentation penalty with tuning.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Best-fit component (minimize waste)\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] -= np.abs(waste)  # Lower waste is better\n\n        # Target fill bonus (around 80% full)\n        target_fill = 0.8\n        ideal_remaining = 1 - target_fill\n        distance_to_ideal = np.abs((bins_remain_cap[valid_bins] - item) - ideal_remaining)\n        priorities[valid_bins] += np.exp(-distance_to_ideal * 5)  # Closer to ideal is better\n        \n        # Fragmentation penalty (discourage near-full bins)\n        near_full_threshold = 0.1\n        near_full = (bins_remain_cap >= item) & (bins_remain_cap < (item * (1 + near_full_threshold)))\n        priorities[near_full] -= 1.2 #Increased Penalty\n        \n        # Encourage near-empty reuse\n        near_empty_threshold = 0.1\n        near_empty = bins_remain_cap > (1 - item * near_empty_threshold)\n        priorities[near_empty] -= 0.75\n    else:\n        priorities[:] = -100  # Discourage invalid placements\n    \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin-usage encouragement\n    with adaptive weights and state-dependent logic.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights (based on item size and bin availability)\n    item_size_factor = min(1.0, item)  # Normalize item size\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    large_bin_bonus_weight = 0.3\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] += fill_ratio_weight * (item / bins_remain_cap[potential_bins])\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)  #Adaptive threshold\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95  # If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight\n\n    #5. Bonus for larger bins if item is small\n    if item_size_factor < 0.3:\n        large_bins = bins_remain_cap > 0.7\n        if np.any(large_bins):\n            priorities[large_bins] += large_bin_bonus_weight\n    \n    #6. Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n    \n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit component: prioritize bins with smallest waste\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        # Fill ratio component: encourage higher fill\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.4\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n        # Adaptive fragmentation penalty: penalize bins becoming almost full\n        almost_full_threshold = 0.1\n        almost_full = bins_remain_cap[valid_bins] < (1 + almost_full_threshold) * item\n        almost_full_penalty = 2.0 # Slightly reduced penalty from v1\n        priorities[valid_bins][almost_full] -= almost_full_penalty\n\n        # Non-linearity based on remaining capacity, gently encouraging tighter fits.\n        remaining_after_fit_scale = 5.0 # Adjusted scaling\n        remaining_after_fit_weight = 0.2\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n        # Prioritize bins with smallest remaining capacity slightly\n        min_remaining_cap = np.min(bins_remain_cap[valid_bins])\n        priorities[bins_remain_cap == min_remaining_cap] += 0.1 # Small boost\n        \n    else:\n        # Discourage placement if no bin fits.\n        discourage_placement_value = 0.0008\n        priorities[:] = -discourage_placement_value\n        \n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and bin-usage encouragement with adaptive weights.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    n_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference (Adjusted for bin fullness)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.5 * (1 - np.mean(bins_remain_cap)))  # Adaptive weight: favors bins when average fullness is low\n\n    # 2. Best Fit Encouragement (Stronger boost)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += 2.2  # Stronger best-fit\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.1 * np.mean(bins_remain_cap))  # Adaptive threshold based on avg capacity\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.5 #Slightly increased penalty\n\n    # 4. Encourage re-use of almost empty bins (Adjusted boost)\n    almost_empty_threshold = 0.90 # Reduced Threshold\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.9  # Increased bonus\n\n    # 5. Bin usage encouragement. Give priority to bins that are already in use, to reduce number of open bins\n    used_bins = bins_remain_cap < 1.0 # bin size normalized to 1\n    if np.any(used_bins):\n        priorities[used_bins] += 0.4 # Small incentive to reuse\n\n    #6. Balancing term: Encourage using bins that will be filled more than a certain percentage\n\n    fill_percentage = item / (1 - bins_remain_cap)\n    high_fill_bins = (bins_remain_cap >= item) & (fill_percentage > 0.7) & (bins_remain_cap < 1)\n    if np.any(high_fill_bins):\n        priorities[high_fill_bins] += 0.6 # Incentive for filling greater than 70%\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, bin balancing, and fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - encourages filling bins well\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += 0.5 * fill_ratio\n\n        # Best Fit - minimizes wasted space\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 0.6 * np.exp(-remaining_space) #Nonlinear best fit\n\n        # Fragmentation Penalty - discourages leaving small gaps\n        priorities[eligible_bins] -= 0.2 * (remaining_space / np.max(bins_remain_cap)) # Normalize penalty\n\n    # Bin Balancing - distributes items across bins\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.1 * bin_capacity_normalized\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit component: prioritize bins with smallest waste\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        # Fill ratio component: encourage higher fill\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.4\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n        # Adaptive fragmentation penalty: penalize bins becoming almost full\n        almost_full_threshold = 0.1\n        almost_full = bins_remain_cap[valid_bins] < (1 + almost_full_threshold) * item\n        almost_full_penalty = 2.0 # Slightly reduced penalty from v1\n        priorities[valid_bins][almost_full] -= almost_full_penalty\n\n        # Non-linearity based on remaining capacity, gently encouraging tighter fits.\n        remaining_after_fit_scale = 5.0 # Adjusted scaling\n        remaining_after_fit_weight = 0.2\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n        # Prioritize bins with smallest remaining capacity slightly\n        min_remaining_cap = np.min(bins_remain_cap[valid_bins])\n        priorities[bins_remain_cap == min_remaining_cap] += 0.1 # Small boost\n        \n    else:\n        # Discourage placement if no bin fits.\n        discourage_placement_value = 0.0008\n        priorities[:] = -discourage_placement_value\n        \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines best-fit, fill-ratio, fragmentation penalty, and bin-usage encouragement\n    with adaptive weights and state-dependent logic.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n    \n    # Adaptive Weights (based on item size and bin availability)\n    item_size_factor = min(1.0, item)  # Normalize item size\n    bin_availability_factor = min(1.0, np.sum(bins_remain_cap >= item) / num_bins)\n\n    fill_ratio_weight = 0.5 + 0.3 * item_size_factor\n    best_fit_weight = 1.5 + 0.5 * bin_availability_factor\n    fragmentation_penalty_weight = 1.0 + 0.2 * item_size_factor\n    reuse_weight = 0.6 + 0.4*bin_availability_factor\n    large_bin_bonus_weight = 0.3\n\n    # 1. Fill Ratio Preference\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        priorities[potential_bins] += fill_ratio_weight * (item / bins_remain_cap[potential_bins])\n\n    # 2. Best Fit Encouragement\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        priorities[best_fit_bins] += best_fit_weight\n\n    # 3. Fragmentation Penalty (Adaptive Threshold)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.1 + 0.1 * item_size_factor)  #Adaptive threshold\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    priorities[fragmented_bins] -= fragmentation_penalty_weight\n\n    # 4. Encourage re-use of almost empty bins.\n    almost_empty_threshold = 0.95  # If more than 95% empty give it a boost\n    almost_empty = bins_remain_cap > (1 - almost_empty_threshold)  # bin size set to 1\n    if np.any(almost_empty):\n        priorities[almost_empty] += reuse_weight\n\n    #5. Bonus for larger bins if item is small\n    if item_size_factor < 0.3:\n        large_bins = bins_remain_cap > 0.7\n        if np.any(large_bins):\n            priorities[large_bins] += large_bin_bonus_weight\n    \n    #6. Penalize bins that are close to full but can't fit the item\n    too_full_bins = (bins_remain_cap < item) & (bins_remain_cap > (item-0.2))\n    priorities[too_full_bins] -= 0.8\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n\n    if np.any(valid_bins):\n        # Best-fit component: prioritize bins with smallest waste\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -np.abs(waste)\n\n        # Fill ratio component: encourage higher fill\n        fill_fraction = item / bins_remain_cap[valid_bins]\n        fill_fraction_weight = 0.4\n        priorities[valid_bins] += fill_fraction * fill_fraction_weight\n\n        # Adaptive fragmentation penalty: penalize bins becoming almost full\n        almost_full_threshold = 0.1\n        almost_full = bins_remain_cap[valid_bins] < (1 + almost_full_threshold) * item\n        almost_full_penalty = 2.0 # Slightly reduced penalty from v1\n        priorities[valid_bins][almost_full] -= almost_full_penalty\n\n        # Non-linearity based on remaining capacity, gently encouraging tighter fits.\n        remaining_after_fit_scale = 5.0 # Adjusted scaling\n        remaining_after_fit_weight = 0.2\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] += np.exp(-remaining_after_fit_scale * remaining_after_fit / item) * remaining_after_fit_weight\n\n        # Prioritize bins with smallest remaining capacity slightly\n        min_remaining_cap = np.min(bins_remain_cap[valid_bins])\n        priorities[bins_remain_cap == min_remaining_cap] += 0.1 # Small boost\n        \n    else:\n        # Discourage placement if no bin fits.\n        discourage_placement_value = 0.0008\n        priorities[:] = -discourage_placement_value\n        \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - scale by a factor\n        fill_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += fill_ratio * 0.7\n\n        # Best Fit - encourage packing to tightest fitting bin\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += np.exp(-5 * remaining_space)\n\n        # Fragmentation Penalty-Adaptive-heavier penalty for very small remaining spaces\n        remaining_space = bins_remain_cap - item\n        nearly_empty = (remaining_space > 0) & (remaining_space < 0.1)\n        priorities[nearly_empty] -= 3.0 # stronger penality\n\n        #First fit preference\n        first_fit_index = np.argmax(eligible_bins)\n        priorities[first_fit_index] += 0.5\n\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, target fill, and adaptive waste/fragmentation penalty with capacity weights.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Best Fit component\n        remaining_space = bins_remain_cap[can_fit] - item\n        fit_scores = 1 / (remaining_space + 1e-9)\n\n        # Target fill ratio component (around 70%)\n        fit_ratios = item / bins_remain_cap[can_fit]\n        target_priority = np.exp(-np.abs(fit_ratios - 0.7))\n\n        # Fragmentation Penalty: penalize leaving small space\n        waste_ratio = remaining_space / item\n        waste_penalty = np.exp( -waste_ratio)\n\n        # Capacity weights\n        capacity_weights = bins_remain_cap[can_fit]/np.max(bins_remain_cap)\n        \n        # Combined score with capacity weights for balancing\n        combined_priority = (capacity_weights * fit_scores + (1 - capacity_weights) * target_priority) - 0.2*waste_penalty # waste_penalty impact\n\n        #Adaptive Penalty for bin utilization > 90%\n        bin_utilization = 1 - bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        adaptive_penalty = np.exp(5 * (bin_utilization - 0.9))\n        combined_priority -= adaptive_penalty\n\n        priorities[can_fit] = combined_priority\n    else:\n        # Prioritize larger bins when no fit exists\n        priorities = bins_remain_cap\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, target fill, and adaptive waste/fragmentation penalty with capacity weights.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # Best Fit component\n        remaining_space = bins_remain_cap[can_fit] - item\n        fit_scores = 1 / (remaining_space + 1e-9)\n\n        # Target fill ratio component (around 70%)\n        fit_ratios = item / bins_remain_cap[can_fit]\n        target_priority = np.exp(-np.abs(fit_ratios - 0.7))\n\n        # Fragmentation Penalty: penalize leaving small space\n        waste_ratio = remaining_space / item\n        waste_penalty = np.exp( -waste_ratio)\n\n        # Capacity weights\n        capacity_weights = bins_remain_cap[can_fit]/np.max(bins_remain_cap)\n        \n        # Combined score with capacity weights for balancing\n        combined_priority = (capacity_weights * fit_scores + (1 - capacity_weights) * target_priority) - 0.2*waste_penalty # waste_penalty impact\n\n        #Adaptive Penalty for bin utilization > 90%\n        bin_utilization = 1 - bins_remain_cap[can_fit] / np.max(bins_remain_cap)\n        adaptive_penalty = np.exp(5 * (bin_utilization - 0.9))\n        combined_priority -= adaptive_penalty\n\n        priorities[can_fit] = combined_priority\n    else:\n        # Prioritize larger bins when no fit exists\n        priorities = bins_remain_cap\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    potential_bins = bins_remain_cap >= item\n\n    if np.any(potential_bins):\n        # Best fit component: Maximize bin utilization.\n        waste = bins_remain_cap[potential_bins] - item\n        priorities[potential_bins] = 1 - waste / bins_remain_cap[potential_bins]\n\n        # Fill ratio bonus\n        fill_fraction = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += 0.3 * fill_fraction  # Weight adjusted\n\n        # Adaptive fragmentation penalty: Penalize bins leaving small fragments\n        small_fragment_threshold = item * 0.6  # Adaptive threshold\n        remaining_after_pack = bins_remain_cap - item\n        too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n        if np.any(too_small_remaining):\n            priorities[too_small_remaining] -= 0.7  # Stronger penalty\n\n        #First fit tiebreaker.\n        eligible_bins = bins_remain_cap >= item\n        if np.any(eligible_bins):\n            first_eligible_index = np.argmax(eligible_bins) # Select the index of the first true value\n            priorities[first_eligible_index] += 0.01\n    else:\n        priorities[:] = -0.001  # Discourage if no suitable bin\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    potential_bins = bins_remain_cap >= item\n\n    if np.any(potential_bins):\n        # Best fit component: Maximize bin utilization.\n        waste = bins_remain_cap[potential_bins] - item\n        priorities[potential_bins] = 1 - waste / bins_remain_cap[potential_bins]\n\n        # Fill ratio bonus\n        fill_fraction = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += 0.3 * fill_fraction  # Weight adjusted\n\n        # Adaptive fragmentation penalty: Penalize bins leaving small fragments\n        small_fragment_threshold = item * 0.6  # Adaptive threshold\n        remaining_after_pack = bins_remain_cap - item\n        too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n        if np.any(too_small_remaining):\n            priorities[too_small_remaining] -= 0.7  # Stronger penalty\n\n        #First fit tiebreaker.\n        eligible_bins = bins_remain_cap >= item\n        if np.any(eligible_bins):\n            first_eligible_index = np.argmax(eligible_bins) # Select the index of the first true value\n            priorities[first_eligible_index] += 0.01\n    else:\n        priorities[:] = -0.001  # Discourage if no suitable bin\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best fit, fill ratio, and adaptive fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    potential_bins = bins_remain_cap >= item\n\n    if np.any(potential_bins):\n        # Best fit component: Maximize bin utilization.\n        waste = bins_remain_cap[potential_bins] - item\n        priorities[potential_bins] = 1 - waste / bins_remain_cap[potential_bins]\n\n        # Fill ratio bonus\n        fill_fraction = item / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += 0.3 * fill_fraction  # Weight adjusted\n\n        # Adaptive fragmentation penalty: Penalize bins leaving small fragments\n        small_fragment_threshold = item * 0.6  # Adaptive threshold\n        remaining_after_pack = bins_remain_cap - item\n        too_small_remaining = (remaining_after_pack > 0) & (remaining_after_pack < small_fragment_threshold)\n        if np.any(too_small_remaining):\n            priorities[too_small_remaining] -= 0.7  # Stronger penalty\n\n        #First fit tiebreaker.\n        eligible_bins = bins_remain_cap >= item\n        if np.any(eligible_bins):\n            first_eligible_index = np.argmax(eligible_bins) # Select the index of the first true value\n            priorities[first_eligible_index] += 0.01\n    else:\n        priorities[:] = -0.001  # Discourage if no suitable bin\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, best fit, fragmentation penalty and almost empty reuse.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if np.any(eligible_bins):\n        # Fill Ratio - adjusted for sensitivity\n        fill_ratio = item / (bins_remain_cap[eligible_bins] + 0.0001)  # Avoid division by zero\n        priorities[eligible_bins] += 0.8 * fill_ratio  #Reduced sensitivity\n\n        # Best Fit - with exponential decay\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] += 1.2*np.exp(-2 * remaining_space) #Best fit bonus\n\n    # Fragmentation Penalty - Dynamic threshold\n    remaining_space_all = bins_remain_cap - item\n    fragmentation_threshold = item * 0.2\n    fragmented_bins = (remaining_space_all > 0) & (remaining_space_all <= fragmentation_threshold)\n    priorities[fragmented_bins] -= 1.0  #Slightly decreased penalty\n\n     # Almost empty reuse\n    almost_empty_threshold = 0.95\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        priorities[almost_empty] += 0.7 #almost empty reuse bonus.\n\n    #Balance the empty bins\n    bin_capacity_normalized = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap)\n    priorities += 0.05*bin_capacity_normalized\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, fill-ratio, fragmentation penalty, and bin-emptiness with adaptive weights.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    num_bins = len(bins_remain_cap)\n\n    # 1. Fill Ratio Preference (Weighted by remaining capacity)\n    potential_bins = bins_remain_cap >= item\n    if np.any(potential_bins):\n        fill_ratios = (bins_remain_cap[potential_bins] - item) / bins_remain_cap[potential_bins]\n        priorities[potential_bins] += fill_ratios * (1 + 0.5 * bins_remain_cap[potential_bins])  # Weight fill ratio\n\n    # 2. Best Fit Encouragement (Adaptive Bonus)\n    capacity_diff = np.abs(bins_remain_cap - item)\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        min_diff = np.min(capacity_diff[eligible_bins])\n        best_fit_bins = capacity_diff == min_diff\n        best_fit_bonus = 1.5 + 0.7 * (1 - (min_diff / item))  # Adaptive bonus based on how \"best\" it is\n        priorities[best_fit_bins] += best_fit_bonus\n\n    # 3. Fragmentation Penalty (Adaptive Threshold and Penalty)\n    remaining_space = bins_remain_cap - item\n    fragmentation_threshold = item * (0.15 + 0.05 * (num_bins / (np.sum(bins_remain_cap) + 1e-9))) #threshold shrinks as bin space increases\n    fragmented_bins = (remaining_space > 0) & (remaining_space <= fragmentation_threshold)\n    fragmentation_penalty = 1.0 + 0.5 * (fragmentation_threshold - remaining_space[fragmented_bins]) / (fragmentation_threshold + 1e-9) #penalty increases as space remaining nears the threshold\n    priorities[fragmented_bins] -= fragmentation_penalty\n\n    # 4. Encourage re-use of almost empty bins (Adaptive Bonus)\n    almost_empty_threshold = 0.9\n    almost_empty = bins_remain_cap > almost_empty_threshold\n    if np.any(almost_empty):\n        almost_empty_bonus = 0.5 + 0.4 * (bins_remain_cap[almost_empty] - almost_empty_threshold) / (1 - almost_empty_threshold + 1e-9)\n        priorities[almost_empty] += almost_empty_bonus\n\n    # 5. Penalize bins that are too full to discourage overfill\n    too_full_threshold = item*1.1 # if bin is filled more than item size, penalize it.\n    overfilled_bins = (bins_remain_cap < item) & (bins_remain_cap > 0)\n    if np.any(overfilled_bins):\n        priorities[overfilled_bins] -= 0.8 #slight penality to encourage use of other viable bins\n        \n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}