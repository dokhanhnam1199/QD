[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\n# Global, reproducible RNG for tie\u2011breaking\n_rng = np.random.default_rng(12345)\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The score favours bins with the smallest remaining slack after placing the\n    item.  It uses a normalized inverse\u2011slack weighting, adds a tiny\n    reproducible random perturbation for stochastic tie\u2011breaking, and applies a\n    minimal deterministic index\u2011based penalty to guarantee a total ordering.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same length as ``bins_remain_cap``).  Infeasible bins\n        (capacity < item) receive ``-np.inf``; the bin with the highest score\n        should be selected for the item.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n\n    # Initialise all scores as infeasible\n    priorities = np.full(n, -np.inf, dtype=float)\n    if n == 0:\n        return priorities\n\n    slack = caps - item\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return priorities\n\n    # Constant epsilon to avoid division by zero\n    eps = 1e-12\n    slack_feas = slack[feasible]\n\n    # Inverse slack (larger for tighter fits)\n    inv_slack = 1.0 / (slack_feas + eps)\n\n    # Normalise to keep scores bounded in [0, 1]\n    max_inv = inv_slack.max()\n    inv_norm = inv_slack / max_inv if max_inv > 0 else inv_slack\n\n    # Small reproducible random perturbation for stochastic tie\u2011breaking\n    rand_noise = _rng.random(inv_norm.shape) * 1e-9\n\n    # Deterministic tiny penalty based on bin index to resolve any remaining ties\n    idx = np.nonzero(feasible)[0].astype(float)\n    idx_penalty = idx * 1e-12\n\n    # Final scores for feasible bins\n    scores = inv_norm + rand_noise - idx_penalty\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    low_percentile: float = 0.10,\n    boost_factor: float = 5.0,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    For each existing bin a score is computed; the bin with the highest score\n    is selected for the incoming ``item``.  The heuristic combines several\n    ideas:\n\n    1. **Inverse\u2011slack bias** \u2013 bins that would have less remaining capacity\n       after placement receive a larger base score.\n    2. **Low\u2011percentile slack boost** \u2013 bins whose post\u2011placement slack falls\n       below ``low_percentile`` (default 10\u202f%) are boosted, encouraging the\n       algorithm to fill \u201calmost full\u2019\u2019 bins.\n    3. **Adaptive weighting** \u2013 the relative weight of the bias and the boost\n       adapts to the current packing situation: when few bins can accommodate\n       the item, the inverse\u2011slack bias dominates; when many bins are feasible,\n       the boost gets a larger share.\n    4. **Normalization** \u2013 deterministic components are normalised to the\n       interval ``[0, 1]`` before blending, preserving ordering while keeping\n       scores comparable across instances.\n    5. **Tiny random tie\u2011breaker** \u2013 a minute random perturbation (\u22481e\u20118) breaks\n       ties without affecting the deterministic ordering.\n\n    Infeasible bins (those that cannot accommodate the item) receive\n    ``-np.inf`` guaranteeing they are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n    low_percentile : float, optional\n        Percentile (in [0, 1]) used to define \u201calmost full\u2019\u2019 bins.\n        Default is ``0.10`` (10\u202f%).\n    boost_factor : float, optional\n        Multiplier controlling the magnitude of the low\u2011percentile boost.\n        Default is ``5.0``.\n    random_state : int or None, optional\n        Seed for reproducible random tie\u2011breaking.\n\n    Returns\n    -------\n    np.ndarray\n        1\u2011D array of priority scores (higher is better). Infeasible bins are\n        marked with ``-np.inf``.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 0) Pre\u2011processing & feasibility mask\n    # ------------------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Edge case: no bins at all\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Slack after hypothetically placing the item\n    slack = caps - item\n    feasible = slack >= 0\n\n    # Initialise all scores as -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if nothing fits\n    if not feasible.any():\n        return priorities\n\n    # ------------------------------------------------------------------\n    # 1) Inverse\u2011slack bias (tight\u2011fit component)\n    # ------------------------------------------------------------------\n    slack_feas = slack[feasible]\n\n    # Scale epsilon with typical slack magnitude to avoid division\u2011by\u2011zero\n    mean_slack = np.mean(slack_feas)\n    eps = max(1e-12, 1e-6 * mean_slack)\n\n    inv_slack = 1.0 / (slack_feas + eps)          # larger when slack is smaller\n\n    # Normalise to [0, 1]\n    inv_slack_norm = inv_slack / (inv_slack.max() + eps)\n\n    # ------------------------------------------------------------------\n    # 2) Low\u2011percentile slack boost\n    # ------------------------------------------------------------------\n    low_percentile = np.clip(low_percentile, 0.0, 1.0)\n\n    if slack_feas.size > 0:\n        threshold = np.quantile(slack_feas, low_percentile)\n    else:\n        threshold = 0.0\n\n    boost = np.zeros_like(slack_feas)\n    low_mask = slack_feas <= threshold\n    boost[low_mask] = boost_factor * (threshold - slack_feas[low_mask])\n\n    # Normalise boost (if any boost is non\u2011zero)\n    if boost.max() > eps:\n        boost_norm = boost / (boost.max() + eps)\n    else:\n        boost_norm = boost  # all zeros\n\n    # ------------------------------------------------------------------\n    # 3) Adaptive weighting between bias and boost\n    # ------------------------------------------------------------------\n    feasible_frac = feasible.sum() / n_bins  # \u2208 (0, 1]\n    # Inverse\u2011slack gets more weight when few bins are feasible,\n    # boost gets more weight when many bins are feasible.\n    w_inv = 1.0 - feasible_frac\n    w_boost = feasible_frac\n\n    # Clamp weights to avoid domination of a single term\n    w_inv = np.clip(w_inv, 0.1, 0.9)\n    w_boost = 1.0 - w_inv\n\n    # Weighted combination (still in [0, 1] because components are normalised)\n    combined = w_inv * inv_slack_norm + w_boost * boost_norm\n\n    # ------------------------------------------------------------------\n    # 4) Normalisation of the combined score\n    # ------------------------------------------------------------------\n    combined_norm = combined / (combined.max() + eps)\n\n    # ------------------------------------------------------------------\n    # 5) Tiny random tie\u2011breaker\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    tie_eps = 1e-8\n    jitter = tie_eps * rng.random(combined_norm.shape[0])\n\n    final_score = combined_norm + jitter\n\n    # ------------------------------------------------------------------\n    # 6) Write back to full priorities array\n    # ------------------------------------------------------------------\n    priorities[feasible] = final_score\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 46.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic tight\u2011fit priority for the online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array (or array\u2011like) of remaining capacities of the currently open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks; a bin is feasible if its\n        remaining capacity is at least ``item - tolerance``.\n    tie_breaker : float, optional\n        Tiny positive value used to break ties deterministically in favour of\n        bins with smaller original indices.  Must be smaller than any meaningful\n        leftover value (e.g., ``tolerance``).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Higher scores indicate more attractive bins.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: bins that can hold the item (within tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 return all -inf\n        return priorities\n\n    # Compute leftover capacity for feasible bins\n    leftover = caps[feasible] - item\n    # Clip tiny negative leftovers caused by floating\u2011point noise\n    leftover = np.maximum(leftover, 0.0)\n\n    # Original indices of feasible bins (preserve order)\n    idx_feas = np.nonzero(feasible)[0]\n\n    # Tight\u2011fit bias: smaller leftover \u2192 higher priority.\n    # Subtract a tiny index\u2011dependent term to break ties in favour of lower indices.\n    # The overall priority is negative leftover (so larger is better) minus tie_breaker*index.\n    priorities[feasible] = -leftover - idx_feas * tie_breaker\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Adaptive priority function for online bin packing.\n\n    - Favors exact (tight) fits.\n    - Uses a deterministic tie\u2011breaker based on bin index.\n    - Adjusts the influence of the slack (remaining space) according to the\n      proportion of feasible bins.\n    - Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility (default 1e-12).\n    tie_breaker : float, optional\n        Small deterministic bias to break ties; lower indices get higher\n        priority (default 1e-12).\n    eps : float, optional\n        Small constant to avoid division by zero (default 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Normalise slack to [0, 1] (smaller slack => smaller norm)\n    max_slack = slack.max()\n    slack_norm = slack / (max_slack + eps)\n\n    # Adaptive weighting: more weight on slack when many bins are feasible\n    feasible_frac = feasible.sum() / n_bins  # \u2208 (0, 1]\n    w_slack = feasible_frac  # higher when many bins can accommodate the item\n\n    # Base score: tighter fit (smaller slack) gets higher (less negative) score\n    base_score = -slack_norm\n    weighted_score = w_slack * base_score  # slack influence adapts to feasibility\n\n    # Deterministic tie\u2011breaker: lower index \u2192 higher priority\n    indices = np.arange(n_bins)\n    tie = -indices[feasible] * tie_breaker\n\n    priorities[feasible] = weighted_score + tie\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin\u2011packing setting.\n\n    - Infeasible bins (remaining capacity < item) receive ``-np.inf`` so they are never chosen.\n    - Feasible bins receive a score proportional to a bias that favours tighter fits\n      (smaller slack) and a random factor for stochastic tie\u2011breaking.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more attractive) for each bin.\n    \"\"\"\n    # Ensure a flat float array of capacities.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask.\n    feasible = caps >= item\n\n    # Initialise all priorities to -inf (infeasible bins).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accommodate the item.\n        return priorities\n\n    # Slack after placing the item in each feasible bin.\n    slack = caps[feasible] - item\n\n    # Bias: larger when slack is small (tighter fit).\n    eps = 1e-12\n    bias = 1.0 / (slack + eps)\n\n    # Random component for stochastic tie\u2011breaking.\n    # Using the default RNG; callers can set the global seed if reproducibility is needed.\n    rand_scores = np.random.rand(bias.shape[0])\n\n    # Combine bias and randomness.\n    scores = bias * rand_scores\n\n    # Assign scores back to the full priority vector.\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 4,
    "obj": 4.008775428799367,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                tolerance: float = 1e-12,\n                tie_breaker: float = 1e-12,\n                seed: int | None = None) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that:\n      * adapts a numerical tolerance for feasibility,\n      * biases bins towards tighter fits using slack,\n      * incorporates the fill level (smaller slack = higher priority),\n      * randomises ties for exploration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    tolerance : float, optional\n        Accept bins whose remaining capacity is within ``item - tolerance``.\n    tie_breaker : float, optional\n        Deterministic bias to break ties between bins with identical priorities\n        (lower\u2011indexed bins are favoured).\n    seed : int or None, optional\n        Seed for the random number generator to obtain reproducible results.\n        If ``None`` the global RNG state is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better).  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Feasibility mask using tolerance\n    feasible = caps >= (item - tolerance)\n\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n    if not np.any(feasible):\n        return priorities\n\n    # Slack (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Bias: smaller slack \u2192 larger bias\n    epsilon = 1e-12\n    bias = 1.0 / (slack + epsilon)\n\n    # Random component for exploration\n    rng = np.random.default_rng(seed)\n    rand_component = rng.random(feasible.sum())\n\n    # Base priority: negative slack (tighter fit first)\n    base_priority = -slack\n\n    # Combine: tighter fit + random exploration\n    priority_vals = base_priority + bias * rand_component\n\n    # Deterministic tie\u2011breaker: lower index favored\n    idx = np.arange(caps.size)\n    priority_vals += -idx[feasible] * tie_breaker\n\n    priorities[feasible] = priority_vals\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 23.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The score favours bins with the smallest remaining slack (tight fits) while\n    adding a random component to break ties and promote diversification.\n    Infeasible bins (insufficient capacity) receive ``-np.inf`` so they are\n    never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    tolerance : float, optional\n        Numerical tolerance used for feasibility checks and to avoid division\n        by zero when computing the bias.\n    tie_breaker : float, optional\n        Tiny positive constant to break ties deterministically; lower\u2011indexed\n        bins are slightly preferred.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible randomness. If ``None`` the global\n        NumPy RNG is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (shape matches ``bins_remain_cap``). Higher\n        scores indicate more attractive bins.\n    \"\"\"\n    # Ensure a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Early exit for empty input.\n    if n_bins == 0:\n        return np.empty_like(caps, dtype=float)\n\n    # Feasibility mask (allow a small tolerance for floating\u2011point errors).\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities as -inf (infeasible bins).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If no bin can accommodate the item, return early.\n    if not np.any(feasible):\n        return priorities\n\n    # Slack for feasible bins (non\u2011negative, clipped to zero if slightly negative).\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Bias: larger for tighter fits (smaller slack). Add tolerance to avoid div\u2011by\u2011zero.\n    bias = np.zeros_like(caps, dtype=float)\n    bias[feasible] = 1.0 / (slack + tolerance)\n\n    # Normalise bias across feasible bins so the maximum becomes 1.\n    max_bias = bias[feasible].max()\n    if max_bias > 0:\n        bias_norm = np.zeros_like(caps, dtype=float)\n        bias_norm[feasible] = bias[feasible] / max_bias\n    else:\n        bias_norm = bias  # all zeros (should not happen for feasible bins)\n\n    # Random component.\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n    rand_vals = rng.random(n_bins)\n\n    # Combine bias and randomness.\n    combined = bias_norm * rand_vals\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage.\n    idx_feasible = np.where(feasible)[0].astype(float)\n    tie_term = np.zeros_like(caps, dtype=float)\n    tie_term[feasible] = idx_feasible * tie_breaker\n\n    # Final priority for feasible bins.\n    priorities[feasible] = combined[feasible] - tie_term[feasible]\n\n    return priorities",
    "response_id": 6,
    "obj": 3.9988033506182825,
    "SLOC": 36.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin\u2011packing that blends exact\u2011fit scoring with a\n    biased random component and a deterministic tie\u2011breaker.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacity for each currently open bin.\n    tolerance : float, optional\n        Numerical tolerance used for feasibility checks and exact\u2011fit\n        detection.\n    tie_breaker : float, optional\n        Small positive constant used to break ties deterministically\n        (lower\u2011indexed bins are slightly preferred).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible randomness. If ``None`` the global\n        NumPy RNG is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin (higher = more attractive).\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure capacities are a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: bins that can accommodate the item (within tolerance).\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priorities with -inf (infeasible bins).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Compute slack for feasible bins (non\u2011negative).\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Exact\u2011fit score: larger when slack is smaller (exact fit => 0).\n    exact_score = -slack\n\n    # Bias: larger for tighter fits.\n    epsilon = tolerance\n    bias = 1.0 / (slack + epsilon)\n\n    # Normalise bias to [0, 1] to keep the random term comparable across bins.\n    bias_norm = bias / bias.max() if bias.max() > 0 else np.zeros_like(bias)\n\n    # Random generator handling.\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    # Random component: random number scaled by bias_norm.\n    rand_vals = rng.random(bias.size)  # one random number per feasible bin\n    random_component = bias_norm * rand_vals  # values in [0, 1]\n\n    # Adaptive weighting of the random part.\n    # If an exact fit exists, reduce randomness to favour it.\n    w_random = 0.1 if np.min(slack) <= tolerance else 0.5\n\n    # Deterministic tie\u2011breaker (lower index slightly preferred).\n    idx_feasible = np.where(feasible)[0]\n    tie_term = idx_feasible.astype(float) * tie_breaker\n\n    # Combine the components.\n    combined = exact_score + w_random * random_component - tie_term\n\n    # Populate the result array.\n    priorities[feasible] = combined\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Random Fit priority for online bin packing, biased toward tighter fits.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1-D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin.  Higher scores indicate higher priority.\n        Infeasible bins receive -np.inf.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    if caps.size == 0:\n        return np.empty(0, dtype=float)\n\n    feasible = caps >= item\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        slack = caps[feasible] - item\n        epsilon = 1e-12\n        rand = np.random.rand(caps.size)[feasible]\n        priorities[feasible] = rand / (slack + epsilon)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.068607897885915,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin\u2011packing setting.\n\n    The score is the product of an inverse\u2011slack bias and a random factor.\n    Infeasible bins receive ``-np.inf`` so they are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; higher values indicate a more\n        desirable placement. Infeasible bins have ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    feasible = caps >= item\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priority\n\n    slack = caps[feasible] - item\n    # Adapt epsilon to the mean slack of feasible bins\n    eps = max(np.mean(slack), 1e-9)\n\n    # Inverse\u2011slack bias: tighter fits get larger bias\n    bias = 1.0 / (slack + eps)\n\n    rng = np.random.default_rng()\n    rand_scores = rng.random(bias.size)\n\n    # Combine bias with random exploration\n    priority[feasible] = bias * rand_scores\n\n    # Tiny noise for deterministic tie\u2011breaking (optional)\n    priority[feasible] += rng.random(bias.size) * 1e-12\n\n    return priority",
    "response_id": 9,
    "obj": 5.045871559633042,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n    Scores each feasible bin by a normalised inverse slack value,\n    prioritising exact\u2011fit bins. Infeasible bins receive -inf.\n    A tiny deterministic pseudo\u2011random noise per bin is added\n    to break ties in a reproducible way.\n    \n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n    \n    Returns\n    -------\n    np.ndarray\n        1\u2011D array of priority scores, one per bin.  The bin with the\n        highest priority will be chosen for the item.\n    \"\"\"\n    # Ensure input is a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute slack and feasibility\n    slack = caps - item\n    feasible = slack >= 0\n\n    # Initialise priority array with -inf for infeasible bins\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # If no feasible bins, return the array as is\n    if not np.any(feasible):\n        return priorities\n\n    # Inverse slack priority with small epsilon to avoid division by zero\n    eps = 1e-12\n    inv_slack = np.zeros_like(caps)\n    inv_slack[feasible] = 1.0 / (slack[feasible] + eps)\n\n    # Normalise to sum to 1 (only over feasible bins)\n    total = np.sum(inv_slack[feasible])\n    if total > 0:\n        inv_slack[feasible] /= total\n\n    # Add deterministic tiny noise per bin to break ties\n    bin_indices = np.arange(caps.size, dtype=np.int64)\n    # Create a simple pseudo\u2011random seed that mixes item size and bin index\n    noise_seed = (bin_indices + int(item * 1_000_000)) & 0xffffffff\n    noise = (noise_seed.astype(np.float64) / 2**32) * 1e-12\n\n    # Combine inverse slack and noise only for feasible bins\n    priorities[feasible] = inv_slack[feasible] + noise[feasible]\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]