```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                tolerance: float = 1e-12,
                tie_breaker: float = 1e-12,
                eps: float = 1e-12) -> np.ndarray:
    """
    Deterministic priority function for the online bin packing problem.

    The function assigns a priority score to each bin based on how tightly the
    incoming ``item`` would fit (i.e., the slack after placement) and a small
    deterministic tie‑breaker that favours bins with lower indices.

    Features:
    - Feasibility check with a tolerance.
    - Slack (remaining space after placing the item) is normalised to [0, 1].
    - Slack influence is weighted by the fraction of feasible bins: when many
      bins can accommodate the item, tighter fits are strongly preferred; when
      few bins are feasible, the influence of slack diminishes and the tie‑breaker
      dominates.
    - Infeasible bins receive ``-np.inf`` so they are never selected.
    - No random components → reproducible behaviour.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility (default 1e-12).
    tie_breaker : float, optional
        Small deterministic bias to break ties; lower indices receive higher
        priority (default 1e-12).
    eps : float, optional
        Small constant to avoid division by zero when normalising slack
        (default 1e-12).

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin.  Infeasible bins have
        ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        # No bins available – return an empty array.
        return np.empty(0, dtype=float)

    # Feasibility mask (allow a tiny tolerance for floating‑point errors)
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible by default)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin – return priorities as all -inf.
        return priorities

    # Slack after placing the item (non‑negative)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Normalise slack to the interval [0, 1].
    max_slack = slack.max()
    slack_norm = slack / (max_slack + eps)  # Avoid division by zero.

    # Adaptive weighting: more weight on slack when many bins are feasible.
    feasible_frac = feasible.sum() / n_bins  # ∈ (0, 1]
    w_slack = feasible_frac  # Larger when many bins can accommodate the item.

    # Base score: tighter fit (smaller slack) gets a larger (less negative) score.
    base_score = -slack_norm
    weighted_score = w_slack * base_score

    # Deterministic tie‑breaker: lower index → slightly higher priority.
    indices = np.arange(n_bins)
    tie = -indices[feasible] * tie_breaker

    # Combine weighted slack score and tie‑breaker.
    priorities[feasible] = weighted_score + tie

    return priorities
```
