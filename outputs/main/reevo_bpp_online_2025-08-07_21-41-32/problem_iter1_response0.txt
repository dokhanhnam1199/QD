```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority vector for a First‑Fit bin‑packing heuristic.
    Feasible bins are ranked by *minimal* remaining space after adding the
    item (the smallest waste is preferred).  Infeasible bins receive a
    priority of –∞ so that they are never chosen.  When two feasible
    bins yield the same waste, the earlier one in the list gets a tiny
    edge by subtracting a negligible amount proportional to its position.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities of all bins.

    Returns:
        1‑D float array of the same shape as bins_remain_cap containing
        the computed priority for each bin.
    """
    # Work on a float copy to avoid unintended dtype issues
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialise all priorities to −∞ so infeasible bins are never chosen
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Mask of bins that can accommodate the item
    can_fit = caps >= item
    if not np.any(can_fit):
        # No bin can hold the item – outside code may decide to open a new bin
        return priorities

    # Remaining capacity if the item is placed
    leftover = caps[can_fit] - item

    # Small index-based bias so that the earliest feasible bin wins when ties occur
    # (the bias is very tiny compared to the leftover values)
    bias = np.arange(np.count_nonzero(can_fit), dtype=float) * 1e-9

    # Rank by smallest leftover (i.e., larger –leftover), break ties with bias
    priorities[can_fit] = -leftover - bias

    return priorities
```
