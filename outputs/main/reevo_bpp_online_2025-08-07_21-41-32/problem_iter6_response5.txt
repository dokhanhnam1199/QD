```python
import numpy as np

# Global RNG for tie‑breaking
_rng = np.random.default_rng()

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin in the online Bin Packing Problem.
    The score is biased toward bins with smaller slack (remaining capacity after
    placing the item) by using an inverse‑slack weighting. The weights are
    normalised to avoid extreme values, a tiny random perturbation is added
    for deterministic tie‑breaking, and infeasible bins receive -inf.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. The bin with the highest score should be
        selected for the item.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.size
    priority = np.full_like(caps, -np.inf, dtype=float)

    if n == 0:
        return priority

    slack = caps - item
    feasible = slack >= 0
    if not np.any(feasible):
        return priority

    eps = 1e-12
    slack_f = slack[feasible]
    # Inverse‑slack weighting (larger when slack is smaller)
    inv_slack = 1.0 / (slack_f + eps)

    # Normalise to keep values bounded (max weight becomes 1.0)
    max_inv = np.max(inv_slack)
    if max_inv > 0:
        inv_slack /= max_inv

    # Random component to bias the decision while retaining some randomness
    rand = _rng.random(inv_slack.shape)

    # Combine bias with randomness; tiny tie‑breaker added for deterministic tie‑breaks
    scores = inv_slack * rand
    scores += _rng.random(inv_slack.shape) * 1e-12

    priority[feasible] = scores
    return priority
```
