```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Softmax‑Based Fit priority function for online Bin Packing.

    For each bin we compute the waste (remaining capacity after placing the item).
    Smaller waste is preferable, so we use a softmax over the negative waste to
    obtain a probability‑like priority. Infeasible bins (remaining capacity < item)
    receive a priority of zero.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each existing bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin, summing to 1 over all feasible bins.
        Bins that cannot accommodate the item receive a score of 0.
    """
    # ---- hyper‑parameters -------------------------------------------------
    temperature = 1.0   # larger -> softer distribution, smaller -> greedier
    gamma = 1.0         # scale of waste penalty (higher = stronger bias to tight fits)

    # Ensure floating point arithmetic
    caps = bins_remain_cap.astype(np.float64, copy=False)

    # Feasibility mask: only bins that can fit the item are considered
    feasible = caps >= item

    # Early exit when no bin can hold the item
    if not np.any(feasible):
        return np.zeros_like(caps, dtype=np.float64)

    # Compute waste for feasible bins (remaining capacity after the item)
    waste = caps - item

    # Logits for the softmax: -γ * waste / temperature (lower waste → higher logit)
    logits = np.full_like(caps, -np.inf, dtype=np.float64)
    logits[feasible] = -gamma * waste[feasible] / temperature

    # Numerical stability: shift logits by their maximum before exponentiation
    max_logit = np.max(logits)          # finite because at least one feasible bin exists
    exp_vals = np.exp(logits - max_logit)

    # Normalise to obtain probabilities (priority scores)
    priorities = exp_vals / np.sum(exp_vals)

    return priorities
```
