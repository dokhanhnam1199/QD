```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    tie_breaker: float = 1e-6,
    tiny_rand_range: float = 1e-6,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks (default 1e-12).
    epsilon : float, optional
        Small constant added to slack to avoid division by zero
        (default 1e-12).
    tie_breaker : float, optional
        Weight applied to the bin index to break ties deterministically.
        Must be small enough not to outweigh the main bias (default 1e-6).
    tiny_rand_range : float, optional
        Scale of the tiny random perturbation added to each bin.
        Keeps randomness low (default 1e-6).
    random_state : np.random.Generator, optional
        Random number generator for reproducibility. If ``None`` a new
        default generator is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins
        receive ``-np.inf`` and will never be selected.
    """
    # Ensure a random generator is available.
    rng = random_state if random_state is not None else np.random.default_rng()

    # Flatten and cast capacities to float.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Compute slack (remaining capacity after placing the item).
    slack = caps - item

    # Determine which bins can accommodate the item (within tolerance).
    feasible = slack >= -tolerance

    # If no bin can hold the item, return all -inf scores.
    if not np.any(feasible):
        return np.full(n_bins, -np.inf, dtype=float)

    # For feasible bins, compute slack_pos (non‑negative slack).
    slack_pos = np.maximum(slack[feasible], 0.0)

    # Base score inversely proportional to slack (higher for tighter fits).
    base = 1.0 / (slack_pos + epsilon)

    # Normalize base scores to the range [0, 1].
    base_norm = base / base.max() if base.max() > 0 else base

    # Weight by the fraction of bins that are feasible.
    feasible_fraction = feasible.sum() / n_bins
    weight = base_norm * feasible_fraction

    # Tiny random component to diversify decisions.
    rand_small = rng.random(n_bins) * tiny_rand_range

    # Deterministic tie‑breaker: lower index gets slightly higher score.
    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker

    # Assemble final scores, initializing infeasible bins to -inf.
    final_score = np.full(n_bins, -np.inf, dtype=float)
    final_score[feasible] = weight + rand_small[feasible] - idx_factor[feasible]

    # Re‑normalize feasible scores to the range [0, 1] (keeps ranking robust).
    feasible_scores = final_score[feasible]
    min_score = feasible_scores.min()
    max_score = feasible_scores.max()
    if max_score > min_score:
        normalized_scores = (feasible_scores - min_score) / (max_score - min_score)
    else:
        normalized_scores = feasible_scores  # all equal; keep as is

    final_score[feasible] = normalized_scores

    return final_score
```
