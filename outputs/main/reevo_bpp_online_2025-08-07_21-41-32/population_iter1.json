[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority vector for a First\u2011Fit bin\u2011packing heuristic.\n    Feasible bins are ranked by *minimal* remaining space after adding the\n    item (the smallest waste is preferred).  Infeasible bins receive a\n    priority of \u2013\u221e so that they are never chosen.  When two feasible\n    bins yield the same waste, the earlier one in the list gets a tiny\n    edge by subtracting a negligible amount proportional to its position.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of all bins.\n\n    Returns:\n        1\u2011D float array of the same shape as bins_remain_cap containing\n        the computed priority for each bin.\n    \"\"\"\n    # Work on a float copy to avoid unintended dtype issues\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Initialise all priorities to \u2212\u221e so infeasible bins are never chosen\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Mask of bins that can accommodate the item\n    can_fit = caps >= item\n    if not np.any(can_fit):\n        # No bin can hold the item \u2013 outside code may decide to open a new bin\n        return priorities\n\n    # Remaining capacity if the item is placed\n    leftover = caps[can_fit] - item\n\n    # Small index-based bias so that the earliest feasible bin wins when ties occur\n    # (the bias is very tiny compared to the leftover values)\n    bias = np.arange(np.count_nonzero(can_fit), dtype=float) * 1e-9\n\n    # Rank by smallest leftover (i.e., larger \u2013leftover), break ties with bias\n    priorities[can_fit] = -leftover - bias\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Return a priority array that implements the Best\u2011Fit strategy.\n\n    For each bin compute the leftover capacity if the item is added:\n        leftover = bins_remain_cap - item\n    A bin is a candidate only if leftover >= 0.  The priority of a candidate bin\n    is the negative of the leftover, i.e. `-(bins_remain_cap - item)`.  \n    This yields a higher priority for bins that would have less free space after\n    packing the item (i.e., \"best fit\").  Infeasible bins are assigned\n    `-np.inf` so they cannot be selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the current remaining capacity in each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; the bin with the largest score will be chosen.\n    \"\"\"\n    # Calculate potential leftover after adding the item\n    leftover = bins_remain_cap - item\n\n    # Identify bins that cannot fit the item\n    infeasible = leftover < 0\n\n    # Base priority: negative leftover, i.e. smallest leftover gets the highest score\n    priority = -leftover\n\n    # Mask infeasible bins with negative infinity so they will not be selected\n    priority[infeasible] = -np.inf\n\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute Worst\u2011Fit priority for each bin.\n\n    The worst\u2011fit strategy always places the next item into the bin with\n    the *largest* remaining free capacity that is large enough to hold\n    the item.  This function returns a score array; the bin with the\n    maximum score is chosen for the item.  Bins that cannot accommodate\n    the item are given a score of -np.inf, ensuring they are never\n    selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin (positive numbers).  Must be 1\u2011D.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores of the same shape as `bins_remain_cap`.  The\n        highest score corresponds to the bin that should receive the\n        item under the worst\u2011fit policy.\n    \"\"\"\n    # Only bins that have enough capacity are considered; others get -inf score\n    valid = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    priorities[valid] = bins_remain_cap[valid]\n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost Full Fit priority function.\n\n    For each bin, compute how tightly the item would fill it.\n    Bins that can accommodate the item receive a priority equal to the\n    negative of the remaining capacity after insertion (so a smaller leftover\n    yields a higher priority). Bins that cannot accommodate the item receive\n    -inf, ensuring they are never selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities of the current bins.\n\n    Returns:\n        A 1\u2011D NumPy array of priority scores (same shape as bins_remain_cap).\n    \"\"\"\n    # Convert to NumPy array for vectorised operations (if not already)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify feasible bins\n    feasible = caps >= item\n\n    # Compute remaining space if the item were placed (only for feasible bins)\n    remaining_after = caps - item\n    remaining_after[~feasible] = np.nan  # Mask out infeasible entries\n\n    # Priority: larger (i.e., less negative) for smaller remaining space.\n    # Use -inf for infeasible bins to guarantee they are not chosen.\n    priorities = np.where(feasible, -remaining_after, -np.inf)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Exact\u2011Fit\u2011First priority function for online Bin Packing.\n\n    The bin with the highest returned score will be chosen for ``item``.\n    Bins that cannot accommodate the item receive ``-np.inf`` so they are\n    never selected. Among feasible bins, a smaller leftover capacity\n    (i.e. a tighter fit) yields a larger priority, and an exact fit\n    (remaining capacity == item) gets the highest possible priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Higher values indicate more attractive bins.\n    \"\"\"\n    # Tiny tolerance to guard against floating\u2011point noise.\n    eps = 1e-12\n\n    # Feasibility mask: bins that have enough space for the item.\n    feasible = bins_remain_cap >= (item - eps)\n\n    # Initialise all priorities to -inf (unfeasible bins).\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Compute leftover capacity if the item were placed.\n    leftover = bins_remain_cap[feasible] - item   # guaranteed >= 0\n\n    # Index\u2011based tiny offset to break ties deterministically\n    # (preferring lower\u2011indexed bins when leftovers are equal).\n    tiny = 1e-12\n    idx = np.where(feasible)[0]\n\n    # Exact\u2011Fit\u2011First: a smaller leftover means higher priority.\n    # Using negative leftover makes an exact fit (leftover == 0) obtain\n    # the largest score (0 before tie\u2011breaking). All other feasible\n    # bins receive negative scores proportional to wasted space.\n    priorities[feasible] = -leftover - idx * tiny\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Inverse Distance (Proximity Fit) priority for the online Bin Packing Problem.\n\n    The priority of a bin is inversely proportional to the leftover space\n    after (hypothetically) placing the item. A tighter fit (smaller leftover)\n    yields a higher priority. Bins that cannot accommodate the item receive a\n    very low priority (\u2212inf) to exclude them from selection.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining free capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as `bins_remain_cap` with a priority score for\n        each bin. The bin with the highest score should be chosen for the item.\n    \"\"\"\n    # Small epsilon prevents division by zero for exact fits\n    EPS = 1e-12\n\n    # Compute how much capacity would remain if we placed the item\n    residual = bins_remain_cap - item\n\n    # Feasible bins have non\u2011negative residual; assign priority = 1/(residual + EPS)\n    # Infeasible bins get a very low priority so they are never selected.\n    priorities = np.where(\n        residual >= 0,\n        1.0 / (residual + EPS),\n        -np.inf\n    )\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority function for the online Bin Packing Problem.\n\n    The idea is to give higher priority to bins that will be tightly packed\n    after the item is placed, while still respecting the feasibility constraint.\n    A logistic (sigmoid) transformation is applied to the normalised residual\n    capacity of each feasible bin.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as ``bins_remain_cap``).  Higher\n        scores indicate a more desirable bin for the item.  Bins that cannot\n        accommodate the item receive ``-np.inf``.\n    \"\"\"\n    # Ensure we work with a NumPy array of floats\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Default: infeasible bins get the lowest possible priority\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Identify bins that are large enough to host the item\n    feasible = caps >= item\n    if not np.any(feasible):\n        # No existing bin can take the item \u2192 caller will likely open a new bin\n        return priorities\n\n    # Residual capacity after placing the item in each feasible bin\n    residual = caps[feasible] - maybe from ... \nI realize the previously truncated text might confuse.\nI'll continue and correct the output.\n\nThe final code should be presented clearly, without comments that cause confusion.\n\nHere is the corrected version:",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41\n    I'll continue and correct the output.\n     ^\nSyntaxError: unterminated string literal (detected at line 41)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41\n    I'll continue and correct the output.\n     ^\nSyntaxError: unterminated string literal (detected at line 41)\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41\n    I'll continue and correct the output.\n     ^\nSyntaxError: unterminated string literal (detected at line 41)\n"
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Random Fit priority. For each bin that can accommodate the item, assigns a random priority score.\n    Bins that cannot accommodate are assigned -np.inf so they are never selected.\n    \n    Selecting the bin with the maximum priority effectively chooses one of the\n    feasible bins uniformly at random, because the maximum of independent\n    uniform draws over the set of feasible bins has a uniform distribution.\n    \n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: Current remaining capacities of all bins.\n    \n    Returns:\n        An array of priority scores where larger score indicates higher priority.\n        Only feasible bins receive a score in [0, 1), others are -np.inf.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Allocate an array of -inf so infeasible bins get lowest priority\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    # Generate random values for feasible bins\n    random_scores = np.random.rand(np.count_nonzero(can_fit))\n    priorities[can_fit] = random_scores\n    return priorities",
    "response_id": 7,
    "obj": 72.96569605105705,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\n# Global configuration for the epsilon\u2011greedy strategy\n_INITIAL_EPSILON = 0.2   # Starting probability of exploration\n_MIN_EPSAY = 0.02       # Minimum exploration probability after decay\n_CALL_COUNT = 0         # Number of times the priority function has been invoked\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Epsilon\u2011greedy priority for online bin packing.\n\n    Exploits a best\u2011fit rule (minimises waste) with probability (1\u2011\u03b5) and\n    explores random feasible bins with probability \u03b5. \u03b5 decays with the\n    number of calls to gradually favour exploitation.\n\n    Returns:\n        np.ndarray: Priority scores for each bin; higher scores denote more\n        desirable bins. Infeasible bins receive -inf priority.\n    \"\"\"\n    global _CALL_COUNT\n    _CALL_COUNT += 1\n\n    # Decaying epsilon: \u03b5 = max(_MIN_EPSILON, _INITIAL_EPSILON / sqrt(call_count))\n    epsilon = max(_MIN_EPSILON, _INITIAL_EPSILON / np.sqrt(_CALL_COUNT))\n\n    # Mask for bins that can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # If no bin can hold the item, return all -inf (caller may open a new bin)\n    if not feasible.any():\n        return priorities\n\n    # --- Exploitation: best\u2011fit (least residual capacity) ---\n    residual = bins_remain_cap - item            # space left after placement\n    best_fit_score = -residual                   # higher score \u2192 less waste\n    best_fit_score[~feasible] = -np.inf\n\n    # --- Exploration: random scoring among feasible bins ---\n    rng = np.random.default_rng()\n    if rng.random() < epsilon:\n        random_score = rng.random(bins_remain_cap.shape)\n        random_score[~feasible] = -np.inf\n        priorities = random_score\n    else:\n        priorities = best_fit_score\n\n    # Tiny jitter to break exact ties deterministically\n    jitter = rng.random(bins_remain_cap.shape) * 1e-8\n    priorities += jitter\n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 23, in priority_v2\n    Bins that cannot accommodate the item receive a score of 0.\nNameError: name '_MIN_EPSILON' is not defined. Did you mean: '_MIN_EPSAY'?\n21\n3\n"
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based Fit priority function for online Bin Packing.\n\n    For each bin we compute the waste (remaining capacity after placing the item).\n    Smaller waste is preferable, so we use a softmax over the negative waste to\n    obtain a probability\u2011like priority. Infeasible bins (remaining capacity < item)\n    receive a priority of zero.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin, summing to 1 over all feasible bins.\n        Bins that cannot accommodate the item receive a score of 0.\n    \"\"\"\n    # ---- hyper\u2011parameters -------------------------------------------------\n    temperature = 1.0   # larger -> softer distribution, smaller -> greedier\n    gamma = 1.0         # scale of waste penalty (higher = stronger bias to tight fits)\n\n    # Ensure floating point arithmetic\n    caps = bins_remain_cap.astype(np.float64, copy=False)\n\n    # Feasibility mask: only bins that can fit the item are considered\n    feasible = caps >= item\n\n    # Early exit when no bin can hold the item\n    if not np.any(feasible):\n        return np.zeros_like(caps, dtype=np.float64)\n\n    # Compute waste for feasible bins (remaining capacity after the item)\n    waste = caps - item\n\n    # Logits for the softmax: -\u03b3 * waste / temperature (lower waste \u2192 higher logit)\n    logits = np.full_like(caps, -np.inf, dtype=np.float64)\n    logits[feasible] = -gamma * waste[feasible] / temperature\n\n    # Numerical stability: shift logits by their maximum before exponentiation\n    max_logit = np.max(logits)          # finite because at least one feasible bin exists\n    exp_vals = np.exp(logits - max_logit)\n\n    # Normalise to obtain probabilities (priority scores)\n    priorities = exp_vals / np.sum(exp_vals)\n\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    First\u2011Fit inspired priority function for online bin packing.\n\n    For each bin, if the item fits (remaining capacity >= item), a priority\n    score is computed that favours bins with smaller index (first bins) while\n    also slightly preferring tighter fits. The bin with the largest score is\n    chosen.\n\n    Parameters\n    ----------\n    item: float\n        Size of the incoming item.\n    bins_remain_cap: np.ndarray\n        1\u2011D array of the remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin, same shape as ``bins_remain_cap``.\n    \"\"\"\n    # Handle empty bin list\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n\n    # Determine which bins can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # Primary first\u2011fit weight: earlier bins get higher weight.\n    # For N bins, bin i gets weight N - i (so bin 0 gets N, bin 1 gets N\u20111, \u2026).\n    N = bins_remain_cap.shape[0]\n    index_weight = N - np.ndarray(np.arange(N), dtype=bins_remain_cap.dtype)\n\n    # Secondary tie\u2011breaker: a tiny bonus for bins that would leave less slack.\n    # Compute slack (remaining capacity after the item would be placed).\n    slack = bins_remain_cap - item\n    # Normalise slack to [0, 1] to keep the bonus small.\n    max_slack = np.max(slack[can_fit]) if np.any(can_fit) else 1.0\n    norm_slack = slack / max_slack\n\n    # Combine the primary first\u2011fit weight with a small epsilon\u2011scaled slack bonus.\n    epsilon = 1e-3\n    priority = np.where(\n        can_fit,\n        index_weight + epsilon * (1.0 - norm_slack),  # higher priority for less slack\n        -np.inf  # bins that cannot fit get the lowest possible priority\n    )\n    return priority",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 34, in priority_v2\nValueError: maximum supported dimension for an ndarray is currently 64, found 5000\n16\n3\n"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin packing problem using a Best\u2011Fit strategy.\n    \n    The returned priorities are such that the bin with the largest score is the bin that,\n    after adding the new item, will have the *smallest* residual capacity.\n    \n    Items that do not fit in a particular bin are assigned a very low priority\n    (negative infinity) so that they are never selected.\n    \n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n    \n    Returns\n    -------\n    np.ndarray\n        Priority scores, one for each bin, identical shape to `bins_remain_cap`.\n    \"\"\"\n    # Capacity left after fitting the item; negative if item cannot fit\n    residual = bins_remain_cap - item\n    \n    # Best\u2011Fit: choose bin with smallest residual \u2192 give priority = -residual\n    # Non\u2011fitting bins are given negative infinity so they are discarded\n    priority = np.where(residual >= 0, -residual, -np.inf)\n    \n    return priority",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function implementing the Worst\u2011Fit strategy for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be placed.\n    bins_remain_cap : np.ndarray\n        Array of current remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores; bins that can hold the item receive a\n        priority equal to the remaining capacity after the placement.\n        Non\u2011fitting bins are assigned a priority of -inf to exclude them.\n    \"\"\"\n    # Prepare array of priorities; start with -inf so that non\u2011fitting bins\n    # are never chosen unless all bins fail.\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Identify bins that have enough capacity to hold the item\n    can_fit = bins_remain_cap >= item\n\n    # Compute priority as the remaining capacity after the item would be added\n    priorities[can_fit] = bins_remain_cap[can_fit] - item\n\n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute priority for each bin according to an Almost Full Fit strategy.\n\n    The algorithm prioritises bins that, after placing the incoming item,\n    will be left with the smallest residual capacity.  This mimics the\n    best\u2011fit principle: use a bin that is already quite full, thereby\n    creating as little wasted space as possible.\n\n    Bins that cannot accommodate the item receive an extremely low\n    priority (`-np.inf`) to effectively remove them from consideration.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be packed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin; the bin with the highest score is\n        chosen by the calling routine.\n    \"\"\"\n    # Ensure a numeric one\u2011dimensional array\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Bin eligibility mask\n    fits = bins_remain_cap >= item\n\n    # Start with a low priority for all bins; \u2013np.inf guarantees that\n    # any fitting bin will dominate\n    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)\n\n    # Residual capacity that would remain after adding the item\n    residuals = bins_remain_cap - item\n\n    # Higher priority \u2192 smaller residual (better fit)\n    # A residual of 0 (perfect fill) gives the maximum score of 0.\n    # Bins with a positive residual give progressively lower scores.\n    priorities[fits] = -residuals[fits]\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function that implements the \"Exact Fit First\" strategy for an\n    online bin\u2011packing problem.  Each bin receives a score; the highest score\n    determines the chosen bin.  Bins that can exactly accommodate the item are\n    favored over those that would leave a larger residue.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of all open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  The item will be placed in the bin\n        with the maximum score.\n    \"\"\"\n    # Ensure we are working with a floating\u2011point array\n    cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Flags for bins that can accommodate the item\n    can_fit = cap >= item\n\n    # Initialize all scores to very negative values (so they cannot be selected)\n    scores = np.full_like(cap, -np.inf)\n\n    if np.any(can_fit):\n        # Compute residual capacity after placing the item\n        leftover = cap[can_fit] - item\n\n        # Higher scores for smaller leftover (best fit).  \n        # Exact fits (leftover == 0) get the highest score (0).\n        scores[can_fit] = -leftover\n\n    return scores",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Inverse Distance (Proximity Fit) priority for online Bin Packing.\n\n    For each bin we compute how closely the remaining capacity matches the\n    item size. Bins that can accommodate the item receive a priority proportional\n    to the inverse of the leftover space after placement (i.e., the smaller the\n    waste, the higher the priority). Bins that cannot fit the item receive a\n    very low priority so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array with the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin. Higher values indicate a more\n        desirable bin for the item.\n    \"\"\"\n    # Numerical stability constant: prevents division by zero when item exactly fills a bin\n    eps = 1e-9\n\n    # Identify bins that can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # Compute waste (remaining capacity after the item would be placed)\n    waste = np.where(feasible, bins_remain_cap - item, np.nan)\n\n    # Inverse distance: higher score for smaller waste\n    # Bins that cannot fit receive -inf to guarantee they are never chosen\n    priorities = np.where(feasible,\n                          1.0 / (waste + eps),\n                          -np.inf)\n\n    # Optional: Scale to non\u2011negative values for downstream components that expect >=0\n    # Shift all finite priorities up by the absolute value of the most negative priority\n    if np.any(np.isfinite(priorities)):\n        min_finite = np.min(priorities[np.isfinite(priorities)])\n        if min_finite < 0:\n            priorities = np.where(np.isfinite(priorities), priorities - min_finite, priorities)\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid\u2011Fit priority for online Bin Packing.\n\n    For each bin we compute the remaining capacity *after* placing the item.\n    Bins that cannot accommodate the item receive a very low (\u2212\u221e) score.\n    Among feasible bins, a logistic (sigmoid) transformation maps the\n    post\u2011packing slack to a priority: bins whose slack is close to a\n    dynamically chosen target slack obtain higher scores, while bins with\n    excessive slack are penalised.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores of the same shape as ``bins_remain_cap``. The bin\n        with the highest score should be selected for the item.\n    \"\"\"\n    # Ensure a NumPy array (float for arithmetic)\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # No bins available \u2013 return empty array\n    # (Edge\u2011case handling; callers may decide to open a new bin)\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n\n    # Slack that would remain after inserting the item\n    residual = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative slack can hold the item\n    feasible = residual >= 0\n\n    # Dynamically choose a desirable slack target.\n    # Here we aim for a slack around half the median remaining capacity,\n    # which balances tight packing and future flexibility.\n    median_cap = np.median(bins_remain_cap)\n    target_slack = 0.5 * median_cap\n\n    # Sigmoid steepness controls how sharply the priority drops\n    # when the slack deviates from the target.\n    steepness = 8.0\n\n    # Logistic transformation (sigmoid):\n    #   score = 1 / (1 + exp(steepness * (residual - target_slack)))\n    # Smaller residual (tighter fit) => larger score.\n    exponent = steepness * (residual - target_slack)\n\n    # Clamp exponent for numerical stability\n    exponent = np.clip(exponent, -50, dtype=float, a_min=-50, a_max=50)\n\n    # Compute raw scores for all bins\n    scores = 1.0 / (1.0 + np.exp(exponent))\n\n    # Infeasible bins receive -inf so they are never selected\n    scores = np.where(feasible, scores, -np.inf)\n\n    return scores",
    "response_id": 16,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 57, in priority_v2\nTypeError: clip() got multiple values for argument 'a_min'\n14\n2\n"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Random Fit priority for online bin packing.\n\n    Each feasible bin (with enough remaining capacity) receives a random score.\n    Infeasible bins receive -inf so they are never selected. This implements a\n    pure random fit strategy, optionally biased toward tighter fits.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each bin.\n\n    Returns:\n        A 1\u2011D array of priority scores, one per bin.\n    \"\"\"\n    # Ensure capacities are a float array.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    feasible = caps >= item\n\n    # Initialise all priorities to -inf (so infeasible bins are never chosen).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Generate independent random numbers for each bin.\n    rand_scores = np.random.rand(caps.size)\n\n    # Bias towards tighter fits: less slack -> larger bias.\n    # Small epsilon avoids division by zero for exact fits.\n    epsilon = 1e-12\n    slack = caps - item\n    bias = np.zeros_like(caps)\n    bias[feasible] = 1.0 / (slack[feasible] + epsilon)  # higher when slack is small\n\n    # Combine random component with bias.\n    # Multiplying emphasizes bins with higher bias while preserving randomness.\n    priorities[feasible] = bias[feasible] * rand_scores[feasible]\n\n    return priorities",
    "response_id": 17,
    "obj": 3.9988033506182825,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"\n    Returns a priority vector for each bin using an epsilon\u2011greedy strategy.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of the remaining capacities of the bins.\n        epsilon: Exploration probability (0 \u2264 epsilon \u2264 1). With probability `epsilon`\n                 the function assigns random priorities to encourage exploration.\n                 Otherwise it uses a best\u2011fit exploitation rule.\n\n    Returns:\n        A NumPy array of the same shape as `bins_remain_cap` with a priority score for\n        each bin. Higher scores are preferred. Infeasible bins receive `-np.inf`.\n    \"\"\"\n    # Ensure bins_remain_cap is a 1\u2011D NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Feasibility mask: bin can accommodate the item\n    feasible = bins_remain_cap >= item\n\n    # Initialise priorities with -inf (so infeasible bins are never chosen)\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)\n\n    # If no bin can accommodate the item, return all -inf\n    if not np.any(feasible):\n        return priorities\n\n    # Decide whether to explore or exploit this step\n    if np.random.rand() < epsilon:\n        # Exploration: assign a random score to each feasible bin\n        priorities[feasible] = np.random.rand(np.sum(feasible))\n    else:\n        # Exploitation: Best\u2011Fit \u2013 minimise leftover space after packing\n        # leftover capacity if the item were placed\n        leftover = bins_remain_cap[feasible] - item\n        # Larger priority for smaller leftover; perfect fit (leftover=0) gets priority 0\n        priorities[feasible] = -leftover\n\n    return priorities",
    "response_id": 18,
    "obj": 4.178300757877951,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Compute Softmax-based priority scores for each bin.\n\n    The function penalizes bins by the leftover space after packing `item`.\n    Bins that cannot accommodate `item` receive zero priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores with shape equal to bins_remain_cap.\n        Larger scores indicate bins that fit `item` more tightly.\n    \"\"\"\n    bins = bins_remain_cap\n    mask = bins >= item\n    if not mask.any():\n        # No bin can fit the item \u2013 the algorithm will create a new bin\n        return np.zeros_like(bins, dtype=float)\n    # Compute a score that is larger for a bin with a smaller leftover\n    base = np.full_like(bins, -np.inf, dtype=float)\n    base[mask] = -(bins[mask] - item)  # -leftover\n    # Numerical stability\n    max_base = np.max(base[mask])\n    exp_val = np.zeros_like(base)\n    exp_val[mask] = np.exp((base[mask] - max_base))\n    return exp_val / np.sum(exp_val)",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin based on a First-Fit strategy.\n\n    The bin with the highest priority score will be chosen for packing the item.\n    Here we give higher priority to bins that can accommodate the item and\n    that appear earlier in the list (smaller index).  Bins that cannot\n    accommodate the item receive a very low priority.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.  The higher the value, the\n        more preferable the bin.\n    \"\"\"\n    n = bins_remain_cap.size\n    # Determine which bins can hold the item\n    can_fit = bins_remain_cap >= item\n    # Assign high priority to earlier bins that can fit\n    # Using a large constant so that later bins still have priority > -inf,\n    # but earlier bins dominate\n    LARGE_PRIO = 1e9\n    priorities = np.full(n, -np.inf, dtype=float)\n    indices = np.arange(n)\n    if np.any(can_fit):\n        priorities[can_fit] = LARGE_PRIO - indices[can_fit]\n    return priorities",
    "response_id": 20,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit inspired priority for online Bin Packing.\n\n    The priority is higher when a bin would be left with as little free\n    capacity as possible after placing ``item`` \u2013 i.e. the bin that fits the\n    item most tightly.  Bins that cannot accommodate the item receive a\n    score of ``-np.inf`` so they are never selected.  In case of ties,\n    a deterministic tie\u2011breaker favouring bins with smaller indices is\n    applied.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        One\u2011dimensional array of remaining free capacity for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of the same shape as ``bins_remain_cap`` containing a priority\n        score for each bin.  The bin with the highest score should be chosen.\n    \"\"\"\n    # Ensure a NumPy array with float dtype for safe arithmetic\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Slack that would remain if we placed the item into each bin\n    slack = bins_remain_cap - item               # feasible if slack >= 0\n    feasible = slack >= 0\n\n    # Linear indices for deterministic tie\u2011breaking (same shape as bins)\n    idx = np.arange(bins_remain_cap.size, dtype=float).reshape(bins_remain_cap.shape)\n\n    # Base priority: negative slack (larger = tighter fit)\n    # Infeasible bins get -inf so they are never chosen\n    base_priority = np.where(feasible, -slack, -np.inf)\n\n    # Tiny index\u2011based penalty to break ties in favour of lower indices\n    # 1e-12 is negligible compared to typical slack magnitudes.\n    tie_breaker = 1e-12 * idx\n\n    priorities = base_priority - tie_breaker\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Worst\u2011Fit priority for online bin packing.\n\n    The function returns a score for each bin; the bin with the highest score\n    (i.e. the most free space after the item would be placed) is selected.\n    Infeasible bins (those that cannot accommodate the item) receive a very\n    low priority so they are never chosen.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        An ndarray of the same shape as ``bins_remain_cap`` containing priority\n        scores.\n    \"\"\"\n    # Ensure we are working with a float array (required for inf handling)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Feasibility mask: True if the bin can hold the item\n    feasible = caps >= item\n\n    # Residual capacity after hypothetically placing the item\n    residual = caps - item\n\n    # Assign -inf to infeasible bins so they are never the argmax\n    low_priority = -np.inf\n    priorities = np.where(feasible, residual, low_priority)\n\n    # Tiny random tie\u2011breaker to avoid deterministic ties when residuals are equal\n    # (adds a negligible epsilon that does not affect ordering)\n    epsilon = np.random.rand(priorities.size) * 1e-12\n    priorities = np.where(feasible, priorities + epsilon, priorities)\n\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for assigning ``item`` to each bin in ``bins_remain_cap``.\n    \n    The heuristic follows the *Almost Full Fit* principle:\n      * Prefer bins where the item fits and leaves the *smallest* leftover space,\n        i.e., bins that become almost full after insertion.\n      * If the resulting leftover is below a small threshold (``eps``), an\n        additional boost is added to strongly favour such bins.\n      * Bins that cannot accommodate the item receive a large negative priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    #\"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after (hypothetical) placement\n    leftover = bins_remain_cap - item\n\n    # Feasibility mask: bins that can actually hold the item\n    feasible = leftover >= 0\n\n    # Base priority: higher when the resulting leftover is smaller\n    base_priority = -leftover\n\n    # Extra boost for bins that become \u201calmost full\u201d\n    eps = 0.1               # tolerance defining \u201calmost full\u201d\n    boost_factor = 10.0     # magnitude of the boost\n    boost = np.where(leftover <= eps, (eps - leftover) * boost_factor, 0.0)\n\n    # Combine base priority and boost; infeasible bins get -inf\n    priorities = np.where(feasible, base_priority + boost, -np.inf)\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact Fit First priority function for online Bin Packing.\n\n    For each bin this function returns a score that is extremely high if the\n    item would fill the bin exactly.  If the bin is not an exact fit, the\n    score decreases as the remaining capacity after placement increases,\n    thereby preferring bins that will leave the smallest leftover space.\n\n    Parameters\n    ----------\n    item : float\n        The size of the incoming item to pack.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Same shape as `bins_remain_cap`; larger values indicate a higher\n        priority to add the item to that bin.\n    \"\"\"\n    EPS = 1e-12          # tolerance for numerical equality\n    INF_HIGH = 1e6       # a large value that outranks all other scores\n\n    # Ensure numeric numpy array\n    bins = np.asarray(bins_remain_cap, dtype=float)\n\n    # Mask of bins that can accommodate the item\n    usable = bins >= item - EPS\n    # Remaining capacity after placing the item\n    remaining_after = bins - item\n\n    # Initialise priorities with -inf (unfit bins)\n    priorities = np.full_like(bins, -np.inf, dtype=float)\n\n    # Bins where the item will fit exactly\n    exact_fit = np.abs(remaining_after) <= EPS\n    if np.any(exact_fit):\n        priorities[exact_fit] = INF_HIGH\n\n    # Other usable bins: prioritize smallest leftover space\n    other_usable = usable & ~exact_fit\n    if np.any(other_usable):\n        # 1/(remaining+1) is larger when remaining is smaller.\n        priorities[other_usable] = 1.0 / (remaining_after[other_usable] + 1.0)\n\n    return priorities",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for placing an item into each bin based on the Inverse Distance (Proximity Fit) strategy.\n    The score is inversely proportional to the leftover capacity after adding the item.\n    Bins that cannot accommodate the item receive a very low priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be added.\n    bins_remain_cap : np.ndarray\n        Array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one for each bin, with higher values indicating better fit.\n    \"\"\"\n    # Small epsilon to avoid division by zero when the leftover is zero.\n    eps = 1e-12\n\n    # Boolean mask for bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n\n    # Compute leftover capacity after adding the item\n    leftover = bins_remain_cap - item\n\n    # Inverse distance priority: larger when leftover is small\n    # Non-fitting bins are assigned a large negative constant\n    inv_priority = np.where(\n        can_fit,\n        1.0 / (leftover + eps),   # priority grows as leftover shrinks\n        -1e12                      # severe penalty for infeasible bins\n    )\n\n    # Optional exploration bias: prefer emptier bins when priorities tie.\n    # The bias is tiny compared to the inverse terms and favors smaller bin indices.\n    bias = 1e-6 * (np.max(bins_remain_cap) - bins_remain_cap)\n    priorities = inv_priority + bias\n\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority: higher priority for bins that will be filled more tightly.\n    \n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores, same shape as `bins_remain_cap`. \n        Bins that cannot accommodate the item receive -inf priority.\n    \"\"\"\n    # Ensure we work on float array\n    bins_remain_cap = bins_remain_cap.astype(float, copy=False)\n\n    # Compute mask of bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    # Initialise all scores to negative infinity (unfit bins)\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    if np.any(fit_mask):\n        # Excess space after placing the item\n        deficit = bins_remain_cap[fit_mask] - item  # non\u2011negative\n        \n        # Logistic\u2011type mapping: 1.0 at deficit = 0, approaching 0 as deficit grows\n        # 2.0 / (1 + exp(k * deficit)) squeezes the values into (0,1]\n        k = 5.0  # slope parameter \u2013 can be tuned\n        exp_term = np.exp(np.clip(k * deficit, None, 700))  # clip to avoid overflow\n        scores[fit_mask] = 2.0 / (1.0 + exp_term)\n\n    return scores",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\n# Global random generator (you can seed it externally if reproducibility is needed)\n_rng = np.random.default_rng()\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Random Fit priority function for online Bin Packing.\n\n    Each bin that can accommodate the incoming item receives a random priority, while\n    bins that cannot fit the item are assigned a very low priority (negative infinity)\n    so they are never selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each existing bin.\n\n    Returns:\n        A NumPy array of the same shape as ``bins_remain_cap`` containing priority\n        scores for each bin. The bin with the highest priority will be chosen.\n    \"\"\"\n    # Ensure we are working with a NumPy array of floats\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Boolean mask: True where the bin can hold the item\n    can_fit = caps >= item\n\n    # Random priority for every bin (uniform in [0, 1))\n    random_priorities = _rng.random(size=caps.shape)\n\n    # Infeasible bins get -inf to guarantee they are never the max\n    priorities = np.where(can_fit, random_priorities, -np.inf)\n\n    return priorities",
    "response_id": 27,
    "obj": 73.14519345831671,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\n# Probability of exploring a random bin instead of the best fit\n_EPSILON = 0.15  # tweak as needed\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority for each bin using an \u03b5\u2011greedy strategy.\n\n    * Exploitation (probability 1\u2011\u03b5): choose the tightest\u2011fit bin,\n      i.e. the bin that leaves the smallest leftover capacity after the item is placed.\n    * Exploration (probability \u03b5): assign random scores to all *feasible* bins.\n\n    Bins that cannot accommodate the item receive a priority of -inf so they will\n    never be selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        np.ndarray of the same shape as ``bins_remain_cap`` containing priority scores.\n    \"\"\"\n    # Initialise all priorities to -inf (infeasible)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask of bins that can actually hold the item\n    feasible = bins_remain_cap >= item\n    if not feasible.any():\n        # No feasible bin \u2013 we just return the -inf vector\n        return priorities\n\n    if np.random.rand() < _EPSILON:\n        # --- Exploration ----------------------------------------------------\n        # Random scores (uniform in [0,1]) for feasible bins\n        random_scores = np.random.rand(bins_remain_cap.shape[0])\n        priorities[feasible] = random_scores[feasible]\n    else:\n        # --- Exploitation ---------------------------------------------------\n        # Tightest fit: smallest leftover = highest priority.\n        # Using negative leftover turns \u201csmaller is better\u201d into \u201clarger is better\u201d.\n        leftover = bins_remain_cap[feasible] - item\n        priorities[feasible] = -leftover\n\n    return priorities",
    "response_id": 28,
    "obj": 4.327881930594345,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based Fit priority for online bin packing.\n\n    The priority for a bin i is proportional to exp(\u2212slack_i / \u03c4),\n    where slack_i = bins_remain_cap[i] \u2212 item. Bins that cannot accommodate\n    the item receive a priority of -inf so they are never selected.\n    The temperature \u03c4 is adapted to the current dispersion of remaining\n    capacities: a higher variance yields a softer (higher\u2011temperature) distribution.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of all currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (one per bin). The bin with the highest\n        score should be chosen.\n    \"\"\"\n    # Compute slack (remaining space after placing the item)\n    slack = bins_remain_cap - item\n\n    # Feasibility mask: only consider bins with non\u2011negative slack\n    feasible = slack >= 0\n\n    # If no bin can accommodate the item, return an array of -inf priorities\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Adaptive temperature \u03c4: scale with the variability of the remaining capacities.\n    # Use a baseline to avoid extremely low \u03c4.\n    eps = 1e-12\n    std_cap = np.std(bins_remain_cap)\n    tau = max(0.1, std_cap)  # baseline of 0.1 ensures a sensible temperature\n\n    # Compute scaled negative slack for feasible bins\n    scaled = -slack[feasible] / tau\n\n    # Numerical stability: subtract the max before exponentiation\n    max_scaled = np.max(scaled)\n    exp_vals = np.exp(scaled - max_scaled)\n\n    # Initialize priorities with -inf for infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Assign softmax scores to feasible bins\n    priorities[feasible] = exp_vals\n\n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]