```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:
    """
    Returns a priority vector for each bin using an epsilon‑greedy strategy.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of the remaining capacities of the bins.
        epsilon: Exploration probability (0 ≤ epsilon ≤ 1). With probability `epsilon`
                 the function assigns random priorities to encourage exploration.
                 Otherwise it uses a best‑fit exploitation rule.

    Returns:
        A NumPy array of the same shape as `bins_remain_cap` with a priority score for
        each bin. Higher scores are preferred. Infeasible bins receive `-np.inf`.
    """
    # Ensure bins_remain_cap is a 1‑D NumPy array of floats
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Feasibility mask: bin can accommodate the item
    feasible = bins_remain_cap >= item

    # Initialise priorities with -inf (so infeasible bins are never chosen)
    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=float)

    # If no bin can accommodate the item, return all -inf
    if not np.any(feasible):
        return priorities

    # Decide whether to explore or exploit this step
    if np.random.rand() < epsilon:
        # Exploration: assign a random score to each feasible bin
        priorities[feasible] = np.random.rand(np.sum(feasible))
    else:
        # Exploitation: Best‑Fit – minimise leftover space after packing
        # leftover capacity if the item were placed
        leftover = bins_remain_cap[feasible] - item
        # Larger priority for smaller leftover; perfect fit (leftover=0) gets priority 0
        priorities[feasible] = -leftover

    return priorities
```
