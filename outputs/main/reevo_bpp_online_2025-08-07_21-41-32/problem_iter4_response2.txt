```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    bin_ages: Optional[np.ndarray] = None,
    temperature: float = 1.0,
    lookahead_items: Optional[np.ndarray] = None,
    random_state: Optional[int] = None,
) -> np.ndarray:
    """
    Compute a priority score for each bin in an online bin‑packing setting.

    The heuristic blends an exact‑fit bias with a worst‑fit component,
    optionally incorporates look‑ahead information and bin (age) information,
    and finally applies a temperature‑scaled exponential transformation to
    encourage exploration. Infeasible bins receive a score of -inf.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.
    bin_ages : np.ndarray, optional
        1‑D array (same length as ``bins_remain_cap``) indicating the age of
        each bin (e.g., number of items already placed). Older bins receive a
        small boost to encourage closing them.
    temperature : float, default 1.0
        Controls the softness of the exponential scaling. Must be > 0.
        Lower values make the algorithm greedier.
    lookahead_items : np.ndarray, optional
        Array of sizes of upcoming items. A bin that can still accommodate many
        look‑ahead items receives a boost.
    random_state : int, optional
        Seed for the internal RNG used for tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better). Infeasible bins have -inf.
    """
    eps = 1e-12  # tiny epsilon to avoid division by zero

    # Guard temperature
    temperature = max(temperature, eps)

    # Prepare capacities
    caps = np.asarray(bins_remain_cap, dtype=float).copy()
    n_bins = caps.size

    # Initialise priorities with -inf (infeasible by default)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Feasibility mask
    feasible = caps >= item
    if not np.any(feasible):
        return priorities  # nothing fits

    # ------------------------------------------------------------------
    # 1. Core exact‑fit / worst‑fit scores
    # ------------------------------------------------------------------
    slack = caps - item                     # remaining space after placement
    slack_feas = slack[feasible]

    # Exact‑fit: prefers tiny slack (i.e., tight fit)
    exact_fit = 1.0 / (slack_feas + eps)    # larger when waste is small

    # Worst‑fit: prefers large slack (i.e., keep space for future large items)
    worst_fit = slack_feas / (np.max(caps) + eps)  # normalized to [0, 1]

    # Blend them (weights sum to 1)
    w_exact = 0.6
    w_worst = 0.4
    core_score = w_exact * exact_fit + w_worst * worst_fit

    # ------------------------------------------------------------------
    # 2. Optional look‑ahead boost
    # ------------------------------------------------------------------
    if lookahead_items is not None and lookahead_items.size > 0:
        lookahead = np.asarray(lookahead_items, dtype=float)

        # Boolean matrix: (n_feasible, n_lookahead) – True if lookahead item fits
        fits = lookahead[None, :] <= slack_feas[:, None]
        # Fraction of look‑ahead items that could still be placed after this item
        lookahead_frac = fits.mean(axis=1)  # in [0, 1]

        lookahead_weight = 0.3
        core_score *= (1.0 + lookahead_weight * lookahead_frac)

    # ------------------------------------------------------------------
    # 3. Optional bin‑age boost
    # ------------------------------------------------------------------
    if bin_ages is not None:
        ages = np.asarray(bin_ages, dtype=float)
        if ages.shape != caps.shape:
            raise ValueError("bin_ages must have the same shape as bins_remain_cap")
        # Normalise ages to [0, 1]
        age_norm = ages / (np.max(ages) + eps)
        age_weight = 0.2
        age_factor = 1.0 + age_weight * age_norm
        core_score *= age_factor[feasible]

    # ------------------------------------------------------------------
    # 4. Temperature‑scaled exponential scaling (softmax‑like)
    # ------------------------------------------------------------------
    exp_score = np.exp(core_score / temperature)

    # ------------------------------------------------------------------
    # 5. Tiny random tie‑breaker for numerical stability / exploration
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    tie_eps = 1e-8
    exp_score += rng.random(exp_score.shape) * tie_eps

    # Fill the priorities array for feasible bins
    priorities[feasible] = exp_score

    return priorities
```
