```python
import numpy as np
from typing import Optional

def priority_v2(item: float, bins_remain_cap: np.ndarray, random_state: Optional[int] = None) -> np.ndarray:
    """
    Compute a priority score for each bin in an online bin‑packing setting.

    This version uses a simple leftover‑based exponential boost with an
    adaptive epsilon. Infeasible bins receive ``-np.inf`` so they are never
    selected. A tiny random perturbation is added for deterministic
    tie‑breaking.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently open bin.
    random_state : int, optional
        Seed for the random number generator used for tie‑breaking noise.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher values indicate a more
        desirable placement. Infeasible bins have ``-np.inf``.
    """
    # Ensure capacities are a float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Compute leftover capacity after placing the item
    leftover = caps - item

    # Feasible bins are those that can accommodate the item
    feasible = leftover >= 0

    # Adaptive epsilon: use mean leftover of feasible bins, with a lower bound
    if np.any(feasible):
        eps = max(np.mean(leftover[feasible]), 1e-9)
    else:
        # No feasible bin – epsilon is irrelevant but must be > 0
        eps = 1e-9

    # Exponential boost: highest when leftover ≈ 0, decays for larger leftovers
    boost = np.exp(-leftover / eps)

    # Assemble priority: boost for feasible bins, -inf otherwise
    priority = np.where(feasible, boost, -np.inf)

    # Tiny random noise for tie‑breaking (deterministic if random_state set)
    rng = np.random.default_rng(random_state)
    noise = rng.random(priority.shape) * 1e-12
    priority[feasible] += noise[feasible]

    return priority
```
