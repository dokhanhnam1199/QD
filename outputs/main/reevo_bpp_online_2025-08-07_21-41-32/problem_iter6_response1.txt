```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    low_percentile: float = 0.10,
    boost_factor: float = 5.0,
    random_state: Optional[int] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    For each existing bin the function returns a score; the bin with the highest
    score is selected for the incoming ``item``.  The heuristic combines:

    1. **Adaptive inverse‑slack bias** – bins that would have less remaining
       capacity after placement receive a larger base score.
    2. **Low‑percentile slack boost** – bins whose post‑placement slack falls
       below a low percentile (default 10 %) are boosted, encouraging the
       algorithm to fill “almost full’’ bins.
    3. **Tiny random tie‑breaker** – a minute random perturbation to break ties
       while preserving the deterministic bias.

    Infeasible bins (those that cannot accommodate the item) receive ``-np.inf``,
    guaranteeing they are never chosen.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.
    low_percentile : float, optional
        Percentile (0‑1) used to define “almost full’’ bins. Default is 0.10.
    boost_factor : float, optional
        Multiplier controlling the magnitude of the low‑percentile boost.
        Default is 5.0.
    random_state : int, optional
        Seed for reproducible random tie‑breaking.

    Returns
    -------
    np.ndarray
        1‑D array of priority scores (higher is better). Infeasible bins are
        marked with ``-np.inf``.
    """
    # Convert to float array and handle empty input
    caps = np.asarray(bins_remain_cap, dtype=float)
    if caps.size == 0:
        return np.array([], dtype=float)

    # Slack after hypothetically placing the item
    slack = caps - item
    feasible = slack >= 0

    # Initialise all scores as -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Early exit if no bin can accommodate the item
    if not np.any(feasible):
        return priorities

    # ------------------------------------------------------------------
    # 1) Adaptive epsilon and inverse‑slack bias
    # ------------------------------------------------------------------
    slack_feas = slack[feasible]
    mean_slack = np.mean(slack_feas)
    # Scale epsilon with typical slack magnitude to avoid division‑by‑zero
    eps = max(1e-12, 1e-6 * mean_slack)
    inv_slack = 1.0 / (slack_feas + eps)  # larger when slack is smaller

    # ------------------------------------------------------------------
    # 2) Low‑percentile slack boost
    # ------------------------------------------------------------------
    # Determine threshold below which bins are considered “almost full”
    if slack_feas.size > 0:
        threshold = np.quantile(slack_feas, low_percentile)
    else:
        threshold = 0.0

    # Linear boost proportional to distance below the threshold
    boost = np.zeros_like(slack_feas)
    low_mask = slack_feas <= threshold
    boost[low_mask] = boost_factor * (threshold - slack_feas[low_mask])

    # ------------------------------------------------------------------
    # 3) Combine deterministic components
    # ------------------------------------------------------------------
    combined = inv_slack + boost

    # Normalise to the range [0, 1] (preserves ordering)
    max_combined = np.max(combined) + eps
    combined_norm = combined / max_combined

    # ------------------------------------------------------------------
    # 4) Tiny random tie‑breaker
    # ------------------------------------------------------------------
    rng = np.random.default_rng(random_state)
    tie_eps = 1e-8
    jitter = tie_eps * rng.random(combined_norm.shape)
    final_score = combined_norm + jitter

    # Store the computed scores back into the full array
    priorities[feasible] = final_score

    return priorities
```
