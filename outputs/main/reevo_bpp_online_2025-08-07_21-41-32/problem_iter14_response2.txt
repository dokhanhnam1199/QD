```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin packing setting.

    The priority is calculated as follows:
    1. Feasibility check with a tiny tolerance.
    2. Inverse‑slack bias (larger for tighter fits).
    3. Normalise bias to [0, 1].
    4. Weight bias by the fraction of feasible bins.
    5. Multiply the weighted bias by a uniform random number in [0, 1).
    6. Re‑normalise the blended value to [0, 1].
    7. Add a deterministic tie‑breaker that slightly favours lower‑index bins.
    8. Infeasible bins receive -np.inf so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; the bin with the highest score will
        be selected for the item.
    """
    # Constants
    _TOL = 1e-12          # Feasibility tolerance
    _EPS = 1e-12          # Small epsilon to avoid division by zero
    _TIE = 1e-12          # Deterministic tie‑breaker magnitude

    # Ensure a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask (allow a tiny tolerance)
    feasible = caps >= (item - _TOL)

    # Initialise all priorities to -inf (infeasible bins)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Slack after placing the item
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Inverse‑slack bias: larger for tighter fits
    bias = 1.0 / (slack + _EPS)

    # Normalise bias to [0, 1]
    bias_norm = bias / (bias.max() + _EPS)

    # Weight bias by the fraction of feasible bins
    feasible_frac = feasible.sum() / n_bins
    weighted_bias = bias_norm * feasible_frac

    # Random component in [0, 1)
    rng = np.random.default_rng()
    rand = rng.random(feasible.sum())

    # Blend bias and randomness multiplicatively
    blended = weighted_bias * rand

    # Re‑normalise blended scores to [0, 1]
    blended_norm = blended / (blended.max() + _EPS)

    # Deterministic tie‑breaker: lower index → slightly higher priority
    indices = np.arange(n_bins)[feasible]
    tie_breaker = -indices * _TIE

    # Final priority for feasible bins
    priorities[feasible] = blended_norm + tie_breaker

    return priorities
```
