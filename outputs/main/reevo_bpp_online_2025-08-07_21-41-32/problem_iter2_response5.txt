```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for assigning ``item`` to each bin in ``bins_remain_cap``.

    This heuristic blends a tight‑fit bias (inverse slack) with a controlled
    random component.  The boost for “almost full” bins is set dynamically
    based on a low‑percentile slack threshold, and the epsilon used in the
    inverse‑slack term adapts to the typical slack magnitude.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        A 1‑D array of priority scores (higher is better).  Infeasible bins
        receive ``-np.inf`` so they are never selected.
    """
    # Ensure a float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Slack after hypothetically placing the item
    slack = caps - item

    # Feasibility mask: only bins that can hold the item
    feasible = slack >= 0

    # Initialise all priorities to -inf (infeasible bins)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # If no feasible bin exists, return the all -inf array early
    if not np.any(feasible):
        return priorities

    # ------------------------------------------------------------------
    # 1) Tight‑fit bias: inverse of slack (smaller slack → larger priority)
    #    epsilon adapts to the typical slack magnitude to avoid division‑by‑zero
    # ------------------------------------------------------------------
    mean_slack = np.mean(slack[feasible]) if np.any(feasible) else 0.0
    eps = max(1e-12, 1e-6 * mean_slack)               # adaptive epsilon
    inv_slack = 1.0 / (slack[feasible] + eps)        # larger for tighter fits

    # ------------------------------------------------------------------
    # 2) Dynamic boost for “almost full” bins
    #    Use a low percentile (e.g., 10th) of the slack distribution as a threshold
    # ------------------------------------------------------------------
    low_percentile = 0.10
    slack_feas = slack[feasible]
    threshold = np.quantile(slack_feas, low_percentile) if slack_feas.size > 0 else 0.0

    boost_factor = 5.0                               # magnitude of boost
    boost = np.zeros_like(slack_feas)
    low_slack_mask = slack_feas <= threshold
    boost[low_slack_mask] = boost_factor * (threshold - slack_feas[low_slack_mask])

    # ------------------------------------------------------------------
    # 3) Combine bias and boost
    # ------------------------------------------------------------------
    combined = inv_slack + boost

    # ------------------------------------------------------------------
    # 4) Controlled randomness: a random factor close to 1 (e.g., [0.8, 1.0])
    #    This keeps the bias dominant while providing tie‑breaking randomness.
    # ------------------------------------------------------------------
    rand_vals = np.random.rand(caps.size)
    rand_factor = 0.8 + 0.2 * rand_vals               # range [0.8, 1.0]
    final_feasible = combined * rand_factor[feasible]

    # Assign computed priorities back to the full array
    priorities[feasible] = final_feasible

    return priorities
```
