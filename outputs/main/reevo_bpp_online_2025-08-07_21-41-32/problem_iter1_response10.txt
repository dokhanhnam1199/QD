```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    First‑Fit inspired priority function for online bin packing.

    For each bin, if the item fits (remaining capacity >= item), a priority
    score is computed that favours bins with smaller index (first bins) while
    also slightly preferring tighter fits. The bin with the largest score is
    chosen.

    Parameters
    ----------
    item: float
        Size of the incoming item.
    bins_remain_cap: np.ndarray
        1‑D array of the remaining capacities of the existing bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin, same shape as ``bins_remain_cap``.
    """
    # Handle empty bin list
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Determine which bins can accommodate the item
    can_fit = bins_remain_cap >= item

    # Primary first‑fit weight: earlier bins get higher weight.
    # For N bins, bin i gets weight N - i (so bin 0 gets N, bin 1 gets N‑1, …).
    N = bins_remain_cap.shape[0]
    index_weight = N - np.ndarray(np.arange(N), dtype=bins_remain_cap.dtype)

    # Secondary tie‑breaker: a tiny bonus for bins that would leave less slack.
    # Compute slack (remaining capacity after the item would be placed).
    slack = bins_remain_cap - item
    # Normalise slack to [0, 1] to keep the bonus small.
    max_slack = np.max(slack[can_fit]) if np.any(can_fit) else 1.0
    norm_slack = slack / max_slack

    # Combine the primary first‑fit weight with a small epsilon‑scaled slack bonus.
    epsilon = 1e-3
    priority = np.where(
        can_fit,
        index_weight + epsilon * (1.0 - norm_slack),  # higher priority for less slack
        -np.inf  # bins that cannot fit get the lowest possible priority
    )
    return priority
```
