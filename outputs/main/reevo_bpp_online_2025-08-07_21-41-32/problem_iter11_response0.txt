```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing that:
    - Prioritises exact‑fit bins.
    - Scores feasible bins by 1/(slack+ε) (higher for tighter fits).
    - Adds a tiny deterministic random tie‑breaker seeded per bin.
    - Falls back to a deterministic index tie‑breaker (lower index wins).
    - Vectorised, with tolerance checks and guard against division‑by‑zero.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.size

    # Tolerance for feasibility check
    tolerance = 1e-12
    feasible = caps >= (item - tolerance)

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Compute slack for feasible bins, ensuring non‑negative values
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Bias: higher when slack is smaller
    eps = 1e-12
    bias = 1.0 / (slack + eps)

    # Optional weighting by the fraction of feasible bins
    feasible_frac = feasible.sum() / n_bins
    weighted_bias = bias * feasible_frac

    # Deterministic tiny random component per bin (seeded by index)
    indices = np.arange(n_bins)
    # Use a simple hash‑like function for reproducibility
    rand_vals = np.sin(indices[feasible] * 12.9898 + 78.233) * 43758.5453
    rand_vals = rand_vals % 1.0
    rand_component = rand_vals * 1e-6  # tiny magnitude

    # Deterministic index tie‑breaker (lower index gets a slight advantage)
    index_tie = -indices[feasible] * 1e-12

    # Combine all components to form final priority scores
    priorities[feasible] = weighted_bias + rand_component + index_tie

    return priorities
```
