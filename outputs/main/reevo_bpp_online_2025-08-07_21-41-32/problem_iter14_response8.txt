```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    eps: float = 1e-12,
    rng: Optional[np.random.Generator] = None,
    random_weight: float = 1e-6,
) -> np.ndarray:
    """
    Priority function for online bin packing.

    Computes a score for each currently open bin. Higher scores indicate bins
    that are more desirable for placing ``item``. The score combines:
      * a bias toward tighter fits (smaller slack),
      * weighting of that bias by the fraction of feasible bins,
      * a low‑magnitude random perturbation for stochastic tie‑breaking,
      * a deterministic tie‑breaker that prefers lower‑indexed bins.

    Infeasible bins receive ``-np.inf`` so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    eps : float, optional
        Small constant used for numerical tolerance and to avoid division by zero.
    rng : np.random.Generator, optional
        Random number generator for reproducibility. If ``None``, a new default RNG is created.
    random_weight : float, optional
        Scaling factor for the random component (kept small to limit randomness).

    Returns
    -------
    np.ndarray
        Array of priority scores (shape ``(n_bins,)``). Infeasible bins have ``-inf``.
    """
    # Normalise input to a flat float array.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask: bin can accommodate the item (allow tiny tolerance).
    feasible = caps >= (item - eps)

    # Initialise all priorities as -inf (infeasible bins).
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can accommodate the item.
        return priorities

    # Slack after placing the item (clip to zero to avoid negative values from rounding).
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Fraction of bins that are feasible.
    feasible_frac = feasible.sum() / n_bins

    # Bias toward tighter fits: larger when slack is smaller.
    # Weight the bias by the feasible fraction.
    bias = (1.0 / (slack + eps)) * feasible_frac

    # Random component: low‑magnitude stochastic perturbation.
    if rng is None:
        rng = np.random.default_rng()
    rand = rng.random(bias.shape) * random_weight

    # Deterministic tie‑breaker: favor lower‑index bins by a tiny decrement.
    # Use the same epsilon magnitude to keep it negligible compared to bias.
    indices = np.nonzero(feasible)[0]
    tie_breaker = -indices.astype(float) * eps

    # Combine components.
    scores = bias + rand + tie_breaker

    # Assign scores to feasible bins.
    priorities[feasible] = scores

    return priorities
```
