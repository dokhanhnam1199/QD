```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each open bin in an online Bin Packing setting.

    The priority combines a deterministic bias favouring tight fits (small slack)
    with a stochastic component to diversify decisions. A tiny deterministic
    tie‑breaker based on the bin index resolves exact ties. Infeasible bins
    (remaining capacity < item) receive ``-np.inf`` so they are never selected.

    ==========  ==========================================================
    Parameter    Description
    ----------  ----------------------------------------------------------
    item         Size of the incoming item (float, non‑negative).
    bins_remain_cap
                1‑D array-like of remaining capacities for each currently
                open bin (float).
    ==========  ==========================================================

    Returns
    -------
    np.ndarray
        Array of priority scores (higher is better) with the same length as
        ``bins_remain_cap``.
    """
    # ---- constants ---------------------------------------------------------
    _TOL = 1e-12          # feasibility tolerance for floating‑point errors
    _EPS = 1e-12          # small number to avoid division by zero
    _TIE = 1e-12          # deterministic tie‑breaker magnitude
    _BIASED_WEIGHT = 0.8 # weight given to the tight‑fit bias (0..1)

    # ---- preprocessing ------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # ---- feasibility mask ---------------------------------------------------
    feasible = caps >= (item - _TOL)

    # Initialise all priorities as -inf (infeasible)
    priorities = np.full(n_bins = n_bins, fill_value=-np.inf, dtype=float)
    if not np.any(feasible):
        return priorities

    # ---- slack and bias ------------------------------------------------------
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)          # ensure non‑negative
    bias = 1.0 / (slack + _EPS)             # larger for tighter fits

    # Normalise bias to [0, 1] (only once)
    bias_norm = bias / (bias.max() + _EPS)

    # ---- random component ----------------------------------------------------
    rng = np.random.default_rng()
    rand_vals = rng.random(bias_norm.shape)   # already in [0, 1)

    # ---- blend bias and randomness -------------------------------------------
    # Weighted sum allows explicit calibration of influence
    blended = _BIASED_WEIGHT * bias_norm + (1.0 - _BIASED_WEIGHT) * rand_vals

    # ---- deterministic tie‑breaker -------------------------------------------
    tie_breaker = -np.arange(n_bins, dtype=float)[feasible] * _TIE

    # ---- final priorities ----------------------------------------------------
    priorities[feasible] = blended + tie_breaker
    return priorities
```
