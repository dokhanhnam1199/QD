{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Global, reproducible RNG for optional stochastic tie\u2011breaking\n_rng = np.random.default_rng(12345)\n\n\n    \"\"\"Priority function for online bin packing (v2).\n\n    Computes a score for each bin such that feasible bins (remaining capacity\n    >= ``item``) receive higher scores when they provide a tighter fit\n    (i.e., smaller slack). The score is based directly on the slack value,\n    with a tiny random perturbation for stochastic tie\u2011breaking and a\n    deterministic index penalty to guarantee a strict total ordering.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same length as ``bins_remain_cap``). Infeasible\n        bins have ``-np.inf`` so they are never selected.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n\n    # Initialise all scores to -inf (infeasible by default)\n    priorities = np.full(n, -np.inf, dtype=float)\n    if n == 0:\n        return priorities\n\n    slack = caps - item\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return priorities\n\n    # Base score: negative slack (higher for tighter fits)\n    base_score = -slack[feasible]\n\n    # Tiny random noise for stochastic tie\u2011breaking (reduced magnitude)\n    rand_noise = _rng.random(base_score.shape) * 1e-12\n\n    # Deterministic index penalty (very small) to break any remaining ties\n    idx = np.nonzero(feasible)[0].astype(float)\n    idx_penalty = idx * 1e-15\n\n    # Final scores for feasible bins\n    scores = base_score + rand_noise - idx_penalty\n    priorities[feasible] = scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Compute priority scores for each bin in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    eps : float, optional\n        Small constant to avoid division by zero when computing bias.\n    rng : numpy.random.Generator, optional\n        Random number generator used for tie\u2011breaking.  If ``None`` a\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more attractive).  Bins that cannot\n        accommodate the item receive ``-np.inf`` so they are never\n        selected.\n    \"\"\"\n    # Ensure we work with a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask.\n    feasible = caps >= item\n\n    # All bins start with an impossible score.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item in each feasible bin.\n    slack = caps[feasible] - item\n\n    # Bias that prefers tighter fits: larger when slack is smaller.\n    bias = 1.0 / (slack + eps)\n\n    # Random component for tie\u2011breaking.\n    if rng is None:\n        rng = np.random.default_rng()\n    rand_factor = rng.random(bias.shape[0])\n\n    # Combine bias and random factor.\n    scores = bias * rand_factor\n\n    # Assign scores back to the full priority vector.\n    priorities[feasible] = scores\n\n    return priorities\n\n[Reflection]\nFavor inverse\u2011slack bias, scale tie\u2011breaking noise, add deterministic index penalty, keep epsilon for stability, avoid underflow.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}