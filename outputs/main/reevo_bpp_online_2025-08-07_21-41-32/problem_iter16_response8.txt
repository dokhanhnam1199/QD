```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    tolerance: float = 1e-12,
    eps: float = 1e-12,
    jitter_scale: float = 1e-4,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Compute priority scores for each bin in an online bin packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks (default 1e-12).
    eps : float, optional
        Small constant to avoid division by zero (default 1e-12).
    jitter_scale : float, optional
        Scale of the random jitter added to feasible bins (default 1e-4).
    tie_breaker : float, optional
        Weight of the deterministic tie‑breaker based on bin index
        (default 1e-12). Lower index receives a slightly larger priority.
    random_state : np.random.Generator, optional
        Random number generator for reproducibility. If ``None``, a fresh
        default RNG is created.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin. Infeasible bins
        receive ``-np.inf``.
    """
    # Ensure a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask (allow a small tolerance for numeric errors)
    feasible = caps >= (item - tolerance)

    # Initialise all scores to -inf (infeasible)
    scores = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can accommodate the item – return all -inf
        return scores

    # Compute slack (remaining capacity after placing the item)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)  # guard against tiny negatives

    # Normalise slack: largest slack among feasible bins becomes 1
    max_slack = slack.max() + eps
    norm_slack = slack / max_slack

    # Bias favouring tighter fits (smaller normalised slack)
    bias = 1.0 / (norm_slack + eps)

    # Weight the bias by the fraction of feasible bins.
    # When many bins can hold the item, we discourage opening a new bin.
    feasible_frac = feasible.sum() / n_bins
    bias *= feasible_frac

    # Random jitter to break ties and avoid pathological deterministic loops
    rng = random_state if random_state is not None else np.random.default_rng()
    jitter = 1.0 + jitter_scale * rng.random(feasible.sum())
    bias *= jitter

    # Deterministic tie‑breaker: prefer lower indices by subtracting a tiny amount
    indices = np.arange(n_bins, dtype=float)
    tie = indices[feasible] * tie_breaker
    # Subtract tie so that smaller index gets a slightly larger final score
    scores[feasible] = bias - tie

    return scores
```
