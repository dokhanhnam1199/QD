[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing setting.\n\n    The priority blends an inverse\u2011slack bias (tight fits) with a random factor\n    and a tiny deterministic tie\u2011breaker based on the bin index. Infeasible\n    bins (capacity < item) receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12   # feasibility tolerance\n    _EPS = 1e-12   # to avoid division by zero\n    _TIE = 1e-12   # deterministic tie\u2011breaker magnitude\n\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask\n    feasible = caps >= (item - _TOL)\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placement (non\u2011negative)\n    slack = np.maximum(caps[feasible] - item, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Random component in [0, 1) for feasible bins\n    rand_vals = np.random.random(bias_norm.shape)\n\n    # Blend bias and randomness multiplicatively\n    blended = bias_norm * rand_vals\n\n    # Tiny deterministic tie\u2011breaker: lower index gets a small advantage\n    tie_breaker = -np.arange(n_bins, dtype=float)[feasible] * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended + tie_breaker\n\n    return priorities",
    "response_id": 0,
    "obj": 4.0885520542481055,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    The priority is based on an inverse\u2011slack bias, a small random perturbation,\n    and a minute deterministic tie\u2011breaker based on the bin index. Bins that\n    cannot accommodate the item receive ``-np.inf`` and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more attractive). Infeasible bins are\n        assigned ``-np.inf``.\n    \"\"\"\n    # constants\n    _TOL = 1e-12          # tolerance for feasibility\n    _EPS = 1e-12          # epsilon to avoid division by zero\n    _RND_SCALE = 1e-12    # scale of random noise\n    _TIE_BREAK = 1e-12    # deterministic index tie\u2011breaker magnitude\n\n    # Flatten caps\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow tiny tolerance)\n    feasible = caps >= (item - _TOL)\n\n    # Initialize priorities\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger when slack is smaller\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalize bias to [0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Small random noise in [0, 1)\n    rng = np.random.default_rng()\n    noise = rng.random(bias_norm.shape) * _RND_SCALE\n\n    # Deterministic tie\u2011breaker: lower index -> slight advantage\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE_BREAK\n\n    # Final priority\n    priorities[feasible] = bias_norm + noise + tie_breaker\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin packing setting.\n\n    The priority is calculated as follows:\n    1. Feasibility check with a tiny tolerance.\n    2. Inverse\u2011slack bias (larger for tighter fits).\n    3. Normalise bias to [0, 1].\n    4. Weight bias by the fraction of feasible bins.\n    5. Multiply the weighted bias by a uniform random number in [0, 1).\n    6. Re\u2011normalise the blended value to [0, 1].\n    7. Add a deterministic tie\u2011breaker that slightly favours lower\u2011index bins.\n    8. Infeasible bins receive -np.inf so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; the bin with the highest score will\n        be selected for the item.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12          # Feasibility tolerance\n    _EPS = 1e-12          # Small epsilon to avoid division by zero\n    _TIE = 1e-12          # Deterministic tie\u2011breaker magnitude\n\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities to -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Weight bias by the fraction of feasible bins\n    feasible_frac = feasible.sum() / n_bins\n    weighted_bias = bias_norm * feasible_frac\n\n    # Random component in [0, 1)\n    rng = np.random.default_rng()\n    rand = rng.random(feasible.sum())\n\n    # Blend bias and randomness multiplicatively\n    blended = weighted_bias * rand\n\n    # Re\u2011normalise blended scores to [0, 1]\n    blended_norm = blended / (blended.max() + _EPS)\n\n    # Deterministic tie\u2011breaker: lower index \u2192 slightly higher priority\n    indices = np.arange(n_bins)[feasible]\n    tie_breaker = -indices * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 2,
    "obj": 4.148384523334677,
    "SLOC": 24.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each open bin in an online bin packing scenario.\n    The score is higher for bins that are feasible, have a tight fit after placing\n    the item, and for which the item occupies a larger fraction of the bin's\n    capacity. Small random noise is added to break pathological ties, and a\n    deterministic tie\u2011breaker favours bins with lower indices.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks.\n    epsilon : float, optional\n        Small constant to avoid division by zero.\n    tie_breaker : float, optional\n        Weight for deterministic index tie\u2011breaker.\n    random_state : np.random.Generator, optional\n        Random generator for reproducibility. If None, a default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    rng = random_state if random_state is not None else np.random.default_rng()\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Scores for all bins, initialize to -inf (infeasible)\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasible bins: capacity sufficient for the item\n    feasible = caps >= (item - tolerance)\n    if not np.any(feasible):\n        return scores\n\n    # Slack after inserting the item (non\u2011negative)\n    slack = caps - item\n    slack[slack < 0] = 0.0\n\n    # Bias favouring tight fits: 1/(slack + epsilon)\n    bias = 1.0 / (slack + epsilon)\n\n    # Fraction of the bin's capacity that would be occupied by the item\n    fill_fraction = np.zeros_like(caps)\n    fill_fraction[feasible] = item / np.maximum(caps[feasible], epsilon)\n\n    # Normalise bias and fill_fraction to [0, 1] within the feasible set\n    max_bias = np.max(bias[feasible]) if np.any(feasible) else 1.0\n    norm_bias = bias / (max_bias + epsilon)\n\n    max_fill = np.max(fill_fraction[feasible]) if np.any(feasible) else 1.0\n    norm_fill = fill_fraction / (max_fill + epsilon)\n\n    # Combine components with equal weight; adjust weights if desired\n    base_score = 0.5 * norm_bias + 0.5 * norm_fill\n\n    # Tiny random noise to diversify decisions\n    noise = rng.random(n_bins) * epsilon\n\n    # Deterministic tie\u2011breaker: lower index gets a small advantage\n    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Final score for feasible bins\n    scores[feasible] = base_score[feasible] + noise[feasible] - idx_factor[feasible]\n\n    return scores",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                tolerance: float = 1e-12,\n                eps: float = 1e-12,\n                noise_scale: float = 1e-6,\n                tie_breaker: float = 1e-15,\n                slack_threshold: float = np.inf,\n                rng: Optional[np.random.Generator] = None) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks.\n    eps : float, optional\n        Small constant added to slack to avoid division by zero.\n    noise_scale : float, optional\n        Relative magnitude of the stochastic tie\u2011breaking noise.\n    tie_breaker : float, optional\n        Deterministic penalty per bin index to break exact ties.\n    slack_threshold : float, optional\n        Maximum slack that is considered \"tight\".  Slacks larger than this\n        will be penalised proportionally.\n    rng : np.random.Generator, optional\n        Random number generator for reproducibility.  If ``None`` a new\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better).  Bins that cannot\n        accommodate the item receive ``-np.inf``.\n    \"\"\"\n    rng = rng or np.random.default_rng()\n\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all scores to -inf\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return scores\n\n    # Compute slack after placing the item\n    slack = np.maximum(caps[feasible] - item, 0.0)\n\n    # Bias: tighter fit => larger bias\n    bias = 1.0 / (slack + eps)\n\n    # Slack threshold penalty: penalise bins with slack larger than the threshold\n    if slack_threshold != np.inf:\n        penalty_factor = np.where(\n            slack <= slack_threshold,\n            1.0,\n            slack_threshold / slack\n        )\n        bias *= penalty_factor\n\n    # Random tie\u2011breaking component, scaled with the bias\n    rand = rng.random(feasible.sum())\n    noise = rand * noise_scale * bias\n\n    # Deterministic tie\u2011breaker: lower index gets a slight advantage\n    idx_penalty = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Combine components\n    scores[feasible] = bias + noise - idx_penalty[feasible]\n\n    return scores",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 32.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing setting.\n\n    The priority favours bins that provide a tight fit (small slack) while\n    retaining a stochastic component to diversify choices. Infeasible bins\n    receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # ---- Constants ---------------------------------------------------------\n    _TOL = 1e-12   # Feasibility tolerance\n    _EPS = 1e-12   # Avoid division by zero\n    _TIE = 1e-12   # Tiny index\u2011based tie\u2011breaker\n\n    # ---- Input sanitisation ------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # ---- Feasibility mask --------------------------------------------------\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities as infeasible\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # ---- Slack (remaining capacity after placing the item) ------------------\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)  # Guard against tiny negative slacks\n\n    # ---- Inverse\u2011slack bias (tight fits get larger bias) -------------------\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to the unit interval [0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # ---- Random component ---------------------------------------------------\n    rng = np.random.default_rng()\n    rand_vals = rng.random(bias_norm if (bias_norm := bias_norm).shape else bias.shape)\n\n    # ---- Multiplicative blend of bias and randomness ------------------------\n    blended = bias_norm * rand_vals\n\n    # Normalise blended scores to [0, 1] for comparability\n    blended_norm = blended / (blended.max() + _EPS)\n\n    # ---- Tie\u2011breaker (lower index \u2192 slight advantage) -----------------------\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE\n\n    # ---- Assemble final priority vector ------------------------------------\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 53, in priority_v2\n    \n  File \"numpy/random/_generator.pyx\", line 360, in numpy.random._generator.Generator.random\n  File \"numpy/random/_common.pyx\", line 312, in numpy.random._common.double_fill\nValueError: maximum supported dimension for an ndarray is currently 64, found 5000\n21\n3\n"
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    eps: float = 1e-12,\n    rand_scale: float = 1e-3,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing that:\n        * only considers bins that can fit the item,\n        * favours tighter fits (smaller slack),\n        * normalises slack to compare bins fairly,\n        * slightly weights all feasible bins together,\n        * adds a tiny random perturbation to avoid deterministic loops,\n        * uses a deterministic tie\u2011breaker favouring lower indices.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks.\n    eps : float, optional\n        Small constant to avoid division by zero.\n    rand_scale : float, optional\n        Maximum scale of the random perturbation (kept small).\n    tie_breaker : float, optional\n        Weight applied to the bin index for deterministic tie\u2011breaking.\n    random_state : np.random.Generator, optional\n        RNG for reproducibility; if None a default RNG is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better). Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Ensure a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask\n    feasible = caps >= (item - tolerance)\n\n    # Scores: infeasible bins get -inf\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return scores\n\n    # Slack after placing the item\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Normalise slack so that the largest slack among feasible bins is 1\n    max_slack = slack.max() + eps\n    norm_slack = slack / max_slack\n\n    # Bias: tighter fit \u2192 larger value\n    bias = 1.0 / (norm_slack + eps)\n\n    # Weight the bias by the fraction of feasible bins (encourages opening new bins when many options)\n    feasible_frac = feasible.sum() / n_bins\n    bias *= feasible_frac\n\n    # Small random factor to diversify choices\n    rand_factor = 1.0 + rng.random(feasible.sum()) * rand_scale\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage\n    indices = np.arange(n_bins)\n    tie = indices[feasible] * tie_breaker\n\n    # Final score: bias + randomness, then break ties\n    scores[feasible] = bias * rand_factor - tie\n\n    return scores",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 29.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing setting.\n\n    This priority function follows the principles outlined in the reflection:\n    * Feasibility is determined with a small tolerance.\n    * A bias based on inverse slack (tight fit) is normalised to [0,1].\n    * The bias is blended with a random component by multiplication.\n    * A tiny deterministic tie\u2011breaker based on bin index resolves ties.\n    * Infeasible bins receive ``-np.inf``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12   # Feasibility tolerance\n    _EPS = 1e-12   # For division by zero avoidance\n    _TIE = 1e-12   # Tie\u2011breaker magnitude\n\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility check: allow a tiny negative slack due to numeric errors\n    feasible = caps >= (item - _TOL)\n\n    # Initialise with -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (>= 0 for feasible bins)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Random factor in [0, 1)\n    rng = np.random.default_rng()\n    rand_vals = rng.random(bias_norm.shape)\n\n    # Blend bias and randomness multiplicatively\n    blended = bias_norm * rand_vals\n\n    # Normalise blended score to [0, 1]\n    blended_norm = blended / (blended.max() + _EPS)\n\n    # Deterministic tie\u2011breaker: lower index gets slight advantage\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE\n\n    # Final priority: blend + tie\u2011breaker\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 7,
    "obj": 4.068607897885915,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    eps: float = 1e-12,\n    rng: Optional[np.random.Generator] = None,\n    random_weight: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing.\n\n    Computes a score for each currently open bin. Higher scores indicate bins\n    that are more desirable for placing ``item``. The score combines:\n      * a bias toward tighter fits (smaller slack),\n      * weighting of that bias by the fraction of feasible bins,\n      * a low\u2011magnitude random perturbation for stochastic tie\u2011breaking,\n      * a deterministic tie\u2011breaker that prefers lower\u2011indexed bins.\n\n    Infeasible bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    eps : float, optional\n        Small constant used for numerical tolerance and to avoid division by zero.\n    rng : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None``, a new default RNG is created.\n    random_weight : float, optional\n        Scaling factor for the random component (kept small to limit randomness).\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (shape ``(n_bins,)``). Infeasible bins have ``-inf``.\n    \"\"\"\n    # Normalise input to a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: bin can accommodate the item (allow tiny tolerance).\n    feasible = caps >= (item - eps)\n\n    # Initialise all priorities as -inf (infeasible bins).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accommodate the item.\n        return priorities\n\n    # Slack after placing the item (clip to zero to avoid negative values from rounding).\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Fraction of bins that are feasible.\n    feasible_frac = feasible.sum() / n_bins\n\n    # Bias toward tighter fits: larger when slack is smaller.\n    # Weight the bias by the feasible fraction.\n    bias = (1.0 / (slack + eps)) * feasible_frac\n\n    # Random component: low\u2011magnitude stochastic perturbation.\n    if rng is None:\n        rng = np.random.default_rng()\n    rand = rng.random(bias.shape) * random_weight\n\n    # Deterministic tie\u2011breaker: favor lower\u2011index bins by a tiny decrement.\n    # Use the same epsilon magnitude to keep it negligible compared to bias.\n    indices = np.nonzero(feasible)[0]\n    tie_breaker = -indices.astype(float) * eps\n\n    # Combine components.\n    scores = bias + rand + tie_breaker\n\n    # Assign scores to feasible bins.\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np.ndarray\nfrom typing import Optional\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each open bin in an online bin\u2011packing setting.\n\n    Higher scores indicate more desirable bins for placing the incoming ``item``.\n    The score combines three ingredients:\n\n    1. **Feasibility** \u2013 a bin must have enough remaining capacity (within a\n       numerical ``tolerance``) to hold the item; infeasible bins receive\n       ``-np.inf``.\n    2. **Tight\u2011fit bias** \u2013 bins that would leave little slack after insertion are\n       favoured via the term ``1 / (slack + epsilon)`` (larger for tighter fits).\n    3. **Diversification & tie\u2011breaking** \u2013 a uniform random factor per bin adds\n       stochasticity, while a tiny deterministic penalty proportional to the\n       bin index (`tie_break) breaks exact ties in favour of lower\u2011indexed bins.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    tolerance : float, optional\n        Numerical tolerance for the feasibility check (default ``1e-12``).\n    epsilon : float, optional\n        Small constant added to slack to avoid division\u2011by\u2011zero (default ``1e-12``).\n    tie_breaker : float, optional\n        Weight of the deterministic index penalty (default ``1e-12``). Must be\n        small enough not to outweigh the main bias.\n    random_state : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None`` a fresh default\n        generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (shape = ``bins_remain_cap.shape``). Infeasible\n        bins have a score of ``-np.inf`` and will never be selected.\n    \"\"\"\n    # Ensure reproducible randomness\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Normalise input to a flat float\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: bin can accommodate the item (allow tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise scores to -inf (infeasible by default)\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if nothing fits\n    if not np.any(feasible):\n        return scores\n\n    # Slack after placing the item (clip tiny negatives)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Tight\u2011fit bias: larger for smaller slack\n    bias = 1.0 / (slack + epsilon)\n\n    # Random diversification component (one per bin)\n    rand = rng.random(n_bins)\n\n    # Deterministic tie\u2011breaker: smaller index => slightly higher score\n    idx_penalty = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Combine components for feasible bins\n    scores[feasible] = bias * rand[feasible] - idx_penalty[feasible]\n\n    return scores",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1\n    import numpy as np.ndarray\n                      ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1\n    import numpy as np.ndarray\n                      ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 1\n    import numpy as np.ndarray\n                      ^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-6,\n    tiny_rand_range: float = 1e-6,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks (default 1e-12).\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero\n        (default 1e-12).\n    tie_breaker : float, optional\n        Weight applied to the bin index to break ties deterministically.\n        Must be small enough not to outweigh the main bias (default 1e-6).\n    tiny_rand_range : float, optional\n        Scale of the tiny random perturbation added to each bin.\n        Keeps randomness low (default 1e-6).\n    random_state : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None`` a new\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Infeasible bins\n        receive ``-np.inf`` and will never be selected.\n    \"\"\"\n    # Ensure a random generator is available.\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Flatten and cast capacities to float.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Compute slack (remaining capacity after placing the item).\n    slack = caps - item\n\n    # Determine which bins can accommodate the item (within tolerance).\n    feasible = slack >= -tolerance\n\n    # If no bin can hold the item, return all -inf scores.\n    if not np.any(feasible):\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # For feasible bins, compute slack_pos (non\u2011negative slack).\n    slack_pos = np.maximum(slack[feasible], 0.0)\n\n    # Base score inversely proportional to slack (higher for tighter fits).\n    base = 1.0 / (slack_pos + epsilon)\n\n    # Normalize base scores to the range [0, 1].\n    base_norm = base / base.max() if base.max() > 0 else base\n\n    # Weight by the fraction of bins that are feasible.\n    feasible_fraction = feasible.sum() / n_bins\n    weight = base_norm * feasible_fraction\n\n    # Tiny random component to diversify decisions.\n    rand_small = rng.random(n_bins) * tiny_rand_range\n\n    # Deterministic tie\u2011breaker: lower index gets slightly higher score.\n    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Assemble final scores, initializing infeasible bins to -inf.\n    final_score = np.full(n_bins, -np.inf, dtype=float)\n    final_score[feasible] = weight + rand_small[feasible] - idx_factor[feasible]\n\n    # Re\u2011normalize feasible scores to the range [0, 1] (keeps ranking robust).\n    feasible_scores = final_score[feasible]\n    min_score = feasible_scores.min()\n    max_score = feasible_scores.max()\n    if max_score > min_score:\n        normalized_scores = (feasible_scores - min_score) / (max_score - min_score)\n    else:\n        normalized_scores = feasible_scores  # all equal; keep as is\n\n    final_score[feasible] = normalized_scores\n\n    return final_score",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 34.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  }
]