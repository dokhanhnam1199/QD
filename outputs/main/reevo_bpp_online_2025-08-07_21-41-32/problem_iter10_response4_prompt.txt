{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Random Fit priority for online bin packing, biased toward tighter fits.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1-D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, one per bin.  Higher scores indicate higher priority.\n        Infeasible bins receive -np.inf.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    if caps.size == 0:\n        return np.empty(0, dtype=float)\n\n    feasible = caps >= item\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if np.any(feasible):\n        slack = caps[feasible] - item\n        epsilon = 1e-12\n        rand = np.random.rand(caps.size)[feasible]\n        priorities[feasible] = rand / (slack + epsilon)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin\u2011packing that blends exact\u2011fit scoring with a\n    biased random component and a deterministic tie\u2011breaker.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacity for each currently open bin.\n    tolerance : float, optional\n        Numerical tolerance used for feasibility checks and exact\u2011fit\n        detection.\n    tie_breaker : float, optional\n        Small positive constant used to break ties deterministically\n        (lower\u2011indexed bins are slightly preferred).\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible randomness. If ``None`` the global\n        NumPy RNG is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin (higher = more attractive).\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure capacities are a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: bins that can accommodate the item (within tolerance).\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priorities with -inf (infeasible bins).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Compute slack for feasible bins (non\u2011negative).\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Exact\u2011fit score: larger when slack is smaller (exact fit => 0).\n    exact_score = -slack\n\n    # Bias: larger for tighter fits.\n    epsilon = tolerance\n    bias = 1.0 / (slack + epsilon)\n\n    # Normalise bias to [0, 1] to keep the random term comparable across bins.\n    bias_norm = bias / bias.max() if bias.max() > 0 else np.zeros_like(bias)\n\n    # Random generator handling.\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    # Random component: random number scaled by bias_norm.\n    rand_vals = rng.random(bias.size)  # one random number per feasible bin\n    random_component = bias_norm * rand_vals  # values in [0, 1]\n\n    # Adaptive weighting of the random part.\n    # If an exact fit exists, reduce randomness to favour it.\n    w_random = 0.1 if np.min(slack) <= tolerance else 0.5\n\n    # Deterministic tie\u2011breaker (lower index slightly preferred).\n    idx_feasible = np.where(feasible)[0]\n    tie_term = idx_feasible.astype(float) * tie_breaker\n\n    # Combine the components.\n    combined = exact_score + w_random * random_component - tie_term\n\n    # Populate the result array.\n    priorities[feasible] = combined\n\n    return priorities\n\n[Reflection]\nBlend exact\u2011fit scoring, normalized slack bias, bounded randomness, tolerance checks, deterministic tie\u2011breaker for robust online bin\u2011packing.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}