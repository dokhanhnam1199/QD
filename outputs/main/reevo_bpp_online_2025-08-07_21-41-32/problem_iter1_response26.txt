```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Sigmoid Fit Score priority: higher priority for bins that will be filled more tightly.
    
    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities for each bin.
    
    Returns:
        Array of priority scores, same shape as `bins_remain_cap`. 
        Bins that cannot accommodate the item receive -inf priority.
    """
    # Ensure we work on float array
    bins_remain_cap = bins_remain_cap.astype(float, copy=False)

    # Compute mask of bins that can fit the item
    fit_mask = bins_remain_cap >= item
    # Initialise all scores to negative infinity (unfit bins)
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    if np.any(fit_mask):
        # Excess space after placing the item
        deficit = bins_remain_cap[fit_mask] - item  # non‑negative
        
        # Logistic‑type mapping: 1.0 at deficit = 0, approaching 0 as deficit grows
        # 2.0 / (1 + exp(k * deficit)) squeezes the values into (0,1]
        k = 5.0  # slope parameter – can be tuned
        exp_term = np.exp(np.clip(k * deficit, None, 700))  # clip to avoid overflow
        scores[fit_mask] = 2.0 / (1.0 + exp_term)

    return scores
```
