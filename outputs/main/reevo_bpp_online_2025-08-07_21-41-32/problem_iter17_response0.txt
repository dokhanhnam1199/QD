```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    jitter: float = 1e-6,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    For each open bin a priority score is computed; the bin with the highest
    score receives the incoming item. The score favours:
      * Feasibility (bin must have enough remaining capacity).
      * Tight fits (small slack after insertion).
      * A deterministic tie‑breaker based on the bin index.
      * Minimal random jitter to avoid pathological deterministic behaviour.
    Scores for feasible bins are normalized to the interval [0, 1]; infeasible
    bins receive ``-np.inf`` and are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks (default 1e-12).
    epsilon : float, optional
        Small constant added to slack to avoid division‑by‑zero (default 1e-12).
    jitter : float, optional
        Magnitude of the random jitter added to each feasible bin's score
        (default 1e-6).
    tie_breaker : float, optional
        Small weight multiplied by the bin index to break ties deterministically
        (default 1e-12).
    random_state : np.random.Generator, optional
        Random generator for reproducibility. If ``None``, a default generator
        is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins have
        ``-np.inf``.
    """
    # Ensure a 1‑D float array for capacities.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask: bin can hold the item within tolerance.
    feasible = caps >= (item - tolerance)

    # Early exit if no bin can accommodate the item.
    if not np.any(feasible):
        return np.full(n_bins, -np.inf, dtype=float)

    # Slack after placing the item (non‑negative).
    slack = np.maximum(caps - item, 0.0)

    # Fraction of bins that are feasible (scalar in (0, 1]).
    feasible_fraction = feasible.mean()

    # Core bias: prefers tighter fits and scales with feasible_fraction.
    bias = (1.0 / (slack + epsilon)) * feasible_fraction

    # Random jitter: tiny uniform noise, seeded if a generator is supplied.
    rng = random_state if random_state is not None else np.random.default_rng()
    jitter_term = jitter * rng.random(n_bins)

    # Deterministic tie‑breaker: lower index → slightly higher score.
    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker

    # Combine components for feasible bins.
    raw_scores = np.full(n_bins, -np.inf, dtype=float)
    raw_scores[feasible] = bias[feasible] + jitter_term[feasible] - idx_factor[feasible]

    # Normalization (only on feasible entries).
    feas_scores = raw_scores[feasible]
    min_score = feas_scores.min()
    max_score = feas_scores.max()
    # Guard against zero range.
    normalized = (feas_scores - min_score) / (max_score - min_score + epsilon)

    # Place normalized scores back, leaving infeasible bins at -inf.
    scores = np.full(n_bins, -np.inf, dtype=float)
    scores[feasible] = normalized

    return scores
```
