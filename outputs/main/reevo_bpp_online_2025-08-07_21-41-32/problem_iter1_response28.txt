```python
import numpy as np

# Probability of exploring a random bin instead of the best fit
_EPSILON = 0.15  # tweak as needed


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority for each bin using an ε‑greedy strategy.

    * Exploitation (probability 1‑ε): choose the tightest‑fit bin,
      i.e. the bin that leaves the smallest leftover capacity after the item is placed.
    * Exploration (probability ε): assign random scores to all *feasible* bins.

    Bins that cannot accommodate the item receive a priority of -inf so they will
    never be selected.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array with the remaining capacity of each bin.

    Returns:
        np.ndarray of the same shape as ``bins_remain_cap`` containing priority scores.
    """
    # Initialise all priorities to -inf (infeasible)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Mask of bins that can actually hold the item
    feasible = bins_remain_cap >= item
    if not feasible.any():
        # No feasible bin – we just return the -inf vector
        return priorities

    if np.random.rand() < _EPSILON:
        # --- Exploration ----------------------------------------------------
        # Random scores (uniform in [0,1]) for feasible bins
        random_scores = np.random.rand(bins_remain_cap.shape[0])
        priorities[feasible] = random_scores[feasible]
    else:
        # --- Exploitation ---------------------------------------------------
        # Tightest fit: smallest leftover = highest priority.
        # Using negative leftover turns “smaller is better” into “larger is better”.
        leftover = bins_remain_cap[feasible] - item
        priorities[feasible] = -leftover

    return priorities
```
