```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Simple priority function for online bin packing.

    For each bin a score is produced; the bin with the highest score is chosen
    for the incoming ``item``.  Infeasible bins (those that cannot accommodate
    the item) receive ``-np.inf`` and are therefore never selected.

    The score combines:
      * a mild bias toward tighter fits (less slack after placement), and
      * a tiny random tie‑breaker to avoid deterministic ties.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the bins.

    Returns
    -------
    np.ndarray
        1‑D array of priority scores (higher is better). Infeasible bins are
        marked with ``-np.inf``.
    """
    # Ensure a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Identify bins that can accommodate the item
    feasible = caps >= item

    # Initialise all scores as -inf (infeasible)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Early exit if nothing fits
    if not feasible.any():
        return priorities

    # Slack after hypothetically placing the item
    slack = caps - item

    # Mild bias toward tighter fits: larger when slack is smaller
    epsilon = 1e-12  # avoid division by zero for exact fits
    bias = np.zeros(n_bins, dtype=float)
    bias[feasible] = 1.0 / (slack[feasible] + epsilon)

    # Tiny random tie‑breaker (≈1e‑8) to break equal scores
    tie_eps = 1e-8
    rng = np.random.default_rng()
    jitter = tie_eps * rng.random(n_bins)

    # Combine bias and jitter for feasible bins
    priorities[feasible] = bias[feasible] + jitter[feasible]

    return priorities
```
