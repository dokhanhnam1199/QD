```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Compute priority scores for each open bin in an online bin packing scenario.
    The score is higher for bins that are feasible, have a tight fit after placing
    the item, and for which the item occupies a larger fraction of the bin's
    capacity. Small random noise is added to break pathological ties, and a
    deterministic tie‑breaker favours bins with lower indices.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.
    tolerance : float, optional
        Numerical tolerance for feasibility checks.
    epsilon : float, optional
        Small constant to avoid division by zero.
    tie_breaker : float, optional
        Weight for deterministic index tie‑breaker.
    random_state : np.random.Generator, optional
        Random generator for reproducibility. If None, a default generator is used.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Infeasible bins receive ``-np.inf``.
    """
    rng = random_state if random_state is not None else np.random.default_rng()
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Scores for all bins, initialize to -inf (infeasible)
    scores = np.full(n_bins, -np.inf, dtype=float)

    # Feasible bins: capacity sufficient for the item
    feasible = caps >= (item - tolerance)
    if not np.any(feasible):
        return scores

    # Slack after inserting the item (non‑negative)
    slack = caps - item
    slack[slack < 0] = 0.0

    # Bias favouring tight fits: 1/(slack + epsilon)
    bias = 1.0 / (slack + epsilon)

    # Fraction of the bin's capacity that would be occupied by the item
    fill_fraction = np.zeros_like(caps)
    fill_fraction[feasible] = item / np.maximum(caps[feasible], epsilon)

    # Normalise bias and fill_fraction to [0, 1] within the feasible set
    max_bias = np.max(bias[feasible]) if np.any(feasible) else 1.0
    norm_bias = bias / (max_bias + epsilon)

    max_fill = np.max(fill_fraction[feasible]) if np.any(feasible) else 1.0
    norm_fill = fill_fraction / (max_fill + epsilon)

    # Combine components with equal weight; adjust weights if desired
    base_score = 0.5 * norm_bias + 0.5 * norm_fill

    # Tiny random noise to diversify decisions
    noise = rng.random(n_bins) * epsilon

    # Deterministic tie‑breaker: lower index gets a small advantage
    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker

    # Final score for feasible bins
    scores[feasible] = base_score[feasible] + noise[feasible] - idx_factor[feasible]

    return scores
```
