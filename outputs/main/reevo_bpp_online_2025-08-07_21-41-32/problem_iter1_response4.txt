```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Exact‑Fit‑First priority function for online Bin Packing.

    The bin with the highest returned score will be chosen for ``item``.
    Bins that cannot accommodate the item receive ``-np.inf`` so they are
    never selected. Among feasible bins, a smaller leftover capacity
    (i.e. a tighter fit) yields a larger priority, and an exact fit
    (remaining capacity == item) gets the highest possible priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher values indicate more attractive bins.
    """
    # Tiny tolerance to guard against floating‑point noise.
    eps = 1e-12

    # Feasibility mask: bins that have enough space for the item.
    feasible = bins_remain_cap >= (item - eps)

    # Initialise all priorities to -inf (unfeasible bins).
    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)

    # Compute leftover capacity if the item were placed.
    leftover = bins_remain_cap[feasible] - item   # guaranteed >= 0

    # Index‑based tiny offset to break ties deterministically
    # (preferring lower‑indexed bins when leftovers are equal).
    tiny = 1e-12
    idx = np.where(feasible)[0]

    # Exact‑Fit‑First: a smaller leftover means higher priority.
    # Using negative leftover makes an exact fit (leftover == 0) obtain
    # the largest score (0 before tie‑breaking). All other feasible
    # bins receive negative scores proportional to wasted space.
    priorities[feasible] = -leftover - idx * tiny

    return priorities
```
