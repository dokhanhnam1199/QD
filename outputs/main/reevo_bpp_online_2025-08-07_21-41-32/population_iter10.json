[
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\n\n# Global, reproducible RNG for optional stochastic tie\u2011breaking\n_rng = np.random.default_rng(12345)\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function for online bin packing (v2).\n\n    Computes a score for each bin such that feasible bins (remaining capacity\n    >= ``item``) receive higher scores when they provide a tighter fit\n    (i.e., smaller slack). The score is based directly on the slack value,\n    with a tiny random perturbation for stochastic tie\u2011breaking and a\n    deterministic index penalty to guarantee a strict total ordering.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the existing bins.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same length as ``bins_remain_cap``). Infeasible\n        bins have ``-np.inf`` so they are never selected.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n = caps.size\n\n    # Initialise all scores to -inf (infeasible by default)\n    priorities = np.full(n, -np.inf, dtype=float)\n    if n == 0:\n        return priorities\n\n    slack = caps - item\n    feasible = slack >= 0\n    if not np.any(feasible):\n        return priorities\n\n    # Base score: negative slack (higher for tighter fits)\n    base_score = -slack[feasible]\n\n    # Tiny random noise for stochastic tie\u2011breaking (reduced magnitude)\n    rand_noise = _rng.random(base_score.shape) * 1e-12\n\n    # Deterministic index penalty (very small) to break any remaining ties\n    idx = np.nonzero(feasible)[0].astype(float)\n    idx_penalty = idx * 1e-15\n\n    # Final scores for feasible bins\n    scores = base_score + rand_noise - idx_penalty\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response1.txt_stdout.txt",
    "code_path": "problem_iter10_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Simple priority function for online bin packing.\n\n    For each bin a score is produced; the bin with the highest score is chosen\n    for the incoming ``item``.  Infeasible bins (those that cannot accommodate\n    the item) receive ``-np.inf`` and are therefore never selected.\n\n    The score combines:\n      * a mild bias toward tighter fits (less slack after placement), and\n      * a tiny random tie\u2011breaker to avoid deterministic ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the bins.\n\n    Returns\n    -------\n    np.ndarray\n        1\u2011D array of priority scores (higher is better). Infeasible bins are\n        marked with ``-np.inf``.\n    \"\"\"\n    # Ensure a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Identify bins that can accommodate the item\n    feasible = caps >= item\n\n    # Initialise all scores as -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if nothing fits\n    if not feasible.any():\n        return priorities\n\n    # Slack after hypothetically placing the item\n    slack = caps - item\n\n    # Mild bias toward tighter fits: larger when slack is smaller\n    epsilon = 1e-12  # avoid division by zero for exact fits\n    bias = np.zeros(n_bins, dtype=float)\n    bias[feasible] = 1.0 / (slack[feasible] + epsilon)\n\n    # Tiny random tie\u2011breaker (\u22481e\u20118) to break equal scores\n    tie_eps = 1e-8\n    rng = np.random.default_rng()\n    jitter = tie_eps * rng.random(n_bins)\n\n    # Combine bias and jitter for feasible bins\n    priorities[feasible] = bias[feasible] + jitter[feasible]\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Simple priority function for online bin packing.\n\n    - Gives a higher score to bins that can accommodate the item.\n    - Biases towards tighter fits (smaller slack) by using 1/(slack+\u03b5).\n    - Breaks ties randomly by multiplying the bias with a uniform random number.\n    - Infeasible bins receive -np.inf so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin, same shape as\n        ``bins_remain_cap``.\n    \"\"\"\n    # Convert to a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Numerical tolerance for feasibility.\n    tol = 1e-12\n    feasible = caps >= (item - tol)\n\n    # Initialise priorities to -inf (infeasible by default).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can hold the item.\n        return priorities\n\n    # Slack (remaining space after placing the item) for feasible bins.\n    slack = caps[feasible] - item\n    # Small epsilon avoids division by zero for exact fits.\n    eps = 1e-12\n    bias = 1.0 / (slack + eps)      # larger when slack is smaller (tighter fit)\n\n    # Random tie\u2011breaker: uniform numbers in (0, 1).\n    rand = np.random.rand(feasible.sum())\n\n    # Combine bias with randomness; multiplication preserves bias while randomising.\n    priorities[feasible] = bias * rand\n\n    return priorities",
    "response_id": 2,
    "obj": 4.01874750698045,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response3.txt_stdout.txt",
    "code_path": "problem_iter10_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                tolerance: float = 1e-12,\n                tie_breaker: float = 1e-12,\n                eps: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for the online bin packing problem.\n\n    The function assigns a priority score to each bin based on how tightly the\n    incoming ``item`` would fit (i.e., the slack after placement) and a small\n    deterministic tie\u2011breaker that favours bins with lower indices.\n\n    Features:\n    - Feasibility check with a tolerance.\n    - Slack (remaining space after placing the item) is normalised to [0, 1].\n    - Slack influence is weighted by the fraction of feasible bins: when many\n      bins can accommodate the item, tighter fits are strongly preferred; when\n      few bins are feasible, the influence of slack diminishes and the tie\u2011breaker\n      dominates.\n    - Infeasible bins receive ``-np.inf`` so they are never selected.\n    - No random components \u2192 reproducible behaviour.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility (default 1e-12).\n    tie_breaker : float, optional\n        Small deterministic bias to break ties; lower indices receive higher\n        priority (default 1e-12).\n    eps : float, optional\n        Small constant to avoid division by zero when normalising slack\n        (default 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.  Infeasible bins have\n        ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        # No bins available \u2013 return an empty array.\n        return np.empty(0, dtype=float)\n\n    # Feasibility mask (allow a tiny tolerance for floating\u2011point errors)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin \u2013 return priorities as all -inf.\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Normalise slack to the interval [0, 1].\n    max_slack = slack.max()\n    slack_norm = slack / (max_slack + eps)  # Avoid division by zero.\n\n    # Adaptive weighting: more weight on slack when many bins are feasible.\n    feasible_frac = feasible.sum() / n_bins  # \u2208 (0, 1]\n    w_slack = feasible_frac  # Larger when many bins can accommodate the item.\n\n    # Base score: tighter fit (smaller slack) gets a larger (less negative) score.\n    base_score = -slack_norm\n    weighted_score = w_slack * base_score\n\n    # Deterministic tie\u2011breaker: lower index \u2192 slightly higher priority.\n    indices = np.arange(n_bins)\n    tie = -indices[feasible] * tie_breaker\n\n    # Combine weighted slack score and tie\u2011breaker.\n    priorities[feasible] = weighted_score + tie\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response4.txt_stdout.txt",
    "code_path": "problem_iter10_code4.py",
    "code": "import numpy as np\nfrom typing import Optional, Union\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[Union[int, np.random.Generator]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin\u2011packing that blends exact\u2011fit scoring,\n    slack bias, bounded randomness, tolerance checks, and a deterministic\n    tie\u2011breaker.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacity for each currently open bin.\n    tolerance : float, optional\n        Numerical tolerance used for feasibility checks and exact\u2011fit\n        detection. Default is 1e-12.\n    tie_breaker : float, optional\n        Small positive constant used to break ties deterministically\n        (lower\u2011indexed bins are slightly preferred). Default is 1e-12.\n    random_state : int or np.random.Generator, optional\n        Seed or generator for reproducible randomness. If ``None`` the\n        global NumPy RNG is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores, one per bin (higher = more attractive).\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure we work with a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Handle the empty case early.\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Feasibility mask: bins that can accommodate the item.\n    feasible = caps >= item - tolerance\n\n    # Initialise priorities with -inf for infeasible bins.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # If no bin can fit the item, we return the default priorities.\n    if not np.any(feasible):\n        return priorities\n\n    # Slack for feasible bins (non\u2011negative).\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Exact\u2011fit score: larger when slack is smaller (exact fit \u2192 0).\n    exact_score = -slack\n\n    # Slack bias: larger for tighter fits, normalised to [0, 1].\n    bias = 1.0 / (slack + tolerance)\n    bias_norm = bias / bias.max() if bias.max() > 0 else np.zeros_like(bias)\n\n    # Random generator handling.\n    if isinstance(random_state, np.random.Generator):\n        rng = random_state\n    else:\n        rng = np.random.default_rng(random_state)\n\n    # Random component scaled by bias_norm; bounded in [0, 1].\n    random_component = bias_norm * rng.random(bias.size)\n\n    # Weight of the random component: reduce randomness if an exact fit exists.\n    w_random = 0.0 if np.any(np.isclose(slack, 0.0, atol=tolerance)) else 0.5\n\n    # Deterministic tie\u2011breaker: lower\u2011indexed bins receive a slight advantage.\n    idx_feasible = np.where(feasible)[0]\n    tie_term = idx_feasible.astype(float) * tie_breaker\n\n    # Combine components: larger value \u2192 higher priority.\n    combined = exact_score + w_random * random_component - tie_term\n\n    # Assign the computed priorities back to the corresponding bins.\n    priorities[feasible] = combined\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility (default 1e-12).\n    tie_breaker : float, optional\n        Small deterministic bias to break ties; lower indices get higher priority\n        (default 1e-12).\n    eps : float, optional\n        Small constant to avoid division by zero (default 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Normalise slack to [0, 1] (smaller slack => smaller norm)\n    max_slack = slack.max()\n    slack_norm = slack / (max_slack + eps)\n\n    # Adaptive weighting: more weight on slack when many bins are feasible\n    feasible_frac = feasible.sum() / n_bins  # \u2208 (0, 1]\n    w_slack = feasible_frac\n\n    # Base score: tighter fit (smaller slack) gets higher (less negative) score\n    base_score = -slack_norm\n    weighted_score = w_slack * base_score\n\n    # Deterministic tie\u2011breaker: lower index \u2192 higher priority\n    indices = np.arange(n_bins)\n    tie = -indices[feasible] * tie_breaker\n\n    priorities[feasible] = weighted_score + tie\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 26.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response6.txt_stdout.txt",
    "code_path": "problem_iter10_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, *, eps: float = 1e-12, rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    eps : float, optional\n        Small constant to avoid division by zero when computing bias.\n    rng : numpy.random.Generator, optional\n        Random number generator used for tie\u2011breaking.  If ``None`` a\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more attractive).  Bins that cannot\n        accommodate the item receive ``-np.inf`` so they are never\n        selected.\n    \"\"\"\n    # Ensure we work with a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask.\n    feasible = caps >= item\n\n    # All bins start with an impossible score.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item in each feasible bin.\n    slack = caps[feasible] - item\n\n    # Bias that prefers tighter fits: larger when slack is smaller.\n    bias = 1.0 / (slack + eps)\n\n    # Random component for tie\u2011breaking.\n    if rng is None:\n        rng = np.random.default_rng()\n    rand_factor = rng.random(bias.shape[0])\n\n    # Combine bias and random factor.\n    scores = bias * rand_factor\n\n    # Assign scores back to the full priority vector.\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 6,
    "obj": 4.038691663342641,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response7.txt_stdout.txt",
    "code_path": "problem_iter10_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tolerance: float = 1e-12,\n                tie_breaker: float = 1e-12,\n                epsilon: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Priority for online bin packing that biases towards tight fits and adds\n    random diversification.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n    tolerance : float, optional\n        Acceptable negative slack due to floating point errors.\n    tie_breaker : float, optional\n        Small value used to break ties in favor of lower index bins.\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores; larger is better.  Feasible bins get a finite score,\n        infeasible bins get -inf.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n = caps.size\n\n    # Feasible bins: can accommodate the item (within tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Default: infeasible bins get -inf\n    priorities = np.full(n, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack: remaining capacity after packing the item\n    slack = caps[feasible] - item\n    # Clip tiny negative values caused by numerical noise\n    slack = np.maximum(slack, 0.0)\n\n    # Bias: higher for tighter fits\n    bias = 1.0 / (slack + epsilon)\n\n    # Random component for diversification\n    rand = np.random.rand(n)\n\n    # Indices of feasible bins (to apply tie\u2011breaker)\n    idx = np.nonzero(feasible)[0]\n\n    # Combine bias and randomness; higher score is better\n    priorities[feasible] = bias * rand[feasible] - idx * tie_breaker\n\n    return priorities",
    "response_id": 7,
    "obj": 3.9688871160749857,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The priority blends a random component with an inverse\u2011slack bias,\n    normalises the result, and adds a deterministic tie\u2011breaker based on the\n    bin index. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12          # feasibility tolerance\n    _EPS = 1e-12          # to avoid division by zero\n    _TIE = 1e-12          # deterministic tie\u2011breaker magnitude\n\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities to -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1] (max bias gets 1)\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Random component in [0, 1)\n    rng = np.random.default_rng()\n    rand_scores = rng.random(caps.shape)\n    rand_feas = rand_scores[feasible]\n\n    # Blend bias and randomness multiplicatively (emphasises both)\n    blended = bias_norm * rand_feas\n\n    # Normalise blended scores to [0, 1] (max gets 1)\n    blended_norm = blended / (blended.max() + _EPS)\n\n    # Deterministic tie\u2011breaker: lower index \u2192 slightly higher priority\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 8,
    "obj": 4.028719585161557,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing that:\n    - Biases random scores by the inverse of the slack (remaining capacity minus item size).\n    - Adapts the weight of the bias based on the fraction of feasible bins.\n    - Adds a deterministic tie\u2011breaker that favors lower indexed bins.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    tolerance = 1e-12\n    feasible = caps >= (item - tolerance)\n\n    # Initialize all priorities to -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse slack bias (higher bias for tighter fits)\n    eps = 1e-12\n    bias = 1.0 / (slack + eps)\n\n    # Weight bias by the fraction of feasible bins\n    feasible_frac = feasible.sum() / n_bins\n    weighted_bias = bias * feasible_frac\n\n    # Random component\n    rand_scores = np.random.rand(feasible.sum())\n\n    # Combine bias and randomness\n    combined = weighted_bias * rand_scores\n\n    # Deterministic tie\u2011breaker: lower index \u2192 higher priority\n    indices = np.arange(n_bins)\n    tie_breaker = 1e-12\n    tie = -indices[feasible] * tie_breaker\n\n    # Assign priorities for feasible bins\n    priorities[feasible] = combined + tie\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9589150378939015,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]