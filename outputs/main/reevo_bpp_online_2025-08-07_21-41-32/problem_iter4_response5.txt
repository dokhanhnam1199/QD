```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for assigning ``item`` to each bin.

    The function favours bins that will be tightly filled (small slack) while
    adding a modest random perturbation to break ties.  An adaptive epsilon
    prevents division‑by‑zero and scales with typical slack size.  Infeasible
    bins receive ``-np.inf`` so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin.
    """
    # Ensure a float array.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Identify feasible bins (enough capacity for the item).
    feasible = caps >= item

    # Initialise all priorities to -inf (so infeasible bins are never chosen).
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # If no feasible bin exists, return early.
    if not np.any(feasible):
        return priorities

    # Slack after placing the item.
    slack = caps - item

    # Adaptive epsilon: a tiny fraction of the typical slack among feasible bins.
    mean_slack = np.mean(slack[feasible])
    eps = max(1e-12, 1e-6 * mean_slack)  # never zero, scales with slack magnitude.

    # Tight‑fit bias: larger when slack is smaller.
    bias = np.zeros_like(caps)
    bias[feasible] = 1.0 / (slack[feasible] + eps)

    # Modest random factor near 1 to break ties without overwhelming the bias.
    # Uniform in [0.95, 1.05].
    rand_factor = 0.95 + 0.1 * np.random.rand(caps.size)

    # Combine bias with random factor.
    priorities[feasible] = bias[feasible] * rand_factor[feasible]

    return priorities
```
