```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for assigning ``item`` to each bin in ``bins_remain_cap``.
    
    The heuristic follows the *Almost Full Fit* principle:
      * Prefer bins where the item fits and leaves the *smallest* leftover space,
        i.e., bins that become almost full after insertion.
      * If the resulting leftover is below a small threshold (``eps``), an
        additional boost is added to strongly favour such bins.
      * Bins that cannot accommodate the item receive a large negative priority.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    #"""
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Remaining capacity after (hypothetical) placement
    leftover = bins_remain_cap - item

    # Feasibility mask: bins that can actually hold the item
    feasible = leftover >= 0

    # Base priority: higher when the resulting leftover is smaller
    base_priority = -leftover

    # Extra boost for bins that become “almost full”
    eps = 0.1               # tolerance defining “almost full”
    boost_factor = 10.0     # magnitude of the boost
    boost = np.where(leftover <= eps, (eps - leftover) * boost_factor, 0.0)

    # Combine base priority and boost; infeasible bins get -inf
    priorities = np.where(feasible, base_priority + boost, -np.inf)

    return priorities
```
