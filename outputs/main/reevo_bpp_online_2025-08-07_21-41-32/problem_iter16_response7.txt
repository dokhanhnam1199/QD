```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    tolerance: float = 1e-12,
    eps: float = 1e-12,
    rand_scale: float = 1e-3,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    Computes a score for each open bin indicating how desirable it is to place
    the incoming ``item`` into that bin. Higher scores are preferred.

    The scoring policy:
        * Only consider bins that can accommodate the item (within tolerance).
        * Favor tighter fits by normalising slack and inverting it.
        * Scale the bias by the fraction of feasible bins (encourages opening a
          new bin when many bins are feasible).
        * Apply a tiny random perturbation to break ties and add diversity.
        * Apply a deterministic tie‑breaker that slightly penalises higher
          bin indices (prefers lower‑indexed bins).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility check.
    eps : float, optional
        Small constant to avoid division by zero.
    rand_scale : float, optional
        Maximum magnitude of the random perturbation (relative to the bias).
    tie_breaker : float, optional
        Weight applied to the bin index for deterministic tie‑breaking.
    random_state : np.random.Generator, optional
        Random number generator for reproducibility. If ``None``, the default
        global RNG is used.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins are
        assigned ``-np.inf``.
    """
    # Resolve RNG
    rng = random_state if random_state is not None else np.random.default_rng()

    # Ensure a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Edge case: no bins at all
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask (bins that can fit the item)
    feasible = caps >= (item - tolerance)

    # Initialise all scores to -inf (infeasible)
    scores = np.full(n_bins = n_bins, fill_value=-np.inf, dtype=float)
    # Note: the above line will cause syntax error; correct usage below

    # Fixed the initialization line
    scores = np.full(n_bins, -np.inf, dtype=float)

    # If no feasible bins, return all -inf scores
    if not np.any(feasible):
        return scores

    # Slack after placing the item (non‑negative)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Normalise slack so the largest slack among feasible bins becomes 1
    max_slack = slack.max() + eps
    norm_slack = slack / max_slack

    # Bias: tighter fit → larger value
    bias = 1.0 / (norm_slack + eps)

    # Weight bias by the fraction of feasible bins (encourages new bins
    # when many feasible bins exist)
    feasible_frac = feasible.sum() / n_bins
    bias *= feasible_frac

    # Random perturbation (multiplicative)
    random_factor = 1.0 + rng.random(bias.shape) * rand_scale
    bias *= random_factor

    # Determinfeasible bins, scores stay -inf; for feasible bins, apply tie‑breaker
    # Lower indices get a tiny advantage (i.e., subtract a small amount)
    tie = np.arange(n_bins, dtype=float)[feasible] * tie_breaker
    scores[feasible] = bias - tie

    return scores
```
