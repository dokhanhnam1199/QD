```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing.

    For each feasible bin, compute a bias based on the remaining slack
    (1 / (slack + eps)), optionally amplified for bins that are already
    more full (smaller remaining capacity).  The amplification factor
    grows over time to encourage tighter packing as the problem progresses.

    A small random perturbation is added to the scores to break ties
    stochastically.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher = more attractive).  Infeasible
        bins receive ``-np.inf``.
    """
    # Ensure a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask
    feasible = caps >= item
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Compute slack and bias
    slack = caps[feasible] - item
    eps = 1e-12
    bias = 1.0 / (slack + eps)  # larger when slack is small

    # Adaptation over time: progressively emphasize bins that are already
    # more full (smaller remaining capacity).  The adaptation factor
    # grows linearly with the number of calls up to a maximum.
    if not hasattr(priority_v2, "_call_count"):
        priority_v2._call_count = 0
    priority_v2._call_count += 1
    alpha = min(1.0, priority_v2._call_count / 2000.0)  # increase over ~2000 calls

    # Weight factor based on remaining capacity relative to the maximum
    # among feasible bins.  Bins with smaller remaining get a higher weight.
    max_remain = caps[feasible].max()
    weight_factor = 1.0 + alpha * (max_remain - caps[feasible]) / max_remain

    # Combine bias and weight
    scores = bias * weight_factor

    # Stochastic tie‑breaking: add tiny random noise.
    rng = np.random.default_rng()
    # Scale noise relative to the magnitude of the scores to keep it small.
    max_score = np.max(scores)
    noise_scale = 1e-6 * (max_score if max_score > 0 else 1.0)
    noise = rng.uniform(-noise_scale, noise_scale, size=scores.shape)
    scores += noise

    # Assign to the output array
    priorities[feasible] = scores
    return priorities
```
