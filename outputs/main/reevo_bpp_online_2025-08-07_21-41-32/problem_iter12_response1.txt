```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    For each currently open bin we compute a score; the bin with the highest
    score will receive the incoming item.  The score favours:
      * Feasibility (the bin must have enough remaining capacity).
      * Tight fits (small slack after insertion).
      * A small deterministic tie‑breaker based on the bin index.
      * Random diversification to avoid pathological deterministic behaviour.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks (default 1e-12).
    epsilon : float, optional
        Small constant added to slack to avoid division by zero
        (default 1e-12).
    tie_breaker : float, optional
        Weight applied to the bin index to break ties deterministically.
        Must be small enough not to outweigh the main bias (default 1e-12).
    random_state : np.random.Generator, optional
        Random number generator for reproducibility. If ``None`` a new
        default generator is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins
        receive ``-np.inf`` (negative infinity) and will never be selected.
    """
    # Ensure a random generator is available.
    rng = random_state if random_state is not None else np.random.default_rng()

    # Flatten and cast capacities to float.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Determine which bins can accommodate the item (within tolerance).
    feasible = caps >= (item - tolerance)

    # Initialise all scores to -inf (infeasible by default).
    scores = np.full(n_bins, -np.inf, dtype=float)

    # Early exit if no bin can hold the item.
    if not np.any(feasible):
        return scores

    # Compute slack (remaining capacity after the item would be placed).
    # Clip negative values caused by floating‑point noise.
    slack = np.maximum(caps - item, 0.0)

    # Bias: larger for tighter fits (smaller slack). Adding epsilon avoids div‑by‑0.
    bias = 1.0 / (slack + epsilon)

    # Random component: one uniform number per bin.
    rand = rng.random(n_bins)

    # Deterministic tie‑breaker: smaller index => slightly higher score.
    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker

    # Combine the three components.
    #   bias * rand   -> favours tight fits while still randomising.
    #   - idx_factor  -> breaks exact ties in favour of lower indices.
    scores[feasible] = bias[feasible] * rand[feasible] - idx_factor[feasible]

    return scores
```
