{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    eps: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility (default 1e-12).\n    tie_breaker : float, optional\n        Small deterministic bias to break ties; lower indices get higher priority\n        (default 1e-12).\n    eps : float, optional\n        Small constant to avoid division by zero (default 1e-12).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Normalise slack to [0, 1] (smaller slack => smaller norm)\n    max_slack = slack.max()\n    slack_norm = slack / (max_slack + eps)\n\n    # Adaptive weighting: more weight on slack when many bins are feasible\n    feasible_frac = feasible.sum() / n_bins  # \u2208 (0, 1]\n    w_slack = feasible_frac\n\n    # Base score: tighter fit (smaller slack) gets higher (less negative) score\n    base_score = -slack_norm\n    weighted_score = w_slack * base_score\n\n    # Deterministic tie\u2011breaker: lower index \u2192 higher priority\n    indices = np.arange(n_bins)\n    tie = -indices[feasible] * tie_breaker\n\n    priorities[feasible] = weighted_score + tie\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Simple priority function for online bin packing.\n\n    - Gives a higher score to bins that can accommodate the item.\n    - Biases towards tighter fits (smaller slack) by using 1/(slack+\u03b5).\n    - Breaks ties randomly by multiplying the bias with a uniform random number.\n    - Infeasible bins receive -np.inf so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin, same shape as\n        ``bins_remain_cap``.\n    \"\"\"\n    # Convert to a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Numerical tolerance for feasibility.\n    tol = 1e-12\n    feasible = caps >= (item - tol)\n\n    # Initialise priorities to -inf (infeasible by default).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can hold the item.\n        return priorities\n\n    # Slack (remaining space after placing the item) for feasible bins.\n    slack = caps[feasible] - item\n    # Small epsilon avoids division by zero for exact fits.\n    eps = 1e-12\n    bias = 1.0 / (slack + eps)      # larger when slack is smaller (tighter fit)\n\n    # Random tie\u2011breaker: uniform numbers in (0, 1).\n    rand = np.random.rand(feasible.sum())\n\n    # Combine bias with randomness; multiplication preserves bias while randomising.\n    priorities[feasible] = bias * rand\n\n    return priorities\n\n[Reflection]\nBias toward tighter fits via\u202f1/(slack+\u03b5), random tie\u2011breaking; avoid complex adaptive weights; keep vectorized and numerically stable.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}