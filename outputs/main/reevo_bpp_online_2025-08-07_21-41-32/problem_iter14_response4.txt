```python
import numpy as np
from typing import Optional

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                tolerance: float = 1e-12,
                eps: float = 1e-12,
                noise_scale: float = 1e-6,
                tie_breaker: float = 1e-15,
                slack_threshold: float = np.inf,
                rng: Optional[np.random.Generator] = None) -> np.ndarray:
    """
    Compute priority scores for bins in an online bin‑packing setting.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the open bins.
    tolerance : float, optional
        Numerical tolerance for feasibility checks.
    eps : float, optional
        Small constant added to slack to avoid division by zero.
    noise_scale : float, optional
        Relative magnitude of the stochastic tie‑breaking noise.
    tie_breaker : float, optional
        Deterministic penalty per bin index to break exact ties.
    slack_threshold : float, optional
        Maximum slack that is considered "tight".  Slacks larger than this
        will be penalised proportionally.
    rng : np.random.Generator, optional
        Random number generator for reproducibility.  If ``None`` a new
        default generator is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better).  Bins that cannot
        accommodate the item receive ``-np.inf``.
    """
    rng = rng or np.random.default_rng()

    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask
    feasible = caps >= (item - tolerance)

    # Initialise all scores to -inf
    scores = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return scores

    # Compute slack after placing the item
    slack = np.maximum(caps[feasible] - item, 0.0)

    # Bias: tighter fit => larger bias
    bias = 1.0 / (slack + eps)

    # Slack threshold penalty: penalise bins with slack larger than the threshold
    if slack_threshold != np.inf:
        penalty_factor = np.where(
            slack <= slack_threshold,
            1.0,
            slack_threshold / slack
        )
        bias *= penalty_factor

    # Random tie‑breaking component, scaled with the bias
    rand = rng.random(feasible.sum())
    noise = rand * noise_scale * bias

    # Deterministic tie‑breaker: lower index gets a slight advantage
    idx_penalty = np.arange(n_bins, dtype=float) * tie_breaker

    # Combine components
    scores[feasible] = bias + noise - idx_penalty[feasible]

    return scores
```
