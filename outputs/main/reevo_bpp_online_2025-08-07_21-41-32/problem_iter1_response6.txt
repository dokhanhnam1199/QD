```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Sigmoid Fit Score priority function for the online Bin Packing Problem.

    The idea is to give higher priority to bins that will be tightly packed
    after the item is placed, while still respecting the feasibility constraint.
    A logistic (sigmoid) transformation is applied to the normalised residual
    capacity of each feasible bin.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``).  Higher
        scores indicate a more desirable bin for the item.  Bins that cannot
        accommodate the item receive ``-np.inf``.
    """
    # Ensure we work with a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Default: infeasible bins get the lowest possible priority
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Identify bins that are large enough to host the item
    feasible = caps >= item
    if not np.any(feasible):
        # No existing bin can take the item → caller will likely open a new bin
        return priorities

    # Residual capacity after placing the item in each feasible bin
    residual = caps[feasible] - maybe from ... 
I realize the previously truncated text might confuse.
I'll continue and correct the output.

The final code should be presented clearly, without comments that cause confusion.

Here is the corrected version:

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Sigmoid Fit Score priority function for online bin packing.
    
    Returns a higher score for bins that will be tightly filled after
    inserting ``item`` while respecting the feasibility constraint.
    
    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the current bins.
    
    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``). Infeasible
        bins receive ``-np.inf``.
    """
    # Normalise input to a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Initialise priorities with -inf (worst possible) for infeasible bins
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Feasibility mask: bins that can accommodate the item
    feasible = caps >= item
    if not np.any(feasible):
        return priorities  # all bins too small

    # Residual capacity after hypothetically placing the item
    residual = caps[feasible] - item

    # Estimate the (uniform) bin capacity.
    # In online BPP all bins share the same max capacity, which we infer as
    # the maximum remaining capacity among currently open bins (i.e., a fresh bin).
    bin_capacity = caps.max() if caps.max() > 0 else item + residual.max()

    # Normalised leftover: range [0, 1]
    norm_res = residual / bin_capacity

    # Sigmoid hyper‑parameters (tunable)
    alpha = 12.0   # steepness of the curve
    beta = 0.15    # target leftover fraction (prefer ≤15% free space)

    # Compute sigmoid fit score: close to 1 for small leftovers,
    # close to 0 for large leftovers.
    fit_score = 1.0 / (1.0 + np.exp(alpha * (norm_res - beta)))

    # Assign scores back to the feasible positions
    priorities[feasible] = fit_score

    return priorities
```

However, the above content is incomplete and seems to cut off abruptly. 
Below is the complete, corrected implementation:

```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Sigmoid Fit Score priority function for online bin packing.
    
    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of the current bins.
    
    Returns
    -------
    np.ndarray
        Priority scores (same shape as ``bins_remain_cap``). Infeasible
        bins receive ``-np.inf``.
    """
    # Ensure a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Default priorities: -inf for bins that cannot host the item
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Feasibility mask
    feasible = caps >= item
    if not np.any(feasible):
        return priorities

    # Residual capacity after placing the item
    residual = caps[feasible] - item

    # Estimate uniform bin capacity (the size of a fresh bin capacity)
    bin_capacity = caps.max() if caps.max() > 0 else item + residual.max()

    # Normalised leftover (0 = perfect fit, 1 = completely empty)
    norm_res = residual / bin_capacity

    # Sigmoid parameters
    alpha = 12.0   # controls steepness
    beta = 0.15    # target leftover fraction (prefer ≤15% free)

    # Sigmoid fit score: high when leftover is small
    fit_score = 1.0 / (1.0 + np.exp(alpha * (norm_res - beta)))

    # Assign scores to feasible bins
    priorities[feasible] = fit_score

    return priorities
```
