```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (BPP).

    Computes a score for each open bin; the bin with the highest score will
    receive the incoming item. Infeasible bins are assigned -inf.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks (default 1e-12).
    epsilon : float, optional
        Small constant added to slack to avoid division by zero (default 1e-12).
    tie_breaker : float, optional
        Tiny weight for deterministic tie‑breaking based on bin index (default 1e-12).
    random_state : np.random.Generator, optional
        Random number generator for reproducibility. If None, a new default
        generator is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Infeasible bins have -inf.
    """
    # Use provided RNG or create a new one for reproducibility.
    rng = random_state if random_state is not None else np.random.default_rng()

    # Flatten capacities to a 1‑D float array.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Identify bins that can accommodate the item (within tolerance).
    feasible = caps >= (item - tolerance)

    # Initialise all scores to -inf (infeasible by default).
    scores = np.full(n_bins, -np.inf, dtype=float)

    # Early exit if no bin can hold the item.
    if not np.any(feasible):
        return scores

    # Compute slack (remaining capacity after placing the item) and clip negatives.
    slack = np.maximum(caps - item, 0.0)

    # Bias favouring tight fits: smaller slack → larger bias.
    bias = 1.0 / (slack + epsilon)

    # Random component per bin for diversification.
    rand_vals = rng.random(n_bins)

    # Deterministic tie‑breaker: lower index gets a tiny advantage.
    tie = np.arange(n_bins, dtype=float) * tie_breaker

    # Combine components for feasible bins.
    scores[feasible] = bias[feasible] * rand_vals[feasible] - tie[feasible]

    return scores
```
