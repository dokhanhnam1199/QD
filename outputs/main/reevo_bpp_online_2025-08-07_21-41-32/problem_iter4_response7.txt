```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive exponential‑boost priority for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently open bin.

    Returns
    -------
    np.ndarray
        Priority score for each bin; higher values indicate a more desirable
        placement. Infeasible bins receive ``-np.inf`` so they are never chosen.
    """
    # Ensure a floating‑point view of the capacities.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Capacity that would remain after placing the item.
    leftover = caps - item

    # Feasibility mask: True for bins that can hold the item.
    feasible = leftover >= 0

    # Base priority: larger when the resulting leftover is smaller.
    base_priority = -leftover

    # Adaptive epsilon for the exponential boost.
    # Use the mean leftover of feasible bins (cheap O(n) operation);
    # fall back to a tiny constant if no bin is feasible.
    if np.any(feasible):
        eps = max(np.mean(leftover[feasible]), 1e-6)
    else:
        eps = 1e-6

    # Exponential boost: strongest when leftover ≈ 0, decays quickly.
    boost_factor = 5.0
    boost = boost_factor * np.exp(-leftover / eps)

    # Combine base priority and boost; penalise infeasible bins.
    priority = np.where(feasible, base_priority + boost, -np.inf)

    # Tiny random perturbation for deterministic tie‑breaking.
    rng = np.random.default_rng()
    noise = rng.random(priority.shape) * 1e-12
    priority[feasible] += noise[feasible]

    return priority
```
