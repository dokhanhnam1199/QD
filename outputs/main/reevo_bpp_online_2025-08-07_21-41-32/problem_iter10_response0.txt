```python
import numpy as np

# Global, reproducible RNG for optional stochastic tie‑breaking
_rng = np.random.default_rng(12345)


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority function for online bin packing (v2).

    Computes a score for each bin such that feasible bins (remaining capacity
    >= ``item``) receive higher scores when they provide a tighter fit
    (i.e., smaller slack). The score is based directly on the slack value,
    with a tiny random perturbation for stochastic tie‑breaking and a
    deterministic index penalty to guarantee a strict total ordering.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the existing bins.

    Returns
    -------
    np.ndarray
        Array of priority scores (same length as ``bins_remain_cap``). Infeasible
        bins have ``-np.inf`` so they are never selected.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    n = caps.size

    # Initialise all scores to -inf (infeasible by default)
    priorities = np.full(n, -np.inf, dtype=float)
    if n == 0:
        return priorities

    slack = caps - item
    feasible = slack >= 0
    if not np.any(feasible):
        return priorities

    # Base score: negative slack (higher for tighter fits)
    base_score = -slack[feasible]

    # Tiny random noise for stochastic tie‑breaking (reduced magnitude)
    rand_noise = _rng.random(base_score.shape) * 1e-12

    # Deterministic index penalty (very small) to break any remaining ties
    idx = np.nonzero(feasible)[0].astype(float)
    idx_penalty = idx * 1e-15

    # Final scores for feasible bins
    scores = base_score + rand_noise - idx_penalty
    priorities[feasible] = scores

    return priorities
```
