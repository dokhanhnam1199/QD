```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    tolerance: float = 1e-12,
    eps: float = 1e-12,
    rand_scale: float = 1e-3,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for online Bin Packing that:
        * only considers bins that can fit the item,
        * favours tighter fits (smaller slack),
        * normalises slack to compare bins fairly,
        * slightly weights all feasible bins together,
        * adds a tiny random perturbation to avoid deterministic loops,
        * uses a deterministic tie‑breaker favouring lower indices.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks.
    eps : float, optional
        Small constant to avoid division by zero.
    rand_scale : float, optional
        Maximum scale of the random perturbation (kept small).
    tie_breaker : float, optional
        Weight applied to the bin index for deterministic tie‑breaking.
    random_state : np.random.Generator, optional
        RNG for reproducibility; if None a default RNG is used.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better). Infeasible bins receive ``-np.inf``.
    """
    rng = random_state if random_state is not None else np.random.default_rng()

    # Ensure a flat float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask
    feasible = caps >= (item - tolerance)

    # Scores: infeasible bins get -inf
    scores = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return scores

    # Slack after placing the item
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Normalise slack so that the largest slack among feasible bins is 1
    max_slack = slack.max() + eps
    norm_slack = slack / max_slack

    # Bias: tighter fit → larger value
    bias = 1.0 / (norm_slack + eps)

    # Weight the bias by the fraction of feasible bins (encourages opening new bins when many options)
    feasible_frac = feasible.sum() / n_bins
    bias *= feasible_frac

    # Small random factor to diversify choices
    rand_factor = 1.0 + rng.random(feasible.sum()) * rand_scale

    # Deterministic tie‑breaker: lower index gets a tiny advantage
    indices = np.arange(n_bins)
    tie = indices[feasible] * tie_breaker

    # Final score: bias + randomness, then break ties
    scores[feasible] = bias * rand_factor - tie

    return scores
```
