```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Random Fit priority for online bin packing.

    Each feasible bin (with enough remaining capacity) receives a random score.
    Infeasible bins receive -inf so they are never selected. This implements a
    pure random fit strategy, optionally biased toward tighter fits.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities for each bin.

    Returns:
        A 1‑D array of priority scores, one per bin.
    """
    # Ensure capacities are a float array.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item.
    feasible = caps >= item

    # Initialise all priorities to -inf (so infeasible bins are never chosen).
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # Generate independent random numbers for each bin.
    rand_scores = np.random.rand(caps.size)

    # Bias towards tighter fits: less slack -> larger bias.
    # Small epsilon avoids division by zero for exact fits.
    epsilon = 1e-12
    slack = caps - item
    bias = np.zeros_like(caps)
    bias[feasible] = 1.0 / (slack[feasible] + epsilon)  # higher when slack is small

    # Combine random component with bias.
    # Multiplying emphasizes bins with higher bias while preserving randomness.
    priorities[feasible] = bias[feasible] * rand_scores[feasible]

    return priorities
```
