[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    eps: float = 1e-12,\n    rng: np.random.Generator = None\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing.\n\n    Combines a bias for tighter fits, weighting by the fraction of feasible bins,\n    a random component for stochastic tie\u2011breaking, and a deterministic tie\u2011breaker\n    that prefers lower\u2011indexed bins. Infeasible bins receive -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently open bin.\n    eps : float, optional\n        Small constant to avoid division by zero.\n    rng : np.random.Generator, optional\n        Random number generator for reproducibility. If None, a default RNG is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Normalise input to a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance for floating\u2011point errors).\n    tolerance = eps\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities as -inf (infeasible bins).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accommodate the item.\n        return priorities\n\n    # Slack after placing the item (clip to zero to avoid negative values).\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Bias toward tighter fits: larger when slack is smaller.\n    bias = 1.0 / (slack + eps)\n\n    # Weight the bias by the fraction of feasible bins.\n    feasible_frac = feasible.sum() / n_bins\n    weighted_bias = bias * feasible_frac\n\n    # Random component for stochastic tie\u2011breaking.\n    if rng is None:\n        rng = np.random.default_rng()\n    rand_scores = rng.random(weighted_bias.shape)\n\n    # Combine bias and randomness \u2013 bias dominates but randomness perturbs the order.\n    combined = weighted_bias * rand_scores\n\n    # Deterministic tie\u2011breaker: favour lower\u2011index bins by a tiny decreasing term.\n    indices = np.arange(n_bins)\n    tie_breaker = 1e-12\n    deterministic = -indices[feasible] * tie_breaker\n\n    # Assign the final scores to the feasible bins.\n    priorities[feasible] = combined + deterministic\n\n    return priorities",
    "response_id": 0,
    "obj": 3.9688871160749857,
    "SLOC": 27.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    For each currently open bin we compute a score; the bin with the highest\n    score will receive the incoming item.  The score favours:\n      * Feasibility (the bin must have enough remaining capacity).\n      * Tight fits (small slack after insertion).\n      * A small deterministic tie\u2011breaker based on the bin index.\n      * Random diversification to avoid pathological deterministic behaviour.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks (default 1e-12).\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero\n        (default 1e-12).\n    tie_breaker : float, optional\n        Weight applied to the bin index to break ties deterministically.\n        Must be small enough not to outweigh the main bias (default 1e-12).\n    random_state : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None`` a new\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Infeasible bins\n        receive ``-np.inf`` (negative infinity) and will never be selected.\n    \"\"\"\n    # Ensure a random generator is available.\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Flatten and cast capacities to float.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Determine which bins can accommodate the item (within tolerance).\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all scores to -inf (infeasible by default).\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if no bin can hold the item.\n    if not np.any(feasible):\n        return scores\n\n    # Compute slack (remaining capacity after the item would be placed).\n    # Clip negative values caused by floating\u2011point noise.\n    slack = np.maximum(caps - item, 0.0)\n\n    # Bias: larger for tighter fits (smaller slack). Adding epsilon avoids div\u2011by\u20110.\n    bias = 1.0 / (slack + epsilon)\n\n    # Random component: one uniform number per bin.\n    rand = rng.random(n_bins)\n\n    # Deterministic tie\u2011breaker: smaller index => slightly higher score.\n    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Combine the three components.\n    #   bias * rand   -> favours tight fits while still randomising.\n    #   - idx_factor  -> breaks exact ties in favour of lower indices.\n    scores[feasible] = bias[feasible] * rand[feasible] - idx_factor[feasible]\n\n    return scores",
    "response_id": 1,
    "obj": 3.9389708815317115,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    eps: float = 1e-12,\n    tolerance: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    The function assigns a higher score to bins that can accommodate the incoming\n    item and favours tighter fits (smaller remaining slack). Random numbers are\n    used as tie\u2011breakers, guaranteeing a deterministic selection only when the\n    random seed is fixed.\n\n    Parameters\n    :param item: Size of the incoming item.\n    :param bins_remain_cap: 1\u2011D array of remaining capacities of currently open bins.\n    :param eps: Small constant to avoid division by zero for exact fits.\n    :param tolerance: Numerical tolerance when checking feasibility.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin; infeasible bins receive\n        ``-np.inf`` so they are never selected.\n    \"\"\"\n    # Ensure a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Determine which bins can actually host the item (allowing a tiny tolerance).\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities to -inf (infeasible by default).\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if nothing fits.\n    if not np.any(feasible):\n        return priorities\n\n    # Compute slack (remaining space after placing the item) for feasible bins.\n    slack = caps[feasible] - item\n    # Numerical noise may produce tiny negative values; clip to zero.\n    slack = np.maximum(slack, dtype=float, where=slack > 0, out=np.zeros_like(slack))\n    # Bias toward tighter fits: larger when slack is smaller.\n    bias = 1.0 / (slack + eps)\n\n    # Random tie\u2011breaker: a uniform random number in (0, 1) for each feasible bin.\n    rand = np.random.rand(bias.size)\n\n    # Combine bias with randomness. Multiplication preserves the bias ordering\n    # while still randomising ties.\n    priorities[feasible] = bias * rand\n\n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 47, in priority_v2\n    # Slack after placing the item (clip to non\u2011negative)\nTypeError: maximum() takes from 2 to 3 positional arguments but 1 were given\n19\n2\n"
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\n# Global reproducible RNG for stochastic tie\u2011breaking\n_rng = np.random.default_rng(12345)\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The score favours feasible bins (capacity >= item) that give a tighter fit,\n    normalises the inverse\u2011slack bias, adds a tiny random perturbation for\n    stochastic tie\u2011breaking, and finally adds a deterministic index penalty\n    to guarantee a strict total ordering.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12      # feasibility tolerance\n    _EPS = 1e-12      # avoid division by zero\n    _RND_EPS = 1e-12  # magnitude of random perturbation\n    _TIE = 1e-15      # deterministic tie\u2011breaker magnitude\n\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities to -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (clip to non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias in feasible bins:\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to (0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Tiny random component for stochastic tie\u2011breaking\n    rand_noise = _rng.random(bias.shape) * _RND_EPS\n\n    # Blend bias with random noise (addition)\n    blended = bias_norm + rand_noise\n\n    # Deterministic tie\u2011breaker: lower index \u2192 slightly higher priority\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended + tie_breaker\n\n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 52\n    bias in feasible bins:\n                     ^^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 52\n    bias in feasible bins:\n                     ^^^^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 52\n    bias in feasible bins:\n                     ^^^^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.  Infeasible bins\n        receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = caps.size\n\n    # Feasibility check with a tiny tolerance\n    tol = 1e-12\n    slack = caps - item\n    feasible = slack >= -tol\n\n    # No feasible bin \u2192 all priorities are -inf\n    if not feasible.any():\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # Slack after placement (non\u2011negative for feasible bins)\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias, zero for infeasible bins\n    bias = np.zeros_like(slack)\n    bias[feasible] = 1.0 / (slack[feasible] + tol)\n\n    # Weight bias by fraction of feasible bins\n    feasible_frac = feasible.sum() / n_bins\n    bias *= feasible_frac\n\n    # Random multiplier (higher bias gets larger random factor)\n    rand = np.random.rand(feasible.sum())\n    score = bias[feasible] * rand\n\n    # Deterministic tie\u2011breaker: lower index \u2192 higher priority\n    idx = np.arange(n_bins)[feasible]\n    score += -idx * 1e-12\n\n    # Assemble final priority array\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n    priorities[feasible] = score\n    return priorities",
    "response_id": 4,
    "obj": 4.068607897885915,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    epsilon: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks.\n    tie_breaker : float, optional\n        Small bias to favor lower\u2011index bins when priorities are equal.\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  Higher scores indicate more desirable bins.\n        Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    if n_bins == 0:\n        return np.empty(0, dtype=float)\n\n    # Feasible bins: capacity is enough to accommodate the item\n    feasible = caps >= (item - tolerance)\n\n    # Default priorities: -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Bias toward tight fits: 1/(slack + epsilon)\n    bias = 1.0 / (slack + epsilon)\n\n    # Weight bias by the fraction of feasible bins\n    feasible_frac = feasible.sum() / n_bins\n    weighted_bias = feasible_frac * bias\n\n    # Random diversification factor (0 to 1)\n    rand = np.random.rand(n_bins)\n\n    # Indices of feasible bins (used for tie\u2011breaking)\n    idx = np.nonzero(feasible)[0]\n\n    # Combine weighted bias, random factor, and tie\u2011breaker\n    priorities[feasible] = weighted_bias * rand[feasible] - idx * tie_breaker\n\n    return priorities",
    "response_id": 5,
    "obj": 4.0885520542481055,
    "SLOC": 24.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing setting.\n\n    The priority blends an inverse\u2011slack bias (tight fits) with a random factor\n    and a tiny deterministic tie\u2011breaker based on the bin index. Bins that\n    cannot accommodate the item receive ``-np.inf`` so they are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12   # feasibility tolerance\n    _EPS = 1e-12   # to avoid division by zero\n    _TIE = 1e-12   # deterministic tie\u2011breaker magnitude\n\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - _TOL)\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1]\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Random component in [0, 1) for feasible bins\n    rng = np.random.default_rng()\n    rand_vals = rng.random(bias_norm.shape)\n\n    # Blend bias and randomness multiplicatively\n    blended = bias_norm * rand_vals\n\n    # Normalise blended scores to [0, 1]\n    blended_norm = blended / (blended.max() + _EPS)\n\n    # Deterministic tie\u2011breaker: lower index gets a slight advantage\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 6,
    "obj": 3.9888312724371757,
    "SLOC": 21.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\n# Global RNG for reproducible stochastic tie\u2011breaking, used when no RNG is supplied.\n_GLOBAL_RNG = np.random.default_rng(123456789)\n\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                *,\n                eps: float = 1e-12,\n                noise_scale: float = 1e-6,\n                idx_penalty: float = 1e-15,\n                rng: np.random.Generator = None) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    eps : float, optional\n        Small constant added to slack to avoid division by zero.\n    noise_scale : float, optional\n        Relative magnitude of the stochastic tie\u2011breaking noise. The actual\n        noise added to a bin is ``U(0,1) * noise_scale * inverse_slack``.\n    idx_penalty : float, optional\n        Deterministic penalty proportional to the bin index used to break any\n        remaining ties (very small to preserve the order dictated by the\n        inverse\u2011slack bias).\n    rng : numpy.random.Generator, optional\n        Random number generator for stochastic tie\u2011breaking. If ``None`` a\n        global reproducible generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher = more attractive). Bins that cannot accommodate\n        the item receive ``-np.inf`` so they are never selected.\n    \"\"\"\n    # Ensure a flat float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Start with infeasible scores.\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask.\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities\n\n    # Slack that would remain after placing the item.\n    slack = caps[feasible] - item\n\n    # Inverse\u2011slack bias: larger when slack is smaller (tighter fit).\n    inv_slack = 1.0 / (slack + eps)\n\n    # Stochastic tie\u2011breaking: small random perturbation scaled to the bias.\n    if rng is None:\n        rng = _GLOBAL_RNG\n    rand = rng.random(inv_slack.shape)          # Uniform [0, 1)\n    noise = rand * noise_scale * inv_slack\n\n    # Deterministic index penalty for any remaining ties.\n    idx = np.nonzero(feasible)[0].astype(float)  # indices of feasible bins\n    penalty = idx * idx_penalty\n\n    # Final priority: bias + noise \u2013 penalty.\n    scores = inv_slack + noise - penalty\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online Bin Packing setting.\n\n    The priority blends an inverse\u2011slack bias with a random component,\n    normalises the result, and adds a deterministic tie\u2011breaker based on the\n    bin index. Infeasible bins (insufficient remaining capacity) receive\n    ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Constants\n    _TOL = 1e-12          # feasibility tolerance\n    _EPS = 1e-12          # to avoid division by zero\n    _TIE = 1e-12          # deterministic tie\u2011breaker magnitude\n\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance)\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities to -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1] (max bias gets 1)\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Random component in [0, 1) for feasible bins\n    rng = np.random.default_rng()\n    rand_feas = rng.random(feasible.sum())\n\n    # Blend bias and randomness multiplicatively (emphasises both)\n    blended = bias_norm * rand_feas\n\n    # Normalise blended scores to [0, 1] (max gets 1)\n    blended_norm = blended / (blended.max() + _EPS)\n\n    # Deterministic tie\u2011breaker: lower index \u2192 slightly higher priority\n    indices = np.arange(n_bins)[feasible]\n    tie_breaker = -indices * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 8,
    "obj": 3.9988033506182825,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                tolerance: float = 1e-12,\n                epsilon: float = 1e-12,\n                tie_breaker: float = 1e-12) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin packing setting.\n\n    Higher scores indicate more desirable bins for placing the given item.\n    The function biases towards tighter fits (small slack) while adding a\n    random diversification component and a deterministic tie\u2011breaker favouring\n    bins with lower indices.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    tolerance : float, optional\n        Feasibility tolerance (allows tiny negative slack due to floating\u2011point\n        errors).\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero when computing\n        the inverse\u2011slack bias.\n    tie_breaker : float, optional\n        Small positive constant used to penalise higher\u2011index bins,\n        breaking ties deterministically.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a 1\u2011D float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: bin can accommodate the item (allow tolerance)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priorities: -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if no feasible bins\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)   # Clip tiny negatives caused by numerics\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + epsilon)\n\n    # Random diversification component\n    rng = np.random.default_rng()\n    rand = rng.random(n_bins)\n\n    # Indices of feasible bins (used for deterministic tie\u2011breaker)\n    idx = np.nonzero(feasible)[0]\n\n    # Combine bias, randomness, and tie\u2011breaker\n    priorities[feasible] = bias * rand[feasible] - idx * tie_breaker\n\n    return priorities",
    "response_id": 9,
    "obj": 3.9888312724371757,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]