```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    epsilon: float = 1e-12,
    tie_breaker: float = 1e-12,
    random_state: Optional[np.random.Generator] = None,
) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem (v2).

    Computes a priority score for each currently open bin. Higher scores
    indicate a more desirable bin for placing the incoming item.

    The scoring favours:
      * Feasibility (bin must have enough remaining capacity).
      * Exact fits (small slack after insertion).
      * Larger fraction of the bin's capacity being utilized by the item.
      * Tiny random noise (seeded per bin) to break pathological ties.
      * Deterministic tie‑breaker based on bin index.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of open bins.
    tolerance : float, optional
        Numerical tolerance for feasibility check (default 1e-12).
    epsilon : float, optional
        Small constant to avoid division by zero (default 1e-12).
    tie_breaker : float, optional
        Weight for deterministic index tie‑breaker (default 1e-12).
    random_state : np.random.Generator, optional
        Random generator for reproducibility. If None, a default generator
        is created.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Infeasible bins receive ``-np.inf``.
    """
    # Ensure we have a random generator.
    rng = random_state if random_state is not None else np.random.default_rng()

    # Convert capacities to a 1‑D float array.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Determine feasibility.
    feasible = caps >= (item - tolerance)

    # Initialise scores with -inf for infeasible bins.
    scores = np.full(n_bins, -np.inf, dtype=float)

    # Early exit if no feasible bin exists.
    if not np.any(feasible):
        return scores

    # Compute slack after insertion (clip negative values to zero).
    slack = np.maximum(caps - item, 0.0)

    # Bias favouring tight fits.
    bias = 1.0 / (slack + epsilon)

    # Fraction of the bin's capacity that the item would occupy.
    # Guard against division by zero using epsilon.
    cap_denominator = np.maximum(caps, epsilon)
    fill_fraction = np.zeros_like(caps)
    fill_fraction[feasible] = item / cap_denominator[feasible]

    # Base score: bias weighted by how much of the bin is filled.
    base_score = bias * fill_fraction

    # Tiny random noise to diversify decisions (scaled by epsilon).
    random_noise = rng.random(n_bins) * epsilon

    # Deterministic tie‑breaker: lower index gets a slight advantage.
    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker

    # Final score for feasible bins.
    scores[feasible] = base_score[feasible] + random_noise[feasible] - idx_factor[feasible]

    return scores
```
