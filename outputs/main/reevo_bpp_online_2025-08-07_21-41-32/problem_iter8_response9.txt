```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin in an online bin‑packing setting.

    The score is the product of an inverse‑slack bias and a random factor.
    Infeasible bins receive ``-np.inf`` so they are never chosen.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; higher values indicate a more
        desirable placement. Infeasible bins have ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    feasible = caps >= item
    priority = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        return priority

    slack = caps[feasible] - item
    # Adapt epsilon to the mean slack of feasible bins
    eps = max(np.mean(slack), 1e-9)

    # Inverse‑slack bias: tighter fits get larger bias
    bias = 1.0 / (slack + eps)

    rng = np.random.default_rng()
    rand_scores = rng.random(bias.size)

    # Combine bias with random exploration
    priority[feasible] = bias * rand_scores

    # Tiny noise for deterministic tie‑breaking (optional)
    priority[feasible] += rng.random(bias.size) * 1e-12

    return priority
```
