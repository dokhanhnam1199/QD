```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Softmax‑Based Fit priority for online bin packing.

    The priority for a bin i is proportional to exp(−slack_i / τ),
    where slack_i = bins_remain_cap[i] − item. Bins that cannot accommodate
    the item receive a priority of -inf so they are never selected.
    The temperature τ is adapted to the current dispersion of remaining
    capacities: a higher variance yields a softer (higher‑temperature) distribution.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of all currently open bins.

    Returns
    -------
    np.ndarray
        Array of priority scores (one per bin). The bin with the highest
        score should be chosen.
    """
    # Compute slack (remaining space after placing the item)
    slack = bins_remain_cap - item

    # Feasibility mask: only consider bins with non‑negative slack
    feasible = slack >= 0

    # If no bin can accommodate the item, return an array of -inf priorities
    if not np.any(feasible):
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Adaptive temperature τ: scale with the variability of the remaining capacities.
    # Use a baseline to avoid extremely low τ.
    eps = 1e-12
    std_cap = np.std(bins_remain_cap)
    tau = max(0.1, std_cap)  # baseline of 0.1 ensures a sensible temperature

    # Compute scaled negative slack for feasible bins
    scaled = -slack[feasible] / tau

    # Numerical stability: subtract the max before exponentiation
    max_scaled = np.max(scaled)
    exp_vals = np.exp(scaled - max_scaled)

    # Initialize priorities with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Assign softmax scores to feasible bins
    priorities[feasible] = exp_vals

    return priorities
```
