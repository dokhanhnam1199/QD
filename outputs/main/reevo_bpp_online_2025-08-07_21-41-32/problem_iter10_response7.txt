```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                tolerance: float = 1e-12,
                tie_breaker: float = 1e-12,
                epsilon: float = 1e-12) -> np.ndarray:
    """
    Priority for online bin packing that biases towards tight fits and adds
    random diversification.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.
    tolerance : float, optional
        Acceptable negative slack due to floating point errors.
    tie_breaker : float, optional
        Small value used to break ties in favor of lower index bins.
    epsilon : float, optional
        Small constant added to slack to avoid division by zero.

    Returns
    -------
    np.ndarray
        Priority scores; larger is better.  Feasible bins get a finite score,
        infeasible bins get -inf.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n = caps.size

    # Feasible bins: can accommodate the item (within tolerance)
    feasible = caps >= (item - tolerance)

    # Default: infeasible bins get -inf
    priorities = np.full(n, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Slack: remaining capacity after packing the item
    slack = caps[feasible] - item
    # Clip tiny negative values caused by numerical noise
    slack = np.maximum(slack, 0.0)

    # Bias: higher for tighter fits
    bias = 1.0 / (slack + epsilon)

    # Random component for diversification
    rand = np.random.rand(n)

    # Indices of feasible bins (to apply tie‑breaker)
    idx = np.nonzero(feasible)[0]

    # Combine bias and randomness; higher score is better
    priorities[feasible] = bias * rand[feasible] - idx * tie_breaker

    return priorities
```
