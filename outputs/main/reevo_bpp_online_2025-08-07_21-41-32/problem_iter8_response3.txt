```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    tolerance: float = 1e-12,
    tie_breaker: float = 1e-12,
    eps: float = 1e-12,
) -> np.ndarray:
    """
    Adaptive priority function for online bin packing.

    - Favors exact (tight) fits.
    - Uses a deterministic tie‑breaker based on bin index.
    - Adjusts the influence of the slack (remaining space) according to the
      proportion of feasible bins.
    - Infeasible bins receive ``-np.inf`` so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility (default 1e-12).
    tie_breaker : float, optional
        Small deterministic bias to break ties; lower indices get higher
        priority (default 1e-12).
    eps : float, optional
        Small constant to avoid division by zero (default 1e-12).

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask (allow a tiny tolerance)
    feasible = caps >= (item - tolerance)

    # Initialise all priorities to -inf (infeasible by default)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Slack after placing the item (non‑negative)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Normalise slack to [0, 1] (smaller slack => smaller norm)
    max_slack = slack.max()
    slack_norm = slack / (max_slack + eps)

    # Adaptive weighting: more weight on slack when many bins are feasible
    feasible_frac = feasible.sum() / n_bins  # ∈ (0, 1]
    w_slack = feasible_frac  # higher when many bins can accommodate the item

    # Base score: tighter fit (smaller slack) gets higher (less negative) score
    base_score = -slack_norm
    weighted_score = w_slack * base_score  # slack influence adapts to feasibility

    # Deterministic tie‑breaker: lower index → higher priority
    indices = np.arange(n_bins)
    tie = -indices[feasible] * tie_breaker

    priorities[feasible] = weighted_score + tie
    return priorities
```
