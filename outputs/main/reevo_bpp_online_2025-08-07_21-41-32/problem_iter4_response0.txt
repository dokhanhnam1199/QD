```python
import numpy as np

# Global random generator for tie‑breaking
_rng = np.random.default_rng()


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin in the online Bin Packing Problem.

    The heuristic favours bins that become almost full after placing the item,
    applying an exponential boost that decays with the leftover capacity.
    Infeasible bins receive a -inf priority so they are never selected.
    A tiny random perturbation is added to break ties non‑deterministically.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. The bin with the highest score should be
        selected for the item.
    """
    # Convert to a float array (handles list, tuple, etc.)
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no bins available
    if caps.size == 0:
        return np.empty_like(caps)

    # Leftover capacity if the item were placed in each bin
    leftover = caps - item

    # Feasibility mask: True where the bin can accommodate the item
    feasible = leftover >= 0

    # Initialise all priorities to -inf (infeasible by default)
    priority = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bins – return all -inf
        return priority

    # Extract leftovers for feasible bins only
    leftover_feas = leftover[feasible]

    # Base priority: larger when leftover is smaller (i.e., -leftover)
    base_priority = -leftover_feas

    # Adaptive epsilon: low percentile of feasible leftovers acts as scale
    eps = np.percentile(leftover_feas, 25)          # 25th percentile
    eps = max(eps, 1e-6)                            # guard against zero

    # Exponential boost: maximal boost when leftover ≈ 0, decays quickly
    boost_factor = 5.0
    boost = boost_factor * np.exp(-leftover_feas / eps)

    # Tiny random tie‑breaker (only on feasible bins)
    tie_break = _rng.random(leftover_feas.shape) * 1e-12

    # Combine components and write back to the full priority array
    priority[feasible] = np.where(feasible, base_priority + boost + tie_break, priority)

    return priority
```
