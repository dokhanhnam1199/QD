```python
import numpy as np
from typing import Optional

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    eps: float = 1e-12,
    rng: Optional[np.random.Generator] = None,
    random_weight: float = 1e-6,
) -> np.ndarray:
    """
    Priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    eps : float, optional
        Small constant used for numerical tolerance and to avoid division by zero.
    rng : np.random.Generator, optional
        Random number generator for reproducibility. If ``None``, a new default RNG is created.
    random_weight : float, optional
        Scaling factor for the random component (kept small to limit randomness).

    Returns
    -------
    np.ndarray
        Array of priority scores (shape ``(n_bins,)``). Infeasible bins have ``-inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask
    feasible = caps >= (item - eps)
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Slack after placing the item
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Fraction of bins that are feasible
    feasible_frac = feasible.sum() / n_bins

    # Bias toward tighter fits, weighted by feasible fraction
    bias = (1.0 / (slack + eps)) * feasible_frac

    # Random perturbation (small magnitude)
    if rng is None:
        rng = np.random.default_rng()
    rand = rng.random(bias.shape) * random_weight

    # Deterministic tie‑breaker: lower index -> slightly higher priority
    indices = np.nonzero(feasible)[0]
    tie_breaker = -indices.astype(float) * eps

    # Combine components
    scores = bias + rand + tie_breaker
    priorities[feasible] = scores

    return priorities
```
