```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    bin_capacity: float = 1.0,
    avg_item_size: float | None = None,
    epsilon: float = 0.05,
    small_leftover_penalty_factor: float = 10.0,
    lookahead_penalty_factor: float = 5.0,
) -> np.ndarray:
    """
    Compute a composite priority score for each bin in an online bin‑packing
    setting.

    The score blends best‑fit and worst‑fit considerations, adds an adaptive
    penalty for creating tiny fragments, and optionally penalises bins that
    would be unable to accommodate a typical future item (look‑ahead).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the existing bins.
    bin_capacity : float, optional
        Fixed capacity of each bin.  Required for normalising weights and
        computing penalties.  Defaults to 1.0.
    avg_item_size : float | None, optional
        Estimate of the average size of items that will arrive later.
        If provided, bins that would leave less remaining space than this
        average are penalised (simple look‑ahead).  If ``None``, the look‑ahead
        term is omitted.
    epsilon : float, optional
        Fraction of ``bin_capacity`` below which leftover space is considered
        a fragment and penalised.  Default is 0.05 (i.e., 5 % of a bin).
    small_leftover_penalty_factor : float, optional
        Multiplicative factor for the fragment‑penalty term.
    lookahead_penalty_factor : float, optional
        Multiplicative factor for the look‑ahead penalty term.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  The bin with the highest score should
        be selected for the item.  Infeasible bins receive ``-np.inf``.
    """
    # Ensure array type
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Compute leftover capacity after placing the item
    leftover = bins_remain_cap - item

    # Feasibility mask: only bins that can hold the item
    feasible = leftover >= 0

    # Base scores
    # Best‑fit: tighter fit -> larger score for smaller leftover (negative leftover)
    best_fit_score = -leftover
    # Worst‑fit: prefer bins with more free space
    worst_fit_score = bins_remain_cap

    # Weight between best‑fit and worst‑fit based on item size relative to bin capacity
    w_best = np.clip(item / bin_capacity, 0.0, 1.0)  # large items -> more best‑fit
    w_worst = 1.0 - w_best

    # Combine the two scores
    priority = w_best * best_fit_score + w_worst * worst_fit_score

    # --- Adaptive penalty for tiny fragments ---
    # Leftover smaller than epsilon*bin_capacity is considered wasteful
    fragment_mask = (leftover > 0) & (leftover < epsilon * bin_capacity)
    fragment_penalty = np.zeros_like(priority)
    fragment_penalty[fragment_mask] = (
        small_leftover_penalty_factor *
        (epsilon * bin_capacity - leftover[fragment_mask])
    )
    priority -= fragment_penalty

    # --- Simple look‑ahead penalty (optional) ---
    if avg_item_size is not None:
        # Penalise bins that would not have enough space for a typical future item
        lookahead_mask = (leftover > 0) & (leftover < avg_item_size)
        lookahead_penalty = np.zeros_like(priority)
        lookahead_penalty[lookahead_mask] = (
            lookahead_penalty_factor *
            (avg_item_size - leftover[lookahead_mask])
        )
        priority -= lookahead_penalty

    # Infeasible bins get -inf so they are never selected
    priority[~feasible] = -np.inf

    return priority
```
