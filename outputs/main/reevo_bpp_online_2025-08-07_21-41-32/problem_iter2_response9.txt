```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a priority score for each bin for the online Bin Packing Problem.

    The heuristic favours bins that become *almost full* after placing the item,
    applying an adaptive boost that grows when the leftover capacity is small.
    Infeasible bins receive a large negative priority so they are never chosen.
    A tiny random perturbation is added to break ties in a non‑deterministic way.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Array of priority scores, one per bin. The bin with the highest score
        should be selected for the item.
    """
    # Ensure a floating point array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Leftover capacity after hypothetically placing the item
    leftover = caps - item

    # Feasibility mask: True if the bin can accommodate the item
    feasible = leftover >= 0

    # Base priority: higher when leftover is smaller (negative leftover)
    base_priority = -leftover

    # Adaptive boost: decays quickly as leftover grows.
    # Use a scale (eps) that adapts to the current distribution of feasible leftovers.
    if np.any(feasible):
        # Use a low percentile of feasible leftovers as a scale.
        # This makes the boost more aggressive when many bins are nearly full.
        eps = np.percentile(leftover[feasible], 25)  # 25th percentile
        # Guard against eps being zero (e.g., when a perfect fit exists)
        eps = max(eps, 1e-6)
    else:
        eps = 0.05  # fallback scale when no bin can hold the item

    boost_factor = 5.0  # magnitude of the boost

    # Exponential decay boost: maximum boost_factor when leftover ≈ 0,
    # decays to near‑zero for leftover ≫ eps.
    boost = boost_factor * np.exp(-leftover / eps)

    # Combine base priority and boost, penalise infeasible bins with -inf
    priority = np.where(feasible, base_priority + boost, -np.inf)

    # Add a tiny random perturbation for tie‑breaking (only on feasible bins)
    rng = np.random.default_rng()
    tie_break = rng.random(priority.shape) * 1e-12
    priority = np.where(feasible, priority + tie_break, priority)

    return priority
```
