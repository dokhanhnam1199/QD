```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing that blends worst‑fit,
    slack‑biased randomness, and an anticipation term based on the
    distribution of current slack values.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. The bin with the maximum score
        will be chosen to hold the item. Bins that cannot accommodate
        the item receive a score of -np.inf.
    """
    # Ensure a float array for calculations
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Feasible bins that can accommodate the item
    feasible = caps >= item

    # Initialise all priorities to -inf (ensures infeasible bins are never selected)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No feasible bin, return the -inf array
        return priorities

    # Extract capacities and slack for feasible bins
    rem = caps[feasible]
    slack = rem - item
    eps = 1e-12

    # Normalise remaining capacity (worst‑fit component)
    rem_min, rem_max = rem.min(), rem.max()
    norm_rem = (rem - rem_min) / (rem_max - rem_min + eps)

    # Normalise inverse slack (tight‑fit component)
    inv_slack = 1.0 / (slack + eps)
    inv_min, inv_max = inv_slack.min(), inv_slack.max()
    norm_inv_slack = (inv_slack - inv_min) / (inv_max - inv_min + eps)

    # Anticipation term: bins whose slack is close to the mean slack
    slack_mean = slack.mean()
    slack_std = slack.std() + eps
    closeness = 1.0 - np.abs(slack - slack_mean) / slack_std
    closeness = np.clip(closeness, 0.0, 1.0)

    # Weight parameters (can be tuned)
    alpha, beta, gamma = 0.4, 0.4, 0.2   # sum to 1
    exploration_factor = 0.05

    # Combine components
    score = (
        alpha * norm_rem
        + beta * norm_inv_slack
        + gamma * closeness
    )

    # Add small random exploration noise
    rng = np.random.default_rng()
    noise = rng.random(size=score.size) * exploration_factor
    score += noise

    # Assign the computed priorities to the feasible bins
    priorities[feasible] = score

    return priorities
```
