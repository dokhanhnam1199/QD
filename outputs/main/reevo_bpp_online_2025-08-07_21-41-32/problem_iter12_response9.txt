```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                tolerance: float = 1e-12,
                epsilon: float = 1e-12,
                tie_breaker: float = 1e-12) -> np.ndarray:
    """
    Compute priority scores for each bin in an online bin packing setting.

    Higher scores indicate more desirable bins for placing the given item.
    The function biases towards tighter fits (small slack) while adding a
    random diversification component and a deterministic tie‑breaker favouring
    bins with lower indices.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    tolerance : float, optional
        Feasibility tolerance (allows tiny negative slack due to floating‑point
        errors).
    epsilon : float, optional
        Small constant added to slack to avoid division by zero when computing
        the inverse‑slack bias.
    tie_breaker : float, optional
        Small positive constant used to penalise higher‑index bins,
        breaking ties deterministically.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Infeasible bins receive ``-np.inf``.
    """
    # Ensure a 1‑D float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Feasibility mask: bin can accommodate the item (allow tolerance)
    feasible = caps >= (item - tolerance)

    # Initialise priorities: -inf for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Early exit if no feasible bins
    if not np.any(feasible):
        return priorities

    # Slack after placing the item (non‑negative)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)   # Clip tiny negatives caused by numerics

    # Inverse‑slack bias: larger for tighter fits
    bias = 1.0 / (slack + epsilon)

    # Random diversification component
    rng = np.random.default_rng()
    rand = rng.random(n_bins)

    # Indices of feasible bins (used for deterministic tie‑breaker)
    idx = np.nonzero(feasible)[0]

    # Combine bias, randomness, and tie‑breaker
    priorities[feasible] = bias * rand[feasible] - idx * tie_breaker

    return priorities
```
