```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Simple priority function for online bin packing.

    - Gives a higher score to bins that can accommodate the item.
    - Biases towards tighter fits (smaller slack) by using 1/(slack+ε).
    - Breaks ties randomly by multiplying the bias with a uniform random number.
    - Infeasible bins receive -np.inf so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better) for each bin, same shape as
        ``bins_remain_cap``.
    """
    # Convert to a flat float array.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    # Numerical tolerance for feasibility.
    tol = 1e-12
    feasible = caps >= (item - tol)

    # Initialise priorities to -inf (infeasible by default).
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can hold the item.
        return priorities

    # Slack (remaining space after placing the item) for feasible bins.
    slack = caps[feasible] - item
    # Small epsilon avoids division by zero for exact fits.
    eps = 1e-12
    bias = 1.0 / (slack + eps)      # larger when slack is smaller (tighter fit)

    # Random tie‑breaker: uniform numbers in (0, 1).
    rand = np.random.rand(feasible.sum())

    # Combine bias with randomness; multiplication preserves bias while randomising.
    priorities[feasible] = bias * rand

    return priorities
```
