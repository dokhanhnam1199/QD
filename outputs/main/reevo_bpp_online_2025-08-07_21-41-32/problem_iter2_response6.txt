```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin‑packing that scores each bin by
    how *tight* the fit would be, normalised between 0 and 1 for
    feasible bins, with a tiny tie‑breaking bias and a hard penalty
    for infeasible bins.

    The score is highest for a bin that would become the most full
    after placing the item (i.e. the smallest leftover capacity).
    Bins that cannot accommodate the item receive -∞ and are never
    chosen.

    Parameters
    ----------
    item : float
        Size of the item to be packed.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of each bin.

    Returns
    -------
    np.ndarray
        An array of the same shape as ``bins_remain_cap`` containing
        a priority score for each bin.
    """
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Compute leftover capacity after placing the item.
    leftover = bins_remain_cap - item

    # Which bins can accept the item?
    feasible = leftover >= 0

    # Handle the case where no bin can fit the item.
    if not np.any(feasible):
        # All bins are infeasible – return a constant negative score
        # (or -np.inf) for every bin.
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Normalise feasible leftovers to a 0‑1 range:
    # 1.0 corresponds to zero leftover (perfect fit).
    # 0.0 corresponds to the largest leftover among feasible bins.
    max_leftover = leftover[feasible].max()
    eps = 1e-12  # avoid division by zero
    denom = max_leftover if max_leftover > eps else eps
    norm_scores = np.where(
        feasible,
        1.0 - leftover / denom,  # higher score for smaller leftover
        -np.inf
    )

    # Tiny bias that prefers bins with *larger* remaining capacity
    # (i.e. smaller indices when bins are sorted by capacity).
    bias = 1e-6 * (bins_remain_cap.max() - bins_remain_cap)
    return norm_scores + bias
```
