```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    tolerance: float = 1e-12,
    tie_breaker: float = 1e-12,
    epsilon: float = 1e-12,
) -> np.ndarray:
    """
    Priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    tolerance : float, optional
        Numerical tolerance for feasibility checks.
    tie_breaker : float, optional
        Small bias to favor lower‑index bins when priorities are equal.
    epsilon : float, optional
        Small constant added to slack to avoid division by zero.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Higher scores indicate more desirable bins.
        Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Feasible bins: capacity is enough to accommodate the item
    feasible = caps >= (item - tolerance)

    # Default priorities: -inf for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Slack after placing the item (non‑negative)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Bias toward tight fits: 1/(slack + epsilon)
    bias = 1.0 / (slack + epsilon)

    # Weight bias by the fraction of feasible bins
    feasible_frac = feasible.sum() / n_bins
    weighted_bias = feasible_frac * bias

    # Random diversification factor (0 to 1)
    rand = np.random.rand(n_bins)

    # Indices of feasible bins (used for tie‑breaking)
    idx = np.nonzero(feasible)[0]

    # Combine weighted bias, random factor, and tie‑breaker
    priorities[feasible] = weighted_bias * rand[feasible] - idx * tie_breaker

    return priorities
```
