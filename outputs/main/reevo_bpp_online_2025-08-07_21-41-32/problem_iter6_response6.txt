```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                tolerance: float = 1e-12, tie_breaker: float = 1e-12) -> np.ndarray:
    """
    Deterministic priority function for the online Bin Packing Problem.

    The priority scores favor bins that can accommodate the incoming item with
    the smallest leftover capacity.  If multiple bins have the same leftover,
    the one with the smallest original index receives the highest score.
    Infeasible bins (those that cannot hold the item) are given ``-np.inf``.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    tolerance : float, optional
        Numerical tolerance for feasibility checks.  A bin is considered
        feasible if its remaining capacity is at least ``item - tolerance``.
    tie_breaker : float, optional
        Tiny positive value used to break ties deterministically.  It must
        be smaller than the smallest meaningful leftover (e.g., ``tolerance``).

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Higher values indicate more attractive
        bins.  Infeasible bins receive ``-np.inf``.
    """
    # Flatten the input to a 1‑D array of floats
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Feasibility mask: bins that can hold the item within tolerance
    feasible = caps >= (item - tolerance)

    # Initialise priorities as -inf (infeasible bins)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can accommodate the item; return -inf array
        return priorities

    # Compute leftover capacity for feasible bins
    leftover = caps[feasible] - item
    # Clip tiny negatives caused by floating‑point errors to zero
    leftover = np.maximum(leftover, 0.0)

    # Indices of feasible bins (preserve original order)
    idx = np.where(feasible)[0]

    # Exact‑fit first: lower leftover => higher priority.
    # Subtract a tiny index‑dependent term to break ties in favour of lower indices.
    priorities[feasible] = -leftover - idx * tie_breaker

    return priorities
```
