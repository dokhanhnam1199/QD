```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                tolerance: float = 1e-12, tie_breaker: float = 1e-12) -> np.ndarray:
    """
    Priority function for the online Bin Packing Problem.

    The function prefers bins that fit the item exactly (or as close as
    numerically possible), penalises any leftover capacity, and breaks ties
    deterministically in favour of lower‑indexed bins. No randomness or
    percentile boosts are used.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    tolerance : float, optional
        Numerical tolerance for feasibility and exact‑fit detection.
        Bins whose remaining capacity is at least ``item - tolerance`` are
        considered feasible. A leftover smaller than ``tolerance`` is treated
        as an exact fit.
    tie_breaker : float, optional
        Tiny positive value used to break ties deterministically. It must be
        smaller than the smallest meaningful leftover (e.g., ``tolerance``).

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher values indicate more attractive bins. Infeasible bins receive
        ``-np.inf``.
    """
    # Ensure a flat NumPy array of floats.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Feasibility mask: bins that can accommodate the item within tolerance.
    feasible = caps >= (item - tolerance)

    # Initialise all priorities as -inf (infeasible bins).
    priorities = np.full_like(caps, -np.inf, dtype=float)

    # If there are no feasible bins, return immediately.
    if not np.any(feasible):
        return priorities

    # Compute leftover capacity for feasible bins.
    # Clip tiny negatives (caused by tolerance) to zero.
    leftover = caps[feasible] - item
    leftover = np.maximum(leftover, 0.0)

    # Indices of all bins (preserves original ordering).
    idx = np.arange(caps.size)

    # Exact‑fit‑first: smaller leftover → higher priority.
    # Use negative leftover so that a perfect fit (leftover == 0) yields the
    # highest raw score. Subtract a tiny index‑dependent term to break ties in
    # favour of lower‑indexed bins.
    priorities[feasible] = -leftover - idx[feasible] * tie_breaker

    return priorities
```
