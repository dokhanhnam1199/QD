```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Sigmoid‑Fit priority for online Bin Packing.

    For each bin we compute the remaining capacity *after* placing the item.
    Bins that cannot accommodate the item receive a very low (−∞) score.
    Among feasible bins, a logistic (sigmoid) transformation maps the
    post‑packing slack to a priority: bins whose slack is close to a
    dynamically chosen target slack obtain higher scores, while bins with
    excessive slack are penalised.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores of the same shape as ``bins_remain_cap``. The bin
        with the highest score should be selected for the item.
    """
    # Ensure a NumPy array (float for arithmetic)
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # No bins available – return empty array
    # (Edge‑case handling; callers may decide to open a new bin)
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Slack that would remain after inserting the item
    residual = bins_remain_cap - item

    # Feasibility mask: only bins with non‑negative slack can hold the item
    feasible = residual >= 0

    # Dynamically choose a desirable slack target.
    # Here we aim for a slack around half the median remaining capacity,
    # which balances tight packing and future flexibility.
    median_cap = np.median(bins_remain_cap)
    target_slack = 0.5 * median_cap

    # Sigmoid steepness controls how sharply the priority drops
    # when the slack deviates from the target.
    steepness = 8.0

    # Logistic transformation (sigmoid):
    #   score = 1 / (1 + exp(steepness * (residual - target_slack)))
    # Smaller residual (tighter fit) => larger score.
    exponent = steepness * (residual - target_slack)

    # Clamp exponent for numerical stability
    exponent = np.clip(exponent, -50, dtype=float, a_min=-50, a_max=50)

    # Compute raw scores for all bins
    scores = 1.0 / (1.0 + np.exp(exponent))

    # Infeasible bins receive -inf so they are never selected
    scores = np.where(feasible, scores, -np.inf)

    return scores
```
