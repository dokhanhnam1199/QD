[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\n# Global random generator for tie\u2011breaking\n_rng = np.random.default_rng()\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in the online Bin Packing Problem.\n\n    The heuristic favours bins that become almost full after placing the item,\n    applying an exponential boost that decays with the leftover capacity.\n    Infeasible bins receive a -inf priority so they are never selected.\n    A tiny random perturbation is added to break ties non\u2011deterministically.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. The bin with the highest score should be\n        selected for the item.\n    \"\"\"\n    # Convert to a float array (handles list, tuple, etc.)\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Edge case: no bins available\n    if caps.size == 0:\n        return np.empty_like(caps)\n\n    # Leftover capacity if the item were placed in each bin\n    leftover = caps - item\n\n    # Feasibility mask: True where the bin can accommodate the item\n    feasible = leftover >= 0\n\n    # Initialise all priorities to -inf (infeasible by default)\n    priority = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bins \u2013 return all -inf\n        return priority\n\n    # Extract leftovers for feasible bins only\n    leftover_feas = leftover[feasible]\n\n    # Base priority: larger when leftover is smaller (i.e., -leftover)\n    base_priority = -leftover_feas\n\n    # Adaptive epsilon: low percentile of feasible leftovers acts as scale\n    eps = np.percentile(leftover_feas, 25)          # 25th percentile\n    eps = max(eps, 1e-6)                            # guard against zero\n\n    # Exponential boost: maximal boost when leftover \u2248 0, decays quickly\n    boost_factor = 5.0\n    boost = boost_factor * np.exp(-leftover_feas / eps)\n\n    # Tiny random tie\u2011breaker (only on feasible bins)\n    tie_break = _rng.random(leftover_feas.shape) * 1e-12\n\n    # Combine components and write back to the full priority array\n    priority[feasible] = np.where(feasible, base_priority + boost + tie_break, priority)\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for online bin packing using inverse waste.\n\n    For each bin that can accommodate the item, the priority is proportional to\n    1 / (remaining_capacity - item + eps).  Bins that cannot accommodate the\n    item receive a priority of -inf, ensuring they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (same shape as ``bins_remain_cap``).  Higher values\n        indicate more desirable bins.\n    \"\"\"\n    eps = 1e-12  # tiny constant to avoid division by zero\n\n    # Ensure a 1\u2011D float array for vectorized operations\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Feasibility mask: bins that can hold the item\n    feasible = caps >= item\n\n    # Compute waste (remaining capacity after placing the item)\n    waste = caps - item\n\n    # Initialise all priorities to -inf (infeasible bins stay -inf)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # Inverse waste for feasible bins (larger priority for tighter fits)\n    priorities[feasible] = 1.0 / (waste[feasible] + eps)\n\n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 9, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, np.ndarray) -> np.ndarray:\n                                   ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/SLOC.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, np.ndarray) -> np.ndarray:\n                                   ^\nSyntaxError: invalid syntax\nTraceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/cyclomatic_complexity.py\", line 7, in <module>\n    from gpt import priority_v2 as priority\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 3\n    def priority_v2(item: float, np.ndarray) -> np.ndarray:\n                                   ^\nSyntaxError: invalid syntax\n"
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    bin_ages: Optional[np.ndarray] = None,\n    temperature: float = 1.0,\n    lookahead_items: Optional[np.ndarray] = None,\n    random_state: Optional[int] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each bin in an online bin\u2011packing setting.\n\n    The heuristic blends an exact\u2011fit bias with a worst\u2011fit component,\n    optionally incorporates look\u2011ahead information and bin (age) information,\n    and finally applies a temperature\u2011scaled exponential transformation to\n    encourage exploration. Infeasible bins receive a score of -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n    bin_ages : np.ndarray, optional\n        1\u2011D array (same length as ``bins_remain_cap``) indicating the age of\n        each bin (e.g., number of items already placed). Older bins receive a\n        small boost to encourage closing them.\n    temperature : float, default 1.0\n        Controls the softness of the exponential scaling. Must be > 0.\n        Lower values make the algorithm greedier.\n    lookahead_items : np.ndarray, optional\n        Array of sizes of upcoming items. A bin that can still accommodate many\n        look\u2011ahead items receives a boost.\n    random_state : int, optional\n        Seed for the internal RNG used for tie\u2011breaking noise.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better). Infeasible bins have -inf.\n    \"\"\"\n    eps = 1e-12  # tiny epsilon to avoid division by zero\n\n    # Guard temperature\n    temperature = max(temperature, eps)\n\n    # Prepare capacities\n    caps = np.asarray(bins_remain_cap, dtype=float).copy()\n    n_bins = caps.size\n\n    # Initialise priorities with -inf (infeasible by default)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Feasibility mask\n    feasible = caps >= item\n    if not np.any(feasible):\n        return priorities  # nothing fits\n\n    # ------------------------------------------------------------------\n    # 1. Core exact\u2011fit / worst\u2011fit scores\n    # ------------------------------------------------------------------\n    slack = caps - item                     # remaining space after placement\n    slack_feas = slack[feasible]\n\n    # Exact\u2011fit: prefers tiny slack (i.e., tight fit)\n    exact_fit = 1.0 / (slack_feas + eps)    # larger when waste is small\n\n    # Worst\u2011fit: prefers large slack (i.e., keep space for future large items)\n    worst_fit = slack_feas / (np.max(caps) + eps)  # normalized to [0, 1]\n\n    # Blend them (weights sum to 1)\n    w_exact = 0.6\n    w_worst = 0.4\n    core_score = w_exact * exact_fit + w_worst * worst_fit\n\n    # ------------------------------------------------------------------\n    # 2. Optional look\u2011ahead boost\n    # ------------------------------------------------------------------\n    if lookahead_items is not None and lookahead_items.size > 0:\n        lookahead = np.asarray(lookahead_items, dtype=float)\n\n        # Boolean matrix: (n_feasible, n_lookahead) \u2013 True if lookahead item fits\n        fits = lookahead[None, :] <= slack_feas[:, None]\n        # Fraction of look\u2011ahead items that could still be placed after this item\n        lookahead_frac = fits.mean(axis=1)  # in [0, 1]\n\n        lookahead_weight = 0.3\n        core_score *= (1.0 + lookahead_weight * lookahead_frac)\n\n    # ------------------------------------------------------------------\n    # 3. Optional bin\u2011age boost\n    # ------------------------------------------------------------------\n    if bin_ages is not None:\n        ages = np.asarray(bin_ages, dtype=float)\n        if ages.shape != caps.shape:\n            raise ValueError(\"bin_ages must have the same shape as bins_remain_cap\")\n        # Normalise ages to [0, 1]\n        age_norm = ages / (np.max(ages) + eps)\n        age_weight = 0.2\n        age_factor = 1.0 + age_weight * age_norm\n        core_score *= age_factor[feasible]\n\n    # ------------------------------------------------------------------\n    # 4. Temperature\u2011scaled exponential scaling (softmax\u2011like)\n    # ------------------------------------------------------------------\n    exp_score = np.exp(core_score / temperature)\n\n    # ------------------------------------------------------------------\n    # 5. Tiny random tie\u2011breaker for numerical stability / exploration\n    # ------------------------------------------------------------------\n    rng = np.random.default_rng(random_state)\n    tie_eps = 1e-8\n    exp_score += rng.random(exp_score.shape) * tie_eps\n\n    # Fill the priorities array for feasible bins\n    priorities[feasible] = exp_score\n\n    return priorities",
    "response_id": 2,
    "obj": 83.27682489030715,
    "SLOC": 43.0,
    "cyclomatic_complexity": 6.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-15,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic exact\u2011fit\u2011first priority function for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility detection. Bins whose remaining\n        capacity is at least ``item - tolerance`` are considered feasible.\n    tie_breaker : float, optional\n        Tiny value used to break ties deterministically in favour of lower\u2011indexed\n        bins. Must be smaller than ``tolerance``.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``). Higher\n        values indicate more attractive bins. Infeasible bins receive ``-np.inf``.\n    \"\"\"\n    # Ensure a flat NumPy array of floats.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Feasibility mask: bins that can accommodate the item within tolerance.\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priorities with -inf for infeasible bins.\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin; return all -inf.\n        return priorities\n\n    # Compute leftover capacity for feasible bins.\n    leftover = caps[feasible] - item\n    # Clip tiny negative leftovers caused by tolerance to zero.\n    leftover = np.maximum(leftover, 0.0)\n\n    # Indices of feasible bins (used for deterministic tie\u2011breaking).\n    idx = np.where(feasible)[0]\n\n    # Exact\u2011fit\u2011first: smaller leftover \u2192 higher priority.\n    # Use negative leftover so exact fit (leftover == 0) yields the highest raw score.\n    # Subtract a tiny index\u2011dependent term to break ties in favour of lower\u2011indexed bins.\n    priorities[feasible] = -leftover - idx * tie_breaker\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin\u2011packing.\n\n    For each bin the score is based on how tight the fit would be\n    (lower leftover \u2192 higher score), normalised between 0 and 1 for\n    all feasible bins.  Infeasible bins receive a score of -\u221e.  A\n    tiny bias that favours bins with larger remaining capacity is\n    added to break ties.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores, same shape as ``bins_remain_cap``.\n    \"\"\"\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after placing the item\n    leftover = bins_remain_cap - item\n    # Feasibility mask\n    feasible = leftover >= 0\n\n    # No feasible bin \u2013 return -inf for all\n    if not np.any(feasible):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Normalise leftover: 1.0 for perfect fit (leftover = 0),\n    # 0.0 for the largest leftover among feasible bins\n    max_leftover = leftover[feasible].max()\n    eps = 1e-12\n    denom = max_leftover if max_leftover > eps else eps\n    norm_scores = np.where(\n        feasible,\n        1.0 - leftover / denom,\n        -np.inf\n    )\n\n    # Tiny bias that prefers bins with larger remaining capacity\n    bias = 1e-6 * bins_remain_cap\n\n    return norm_scores + bias",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for assigning ``item`` to each bin.\n\n    The function favours bins that will be tightly filled (small slack) while\n    adding a modest random perturbation to break ties.  An adaptive epsilon\n    prevents division\u2011by\u2011zero and scales with typical slack size.  Infeasible\n    bins receive ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    # Ensure a float array.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Identify feasible bins (enough capacity for the item).\n    feasible = caps >= item\n\n    # Initialise all priorities to -inf (so infeasible bins are never chosen).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # If no feasible bin exists, return early.\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item.\n    slack = caps - item\n\n    # Adaptive epsilon: a tiny fraction of the typical slack among feasible bins.\n    mean_slack = np.mean(slack[feasible])\n    eps = max(1e-12, 1e-6 * mean_slack)  # never zero, scales with slack magnitude.\n\n    # Tight\u2011fit bias: larger when slack is smaller.\n    bias = np.zeros_like(caps)\n    bias[feasible] = 1.0 / (slack[feasible] + eps)\n\n    # Modest random factor near 1 to break ties without overwhelming the bias.\n    # Uniform in [0.95, 1.05].\n    rand_factor = 0.95 + 0.1 * np.random.rand(caps.size)\n\n    # Combine bias with random factor.\n    priorities[feasible] = bias[feasible] * rand_factor[feasible]\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Exact\u2011Fit\u2011First priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of the open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility and exact\u2011fit detection.\n        Bins whose remaining capacity is at least ``item - tolerance`` are considered\n        feasible.  A leftover smaller than ``tolerance`` is treated as an exact fit.\n    tie_breaker : float, optional\n        Tiny value used to break ties deterministically in favour of lower\u2011indexed bins.\n        Must be sufficiently smaller than the smallest possible leftover.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Higher values indicate more attractive bins.  Infeasible bins receive\n        ``-np.inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Feasibility mask\n    feasible = caps >= (item - tolerance)\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No feasible bin; return all -inf\n        return priorities\n\n    # Leftover capacity for feasible bins (ensure non\u2011negative)\n    leftover = np.clip(caps[feasible] - item, 0.0, None)\n\n    # Indices of feasible bins (for deterministic tie\u2011breaking)\n    idx = np.where(feasible)[0]\n\n    # Exact\u2011Fit\u2011First: smaller leftover \u2192 higher priority\n    # Use negative leftover so that exact fit (leftover == 0) has the highest raw score.\n    priorities[feasible] = -leftover - idx * tie_breaker\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive exponential\u2011boost priority for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority score for each bin; higher values indicate a more desirable\n        placement. Infeasible bins receive ``-np.inf`` so they are never chosen.\n    \"\"\"\n    # Ensure a floating\u2011point view of the capacities.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Capacity that would remain after placing the item.\n    leftover = caps - item\n\n    # Feasibility mask: True for bins that can hold the item.\n    feasible = leftover >= 0\n\n    # Base priority: larger when the resulting leftover is smaller.\n    base_priority = -leftover\n\n    # Adaptive epsilon for the exponential boost.\n    # Use the mean leftover of feasible bins (cheap O(n) operation);\n    # fall back to a tiny constant if no bin is feasible.\n    if np.any(feasible):\n        eps = max(np.mean(leftover[feasible]), 1e-6)\n    else:\n        eps = 1e-6\n\n    # Exponential boost: strongest when leftover \u2248 0, decays quickly.\n    boost_factor = 5.0\n    boost = boost_factor * np.exp(-leftover / eps)\n\n    # Combine base priority and boost; penalise infeasible bins.\n    priority = np.where(feasible, base_priority + boost, -np.inf)\n\n    # Tiny random perturbation for deterministic tie\u2011breaking.\n    rng = np.random.default_rng()\n    noise = rng.random(priority.shape) * 1e-12\n    priority[feasible] += noise[feasible]\n\n    return priority",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    tie_breaker: float = 1e-12,\n) -> np.ndarray:\n    \"\"\"\n    Deterministic priority function for the online Bin Packing Problem.\n\n    The function prefers bins that fit the item exactly (or as close as\n    numerically possible), penalises any leftover capacity, and breaks ties\n    deterministically in favour of lower\u2011indexed bins. No randomness is used.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array (or array\u2011like) of remaining capacities of the currently open\n        bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility and exact\u2011fit detection.\n        Bins whose remaining capacity is at least ``item - tolerance`` are\n        considered feasible. A leftover smaller than ``tolerance`` is treated\n        as an exact fit.\n    tie_breaker : float, optional\n        Tiny positive value used to break ties deterministically. It must be\n        smaller than the smallest meaningful leftover (e.g., ``tolerance``).\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``).\n        Higher values indicate more attractive bins. Infeasible bins receive\n        ``-np.inf``.\n    \"\"\"\n    # Convert input to a flat NumPy array of floats.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n\n    # Feasibility mask: bins that can accommodate the item within tolerance.\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all priorities as -inf (infeasible bins).\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # If there are no feasible bins, return the -inf array immediately.\n    if not np.any(feasible):\n        return priorities\n\n    # Compute leftover capacity for feasible bins.\n    # Clip tiny negatives (caused by tolerance) to zero.\n    leftover = caps[feasible] - item\n    leftover = np.maximum(leftover, 0.0)\n\n    # Indices of feasible bins (preserves original ordering).\n    idx = np.where(feasible)[0]\n\n    # Exact\u2011fit\u2011first: smaller leftover \u2192 higher priority.\n    # Use negative leftover so that a perfect fit (leftover == 0) yields the\n    # highest raw score. Subtract a tiny index\u2011dependent term to break ties in\n    # favour of lower\u2011indexed bins.\n    priorities[feasible] = -leftover - idx * tie_breaker\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    For each existing bin the function returns a score; the bin with the\n    highest score is selected for the incoming ``item``.  The heuristic\n    combines three ingredients:\n\n    1. **Inverse\u2011slack bias** \u2013 bins with less remaining capacity after the\n       item (i.e. tighter fits) receive a larger base score.\n    2. **Percentile\u2011based boost** \u2013 bins whose slack falls below a low\u2011percentile\n       (default 10\u202f%) are further boosted, encouraging the algorithm to fill\n       \u201calmost full\u2019\u2019 bins.\n    3. **Controlled randomness** \u2013 a mild random factor in the range\n       [0.9,\u202f1.0] breaks ties while keeping the deterministic bias dominant.\n\n    Infeasible bins (those that cannot accommodate the item) obtain ``-np.inf``,\n    guaranteeing they are never chosen.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each bin.\n\n    Returns\n    -------\n    np.ndarray\n        1\u2011D array of priority scores (higher is better).  Infeasible bins are\n        marked with ``-np.inf``.\n    \"\"\"\n    # Ensure we work with a float array\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Slack after hypothetically placing the item\n    slack = caps - item\n    feasible = slack >= 0\n\n    # Initialise all scores as -inf (infeasible)\n    priorities = np.full_like(caps, -np.inf, dtype=float)\n\n    # If no bin can hold the item, return early\n    if not np.any(feasible):\n        return priorities\n\n    # ------------------------------------------------------------------\n    # 1) Adaptive epsilon and inverse\u2011slack bias\n    # ------------------------------------------------------------------\n    # Typical slack magnitude \u2013 use mean of feasible slacks\n    mean_slack = np.mean(slack[feasible])\n    # epsilon scales with the typical slack to avoid division\u2011by\u2011zero\n    eps = max(1e-12, 1e-6 * mean_slack)\n    inv_slack = 1.0 / (slack[feasible] + eps)   # larger when slack is smaller\n\n    # ------------------------------------------------------------------\n    # 2) Percentile\u2011based boost for \u201calmost full\u2019\u2019 bins\n    # ------------------------------------------------------------------\n    low_percentile = 0.10                     # 10\u202f% percentile\n    slack_feas = slack[feasible]\n    # Threshold slack value below which bins receive a boost\n    threshold = np.quantile(slack_feas, low_percentile) if slack_feas.size else 0.0\n\n    # Linear boost proportional to distance below the threshold\n    boost_factor = 5.0                         # magnitude of boost\n    boost = np.zeros_like(slack_feas)\n    low_slack_mask = slack_feas <= threshold\n    boost[low_slack_mask] = boost_factor * (threshold - slack_feas[low_slack_mask])\n\n    # ------------------------------------------------------------------\n    # 3) Combine deterministic components\n    # ------------------------------------------------------------------\n    combined = inv_slack + boost\n\n    # ------------------------------------------------------------------\n    # 4) Controlled random tie\u2011breaker (range [0.9, 1.0])\n    # ------------------------------------------------------------------\n    rand_vals = np.random.rand(caps.size)      # one random number per bin\n    rand_factor = 0.9 + 0.1 * rand_vals         # maps to [0.9, 1.0]\n    # Apply only to feasible bins\n    final_score = combined * rand_factor[feasible]\n\n    # Store the computed scores back into the full array\n    priorities[feasible] = final_score\n\n    return priorities",
    "response_id": 9,
    "obj": 4.15835660151576,
    "SLOC": 23.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]