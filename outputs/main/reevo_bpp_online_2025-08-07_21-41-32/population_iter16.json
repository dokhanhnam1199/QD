[
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    eps: float = 1e-12,\n    rng: Optional[np.random.Generator] = None,\n    random_weight: float = 1e-6,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n    eps : float, optional\n        Small constant used for numerical tolerance and to avoid division by zero.\n    rng : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None``, a new default RNG is created.\n    random_weight : float, optional\n        Scaling factor for the random component (kept small to limit randomness).\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (shape ``(n_bins,)``). Infeasible bins have ``-inf``.\n    \"\"\"\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask\n    feasible = caps >= (item - eps)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Fraction of bins that are feasible\n    feasible_frac = feasible.sum() / n_bins\n\n    # Bias toward tighter fits, weighted by feasible fraction\n    bias = (1.0 / (slack + eps)) * feasible_frac\n\n    # Random perturbation (small magnitude)\n    if rng is None:\n        rng = np.random.default_rng()\n    rand = rng.random(bias.shape) * random_weight\n\n    # Deterministic tie\u2011breaker: lower index -> slightly higher priority\n    indices = np.nonzero(feasible)[0]\n    tie_breaker = -indices.astype(float) * eps\n\n    # Combine components\n    scores = bias + rand + tie_breaker\n    priorities[feasible] = scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response1.txt_stdout.txt",
    "code_path": "problem_iter16_code1.py",
    "code": "import numpy as np\n\n# Global RNG to avoid re\u2011creating it on each call\n_rng = np.random.default_rng()\n\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing setting.\n\n    The priority favours tighter fits (small slack) while adding a stochastic\n    component to diversify choices. Infeasible bins (capacity < item) receive\n    ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of feasible remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin.\n    \"\"\"\n    _TOL = 1e-12   # feasibility tolerance\n    _EPS = 1e-12   # epsilon to avoid division by zero\n    _TIE = 1e-12   # tiny deterministic tie\u2011breaker magnitude\n\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask: allow a tiny tolerance for numeric errors\n    feasible = caps >= (item - _TOL)\n\n    # Initialise priorities with -inf for infeasible bins\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative for feasible bins)\n    slack = np.maximum(caps[feasible] - item, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1] (max bias gets 1)\n    # bias.max() > 0 because bias > 0\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # Random factor in [0, 1) for feasible bins\n    rand_vals = _rng.random(bias_norm.shape)\n\n    # Blend bias and randomness multiplicatively\n    blended = bias_norm * rand_vals\n\n    # Tiny deterministic tie\u2011breaker: lower index gets a slight advantage\n    tie_breaker = -np.arange(n_bins, dtype=float)[feasible] * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended + tie_breaker\n\n    return priorities",
    "response_id": 1,
    "obj": 3.9389708815317115,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response2.txt_stdout.txt",
    "code_path": "problem_iter16_code2.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-6,\n    rand_scale: float = 1e-6,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem.\n\n    Computes a score for each open bin indicating how desirable it is\n    to place the incoming ``item`` in that bin. Higher scores are\n    preferred. Infeasible bins (remaining capacity smaller than the\n    item) receive ``-np.inf`` and will never be selected.\n\n    The score combines:\n    * An inverse\u2011slack bias (tight fits get higher scores) that is\n      normalised to ``[0, 1]``.\n    * A small random perturbation to break ties and diversify\n      decisions.\n    * A deterministic tie\u2011breaker that favours bins with lower index.\n    * A weighting by the fraction of bins that are feasible, which\n      down\u2011scales the bias when many bins can accept the item.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks.\n    epsilon : float, optional\n        Small constant added to slack to avoid division\u2011by\u2011zero.\n    tie_breaker : float, optional\n        Weight of the deterministic tie\u2011breaker (must be tiny).\n    rand_scale : float, optional\n        Scale of the random perturbation (tiny).\n    random_state : np.random.Generator, optional\n        Random generator for reproducibility. If ``None``, a new\n        default generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Infeasible bins\n        contain ``-np.inf``.\n    \"\"\"\n    # Random generator (reproducible if provided)\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Ensure a flat float array of capacities\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Slack after placing the item\n    slack = caps - item\n\n    # Feasibility mask (allow small tolerance)\n    feasible = slack >= -tolerance\n\n    # Initialise all scores as -inf (infeasible)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if nothing fits\n    if not np.any(feasible):\n        return priorities\n\n    # Positive slack for feasible bins (negative slack -> 0)\n    slack_pos = np.maximum(slack[feasible], 0.0)\n\n    # Inverse\u2011slack bias: tighter fit -> larger bias\n    bias = 1.0 / (slack_pos + epsilon)\n\n    # Normalise bias to [0, 1]\n    bias_norm = bias / bias.max()\n\n    # Weight by fraction of feasible bins\n    feasible_frac = feasible.sum() / n_bins\n    weighted_bias = bias_norm * feasible_frac\n\n    # Tiny random perturbation\n    rand_vals = rng.random(weighted_bias.shape) * rand_scale\n\n    # Deterministic tie\u2011breaker: lower index gets slight advantage\n    tie_vals = -np.arange(n_bins, dtype=float)[feasible] * tie_breaker\n\n    # Combine components\n    scores = weighted_bias + rand_vals + tie_vals\n\n    # Populate feasible positions\n    priorities[feasible] = scores\n\n    # Final normalisation among feasible scores (preserve ordering, bound to [0,1])\n    feas_scores = priorities[feasible]\n    min_score = feas_scores.min()\n    max_score = feas_scores.max()\n    if max_score > min_score:\n        priorities[feasible] = (feas_scores - min_score) / (max_score - min_score)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 32.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response3.txt_stdout.txt",
    "code_path": "problem_iter16_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online Bin Packing problem.\n\n    The priority is based on a tight\u2011fit bias (inverse slack) multiplied by a\n    random factor, normalised to [0, 1], and a tiny deterministic tie\u2011breaker\n    that favours lower\u2011index bins. Infeasible bins receive ``-np.inf``.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin; the bin with the highest score should be\n        selected for the item.\n    \"\"\"\n    # Numerical tolerances\n    _TOL = 1e-12  # tolerance for feasibility check (tiny)\n    _EPS = 1e-12  # avoid division by zero\n    _TIE = 1e-12  # deterministic tie\u2011breaker magnitude\n\n    # Ensure a flat float array of capacities\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a tiny tolerance for floating\u2011point errors)\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities to -inf (infeasible bins)\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        return priorities\n\n    # Slack after placing the item (non\u2011negative for feasible bins)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Inverse\u2011slack bias: larger for tighter fits\n    bias = 1.0 / (slack + _EPS)\n\n    # Normalise bias to [0, 1]\n    bias_norm = bias / bias.max()\n\n    # Random factor in [0, 1) for each feasible bin\n    rng = np.inf  # placeholder to avoid import errors if np.random missing\n    rng = np.random.default_rng()\n    rand_vals = rng.random(bias_norm.shape)\n\n    # Blend bias and randomness multiplicatively\n    blended = bias_norm * rand_vals\n\n    # Normalise blended scores to [0, 1]\n    max_blended = blended.max()\n    blended_norm = blended / (max_blended + _EPS)\n\n    # Deterministic tie\u2011breaker: lower index gets a slight advantage\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE\n\n    # Final priority for feasible bins\n    priorities[feasible] = blended_norm + tie_breaker\n\n    return priorities",
    "response_id": 3,
    "obj": 4.008775428799367,
    "SLOC": 23.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response4.txt_stdout.txt",
    "code_path": "problem_iter16_code4.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each open bin in an online bin packing scenario.\n\n    The score favours:\n      * Feasibility (the bin must have enough remaining capacity).\n      * Tight fits (small slack after insertion) via a bias term.\n      * Random diversification to avoid deterministic patterns.\n      * A tiny deterministic tie\u2011breaker based on bin index.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of currently open bins (float or int).\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks (default 1e-12).\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero (default 1e-12).\n    tie_breaker : float, optional\n        Tiny weight applied to bin index to break exact ties (default 1e-12).\n    random_state : Optional[np.random.Generator], optional\n        Random generator for reproducibility; if None, a default generator is used.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores for each bin; infeasible bins receive -inf.\n    \"\"\"\n    # Ensure a random generator is available.\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Flatten capacities and cast to float.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Determine feasibility: bin must have enough remaining capacity.\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all scores to -inf (infeasible by default).\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if no bin can hold the item.\n    if not np.any(feasible):\n        return scores\n\n    # Slack after placing the item, clipped at zero to handle floating\u2011point noise.\n    slack = np.maximum(caps - item, 0.0)\n\n    # Bias favouring tighter fits (smaller slack). epsilon avoids division by zero.\n    bias = 1.0 / (slack + epsilon)\n\n    # Random component for diversification.\n    rand = rng.random(n_bins)\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage.\n    idx_factor = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Combine components: bias * random - idx_factor.\n    scores[feasible] = bias[feasible] * rand[feasible] - idx_factor[feasible]\n\n    return scores",
    "response_id": 4,
    "obj": 4.008775428799367,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response5.txt_stdout.txt",
    "code_path": "problem_iter16_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for bins in an online bin\u2011packing setting.\n\n    The priority favours bins where the item fits tightly (small slack),\n    adds a tiny random perturbation to break ties probabilistically,\n    and includes a deterministic tie\u2011breaker that gives a minute advantage\n    to lower\u2011index bins. Bins that cannot accommodate the item receive\n    ``-np.inf`` and are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority V2 scores (higher = more attractive). Infeasible bins are\n        assigned ``-np.inf``.\n    \"\"\"\n    # constants\n    _TOL = 1e-12          # feasibility tolerance\n    _EPS = 1e-9           # epsilon for inverse\u2011slack to avoid division by zero\n    _RND_SCALE = 1e-10    # tiny random noise scale\n    _TIE_BREAK = 1e-12    # deterministic tie\u2011breaker magnitude\n\n    # flatten capacity array to 1\u2011D float vector\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # feasibility mask (allow a tiny tolerance for floating\u2011point errors)\n    feasible = caps >= (item - _TOL)\n\n    # initialise priorities: infeasible bins get -inf\n    priorities = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # no bin can accommodate the item\n        return priorities\n\n    # slack that would remain after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # inverse\u2011slack bias: larger when slack is smaller (tighter fit)\n    bias = 1.0 / (slack + _EPS)\n\n    # tiny random perturbation\n    rng = np.random.default_rng()\n    noise = rng.random(bias.shape) * _RND_SCALE\n\n    # deterministic tie\u2011breaker: lower index \u2192 slight advantage\n    tie_breaker = -np.arange(n_bins)[feasible] * _TIE_BREAK\n\n    # final priority for feasible bins\n    priorities[feasible] = bias + noise + tie_breaker\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response6.txt_stdout.txt",
    "code_path": "problem_iter16_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a priority score for each open bin in an online Bin Packing setting.\n\n    The priority combines a deterministic bias favouring tight fits (small slack)\n    with a stochastic component to diversify decisions. A tiny deterministic\n    tie\u2011breaker based on the bin index resolves exact ties. Infeasible bins\n    (remaining capacity < item) receive ``-np.inf`` so they are never selected.\n\n    ==========  ==========================================================\n    Parameter    Description\n    ----------  ----------------------------------------------------------\n    item         Size of the incoming item (float, non\u2011negative).\n    bins_remain_cap\n                1\u2011D array-like of remaining capacities for each currently\n                open bin (float).\n    ==========  ==========================================================\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (higher is better) with the same length as\n        ``bins_remain_cap``.\n    \"\"\"\n    # ---- constants ---------------------------------------------------------\n    _TOL = 1e-12          # feasibility tolerance for floating\u2011point errors\n    _EPS = 1e-12          # small number to avoid division by zero\n    _TIE = 1e-12          # deterministic tie\u2011breaker magnitude\n    _BIASED_WEIGHT = 0.8 # weight given to the tight\u2011fit bias (0..1)\n\n    # ---- preprocessing ------------------------------------------------------\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # ---- feasibility mask ---------------------------------------------------\n    feasible = caps >= (item - _TOL)\n\n    # Initialise all priorities as -inf (infeasible)\n    priorities = np.full(n_bins = n_bins, fill_value=-np.inf, dtype=float)\n    if not np.any(feasible):\n        return priorities\n\n    # ---- slack and bias ------------------------------------------------------\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)          # ensure non\u2011negative\n    bias = 1.0 / (slack + _EPS)             # larger for tighter fits\n\n    # Normalise bias to [0, 1] (only once)\n    bias_norm = bias / (bias.max() + _EPS)\n\n    # ---- random component ----------------------------------------------------\n    rng = np.random.default_rng()\n    rand_vals = rng.random(bias_norm.shape)   # already in [0, 1)\n\n    # ---- blend bias and randomness -------------------------------------------\n    # Weighted sum allows explicit calibration of influence\n    blended = _BIASED_WEIGHT * bias_norm + (1.0 - _BIASED_WEIGHT) * rand_vals\n\n    # ---- deterministic tie\u2011breaker -------------------------------------------\n    tie_breaker = -np.arange(n_bins, dtype=float)[feasible] * _TIE\n\n    # ---- final priorities ----------------------------------------------------\n    priorities[feasible] = blended + tie_breaker\n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 41, in priority_v2\n    tie_breaker : float, optional\nTypeError: full() got an unexpected keyword argument 'n_bins'\n21\n2\n"
  },
  {
    "stdout_filepath": "problem_iter16_response7.txt_stdout.txt",
    "code_path": "problem_iter16_code7.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    eps: float = 1e-12,\n    rand_scale: float = 1e-3,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    Computes a score for each open bin indicating how desirable it is to place\n    the incoming ``item`` into that bin. Higher scores are preferred.\n\n    The scoring policy:\n        * Only consider bins that can accommodate the item (within tolerance).\n        * Favor tighter fits by normalising slack and inverting it.\n        * Scale the bias by the fraction of feasible bins (encourages opening a\n          new bin when many bins are feasible).\n        * Apply a tiny random perturbation to break ties and add diversity.\n        * Apply a deterministic tie\u2011breaker that slightly penalises higher\n          bin indices (prefers lower\u2011indexed bins).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility check.\n    eps : float, optional\n        Small constant to avoid division by zero.\n    rand_scale : float, optional\n        Maximum magnitude of the random perturbation (relative to the bias).\n    tie_breaker : float, optional\n        Weight applied to the bin index for deterministic tie\u2011breaking.\n    random_state : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None``, the default\n        global RNG is used.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Infeasible bins are\n        assigned ``-np.inf``.\n    \"\"\"\n    # Resolve RNG\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Ensure a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Edge case: no bins at all\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Feasibility mask (bins that can fit the item)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all scores to -inf (infeasible)\n    scores = np.full(n_bins = n_bins, fill_value=-np.inf, dtype=float)\n    # Note: the above line will cause syntax error; correct usage below\n\n    # Fixed the initialization line\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # If no feasible bins, return all -inf scores\n    if not np.any(feasible):\n        return scores\n\n    # Slack after placing the item (non\u2011negative)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)\n\n    # Normalise slack so the largest slack among feasible bins becomes 1\n    max_slack = slack.max() + eps\n    norm_slack = slack / max_slack\n\n    # Bias: tighter fit \u2192 larger value\n    bias = 1.0 / (norm_slack + eps)\n\n    # Weight bias by the fraction of feasible bins (encourages new bins\n    # when many feasible bins exist)\n    feasible_frac = feasible.sum() / n_bins\n    bias *= feasible_frac\n\n    # Random perturbation (multiplicative)\n    random_factor = 1.0 + rng.random(bias.shape) * rand_scale\n    bias *= random_factor\n\n    # Determinfeasible bins, scores stay -inf; for feasible bins, apply tie\u2011breaker\n    # Lower indices get a tiny advantage (i.e., subtract a small amount)\n    tie = np.arange(n_bins, dtype=float)[feasible] * tie_breaker\n    scores[feasible] = bias - tie\n\n    return scores",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 68, in priority_v2\n    # Weight the bias by the fraction of feasible bins.\nTypeError: full() got an unexpected keyword argument 'n_bins'\n32\n4\n"
  },
  {
    "stdout_filepath": "problem_iter16_response8.txt_stdout.txt",
    "code_path": "problem_iter16_code8.py",
    "code": "import numpy as np\nfrom typing import Optional\n\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    *,\n    tolerance: float = 1e-12,\n    eps: float = 1e-12,\n    jitter_scale: float = 1e-4,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin in an online bin packing setting.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks (default 1e-12).\n    eps : float, optional\n        Small constant to avoid division by zero (default 1e-12).\n    jitter_scale : float, optional\n        Scale of the random jitter added to feasible bins (default 1e-4).\n    tie_breaker : float, optional\n        Weight of the deterministic tie\u2011breaker based on bin index\n        (default 1e-12). Lower index receives a slightly larger priority.\n    random_state : np.random.Generator, optional\n        Random number generator for reproducibility. If ``None``, a fresh\n        default RNG is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores (higher is better) for each bin. Infeasible bins\n        receive ``-np.inf``.\n    \"\"\"\n    # Ensure a flat float array\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Feasibility mask (allow a small tolerance for numeric errors)\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all scores to -inf (infeasible)\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    if not np.any(feasible):\n        # No bin can accommodate the item \u2013 return all -inf\n        return scores\n\n    # Compute slack (remaining capacity after placing the item)\n    slack = caps[feasible] - item\n    slack = np.maximum(slack, 0.0)  # guard against tiny negatives\n\n    # Normalise slack: largest slack among feasible bins becomes 1\n    max_slack = slack.max() + eps\n    norm_slack = slack / max_slack\n\n    # Bias favouring tighter fits (smaller normalised slack)\n    bias = 1.0 / (norm_slack + eps)\n\n    # Weight the bias by the fraction of feasible bins.\n    # When many bins can hold the item, we discourage opening a new bin.\n    feasible_frac = feasible.sum() / n_bins\n    bias *= feasible_frac\n\n    # Random jitter to break ties and avoid pathological deterministic loops\n    rng = random_state if random_state is not None else np.random.default_rng()\n    jitter = 1.0 + jitter_scale * rng.random(feasible.sum())\n    bias *= jitter\n\n    # Deterministic tie\u2011breaker: prefer lower indices by subtracting a tiny amount\n    indices = np.arange(n_bins, dtype=float)\n    tie = indices[feasible] * tie_breaker\n    # Subtract tie so that smaller index gets a slightly larger final score\n    scores[feasible] = bias - tie\n\n    return scores",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 30.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response9.txt_stdout.txt",
    "code_path": "problem_iter16_code9.py",
    "code": "import numpy as np\nfrom typing import Optional\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    tolerance: float = 1e-12,\n    epsilon: float = 1e-12,\n    tie_breaker: float = 1e-12,\n    random_state: Optional[np.random.Generator] = None,\n) -> np.ndarray:\n    \"\"\"\n    Priority function for the online Bin Packing Problem (BPP).\n\n    Computes a score for each open bin; the bin with the highest score will\n    receive the incoming item. Infeasible bins are assigned -inf.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for each currently open bin.\n    tolerance : float, optional\n        Numerical tolerance for feasibility checks (default 1e-12).\n    epsilon : float, optional\n        Small constant added to slack to avoid division by zero (default 1e-12).\n    tie_breaker : float, optional\n        Tiny weight for deterministic tie\u2011breaking based on bin index (default 1e-12).\n    random_state : np.random.Generator, optional\n        Random number generator for reproducibility. If None, a new default\n        generator is created.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Infeasible bins have -inf.\n    \"\"\"\n    # Use provided RNG or create a new one for reproducibility.\n    rng = random_state if random_state is not None else np.random.default_rng()\n\n    # Flatten capacities to a 1\u2011D float array.\n    caps = np.asarray(bins_remain_cap, dtype=float).ravel()\n    n_bins = caps.size\n\n    # Identify bins that can accommodate the item (within tolerance).\n    feasible = caps >= (item - tolerance)\n\n    # Initialise all scores to -inf (infeasible by default).\n    scores = np.full(n_bins, -np.inf, dtype=float)\n\n    # Early exit if no bin can hold the item.\n    if not np.any(feasible):\n        return scores\n\n    # Compute slack (remaining capacity after placing the item) and clip negatives.\n    slack = np.maximum(caps - item, 0.0)\n\n    # Bias favouring tight fits: smaller slack \u2192 larger bias.\n    bias = 1.0 / (slack + epsilon)\n\n    # Random component per bin for diversification.\n    rand_vals = rng.random(n_bins)\n\n    # Deterministic tie\u2011breaker: lower index gets a tiny advantage.\n    tie = np.arange(n_bins, dtype=float) * tie_breaker\n\n    # Combine components for feasible bins.\n    scores[feasible] = bias[feasible] * rand_vals[feasible] - tie[feasible]\n\n    return scores",
    "response_id": 9,
    "obj": 4.058635819704831,
    "SLOC": 21.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]