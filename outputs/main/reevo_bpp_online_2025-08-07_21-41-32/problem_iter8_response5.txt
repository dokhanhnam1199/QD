```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *,
                tolerance: float = 1e-12,
                tie_breaker: float = 1e-12,
                seed: int | None = None) -> np.ndarray:
    """
    Priority function for online bin packing that:
      * adapts a numerical tolerance for feasibility,
      * biases bins towards tighter fits using slack,
      * incorporates the fill level (smaller slack = higher priority),
      * randomises ties for exploration.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for each open bin.
    tolerance : float, optional
        Accept bins whose remaining capacity is within ``item - tolerance``.
    tie_breaker : float, optional
        Deterministic bias to break ties between bins with identical priorities
        (lower‑indexed bins are favoured).
    seed : int or None, optional
        Seed for the random number generator to obtain reproducible results.
        If ``None`` the global RNG state is used.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better).  Infeasible bins receive ``-np.inf``.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()

    # Feasibility mask using tolerance
    feasible = caps >= (item - tolerance)

    priorities = np.full_like(caps, -np.inf, dtype=float)
    if not np.any(feasible):
        return priorities

    # Slack (non‑negative)
    slack = caps[feasible] - item
    slack = np.maximum(slack, 0.0)

    # Bias: smaller slack → larger bias
    epsilon = 1e-12
    bias = 1.0 / (slack + epsilon)

    # Random component for exploration
    rng = np.random.default_rng(seed)
    rand_component = rng.random(feasible.sum())

    # Base priority: negative slack (tighter fit first)
    base_priority = -slack

    # Combine: tighter fit + random exploration
    priority_vals = base_priority + bias * rand_component

    # Deterministic tie‑breaker: lower index favored
    idx = np.arange(caps.size)
    priority_vals += -idx[feasible] * tie_breaker

    priorities[feasible] = priority_vals
    return priorities
```
