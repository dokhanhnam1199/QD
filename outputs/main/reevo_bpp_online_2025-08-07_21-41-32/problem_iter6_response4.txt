```python
import numpy as np

_rng = np.random.default_rng()

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing that biases random choice
    towards bins with small remaining slack. It adapts the bias to the
    current distribution of leftover capacities and adds a tiny random
    perturbation for deterministic tie‑breaking.
    """
    # Ensure the input is a float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Remaining slack after placing the item
    slack = caps - item

    # Feasibility mask
    feasible = slack >= 0

    # Prepare output array with -inf for infeasible bins
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    eps = 1e-12

    # Inverse‑slack bias (larger when slack is smaller)
    bias = np.zeros_like(caps)
    bias[feasible] = 1.0 / (slack[feasible] + eps)

    # Adapt scaling based on the current slack distribution
    min_slack = np.min(slack[feasible])
    max_slack = np.max(slack[feasible])
    scale_den = max_slack - min_slack

    scaling = np.ones_like(caps)
    if scale_den >= eps:
        scaling[feasible] = (max_slack - slack[feasible]) / (scale_den + eps)
    else:
        # When all feasible bins have identical slack, keep scaling 1
        scaling[feasible] = 1.0

    # Combine bias and scaling
    scores = bias * scaling

    # Tiny random tie‑breaker (only on feasible bins)
    tie_break = _rng.random(feasible.sum()) * 1e-12
    scores[feasible] += tie_break

    # Place scores into the output array
    priorities[feasible] = scores[feasible]
    return priorities
```
