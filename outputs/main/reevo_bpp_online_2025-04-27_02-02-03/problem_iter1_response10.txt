```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate wasted space if the item is placed in each bin
    wasted_space = bins_remain_cap - item

    # Give a high priority to bins where the item fits and the wasted space is minimized.
    # Bins where the item doesn't fit get a negative priority (we don't want to put the item there).
    for i, waste in enumerate(wasted_space):
        if waste >= 0:
            priorities[i] = 1 / (waste + 1e-6)  # Invert waste (+ small const.) to prioritize small waste
        else:
            priorities[i] = -1e9  # Very negative priority if it doesn't fit.

    # Bonus for bins that are nearly full after placing the item (avoid creating many almost-empty bins)
    nearly_full_threshold = 0.1  # e.g., bin must be at least 90% full after placing the item
    for i, remaining_cap in enumerate(bins_remain_cap):
      if remaining_cap >= item and (remaining_cap - item) / remaining_cap < nearly_full_threshold:
        priorities[i] += 10  # Add a significant bonus

    # If no bin fits, return all zeros. This shouldn't generally happen
    # but is included for robustness. It signals to a higher-level
    # process that a new bin is needed.
    if np.all(priorities == -1e9):
      return np.zeros_like(bins_remain_cap)

    return priorities
```
