{
     "algorithm": "This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, and then computes a heuristic matrix indicating how frequently each edge appears in feasible routes, normalized by the distance of that edge.",
     "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, and then computes a heuristic matrix indicating how frequently each edge appears in feasible routes, normalized by the distance of that edge.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct routes\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_demand = demands[customer]\n        current_route.append(0) #close route at depot\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix\n    \n    #Normalize heuristic by distance matrix\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j] \n\n    return heuristics_matrix",
     "objective": 25.30195,
     "other_inf": null,
     "SLOC": 29.0,
     "cyclomatic_complexity": 6.0,
     "halstead": 96.0
}