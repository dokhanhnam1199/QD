[
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, and then computes a heuristic matrix indicating how frequently each edge appears in feasible routes, normalized by the distance of that edge.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility based on capacity constraints, and then computes a heuristic matrix indicating how frequently each edge appears in feasible routes, normalized by the distance of that edge.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Construct routes\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_demand = demands[customer]\n        current_route.append(0) #close route at depot\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetric distance matrix\n    \n    #Normalize heuristic by distance matrix\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > 0:\n                heuristics_matrix[i, j] /= distance_matrix[i, j] \n\n    return heuristics_matrix",
          "objective": 25.30195,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by stochastically sampling feasible routes based on distance and capacity constraints, favoring shorter distances and routes that efficiently utilize vehicle capacity.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a heuristics matrix by stochastically sampling feasible routes based on distance and capacity constraints, favoring shorter distances and routes that efficiently utilize vehicle capacity.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Start from the depot\n        current_node = 0\n        current_route = [0]\n        remaining_nodes = set(range(1, n))\n        current_load = 0\n\n        while remaining_nodes:\n            # Find feasible neighbors\n            feasible_neighbors = []\n            for neighbor in remaining_nodes:\n                if current_load + demands[neighbor] <= capacity:\n                    feasible_neighbors.append(neighbor)\n            \n            if not feasible_neighbors:\n                # Return to depot\n                current_route.append(0)\n                for i in range(len(current_route) - 1):\n                    heuristics_matrix[current_route[i], current_route[i+1]] += 1\n                current_node = 0\n                current_load = 0\n                current_route = [0]\n\n                feasible_neighbors = []\n                for neighbor in remaining_nodes:\n                    if current_load + demands[neighbor] <= capacity:\n                        feasible_neighbors.append(neighbor)\n                if not feasible_neighbors:\n                    break #impossible route\n\n            # Choose next node stochastically based on distance\n            probabilities = []\n            total_distance = 0\n            for neighbor in feasible_neighbors:\n                total_distance += (1 / distance_matrix[current_node, neighbor])\n\n            for neighbor in feasible_neighbors:\n                probabilities.append((1 / distance_matrix[current_node, neighbor]) / total_distance)\n\n            try:\n                next_node = np.random.choice(feasible_neighbors, p=probabilities)\n            except ValueError:\n                next_node = feasible_neighbors[0]\n\n            current_route.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_load += demands[next_node]\n            current_node = next_node\n            \n        # Return to depot\n        current_route.append(0)\n        for i in range(len(current_route) - 1):\n            heuristics_matrix[current_route[i], current_route[i+1]] += 1\n    return heuristics_matrix",
          "objective": 25.49957,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency with which each edge appears in feasible routes to estimate its desirability.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples a large number of random routes, evaluates their feasibility and cost, and uses the frequency with which each edge appears in feasible routes to estimate its desirability.}\"\"\"\n\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_permutation = list(range(1, n))\n        random.shuffle(customer_permutation)\n\n        # Construct routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_permutation:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_demand = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n        \n        #Update heuristics matrix for each route\n        for route in routes:\n          for i in range(len(route) - 1):\n            node1 = route[i]\n            node2 = route[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n        \n\n    return heuristics_matrix",
          "objective": 29.4197,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then aggregates edge usage frequency in feasible routes to create a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then aggregates edge usage frequency in feasible routes to create a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000  # Number of random routes to sample\n    \n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_permutation = list(range(1, n))\n        random.shuffle(customer_permutation)\n        \n        # Construct routes based on capacity constraint\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n        \n        for customer in customer_permutation:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_capacity = demands[customer]\n                \n        current_route.append(0)  # Close the last route\n        routes.append(current_route)\n        \n        # Check feasibility (all customers visited) - optional, but good practice\n        visited_customers = set()\n        for route in routes:\n            for customer in route:\n                if customer != 0:\n                    visited_customers.add(customer)\n        if len(visited_customers) != n - 1: #exclude depot\n           continue # if route not feasible, skip this round\n\n        # Update heuristics matrix: Increment count for edges in feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Since it's an undirected graph\n                \n    return heuristics_matrix",
          "objective": 29.5285,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm generates multiple random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm generates multiple random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        routes = []\n        current_route = [0]\n        current_load = 0\n\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_load = demands[customer]\n\n        current_route.append(0)  # Return to depot\n        routes.append(current_route)\n\n        # Check feasibility (all customers visited)\n        visited_customers = set()\n        for route in routes:\n          visited_customers.update(route)\n        \n        valid_solution = True\n        for i in range(1, n):\n            if i not in visited_customers:\n                valid_solution = False\n                break\n                \n        if valid_solution:\n\n            # Update heuristic matrix based on edges in the route\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i + 1]\n                    heuristics_matrix[node1, node2] += 1\n                    heuristics_matrix[node2, node1] += 1  # Symmetric\n\n    return heuristics_matrix",
          "objective": 29.5892,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by sampling random routes, evaluating their feasibility based on capacity, and rewarding edges that appear in feasible routes with a score inversely proportional to the route length.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a heuristics matrix by sampling random routes, evaluating their feasibility based on capacity, and rewarding edges that appear in feasible routes with a score inversely proportional to the route length.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Build routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n        \n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_demand = demands[customer]\n        \n        current_route.append(0)  # End the last route at the depot\n        routes.append(current_route)\n\n        # Calculate total route length\n        total_length = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_length += distance_matrix[route[i], route[i+1]]\n        \n        # Update heuristics matrix if routes are feasible\n        if total_length > 0:  # Ensure the route is not empty\n            reward = 1.0 / total_length\n            for route in routes:\n                for i in range(len(route) - 1):\n                    heuristics_matrix[route[i], route[i+1]] += reward\n                    heuristics_matrix[route[i+1], route[i]] += reward  # Assuming symmetry\n\n    return heuristics_matrix",
          "objective": 29.58963,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "The algorithm samples many random routes, evaluates their feasibility with respect to capacity constraints, and constructs a heuristic matrix favoring edges that appear frequently in feasible solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{The algorithm samples many random routes, evaluates their feasibility with respect to capacity constraints, and constructs a heuristic matrix favoring edges that appear frequently in feasible solutions.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Create routes based on capacity constraint\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_load = demands[customer]\n\n        current_route.append(0)  # Complete the last route\n        routes.append(current_route)\n\n        # Update heuristics matrix if the solution is feasible\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetry\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.63691,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and aggregates edge frequencies across feasible routes to create a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and aggregates edge frequencies across feasible routes to create a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        random.shuffle(route)\n\n        routes = []\n        current_route = [0]\n        current_demand = 0\n        \n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, node]\n                current_demand = demands[node]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n\n    return heuristics_matrix",
          "objective": 29.65684,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes as a heuristic.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility and cost, and uses the frequency of each edge appearing in feasible routes as a heuristic.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        permutation = random.sample(range(1, n), n - 1)\n        \n        # Construct routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        \n        for customer in permutation:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_load = demands[customer]\n        \n        current_route.append(0) # return to depot\n        routes.append(current_route)\n        \n        # Evaluate feasibility (all customers visited)\n        visited_customers = set()\n        for route in routes:\n            visited_customers.update(route)\n        \n        valid_permutation = all(i in visited_customers for i in range(1,n))\n    \n        # Update heuristics matrix if the permutation yields a valid routing\n        if valid_permutation:\n          for route in routes:\n            for i in range(len(route) - 1):\n                heuristics_matrix[route[i], route[i+1]] += 1\n                heuristics_matrix[route[i+1], route[i]] += 1  # Assuming undirected graph\n\n    return heuristics_matrix",
          "objective": 29.67163,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples random feasible routes, evaluates their quality based on distance and capacity constraints, and aggregates edge usage frequency to generate a heuristic matrix favoring edges appearing in better solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples random feasible routes, evaluates their quality based on distance and capacity constraints, and aggregates edge usage frequency to generate a heuristic matrix favoring edges appearing in better solutions.}\"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000  # Number of random samples to generate\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.arange(1, n)\n        np.random.shuffle(customer_indices)\n\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n\n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_demand = demands[customer]\n\n        current_route.append(0)  # Return to depot\n        routes.append(current_route)\n\n        # Calculate the total distance of the routes\n        total_distance = 0\n        for route in routes:\n            for i in range(len(route) - 1):\n                total_distance += distance_matrix[route[i], route[i + 1]]\n\n        # Update the heuristics matrix based on edge usage and total distance\n        # Edges in shorter routes get higher scores\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i + 1]\n                heuristics_matrix[node1, node2] += 1 / (1 + total_distance) #Higher score for edges in good solutions\n                heuristics_matrix[node2, node1] += 1 / (1 + total_distance) # Ensure symmetry\n\n\n    return heuristics_matrix",
          "objective": 29.69882,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility\n    regarding capacity constraints, and updates edge scores based on the\n    frequency of feasible routes containing each edge.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples multiple random routes, evaluates their feasibility\n    regarding capacity constraints, and updates edge scores based on the\n    frequency of feasible routes containing each edge.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        route = list(range(1, n))\n        np.random.shuffle(route)\n        \n        current_route = [0]\n        current_demand = 0\n        routes = []\n        \n        for node in route:\n            if current_demand + demands[node] <= capacity:\n                current_route.append(node)\n                current_demand += demands[node]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, node]\n                current_demand = demands[node]\n        \n        current_route.append(0)\n        routes.append(current_route)\n\n        for r in routes:\n            for i in range(len(r) - 1):\n                heuristics_matrix[r[i], r[i+1]] += 1\n                heuristics_matrix[r[i+1], r[i]] += 1\n                \n    return heuristics_matrix",
          "objective": 29.76461,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates their feasibility and cost, and then uses the edge frequencies in feasible routes to construct a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates their feasibility and cost, and then uses the edge frequencies in feasible routes to construct a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        permutation = random.sample(range(1, n), n - 1)\n\n        # Route construction\n        routes = []\n        current_route = [0]\n        current_load = 0\n\n        for customer in permutation:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_load = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n\n        # Feasibility check\n        feasible = True\n        for route in routes:\n            route_load = 0\n            for customer in route:\n                route_load += demands[customer]\n            if route_load > capacity:\n                feasible = False\n                break\n\n        # Update heuristics matrix if the solution is feasible\n        if feasible:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    u = route[i]\n                    v = route[i+1]\n                    heuristics_matrix[u, v] += 1\n                    heuristics_matrix[v, u] += 1 #since the distances are assumed to be symmetric, we can add the opposite direction\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.78127,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm constructs a heuristic matrix by sampling random routes and penalizing edges that frequently violate capacity constraints while rewarding edges present in feasible solutions.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm constructs a heuristic matrix by sampling random routes and penalizing edges that frequently violate capacity constraints while rewarding edges present in feasible solutions.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Initialize variables for route construction\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        routes = []\n\n        # Build routes based on capacity constraints\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_load = demands[customer]\n\n        current_route.append(0) # Return to depot after last customer\n        routes.append(current_route)\n\n        # Update heuristic matrix based on route feasibility\n        feasible = True\n        for route in routes:\n            total_demand = sum(demands[i] for i in route if i != 0)\n            if total_demand > capacity:\n                feasible = False\n                break\n\n        if feasible:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += 1\n                    heuristics_matrix[node2, node1] += 1\n        else:\n            # Penalize edges in infeasible solutions\n             for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] -= 0.5\n                    heuristics_matrix[node2, node1] -= 0.5\n\n    return heuristics_matrix",
          "objective": 29.85357,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by sampling random routes, \n     penalizing routes exceeding vehicle capacity, and aggregating edge frequencies across samples.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge inclusion probabilities by sampling random routes, \n     penalizing routes exceeding vehicle capacity, and aggregating edge frequencies across samples.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000  # Number of random routes to sample\n    alpha = 0.1         # Penalty factor for exceeding capacity\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = np.random.permutation(range(1, n))\n        \n        # Construct a route based on the random permutation\n        route = [0]  # Start at the depot\n        current_load = 0\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                route.append(customer)\n                current_load += demands[customer]\n            else:\n                route.append(0)  # Return to depot\n                current_load = demands[customer]\n                route.append(customer)\n        route.append(0)  # Return to depot\n\n        # Calculate the cost of the route and penalty\n        route_cost = 0\n        penalty = 0\n        current_load = 0\n        valid_route = True\n        \n        temp_route = [0]\n        \n        for i in range(len(route) - 1):\n            u = route[i]\n            v = route[i+1]\n            route_cost += distance_matrix[u, v]\n            if v != 0:\n              if current_load + demands[v] <= capacity:\n                  current_load += demands[v]\n                  temp_route.append(v)\n              else:\n                  valid_route = False\n                  break\n            else:\n              current_load = 0\n              temp_route = [0]\n              \n        \n        current_load = 0\n        for i in range(len(route) - 1):\n          \n            if route[i+1] != 0:\n              if current_load + demands[route[i+1]] > capacity:\n                  valid_route = False\n                  break\n              else:\n                  current_load += demands[route[i+1]]\n            else:\n              current_load = 0\n\n\n        if not valid_route:\n          penalty = alpha * route_cost\n          route_cost += penalty\n          \n\n        # Update heuristics matrix based on edges in the route\n        for i in range(len(route) - 1):\n            u = route[i]\n            v = route[i+1]\n            heuristics_matrix[u, v] += 1 / (route_cost + 1e-6)  # Add a small epsilon to avoid division by zero\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 29.85858,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm estimates edge inclusion probabilities by iteratively generating random feasible routes and counting edge occurrences.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm estimates edge inclusion probabilities by iteratively generating random feasible routes and counting edge occurrences.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros((n, n))\n    num_iterations = 1000  # Number of random route generation iterations\n\n    for _ in range(num_iterations):\n        # Generate a random permutation of customer indices (excluding the depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Build routes based on the random permutation and capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_capacity = demands[customer]\n        \n        current_route.append(0) #Return to depot\n        routes.append(current_route)\n\n        # Update heuristics matrix based on the edges in the generated routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i + 1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Since the problem is symmetric\n    \n    # Normalize the heuristics matrix to get probabilities\n    heuristics_matrix = heuristics_matrix / num_iterations\n\n    return heuristics_matrix",
          "objective": 29.87011,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples a set of random routes, evaluates them based on distance and capacity constraints, and constructs a heuristic matrix by aggregating the frequency with which each edge appears in feasible routes.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a set of random routes, evaluates them based on distance and capacity constraints, and constructs a heuristic matrix by aggregating the frequency with which each edge appears in feasible routes.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = np.random.permutation(np.arange(1, n))\n        \n        # Create routes based on capacity constraints\n        routes = []\n        current_route = [0]\n        current_capacity = 0\n        \n        for customer in customer_indices:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)\n                routes.append(current_route)\n                current_route = [0, customer]\n                current_capacity = demands[customer]\n\n        current_route.append(0)\n        routes.append(current_route)\n        \n        # Update the heuristic matrix with edges present in the route\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1\n                \n    return heuristics_matrix",
          "objective": 29.99325,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples random routes, checks their feasibility based on capacity, and then updates a heuristic matrix based on the frequency with which each edge appears in feasible routes.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples random routes, checks their feasibility based on capacity, and then updates a heuristic matrix based on the frequency with which each edge appears in feasible routes.}\"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_permutation = list(range(1, n))\n        random.shuffle(customer_permutation)\n\n        # Construct routes based on capacity\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_capacity = 0\n\n        for customer in customer_permutation:\n            if current_capacity + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_capacity += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start new route from depot\n                current_capacity = demands[customer]\n        \n        current_route.append(0)\n        routes.append(current_route)\n\n        # Update heuristics matrix based on edges in routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1 #Symmetric Matrix\n\n    return heuristics_matrix",
          "objective": 30.01002,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples many random routes, evaluates their feasibility with respect to capacity constraints, and averages edge occurrences in feasible routes to construct a heuristic matrix favoring edges that appear frequently in good solutions.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples many random routes, evaluates their feasibility with respect to capacity constraints, and averages edge occurrences in feasible routes to construct a heuristic matrix favoring edges that appear frequently in good solutions.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n\n        # Assign customers to routes based on capacity\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n\n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route from depot\n                current_load = demands[customer]\n\n        current_route.append(0) # final return to depot\n        routes.append(current_route)\n        \n        # Update heuristics matrix\n        for route in routes:\n            for i in range(len(route) - 1):\n                u = route[i]\n                v = route[i+1]\n                heuristics_matrix[u, v] += 1\n                heuristics_matrix[v, u] += 1  # Assuming symmetric distance matrix\n\n    # Normalize the matrix to get a probability-like heuristic\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 30.08647,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"{This algorithm samples multiple random routes, evaluates their feasibility with respect to capacity constraints, and uses the frequency of each edge appearing in feasible routes to construct a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros((n, n))\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random permutation of customers (excluding the depot)\n        customer_indices = np.random.permutation(np.arange(1, n))\n        \n        # Build a route based on the permutation, respecting capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_load = 0\n        \n        for customer in customer_indices:\n            if current_load + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_load += demands[customer]\n            else:\n                current_route.append(0)  # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer]  # Start a new route\n                current_load = demands[customer]\n\n        current_route.append(0) # End the current route and return to the depot\n        routes.append(current_route)\n\n        # Update the heuristic matrix based on edges in the feasible routes\n        for route in routes:\n            for i in range(len(route) - 1):\n                node1 = route[i]\n                node2 = route[i+1]\n                heuristics_matrix[node1, node2] += 1\n                heuristics_matrix[node2, node1] += 1  # Assuming symmetry\n\n    return heuristics_matrix",
          "objective": 30.1107,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     },
     {
          "algorithm": "This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then uses the frequency with which each edge appears in feasible solutions to construct a heuristic matrix.",
          "code": "import numpy as np\nimport random\n\ndef heuristics_v2(distance_matrix, coordinates, demands, capacity):\n    \"\"\"\n    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and then uses the frequency with which each edge appears in feasible solutions to construct a heuristic matrix.}\n    \"\"\"\n    n = len(demands)\n    heuristics_matrix = np.zeros_like(distance_matrix)\n    num_samples = 1000 # Increased number of samples\n    \n    for _ in range(num_samples):\n        \n        # Generate a random permutation of customers (excluding depot)\n        customer_indices = list(range(1, n))\n        random.shuffle(customer_indices)\n        \n        # Construct routes based on capacity constraints\n        routes = []\n        current_route = [0]  # Start at the depot\n        current_demand = 0\n        \n        for customer in customer_indices:\n            if current_demand + demands[customer] <= capacity:\n                current_route.append(customer)\n                current_demand += demands[customer]\n            else:\n                current_route.append(0) # Return to depot\n                routes.append(current_route)\n                current_route = [0, customer] # Start a new route at depot\n                current_demand = demands[customer]\n        \n        current_route.append(0) # Return to depot at the end\n        routes.append(current_route)\n\n        #Check feasibility. For simplicity, we suppose that all demands[i] < capacity.\n        feasible = True\n        for route in routes:\n            total_demand = 0\n            for node in route:\n                total_demand += demands[node]\n            if total_demand > capacity:\n                feasible = False\n                break\n                \n        # Update the heuristic matrix\n        if feasible:\n            for route in routes:\n                for i in range(len(route) - 1):\n                    node1 = route[i]\n                    node2 = route[i+1]\n                    heuristics_matrix[node1, node2] += 1\n                    heuristics_matrix[node2, node1] += 1  # Symmetric\n\n    # Normalize the heuristic matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n\n    return heuristics_matrix",
          "objective": 30.19581,
          "other_inf": null,
          "SLOC": 29.0,
          "cyclomatic_complexity": 6.0,
          "halstead": 96.0
     }
]