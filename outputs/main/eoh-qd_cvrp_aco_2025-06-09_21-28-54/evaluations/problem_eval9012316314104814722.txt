import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes by probabilistically selecting the next node based on distance and demand, favoring closer and feasible nodes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000

    for _ in range(num_iterations):
        current_node = 0
        current_demand = 0
        route = [0]
        unvisited = set(range(1, n))
        
        while unvisited:
            # Calculate probabilities for each unvisited node
            probabilities = []
            for node in unvisited:
                if current_demand + demands[node] <= capacity:
                    distance = distance_matrix[current_node, node]
                    # Probability inversely proportional to distance and demand
                    probability = (1 / (distance + 1e-6)) * (1 / (demands[node] + 1e-6))
                    probabilities.append((node, probability))
                else:
                    probabilities.append((node, 0))

            # Normalize probabilities
            total_probability = sum(p for _, p in probabilities)
            if total_probability > 0:
                probabilities = [(node, p / total_probability) for node, p in probabilities]
            else:
                # If no feasible nodes, return to depot
                probabilities = [(0, 1)]  # Only option is to go to depot
                unvisited.add(current_node)
                current_node = 0
                current_demand = 0
                break #Restart route from depot in next iteration


            # Select next node based on probabilities
            nodes, probs = zip(*probabilities)
            next_node = random.choices(nodes, probs)[0]
            

            if next_node == 0:
              route.append(0)
              current_node = 0
              current_demand = 0
              unvisited = set(range(1, n))
              break #Restart route from depot in next iteration
            else:
              route.append(next_node)
              current_demand += demands[next_node]
              current_node = next_node
              unvisited.remove(next_node)

        route.append(0) # Return to depot

        # Update heuristic matrix
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i+1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
