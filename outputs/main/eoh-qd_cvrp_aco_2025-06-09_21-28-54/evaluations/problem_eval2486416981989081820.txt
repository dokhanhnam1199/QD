import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses an ant colony optimization approach to probabilistically construct routes, updating pheromone levels based on route quality and feasibility, to generate a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    pheromone = np.ones((n, n))  # Initialize pheromone levels
    alpha = 1  # Pheromone influence
    beta = 2   # Distance influence
    rho = 0.5   # Evaporation rate
    Q = 100     # Pheromone deposit constant
    num_ants = 50
    num_iterations = 100

    for iteration in range(num_iterations):
        all_routes = []
        for ant in range(num_ants):
            unvisited = list(range(1, n))
            current_node = 0
            current_route = [0]
            current_load = 0
            routes = []

            while unvisited:
                probabilities = []
                for next_node in unvisited:
                    if current_load + demands[next_node] <= capacity:
                        probabilities.append((pheromone[current_node, next_node]**alpha) * ((1/distance_matrix[current_node, next_node])**beta))
                    else:
                        probabilities.append(0) #Invalid choice, probability 0

                if sum(probabilities) == 0: # No feasible nodes left, return to depot
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0]
                    current_load = 0
                    probabilities = []
                    for next_node in unvisited:
                        if demands[next_node] <= capacity: #Ensure feasibility to start new route
                            probabilities.append((pheromone[current_node, next_node]**alpha) * ((1/distance_matrix[current_node, next_node])**beta))
                        else:
                            probabilities.append(0) #Node too large.

                    if sum(probabilities) == 0: #if none of the remaining unvisited can be added, break
                        break

                probabilities = np.array(probabilities) / sum(probabilities)
                next_node = random.choices(unvisited, weights=probabilities)[0]

                if current_load + demands[next_node] <= capacity:
                    current_route.append(next_node)
                    current_load += demands[next_node]
                    unvisited.remove(next_node)
                    current_node = next_node
                else:
                    current_route.append(0) #Return to depot
                    routes.append(current_route)
                    current_route = [0,next_node] #Restart new Route.
                    current_load = demands[next_node]
                    unvisited.remove(next_node)
                    current_node = next_node
            current_route.append(0)
            routes.append(current_route)
            all_routes.append(routes)

        # Update pheromones
        for i in range(n):
            for j in range(n):
                pheromone[i, j] *= (1 - rho)  # Evaporation

        for routes in all_routes:
            total_distance = 0
            for route in routes:
                for i in range(len(route) - 1):
                    total_distance += distance_matrix[route[i], route[i + 1]]

            for route in routes:
                for i in range(len(route) - 1):
                    node1 = route[i]
                    node2 = route[i + 1]
                    pheromone[node1, node2] += Q / (total_distance + 1e-6) #Avoid divide by zero
                    pheromone[node2, node1] += Q / (total_distance + 1e-6) # Symmetric

    #Use pheromone as heuristic matrix
    heuristics_matrix = pheromone

    return heuristics_matrix
