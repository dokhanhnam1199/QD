import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a biased random walk to generate routes, favoring edges with shorter distances and penalizing edges that lead to capacity violations, accumulating edge usage as a heuristic.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000

    for _ in range(num_samples):
        current_node = 0
        current_load = 0
        route = [0]
        unvisited = set(range(1, n))
        
        while unvisited:
            # Calculate probabilities for each neighbor
            probabilities = []
            neighbors = list(unvisited) + [0] # Include depot as a possibility

            for neighbor in neighbors:
                if neighbor == 0:
                    potential_load = 0  # Returning to depot resets load
                else:
                    potential_load = current_load + demands[neighbor]
                
                if potential_load <= capacity or neighbor == 0:
                    distance = distance_matrix[current_node, neighbor]
                    # Favor shorter distances and avoid immediate capacity violations
                    probability = (1 / (distance + 1e-6)) # Avoid division by zero
                    probabilities.append(probability)
                else:
                    probabilities.append(0) # Very low probability to discourage infeasible moves

            # Normalize probabilities
            total_probability = sum(probabilities)
            if total_probability == 0:
                 break # No feasible moves left
            probabilities = [p / total_probability for p in probabilities]

            # Choose the next node based on probabilities
            next_node = random.choices(neighbors, weights=probabilities, k=1)[0]

            # Update route and load
            if next_node == 0:
                current_load = 0
                unvisited = set(range(1, n)) - set(route) 
            else:
                 current_load += demands[next_node]
                 unvisited.remove(next_node)
            route.append(next_node)
            current_node = next_node

        if len(set(route)) == n:

            # Update heuristic matrix based on edges in the route
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i + 1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1  # Symmetric

    return heuristics_matrix
