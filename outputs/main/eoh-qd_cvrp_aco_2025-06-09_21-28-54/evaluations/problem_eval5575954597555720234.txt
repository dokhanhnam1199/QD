import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an ant colony optimization approach to probabilistically construct routes, using pheromone levels and distances to guide ant movement, and updates pheromones based on route quality and feasibility.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)  # Initialize pheromone levels
    alpha = 1.0  # Pheromone influence
    beta = 2.0  # Distance influence
    evaporation_rate = 0.1
    Q = 100.0  # Pheromone deposit constant
    num_ants = 50
    iterations = 100

    for _ in range(iterations):
        all_routes = []
        for ant in range(num_ants):
            route = [0]
            remaining_nodes = list(range(1, n))
            current_load = 0

            while remaining_nodes:
                probabilities = []
                for node in remaining_nodes:
                    if current_load + demands[node] <= capacity:
                        probabilities.append((pheromone_matrix[route[-1], node]**alpha) / (distance_matrix[route[-1], node]**beta))
                    else:
                        probabilities.append(0)
                
                if sum(probabilities) == 0:
                    route.append(0)
                    current_load = 0
                    continue
                
                probabilities = np.array(probabilities) / sum(probabilities)

                next_node = random.choices(remaining_nodes, weights=probabilities)[0]
                
                if current_load + demands[next_node] <= capacity:
                    route.append(next_node)
                    current_load += demands[next_node]
                    remaining_nodes.remove(next_node)
                else:
                    route.append(0)
                    current_load = 0

            route.append(0)
            all_routes.append(route)

        # Evaluate routes and update pheromones
        for route in all_routes:
            route_cost = 0
            for i in range(len(route) - 1):
                route_cost += distance_matrix[route[i], route[i+1]]

            # Check capacity constraint satisfaction
            valid_route = True
            current_load = 0
            for i in range(len(route) - 1):
              if route[i+1] != 0:
                if current_load + demands[route[i+1]] > capacity:
                  valid_route = False
                  break
                else:
                  current_load += demands[route[i+1]]
              else:
                current_load = 0
                
            if valid_route:
                pheromone_deposit = Q / route_cost
                for i in range(len(route) - 1):
                    u = route[i]
                    v = route[i+1]
                    pheromone_matrix[u, v] += pheromone_deposit
                    pheromone_matrix[v, u] += pheromone_deposit  # Ensure symmetry

        # Evaporation
        pheromone_matrix *= (1 - evaporation_rate)

    # Aggregate edge frequencies from pheromone matrix (can be adjusted)
    heuristics_matrix = pheromone_matrix

    return heuristics_matrix
