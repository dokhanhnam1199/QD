import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by probabilistically accepting edge swaps that improve a cost-weighted objective function, updating a heuristic matrix based on edge usage in accepted routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    alpha = 0.1  # Learning rate
    temperature = 10.0

    # Initialize a random solution (routes)
    current_solution = []
    unvisited_customers = list(range(1, n))
    current_route = [0]
    current_capacity = 0

    while unvisited_customers:
        customer = random.choice(unvisited_customers)
        if current_capacity + demands[customer] <= capacity:
            current_route.append(customer)
            current_capacity += demands[customer]
            unvisited_customers.remove(customer)
        else:
            current_route.append(0)
            current_solution.append(current_route)
            current_route = [0]
            current_capacity = 0
    current_route.append(0)
    current_solution.append(current_route)

    def calculate_solution_cost(solution):
        cost = 0
        for route in solution:
            for i in range(len(route) - 1):
                cost += distance_matrix[route[i], route[i+1]]
        return cost

    current_cost = calculate_solution_cost(current_solution)

    for _ in range(num_iterations):
        # Select a random route from the current solution
        route_index = random.randint(0, len(current_solution) - 1)
        route = current_solution[route_index]

        # Select two random edges within the route
        if len(route) < 4:
            continue # Skip if route is too small to swap

        i = random.randint(0, len(route) - 2)
        j = random.randint(i + 1, len(route) - 1)

        # Create a new solution by swapping the selected edges
        new_route = route[:i+1] + route[i+1:j+1][::-1] + route[j+1:]
        new_solution = current_solution[:route_index] + [new_route] + current_solution[route_index+1:]
        
        # Check feasibility of the new solution
        feasible = True
        for r in new_solution:
            cap = 0
            for c in r:
                cap += demands[c]
            if cap > capacity:
                feasible = False
                break
        if not feasible:
            continue

        new_cost = calculate_solution_cost(new_solution)

        # Acceptance probability based on simulated annealing
        delta_cost = new_cost - current_cost
        acceptance_probability = np.exp(-delta_cost / temperature)

        # Accept the new solution with probability
        if random.random() < acceptance_probability:
            current_solution = new_solution
            current_cost = new_cost

            # Update heuristics matrix:
            for route in current_solution:
                for k in range(len(route) - 1):
                    u = route[k]
                    v = route[k+1]
                    heuristics_matrix[u, v] = (1 - alpha) * heuristics_matrix[u, v] + alpha*1
                    heuristics_matrix[v, u] = (1 - alpha) * heuristics_matrix[v, u] + alpha*1

        temperature *= 0.99  #Cooling schedule

    return heuristics_matrix
