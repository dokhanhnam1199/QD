import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a genetic algorithm approach to evolve a population of routes, selecting routes based on feasibility and cost to construct a heuristic matrix favoring edges in better routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1

    def create_individual():
        customer_indices = list(range(1, n))
        random.shuffle(customer_indices)
        routes = []
        current_route = [0]
        current_load = 0

        for customer in customer_indices:
            if current_load + demands[customer] <= capacity:
                current_route.append(customer)
                current_load += demands[customer]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, customer]
                current_load = demands[customer]

        current_route.append(0)
        routes.append(current_route)
        return routes

    def calculate_fitness(routes):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i + 1]]

        # Penalize infeasible solutions heavily
        total_demand = 0
        num_customers = 0
        for route in routes:
            route_demand = 0
            for customer in route:
                if customer != 0:
                    route_demand += demands[customer]
                    num_customers += 1
            total_demand += route_demand

        penalty = 0 if total_demand == sum(demands[1:]) else 1e9
        visited_customers = set()
        for route in routes:
            visited_customers.update(route)

        for i in range(1, n):
            if i not in visited_customers:
                penalty += 1e9
                
        return 1 / (total_distance + 1 + penalty)
    
    def crossover(parent1, parent2):
        # Simple one-point crossover
        crossover_point = random.randint(0, min(len(parent1), len(parent2)))
        child1 = parent1[:crossover_point] + parent2[crossover_point:]
        child2 = parent2[:crossover_point] + parent1[crossover_point:]
        return child1, child2

    def mutate(routes):
        if random.random() < mutation_rate:
            route_to_mutate = random.choice(routes)
            if len(route_to_mutate) > 2:
                i = random.randint(1, len(route_to_mutate) - 2)
                j = random.randint(1, len(route_to_mutate) - 2)
                route_to_mutate[i], route_to_mutate[j] = route_to_mutate[j], route_to_mutate[i]
        return routes

    # Initialize population
    population = [create_individual() for _ in range(population_size)]

    # Evolve population
    for generation in range(num_generations):
        # Evaluate fitness
        fitnesses = [calculate_fitness(individual) for individual in population]

        # Selection (roulette wheel selection)
        probabilities = [f / sum(fitnesses) for f in fitnesses]
        selected_indices = random.choices(range(population_size), weights=probabilities, k=population_size)
        selected_population = [population[i] for i in selected_indices]
        
        # Crossover and Mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = random.choice(selected_population)
            parent2 = random.choice(selected_population)
            child1, child2 = crossover(parent1, parent2)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))

        population = new_population[:population_size]  # Ensure population size stays constant
        

    # After evolution, use the best route to update the heuristic matrix
    best_routes = max(population, key=calculate_fitness) # Get best route
    
    for route in best_routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i + 1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
