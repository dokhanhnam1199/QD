import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm generates random route segments, evaluates their cost-effectiveness based on distance and remaining capacity, and aggregates segment usage frequency to generate a heuristic matrix favoring cost-effective segments.}"""
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    num_iterations = 1000

    for _ in range(num_iterations):
        # Select a random starting node (excluding the depot for segments)
        start_node = random.randint(1, n - 1)
        
        # Generate a random segment length
        segment_length = random.randint(2, min(5, n))  #Limit segment length to avoid excessively long segments

        # Build a random segment
        segment = [start_node]
        current_capacity = demands[start_node]
        
        possible_next_nodes = list(range(1, n))
        
        for _ in range(segment_length - 1):
            #Select next node from all possible next nodes
            next_node = random.choice(possible_next_nodes)
            
            if current_capacity + demands[next_node] <= capacity:
                segment.append(next_node)
                current_capacity += demands[next_node]
                possible_next_nodes.remove(next_node)
            else:
                break #Stop building the segment if capacity is exceeded
        
        #Evaluate cost-effectiveness of segment
        segment_distance = 0
        for i in range(len(segment) - 1):
            segment_distance += distance_matrix[segment[i], segment[i+1]]

        if segment_distance > 0: #Avoid division by zero
            cost_effectiveness = current_capacity / segment_distance #Reward segments carrying more load over shorter distances
        else:
            cost_effectiveness = 0

        #Update heuristics matrix based on segment usage and cost-effectiveness
        for i in range(len(segment) - 1):
            node1 = segment[i]
            node2 = segment[i + 1]
            heuristics_matrix[node1, node2] += cost_effectiveness
            heuristics_matrix[node2, node1] += cost_effectiveness #Symmetry
    
    return heuristics_matrix
