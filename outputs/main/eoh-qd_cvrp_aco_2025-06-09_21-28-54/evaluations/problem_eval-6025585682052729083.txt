import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a combination of savings and demand-weighted distance to create a heuristic matrix, favoring edges that connect nodes with high savings and low demand-weighted distances.}"""

    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate savings for each pair of nodes
    savings_matrix = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]

    # Calculate demand-weighted distance
    demand_weighted_distance = np.zeros_like(distance_matrix)
    for i in range(1, n):
        for j in range(1, n):
            demand_weighted_distance[i, j] = distance_matrix[i, j] * (demands[i] + demands[j])

    # Combine savings and demand-weighted distance to create the heuristic matrix
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                heuristics_matrix[i, j] = savings_matrix[i, j] / (demand_weighted_distance[i, j] + 1e-6) # Adding a small constant to avoid division by zero

    return heuristics_matrix
