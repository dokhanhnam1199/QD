import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs solutions by probabilistically adding edges based on their cost and a dynamically updated edge desirability score derived from previous feasible solutions.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    edge_desirability = np.ones_like(distance_matrix) # Initialize all edges with equal desirability
    num_iterations = 100

    for iteration in range(num_iterations):
        # Solution construction
        routes = []
        unvisited = set(range(1, n))
        current_route = [0]
        current_load = 0

        while unvisited:
            current_node = current_route[-1]
            # Calculate probabilities based on distance and desirability
            probabilities = np.zeros(n)
            for neighbor in range(1, n):
                if neighbor in unvisited:
                    probabilities[neighbor] = edge_desirability[current_node, neighbor] / distance_matrix[current_node, neighbor] if distance_matrix[current_node, neighbor] > 0 else 0 # Avoid division by zero
            
            # Normalize probabilities (only for unvisited nodes)
            probabilities = probabilities / np.sum(probabilities[list(unvisited)]) if np.sum(probabilities[list(unvisited)]) > 0 else np.zeros(n)

            # Select next node probabilistically
            next_node = None
            
            possible_nodes = [node for node in range(1,n) if node in unvisited and probabilities[node] > 0]
            
            if len(possible_nodes) > 0:
                next_node = random.choices(possible_nodes, weights=[probabilities[node] for node in possible_nodes], k=1)[0]

            if next_node is not None and current_load + demands[next_node] <= capacity:
                current_route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_load = 0

        current_route.append(0)
        routes.append(current_route)

        # Feasibility check (capacity constraints)
        feasible = True
        for route in routes:
            route_load = sum(demands[customer] for customer in route)
            if route_load > capacity:
                feasible = False
                break

        # Update edge desirability based on solution feasibility
        if feasible:
            for route in routes:
                for i in range(len(route) - 1):
                    u = route[i]
                    v = route[i+1]
                    heuristics_matrix[u, v] += 1
                    heuristics_matrix[v, u] += 1
                    edge_desirability[u, v] *= 1.1  # Increase desirability of edges in good solutions
                    edge_desirability[v, u] *= 1.1
        else:
            for route in routes:
                for i in range(len(route) - 1):
                    u = route[i]
                    v = route[i+1]
                    edge_desirability[u, v] *= 0.9  # Decrease desirability of edges in infeasible solutions
                    edge_desirability[v, u] *= 0.9
        # Normalize desirability to avoid values growing too large or small.
        edge_desirability = np.clip(edge_desirability, 0.1, 10)

    return heuristics_matrix
