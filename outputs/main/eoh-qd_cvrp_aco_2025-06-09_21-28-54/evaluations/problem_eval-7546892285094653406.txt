import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a clustering-first, routing-second approach, clustering customers based on their proximity and demand to create vehicle routes, then improving route assignments using a savings heuristic, finally aggregating edge usage frequency to generate a heuristic matrix.}"""

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_clusters = int(np.sqrt(n))  # Heuristic for number of clusters
    
    # 1. Clustering (K-Means)
    from sklearn.cluster import KMeans
    kmeans = KMeans(n_clusters=num_clusters, random_state=0, n_init = 'auto')
    customer_indices = np.arange(1, n)
    cluster_labels = kmeans.fit_predict(coordinates[customer_indices])

    # 2. Initial Route Construction
    routes = [([0], 0) for _ in range(num_clusters)] # (route, current_demand)
    for i, customer in enumerate(customer_indices):
        cluster_id = cluster_labels[i]
        if routes[cluster_id][1] + demands[customer] <= capacity:
            routes[cluster_id] = (routes[cluster_id][0] + [customer], routes[cluster_id][1] + demands[customer])
        else:
            # Start a new route
            routes.append(([0, customer], demands[customer])) #append new route for over capacity
            num_clusters += 1

    routes = [route[0] + [0] for route in routes]

    # 3. Savings Heuristic (Route Improvement) -simplified
    for _ in range(50): #iterations
        for i in range(len(routes)):
            for j in range(len(routes)):
                if i != j:
                    # Check if merging routes i and j improves distance
                    route_i = routes[i]
                    route_j = routes[j]

                    if route_i is None or route_j is None: continue

                    total_demand = sum(demands[node] for node in route_i[:-1]) + sum(demands[node] for node in route_j[:-1])

                    if total_demand <= capacity:

                        dist_before = distance_matrix[route_i[-2], 0] + distance_matrix[route_j[-2],0]
                        dist_after = distance_matrix[route_i[-2], route_j[1]] + distance_matrix[route_j[-2], route_i[1]]

                        if  dist_before > dist_after:
                            new_route = route_i[:-1] + route_j[1:]
                            routes[i] = new_route
                            routes[j] = None

    routes = [route for route in routes if route is not None]


    # 4. Heuristics Matrix Update (Edge Frequency)
    for route in routes:
        if route is None: continue
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1  # Ensure symmetry

    return heuristics_matrix
