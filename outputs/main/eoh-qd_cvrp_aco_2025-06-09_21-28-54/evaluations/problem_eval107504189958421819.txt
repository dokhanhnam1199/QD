import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a clustering approach to create initial routes, refines them by swapping nodes between routes to improve capacity balance and reduce distance, and then updates edge scores based on the refined routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_clusters = 3  # Number of initial clusters (can be a parameter)
    num_iterations = 500

    # 1. Clustering (k-means-like, but simpler for this context)
    customer_indices = list(range(1, n))
    random.shuffle(customer_indices)
    cluster_centers = random.sample(customer_indices, min(num_clusters, n - 1)) # Ensure valid cluster centers
    clusters = [[] for _ in range(len(cluster_centers))]

    for customer in customer_indices:
        closest_center = min(range(len(cluster_centers)), key=lambda i: distance_matrix[customer, cluster_centers[i]])
        clusters[closest_center].append(customer)

    # 2. Initial Route Construction (Greedy)
    routes = []
    for cluster in clusters:
        current_route = [0]
        current_load = 0
        for customer in sorted(cluster, key=lambda c: distance_matrix[0, c]): #Greedy insertion
            if current_load + demands[customer] <= capacity:
                current_route.append(customer)
                current_load += demands[customer]
            else:
                routes.append(current_route + [0])  # Close the route
                current_route = [0, customer]
                current_load = demands[customer]
        routes.append(current_route + [0])

    # 3. Route Refinement (Node Swapping)
    for _ in range(num_iterations):
        # Select two random routes
        if len(routes) < 2: #If less than 2 routes, skip
            continue

        route_index1, route_index2 = random.sample(range(len(routes)), 2)
        route1 = routes[route_index1]
        route2 = routes[route_index2]

        # Select a random customer from each route (excluding depot)
        customer1_index = random.randint(1, len(route1) - 2) if len(route1) > 2 else -1 #Checking whether route1 is valid
        customer2_index = random.randint(1, len(route2) - 2) if len(route2) > 2 else -1 #Checking whether route2 is valid

        if customer1_index == -1 or customer2_index == -1:
            continue

        customer1 = route1[customer1_index]
        customer2 = route2[customer2_index]
    

        # Calculate new loads after swapping
        new_load1 = sum(demands[c] for c in route1[1:-1]) - demands[customer1] + demands[customer2]
        new_load2 = sum(demands[c] for c in route2[1:-1]) - demands[customer2] + demands[customer1]

        # Check capacity feasibility and distance improvement
        if new_load1 <= capacity and new_load2 <= capacity:
            # Calculate the distance change
            old_distance = distance_matrix[route1[customer1_index-1], customer1] + distance_matrix[customer1, route1[customer1_index+1]] + distance_matrix[route2[customer2_index-1], customer2] + distance_matrix[customer2, route2[customer2_index+1]]
            new_distance = distance_matrix[route1[customer1_index-1], customer2] + distance_matrix[customer2, route1[customer1_index+1]] + distance_matrix[route2[customer2_index-1], customer1] + distance_matrix[customer1, route2[customer2_index+1]]

            if new_distance < old_distance:
                # Perform the swap
                route1[customer1_index] = customer2
                route2[customer2_index] = customer1
                routes[route_index1] = route1
                routes[route_index2] = route2
    
    # 4. Update Heuristics Matrix
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    return heuristics_matrix
