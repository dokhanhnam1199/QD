import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by iteratively improving routes using a greedy insertion approach, biased by distance and demand, and penalizing infeasible routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000
    alpha = 0.5  # Weight for distance vs. demand
    beta = 1.0 # Penalty for infeasibility

    for _ in range(num_iterations):
        # Initialize a random route starting from the depot
        unvisited = set(range(1, n))
        current_route = [0]
        current_load = 0
        routes = []

        while unvisited:
            # Calculate insertion costs for each unvisited node
            insertion_costs = {}
            for node in unvisited:
                insertion_costs[node] = 0
                min_insertion_cost = float('inf')
                best_insertion_index = -1

                for i in range(len(current_route)):
                    temp_route = current_route[:i] + [node] + current_route[i:]
                    temp_load = 0
                    for customer in temp_route:
                      temp_load += demands[customer]
                    
                    if temp_load <= capacity:
                        insertion_cost = alpha * (distance_matrix[current_route[i-1], node] + distance_matrix[node, current_route[i]] - distance_matrix[current_route[i-1], current_route[i]]) if i > 0 else alpha * (distance_matrix[0, node] + distance_matrix[node, current_route[i]] - distance_matrix[0, current_route[i]])

                        if insertion_cost < min_insertion_cost:
                            min_insertion_cost = insertion_cost
                            best_insertion_index = i
                    else:
                      min_insertion_cost = float('inf')
                      best_insertion_index = -1

                if best_insertion_index != -1:
                    insertion_costs[node] = min_insertion_cost
                else:
                    insertion_costs[node] = float('inf') # Mark as infeasible for the current route

            # Select the best node to insert based on cost, with preference to feasible ones
            best_node = None
            min_cost = float('inf')
            for node, cost in insertion_costs.items():
                if cost < min_cost:
                    min_cost = cost
                    best_node = node

            #If no node can be added to the route
            if best_node is None or min_cost == float('inf'):
              # Close the current route and start a new one
              current_route.append(0)
              routes.append(current_route)
              current_route = [0]
              current_load = 0
              continue

            # Find best insertion index for selected node
            min_insertion_cost = float('inf')
            best_insertion_index = -1
            for i in range(len(current_route)):
                temp_route = current_route[:i] + [best_node] + current_route[i:]
                temp_load = 0
                for customer in temp_route:
                  temp_load += demands[customer]
                if temp_load <= capacity:
                    insertion_cost = alpha * (distance_matrix[current_route[i-1], best_node] + distance_matrix[best_node, current_route[i]] - distance_matrix[current_route[i-1], current_route[i]]) if i > 0 else alpha * (distance_matrix[0, best_node] + distance_matrix[best_node, current_route[i]] - distance_matrix[0, current_route[i]])

                    if insertion_cost < min_insertion_cost:
                        min_insertion_cost = insertion_cost
                        best_insertion_index = i

            #Insert best node at best location
            current_route = current_route[:best_insertion_index] + [best_node] + current_route[best_insertion_index:]
            current_load = 0
            for customer in current_route:
              current_load += demands[customer]

            unvisited.remove(best_node)
        
        current_route.append(0)
        routes.append(current_route)


        # Update heuristics matrix
        total_load = 0
        is_feasible = True
        for r in routes:
          route_load = 0
          for customer in r:
            route_load += demands[customer]

          if route_load > capacity:
            is_feasible = False
            break
          total_load += route_load

        for route in routes:
          for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]

            if is_feasible:
              heuristics_matrix[u, v] += 1
              heuristics_matrix[v, u] += 1
            else:
              heuristics_matrix[u,v] -= beta
              heuristics_matrix[v,u] -= beta

    return heuristics_matrix
