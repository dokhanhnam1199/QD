import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively constructs routes by considering savings from merging nodes and penalizing routes exceeding capacity, building a heuristic matrix based on edge frequency.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 1000

    for _ in range(num_iterations):
        routes = [[i] for i in range(1, n)]  # Initial routes: each customer in its own route
        
        # Savings matrix: savings[i][j] = distance_matrix[i][0] + distance_matrix[0][j] - distance_matrix[i][j]
        savings = np.zeros((n, n))
        for i in range(1, n):
            for j in range(1, n):
                if i != j:
                    savings[i, j] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]

        # Iteratively merge routes based on savings
        for _ in range(n - 1):  # At most n-1 merges
            best_savings = -np.inf
            best_i = -1
            best_j = -1
            route_i_index = -1
            route_j_index = -1
            
            for i_index, route_i in enumerate(routes):
                for j_index, route_j in enumerate(routes):
                    if i_index != j_index and route_i and route_j:
                        i = route_i[-1]
                        j = route_j[0]
                        if savings[i, j] > best_savings:
                            best_savings = savings[i, j]
                            best_i = i
                            best_j = j
                            route_i_index = i_index
                            route_j_index = j_index

            if best_i != -1:
                # Check capacity constraints
                total_demand_i = sum(demands[node] for node in routes[route_i_index])
                total_demand_j = sum(demands[node] for node in routes[route_j_index])
                
                if total_demand_i + total_demand_j <= capacity:
                    # Merge routes
                    routes[route_i_index].extend(routes[route_j_index])
                    routes[route_j_index] = []  # Mark route as merged
                else:
                    # Penalize merging by reducing savings (not implemented for simplicity)
                    pass
        
        # Construct a complete route for each non-empty route, starting and ending at the depot
        for route in routes:
            if route:
                full_route = [0] + route + [0]
                for i in range(len(full_route) - 1):
                    heuristics_matrix[full_route[i], full_route[i+1]] += 1
                
    return heuristics_matrix
