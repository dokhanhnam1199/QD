import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an adaptive large neighborhood search (ALNS) approach to iteratively improve routes and update a heuristic matrix based on edge selection frequency.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 100
    num_routes = 5

    # Initial solution: random routes
    routes = []
    unassigned_customers = list(range(1, n))
    while unassigned_customers:
        route = [0]
        current_load = 0
        while unassigned_customers:
            best_customer = -1
            best_dist = float('inf')
            for customer in unassigned_customers:
                if current_load + demands[customer] <= capacity:
                    dist = distance_matrix[route[-1], customer]
                    if dist < best_dist:
                        best_dist = dist
                        best_customer = customer
            if best_customer != -1:
                route.append(best_customer)
                current_load += demands[best_customer]
                unassigned_customers.remove(best_customer)
            else:
                break
        route.append(0)
        routes.append(route)

    best_routes = routes[:]

    for iteration in range(num_iterations):
        # Select a route to destroy (randomly)
        route_to_destroy_index = random.randint(0, len(routes) - 1)
        route_to_destroy = routes[route_to_destroy_index]

        # Remove the route and its customers from the current solution
        del routes[route_to_destroy_index]
        unassigned_customers = route_to_destroy[1:-1]

        # Re-insert customers into new routes
        while unassigned_customers:
            best_route_index = -1
            best_insertion_cost = float('inf')
            best_customer_to_insert = -1

            for customer in unassigned_customers:
                for i in range(len(routes)):
                    current_route = routes[i]
                    if sum(demands[node] for node in current_route[1:-1]) + demands[customer] <= capacity:
                        # Find the best insertion point for the customer
                        for j in range(1, len(current_route)):
                            insertion_cost = distance_matrix[current_route[j-1], customer] + distance_matrix[customer, current_route[j]] - distance_matrix[current_route[j-1], current_route[j]]
                            if insertion_cost < best_insertion_cost:
                                best_insertion_cost = insertion_cost
                                best_route_index = i
                                best_customer_to_insert = customer
                                best_insertion_point = j

            if best_customer_to_insert != -1:
                routes[best_route_index].insert(best_insertion_point, best_customer_to_insert)
                unassigned_customers.remove(best_customer_to_insert)
            else:
                # If no suitable route is found, create a new one
                new_route = [0, unassigned_customers[0], 0]
                routes.append(new_route)
                unassigned_customers.remove(unassigned_customers[0])

        # Evaluate the new solution
        total_distance = sum(sum(distance_matrix[routes[i][j], routes[i][j+1]] for j in range(len(routes[i])-1)) for i in range(len(routes)))
        best_total_distance = sum(sum(distance_matrix[best_routes[i][j], best_routes[i][j+1]] for j in range(len(best_routes[i])-1)) for i in range(len(best_routes)))

        # Update the best solution if the new solution is better
        if total_distance < best_total_distance:
            best_routes = routes[:]

        # Update the heuristic matrix
        for route in routes:
            for i in range(len(route) - 1):
                heuristics_matrix[route[i], route[i+1]] += 1
                heuristics_matrix[route[i+1], route[i]] += 1

    return heuristics_matrix
