import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs routes using a savings-based approach, iteratively merging routes until no further feasible merges are possible, and uses edge frequency in these savings-based routes to build the heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Initialize individual routes for each customer
    routes = [[0, i, 0] for i in range(1, n)]
    
    # Calculate savings for all pairs of customers
    savings = {}
    for i in range(1, n):
        for j in range(i + 1, n):
            savings[(i, j)] = distance_matrix[i, 0] + distance_matrix[0, j] - distance_matrix[i, j]
    
    # Sort savings in descending order
    sorted_savings = sorted(savings.items(), key=lambda item: item[1], reverse=True)
    
    # Iteratively merge routes based on savings
    while sorted_savings:
        (i, j), saving_value = sorted_savings.pop(0)
        
        route_i = None
        route_j = None
        
        # Find the routes containing i and j
        for route in routes:
            if i in route:
                route_i = route
            if j in route:
                route_j = route
        
        # Check if routes exist, are different, and i and j are at the ends of their respective routes
        if route_i and route_j and route_i != route_j and route_i[-2] == i and route_j[1] == j:
            # Check capacity constraint
            total_demand = sum(demands[node] for node in route_i[1:-1]) + sum(demands[node] for node in route_j[1:-1])
            if total_demand <= capacity:
                # Merge routes
                merged_route = route_i[:-1] + route_j[1:]
                routes.remove(route_i)
                routes.remove(route_j)
                routes.append(merged_route)
    
    # Update heuristics matrix based on final routes
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1
    
    return heuristics_matrix
