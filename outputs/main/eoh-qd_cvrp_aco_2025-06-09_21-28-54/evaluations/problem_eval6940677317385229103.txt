import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge inclusion probabilities by sampling random routes, weighting edges based on a combination of route length and capacity utilization, and penalizing routes exceeding vehicle capacity.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000  # Number of random routes to sample
    alpha = 0.1         # Penalty factor for exceeding capacity
    beta = 0.5          # Weight for capacity utilization in score

    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding depot)
        customer_indices = np.random.permutation(range(1, n))
        
        # Construct a route based on the random permutation
        route = [0]  # Start at the depot
        current_load = 0
        for customer in customer_indices:
            if current_load + demands[customer] <= capacity:
                route.append(customer)
                current_load += demands[customer]
            else:
                route.append(0)  # Return to depot
                current_load = demands[customer]
                route.append(customer)
        route.append(0)  # Return to depot

        # Calculate the cost of the route and penalty
        route_cost = 0
        penalty = 0
        current_load = 0
        valid_route = True
        
        temp_route = [0]
        
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            route_cost += distance_matrix[u, v]
            if v != 0:
              if current_load + demands[v] <= capacity:
                  current_load += demands[v]
                  temp_route.append(v)
              else:
                  valid_route = False
                  break
            else:
              current_load = 0
              temp_route = [0]
              
        
        current_load = 0
        for i in range(len(route) - 1):
          
            if route[i+1] != 0:
              if current_load + demands[route[i+1]] > capacity:
                  valid_route = False
                  break
              else:
                  current_load += demands[route[i+1]]
            else:
              current_load = 0


        if not valid_route:
          penalty = alpha * route_cost
          route_cost += penalty
          

        # Update heuristics matrix based on edges in the route
        total_demand = sum([demands[node] for node in route if node != 0])
        capacity_utilization = total_demand / (len([node for node in route if node == 0]) * capacity) if len([node for node in route if node == 0]) > 0 else 0
        
        score = (1 - beta) / (route_cost + 1e-6) + beta * capacity_utilization

        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += score

    # Normalize the heuristics matrix
    heuristics_matrix = heuristics_matrix / num_samples

    return heuristics_matrix
