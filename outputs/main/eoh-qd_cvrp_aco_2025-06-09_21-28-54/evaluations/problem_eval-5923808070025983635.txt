import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm iteratively refines routes by swapping nodes between routes to minimize cost and satisfy capacity constraints, updating a heuristic matrix based on edge usage in improved routes.}"""
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_iterations = 100

    # Initialize routes randomly
    routes = []
    unassigned_customers = list(range(1, n))
    while unassigned_customers:
        route = [0]
        current_capacity = 0
        while unassigned_customers:
            best_customer = -1
            best_distance = float('inf')
            for customer in unassigned_customers:
                if current_capacity + demands[customer] <= capacity:
                    dist = distance_matrix[route[-1], customer]
                    if dist < best_distance:
                        best_distance = dist
                        best_customer = customer
            if best_customer == -1:
                break
            route.append(best_customer)
            current_capacity += demands[best_customer]
            unassigned_customers.remove(best_customer)
        route.append(0)
        routes.append(route)

    for _ in range(num_iterations):
        # Choose two routes randomly
        if len(routes) < 2:
            break
        route1_idx, route2_idx = random.sample(range(len(routes)), 2)
        route1 = routes[route1_idx]
        route2 = routes[route2_idx]

        # Choose two nodes from the routes randomly
        if len(route1) < 3 or len(route2) < 3:
            continue
        node1_idx = random.randint(1, len(route1) - 2)
        node2_idx = random.randint(1, len(route2) - 2)
        node1 = route1[node1_idx]
        node2 = route2[node2_idx]

        # Swap the nodes and check capacity constraints
        new_route1 = route1[:node1_idx] + [node2] + route1[node1_idx+1:]
        new_route2 = route2[:node2_idx] + [node1] + route2[node2_idx+1:]

        capacity1 = sum(demands[c] for c in new_route1[1:-1])
        capacity2 = sum(demands[c] for c in new_route2[1:-1])

        if capacity1 <= capacity and capacity2 <= capacity:
            # Calculate the cost of the old routes
            old_cost = 0
            for i in range(len(route1) - 1):
                old_cost += distance_matrix[route1[i], route1[i+1]]
            for i in range(len(route2) - 1):
                old_cost += distance_matrix[route2[i], route2[i+1]]

            # Calculate the cost of the new routes
            new_cost = 0
            for i in range(len(new_route1) - 1):
                new_cost += distance_matrix[new_route1[i], new_route1[i+1]]
            for i in range(len(new_route2) - 1):
                new_cost += distance_matrix[new_route2[i], new_route2[i+1]]
            
            # If the new routes are better, update the routes and heuristics matrix
            if new_cost < old_cost:
                routes[route1_idx] = new_route1
                routes[route2_idx] = new_route2

                for route in [new_route1, new_route2]:
                  for i in range(len(route) - 1):
                    node1_ = route[i]
                    node2_ = route[i+1]
                    heuristics_matrix[node1_, node2_] += 1
                    heuristics_matrix[node2_, node1_] += 1

    return heuristics_matrix
