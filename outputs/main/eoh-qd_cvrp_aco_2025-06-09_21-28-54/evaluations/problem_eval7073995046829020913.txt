import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """{This algorithm uses a clustering approach to group customers, then samples routes within each cluster and aggregates edge frequencies to build the heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_clusters = int(np.sqrt(n))  # Adjust as needed
    num_samples_per_cluster = 100

    # Clustering (using k-means as a simple example, can be improved)
    from sklearn.cluster import KMeans
    kmeans = KMeans(n_clusters=num_clusters, random_state=0, n_init=10).fit(coordinates[1:]) #exclude depot when clustering
    cluster_labels = kmeans.labels_

    # Sample routes within each cluster
    for cluster_id in range(num_clusters):
        cluster_indices = [i + 1 for i, label in enumerate(cluster_labels) if label == cluster_id] #+1 because depot is excluded in the clustering step

        for _ in range(num_samples_per_cluster):
            # Include depot in the route
            route = [0] + random.sample(cluster_indices, min(len(cluster_indices), int(len(cluster_indices)))) + [0]

            # Check capacity feasibility for the cluster-based sample
            current_load = 0
            feasible = True
            current_route = []
            routes = []
            for node in route:
                if node == 0:
                    if current_load > 0:
                        routes.append(current_route)
                        current_route = []
                    current_load = 0
                    current_route.append(node)
                else:
                    if current_load + demands[node] <= capacity:
                        current_route.append(node)
                        current_load += demands[node]
                    else:
                        feasible = False
                        break
            if feasible:
                routes.append(current_route)

            if feasible: # Only update heuristics if the route segment is feasible
                for route_part in routes:
                    for i in range(len(route_part) - 1):
                        node1 = route_part[i]
                        node2 = route_part[i + 1]
                        heuristics_matrix[node1, node2] += 1
                        heuristics_matrix[node2, node1] += 1
    return heuristics_matrix
