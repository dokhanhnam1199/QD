import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses a clustering approach based on node proximity and demand to create initial routes, then refines these routes by iteratively swapping nodes between routes to improve feasibility and reduce total distance.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # 1. Clustering based on proximity and demand
    clusters = []
    remaining_nodes = list(range(1, n))
    while remaining_nodes:
        seed_node = random.choice(remaining_nodes)
        cluster = [seed_node]
        remaining_nodes.remove(seed_node)
        cluster_demand = demands[seed_node]
        
        # Add nodes to the cluster until capacity is reached or no more nodes are close
        while cluster_demand < capacity and remaining_nodes:
            nearest_node = min(remaining_nodes, key=lambda x: distance_matrix[seed_node, x])
            if cluster_demand + demands[nearest_node] <= capacity:
                cluster.append(nearest_node)
                remaining_nodes.remove(nearest_node)
                cluster_demand += demands[nearest_node]
            else:
                break
        clusters.append(cluster)
    
    # 2. Create initial routes from clusters
    routes = []
    for cluster in clusters:
        route = [0] + cluster + [0]
        routes.append(route)
    
    # 3. Iterative route refinement (node swapping)
    num_iterations = 1000
    for _ in range(num_iterations):
        # Randomly select two routes
        if len(routes) < 2:
          break
        route1_idx, route2_idx = random.sample(range(len(routes)), 2)
        route1 = routes[route1_idx]
        route2 = routes[route2_idx]
        
        # Randomly select a node from each route (excluding depot)
        if len(route1) <= 2 or len(route2) <= 2:
          continue
        node1_idx = random.randint(1, len(route1) - 2)
        node2_idx = random.randint(1, len(route2) - 2)
        node1 = route1[node1_idx]
        node2 = route2[node2_idx]
        
        # Check if swapping the nodes improves the solution
        # Calculate new route demands
        route1_demand = sum(demands[node] for node in route1[1:-1]) - demands[node1] + demands[node2]
        route2_demand = sum(demands[node] for node in route2[1:-1]) - demands[node2] + demands[node1]
        
        if route1_demand <= capacity and route2_demand <= capacity:
            # Calculate the change in distance
            old_distance = distance_matrix[route1[node1_idx-1], node1] + distance_matrix[node1, route1[node1_idx+1]] + \
                           distance_matrix[route2[node2_idx-1], node2] + distance_matrix[node2, route2[node2_idx+1]]
            new_distance = distance_matrix[route1[node1_idx-1], node2] + distance_matrix[node2, route1[node1_idx+1]] + \
                           distance_matrix[route2[node2_idx-1], node1] + distance_matrix[node1, route2[node2_idx+1]]
            
            if new_distance < old_distance:
                # Swap the nodes
                route1[node1_idx] = node2
                route2[node2_idx] = node1
                routes[route1_idx] = route1
                routes[route2_idx] = route2
    
    # 4. Update heuristics matrix
    for route in routes:
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1
            
    return heuristics_matrix
