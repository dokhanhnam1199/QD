import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm generates a population of route sets, evaluates each route set's feasibility and cost using a fitness function, and evolves the population using selection, crossover, and mutation to converge towards better solutions, using edge appearance frequencies in the best route sets to build the heuristic matrix.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros((n, n))
    population_size = 50
    num_generations = 100
    mutation_rate = 0.1

    def create_initial_population(population_size, n):
        population = []
        for _ in range(population_size):
            customer_indices = list(range(1, n))
            random.shuffle(customer_indices)

            routes = []
            current_route = [0]
            current_load = 0

            for customer in customer_indices:
                if current_load + demands[customer] <= capacity:
                    current_route.append(customer)
                    current_load += demands[customer]
                else:
                    current_route.append(0)
                    routes.append(current_route)
                    current_route = [0, customer]
                    current_load = demands[customer]

            current_route.append(0)  # Return to depot
            routes.append(current_route)
            population.append(routes)
        return population

    def calculate_fitness(routes, distance_matrix, demands, capacity):
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                total_distance += distance_matrix[route[i], route[i+1]]

        # Check feasibility
        total_demand = 0
        for route in routes:
          route_demand = 0
          for node in route:
            total_demand += demands[node]
            route_demand += demands[node]
          if route_demand > capacity and len(route) > 2:
            return float('inf')

        visited_customers = set()
        for route in routes:
            visited_customers.update(route)

        for i in range(1,n):
          if i not in visited_customers:
            return float('inf')

        return total_distance

    def selection(population, distance_matrix, demands, capacity):
        fitness_scores = [calculate_fitness(routes, distance_matrix, demands, capacity) for routes in population]
        # Normalize fitness scores to probabilities (lower fitness is better)
        fitness_scores = np.array(fitness_scores)
        fitness_scores[fitness_scores == float('inf')] = np.max(fitness_scores[fitness_scores != float('inf')]) if np.any(fitness_scores != float('inf')) else 1e9
        probabilities = np.max(fitness_scores) / (fitness_scores + 1e-6) #Avoid division by zero
        probabilities /= np.sum(probabilities)
        
        selected_indices = np.random.choice(len(population), size=population_size, replace=True, p=probabilities)
        selected_population = [population[i] for i in selected_indices]
        return selected_population

    def crossover(parent1, parent2):
        # Simple one-point crossover (for each route separately)
        child = []
        for route1, route2 in zip(parent1, parent2):
          crossover_point = random.randint(1, min(len(route1), len(route2)) - 1) if min(len(route1), len(route2)) > 1 else 1

          child_route = route1[:crossover_point] + route2[crossover_point:]
          child.append(child_route)
        return child

    def mutate(routes, demands, capacity, n):
        mutated_routes = []
        for route in routes:
            if random.random() < mutation_rate:
              if len(route) > 2:
                idx1 = random.randint(1, len(route) -2)
                idx2 = random.randint(1, len(route) -2)
                route[idx1], route[idx2] = route[idx2], route[idx1]

            mutated_routes.append(route)
        return mutated_routes

    # Genetic algorithm
    population = create_initial_population(population_size, n)
    for generation in range(num_generations):
        population = selection(population, distance_matrix, demands, capacity)

        new_population = []
        for i in range(0, population_size, 2):
            parent1 = population[i]
            parent2 = population[min(i+1, population_size-1)] #handle odd population sizes

            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)

            child1 = mutate(child1, demands, capacity, n)
            child2 = mutate(child2, demands, capacity, n)
            
            new_population.append(child1)
            new_population.append(child2)
        population = new_population[:population_size]

    # Build heuristic matrix from best solution
    best_solution = min(population, key=lambda routes: calculate_fitness(routes, distance_matrix, demands, capacity))

    for route in best_solution:
        for i in range(len(route) - 1):
            node1 = route[i]
            node2 = route[i + 1]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
