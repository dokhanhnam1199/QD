import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm estimates edge inclusion probabilities by sampling routes constructed using a nearest neighbor approach with stochastic restarts and capacity checks, penalizing exceeding capacity, and accumulating edge frequencies.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000
    alpha = 0.1

    for _ in range(num_samples):
        start_node = np.random.randint(1, n)  # Randomly select a starting customer
        route = [0, start_node]  # Start at the depot, then go to the starting customer
        current_load = demands[start_node]
        unvisited = set(range(1, n))
        unvisited.remove(start_node)
        
        while unvisited:
            last_node = route[-1]
            
            # Find nearest neighbors among unvisited nodes
            distances = [distance_matrix[last_node, node] for node in unvisited]
            nearest_neighbors = sorted(zip(unvisited, distances), key=lambda x: x[1])
            
            # Stochastic selection of next node among nearest neighbors
            num_candidates = min(5, len(nearest_neighbors)) # Consider only top 5 nearest neighbors
            candidate_neighbors = nearest_neighbors[:num_candidates]
            
            # Use probabilities to sample among candidate neighbors, giving preference to closer neighbors
            probabilities = np.array([1/(dist + 1e-6) for _, dist in candidate_neighbors]) # Inverse distance
            probabilities /= np.sum(probabilities) # Normalize probabilities
            
            next_node = np.random.choice([node for node, _ in candidate_neighbors], p=probabilities)

            if current_load + demands[next_node] <= capacity:
                route.append(next_node)
                current_load += demands[next_node]
                unvisited.remove(next_node)
            else:
                route.append(0) # Return to depot
                current_load = demands[next_node]
                route.append(next_node)
                unvisited.remove(next_node)

        route.append(0) # Return to depot

        # Calculate the cost of the route and penalty
        route_cost = 0
        penalty = 0
        valid_route = True
        current_load = 0
        
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            route_cost += distance_matrix[u, v]
            if v != 0:
              if current_load + demands[v] <= capacity:
                  current_load += demands[v]
              else:
                  valid_route = False
                  break
            else:
              current_load = 0
              

        current_load = 0
        for i in range(len(route) - 1):
          
            if route[i+1] != 0:
              if current_load + demands[route[i+1]] > capacity:
                  valid_route = False
                  break
              else:
                  current_load += demands[route[i+1]]
            else:
              current_load = 0


        if not valid_route:
          penalty = alpha * route_cost
          route_cost += penalty

        # Update heuristics matrix based on edges in the route
        for i in range(len(route) - 1):
            u = route[i]
            v = route[i+1]
            heuristics_matrix[u, v] += 1 / (route_cost + 1e-6)

    # Normalize the heuristics matrix
    heuristics_matrix = heuristics_matrix / num_samples

    return heuristics_matrix
