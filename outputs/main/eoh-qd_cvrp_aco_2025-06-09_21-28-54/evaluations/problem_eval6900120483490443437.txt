import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm uses an adaptive sampling approach, focusing on generating routes that are more likely to be feasible by biasing the route construction towards shorter edges and nodes with remaining demand, then updating a heuristic matrix based on edge frequencies in these 'promising' routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000
    alpha = 0.5  # Weight for distance in route construction probability
    beta = 0.5  # Weight for remaining demand in route construction probability

    for _ in range(num_samples):
        unvisited_nodes = list(range(1, n))
        routes = []
        current_route = [0]
        current_capacity = 0

        while unvisited_nodes:
            # Calculate probabilities for each unvisited node
            probabilities = np.zeros(len(unvisited_nodes))
            for i, node in enumerate(unvisited_nodes):
                distance_to_node = distance_matrix[current_route[-1], node]
                remaining_demand = demands[node]
                
                # Bias towards shorter distances and remaining demand (scaled to [0, 1])
                distance_score = (np.max(distance_matrix) - distance_to_node) / np.max(distance_matrix)
                demand_score = (capacity - current_capacity - remaining_demand + 1e-9) / capacity #Avoid negative scores
                probabilities[i] = (alpha * distance_score + beta * demand_score)
            
            # Normalize probabilities to sum to 1
            probabilities = probabilities / np.sum(probabilities)

            # Select the next node based on probabilities
            next_node_index = np.random.choice(len(unvisited_nodes), p=probabilities)
            next_node = unvisited_nodes[next_node_index]
            
            if current_capacity + demands[next_node] <= capacity:
                current_route.append(next_node)
                current_capacity += demands[next_node]
                unvisited_nodes.pop(next_node_index)
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0]
                current_capacity = 0

        current_route.append(0)
        routes.append(current_route)

        for route in routes:
            for i in range(len(route) - 1):
                node1 = route[i]
                node2 = route[i+1]
                heuristics_matrix[node1, node2] += 1
                heuristics_matrix[node2, node1] += 1

    return heuristics_matrix
