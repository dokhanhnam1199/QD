import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples multiple random routes, evaluates their feasibility regarding capacity constraints, and updates edge scores based on the frequency and length of feasible routes containing each edge, penalizing edges in longer routes.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))
    num_samples = 1000

    for _ in range(num_samples):
        route = list(range(1, n))
        np.random.shuffle(route)
        
        current_route = [0]
        current_demand = 0
        routes = []
        
        for node in route:
            if current_demand + demands[node] <= capacity:
                current_route.append(node)
                current_demand += demands[node]
            else:
                current_route.append(0)
                routes.append(current_route)
                current_route = [0, node]
                current_demand = demands[node]
        
        current_route.append(0)
        routes.append(current_route)

        for r in routes:
            route_length = len(r) - 1
            for i in range(len(r) - 1):
                heuristics_matrix[r[i], r[i+1]] += 1.0 / route_length
                heuristics_matrix[r[i+1], r[i]] += 1.0 / route_length
                
    return heuristics_matrix
