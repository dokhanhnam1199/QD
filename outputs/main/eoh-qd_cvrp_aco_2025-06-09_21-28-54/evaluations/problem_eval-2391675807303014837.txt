import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm samples a large number of random routes, evaluates their feasibility and cost, and aggregates edge usage frequency in feasible routes, weighting each route by the inverse of its total distance to favor shorter, feasible routes.}
    """
    n = len(demands)
    heuristics_matrix = np.zeros_like(distance_matrix)
    num_samples = 1000  # Number of random routes to sample
    
    for _ in range(num_samples):
        # Generate a random permutation of customers (excluding the depot)
        customer_permutation = list(range(1, n))
        random.shuffle(customer_permutation)
        
        # Construct routes based on capacity constraint
        routes = []
        current_route = [0]  # Start at the depot
        current_capacity = 0
        
        for customer in customer_permutation:
            if current_capacity + demands[customer] <= capacity:
                current_route.append(customer)
                current_capacity += demands[customer]
            else:
                current_route.append(0)  # Return to depot
                routes.append(current_route)
                current_route = [0, customer]  # Start a new route
                current_capacity = demands[customer]
                
        current_route.append(0)  # Close the last route
        routes.append(current_route)
        
        # Check feasibility (all customers visited) - optional, but good practice
        visited_customers = set()
        for route in routes:
            for customer in route:
                if customer != 0:
                    visited_customers.add(customer)
        if len(visited_customers) != n - 1: #exclude depot
           continue # if route not feasible, skip this round

        # Calculate the total distance of the routes
        total_distance = 0
        for route in routes:
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i+1]
                total_distance += distance_matrix[u, v]
        
        #Weight the routes
        weight = 1.0/total_distance if total_distance >0 else 0

        # Update heuristics matrix: Increment count for edges in feasible routes
        for route in routes:
            for i in range(len(route) - 1):
                u = route[i]
                v = route[i+1]
                heuristics_matrix[u, v] += weight
                heuristics_matrix[v, u] += weight  # Since it's an undirected graph
                
    return heuristics_matrix
