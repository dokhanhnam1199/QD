import numpy as np
import random

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm iteratively refines a heuristic matrix by generating routes biased towards edges with high heuristic values and low distances, while penalizing infeasible routes based on capacity violations.}
    """
    n = len(demands)
    heuristics_matrix = np.ones((n, n))  # Initialize with ones to avoid division by zero
    alpha = 0.1 #weight to keep history and discover new routes
    beta = 0.5 #weight balance between heuristic value and distance
    num_iterations = 100

    for _ in range(num_iterations):
        routes = []
        remaining_customers = set(range(1, n))
        while remaining_customers:
            current_route = [0]
            current_load = 0
            current_node = 0
            
            while True:
                # Select the next customer based on heuristic value and distance
                feasible_neighbors = []
                for neighbor in remaining_customers:
                    if current_load + demands[neighbor] <= capacity:
                        feasible_neighbors.append(neighbor)
                
                if not feasible_neighbors:
                    break
                
                probabilities = []
                total_prob = 0
                for neighbor in feasible_neighbors:
                    heuristic_val = heuristics_matrix[current_node, neighbor]
                    distance = distance_matrix[current_node, neighbor]
                    prob = (heuristic_val**beta) / (distance**(1-beta)+ 1e-9) #Small value to avoid division by zero
                    total_prob += prob
                    probabilities.append(prob)
                
                probabilities = [p / total_prob for p in probabilities]
                
                next_customer = random.choices(feasible_neighbors, weights=probabilities)[0]
                
                current_route.append(next_customer)
                current_load += demands[next_customer]
                remaining_customers.remove(next_customer)
                current_node = next_customer
            
            current_route.append(0)
            routes.append(current_route)

            # Update heuristic matrix: reward edges in the route
            for route in routes:
              for i in range(len(route) - 1):
                  node1 = route[i]
                  node2 = route[i+1]
                  heuristics_matrix[node1, node2] = (1-alpha) * heuristics_matrix[node1, node2] + alpha *10 # Reward. The 10 is an arbitrary constant
                  heuristics_matrix[node2, node1] = (1-alpha) * heuristics_matrix[node2, node1] + alpha * 10

    return heuristics_matrix
