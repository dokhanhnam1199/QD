import numpy as np

def heuristics_v2(distance_matrix, coordinates, demands, capacity):
    """
    {This algorithm constructs a heuristic matrix by sampling random route segments, evaluating their efficiency based on distance and capacity, and updating edge scores using a weighted average of segment efficiencies.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000
    segment_length = 5  # Length of route segments to sample

    for _ in range(num_samples):
        # Generate a random starting node (excluding depot for segment start)
        start_node = np.random.randint(1, n)
        
        # Generate a random route segment starting from start_node
        segment = [start_node]
        current_demand = demands[start_node]
        
        for _ in range(segment_length - 1):
            # Find feasible neighbors (within capacity if added to segment)
            feasible_neighbors = [
                node for node in range(1, n)
                if node not in segment and current_demand + demands[node] <= capacity
            ]
            
            if not feasible_neighbors:
                break  # No more feasible neighbors, end the segment
            
            # Choose a random feasible neighbor
            next_node = np.random.choice(feasible_neighbors)
            segment.append(next_node)
            current_demand += demands[next_node]
        
        # Evaluate the segment's efficiency
        segment_length_actual = len(segment)
        if segment_length_actual > 1:
            segment_distance = 0
            for i in range(segment_length_actual - 1):
                segment_distance += distance_matrix[segment[i], segment[i+1]]
            
            # Calculate efficiency score (higher is better)
            efficiency = (current_demand / capacity) / (segment_distance + 1e-6)  # Add a small value to avoid division by zero

            # Update heuristics matrix based on segment efficiency
            for i in range(segment_length_actual - 1):
                heuristics_matrix[segment[i], segment[i+1]] += efficiency
                heuristics_matrix[segment[i+1], segment[i]] += efficiency

    return heuristics_matrix
