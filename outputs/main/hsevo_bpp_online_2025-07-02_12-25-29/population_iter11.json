[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins, combining close fit, target fill, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close Fit Priority\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities[feasible_bins] += close_fit_reward[feasible_bins]\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(feasible_bins & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Fragmentation penalty\n    small_capacity_threshold = 0.1\n    valid_indices = (remaining_after_fit > 0) & feasible_bins\n    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    fragmentation_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= fragmentation_penalty[valid_indices]*0.5\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity and filling target.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n    remaining_after_fit = feasible_bins - item\n\n    # Close fit bonus\n    priorities[feasible_indices] += np.exp(-2 * np.abs(remaining_after_fit))\n\n    # Filling target bonus (0.75 of bin capacity)\n    filling_threshold = 0.75\n    fill_level = 1 - remaining_after_fit\n    threshold_bonus = np.where(fill_level >= filling_threshold, 0.5, 0.0)\n    priorities[feasible_indices] += threshold_bonus\n\n    # Fragmentation penalty\n    frag_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0)\n    priorities[feasible_indices] += frag_penalty\n    priorities = np.maximum(priorities, 0) # Ensure non-negative\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close-to-full, reasonable fit, and size difference.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.\")\n\n    if not np.any(item_fits):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 2.0 * nearly_full\n\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n    \n    priorities[bins_remain_cap < item] = -1e9\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.108496210610296,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill, with early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close fit priority (higher is better)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)  # Tuned exponent\n\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.56) # Assuming bin capacity 1.56\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) # Tuned exponent\n\n    priorities += 0.5 * target_bonus * feasible_bins #Tunned weight\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best fit, filling threshold, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Best Fit\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Filling Threshold\n    filling_threshold = 0.75\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level_after_fit >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Fragmentation Avoidance\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold), -0.2, 0.0)\n    priorities += fragmentation_penalty\n\n    priorities[bins_remain_cap < item] = 0.0\n    priorities = np.maximum(priorities, 0.0)\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fit, target fullness, and wasted space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    target_remaining = 0.1 # Target remaining capacity after packing\n\n    # Bonus for bins meeting target fullness\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - target_remaining))\n    priorities += almost_full_bonus * feasible_bins\n\n    # Close fit priority with wasted space penalty\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    wasted_space_penalty = np.exp(10* remaining_after_fit) # Penalize bins with small remaining capacity\n    priorities += close_fit_priority * feasible_bins - 0.1* wasted_space_penalty*feasible_bins\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best fit, filling threshold, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    best_fit_priority = np.exp(-5 * np.abs(remaining_after_fit)) * item_fits\n    priorities += best_fit_priority\n\n    filling_threshold = 0.75\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level_after_fit >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold), -0.25, 0.0)\n    priorities += fragmentation_penalty\n\n    priorities[bins_remain_cap < item] = 0.0\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit, bin utilization and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n\n    # Tight fit reward\n    remaining_capacity_priority = np.exp(-np.abs(feasible_bins - item))\n    priorities[feasible_indices] += remaining_capacity_priority\n\n    # Bin utilization reward\n    bin_utilization = 1 - (feasible_bins / np.max(bins_remain_cap))\n    priorities[feasible_indices] += 0.5 * bin_utilization\n\n    # Fragmentation penalty\n    remaining_after_fit = feasible_bins - item\n    fragmentation_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0)\n    priorities[feasible_indices] += fragmentation_penalty\n\n    priorities = np.maximum(priorities, 0)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]