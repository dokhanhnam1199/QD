{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small negative value to avoid selecting infeasible bins.\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Find feasible bins (bins with enough remaining capacity).\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all remain -inf\n\n    # Calculate the wasted space after placing the item in each feasible bin.\n    wasted_space = bins_remain_cap[feasible_bins] - item\n\n    # Prioritize bins with less wasted space (First-Fit Decreasing-like behavior).\n    # But also add a slight preference for bins that are already somewhat full (to encourage packing).\n    fullness_factor = bins_remain_cap[feasible_bins] / np.sum(bins_remain_cap)\n\n    priorities[feasible_bins] = -wasted_space + 0.1 * fullness_factor # Trade-off between wasted space and already-filled bins\n\n    # Add a bonus for bins that would become exactly full after adding the item\n    exact_fit = wasted_space == 0\n    priorities[feasible_bins][exact_fit] += 1.0 # large number to prefer perfect fit\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics:\n    1. Reward bins that can *almost* perfectly fit the item (minimize wasted space).\n    2. Penalize bins that would become nearly full (risk of wasted capacity).\n    3. Exclude bins that cannot accommodate the item.\n    4. Add a small randomness for exploration\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exclude bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were added to each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf #effectively exclude those bins\n\n    # Reward bins with small wasted space (close fit)\n    close_fit_reward = np.exp(-wasted_space) # Exponential decay. Closer fit is exponentially better\n\n    # Penalize bins that become nearly full after adding the item\n    nearly_full_penalty = np.exp( - 1 / (wasted_space + 1e-9))  # Avoid division by zero\n\n    # Combine reward and penalty\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Add small randomness for exploration (Gaussian noise)\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape) #consider making magnitude of noise item-size dependent.\n    priorities += noise\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses exponential decay to prioritize bins based on how closely they fit the item and how full they would become after adding the item, while the worst heuristic aims for a target fill ratio of 0.7 and adds penalties based on median capacity and excessive remaining capacity. The best also considers fragmentation, unlike the worst.\n\nComparing (2nd best) vs (second worst), we see similar approaches to the (best) vs (worst) comparison. The second-best heuristic also considers space utilization and fragmentation, using exponential decay to prioritize bins. The second worst prioritizes bins with higher remaining capacity if no bins can fit the item, and then goes on to use a target fill ratio, penalizing deviations from it.\n\nComparing (1st) vs (2nd), they are exactly identical, meaning that small variations elsewhere must influence performance.\n\nComparing (3rd) vs (4th), the 3rd uses wasted space and a fullness factor, and provides a bonus for exact fits, while the 4th uses a \"quantum action\" inspired approach, normalizing amplitudes based on wasted space to assign priorities. 3rd uses a simpler trade-off between wasted space and fullness.\n\nComparing (second worst) vs (worst), we see penalization for exceeding a proportion of item capacity.\n\nOverall: Better heuristics use a combination of rewards and penalties, focusing on minimizing wasted space and fragmentation. Exponential decay functions seem effective for prioritizing bins based on fit and fullness. Avoiding target fill ratios and directly considering wasted space seems beneficial. More successful heuristics also often have negative infinity to avoid picking the invalid bins.\nSimpler approaches with clearly defined rewards and penalties seem to outperform those inspired by more complex physical analogies.\n- \nOkay, here's a refined definition of \"Current self-reflection\" to guide heuristic design, focusing on effectiveness:\n\n*   **Keywords:** Objective-alignment, iterative refinement, evaluation, interpretable rules, reward/penalty system, constraint handling.\n\n*   **Advice:** Explicitly link heuristic components to specific objectives. Measure the impact of each design choice on performance and interpretability. Prioritize constraint satisfaction.\n\n*   **Avoid:** Premature complexity, uninterpretable rules, neglecting objective alignment, insufficient evaluation.\n\n*   **Explanation:** Focus on creating heuristics that directly optimize the target objective, adding complexity only when demonstrably beneficial and always evaluating their impact. Consider constraints early.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}