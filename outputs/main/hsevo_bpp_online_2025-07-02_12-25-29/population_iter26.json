[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and bin pressure.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Perfect fit bonus\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1.0\n        return priorities\n    \n    # Close fit bonus\n    fit_difference = np.abs(bins_remain_cap - item)\n    proximity_priority = np.exp(-5 * (fit_difference / bin_capacity)**2) * item_fits\n    priorities += proximity_priority\n    \n    # Target fill bonus: target around 75%\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.5 * target_bonus\n    \n    # Bin selection pressure bonus: favour bins almost full\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.5\n    priorities += bin_pressure_bonus\n\n    # If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    # Normalize priorities\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n    \n    # Waste penalty, similar to v0\n    remaining_after_fit = bins_remain_cap - item\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities += waste_penalty\n    \n    # Target fill bonus, similar to v1\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.7 * target_bonus * item_fits\n\n    # Desperation strategy, if no bin fits\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, and target utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit gives immediate high priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n    \n    # Close fit bonus\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n    \n    # Target utilization bonus\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n    \n    # If no bin can fit item, return a array of -infinity\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf)\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill level.\"\"\"\n    bin_capacity = 1.0\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return -np.ones_like(bins_remain_cap) * 1e9\n    \n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.9\n\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n\n    # Normalize priorities\n    close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n    fill_priority = fill_priority / np.max(fill_priority, initial=1e-9)\n    \n    priorities = 0.6 * close_fit_priority + 0.4 * fill_priority\n    \n    priorities[~item_fits] = -1e9\n\n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n    \n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: close fit, target fill, and bin pressure.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    # 1. Close Fit Priority: Exponentially favor bins close to item size.\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # 2. Target Fill Bonus: Reward bins approaching a target fill level.\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.5*target_bonus\n\n    # 3. Bin Selection Pressure: Encourage filling existing bins.\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.3\n    priorities += bin_pressure_bonus\n\n\n    # 4.  Slight bonus for non-empty bins\n    non_empty_bonus = np.where(bins_remain_cap < bin_capacity, 0.1, 0.0) * item_fits\n    priorities += non_empty_bonus\n\n\n    # No fit handling : Put item into the bin with largest remain capcity.\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmax(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # High priority for perfect fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Prioritize bins where the item fits initially\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus with exponential decay\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n\n    # Minimize wasted space by penalizing larger gaps, exponentially\n    wasted_space = np.abs(remaining_after_fit) * item_fits\n    wasted_space_penalty = np.exp(-5 * wasted_space) * item_fits\n    priorities += wasted_space_penalty\n\n    # Add a small bonus for bins which are larger than the item\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    \n    priorities[~item_fits] = -1e9  # Very low priority if item doesn't fit\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    \n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    \n\n    # Normalize priorities\n    if np.any(item_fits):\n        close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n        fill_priority = fill_priority / np.max(fill_priority, initial=1e-9)\n\n    priorities = 0.6 * close_fit_priority + 0.4 * fill_priority\n\n    priorities[~item_fits] = -1e9\n    \n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n        return priorities\n    \n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Waste minimization priority\n    remaining_after_fit = bins_remain_cap - item\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities = waste_penalty\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.7 * target_bonus\n\n    # No-fit handling: put in smallest bin\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines proximity to item size, filling threshold, and bin pressure.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Proximity to item size\n    fit_difference = bins_remain_cap - item\n    proximity_priority = np.exp(-5 * (fit_difference)**2) * item_fits\n    priorities += proximity_priority\n\n    # Filling Threshold\n    filling_threshold = 0.8\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.75, 0.0)\n    priorities += threshold_bonus\n\n    # Bin Selection Pressure\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.5\n    priorities += bin_pressure_bonus\n\n    # Ensure zero priority if item doesn't fit\n    priorities[bins_remain_cap < item] = 0.0\n    \n    # Small preference for non-empty bins\n    non_empty_bonus = np.where(bins_remain_cap < bin_capacity, 0.1, 0.0) * item_fits\n    priorities += non_empty_bonus\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # No fit: put in smallest bin\n    if not np.any(item_fits):\n        priorities[:] = -1e9 #make all bins have very low priority\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Cost function based on remaining capacity: penalize wasted space\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities += waste_penalty\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority * 0.5 # lower weight target fill\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]