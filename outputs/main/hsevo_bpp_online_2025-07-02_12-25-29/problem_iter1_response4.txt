```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Uses a heuristic that considers both the remaining capacity and the item size,
    favoring bins that can accommodate the item with minimal wasted space, but also
    penalizing bins that are already close to full (to avoid creating overly fragmented bins).
    A tesla-inspired touch involves considering "resonance" - when the item size aligns
    well with a certain fraction of the bin capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Very small bins (smaller than item size) should get extremely low priority
    priorities[bins_remain_cap < item] = -np.inf

    # Reward bins that can fit the item
    fit_mask = bins_remain_cap >= item
    remaining_space = bins_remain_cap[fit_mask] - item
    
    # Prioritize bins with smaller wasted space, but add some noise
    # This is the core heuristic: smaller remainder is better
    priorities[fit_mask] = -remaining_space + np.random.normal(0, 0.01, size=remaining_space.shape)  # Add a touch of randomness

    # Add a penalty for bins that are nearly full.
    fullness_ratio = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize to range [0,1] representing fullness. bins_remain_cap must be non-negative
    priorities -= (fullness_ratio**3) * 0.5 # Cubing it allows small values to not contribute much, and prioritizes high fullness penalty
    

    # "Resonance" effect (Tesla inspired):
    # Favor bins where the item size is a multiple of some "fundamental frequency" of the bin
    # This is a highly speculative addition to improve the quality of the fit, but not necessarily time efficent
    resonance_strength = 0.1 # Can be tuned based on experiment
    for i in range(len(bins_remain_cap)):
      if bins_remain_cap[i] >= item:
            if item > 0:
                fundamental_frequency = bins_remain_cap[i] / 2
                resonance_factor = np.exp(-((item % fundamental_frequency)**2) / (2 * (fundamental_frequency/5)**2) ) # Gaussian curve that peaks at 0

                priorities[i] += resonance_strength * resonance_factor # Adding to priority of current bin
    return priorities
```
