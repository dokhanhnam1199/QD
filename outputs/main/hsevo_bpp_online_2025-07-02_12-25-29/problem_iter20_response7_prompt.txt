{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n    \n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation strategy\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on close fit, target fill, and early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # Early exit: If there's a bin that fits the item perfectly, prioritize it highly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0  # High priority for perfect fit\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.0) #scale remaining capacity to 0-1\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n\n    priorities += 0.5 * target_bonus * feasible_bins\n\n    # Moderate penalty for leaving too much space\n    bin_capacity = 1.0\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * feasible_bins\n    priorities += space_left_penalty\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that the 1st prioritizes bins based on space utilization, fragmentation and filling threshold. The 2nd prioritizes bins based on close fit, filling and avoids fragmentation. However, the 2nd has an early exit for perfect fit. The 2nd also has a penalty for leaving large remaining space.\n\nComparing (3rd) vs (4th), they are identical.\n\nComparing (5th) vs (6th), they are identical.\n\nComparing (7th) vs (8th), we see that the 7th prioritizes bins based on fill target, fit and fragmentation with early exits and the 8th prioritizes bins based on whether the item fits, remaining capacity, filling threshold and penalizing bins that are already too full.\n\nComparing (9th) vs (10th), we see that the 9th prioritizes bins based on close fit, target fill and avoids fragmentation and takes `bin_capacity` as an argument and the 10th combines target fill, close fit and handles edge cases.\n\nComparing (11th) vs (12th), we see that the 11th prioritizes bins that results in a fill level closest to a target and the 12th prioritizes bins based on a combination of factors like ability to fit item, target fill level, avoiding excessive fragmentation and a tie-breaker for the fullest bin so far.\n\nComparing (13th) vs (14th), we see that the 13th prioritizes bins considering close fit, target fill, and fragmentation with early exit with adjusted penalties. The 14th prioritizes bins based on a combination of factors like ability to fit item, target fill level, avoiding excessive fragmentation and a tie-breaker for the fullest bin so far.\n\nComparing (15th, 16th, 17th, 18th) they only implement early exit of perfect fit.\nComparing (19th) vs (20th), they are identical.\n\nOverall: The better heuristics tend to consider more factors such as fragmentation, target fill level, and close fit. They also implement early exits for perfect fit scenarios and handle edge cases where no bins can fit the item. Penalties for large remaining space and small remaining space after fit are also important.\n- \nOkay, let's redefine \"Current self-reflection\" to make it more effective for designing bin packing heuristics. We'll focus on actionable insights and avoid the pitfalls of the \"Ineffective self-reflection\" examples.\n\nHere's a refined version:\n\n*   **Keywords:** Directness, combination, normalization, exploration, clear objectives, gradual refinement.\n\n*   **Advice:** Prioritize direct combinations of closeness-of-fit and fullness. Use normalization to balance different criteria and facilitate exploration of the design space. Handle edge cases explicitly (e.g., no fit bins).\n\n*   **Avoid:** Multiplicative combinations, premature complexity, relying solely on randomness, neglecting the optimization objective.\n\n*   **Explanation:** Design heuristics that are both clear and effective. Begin with a simple core and add complexity cautiously. Ensure factors like fill level and fit contribute directly to the optimization goal, and normalize priorities across different factors.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}