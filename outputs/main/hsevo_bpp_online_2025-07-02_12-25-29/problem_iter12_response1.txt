```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that minimize wasted space and balance bin utilization.
    It focuses on finding the closest fit and discourages excessive fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item fits
    item_fits = bins_remain_cap >= item
    
    # Calculate remaining capacity after adding the item
    remaining_after_fit = bins_remain_cap - item
    remaining_after_fit[~item_fits] = np.inf # set to infinity if item does not fit so that they are not selected.
    
    # Prioritize bins with minimal wasted space (closest fit). Use inverse of remaining space.
    # Avoid division by zero by adding a small epsilon
    epsilon = 1e-6
    priorities = 1.0 / (remaining_after_fit + epsilon)
    
    # Scale priorities for better performance
    priorities = priorities * item_fits # only if the item fits
    
    # Further reward bins that result in a higher fill level (e.g., > 60%)
    fill_level = 1.0 - (remaining_after_fit / 1.0) # assuming bin capacity is 1.0
    high_fill_bonus = np.where(item_fits & (fill_level > 0.6), 0.5, 0.0)
    priorities += high_fill_bonus

    return priorities
```
