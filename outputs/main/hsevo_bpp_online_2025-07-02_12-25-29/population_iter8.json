[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines filling threshold, close fit, and wasted space considerations.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    filling_threshold = 0.75\n    bin_capacity = 1.0\n\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = 0  # Set priority to 0 rather than -inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, utilization, fragmentation, and validation for bin selection.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility Handling:\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities # No feasible bins, return zero priorities\n\n    # 1. Close Fit Priority:\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)\n    priorities += fragmentation_penalty\n\n    # Apply mask AFTER calculating other priorities to avoid influencing calculations\n    priorities[~feasible_bins] = 0\n\n    # Scaling to rank feasible bins, avoid division by zero\n    priorities[feasible_bins] *= (bins_remain_cap[feasible_bins] - item + 1e-9) / (bins_remain_cap[feasible_bins] + 1e-9)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.9760670123653865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fit, fullness, and bin utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = 0\n\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.5 * bin_utilization\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities considering fit, fill threshold, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get zero priority\n    item_fits = bins_remain_cap >= item\n    priorities[~item_fits] = 0.0\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Close fit reward\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward * item_fits\n\n    # Fragmentation penalty: Avoid small remaining capacities\n    small_capacity_threshold = 0.1\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_indices = (remaining_after_fit > 0) & item_fits\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    # Small bonus to larger bins that can fit the item\n    larger_bins_bonus = item_fits * 0.1\n    priorities += larger_bins_bonus\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.078579976067022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Combines filling threshold, close fit, and avoids fragmentation.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    priorities[bins_remain_cap < item] = 0\n\n    small_remaining = remaining_after_fit < 0.1\n    priorities[item_fits & small_remaining] -= 0.5\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, fullness, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority (sharper decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)\n    priorities[~possible_bins] = 0  # Infeasible bins get zero priority\n\n    # Fullness reward (sharper decay)\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Already Occupied preference (reduced coefficient)\n    already_occupied = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.5 * already_occupied\n\n    # Fragmentation penalty (fragments smaller than 0.1)\n    small_fragment_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_fragment_indices = np.where((bins_remain_cap >= item) & (remaining_after_fit > 0) & (remaining_after_fit < 0.1))\n    small_fragment_penalty[small_fragment_indices] = -1\n    priorities += small_fragment_penalty\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on closeness of fit and utilization.\n    Addresses infeasibility and potential division-by-zero errors.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # 1. Closeness of fit\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit_diff)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. High Utilization\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # 3. Scale based on remaining capacity after fit\n    priorities[bins_remain_cap >= item] *= (bins_remain_cap[bins_remain_cap >= item] - item + 0.0001) / (bins_remain_cap[bins_remain_cap >= item] + 0.0001)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.656960510570408,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering filling threshold, close fit, and error handling.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    priorities[bins_remain_cap < item] = 0\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n    \n    # Penalize bins that would leave a very small remaining capacity (fragmentation)\n    small_remaining = remaining_after_fit < 0.1\n    priorities[item_fits & small_remaining] -= 0.25 \n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines filling threshold and close-fit reward for bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get zero priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = 0\n\n    # Close-fit reward using exponential decay\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n    close_fit_reward = np.exp(-5*np.abs(wasted_space))\n    priorities += close_fit_reward * (bins_remain_cap >= item)\n\n    # Filling threshold bonus.\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where((bins_remain_cap >= item) & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n    \n    # Small bonus for larger bins that fit item.\n    larger_bins = bins_remain_cap >= item\n    priorities += 0.1 * larger_bins\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit, fullness, and a target fullness, robustly.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Infeasible bins get -inf\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = np.exp(-close_fit)\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Bonus for bins close to a target fullness after placement\n    target_remaining = 0.1\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - target_remaining))\n    priorities[feasible_bins] += almost_full_bonus * 0.5\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]