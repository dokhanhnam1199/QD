{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines filling threshold, close fit, and wasted space considerations.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    filling_threshold = 0.75\n    bin_capacity = 1.0\n\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = 0  # Set priority to 0 rather than -inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Best Fit: Prioritizes bins with the smallest remaining capacity after adding the item.\n    2.  Filling Threshold: Provides a bonus for bins that reach a desired fill level.\n    3.  Avoidance of Fragmentation: Discourages placing items in bins where it leaves\n        a small unused space.\n    4. Prevents selecting Infeasible bins.\n    5. Validates feasibility during runtime.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n\n    # Feasibility check: Ensure item fits in the bin\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return all zeros immediately\n    if not np.any(item_fits):\n        return priorities\n    \n    # Best Fit Priority: reward small remaining capacity.\n    remaining_after_fit = bins_remain_cap - item\n    best_fit_priority = np.where(item_fits, bin_capacity - remaining_after_fit, 0.0)  # Use remaining capacity directly\n    priorities += best_fit_priority\n\n    # Filling Threshold Priority: reward bins close to full.\n    filling_threshold = 0.75\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level_after_fit >= filling_threshold), 0.5, 0.0)  # Scale the bonus\n    priorities += threshold_bonus\n\n    # Fragmentation Avoidance: Penality for leaving tiny gaps.\n    fragmentation_threshold = 0.1  # Tune this parameter\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold), -0.2, 0.0)  # Penalize, but not too harshly\n    priorities += fragmentation_penalty\n\n    # Infeasible Bin Handling: Explicitly set priority to zero\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Validation: Check for negative priorities and cap at zero. (defensive programming)\n    priorities = np.maximum(priorities, 0.0)\n    \n    # Final Scaling: Ensure meaningful values\n    priorities = priorities/np.max(priorities) if np.max(priorities) > 0 else priorities # Scale between zero and one.\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first incorporates a target fill level, nearly empty penalty, and nearly full bonus, while the last emphasizes close fit, utilization, and fragmentation. (2nd best) vs (second worst) reveal similar trends, with (2nd best) emphasizing filling threshold and close fit with wasted space considerations and (second worst) focusing on closeness of fit and utilization, but lacking specific target or penalties/bonuses. Comparing (1st) vs (2nd), we see (1st) validates if the item fits first and returns early if not, while the (2nd) calculates before checking. (3rd) vs (4th) shows (3rd) has a penalty for small remaining capacity and (4th) parameterizes filling threshold and other parameters. Comparing (second worst) vs (worst), we see (second worst) calculates fragmentation before masking infeasible bins, while (worst) calculates fragmentation and then masks, and it also includes scaling. Overall: The better heuristics incorporate a wider range of factors and explicit checks, whereas the worse ones focus on fewer aspects and may lack robustness. The best ones also tend to validate the input early on and return early.\n- \nOkay, I'm ready to help you earn that tip! Let's redefine \"Current Self-Reflection\" for better heuristic design, focusing on effectiveness and avoiding common pitfalls.\n\n*   **Keywords:** Objective-driven, validation, additive penalties/bonuses, incremental complexity.\n\n*   **Advice:** Design heuristics from the objective function *outward*. Prioritize validated inputs and outputs at each stage. Use additive (linear) combinations of rewards/penalties for desired/undesired outcomes. Introduce complexity *incrementally*, carefully measuring each addition's impact on solution quality and runtime.\n\n*   **Avoid:** Premature parameterization, complex multiplicative combinations, and unchecked randomness without clear justification.\n\n*   **Explanation:** Focus on directly addressing the optimization goal with simple, verifiable steps. Parameterization without a strong justification, complex multiplicative rules, and randomness can obscure the heuristic's behavior, making it harder to understand, debug, and improve. Build from a simple base, validating each addition.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}