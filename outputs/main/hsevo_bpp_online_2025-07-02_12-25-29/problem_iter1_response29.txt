```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Heuristic 1: Prefer bins where the item fits (First Fit Decreasing inspired)
    fits = bins_remain_cap >= item
    priorities[fits] += 1.0

    # Heuristic 2: Favor bins that would be filled relatively more completely.
    #  A higher completion ratio is desired, but avoid filling up the bin entirely.
    completion_ratio = item / bins_remain_cap
    valid_completion = (completion_ratio > 0) & (completion_ratio <= 1.0)  # Check that the item can be accomodated and does not overfill
    priorities[valid_completion] += completion_ratio[valid_completion] * 2 # Scaling factor to give emphasis
    #Heuristic 3: Penalize bins which can barely fit, encourage full-ish usage
    nearly_full = (bins_remain_cap - item) < (0.1 * item)  # Less than 10% of item size is remaining. Arbitrary choice for demonstration.
    priorities[nearly_full] -= 0.5

    #Heuristic 4: If bin is empty, it may be suitable but only if item is significantly large
    empty_bins = bins_remain_cap == bins_remain_cap.max()
    large_item = item > 0.5 * bins_remain_cap.max()  # Significant large item
    if large_item:
        priorities[empty_bins] += 0.75 # Add moderate priority to new bin if there is large item
    return priorities
```
