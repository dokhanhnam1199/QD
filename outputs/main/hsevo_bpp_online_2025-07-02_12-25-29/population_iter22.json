[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1e9  # Max priority for perfect fit\n        return priorities\n\n    # Close fit bonus (higher priority for less waste)\n    close_fit_priority = np.exp(-2 * (bins_remain_cap - item)) * item_fits\n\n    # Target fill bonus (reward bins close to full after packing)\n    fill_threshold = 0.9\n    nearly_full_bonus = np.where(item_fits & (1 - remaining_after_fit/bin_capacity >= fill_threshold), 0.5, 0)\n\n    # Fragmentation penalty (avoid small remaining space)\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity <= fragmentation_threshold), -0.25, 0)\n\n    # Combine all factors, normalizing the close fit.\n    priorities = close_fit_priority + nearly_full_bonus + fragmentation_penalty\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill and close fit, with fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0 # Assume bin capacity is 1\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits): # Handle edge case: item doesn't fit in any bin\n        priorities[:] = -1e9 # Very low priority\n        priorities[np.argmin(bins_remain_cap)] = 0  # Put in the least full bin if it doesn't fit\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits #Target fill.\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits  # Close fit\n\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit < fragmentation_threshold), -0.3, 0.0)\n\n    priorities = fill_level_priority + close_fit_priority + fragmentation_penalty #Sum up the priorities\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, close fit, and avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_fill_level = 0.9\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target Fill Priority\n    fill_level_diff = np.abs(fill_level - target_fill_level)\n    fill_priority = np.exp(-5 * fill_level_diff) * item_fits\n    priorities += fill_priority\n\n    # Close Fit Priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    priorities[bins_remain_cap < item] = 0  # Infeasible bins\n\n    # Fragmentation Penalty\n    priorities -= 0.1 * bins_remain_cap * item_fits\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill priority\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / bin_capacity)\n    target_fill = 0.9\n    target_bonus = np.exp(-5.0 * np.abs(fill_level - target_fill))\n    priorities += 0.7 * target_bonus * feasible_bins\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and fragmentation avoidance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # No fit: put in smallest bin\n    if not np.any(item_fits):\n        priorities[np.argmin(bins_remain_cap)] = 0.1\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill target, close fit, avoids fragmentation, normalizes.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    item_fits = bins_remain_cap >= item\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.8, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Penalize bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0\n\n    # Normalize priorities.  Important for balancing factors.\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n    min_remaining_cap = 0.05\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 2.0  # High priority for perfect fit\n        return priorities\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n\n    # Penalize small remaining capacity\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -1.0, 0.0)\n    priorities += low_capacity_penalty\n\n    filling_incentive = (1 - remaining_after_fit) * item_fits * 0.2\n    priorities += filling_incentive\n\n    # If no bin can fit item, return a array of -infinity\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 7,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining close fit, target fill, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    priorities[~item_fits] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    priorities += fill_priority\n\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    small_space_penalty = np.where((remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.5, 0)\n    priorities += small_space_penalty * item_fits\n\n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n        return priorities\n    \n    if np.max(priorities) == np.min(priorities):\n        return priorities\n\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 0.1  # Small bonus for fitting\n\n    # Avoid bins with less than 5% capacity remaining\n    min_remaining_cap = 0.05\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -0.2, 0.0)\n    priorities += low_capacity_penalty * item_fits\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill target and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    if not np.any(item_fits):\n        return priorities\n\n    # Target Fill Level\n    target_fill = 0.9\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    deviation_from_target = np.abs(fill_level_after_fit - target_fill)\n    priorities += np.exp(-5 * deviation_from_target) * item_fits\n\n    # Fragmentation Penalty\n    fragmentation_penalty = np.exp(-2 * remaining_after_fit) * item_fits\n    priorities += fragmentation_penalty\n\n    # Fullest bin tie-breaker\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.1 * current_fill_level * item_fits\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1.0\n        return priorities\n    \n    priorities[bins_remain_cap < item] = 0.0\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version combines closeness-of-fit and fullness after packing, with normalization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Closeness-of-fit priority (normalized)\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    \n    # Fullness after packing priority (normalized)\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    fullness_priority = fill_level * item_fits\n\n    # Combine and normalize the priorities\n    combined_priority = close_fit_priority + fullness_priority\n    \n    # Normalize priorities to a 0-1 range to avoid domination by either factor.\n    max_priority = np.max(combined_priority)\n    if max_priority > 0:\n        normalized_priority = combined_priority / max_priority\n    else:\n        normalized_priority = combined_priority # All zeros, no normalization needed\n    \n    priorities = normalized_priority\n\n    # Penalize bins where the item doesn't fit by assigning zero priority\n    priorities[bins_remain_cap < item] = 0.0\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response1.txt_stdout.txt",
    "code_path": "problem_iter21_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version focuses on a normalized combination of fill level and closeness-of-fit,\n    explicitly handling edge cases and prioritizing a simple, direct approach.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Calculate fill level after adding the item (only for bins where it fits)\n    fill_level = np.where(item_fits, (bin_capacity - remaining_after_fit) / bin_capacity, 0.0)\n\n    # Normalize fill level\n    normalized_fill = fill_level  # Already between 0 and 1\n\n    # Closeness-of-fit priority (only for bins where it fits)\n    close_fit = np.abs(bins_remain_cap - item)\n    normalized_close_fit = np.where(item_fits, np.exp(-5 * close_fit), 0.0)  # Exponential decay\n\n    # Combine fill level and closeness-of-fit (only for bins where it fits)\n    priorities = normalized_fill + normalized_close_fit\n\n    # Ensure bins where the item doesn't fit have zero priority\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Small bias toward using any available space when possible\n    priorities = np.where(item_fits, priorities + 0.01, priorities)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version combines closeness-of-fit and fullness, with normalization\n    to balance the factors. It focuses on bins where the item fits and\n    prioritizes those that result in high fill levels or close-to-perfect fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Closeness-of-fit priority (normalized)\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9) # Normalize\n\n    # Fullness priority (normalized) - prioritize higher fill levels\n    fullness_priority = fill_level * item_fits\n    fullness_priority = fullness_priority / np.max(fullness_priority, initial=1e-9) # Normalize\n\n    # Combine priorities (direct combination)\n    priorities = 0.6 * close_fit_priority + 0.4 * fullness_priority  # Weighted average\n\n    # Ensure bins where item doesn't fit have zero priority\n    priorities[bins_remain_cap < item] = 0\n\n    # Small bonus for using any available space\n    priorities[item_fits] += 0.05\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response3.txt_stdout.txt",
    "code_path": "problem_iter21_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version combines closeness-of-fit and fullness with normalization.\n    It prioritizes bins where the item fits, aiming for optimal fill levels,\n    while explicitly handling edge cases and balancing different criteria.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Closeness-of-fit priority (normalized)\n    remaining_after_fit = bins_remain_cap - item\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit)\n    close_fit_priority[~item_fits] = 0  # Zero priority if item doesn't fit\n    close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n\n    # Fullness priority (normalized)\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    fullness_priority = fill_level * item_fits  # Only consider if item fits\n    fullness_priority = fullness_priority / np.max(fullness_priority, initial=1e-9)\n\n    # Combined priority (weighted sum, normalized)\n    priorities = 0.6 * close_fit_priority + 0.4 * fullness_priority\n\n    # Encourage filling bins beyond a threshold\n    filling_threshold = 0.8\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    # Explicitly handle bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Small bonus for bins that can fit the item (prioritize packing something)\n    priorities[item_fits] += 0.1\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response4.txt_stdout.txt",
    "code_path": "problem_iter21_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of remaining capacity after placement,\n    the filling threshold, and normalization to balance these factors. It uses a more direct\n    and understandable approach than v1.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    if not np.any(item_fits):\n        return priorities # no bin can contain the item\n\n    # Remaining capacity after adding the item.  Use clipping to avoid negative values\n    remaining_after_fit = np.clip(bins_remain_cap - item, 0, bin_capacity)  # Ensure no negative values\n\n    # Fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Prioritize bins based on closeness of fit (lower remaining capacity is better)\n    # Use inverse of remaining capacity + a small constant for stability.  Normalize.\n    fit_priority = 1.0 / (remaining_after_fit + 0.01)  # Avoid division by zero\n    fit_priority[~item_fits] = 0  # Only consider bins where the item fits\n    fit_priority /= np.sum(fit_priority) + 1e-9 # Normalize to avoid single bin dominance\n\n    # Prioritize bins that reach a filling threshold (e.g., 80%)\n    filling_threshold = 0.8\n    threshold_priority = np.where(fill_level >= filling_threshold, 1.0, 0.0)\n    threshold_priority[~item_fits] = 0\n    threshold_priority /= np.sum(threshold_priority) + 1e-9 # Normalize\n\n    # Combine fit and threshold priorities. Give slightly more weight to fit.\n    priorities = 0.6 * fit_priority + 0.4 * threshold_priority\n\n    # Small bonus to use bins that can at least fit an item, avoiding empty bins\n    larger_bins_bonus = 0.05 * item_fits / (np.sum(item_fits)+ 1e-9)\n    priorities += larger_bins_bonus\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                perfect_fit_priority: float = 7.465168841650064,\n                close_fit_decay: float = 6.792870535909392,\n                target_fill: float = 0.5792050207302496,\n                target_decay: float = 9.97324957051447,\n                target_bonus_weight: float = 0.21483526019194793,\n                large_space_threshold: float = 0.7261569880180845,\n                large_space_penalty: float = -0.5653813421940123,\n                no_fit_penalty: float = -8824463787.539772,\n                bin_capacity: float = 1.0680776423324565) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.198244914240141,
    "exec_success": true
  }
]