[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins, combining close fit, target fill, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close Fit Priority\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities[feasible_bins] += close_fit_reward[feasible_bins]\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(feasible_bins & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Fragmentation penalty\n    small_capacity_threshold = 0.1\n    valid_indices = (remaining_after_fit > 0) & feasible_bins\n    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    fragmentation_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= fragmentation_penalty[valid_indices]*0.5\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity and filling target.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n    remaining_after_fit = feasible_bins - item\n\n    # Close fit bonus\n    priorities[feasible_indices] += np.exp(-2 * np.abs(remaining_after_fit))\n\n    # Filling target bonus (0.75 of bin capacity)\n    filling_threshold = 0.75\n    fill_level = 1 - remaining_after_fit\n    threshold_bonus = np.where(fill_level >= filling_threshold, 0.5, 0.0)\n    priorities[feasible_indices] += threshold_bonus\n\n    # Fragmentation penalty\n    frag_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0)\n    priorities[feasible_indices] += frag_penalty\n    priorities = np.maximum(priorities, 0) # Ensure non-negative\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close-to-full, reasonable fit, and size difference.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.\")\n\n    if not np.any(item_fits):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 2.0 * nearly_full\n\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n    \n    priorities[bins_remain_cap < item] = -1e9\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.108496210610296,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill, with early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close fit priority (higher is better)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)  # Tuned exponent\n\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.56) # Assuming bin capacity 1.56\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) # Tuned exponent\n\n    priorities += 0.5 * target_bonus * feasible_bins #Tunned weight\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best fit, filling threshold, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Best Fit\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Filling Threshold\n    filling_threshold = 0.75\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level_after_fit >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Fragmentation Avoidance\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold), -0.2, 0.0)\n    priorities += fragmentation_penalty\n\n    priorities[bins_remain_cap < item] = 0.0\n    priorities = np.maximum(priorities, 0.0)\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fit, target fullness, and wasted space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    target_remaining = 0.1 # Target remaining capacity after packing\n\n    # Bonus for bins meeting target fullness\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - target_remaining))\n    priorities += almost_full_bonus * feasible_bins\n\n    # Close fit priority with wasted space penalty\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    wasted_space_penalty = np.exp(10* remaining_after_fit) # Penalize bins with small remaining capacity\n    priorities += close_fit_priority * feasible_bins - 0.1* wasted_space_penalty*feasible_bins\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best fit, filling threshold, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    best_fit_priority = np.exp(-5 * np.abs(remaining_after_fit)) * item_fits\n    priorities += best_fit_priority\n\n    filling_threshold = 0.75\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level_after_fit >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold), -0.25, 0.0)\n    priorities += fragmentation_penalty\n\n    priorities[bins_remain_cap < item] = 0.0\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on tight fit, bin utilization and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n\n    # Tight fit reward\n    remaining_capacity_priority = np.exp(-np.abs(feasible_bins - item))\n    priorities[feasible_indices] += remaining_capacity_priority\n\n    # Bin utilization reward\n    bin_utilization = 1 - (feasible_bins / np.max(bins_remain_cap))\n    priorities[feasible_indices] += 0.5 * bin_utilization\n\n    # Fragmentation penalty\n    remaining_after_fit = feasible_bins - item\n    fragmentation_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0)\n    priorities[feasible_indices] += fragmentation_penalty\n\n    priorities = np.maximum(priorities, 0)\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits in the bin.\n    2. The remaining capacity after adding the item (favoring smaller remaining capacity).\n    3. A penalty for high fragmentation (large remaining capacity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Check if the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # If the item doesn't fit, the priority is 0\n    priorities[~item_fits] = 0.0\n    \n    # Consider only bins where item fits for calculating priorities\n    valid_bins = bins_remain_cap[item_fits]\n    \n    if len(valid_bins) > 0:\n        # 2. Reward bins with small remaining capacity after adding the item\n        remaining_capacity_after_fit = valid_bins - item\n        \n        # Use inverse of remaining capacity as a reward (higher value means smaller remaining capacity)\n        # Add a small constant to avoid division by zero\n        capacity_priority = 1.0 / (remaining_capacity_after_fit + 0.01)\n        \n        # Normalize capacity priority to be between 0 and 1\n        capacity_priority = (capacity_priority - np.min(capacity_priority)) / (np.max(capacity_priority) - np.min(capacity_priority))\n        \n        # 3. Penalize bins with large remaining capacity\n        fragmentation_penalty = valid_bins # Direct fragmentation penalty\n        \n        # Scale the fragmentation penalty to a reasonable range\n        fragmentation_penalty = (fragmentation_penalty - np.min(fragmentation_penalty)) / (np.max(fragmentation_penalty) - np.min(fragmentation_penalty))\n        \n        # Combine the priorities with weights\n        combined_priority = 0.7 * capacity_priority - 0.3 * fragmentation_penalty\n        \n        # Assign the priorities to the original array, where the item fits\n        priorities[item_fits] = combined_priority\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that minimize wasted space and balance bin utilization.\n    It focuses on finding the closest fit and discourages excessive fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~item_fits] = np.inf # set to infinity if item does not fit so that they are not selected.\n    \n    # Prioritize bins with minimal wasted space (closest fit). Use inverse of remaining space.\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-6\n    priorities = 1.0 / (remaining_after_fit + epsilon)\n    \n    # Scale priorities for better performance\n    priorities = priorities * item_fits # only if the item fits\n    \n    # Further reward bins that result in a higher fill level (e.g., > 60%)\n    fill_level = 1.0 - (remaining_after_fit / 1.0) # assuming bin capacity is 1.0\n    high_fill_bonus = np.where(item_fits & (fill_level > 0.6), 0.5, 0.0)\n    priorities += high_fill_bonus\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version emphasizes a balance between fill level, avoiding fragmentation, and bin utilization.\n    It prioritizes bins where the item fits best, aiming for high fill levels without excessive fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # 1. Feasibility: Only consider bins where the item fits\n    item_fits = bins_remain_cap >= item\n    priorities[~item_fits] = -np.inf  # Disqualify bins where the item doesn't fit\n\n    # 2. Fill Level: Reward bins with higher fill levels *after* adding the item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after = (bin_capacity - remaining_after_fit) / bin_capacity\n    priorities += fill_level_after * item_fits  # Directly reward fill level, only if item fits\n\n    # 3. Fragmentation Penalty: Penalize bins that will have small remaining space\n    #    after adding the item.  A small remaining space means more fragmentation\n    fragmentation = np.abs(remaining_after_fit)\n    fragmentation_penalty = np.exp(-5 * fragmentation) * item_fits\n    priorities -= 0.3 * fragmentation_penalty # Subtract from priority\n\n    # 4. Bin Utilization Reward: Give a smaller bonus to bins that have been used before. This aims to consolidate items into fewer bins,\n    # potentially freeing up other bins for larger items later.  Bins that have been untouched have initial capacity of 1.0.\n    bin_utilization = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.1 * bin_utilization * item_fits\n\n    # 5. Emphasize nearly full bins after placement\n    nearly_full_bonus = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.2 * nearly_full_bonus\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits best, aiming for high fill rates\n    while avoiding excessive fragmentation.  It uses a simpler, more focused approach\n    than v1, emphasizing close fits and avoiding penalties for bins that don't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # 1. Prioritize bins with the smallest remaining capacity AFTER adding the item.\n    #    This encourages filling bins as much as possible.  We only consider bins\n    #    where the item *can* fit. Smaller remaining capacity -> higher priority.\n    remaining_after_fit = bins_remain_cap - item\n    fit_quality = np.where(item_fits, np.exp(-5 * remaining_after_fit), 0)  # Exponential decay of priority as remaining cap increases.  Only active if item fits.\n    priorities += fit_quality\n\n    # 2. Bonus for bins that are filled above a threshold after placing the item\n    filling_threshold = 0.8  # Slightly higher threshold\n    bin_capacity = 1.0\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0) #Reduced bonus strength\n    priorities += threshold_bonus\n\n    # 3. Avoid extreme fragmentation: Slightly penalize bins where there's a significant amount of space left.\n    #   This is a weaker penalty than previous versions, aiming for balance. Only apply if item fits\n    large_waste = np.where(item_fits & (remaining_after_fit > 0.5), -0.1, 0)  # Reduced penalty value\n    priorities += large_waste\n\n    # No penalty for bins where item doesn't fit.\n    # No bonus for larger bins\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How much space will be wasted if the item is placed in the bin (lower waste is better).\n    3. A bonus for filling the bin close to capacity.\n    4. A penalty for bins that would result in very small remaining capacity (\"fragmentation\").\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Item fits check\n    item_fits = bins_remain_cap >= item\n\n    # If no bins fit, return all zeros. Prevents errors and wasted computation\n    if not np.any(item_fits):\n        return priorities\n\n    # 2. Waste calculation (remaining capacity after placing item)\n    remaining_after_fit = bins_remain_cap - item\n    waste = np.where(item_fits, remaining_after_fit, np.inf)  # Inf for bins that don't fit\n\n    # 3. Prioritize bins with less waste (more efficient packing)\n    # Use inverse of waste, scaled.  Smaller waste => larger priority\n    waste_priority = np.where(item_fits, np.exp(-2 * waste), 0) #exponential decay\n\n    priorities += waste_priority\n\n    # 4. Bonus for bins filling up close to capacity\n    nearly_full_threshold = 0.1 # how close to full is considered \"nearly full\"\n    nearly_full_bonus = np.where(item_fits & (remaining_after_fit <= nearly_full_threshold), 0.5, 0)\n    priorities += nearly_full_bonus\n    \n    # 5. Penalty for small remaining capacity (fragmentation avoidance)\n    fragmentation_threshold = 0.2 # if remaining capacity is less than this, it's considered fragmented.\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit <= fragmentation_threshold), -0.25, 0)\n    priorities += fragmentation_penalty\n    \n    #Ensure non negative priorities\n    priorities = np.maximum(priorities, 0)\n\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 0.6886532591956872, filling_threshold: float = 0.6310140286995914, close_fit_decay: float = 3.323878541768556, fragment_threshold: float = 0.11292796372392662, reasonable_fit_weight: float = 0.9940201145782193, penalty: float = -475702151.8806095) -> np.ndarray:\n    \"\"\"Prioritizes bins, combining close fit, target fill, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-close_fit_decay * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > fragment_threshold)\n    priorities += reasonable_fit_weight * reasonable_fit\n\n    priorities[bins_remain_cap < item] = penalty\n\n    # Desperation\n    if not np.any(item_fits):\n        priorities[:] = penalty\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 3.9788591942560925,
    "exec_success": true
  }
]