{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on closeness of fit, fullness, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # 1. Closeness of fit (exponential decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. Reward nearly full bins after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # 3. Penalize low utilization, encourage fuller bins\n    bin_size = np.max(bins_remain_cap)\n    utilization = (bin_size - remaining_after_fit) / bin_size\n    empty_penalty = np.exp(-5 * (1 - utilization))\n    priorities = priorities * empty_penalty\n    \n    min_utilization_threshold = 0.2\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = 0\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and bin fill level\n    after item placement. It prioritizes bins that provide a close fit and lead\n    to high bin utilization while minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit Priority:\n    # Prioritize bins where item size is close to remaining capacity.\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)  # Sharper decay for better fit\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    # Prioritize bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    # Penalize bins that would leave significant wasted space after adding the item.\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)  # Larger remaining gets larger penalty. The decay is smaller, such that we still account for this factor.\n    priorities += fragmentation_penalty\n\n    # 4. Infeasibility Handling:\n    # Set priority to zero for bins where the item doesn't fit.\n    priorities[bins_remain_cap < item] = 0\n\n    # 5. Scale to better rank feasible candidates.\n    priorities[bins_remain_cap >= item] *= (bins_remain_cap[bins_remain_cap >= item] - item + 0.0001) / (bins_remain_cap[bins_remain_cap >= item] + 0.0001)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st doesn't include calculating `wasted_space` to be `inf` to avoid errors, the 20th does. The 1st adds a boost priority to larger bins to promote using any bins over nothing. Comparing (1st) vs (6th), we see the 1st utilizes a filling threshold and gives a bonus, where the 6th considers a filling threshold. Comparing (2nd best) vs (second worst), we see the 2nd and 19th codes are almost identical, save for a small coefficient. Comparing (1st) vs (2nd), we see the codes are identical. Comparing (3rd) vs (4th), we see the codes are identical. Comparing (second worst) vs (worst), we see that the 19th initializes `possible_bins` and validates if they exist before proceeding. The 20th also includes `1e-9` to avoid divide-by-zero errors. Overall: The better heuristics take into account filling thresholds, and are concerned with errors arising with division and invalid conditions.\n- \nOkay, let's refine \"Current Self-Reflection\" to focus on actionable insights for better heuristic design, steering clear of the pitfalls outlined in \"Ineffective Self-Reflection.\"\n\nHere's a revised approach:\n\n*   **Keywords:** Robustness, validation, directness, impact analysis, avoidance.\n*   **Advice:** Implement validation checks during heuristic execution. Combine factors additively where possible. Explicitly address edge cases such as infeasible bins.\n*   **Avoid:** Blindly adding complexity, multiplicative combinations of factors without strong justification. Over-reliance on randomness that obscures heuristic logic.\n*   **Explanation:** Focus on creating robust heuristics by checking for possible errors before and after bin selections. Evaluate the real impact after adding each new factor.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}