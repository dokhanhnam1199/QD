{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers both space utilization (how full the bin would become)\n    and fragmentation (how much space would be wasted if the item is added).\n    Bins with capacity closest to the item size get the highest priority,\n    followed by bins that would be filled close to full if the item were added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Also reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit) )\n\n    priorities += nearly_full\n    # Prioritize bins with higher utilization after placement\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers both space utilization (how full the bin would become)\n    and fragmentation (how much space would be wasted if the item is added).\n    Bins with capacity closest to the item size get the highest priority,\n    followed by bins that would be filled close to full if the item were added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Also reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit) )\n\n    priorities += nearly_full\n    # Prioritize bins with higher utilization after placement\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small negative value to avoid selecting infeasible bins.\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Find feasible bins (bins with enough remaining capacity).\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all remain -inf\n\n    # Calculate the wasted space after placing the item in each feasible bin.\n    wasted_space = bins_remain_cap[feasible_bins] - item\n\n    # Prioritize bins with less wasted space (First-Fit Decreasing-like behavior).\n    # But also add a slight preference for bins that are already somewhat full (to encourage packing).\n    fullness_factor = bins_remain_cap[feasible_bins] / np.sum(bins_remain_cap)\n\n    priorities[feasible_bins] = -wasted_space + 0.1 * fullness_factor # Trade-off between wasted space and already-filled bins\n\n    # Add a bonus for bins that would become exactly full after adding the item\n    exact_fit = wasted_space == 0\n    priorities[feasible_bins][exact_fit] += 1.0 # large number to prefer perfect fit\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by Feynman's path integral formulation, we consider all possible \"paths\" (bins) and weight them based on a \"quantum action.\"\n    The \"action\" here is related to how well the item fits into the bin's remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Give zero priority to bins that cannot fit the item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, return all zeros\n\n    # Action: How much space is wasted if we place the item in this bin\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf # Penalize infeasible bins very heavily (infinity)\n\n    # \"Quantum amplitude\": e^(-action)  (More negative waste means better fit)\n    amplitudes = np.exp(-waste)\n\n    # Normalize amplitudes (to get a probability-like distribution, Feynman-style)\n    amplitudes[~feasible_bins] = 0 #ensure that we only consider feasible bins\n    if np.sum(amplitudes) > 0:\n      amplitudes = amplitudes / np.sum(amplitudes)\n    else:\n      amplitudes = np.ones_like(amplitudes) / len(amplitudes) #if they are all zero, then just divide them evenly\n\n    priorities = amplitudes # Assign probability/priority according to quantum amplitudes\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Prioritizes bins with remaining capacity slightly larger than the item size,\n    but also penalizes bins that are too empty. A sweet spot is targeted.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for bins where item fits and remaining space is small\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Fraction of waste\n        priorities[fit_mask] = 1 - priorities[fit_mask] # Make the less waste the highest priority\n        # Small penalty for bins where remaining capacity is significantly more than item.\n        # This encourages filling bins without leaving too much space.\n        waste_mask = bins_remain_cap > 2 * item\n        priorities[waste_mask] -= 0.1\n\n    # Penalize bins where item does not fit.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf #ensure that we never pick them\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by gravitational attraction: Larger remaining capacity (mass) attracts more strongly,\n    but the attraction diminishes with distance (difference between item size and remaining capacity).\n    Also incorporates a penalty for bins where the item doesn't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between bin capacity and item size.  A smaller\n    # positive difference means a tighter fit.  Use 0 for bins where the item does not fit.\n    difference = bins_remain_cap - item\n    difference = np.where(difference >= 0, difference, np.inf) # Inf if item doesn't fit, otherwise the gap\n\n    # Create a baseline priority based on inverse difference (smaller gap is better, avoid overflow)\n    priorities = np.where(difference != np.inf, 1 / (difference + 0.0001), -np.inf)\n\n    # Enhance priority: larger capacity is also attractive (Newtonian Gravitation concept):\n    priorities = priorities * (bins_remain_cap**0.5)\n\n    # Penalize bins where the item does not fit.\n    priorities = np.where(difference == np.inf, -np.inf, priorities)\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers both space utilization (how full the bin would become)\n    and fragmentation (how much space would be wasted if the item is added).\n    Bins with capacity closest to the item size get the highest priority,\n    followed by bins that would be filled close to full if the item were added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Also reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit) )\n\n    priorities += nearly_full\n    # Prioritize bins with higher utilization after placement\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Calculate remaining capacity after placing the item (only for valid bins)\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        \n        # Prioritize bins where the remaining capacity is small, but not zero (almost full)\n        priorities[valid_bins] = 1 / (remaining_capacity + 1e-9) # Avoid division by zero\n\n        # Slightly boost priority for bins where item fills more than half of the bin's capacity\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += (fill_ratio > 0.5) * 0.5\n\n        # Penalize bins with remaining capacity close to the item size \n        # to encourage packing more than one item into a bin (prevent fragmentation)\n        close_to_item_size = np.abs(remaining_capacity - item)\n        priorities[valid_bins] -= np.exp(-close_to_item_size) * 0.2\n    else:\n        #If no bin can fit the item, assign lowest priority to all bins.\n        priorities[:] = -np.inf\n        \n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Heuristic 1: Consider only bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if not np.any(valid_bins):\n        # If no bin can fit, prioritize the fullest one to minimise waste when a new bin is eventually used.\n        priorities = bins_remain_cap  #Prioritise higher remaining capacity for the item, acting like First Fit Decreasing.\n        return priorities\n    else:\n        # Heuristic 2: First fit considering fill ratio, otherwise 0 priority\n\n        fill_ratios = item / bins_remain_cap\n        fill_ratios[~valid_bins] = -1  # Set to negative if it doesn't fit to exclude\n\n        # Heuristic 3: Prioritize bins with fill ratios close to optimal, but above a threshold.\n        optimal_fill_ratio = 0.9  # Aim for a 90% filled bin\n        priority_boost = np.exp(-np.abs(fill_ratios - optimal_fill_ratio) * 10) # Penalise strongly deviation from the optima\n\n        priorities[valid_bins] = priority_boost[valid_bins] # Only valid bins get a priority\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small value\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Assign high priority to bins where the item fits\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n    if len(fit_indices) > 0:\n        # Prioritize bins that are filled most efficiently (minimize wasted space). Avoid very small remaining space to improve the chances of packing a large item later.\n        wasted_space = bins_remain_cap[fit_indices] - item\n        # Prioritize those with small wasted space and a buffer\n        buffer = np.where(wasted_space > 0.1 * item, wasted_space, np.inf)\n        best_fit_indices = fit_indices[np.argmin(buffer)] #prefer larger wasted space that exceeds buffer\n\n        priorities[best_fit_indices] = 1.0 + (bins_remain_cap[best_fit_indices] - item)/np.max(bins_remain_cap)  # Normalize based on maximum bin capacity\n    else:\n        # If the item doesn't fit in any bin, assign low priority. No bin will be selected.\n        priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics:\n    1. Reward bins that can *almost* perfectly fit the item (minimize wasted space).\n    2. Penalize bins that would become nearly full (risk of wasted capacity).\n    3. Exclude bins that cannot accommodate the item.\n    4. Add a small randomness for exploration\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exclude bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were added to each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf #effectively exclude those bins\n\n    # Reward bins with small wasted space (close fit)\n    close_fit_reward = np.exp(-wasted_space) # Exponential decay. Closer fit is exponentially better\n\n    # Penalize bins that become nearly full after adding the item\n    nearly_full_penalty = np.exp( - 1 / (wasted_space + 1e-9))  # Avoid division by zero\n\n    # Combine reward and penalty\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Add small randomness for exploration (Gaussian noise)\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape) #consider making magnitude of noise item-size dependent.\n    priorities += noise\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics:\n    1. Reward bins that can *almost* perfectly fit the item (minimize wasted space).\n    2. Penalize bins that would become nearly full (risk of wasted capacity).\n    3. Exclude bins that cannot accommodate the item.\n    4. Add a small randomness for exploration\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exclude bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were added to each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf #effectively exclude those bins\n\n    # Reward bins with small wasted space (close fit)\n    close_fit_reward = np.exp(-wasted_space) # Exponential decay. Closer fit is exponentially better\n\n    # Penalize bins that become nearly full after adding the item\n    nearly_full_penalty = np.exp( - 1 / (wasted_space + 1e-9))  # Avoid division by zero\n\n    # Combine reward and penalty\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Add small randomness for exploration (Gaussian noise)\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape) #consider making magnitude of noise item-size dependent.\n    priorities += noise\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version incorporates several heuristics:\n    1. Reward bins that can *almost* perfectly fit the item (minimize wasted space).\n    2. Penalize bins that would become nearly full (risk of wasted capacity).\n    3. Exclude bins that cannot accommodate the item.\n    4. Add a small randomness for exploration\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exclude bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were added to each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf #effectively exclude those bins\n\n    # Reward bins with small wasted space (close fit)\n    close_fit_reward = np.exp(-wasted_space) # Exponential decay. Closer fit is exponentially better\n\n    # Penalize bins that become nearly full after adding the item\n    nearly_full_penalty = np.exp( - 1 / (wasted_space + 1e-9))  # Avoid division by zero\n\n    # Combine reward and penalty\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Add small randomness for exploration (Gaussian noise)\n    noise = np.random.normal(0, 0.01, size=bins_remain_cap.shape) #consider making magnitude of noise item-size dependent.\n    priorities += noise\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Einstein's Intuition:\n    # Maximize space utilization while preventing near-empty bins.\n    # Employ a non-linear combination of factors to balance exploration and exploitation.\n\n    # 1. Feasibility: Disqualify bins that are too small.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf  # Assign lowest priority if not feasible\n\n    # 2. Space Utilization Factor:\n    # How much of the bin's capacity will be used.\n    utilization = item / bins_remain_cap[feasible_bins]\n\n    # 3. Remaining Capacity Factor:\n    # We prefer bins where there will still be some capacity left.\n    remaining_capacity_after_fit = bins_remain_cap[feasible_bins] - item\n    normalized_remaining = remaining_capacity_after_fit / np.max(bins_remain_cap)  # Normalize to [0,1]\n\n\n    # 4. Einsteinian Blend: A non-linear combination.\n    # Emphasis on near full, without penalizing more filled bins too much\n    # Balance utilization (avoiding waste) with leaving some room for future items.\n    # The square root adds a damping effect. Small changes when bin near full\n\n    # Avoiding small values for remaining cap which could have caused instability:\n    priorities[feasible_bins] = np.sqrt(utilization) * (1 + normalized_remaining)\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Einstein's Intuition:\n    # Maximize space utilization while preventing near-empty bins.\n    # Employ a non-linear combination of factors to balance exploration and exploitation.\n\n    # 1. Feasibility: Disqualify bins that are too small.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf  # Assign lowest priority if not feasible\n\n    # 2. Space Utilization Factor:\n    # How much of the bin's capacity will be used.\n    utilization = item / bins_remain_cap[feasible_bins]\n\n    # 3. Remaining Capacity Factor:\n    # We prefer bins where there will still be some capacity left.\n    remaining_capacity_after_fit = bins_remain_cap[feasible_bins] - item\n    normalized_remaining = remaining_capacity_after_fit / np.max(bins_remain_cap)  # Normalize to [0,1]\n\n\n    # 4. Einsteinian Blend: A non-linear combination.\n    # Emphasis on near full, without penalizing more filled bins too much\n    # Balance utilization (avoiding waste) with leaving some room for future items.\n    # The square root adds a damping effect. Small changes when bin near full\n\n    # Avoiding small values for remaining cap which could have caused instability:\n    priorities[feasible_bins] = np.sqrt(utilization) * (1 + normalized_remaining)\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very high priority to bins that can fit the item almost perfectly\n    fit_threshold = 0.95\n    perfect_fit_mask = (bins_remain_cap >= item) & (item / bins_remain_cap >= fit_threshold)\n    priorities[perfect_fit_mask] += 100  # Large bonus for near-perfect fit\n\n    # Reward bins that can fit the item (First-Fit Decreasing heuristic influence)\n    can_fit_mask = bins_remain_cap >= item\n    priorities[can_fit_mask] += bins_remain_cap[can_fit_mask] - item # Favor bins with smaller waste\n\n    # Penalize bins that cannot fit the item to 0, this will effectively remove them from consideration\n    cannot_fit_mask = bins_remain_cap < item\n    priorities[cannot_fit_mask] = -np.inf  # Large penalty for overflow\n\n    # Bonus for bins with higher remaining capacity (encourages using more full bins first, less fragmentation)\n    priorities += bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0 # Normalise the remaining capacity\n    \n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very high priority to bins that can fit the item almost perfectly\n    fit_threshold = 0.95\n    perfect_fit_mask = (bins_remain_cap >= item) & (item / bins_remain_cap >= fit_threshold)\n    priorities[perfect_fit_mask] += 100  # Large bonus for near-perfect fit\n\n    # Reward bins that can fit the item (First-Fit Decreasing heuristic influence)\n    can_fit_mask = bins_remain_cap >= item\n    priorities[can_fit_mask] += bins_remain_cap[can_fit_mask] - item # Favor bins with smaller waste\n\n    # Penalize bins that cannot fit the item to 0, this will effectively remove them from consideration\n    cannot_fit_mask = bins_remain_cap < item\n    priorities[cannot_fit_mask] = -np.inf  # Large penalty for overflow\n\n    # Bonus for bins with higher remaining capacity (encourages using more full bins first, less fragmentation)\n    priorities += bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0 # Normalise the remaining capacity\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities # all zeros. This should trigger adding new bin in the higher level function\n\n    # Calculate space utilization if the item were placed in the bin\n    utilization = item / bins_remain_cap\n    utilization[~possible_bins] = -1  # Mark impossible bins\n\n    # Give high priority to bins that would be filled reasonably well, but not overfilled\n    # penalize almost full, empty, or impossible bins\n    priorities = np.where(possible_bins, 1 - np.abs(utilization - 0.7), -100) #0.7 is the target remaining ratio\n\n    # Prefer to fill bins that are already somewhat filled\n    priorities += bins_remain_cap * 0.01\n\n    # Slight penalty for adding item to bins with very large capacity (prevent too much waste), only if item is smaller than the median capacity\n    median_capacity = np.median(bins_remain_cap)\n    if item < median_capacity:\n       priorities -= (bins_remain_cap > median_capacity) * (bins_remain_cap - median_capacity) * 0.005\n\n    #Very large remaining capacities get very small priority\n    priorities -= (bins_remain_cap > item*5)* bins_remain_cap*0.001\n\n    #Ensure that the bins that do not fit the item get a very negative priority, if fit at all is impossible, trigger new bin\n    priorities[~possible_bins] = -1000\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities # all zeros. This should trigger adding new bin in the higher level function\n\n    # Calculate space utilization if the item were placed in the bin\n    utilization = item / bins_remain_cap\n    utilization[~possible_bins] = -1  # Mark impossible bins\n\n    # Give high priority to bins that would be filled reasonably well, but not overfilled\n    # penalize almost full, empty, or impossible bins\n    priorities = np.where(possible_bins, 1 - np.abs(utilization - 0.7), -100) #0.7 is the target remaining ratio\n\n    # Prefer to fill bins that are already somewhat filled\n    priorities += bins_remain_cap * 0.01\n\n    # Slight penalty for adding item to bins with very large capacity (prevent too much waste), only if item is smaller than the median capacity\n    median_capacity = np.median(bins_remain_cap)\n    if item < median_capacity:\n       priorities -= (bins_remain_cap > median_capacity) * (bins_remain_cap - median_capacity) * 0.005\n\n    #Very large remaining capacities get very small priority\n    priorities -= (bins_remain_cap > item*5)* bins_remain_cap*0.001\n\n    #Ensure that the bins that do not fit the item get a very negative priority, if fit at all is impossible, trigger new bin\n    priorities[~possible_bins] = -1000\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    possible_bins = bins_remain_cap >= item\n    if not np.any(possible_bins):\n        return priorities # all zeros. This should trigger adding new bin in the higher level function\n\n    # Calculate space utilization if the item were placed in the bin\n    utilization = item / bins_remain_cap\n    utilization[~possible_bins] = -1  # Mark impossible bins\n\n    # Give high priority to bins that would be filled reasonably well, but not overfilled\n    # penalize almost full, empty, or impossible bins\n    priorities = np.where(possible_bins, 1 - np.abs(utilization - 0.7), -100) #0.7 is the target remaining ratio\n\n    # Prefer to fill bins that are already somewhat filled\n    priorities += bins_remain_cap * 0.01\n\n    # Slight penalty for adding item to bins with very large capacity (prevent too much waste), only if item is smaller than the median capacity\n    median_capacity = np.median(bins_remain_cap)\n    if item < median_capacity:\n       priorities -= (bins_remain_cap > median_capacity) * (bins_remain_cap - median_capacity) * 0.005\n\n    #Very large remaining capacities get very small priority\n    priorities -= (bins_remain_cap > item*5)* bins_remain_cap*0.001\n\n    #Ensure that the bins that do not fit the item get a very negative priority, if fit at all is impossible, trigger new bin\n    priorities[~possible_bins] = -1000\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}