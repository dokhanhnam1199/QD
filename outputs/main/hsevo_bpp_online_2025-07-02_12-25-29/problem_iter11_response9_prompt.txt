{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins considering fit, fullness, and bin utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = 0\n\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.5 * bin_utilization\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. Remaining capacity after placing the item (favoring tighter fits).\n    3. A filling threshold to encourage bins to reach a desirable fill level.\n    4. A penalty for excessive fragmentation.\n    5. A bonus for almost filling up the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros.\n    if not np.any(item_fits):\n        return priorities\n\n    # 1. Feasibility check: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n\n    # 2. Remaining capacity priority: Higher priority to bins that leave less space.\n    remaining_capacity_priority = 1 - (feasible_bins - item) / bin_capacity\n    priorities[feasible_indices] += remaining_capacity_priority\n\n    # 3. Filling threshold: Reward bins that cross a certain threshold after placement.\n    filling_threshold = 0.75\n    remaining_after_fit = feasible_bins - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(fill_level >= filling_threshold, 0.5, 0.0)  # Adjusted bonus\n    priorities[feasible_indices] += threshold_bonus\n\n    # 4. Fragmentation penalty: Penalize bins that would leave very small remaining space.\n    fragmentation_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0) #Adjusted penalty and threshold\n    priorities[feasible_indices] += fragmentation_penalty\n\n    # 5. Nearly Full Bonus : Give bins a boost if they are almost full.\n    almost_full_bonus = np.where(remaining_after_fit <= 0.05, 0.3, 0.0) #Adjusted threshold and bonus\n    priorities[feasible_indices] += almost_full_bonus\n\n    # Validation: Ensure priorities are non-negative.  Important to keep\n    # for heuristics where we subtract factors.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first incorporates a target fill level, nearly empty penalty, and nearly full bonus, while the last emphasizes close fit, utilization, and fragmentation. (2nd best) vs (second worst) reveal similar trends, with (2nd best) emphasizing filling threshold and close fit with wasted space considerations and (second worst) focusing on closeness of fit and utilization, but lacking specific target or penalties/bonuses. Comparing (1st) vs (2nd), we see (1st) validates if the item fits first and returns early if not, while the (2nd) calculates before checking. (3rd) vs (4th) shows (3rd) has a penalty for small remaining capacity and (4th) parameterizes filling threshold and other parameters. Comparing (second worst) vs (worst), we see (second worst) calculates fragmentation before masking infeasible bins, while (worst) calculates fragmentation and then masks, and it also includes scaling. Overall: The better heuristics incorporate a wider range of factors and explicit checks, whereas the worse ones focus on fewer aspects and may lack robustness. The best ones also tend to validate the input early on and return early.\n- \nOkay, I'm ready to help you earn that tip! Let's redefine \"Current Self-Reflection\" for better heuristic design, focusing on effectiveness and avoiding common pitfalls.\n\n*   **Keywords:** Objective-driven, validation, additive penalties/bonuses, incremental complexity.\n\n*   **Advice:** Design heuristics from the objective function *outward*. Prioritize validated inputs and outputs at each stage. Use additive (linear) combinations of rewards/penalties for desired/undesired outcomes. Introduce complexity *incrementally*, carefully measuring each addition's impact on solution quality and runtime.\n\n*   **Avoid:** Premature parameterization, complex multiplicative combinations, and unchecked randomness without clear justification.\n\n*   **Explanation:** Focus on directly addressing the optimization goal with simple, verifiable steps. Parameterization without a strong justification, complex multiplicative rules, and randomness can obscure the heuristic's behavior, making it harder to understand, debug, and improve. Build from a simple base, validating each addition.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}