{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Whether the item fits.\n    2.  The remaining capacity after adding the item (favoring tighter fits).\n    3.  A filling threshold to encourage bins to be filled above a certain level.\n    4.  Penalizing bins that are already too full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    filling_threshold = 0.75\n\n    # 1. Check if the item fits\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities  # No bin can accommodate item, return zero priorities\n\n    # 2. Remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # 3. Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # 4. Give a bonus to bins that meet the filling threshold\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.8, 0.0)  # Reduced bonus\n    priorities += threshold_bonus\n\n    # 5. Prioritize tighter fits (smaller remaining capacity)\n    # But only if the item fits.  Also avoid taking log of zero.\n    fit_priority = np.where(item_fits & (remaining_after_fit > 0), np.exp(-5 * remaining_after_fit), 0.0)\n\n    priorities += fit_priority\n\n\n    # 6. Penalize bins where the item doesn't fit at all.\n    priorities[bins_remain_cap < item] = 0\n\n    # 7. Add a small incentive to using non-empty bins if possible.  This\n    #    addresses an edge case where if all bins are empty, the algorithm\n    #    doesn't prefer one over the other.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.05 * larger_bins  # Even smaller bonus\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that the 1st prioritizes bins based on space utilization, fragmentation and filling threshold. The 2nd prioritizes bins based on close fit, filling and avoids fragmentation. However, the 2nd has an early exit for perfect fit. The 2nd also has a penalty for leaving large remaining space.\n\nComparing (3rd) vs (4th), they are identical.\n\nComparing (5th) vs (6th), they are identical.\n\nComparing (7th) vs (8th), we see that the 7th prioritizes bins based on fill target, fit and fragmentation with early exits and the 8th prioritizes bins based on whether the item fits, remaining capacity, filling threshold and penalizing bins that are already too full.\n\nComparing (9th) vs (10th), we see that the 9th prioritizes bins based on close fit, target fill and avoids fragmentation and takes `bin_capacity` as an argument and the 10th combines target fill, close fit and handles edge cases.\n\nComparing (11th) vs (12th), we see that the 11th prioritizes bins that results in a fill level closest to a target and the 12th prioritizes bins based on a combination of factors like ability to fit item, target fill level, avoiding excessive fragmentation and a tie-breaker for the fullest bin so far.\n\nComparing (13th) vs (14th), we see that the 13th prioritizes bins considering close fit, target fill, and fragmentation with early exit with adjusted penalties. The 14th prioritizes bins based on a combination of factors like ability to fit item, target fill level, avoiding excessive fragmentation and a tie-breaker for the fullest bin so far.\n\nComparing (15th, 16th, 17th, 18th) they only implement early exit of perfect fit.\nComparing (19th) vs (20th), they are identical.\n\nOverall: The better heuristics tend to consider more factors such as fragmentation, target fill level, and close fit. They also implement early exits for perfect fit scenarios and handle edge cases where no bins can fit the item. Penalties for large remaining space and small remaining space after fit are also important.\n- \nOkay, let's redefine \"Current self-reflection\" to make it more effective for designing bin packing heuristics. We'll focus on actionable insights and avoid the pitfalls of the \"Ineffective self-reflection\" examples.\n\nHere's a refined version:\n\n*   **Keywords:** Directness, combination, normalization, exploration, clear objectives, gradual refinement.\n\n*   **Advice:** Prioritize direct combinations of closeness-of-fit and fullness. Use normalization to balance different criteria and facilitate exploration of the design space. Handle edge cases explicitly (e.g., no fit bins).\n\n*   **Avoid:** Multiplicative combinations, premature complexity, relying solely on randomness, neglecting the optimization objective.\n\n*   **Explanation:** Design heuristics that are both clear and effective. Begin with a simple core and add complexity cautiously. Ensure factors like fill level and fit contribute directly to the optimization goal, and normalize priorities across different factors.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}