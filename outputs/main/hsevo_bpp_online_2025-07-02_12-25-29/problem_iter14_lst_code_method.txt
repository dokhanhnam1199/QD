{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins, combining close fit, target fill, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 0.6886532591956872, filling_threshold: float = 0.6310140286995914, close_fit_decay: float = 3.323878541768556, fragment_threshold: float = 0.11292796372392662, reasonable_fit_weight: float = 0.9940201145782193, penalty: float = -475702151.8806095) -> np.ndarray:\n    \"\"\"Prioritizes bins, combining close fit, target fill, and fragmentation avoidance.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-close_fit_decay * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > fragment_threshold)\n    priorities += reasonable_fit_weight * reasonable_fit\n\n    priorities[bins_remain_cap < item] = penalty\n\n    # Desperation\n    if not np.any(item_fits):\n        priorities[:] = penalty\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close Fit Priority\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities[feasible_bins] += close_fit_reward[feasible_bins]\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(feasible_bins & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Fragmentation penalty\n    small_capacity_threshold = 0.1\n    valid_indices = (remaining_after_fit > 0) & feasible_bins\n    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    fragmentation_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= fragmentation_penalty[valid_indices]*0.5\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity and filling target.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n    remaining_after_fit = feasible_bins - item\n\n    # Close fit bonus\n    priorities[feasible_indices] += np.exp(-2 * np.abs(remaining_after_fit))\n\n    # Filling target bonus (0.75 of bin capacity)\n    filling_threshold = 0.75\n    fill_level = 1 - remaining_after_fit\n    threshold_bonus = np.where(fill_level >= filling_threshold, 0.5, 0.0)\n    priorities[feasible_indices] += threshold_bonus\n\n    # Fragmentation penalty\n    frag_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0)\n    priorities[feasible_indices] += frag_penalty\n    priorities = np.maximum(priorities, 0) # Ensure non-negative\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that minimize wasted space and balance bin utilization.\n    It focuses on finding the closest fit and discourages excessive fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~item_fits] = np.inf # set to infinity if item does not fit so that they are not selected.\n    \n    # Prioritize bins with minimal wasted space (closest fit). Use inverse of remaining space.\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-6\n    priorities = 1.0 / (remaining_after_fit + epsilon)\n    \n    # Scale priorities for better performance\n    priorities = priorities * item_fits # only if the item fits\n    \n    # Further reward bins that result in a higher fill level (e.g., > 60%)\n    fill_level = 1.0 - (remaining_after_fit / 1.0) # assuming bin capacity is 1.0\n    high_fill_bonus = np.where(item_fits & (fill_level > 0.6), 0.5, 0.0)\n    priorities += high_fill_bonus\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill, with early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close fit priority (higher is better)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)  # Tuned exponent\n\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.56) # Assuming bin capacity 1.56\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) # Tuned exponent\n\n    priorities += 0.5 * target_bonus * feasible_bins #Tunned weight\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill, with early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close fit priority (higher is better)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)  # Tuned exponent\n\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.56) # Assuming bin capacity 1.56\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) # Tuned exponent\n\n    priorities += 0.5 * target_bonus * feasible_bins #Tunned weight\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fit, target fullness, and wasted space.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    target_remaining = 0.1 # Target remaining capacity after packing\n\n    # Bonus for bins meeting target fullness\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - target_remaining))\n    priorities += almost_full_bonus * feasible_bins\n\n    # Close fit priority with wasted space penalty\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    wasted_space_penalty = np.exp(10* remaining_after_fit) # Penalize bins with small remaining capacity\n    priorities += close_fit_priority * feasible_bins - 0.1* wasted_space_penalty*feasible_bins\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How much space will be wasted if the item is placed in the bin (lower waste is better).\n    3. A bonus for filling the bin close to capacity.\n    4. A penalty for bins that would result in very small remaining capacity (\"fragmentation\").\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Item fits check\n    item_fits = bins_remain_cap >= item\n\n    # If no bins fit, return all zeros. Prevents errors and wasted computation\n    if not np.any(item_fits):\n        return priorities\n\n    # 2. Waste calculation (remaining capacity after placing item)\n    remaining_after_fit = bins_remain_cap - item\n    waste = np.where(item_fits, remaining_after_fit, np.inf)  # Inf for bins that don't fit\n\n    # 3. Prioritize bins with less waste (more efficient packing)\n    # Use inverse of waste, scaled.  Smaller waste => larger priority\n    waste_priority = np.where(item_fits, np.exp(-2 * waste), 0) #exponential decay\n\n    priorities += waste_priority\n\n    # 4. Bonus for bins filling up close to capacity\n    nearly_full_threshold = 0.1 # how close to full is considered \"nearly full\"\n    nearly_full_bonus = np.where(item_fits & (remaining_after_fit <= nearly_full_threshold), 0.5, 0)\n    priorities += nearly_full_bonus\n    \n    # 5. Penalty for small remaining capacity (fragmentation avoidance)\n    fragmentation_threshold = 0.2 # if remaining capacity is less than this, it's considered fragmented.\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit <= fragmentation_threshold), -0.25, 0)\n    priorities += fragmentation_penalty\n    \n    #Ensure non negative priorities\n    priorities = np.maximum(priorities, 0)\n\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on remaining capacity and filling target.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities\n\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n    remaining_after_fit = feasible_bins - item\n\n    # Close fit bonus\n    priorities[feasible_indices] += np.exp(-2 * np.abs(remaining_after_fit))\n\n    # Filling target bonus (0.75 of bin capacity)\n    filling_threshold = 0.75\n    fill_level = 1 - remaining_after_fit\n    threshold_bonus = np.where(fill_level >= filling_threshold, 0.5, 0.0)\n    priorities[feasible_indices] += threshold_bonus\n\n    # Fragmentation penalty\n    frag_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0)\n    priorities[feasible_indices] += frag_penalty\n    priorities = np.maximum(priorities, 0) # Ensure non-negative\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How much space will be wasted if the item is placed in the bin (lower waste is better).\n    3. A bonus for filling the bin close to capacity.\n    4. A penalty for bins that would result in very small remaining capacity (\"fragmentation\").\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Item fits check\n    item_fits = bins_remain_cap >= item\n\n    # If no bins fit, return all zeros. Prevents errors and wasted computation\n    if not np.any(item_fits):\n        return priorities\n\n    # 2. Waste calculation (remaining capacity after placing item)\n    remaining_after_fit = bins_remain_cap - item\n    waste = np.where(item_fits, remaining_after_fit, np.inf)  # Inf for bins that don't fit\n\n    # 3. Prioritize bins with less waste (more efficient packing)\n    # Use inverse of waste, scaled.  Smaller waste => larger priority\n    waste_priority = np.where(item_fits, np.exp(-2 * waste), 0) #exponential decay\n\n    priorities += waste_priority\n\n    # 4. Bonus for bins filling up close to capacity\n    nearly_full_threshold = 0.1 # how close to full is considered \"nearly full\"\n    nearly_full_bonus = np.where(item_fits & (remaining_after_fit <= nearly_full_threshold), 0.5, 0)\n    priorities += nearly_full_bonus\n    \n    # 5. Penalty for small remaining capacity (fragmentation avoidance)\n    fragmentation_threshold = 0.2 # if remaining capacity is less than this, it's considered fragmented.\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit <= fragmentation_threshold), -0.25, 0)\n    priorities += fragmentation_penalty\n    \n    #Ensure non negative priorities\n    priorities = np.maximum(priorities, 0)\n\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close-to-full, reasonable fit, and size difference.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.\")\n\n    if not np.any(item_fits):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 2.0 * nearly_full\n\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n    \n    priorities[bins_remain_cap < item] = -1e9\n    \n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close-to-full, reasonable fit, and size difference.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.\")\n\n    if not np.any(item_fits):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 2.0 * nearly_full\n\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n    \n    priorities[bins_remain_cap < item] = -1e9\n    \n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close-to-full, reasonable fit, and size difference.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.\")\n\n    if not np.any(item_fits):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 2.0 * nearly_full\n\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n    \n    priorities[bins_remain_cap < item] = -1e9\n    \n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}