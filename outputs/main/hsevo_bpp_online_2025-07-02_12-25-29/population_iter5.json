[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness, using exponential decay and inf for infeasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = np.exp(-close_fit)\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Add a bonus for bins that will be almost full after placing the item\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - 0.1)) # Target 0.1 remaining\n    priorities[feasible_bins] += almost_full_bonus * 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and resulting fullness additively.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Boost priority for bins that are almost full after adding the item\n    remaining_capacity = bins_remain_cap - item\n    almost_full = (remaining_capacity >=0) & (remaining_capacity < (0.1 * bins_remain_cap))\n    close_to_full_boost = np.zeros_like(bins_remain_cap, dtype=float)\n    close_to_full_boost[almost_full] = 0.5  # Boost priority\n\n    # Combine rewards\n    priorities = close_fit_reward + close_to_full_boost\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on closeness of fit, fullness, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # 1. Closeness of fit (exponential decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. Reward nearly full bins after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # 3. Penalize low utilization, encourage fuller bins\n    bin_size = np.max(bins_remain_cap)\n    utilization = (bin_size - remaining_after_fit) / bin_size\n    empty_penalty = np.exp(-5 * (1 - utilization))\n    priorities = priorities * empty_penalty\n    \n    min_utilization_threshold = 0.2\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = 0\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and resulting fullness, add small exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities[feasible_bins] = np.exp(-close_fit[feasible_bins])\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Add small exploration\n    priorities += np.random.normal(0, 0.001, size=bins_remain_cap.shape)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 34.12445153570005,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = -np.inf\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and resulting fullness additively.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  # Avoid errors later\n\n    # Reward close fit (small wasted space)\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Reward bins that will be nearly full\n    nearly_full_reward = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Additively combine the rewards for final priority\n    priorities = close_fit_reward + nearly_full_reward\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit, fullness, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Closeness of fit (higher priority for bins where the item fits well)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  #avoid error on infeasible bins\n\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward\n\n    # Fill level after adding the item (encourage full bins)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[infeasible_mask] = np.inf\n    fill_level = 1 - np.abs(remaining_after_fit) / np.max(bins_remain_cap) # Scale to bin size\n    priorities += fill_level * 0.75 # Weigh fill level\n\n    # Avoid small remaining capacities (reduce fragmentation)\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_capacity_threshold = 0.1  # Fraction of max bin capacity\n    \n    valid_indices = (remaining_after_fit > 0) & (remaining_after_fit != np.inf)\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 84.98205025927405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using wasted space, fullness, and infeasibility.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Wasted space calculation (exclude infeasible)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-2 * wasted_space)\n\n    # Reward nearly full bins exponentially\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same capacity\n    utilization = (bin_size - wasted_space) / bin_size\n    nearly_full_reward = np.exp(-2 * np.abs(wasted_space)) # more sensitive\n\n    # Combine rewards and penalties additively\n    priorities = close_fit_reward + nearly_full_reward\n\n    # Penalize bins that remain far from full. Encourage utilization.\n    empty_penalty = np.exp(-5 * (1 - utilization))\n    priorities += empty_penalty  # reduced impact\n\n    # Minimum utilization threshold to reduce extreme fragmentation\n    min_utilization_threshold = 0.2\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = -np.inf\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness, additively combined.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = -np.inf\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]