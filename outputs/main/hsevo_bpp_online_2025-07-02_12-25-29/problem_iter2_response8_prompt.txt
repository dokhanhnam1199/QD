{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by gravitational attraction: Larger remaining capacity (mass) attracts more strongly,\n    but the attraction diminishes with distance (difference between item size and remaining capacity).\n    Also incorporates a penalty for bins where the item doesn't fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the difference between bin capacity and item size.  A smaller\n    # positive difference means a tighter fit.  Use 0 for bins where the item does not fit.\n    difference = bins_remain_cap - item\n    difference = np.where(difference >= 0, difference, np.inf) # Inf if item doesn't fit, otherwise the gap\n\n    # Create a baseline priority based on inverse difference (smaller gap is better, avoid overflow)\n    priorities = np.where(difference != np.inf, 1 / (difference + 0.0001), -np.inf)\n\n    # Enhance priority: larger capacity is also attractive (Newtonian Gravitation concept):\n    priorities = priorities * (bins_remain_cap**0.5)\n\n    # Penalize bins where the item does not fit.\n    priorities = np.where(difference == np.inf, -np.inf, priorities)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very high priority to bins that can fit the item almost perfectly\n    fit_threshold = 0.95\n    perfect_fit_mask = (bins_remain_cap >= item) & (item / bins_remain_cap >= fit_threshold)\n    priorities[perfect_fit_mask] += 100  # Large bonus for near-perfect fit\n\n    # Reward bins that can fit the item (First-Fit Decreasing heuristic influence)\n    can_fit_mask = bins_remain_cap >= item\n    priorities[can_fit_mask] += bins_remain_cap[can_fit_mask] - item # Favor bins with smaller waste\n\n    # Penalize bins that cannot fit the item to 0, this will effectively remove them from consideration\n    cannot_fit_mask = bins_remain_cap < item\n    priorities[cannot_fit_mask] = -np.inf  # Large penalty for overflow\n\n    # Bonus for bins with higher remaining capacity (encourages using more full bins first, less fragmentation)\n    priorities += bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0 # Normalise the remaining capacity\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses exponential decay to prioritize bins based on how closely they fit the item and how full they would become after adding the item, while the worst heuristic aims for a target fill ratio of 0.7 and adds penalties based on median capacity and excessive remaining capacity. The best also considers fragmentation, unlike the worst.\n\nComparing (2nd best) vs (second worst), we see similar approaches to the (best) vs (worst) comparison. The second-best heuristic also considers space utilization and fragmentation, using exponential decay to prioritize bins. The second worst prioritizes bins with higher remaining capacity if no bins can fit the item, and then goes on to use a target fill ratio, penalizing deviations from it.\n\nComparing (1st) vs (2nd), they are exactly identical, meaning that small variations elsewhere must influence performance.\n\nComparing (3rd) vs (4th), the 3rd uses wasted space and a fullness factor, and provides a bonus for exact fits, while the 4th uses a \"quantum action\" inspired approach, normalizing amplitudes based on wasted space to assign priorities. 3rd uses a simpler trade-off between wasted space and fullness.\n\nComparing (second worst) vs (worst), we see penalization for exceeding a proportion of item capacity.\n\nOverall: Better heuristics use a combination of rewards and penalties, focusing on minimizing wasted space and fragmentation. Exponential decay functions seem effective for prioritizing bins based on fit and fullness. Avoiding target fill ratios and directly considering wasted space seems beneficial. More successful heuristics also often have negative infinity to avoid picking the invalid bins.\nSimpler approaches with clearly defined rewards and penalties seem to outperform those inspired by more complex physical analogies.\n- \nOkay, here's a refined definition of \"Current self-reflection\" to guide heuristic design, focusing on effectiveness:\n\n*   **Keywords:** Objective-alignment, iterative refinement, evaluation, interpretable rules, reward/penalty system, constraint handling.\n\n*   **Advice:** Explicitly link heuristic components to specific objectives. Measure the impact of each design choice on performance and interpretability. Prioritize constraint satisfaction.\n\n*   **Avoid:** Premature complexity, uninterpretable rules, neglecting objective alignment, insufficient evaluation.\n\n*   **Explanation:** Focus on creating heuristics that directly optimize the target objective, adding complexity only when demonstrably beneficial and always evaluating their impact. Consider constraints early.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}