{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fit and fullness, using exponential decay and inf for infeasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = np.exp(-close_fit)\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Add a bonus for bins that will be almost full after placing the item\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - 0.1)) # Target 0.1 remaining\n    priorities[feasible_bins] += almost_full_bonus * 0.5\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st doesn't include calculating `wasted_space` to be `inf` to avoid errors, the 20th does. The 1st adds a boost priority to larger bins to promote using any bins over nothing. Comparing (1st) vs (6th), we see the 1st utilizes a filling threshold and gives a bonus, where the 6th considers a filling threshold. Comparing (2nd best) vs (second worst), we see the 2nd and 19th codes are almost identical, save for a small coefficient. Comparing (1st) vs (2nd), we see the codes are identical. Comparing (3rd) vs (4th), we see the codes are identical. Comparing (second worst) vs (worst), we see that the 19th initializes `possible_bins` and validates if they exist before proceeding. The 20th also includes `1e-9` to avoid divide-by-zero errors. Overall: The better heuristics take into account filling thresholds, and are concerned with errors arising with division and invalid conditions.\n- \nOkay, let's refine \"Current Self-Reflection\" to focus on actionable insights for better heuristic design, steering clear of the pitfalls outlined in \"Ineffective Self-Reflection.\"\n\nHere's a revised approach:\n\n*   **Keywords:** Robustness, validation, directness, impact analysis, avoidance.\n*   **Advice:** Implement validation checks during heuristic execution. Combine factors additively where possible. Explicitly address edge cases such as infeasible bins.\n*   **Avoid:** Blindly adding complexity, multiplicative combinations of factors without strong justification. Over-reliance on randomness that obscures heuristic logic.\n*   **Explanation:** Focus on creating robust heuristics by checking for possible errors before and after bin selections. Evaluate the real impact after adding each new factor.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}