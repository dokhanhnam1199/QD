```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins based on a combination of factors,
    including space utilization, fragmentation, a filling threshold,
    and a preference for bins that leave minimal wasted space. It also
    introduces a small element of randomness to avoid local optima.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = 1.0  # Assuming bin capacity is 1.0
    filling_threshold = 0.70 # Slightly reduced threshold

    # Item fits check
    item_fits = bins_remain_cap >= item

    # Immediate disqualification
    priorities[~item_fits] = -1.0  # Negative priority if it doesn't fit

    # Remaining capacity after placing item
    remaining_after_fit = bins_remain_cap - item
    
    # Filling level after placing item
    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity

    # Threshold Bonus: Strong incentive to cross threshold
    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 2.0, 0.0)
    priorities += threshold_bonus

    # Primary objective: Minimize wasted space (residual)
    waste_priority = np.exp(-10 * remaining_after_fit) * item_fits # Higher exponent
    priorities += waste_priority

    # Bins closer to full get higher priority
    fullness_priority = fill_level * item_fits * 0.5
    priorities += fullness_priority

    # Small bonus to use non-empty bins
    priorities += 0.1 * item_fits 
    
    # Add small random noise to potentially escape local optima
    priorities += 0.01 * np.random.rand(len(bins_remain_cap))

    return priorities
```
