{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fit, fullness, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Closeness of fit (higher priority for bins where the item fits well)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  #avoid error on infeasible bins\n\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward\n\n    # Fill level after adding the item (encourage full bins)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[infeasible_mask] = np.inf\n    fill_level = 1 - np.abs(remaining_after_fit) / np.max(bins_remain_cap) # Scale to bin size\n    priorities += fill_level * 0.75 # Weigh fill level\n\n    # Avoid small remaining capacities (reduce fragmentation)\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_capacity_threshold = 0.1  # Fraction of max bin capacity\n    \n    valid_indices = (remaining_after_fit > 0) & (remaining_after_fit != np.inf)\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st doesn't include calculating `wasted_space` to be `inf` to avoid errors, the 20th does. The 1st adds a boost priority to larger bins to promote using any bins over nothing. Comparing (1st) vs (6th), we see the 1st utilizes a filling threshold and gives a bonus, where the 6th considers a filling threshold. Comparing (2nd best) vs (second worst), we see the 2nd and 19th codes are almost identical, save for a small coefficient. Comparing (1st) vs (2nd), we see the codes are identical. Comparing (3rd) vs (4th), we see the codes are identical. Comparing (second worst) vs (worst), we see that the 19th initializes `possible_bins` and validates if they exist before proceeding. The 20th also includes `1e-9` to avoid divide-by-zero errors. Overall: The better heuristics take into account filling thresholds, and are concerned with errors arising with division and invalid conditions.\n- \nOkay, let's refine \"Current Self-Reflection\" to focus on actionable insights for better heuristic design, steering clear of the pitfalls outlined in \"Ineffective Self-Reflection.\"\n\nHere's a revised approach:\n\n*   **Keywords:** Robustness, validation, directness, impact analysis, avoidance.\n*   **Advice:** Implement validation checks during heuristic execution. Combine factors additively where possible. Explicitly address edge cases such as infeasible bins.\n*   **Avoid:** Blindly adding complexity, multiplicative combinations of factors without strong justification. Over-reliance on randomness that obscures heuristic logic.\n*   **Explanation:** Focus on creating robust heuristics by checking for possible errors before and after bin selections. Evaluate the real impact after adding each new factor.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}