{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1 \n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How much space will be wasted if the item is placed in the bin (lower waste is better).\n    3. A bonus for filling the bin close to capacity.\n    4. A penalty for bins that would result in very small remaining capacity (\"fragmentation\").\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Item fits check\n    item_fits = bins_remain_cap >= item\n\n    # If no bins fit, return all zeros. Prevents errors and wasted computation\n    if not np.any(item_fits):\n        return priorities\n\n    # 2. Waste calculation (remaining capacity after placing item)\n    remaining_after_fit = bins_remain_cap - item\n    waste = np.where(item_fits, remaining_after_fit, np.inf)  # Inf for bins that don't fit\n\n    # 3. Prioritize bins with less waste (more efficient packing)\n    # Use inverse of waste, scaled.  Smaller waste => larger priority\n    waste_priority = np.where(item_fits, np.exp(-2 * waste), 0) #exponential decay\n\n    priorities += waste_priority\n\n    # 4. Bonus for bins filling up close to capacity\n    nearly_full_threshold = 0.1 # how close to full is considered \"nearly full\"\n    nearly_full_bonus = np.where(item_fits & (remaining_after_fit <= nearly_full_threshold), 0.5, 0)\n    priorities += nearly_full_bonus\n    \n    # 5. Penalty for small remaining capacity (fragmentation avoidance)\n    fragmentation_threshold = 0.2 # if remaining capacity is less than this, it's considered fragmented.\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit <= fragmentation_threshold), -0.25, 0)\n    priorities += fragmentation_penalty\n    \n    #Ensure non negative priorities\n    priorities = np.maximum(priorities, 0)\n\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combination of \"nearly full,\" \"reasonable fit,\" and \"size difference,\" along with handling the case where no item fits by assigning a large negative priority except to the bin with the smallest capacity. The worst focuses on similar concepts but is less refined. (2nd) is identical to (1st) which is a perfect clone so no differences. Comparing (1st) vs (3rd), (1st) uses a \"nearly full\" bonus with an exponential decay based on the absolute difference between remaining capacity and zero, while (3rd) uses a target fill bonus and avoids tiny fragments, adding a desperation strategy when no item fits. Comparing (3rd) vs (4th), the main difference is that (4th) is heavily parameterized, allowing for fine-tuning but potentially overfitting, while (3rd) uses hardcoded values. (15th) focuses on waste calculation, near-full bonus, and fragmentation penalty, ensuring non-negative priorities, whilst many other heuristics are similar but the weighting and combination of factors vary significantly. Comparing (16th) vs (17th), we observe similar priorities for close fit, filling target, and fragmentation, but (17th) explicitly handles the case where no items fit using an early exit strategy. Comparing (second worst) vs (worst), the difference lies in the explicit `ValueError` check for negative bin capacities and the more refined bonus/penalty calculations in the second worst. Overall: better heuristics seem to involve a combination of close-fit rewards, target fill bonuses, fragmentation penalties, and careful consideration of edge cases where no items fit or negative bin capacities exist. The weighting of these factors and the use of exponential decay functions appear to influence performance significantly.\n- \nOkay, let's redefine \"Current self-reflection\" to design better bin packing heuristics, focusing on avoiding the pitfalls of \"Ineffective self-reflection.\"\n\nHere's a revised approach to self-reflection, designed for actionable improvements:\n\n*   **Keywords:** Objective alignment, Component Interaction, Early Exit, Parameter control.\n*   **Advice:** Focus on the *interaction* of combined factors (close-fit, fill). Iteratively refine these interactions and early exits based on *empirical performance*.\n*   **Avoid:** Vague considerations (e.g., \"handle fragmentation\" without a specific implementation). Over-parameterization without demonstrable benefit.\n*   **Explanation:** Prioritize strategies grounded in data & experimentation. Don't get lost in general considerations; test specific ideas and measure the effect on performance.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}