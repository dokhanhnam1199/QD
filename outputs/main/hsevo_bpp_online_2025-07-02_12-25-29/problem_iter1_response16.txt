```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Initialize priority scores. Avoid operating directly on bins_remain_cap
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Extremely small value to avoid division by zero and log(0)
    epsilon = 1e-9

    # Find bins that can accommodate the item. This is key to avoid overflowing.
    feasible_bins = bins_remain_cap >= item

    # If no feasible bins are available, return a low priority for all bins, essentially signaling failure.
    if not np.any(feasible_bins):
        return np.full_like(bins_remain_cap, -np.inf) #Return -infinity to signal impossible placement. Prevents errors.

    #Calculate remaining capacity AFTER placing item
    post_placement_capacities = bins_remain_cap - item

    #Heuristic 1: Maximize filled space, but prioritize near full bins that CAN accommodate item
    fill_ratios = item / (bins_remain_cap + epsilon) #How "full" is this item?

    #Heuristic 2: Emphasize completely filling a bin (minimize waste).
    #This calculates the amount of space that would be wasted if the item is placed in each bin.
    waste = bins_remain_cap - item
    waste[waste < 0] = np.inf #Inf waste if the item doesn't fit.
    waste_penalty = -waste  #Penalize high waste values.
    # Apply a discount factor. This determines how important it is to fully fill the bin relative to other factors.
    # A smaller discount makes bin filling less important.
    waste_discount = 0.5

    #Heuristic 3: Moderate the influence of fill_ratios and encourage better balanced bins in the long run.
    cap_ratios = post_placement_capacities / (bins_remain_cap.max()+ epsilon) #post placement capacity to overall size of largest bin

    # Combined priority scores, weighting each factor.
    priorities[feasible_bins] = fill_ratios[feasible_bins] + waste_discount * waste_penalty[feasible_bins] + 0.2 * cap_ratios[feasible_bins]
    #If a bin is feasible it gets the fill ratio, waste penality, and bin balancing terms added together.

    #For any infeasible bins, assign them the lowest possible priority to minimize changes they are used.
    priorities[~feasible_bins] = -np.inf

    return priorities
```
