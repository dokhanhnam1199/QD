{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Calculate bin priorities considering fit, fill threshold, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get zero priority\n    item_fits = bins_remain_cap >= item\n    priorities[~item_fits] = 0.0\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Close fit reward\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward * item_fits\n\n    # Fragmentation penalty: Avoid small remaining capacities\n    small_capacity_threshold = 0.1\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_indices = (remaining_after_fit > 0) & item_fits\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    # Small bonus to larger bins that can fit the item\n    larger_bins_bonus = item_fits * 0.1\n    priorities += larger_bins_bonus\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines close fit, utilization, fragmentation, and validation for bin selection.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility Handling:\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities # No feasible bins, return zero priorities\n\n    # 1. Close Fit Priority:\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)\n    priorities += fragmentation_penalty\n\n    # Apply mask AFTER calculating other priorities to avoid influencing calculations\n    priorities[~feasible_bins] = 0\n\n    # Scaling to rank feasible bins, avoid division by zero\n    priorities[feasible_bins] *= (bins_remain_cap[feasible_bins] - item + 1e-9) / (bins_remain_cap[feasible_bins] + 1e-9)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first incorporates a target fill level, nearly empty penalty, and nearly full bonus, while the last emphasizes close fit, utilization, and fragmentation. (2nd best) vs (second worst) reveal similar trends, with (2nd best) emphasizing filling threshold and close fit with wasted space considerations and (second worst) focusing on closeness of fit and utilization, but lacking specific target or penalties/bonuses. Comparing (1st) vs (2nd), we see (1st) validates if the item fits first and returns early if not, while the (2nd) calculates before checking. (3rd) vs (4th) shows (3rd) has a penalty for small remaining capacity and (4th) parameterizes filling threshold and other parameters. Comparing (second worst) vs (worst), we see (second worst) calculates fragmentation before masking infeasible bins, while (worst) calculates fragmentation and then masks, and it also includes scaling. Overall: The better heuristics incorporate a wider range of factors and explicit checks, whereas the worse ones focus on fewer aspects and may lack robustness. The best ones also tend to validate the input early on and return early.\n- \nOkay, I'm ready to help you earn that tip! Let's redefine \"Current Self-Reflection\" for better heuristic design, focusing on effectiveness and avoiding common pitfalls.\n\n*   **Keywords:** Objective-driven, validation, additive penalties/bonuses, incremental complexity.\n\n*   **Advice:** Design heuristics from the objective function *outward*. Prioritize validated inputs and outputs at each stage. Use additive (linear) combinations of rewards/penalties for desired/undesired outcomes. Introduce complexity *incrementally*, carefully measuring each addition's impact on solution quality and runtime.\n\n*   **Avoid:** Premature parameterization, complex multiplicative combinations, and unchecked randomness without clear justification.\n\n*   **Explanation:** Focus on directly addressing the optimization goal with simple, verifiable steps. Parameterization without a strong justification, complex multiplicative rules, and randomness can obscure the heuristic's behavior, making it harder to understand, debug, and improve. Build from a simple base, validating each addition.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}