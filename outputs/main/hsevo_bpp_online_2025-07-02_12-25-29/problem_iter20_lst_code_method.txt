{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n    \n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation strategy\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n    \n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation strategy\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # Early exit: If there's a bin that fits the item perfectly, prioritize it highly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0  # High priority for perfect fit\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.0) #scale remaining capacity to 0-1\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n\n    priorities += 0.5 * target_bonus * feasible_bins\n\n    # Moderate penalty for leaving too much space\n    bin_capacity = 1.0\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * feasible_bins\n    priorities += space_left_penalty\n    \n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # Early exit: If there's a bin that fits the item perfectly, prioritize it highly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0  # High priority for perfect fit\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.0) #scale remaining capacity to 0-1\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n\n    priorities += 0.5 * target_bonus * feasible_bins\n\n    # Moderate penalty for leaving too much space\n    bin_capacity = 1.0\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * feasible_bins\n    priorities += space_left_penalty\n    \n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill target, fit, and fragmentation.\n\n    Handles no-fit scenario with smallest bin, and adds early perfect fit exit.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Perfect fit early exit\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1.0\n        return priorities\n\n    # Early exit if item doesn't fit in any bin, assign smallest bin highest priority\n    if np.all(bins_remain_cap < item):\n        priorities[np.argmin(bins_remain_cap)] = 1.0\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Whether the item fits.\n    2.  The remaining capacity after adding the item (favoring tighter fits).\n    3.  A filling threshold to encourage bins to be filled above a certain level.\n    4.  Penalizing bins that are already too full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    filling_threshold = 0.75\n\n    # 1. Check if the item fits\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return priorities  # No bin can accommodate item, return zero priorities\n\n    # 2. Remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # 3. Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # 4. Give a bonus to bins that meet the filling threshold\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.8, 0.0)  # Reduced bonus\n    priorities += threshold_bonus\n\n    # 5. Prioritize tighter fits (smaller remaining capacity)\n    # But only if the item fits.  Also avoid taking log of zero.\n    fit_priority = np.where(item_fits & (remaining_after_fit > 0), np.exp(-5 * remaining_after_fit), 0.0)\n\n    priorities += fit_priority\n\n\n    # 6. Penalize bins where the item doesn't fit at all.\n    priorities[bins_remain_cap < item] = 0\n\n    # 7. Add a small incentive to using non-empty bins if possible.  This\n    #    addresses an edge case where if all bins are empty, the algorithm\n    #    doesn't prefer one over the other.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.05 * larger_bins  # Even smaller bonus\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Close fit bonus (higher priority for less waste)\n    close_fit_priority = np.exp(-2 * (bins_remain_cap - item)) * item_fits\n    priorities += close_fit_priority\n\n    # Target fill bonus (reward bins close to full after packing)\n    fill_threshold = 0.9\n    nearly_full_bonus = np.where(item_fits & (1 - remaining_after_fit/bin_capacity >= fill_threshold), 0.5, 0)\n    priorities += nearly_full_bonus\n\n    # Fragmentation penalty (avoid small remaining space)\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity <= fragmentation_threshold), -0.25, 0)\n    priorities += fragmentation_penalty\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines target fill, close fit, and handles edge cases.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits): # Early exit if no bin can fit\n        priorities[:] = -1e9\n        priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that result in a fill level closest to a target fill level\n    after adding the item. It also considers the absolute remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_fill_level = 0.9  # Aim for bins that are nearly full\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after placing the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Calculate fill level after placing the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Prioritize bins with fill level closest to target\n    fill_level_diff = np.abs(fill_level - target_fill_level)\n    fill_priority = np.exp(-5 * fill_level_diff) * item_fits  # Exponential decay around target\n\n    priorities += fill_priority\n\n    # Penalize bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0\n\n    # Add a bonus proportional to remaining capacity *only if* the item fits. Larger free bins are less preferable\n    # This avoids completely filling small bins when bigger bins are available and a near-perfect fit is not available.\n    priorities -= 0.1 * bins_remain_cap * item_fits\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    - Ability to fit the item.\n    - Closeness to a target fill level (around 90%).\n    - Avoiding excessive fragmentation (remaining space).\n    - A tie-breaker for the fullest bin so far.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Check which bins can accommodate the item\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can fit the item, return an array of zeros.\n    if not np.any(item_fits):\n        return priorities\n        \n\n    # 1. Target Fill Level: Prioritize bins that will be close to 90% full.\n    target_fill = 0.9\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Calculate deviation from target fill; smaller deviation is better\n    deviation_from_target = np.abs(fill_level_after_fit - target_fill)\n    \n    # Give higher priority to bins closer to the target fill\n    target_priority = np.exp(-5 * deviation_from_target) * item_fits\n    priorities += target_priority\n\n    # 2. Fragmentation Penalty: Penalize bins that leave too much empty space.\n    fragmentation_penalty = np.exp(-2 * remaining_after_fit) * item_fits # Smaller remaining is better\n    priorities += fragmentation_penalty\n\n    # 3. Tie-breaker: Prioritize the fullest bin (smallest remaining cap) if multiple bins are suitable\n    # This encourages filling bins completely before starting new ones. Only apply to viable bins.\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.1 * current_fill_level * item_fits  # Small bonus for current fill.\n\n\n    # Ensure priorities for bins that don't fit the item are zero.\n    priorities[bins_remain_cap < item] = 0.0\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering close fit, target fill, and fragmentation.\n    Combines early exit with adjusted penalties.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Early exit for bins where item does not fit\n    priorities[~item_fits] = -1e9  # Large penalty\n\n    # Calculate remaining capacity and fill level\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target Fill Level Priority\n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    priorities += fill_priority\n\n    # Close Fit Priority\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Avoid Small Remaining Space\n    small_space_penalty = np.where((remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.5, 0)\n    priorities += small_space_penalty * item_fits\n\n    # Perfect Fit Early Exit\n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9 # Huge bonus for perfect fit\n        return priorities\n    \n    # Normalize priorities (handle the case where all priorities are the same)\n    if np.max(priorities) == np.min(priorities):\n        return priorities # or return np.zeros_like(priorities), depending on desired behavior\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    - Ability to fit the item.\n    - Closeness to a target fill level (around 90%).\n    - Avoiding excessive fragmentation (remaining space).\n    - A tie-breaker for the fullest bin so far.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Check which bins can accommodate the item\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can fit the item, return an array of zeros.\n    if not np.any(item_fits):\n        return priorities\n        \n\n    # 1. Target Fill Level: Prioritize bins that will be close to 90% full.\n    target_fill = 0.9\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Calculate deviation from target fill; smaller deviation is better\n    deviation_from_target = np.abs(fill_level_after_fit - target_fill)\n    \n    # Give higher priority to bins closer to the target fill\n    target_priority = np.exp(-5 * deviation_from_target) * item_fits\n    priorities += target_priority\n\n    # 2. Fragmentation Penalty: Penalize bins that leave too much empty space.\n    fragmentation_penalty = np.exp(-2 * remaining_after_fit) * item_fits # Smaller remaining is better\n    priorities += fragmentation_penalty\n\n    # 3. Tie-breaker: Prioritize the fullest bin (smallest remaining cap) if multiple bins are suitable\n    # This encourages filling bins completely before starting new ones. Only apply to viable bins.\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.1 * current_fill_level * item_fits  # Small bonus for current fill.\n\n\n    # Ensure priorities for bins that don't fit the item are zero.\n    priorities[bins_remain_cap < item] = 0.0\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, perfect_fit_priority: float = 7.105451609448277,\n                close_fit_decay: float = 2.686921869142396, filling_threshold: float = 0.8831826320232768,\n                threshold_bonus_value: float = 0.33061845641303667, min_fragment: float = 0.09103843162307605,\n                reasonable_fit_weight: float = 0.5881196697670336, large_space_threshold: float = 0.6051564579290349,\n                large_space_penalty: float = -0.28791833084639207, impossible_priority: float = -4602434002.308028,\n                bin_capacity: float = 1.1314215963432501) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, perfect_fit_priority: float = 7.105451609448277,\n                close_fit_decay: float = 2.686921869142396, filling_threshold: float = 0.8831826320232768,\n                threshold_bonus_value: float = 0.33061845641303667, min_fragment: float = 0.09103843162307605,\n                reasonable_fit_weight: float = 0.5881196697670336, large_space_threshold: float = 0.6051564579290349,\n                large_space_penalty: float = -0.28791833084639207, impossible_priority: float = -4602434002.308028,\n                bin_capacity: float = 1.1314215963432501) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, perfect_fit_priority: float = 7.105451609448277,\n                close_fit_decay: float = 2.686921869142396, filling_threshold: float = 0.8831826320232768,\n                threshold_bonus_value: float = 0.33061845641303667, min_fragment: float = 0.09103843162307605,\n                reasonable_fit_weight: float = 0.5881196697670336, large_space_threshold: float = 0.6051564579290349,\n                large_space_penalty: float = -0.28791833084639207, impossible_priority: float = -4602434002.308028,\n                bin_capacity: float = 1.1314215963432501) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, perfect_fit_priority: float = 7.105451609448277,\n                close_fit_decay: float = 2.686921869142396, filling_threshold: float = 0.8831826320232768,\n                threshold_bonus_value: float = 0.33061845641303667, min_fragment: float = 0.09103843162307605,\n                reasonable_fit_weight: float = 0.5881196697670336, large_space_threshold: float = 0.6051564579290349,\n                large_space_penalty: float = -0.28791833084639207, impossible_priority: float = -4602434002.308028,\n                bin_capacity: float = 1.1314215963432501) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How full the bin would be after adding the item (target utilization).\n    3. Remaining capacity, penalizing bins with extremely low remaining capacity after placing the item.\n    4. A bonus for bins that are close to being filled to a specified target.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    target_utilization = 0.9  # Aim for 90% full\n    min_remaining_cap = 0.05  # Avoid bins with less than 5% capacity remaining\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus: reward bins that get close to the target\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits  # Exponential decay\n    priorities += utilization_bonus\n\n    # Penalize small remaining capacity\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -1.0, 0.0)\n    priorities += low_capacity_penalty\n\n    # Encourage filling, but not too aggressively.\n    filling_incentive = (1 - remaining_after_fit) * item_fits * 0.2\n    priorities += filling_incentive\n    \n    # If no bin can fit item, return a array of -infinity, to ensure a new bin is used.\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf) #Ensures that a new bin is opened\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How full the bin would be after adding the item (target utilization).\n    3. Remaining capacity, penalizing bins with extremely low remaining capacity after placing the item.\n    4. A bonus for bins that are close to being filled to a specified target.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    target_utilization = 0.9  # Aim for 90% full\n    min_remaining_cap = 0.05  # Avoid bins with less than 5% capacity remaining\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus: reward bins that get close to the target\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits  # Exponential decay\n    priorities += utilization_bonus\n\n    # Penalize small remaining capacity\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -1.0, 0.0)\n    priorities += low_capacity_penalty\n\n    # Encourage filling, but not too aggressively.\n    filling_incentive = (1 - remaining_after_fit) * item_fits * 0.2\n    priorities += filling_incentive\n    \n    # If no bin can fit item, return a array of -infinity, to ensure a new bin is used.\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf) #Ensures that a new bin is opened\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}