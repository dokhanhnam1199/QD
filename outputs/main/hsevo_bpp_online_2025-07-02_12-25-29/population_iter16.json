[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and a desperate placement strategy.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # Desperate strategy: put in smallest bin if nothing fits\n        priorities[np.argmin(bins_remain_cap)] = 1.0\n        return priorities\n\n    # Close Fit Priority\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities[feasible_bins] += close_fit_reward[feasible_bins]\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(feasible_bins & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\nbin_capacity = 1.0\nclose_fit_decay = 2.0\nfilling_threshold = 0.75\nfragment_threshold = 0.1\nreasonable_fit_weight = 0.3\npenalty = -1e9\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and fragmentation avoidance with early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    if not np.any(item_fits):\n        priorities[:] = penalty\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-close_fit_decay * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Filling target bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > fragment_threshold)\n    priorities += reasonable_fit_weight * reasonable_fit\n\n    priorities[bins_remain_cap < item] = penalty\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.078579976067022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: target fill, fit, fragmentation, desperation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    if np.all(bins_remain_cap < item):\n        # Desperation: put in largest bin\n        priorities[np.argmax(bins_remain_cap)] = 0.001\n        return priorities\n    \n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n    \n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n    \n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1\n\n    # Prioritize bins with minimal wasted space (closest fit). Use inverse of remaining space.\n    epsilon = 1e-6\n    close_fit_priority = 0.0\n    close_fit_priority = (1.0 / (remaining_after_fit + epsilon)) * item_fits\n    priorities += close_fit_priority\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill, early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.56)\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n\n    priorities += 0.5 * target_bonus * feasible_bins\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: close fit, target fill, and no fit handling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    # Close fit (nearly full)\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 2.0 * nearly_full\n\n    #Target fill.  Bin capacity is assumed 1.56 here\n    fill_level = 1.0 - (remaining_after_fit / 1.56)\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, fit, and fragmentation; handles no-fit scenario.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin, assign smallest bin highest priority\n    if np.all(bins_remain_cap < item):\n        priorities[np.argmin(bins_remain_cap)] = 1.0\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines target fill, close fit, and fragmentation, with an early exit.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    if np.all(bins_remain_cap < item): # Early exit when no bin can fit item.\n        priorities[np.argmin(bins_remain_cap)] = 0.01  # Desperation strategy: try smallest bin\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    priorities[item_fits] += 0.1  # Larger bin bonus if item fits.\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste, nearly-full bonus, and fragmentation penalty.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    remaining_after_fit = bins_remain_cap - item\n    waste = np.where(item_fits, remaining_after_fit, np.inf)\n    waste_priority = np.where(item_fits, np.exp(-2 * waste), 0)\n    priorities += waste_priority\n\n    nearly_full_threshold = 0.1\n    nearly_full_bonus = np.where(item_fits & (remaining_after_fit <= nearly_full_threshold), 0.5, 0)\n    priorities += nearly_full_bonus\n    \n    fragmentation_threshold = 0.2\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit <= fragmentation_threshold), -0.25, 0)\n    priorities += fragmentation_penalty\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins, considering close fit, target fill, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)\n    priorities += 0.8 * reasonable_fit\n    \n    priorities[bins_remain_cap < item] = -1e9\n\n    # Desperation strategy\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 8,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines target fill, fit, and fragmentation with no-fit handling.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    # Early exit if item doesn't fit in any bin\n    if np.all(bins_remain_cap < item):\n        # Desperation strategy: put in smallest bin.\n        min_cap_idx = np.argmin(bins_remain_cap)\n        priorities[min_cap_idx] = 1.0\n        return priorities\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus with exponential decay\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n\n    # Larger bin bonus (if item fits)\n    priorities[item_fits] += 0.1\n\n    #Waste calculation\n    waste = np.where(item_fits, remaining_after_fit, np.inf)\n    waste_priority = np.where(item_fits, np.exp(-2 * waste), 0)\n    priorities += waste_priority\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.078579976067022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors,\n    including fill level, close fit, and a penalty for creating small\n    fragments. It also incorporates an early exit condition to improve\n    efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    \n    # Early exit if no bin can accommodate the item\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    # Filling threshold: aim for bins that get reasonably full\n    filling_threshold = 0.8\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Bonus for bins that meet filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority: higher priority if the item almost perfectly fits\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits  # Exponential decay\n    priorities += close_fit_priority\n    \n    # Fragmentation penalty: penalize bins that leave small remaining space\n    fragmentation_threshold = 0.2  # Maximum small fragment size\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit <= fragmentation_threshold), -0.5, 0.0)\n    priorities += fragmentation_penalty\n\n    # Slightly prioritize bins already with content to consolidate fills.\n    already_used = bins_remain_cap < bin_capacity\n    priorities += 0.05 * already_used * item_fits\n\n    # Zero out priorities for bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0.0\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with a close fit and a preference for filling bins past a threshold,\n    while incorporating a penalty for leaving too much empty space and an early exit condition.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Early exit: If there's a bin that fits the item perfectly, prioritize it highly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0  # High priority for perfect fit\n        return priorities\n\n    # Threshold bonus for bins exceeding fill threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Close-fit priority with increased sensitivity\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-10 * close_fit)  # Sharper decay for close fits\n    priorities += close_fit_priority * item_fits\n\n    # Moderate penalty for leaving too much space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # A slight incentive to use any bin that can fit the item\n    priorities += 0.1 * item_fits\n\n    # Zero out priorities for bins that cannot fit the item\n    priorities[bins_remain_cap < item] = 0.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.078579976067022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version improves upon v1 by dynamically adjusting parameters\n    based on item size and remaining bin capacities. It focuses on a\n    stronger balance between close fit and filling thresholds, with an\n    early exit for obviously unsuitable bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Early exit: If no bins can fit the item, return all zeros.\n    if np.all(bins_remain_cap < item):\n        return priorities\n\n    # Filling threshold, dynamically adjusted based on item size.\n    # Smaller items encourage higher fill levels.\n    filling_threshold = 0.7 + 0.2 * min(item, 0.3)  # Threshold between 0.7 and 0.9\n\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Bonus for meeting the filling threshold.  Increased bonus for larger items.\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0 + item, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority.  Adjust the exponent based on item size to make it more/less sensitive.\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_sensitivity = 5 + 5 * item  # Scale sensitivity with item size (larger items -> more sensitive)\n    close_fit_priority = np.exp(-close_fit_sensitivity * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Very strong penalty for bins where item doesn't fit (set to -inf to ensure never selected).\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Encourage bins to become nearly full, scale reward by the *remaining* space.\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full * (1 - remaining_after_fit) # Prefer bins with less remaining space\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 79.85640207419226,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version balances fill level targets, close fit, and bin usage efficiency,\n    with a focus on avoiding excessive fragmentation and promoting bin completion.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n\n    # Target fill level: Aim for bins close to this fill level after packing\n    target_fill = 0.9\n    fill_level_after = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Priority for bins nearing target fill level\n    target_fill_priority = np.exp(-10 * np.abs(fill_level_after - target_fill)) * item_fits\n    priorities += 0.8 * target_fill_priority\n\n    # Close fit bonus, stronger than before\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-15 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Bonus for filling bins past a minimum threshold, but only if it doesn't exceed the target.\n    min_fill = 0.6\n    min_fill_bonus = np.where(item_fits & (fill_level_after >= min_fill) & (fill_level_after <= target_fill), 0.5, 0.0)\n    priorities += min_fill_bonus\n\n    # Discourage leaving very small gaps (fragmentation)\n    small_gap_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.3, 0.0) # Reduced Penalty\n    priorities += small_gap_penalty\n\n    # Prioritize using almost-empty bins if the item is large\n    large_item_threshold = 0.7\n    almost_empty_bonus = np.where((bins_remain_cap > 0.9) & (item >= large_item_threshold), 0.4, 0.0) # Increased Bonus\n    priorities += almost_empty_bonus\n\n    # Set priority to 0 for bins where the item doesn't fit\n    priorities[~item_fits] = 0.0\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.078579976067022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Target Fill Level: Aims for a specific fill level (e.g., 90%) after adding the item.\n    2.  Close Fit: Prioritizes bins where the item fits snugly, minimizing wasted space.\n    3.  Avoidance of Small Remaining Space: Discourages leaving very small spaces in bins.\n    4. Early exit for bins where item does not fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    item_fits = bins_remain_cap >= item\n\n    #Early exit for bins where the item does not fit\n    priorities[~item_fits] = -1  # Assign lowest priority to bins where item doesn't fit\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # 1. Target Fill Level Priority:  Aim for a fill level close to 90%\n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits #Higher the fill higher priority\n    priorities += fill_priority\n\n    # 2. Close Fit Priority: Exponential decay around a perfect fit.\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits # the closer the fit the higher the priority\n    priorities += close_fit_priority\n\n    # 3. Avoid Small Remaining Space: Penalize bins that result in very small remaining space\n    small_space_penalty = np.where((remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.5, 0) #Penalize if less than 0.1\n    priorities += small_space_penalty * item_fits\n    \n    # Normalize priorities to avoid overflow.\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n    priorities[~item_fits] = 0\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_hs4.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                bin_capacity: float = 1.2759569160172228,\n                filling_threshold: float = 0.9191269880747632,\n                close_fit_exponent: float = 4.149944013885927,\n                threshold_bonus_amount: float = 0.4749164031152632,\n                min_fragment_size: float = 0.07381592148418002,\n                reasonable_fit_weight: float = 0.10632113972248464,\n                penalty_for_not_fit: float = 7409739688.148713) -> np.ndarray:\n    \"\"\"Prioritizes bins, considering close fit, target fill, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-close_fit_exponent * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), threshold_bonus_amount, 0.0)\n    priorities += threshold_bonus\n    \n    # Avoid tiny fragments\n    reasonable_fit = item_fits & (remaining_after_fit > min_fragment_size)\n    priorities += reasonable_fit_weight * reasonable_fit\n    \n    priorities[bins_remain_cap < item] = -penalty_for_not_fit\n\n    # Desperation strategy\n    if not np.any(item_fits):\n        priorities[:] = -penalty_for_not_fit\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9788591942560925,
    "exec_success": true
  }
]