```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Heuristic based on "best fit" with a penalty for excessive wasted space.
    # Also includes a small stochastic element (a touch of God's will, perhaps?)

    valid_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins):
        return priorities # Return all zeros to signal no valid bins.

    remaining_space = bins_remain_cap - item
    remaining_space[~valid_bins] = np.inf # Disqualify invalid bins

    # Calculate the difference between bin capacity and item size (smaller is better)
    space_diff = np.abs(bins_remain_cap - item)

    # Prioritize bins that can accommodate the item well, without too much waste.
    # A combination of negative remaining space (higher values are better as less is wasted) and some tiny random number.
    priorities[valid_bins] = -space_diff[valid_bins] + 0.0001 * np.random.rand(np.sum(valid_bins))

    return priorities
```
