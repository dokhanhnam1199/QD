```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Favors bins with sufficient capacity, while penalizing near-full bins and bins that cannot accommodate the item.
    Also includes a 'tidiness' term that slightly favors bins that, after packing the item, would have a remaining capacity
    close to a power of 2. This encourages more structured packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap < item:
            priorities[i] = -np.inf  # Cannot fit, lowest priority
        else:
            # Base priority based on remaining capacity after packing
            remaining_after_pack = cap - item
            priority = remaining_after_pack  # Higher remaining capacity is initially better

            # Penalize near-full bins: avoid leaving very small gaps
            if remaining_after_pack < 0.1:
                priority -= 10 # Strong penalty

            # Bonus for leaving a remainder near a power of 2, creating tidiness
            powers_of_2 = np.array([0.125, 0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0]) # Reasonable power of 2 in cap range
            closest_power_of_2 = powers_of_2[np.argmin(np.abs(powers_of_2 - remaining_after_pack))]
            tidiness_bonus = -abs(remaining_after_pack - closest_power_of_2) / 10  # Smaller difference is better
            priority += tidiness_bonus


            priorities[i] = priority

    return priorities
```
