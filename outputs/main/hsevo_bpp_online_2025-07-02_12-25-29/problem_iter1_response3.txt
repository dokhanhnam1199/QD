```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Prioritizes bins with remaining capacity slightly larger than the item size,
    but also penalizes bins that are too empty. A sweet spot is targeted.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # High priority for bins where item fits and remaining space is small
    fit_mask = bins_remain_cap >= item
    if np.any(fit_mask):
        priorities[fit_mask] = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Fraction of waste
        priorities[fit_mask] = 1 - priorities[fit_mask] # Make the less waste the highest priority
        # Small penalty for bins where remaining capacity is significantly more than item.
        # This encourages filling bins without leaving too much space.
        waste_mask = bins_remain_cap > 2 * item
        priorities[waste_mask] -= 0.1

    # Penalize bins where item does not fit.
    no_fit_mask = bins_remain_cap < item
    priorities[no_fit_mask] = -np.inf #ensure that we never pick them

    return priorities
```
