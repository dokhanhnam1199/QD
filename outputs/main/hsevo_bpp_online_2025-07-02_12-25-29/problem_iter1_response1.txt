```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers both space utilization (how full the bin would become)
    and fragmentation (how much space would be wasted if the item is added).
    Bins with capacity closest to the item size get the highest priority,
    followed by bins that would be filled close to full if the item were added.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give high priority to bins where the item almost fits perfectly
    close_fit = np.abs(bins_remain_cap - item)
    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit

    # Penalize bins where the item doesn't fit (assign zero priority)
    priorities[bins_remain_cap < item] = 0

    # Also reward bins that become nearly full after adding the item
    remaining_after_fit = bins_remain_cap - item
    nearly_full = np.exp(-np.abs(remaining_after_fit) )

    priorities += nearly_full
    # Prioritize bins with higher utilization after placement

    return priorities
```
