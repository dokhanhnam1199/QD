[
  {
    "stdout_filepath": "problem_iter23_response0.txt_stdout.txt",
    "code_path": "problem_iter23_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill level.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    \n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n\n    filling_threshold = 0.8\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    \n    priorities = close_fit_priority + threshold_bonus\n\n    priorities[bins_remain_cap < item] = 0.0\n    \n    priorities[item_fits] += 0.1\n    \n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response1.txt_stdout.txt",
    "code_path": "problem_iter23_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and fragmentation, with normalization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    priorities[~item_fits] = -1e9  # Very low priority if item doesn't fit\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    \n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    \n\n    # Normalize priorities\n    if np.any(item_fits):\n        close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n        fill_priority = fill_priority / np.max(fill_priority, initial=1e-9)\n\n    priorities = 0.6 * close_fit_priority + 0.4 * fill_priority\n\n    priorities[~item_fits] = -1e9\n    \n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n        return priorities\n    \n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response2.txt_stdout.txt",
    "code_path": "problem_iter23_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and handles edge cases.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus (normalized)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Adjusted exponent\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.8  # Adjusted target\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.7 * target_bonus * item_fits  # Adjusted weight\n\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, avoids fragmentation, and handles edge cases.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0  #desperation strategy: put in smallest bin\n        return priorities\n\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1e9\n        return priorities\n    \n    # Close fit bonus\n    close_fit_priority = np.exp(-2 * (bins_remain_cap - item)) * item_fits\n\n    # Target fill bonus\n    fill_threshold = 0.9\n    nearly_full_bonus = np.where(item_fits & (1 - remaining_after_fit/bin_capacity >= fill_threshold), 0.5, 0)\n    \n    # Fragmentation penalty\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity <= fragmentation_threshold), -0.25, 0)\n    \n    priorities = close_fit_priority + nearly_full_bonus + fragmentation_penalty\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response4.txt_stdout.txt",
    "code_path": "problem_iter23_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and desperation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n\n    # Combine close fit and target fill, normalize\n    combined_priority = close_fit_priority + 0.5*target_bonus\n    max_priority = np.max(combined_priority)\n    if max_priority > 0:\n        normalized_priority = combined_priority / max_priority\n    else:\n        normalized_priority = combined_priority\n\n    priorities = normalized_priority\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response5.txt_stdout.txt",
    "code_path": "problem_iter23_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: close fit, target fill, handles edge cases.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Target fill bonus around 75%\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.5 * target_bonus\n\n    # Desperation strategy if no bin fits\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response6.txt_stdout.txt",
    "code_path": "problem_iter23_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target utilization, and penalizes large remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n    min_remaining_cap = 0.05\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0  # High priority for perfect fit\n        return priorities\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n\n    # Penalize small remaining capacity\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -2.0, 0.0)\n    priorities += low_capacity_penalty\n\n    # Filling incentive, normalized by item size to avoid bias towards small items\n    filling_incentive = (1 - remaining_after_fit) * item_fits * 0.2 * item\n    priorities += filling_incentive\n\n    # If no bin can fit item, return a array of -infinity\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and handles edge cases.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # No fit: put in smallest bin\n    if not np.any(item_fits):\n        priorities[:] = -1e9 #make all bins have very low priority\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    target_fill = 0.8\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty (avoid small remaining space)\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n    \n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response8.txt_stdout.txt",
    "code_path": "problem_iter23_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fill level, close fit, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0 #High priority for perfect fit\n        return priorities\n    \n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n\n    fragmentation_threshold = 0.2 #Slightly higher threshold\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit < fragmentation_threshold), -0.3, 0.0)\n\n    large_space_threshold = 0.7\n    large_space_penalty = np.where(item_fits & (bins_remain_cap > large_space_threshold), -0.1, 0.0)\n\n    priorities = fill_level_priority + close_fit_priority + fragmentation_penalty + large_space_penalty\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response9.txt_stdout.txt",
    "code_path": "problem_iter23_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, and handles edge cases.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.5 * target_bonus\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    # Normalize priorities\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n    \n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response0.txt_stdout.txt",
    "code_path": "problem_iter24_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that minimize wasted space after packing the item.\n    It uses a cost function based on remaining capacity to guide the packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Cost function based on remaining capacity: penalize wasted space\n    # The closer to zero, the better the fit.  Use exponential decay to\n    # heavily penalize large remaining capacities.  Only consider bins\n    # where the item fits.\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    \n    # Invert the penalty to get a priority (lower waste = higher priority)\n    priorities = waste_penalty\n\n    # Small bonus for bins where we can fit the item at all, \n    # to prioritize using bins over leaving items unpacked.\n    priorities += 0.1 * item_fits\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response1.txt_stdout.txt",
    "code_path": "problem_iter24_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with the smallest remaining capacity that can still fit the item,\n    aiming to fill bins as completely as possible.  It also introduces a small penalty for bins that become too empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # If no bin fits, return zero priorities.\n    if not np.any(item_fits):\n      return priorities\n\n    # Give highest priority to the bin with the smallest remaining capacity where the item fits.\n    # This encourages filling bins as much as possible.\n    priorities[item_fits] = 1 / bins_remain_cap[item_fits]\n\n    # Add a bonus for bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = (remaining_after_fit >= 0) & (remaining_after_fit <= 0.1)  # Adjust threshold as needed\n    priorities[nearly_full] += 1.0\n\n    # Penalize bins that become too empty after adding the item.  This can help avoid fragmentation.\n    too_empty = (remaining_after_fit > 0.5) & item_fits # Only if item fits\n    priorities[too_empty] -= 0.5\n\n    # Ensure non-fitting bins have zero priority. This is crucial.\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response2.txt_stdout.txt",
    "code_path": "problem_iter24_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity closest to the item size\n    while avoiding excessive fragmentation. It incorporates a filling threshold\n    and a bin-selection pressure to consolidate items into fewer bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # 1. Proximity to item size: Favor bins that are a close fit for the item.\n    #    This reduces fragmentation. Use a quadratic penalty for the difference.\n    fit_difference = bins_remain_cap - item\n    proximity_priority = np.exp(-5 * (fit_difference / bin_capacity)**2) * item_fits\n    priorities += proximity_priority\n\n    # 2. Filling Threshold: Reward bins that, after adding the item, exceed a\n    #    certain fill threshold.  This promotes efficient bin utilization.\n    filling_threshold = 0.8 # aim for 80% fill\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.75, 0.0)\n    priorities += threshold_bonus\n\n\n    # 3. Bin Selection Pressure: Add a bonus for bins that are already partially full.\n    #    This encourages filling existing bins before opening new ones. The fuller\n    #    the bin, the higher the bonus, up to a point.\n\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.5 # Max bonus of 0.45\n    priorities += bin_pressure_bonus\n\n\n    # 4. Avoidance of bins where item doesn't fit. Ensure priority is strictly zero.\n    priorities[bins_remain_cap < item] = 0.0\n    \n    # 5. Slight preference for non-empty bins\n    non_empty_bonus = np.where(bins_remain_cap < bin_capacity, 0.1, 0.0) * item_fits\n    priorities += non_empty_bonus\n\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a few key factors:\n    1. Whether the item fits.\n    2. How well the item fills the bin (space utilization).\n    3. A penalty for leaving too little space (fragmentation).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Item fits check\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Calculate fill ratio if the item were placed in the bin.\n    fill_ratio = (bins_remain_cap - remaining_after_fit) / 1.0  # Assuming bin capacity is 1.0\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] = 1.0\n\n    # Reward better fill ratios.  Use a scaled fill ratio to avoid extreme values.\n    priorities[item_fits] += fill_ratio[item_fits] * 0.5\n\n    # Penalize leaving very small remaining space (fragmentation).\n    # Experiment with the threshold and penalty factor.\n    fragmentation_threshold = 0.1  # e.g., don't leave less than 10% of the bin\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit < fragmentation_threshold), -0.75, 0)\n    priorities += fragmentation_penalty\n\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.534503390506582,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response4.txt_stdout.txt",
    "code_path": "problem_iter24_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a simple best-fit approach with\n    added considerations for fill level and bin usage.  It avoids complex\n    multiplicative combinations and focuses on clear, interpretable rules.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n\n    # 1. Item Fits: Filter out bins where the item doesn't fit immediately.\n    item_fits = bins_remain_cap >= item\n    \n    #If item doesn't fit in any bins, return zero priorities to avoid errors\n    if not np.any(item_fits):\n        return priorities\n    \n    # 2. Best Fit: Prioritize bins with the smallest remaining space after placing the item.\n    remaining_after_fit = bins_remain_cap - item\n    best_fit_priority = -remaining_after_fit  # Smaller remaining = higher priority\n    best_fit_priority[remaining_after_fit < 0] = -np.inf  # Remove non-fitting bins explicitly\n\n    # 3. Fill Level Incentive:  Give a bonus for filling the bin reasonably well.\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_threshold = 0.7\n    fill_bonus = np.where((fill_level >= fill_threshold) & item_fits, 0.5, 0.0)\n\n    # 4. Use Bins: Provide a small constant bonus for any bin the item fits into.\n    bin_usage_bonus = np.where(item_fits, 0.1, 0.0)\n    \n    # Combine Priorities\n    priorities = best_fit_priority + fill_bonus + bin_usage_bonus\n    \n    # Set priority to 0 where item doesn't fit, just to be explicit.\n    priorities[bins_remain_cap < item] = 0\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response1.txt_stdout.txt",
    "code_path": "problem_iter25_code1.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, \n                bins_remain_cap: np.ndarray,\n                bin_capacity: float = 0.6668847047828119,\n                close_fit_decay: float = 5.211113402603695,\n                filling_threshold: float = 0.9193986439061714,\n                threshold_bonus_value: float = 0.9657259447902455,\n                fit_priority_bonus: float = 0.1947913473918812) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill level.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    item_fits = bins_remain_cap >= item\n    \n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-close_fit_decay * close_fit) * item_fits\n\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), threshold_bonus_value, 0.0)\n    \n    priorities = close_fit_priority + threshold_bonus\n\n    priorities[bins_remain_cap < item] = 0.0\n    \n    priorities[item_fits] += fit_priority_bonus\n    \n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  }
]