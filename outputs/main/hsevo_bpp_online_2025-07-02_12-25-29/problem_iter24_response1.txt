```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with the smallest remaining capacity that can still fit the item,
    aiming to fill bins as completely as possible.  It also introduces a small penalty for bins that become too empty.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item fits
    item_fits = bins_remain_cap >= item

    # If no bin fits, return zero priorities.
    if not np.any(item_fits):
      return priorities

    # Give highest priority to the bin with the smallest remaining capacity where the item fits.
    # This encourages filling bins as much as possible.
    priorities[item_fits] = 1 / bins_remain_cap[item_fits]

    # Add a bonus for bins that become nearly full after adding the item
    remaining_after_fit = bins_remain_cap - item
    nearly_full = (remaining_after_fit >= 0) & (remaining_after_fit <= 0.1)  # Adjust threshold as needed
    priorities[nearly_full] += 1.0

    # Penalize bins that become too empty after adding the item.  This can help avoid fragmentation.
    too_empty = (remaining_after_fit > 0.5) & item_fits # Only if item fits
    priorities[too_empty] -= 0.5

    # Ensure non-fitting bins have zero priority. This is crucial.
    priorities[bins_remain_cap < item] = 0

    return priorities
```
