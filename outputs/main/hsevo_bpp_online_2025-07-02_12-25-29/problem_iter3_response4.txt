```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version refines the priority calculation by explicitly considering:
    1.  Wasted space: A penalty for bins that would leave a significant gap.
    2.  Bin fullness: A reward for bins that would be filled to a high percentage.
    3.  Fit Score: Reward bins where item fits best (smallest remaining capacity).
    4.  Capacity utilization ratio.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Filter bins where item doesn't fit
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities # No bin can accommodate the item

    # 1. Wasted Space Penalty: Penalize bins that leave a large gap
    remaining_after_fit = bins_remain_cap - item
    wasted_space_penalty = np.exp(-remaining_after_fit[valid_bins])  # Smaller remaining space = smaller penalty
    priorities[valid_bins] += wasted_space_penalty

    # 2. Bin Fullness Reward: Reward bins close to being full
    bin_fullness = 1 - (remaining_after_fit / bins_remain_cap)[valid_bins]
    fullness_reward = np.exp(bin_fullness * 5) # Scale fullness for better impact
    priorities[valid_bins] += fullness_reward

    # 3. Fit Score: Reward bins where the item fits best
    fit_score = np.exp(-np.abs(remaining_after_fit[valid_bins]))
    priorities[valid_bins] += fit_score

    #4. Capacity Utilization Ratio: Give priority to bins with higher utilization
    capacity_utilization_ratio = (item / bins_remain_cap)[valid_bins]
    priorities[valid_bins] += capacity_utilization_ratio * 2 #Scale utilization ratio for better impact


    return priorities
```
