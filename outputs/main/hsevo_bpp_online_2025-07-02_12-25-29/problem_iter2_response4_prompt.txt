{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by Feynman's path integral formulation, we consider all possible \"paths\" (bins) and weight them based on a \"quantum action.\"\n    The \"action\" here is related to how well the item fits into the bin's remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Give zero priority to bins that cannot fit the item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, return all zeros\n\n    # Action: How much space is wasted if we place the item in this bin\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf # Penalize infeasible bins very heavily (infinity)\n\n    # \"Quantum amplitude\": e^(-action)  (More negative waste means better fit)\n    amplitudes = np.exp(-waste)\n\n    # Normalize amplitudes (to get a probability-like distribution, Feynman-style)\n    amplitudes[~feasible_bins] = 0 #ensure that we only consider feasible bins\n    if np.sum(amplitudes) > 0:\n      amplitudes = amplitudes / np.sum(amplitudes)\n    else:\n      amplitudes = np.ones_like(amplitudes) / len(amplitudes) #if they are all zero, then just divide them evenly\n\n    priorities = amplitudes # Assign probability/priority according to quantum amplitudes\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, filter out bins that cannot accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        # Calculate remaining capacity after placing the item (only for valid bins)\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        \n        # Prioritize bins where the remaining capacity is small, but not zero (almost full)\n        priorities[valid_bins] = 1 / (remaining_capacity + 1e-9) # Avoid division by zero\n\n        # Slightly boost priority for bins where item fills more than half of the bin's capacity\n        fill_ratio = item / bins_remain_cap[valid_bins]\n        priorities[valid_bins] += (fill_ratio > 0.5) * 0.5\n\n        # Penalize bins with remaining capacity close to the item size \n        # to encourage packing more than one item into a bin (prevent fragmentation)\n        close_to_item_size = np.abs(remaining_capacity - item)\n        priorities[valid_bins] -= np.exp(-close_to_item_size) * 0.2\n    else:\n        #If no bin can fit the item, assign lowest priority to all bins.\n        priorities[:] = -np.inf\n        \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses exponential decay to prioritize bins based on how closely they fit the item and how full they would become after adding the item, while the worst heuristic aims for a target fill ratio of 0.7 and adds penalties based on median capacity and excessive remaining capacity. The best also considers fragmentation, unlike the worst.\n\nComparing (2nd best) vs (second worst), we see similar approaches to the (best) vs (worst) comparison. The second-best heuristic also considers space utilization and fragmentation, using exponential decay to prioritize bins. The second worst prioritizes bins with higher remaining capacity if no bins can fit the item, and then goes on to use a target fill ratio, penalizing deviations from it.\n\nComparing (1st) vs (2nd), they are exactly identical, meaning that small variations elsewhere must influence performance.\n\nComparing (3rd) vs (4th), the 3rd uses wasted space and a fullness factor, and provides a bonus for exact fits, while the 4th uses a \"quantum action\" inspired approach, normalizing amplitudes based on wasted space to assign priorities. 3rd uses a simpler trade-off between wasted space and fullness.\n\nComparing (second worst) vs (worst), we see penalization for exceeding a proportion of item capacity.\n\nOverall: Better heuristics use a combination of rewards and penalties, focusing on minimizing wasted space and fragmentation. Exponential decay functions seem effective for prioritizing bins based on fit and fullness. Avoiding target fill ratios and directly considering wasted space seems beneficial. More successful heuristics also often have negative infinity to avoid picking the invalid bins.\nSimpler approaches with clearly defined rewards and penalties seem to outperform those inspired by more complex physical analogies.\n- \nOkay, here's a refined definition of \"Current self-reflection\" to guide heuristic design, focusing on effectiveness:\n\n*   **Keywords:** Objective-alignment, iterative refinement, evaluation, interpretable rules, reward/penalty system, constraint handling.\n\n*   **Advice:** Explicitly link heuristic components to specific objectives. Measure the impact of each design choice on performance and interpretability. Prioritize constraint satisfaction.\n\n*   **Avoid:** Premature complexity, uninterpretable rules, neglecting objective alignment, insufficient evaluation.\n\n*   **Explanation:** Focus on creating heuristics that directly optimize the target objective, adding complexity only when demonstrably beneficial and always evaluating their impact. Consider constraints early.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}