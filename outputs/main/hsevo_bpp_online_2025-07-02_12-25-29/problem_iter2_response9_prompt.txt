{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers both space utilization (how full the bin would become)\n    and fragmentation (how much space would be wasted if the item is added).\n    Bins with capacity closest to the item size get the highest priority,\n    followed by bins that would be filled close to full if the item were added.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Also reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit) )\n\n    priorities += nearly_full\n    # Prioritize bins with higher utilization after placement\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Einstein's Intuition:\n    # Maximize space utilization while preventing near-empty bins.\n    # Employ a non-linear combination of factors to balance exploration and exploitation.\n\n    # 1. Feasibility: Disqualify bins that are too small.\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf  # Assign lowest priority if not feasible\n\n    # 2. Space Utilization Factor:\n    # How much of the bin's capacity will be used.\n    utilization = item / bins_remain_cap[feasible_bins]\n\n    # 3. Remaining Capacity Factor:\n    # We prefer bins where there will still be some capacity left.\n    remaining_capacity_after_fit = bins_remain_cap[feasible_bins] - item\n    normalized_remaining = remaining_capacity_after_fit / np.max(bins_remain_cap)  # Normalize to [0,1]\n\n\n    # 4. Einsteinian Blend: A non-linear combination.\n    # Emphasis on near full, without penalizing more filled bins too much\n    # Balance utilization (avoiding waste) with leaving some room for future items.\n    # The square root adds a damping effect. Small changes when bin near full\n\n    # Avoiding small values for remaining cap which could have caused instability:\n    priorities[feasible_bins] = np.sqrt(utilization) * (1 + normalized_remaining)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses exponential decay to prioritize bins based on how closely they fit the item and how full they would become after adding the item, while the worst heuristic aims for a target fill ratio of 0.7 and adds penalties based on median capacity and excessive remaining capacity. The best also considers fragmentation, unlike the worst.\n\nComparing (2nd best) vs (second worst), we see similar approaches to the (best) vs (worst) comparison. The second-best heuristic also considers space utilization and fragmentation, using exponential decay to prioritize bins. The second worst prioritizes bins with higher remaining capacity if no bins can fit the item, and then goes on to use a target fill ratio, penalizing deviations from it.\n\nComparing (1st) vs (2nd), they are exactly identical, meaning that small variations elsewhere must influence performance.\n\nComparing (3rd) vs (4th), the 3rd uses wasted space and a fullness factor, and provides a bonus for exact fits, while the 4th uses a \"quantum action\" inspired approach, normalizing amplitudes based on wasted space to assign priorities. 3rd uses a simpler trade-off between wasted space and fullness.\n\nComparing (second worst) vs (worst), we see penalization for exceeding a proportion of item capacity.\n\nOverall: Better heuristics use a combination of rewards and penalties, focusing on minimizing wasted space and fragmentation. Exponential decay functions seem effective for prioritizing bins based on fit and fullness. Avoiding target fill ratios and directly considering wasted space seems beneficial. More successful heuristics also often have negative infinity to avoid picking the invalid bins.\nSimpler approaches with clearly defined rewards and penalties seem to outperform those inspired by more complex physical analogies.\n- \nOkay, here's a refined definition of \"Current self-reflection\" to guide heuristic design, focusing on effectiveness:\n\n*   **Keywords:** Objective-alignment, iterative refinement, evaluation, interpretable rules, reward/penalty system, constraint handling.\n\n*   **Advice:** Explicitly link heuristic components to specific objectives. Measure the impact of each design choice on performance and interpretability. Prioritize constraint satisfaction.\n\n*   **Avoid:** Premature complexity, uninterpretable rules, neglecting objective alignment, insufficient evaluation.\n\n*   **Explanation:** Focus on creating heuristics that directly optimize the target objective, adding complexity only when demonstrably beneficial and always evaluating their impact. Consider constraints early.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}