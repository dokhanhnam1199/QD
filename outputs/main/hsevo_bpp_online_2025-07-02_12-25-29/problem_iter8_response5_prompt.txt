{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a slight preference\n    for bins that are already somewhat full. It also adds a penalty for creating\n    very small fragments.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit: Prioritize bins where the item almost fits perfectly.\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay\n\n    # 2. Infeasibility: Penalize bins where the item doesn't fit (assign zero priority).\n    priorities[bins_remain_cap < item] = 0\n\n    # 3. Nearly Full: Reward bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full\n\n    # 4. Already Occupied: Slight preference for bins that are already somewhat full.\n    #    This encourages filling existing bins before opening new ones.\n    already_occupied = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Normalized remaining capacity\n    priorities += 0.5 * already_occupied # Reduced coefficient\n\n    # 5. Fragmentation Penalty: Penalize bins where the item would leave a very small fragment.\n    small_fragment_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_fragment_indices = np.where((bins_remain_cap >= item) & (remaining_after_fit > 0) & (remaining_after_fit < 0.1)) # Fragments smaller than 0.1\n    small_fragment_penalty[small_fragment_indices] = -1 # Penalty \n    priorities += small_fragment_penalty\n\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the 1st doesn't include calculating `wasted_space` to be `inf` to avoid errors, the 20th does. The 1st adds a boost priority to larger bins to promote using any bins over nothing. Comparing (1st) vs (6th), we see the 1st utilizes a filling threshold and gives a bonus, where the 6th considers a filling threshold. Comparing (2nd best) vs (second worst), we see the 2nd and 19th codes are almost identical, save for a small coefficient. Comparing (1st) vs (2nd), we see the codes are identical. Comparing (3rd) vs (4th), we see the codes are identical. Comparing (second worst) vs (worst), we see that the 19th initializes `possible_bins` and validates if they exist before proceeding. The 20th also includes `1e-9` to avoid divide-by-zero errors. Overall: The better heuristics take into account filling thresholds, and are concerned with errors arising with division and invalid conditions.\n- \nOkay, let's refine \"Current Self-Reflection\" to focus on actionable insights for better heuristic design, steering clear of the pitfalls outlined in \"Ineffective Self-Reflection.\"\n\nHere's a revised approach:\n\n*   **Keywords:** Robustness, validation, directness, impact analysis, avoidance.\n*   **Advice:** Implement validation checks during heuristic execution. Combine factors additively where possible. Explicitly address edge cases such as infeasible bins.\n*   **Avoid:** Blindly adding complexity, multiplicative combinations of factors without strong justification. Over-reliance on randomness that obscures heuristic logic.\n*   **Explanation:** Focus on creating robust heuristics by checking for possible errors before and after bin selections. Evaluate the real impact after adding each new factor.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}