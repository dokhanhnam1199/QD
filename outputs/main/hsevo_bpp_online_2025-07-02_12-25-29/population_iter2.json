[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness using exponential decay.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = 0\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Add negative infinite priority for invalid bins\n    priorities[~possible_bins] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on space utilization and remaining capacity.\"\"\"\n\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf\n\n    if np.any(feasible_bins):\n        utilization = item / bins_remain_cap[feasible_bins]\n        remaining_capacity = bins_remain_cap[feasible_bins] - item\n        normalized_remaining = remaining_capacity / np.max(bins_remain_cap)\n\n        priorities[feasible_bins] = np.sqrt(utilization) * (1 + normalized_remaining)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 64.31990426804947,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority score for each bin.\n    Combines close fit via exponential decay with a fullness reward.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities # all zeros. This should trigger adding new bin in the higher level function\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = 0\n\n    # Fullness reward, avoid nearly empty bins\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    priorities[~possible_bins] = -1000\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines wasted space minimization with fullness consideration.\"\"\"\n\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize bins becoming nearly full, avoid division by zero\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    priorities[feasible_bins] = close_fit_reward * nearly_full_penalty\n\n    # Bonus for exact fit\n    exact_fit = wasted_space == 0\n    priorities[feasible_bins][exact_fit] += 1.0\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and fullness, using exponential decay.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities[:] = -np.inf\n        return priorities\n\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf\n\n    # Prioritize bins with smaller waste using exponential decay\n    priorities[feasible_bins] = np.exp(-waste[feasible_bins])\n\n    # Boost priority for bins that are almost full after adding the item\n    remaining_capacity = bins_remain_cap[feasible_bins] - item\n    almost_full = remaining_capacity < (0.1 * bins_remain_cap[feasible_bins]) #within 10%\n    priorities[feasible_bins][almost_full] += 0.5\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on minimizing waste and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for near-perfect fits, minimizing waste.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        waste = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = np.exp(-5 * waste / item)  # Exponential decay based on waste\n\n        # Penalize bins that are too empty to reduce fragmentation.\n        waste_mask = bins_remain_cap > 2 * item\n        priorities[waste_mask] -= 0.1 * (bins_remain_cap[waste_mask] - 2 * item) / item\n\n    # Ensure invalid bins are never picked.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space, fullness, and exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Wasted space calculation (exclude infeasible)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize nearly full bins exponentially\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Combine rewards and penalties\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Encourage filling bins already somewhat full + randomness\n    priorities += bins_remain_cap * 0.01 + np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 149.10251296370166,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and fullness, combining ideas.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exclude bins that cannot fit the item, or make wasted space computation\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward bins with small wasted space (close fit)\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize bins that become nearly full after adding the item\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Combine reward and penalty\n    priorities = close_fit_reward * nearly_full_penalty\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining fit proximity and capacity.\"\"\"\n\n    difference = bins_remain_cap - item\n    difference = np.where(difference >= 0, difference, np.inf)\n\n    priorities = np.where(difference != np.inf, np.exp(-5 * difference) * (bins_remain_cap**0.5), -np.inf)\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and resulting fullness, using exponential decay.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities[feasible_bins] = np.exp(-close_fit[feasible_bins])\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]