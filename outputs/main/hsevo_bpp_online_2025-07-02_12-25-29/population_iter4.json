[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness using exponential decay.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = 0\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Add negative infinite priority for invalid bins\n    priorities[~possible_bins] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on space utilization and remaining capacity.\"\"\"\n\n    feasible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[~feasible_bins] = -np.inf\n\n    if np.any(feasible_bins):\n        utilization = item / bins_remain_cap[feasible_bins]\n        remaining_capacity = bins_remain_cap[feasible_bins] - item\n        normalized_remaining = remaining_capacity / np.max(bins_remain_cap)\n\n        priorities[feasible_bins] = np.sqrt(utilization) * (1 + normalized_remaining)\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 64.31990426804947,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority score for each bin.\n    Combines close fit via exponential decay with a fullness reward.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities # all zeros. This should trigger adding new bin in the higher level function\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = 0\n\n    # Fullness reward, avoid nearly empty bins\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    priorities[~possible_bins] = -1000\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines wasted space minimization with fullness consideration.\"\"\"\n\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize bins becoming nearly full, avoid division by zero\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    priorities[feasible_bins] = close_fit_reward * nearly_full_penalty\n\n    # Bonus for exact fit\n    exact_fit = wasted_space == 0\n    priorities[feasible_bins][exact_fit] += 1.0\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and fullness, using exponential decay.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        priorities[:] = -np.inf\n        return priorities\n\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf\n\n    # Prioritize bins with smaller waste using exponential decay\n    priorities[feasible_bins] = np.exp(-waste[feasible_bins])\n\n    # Boost priority for bins that are almost full after adding the item\n    remaining_capacity = bins_remain_cap[feasible_bins] - item\n    almost_full = remaining_capacity < (0.1 * bins_remain_cap[feasible_bins]) #within 10%\n    priorities[feasible_bins][almost_full] += 0.5\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on minimizing waste and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # High priority for near-perfect fits, minimizing waste.\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        waste = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = np.exp(-5 * waste / item)  # Exponential decay based on waste\n\n        # Penalize bins that are too empty to reduce fragmentation.\n        waste_mask = bins_remain_cap > 2 * item\n        priorities[waste_mask] -= 0.1 * (bins_remain_cap[waste_mask] - 2 * item) / item\n\n    # Ensure invalid bins are never picked.\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space, fullness, and exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Wasted space calculation (exclude infeasible)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize nearly full bins exponentially\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Combine rewards and penalties\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Encourage filling bins already somewhat full + randomness\n    priorities += bins_remain_cap * 0.01 + np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 149.10251296370166,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and fullness, combining ideas.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exclude bins that cannot fit the item, or make wasted space computation\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward bins with small wasted space (close fit)\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize bins that become nearly full after adding the item\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Combine reward and penalty\n    priorities = close_fit_reward * nearly_full_penalty\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 5.195452732349436,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining fit proximity and capacity.\"\"\"\n\n    difference = bins_remain_cap - item\n    difference = np.where(difference >= 0, difference, np.inf)\n\n    priorities = np.where(difference != np.inf, np.exp(-5 * difference) * (bins_remain_cap**0.5), -np.inf)\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and resulting fullness, using exponential decay.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities[feasible_bins] = np.exp(-close_fit[feasible_bins])\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version refines the priority calculation by explicitly considering\n    the wasted space ratio and introducing a saturation mechanism to prevent\n    over-emphasis on nearly-full bins. It also adds a small bonus for bins\n    that are already somewhat full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect Fit:  Prioritize bins where the item fits almost perfectly.\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit * 5)  # Sharper exponential decay\n\n    # 2. Constraint Handling: Zero priority if the item doesn't fit.\n    priorities[bins_remain_cap < item] = 0\n\n    # 3. Near-Full Reward (with Saturation): Reward bins that become nearly full,\n    #    but with diminishing returns as they get closer to completely full.\n    remaining_after_fit = bins_remain_cap - item\n    utilization = (bins_remain_cap - remaining_after_fit) / bins_remain_cap\n    nearly_full = np.exp(-np.abs(remaining_after_fit) * 2) * (1 - utilization)**0.5 # Soft saturation\n\n    priorities += nearly_full\n\n    # 4. Wasted Space Penalty:  Penalize bins based on the proportion of space wasted.\n    wasted_space_ratio = np.abs(remaining_after_fit) / bins_remain_cap\n    priorities -= wasted_space_ratio * 0.5 # Moderate penalty\n\n    # 5. Initial fullness Bonus\n    initial_fullness = (1 - bins_remain_cap)\n    priorities += initial_fullness *0.1\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Closeness of fit (how well the item fits in the bin).\n    2. Fill level after adding the item (encourages full bins).\n    3. Avoidance of small remaining capacities (reduces fragmentation).\n    4. A slight preference for bins that are already somewhat full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Closeness of fit (higher priority for bins where the item fits well)\n    fit_difference = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-fit_difference * 2)  # Sharper exponential decay\n\n    # Penalize bins where the item doesn't fit (zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. Fill level after adding the item (encourage full bins)\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1 - np.abs(remaining_after_fit) / np.max(bins_remain_cap) # Scale to bin size\n    priorities += fill_level * 0.75 # Weigh fill level\n\n    # 3. Avoid small remaining capacities (reduce fragmentation)\n    #   Penalize bins that would have very small remaining capacity.  Apply penalty only if it fits\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_capacity_threshold = 0.1  # Fraction of max bin capacity\n    small_capacity_penalty[remaining_after_fit > 0 ] = np.exp(-remaining_after_fit[remaining_after_fit > 0 ] / small_capacity_threshold)\n    \n    priorities[remaining_after_fit > 0 ] -= small_capacity_penalty[remaining_after_fit > 0 ]* 0.5\n\n    # 4. Prefer bins that are already somewhat full (helps consolidate items)\n    initial_fullness = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    priorities += initial_fullness * 0.25 # Weigh initial fullness less\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Closeness of fit: Bins where the item fits nearly perfectly get a high priority.\n    2. Resulting fragmentation: Bins that would leave minimal wasted space after adding the item are favored.\n    3. Avoidance of near-empty bins: Penalizes bins that, after adding the item, are still far from full.\n    4. Considers a minimum threshold for bin utilization to avoid extreme fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Closeness of fit: Exponential decay around the perfect fit.\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)  # Increased sensitivity to close fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. Reward bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit)) # Increased sensitivity\n\n    priorities += nearly_full\n\n    # 3. Penalize bins that remain far from full. Encourage utilization.\n    # Avoid adding items to bins that will still be mostly empty\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same capacity\n    utilization = (bin_size - remaining_after_fit) / bin_size\n    empty_penalty = np.exp(-5 * (1 - utilization)) # Stronger penalty for low utilization\n    priorities *= empty_penalty # Reduced impact if poorly utilized\n\n\n    # 4. Minimum utilization threshold to reduce extreme fragmentation\n    min_utilization_threshold = 0.2  # e.g., require at least 20% utilization.\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = 0  # Zero out priorities for bins below utilization threshold\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a slight preference\n    for bins that are already somewhat full. It also introduces a more nuanced\n    penalty for bins that would result in very small remaining capacities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect Fit: Highest priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit * 2)  # Sharper exponential decay\n\n    # 2. Item Doesn't Fit: Zero priority\n    priorities[bins_remain_cap < item] = 0\n\n    # 3. Nearly Full: Reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit) * 2) # Sharper decay\n    priorities += nearly_full * 0.8 # Reduced weight compared to perfect fit\n\n    # 4. Existing Fill Level: Slight preference for bins that are already somewhat full\n    #    This encourages filling existing bins before starting new ones.\n    existing_fill = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize remaining capacity\n    priorities += existing_fill * 0.2  # Small contribution\n\n    # 5. Fragmentation Penalty: Penalize bins that would result in very small remaining capacities.\n    #    This aims to avoid creating many bins with tiny amounts of space left.\n    very_small_remaining = remaining_after_fit < 0.1 #tuneable parameter\n    priorities[very_small_remaining] *= 0.5  # Reduce priority if fragmentation is high\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version refines the priority calculation by explicitly considering:\n    1.  Wasted space: A penalty for bins that would leave a significant gap.\n    2.  Bin fullness: A reward for bins that would be filled to a high percentage.\n    3.  Fit Score: Reward bins where item fits best (smallest remaining capacity).\n    4.  Capacity utilization ratio.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins where item doesn't fit\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities # No bin can accommodate the item\n\n    # 1. Wasted Space Penalty: Penalize bins that leave a large gap\n    remaining_after_fit = bins_remain_cap - item\n    wasted_space_penalty = np.exp(-remaining_after_fit[valid_bins])  # Smaller remaining space = smaller penalty\n    priorities[valid_bins] += wasted_space_penalty\n\n    # 2. Bin Fullness Reward: Reward bins close to being full\n    bin_fullness = 1 - (remaining_after_fit / bins_remain_cap)[valid_bins]\n    fullness_reward = np.exp(bin_fullness * 5) # Scale fullness for better impact\n    priorities[valid_bins] += fullness_reward\n\n    # 3. Fit Score: Reward bins where the item fits best\n    fit_score = np.exp(-np.abs(remaining_after_fit[valid_bins]))\n    priorities[valid_bins] += fit_score\n\n    #4. Capacity Utilization Ratio: Give priority to bins with higher utilization\n    capacity_utilization_ratio = (item / bins_remain_cap)[valid_bins]\n    priorities[valid_bins] += capacity_utilization_ratio * 2 #Scale utilization ratio for better impact\n\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, close_fit_decay_rate: float = 0.6505133384421425, nearly_full_decay_rate: float = 0.26884864193173436) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness using exponential decay.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "exec_success": true
  }
]