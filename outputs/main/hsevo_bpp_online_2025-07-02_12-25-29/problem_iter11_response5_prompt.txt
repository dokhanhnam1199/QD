{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Whether the item fits.\n    2.  How close the resulting fill level is to an ideal target.\n    3.  A penalty for bins that would become nearly empty.\n    4.  A bonus for bins that would become nearly full.\n    5. Validation to check if item fits.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    \n    # Check if the item fits in any of the bins, if not return all zero priorities\n    if np.all(bins_remain_cap < item):\n        return priorities\n    \n    # 1. Item Fit Check\n    item_fits = bins_remain_cap >= item\n    \n    # Set priority to 0 for bins where item doesn't fit\n    priorities[~item_fits] = 0.0\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # 2. Target Fill Level\n    target_fill = 0.85\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n    \n    # 3. Nearly Empty Penalty\n    nearly_empty_threshold = 0.2\n    nearly_empty = remaining_after_fit / bin_capacity > nearly_empty_threshold\n    priorities[nearly_empty & item_fits] -= 0.2 # Reduced penalty for stability.\n\n    # 4. Nearly Full Bonus\n    nearly_full_threshold = 0.95\n    nearly_full = fill_level_after_fit >= nearly_full_threshold\n    priorities[nearly_full & item_fits] += 0.5\n    \n    # 5. Prioritize larger bins that can accomodate the item.\n    larger_bins = bins_remain_cap >= item\n    priorities += 0.1 * larger_bins\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Combines filling threshold, close fit, and avoids fragmentation.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    priorities[bins_remain_cap < item] = 0\n\n    small_remaining = remaining_after_fit < 0.1\n    priorities[item_fits & small_remaining] -= 0.5\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first incorporates a target fill level, nearly empty penalty, and nearly full bonus, while the last emphasizes close fit, utilization, and fragmentation. (2nd best) vs (second worst) reveal similar trends, with (2nd best) emphasizing filling threshold and close fit with wasted space considerations and (second worst) focusing on closeness of fit and utilization, but lacking specific target or penalties/bonuses. Comparing (1st) vs (2nd), we see (1st) validates if the item fits first and returns early if not, while the (2nd) calculates before checking. (3rd) vs (4th) shows (3rd) has a penalty for small remaining capacity and (4th) parameterizes filling threshold and other parameters. Comparing (second worst) vs (worst), we see (second worst) calculates fragmentation before masking infeasible bins, while (worst) calculates fragmentation and then masks, and it also includes scaling. Overall: The better heuristics incorporate a wider range of factors and explicit checks, whereas the worse ones focus on fewer aspects and may lack robustness. The best ones also tend to validate the input early on and return early.\n- \nOkay, I'm ready to help you earn that tip! Let's redefine \"Current Self-Reflection\" for better heuristic design, focusing on effectiveness and avoiding common pitfalls.\n\n*   **Keywords:** Objective-driven, validation, additive penalties/bonuses, incremental complexity.\n\n*   **Advice:** Design heuristics from the objective function *outward*. Prioritize validated inputs and outputs at each stage. Use additive (linear) combinations of rewards/penalties for desired/undesired outcomes. Introduce complexity *incrementally*, carefully measuring each addition's impact on solution quality and runtime.\n\n*   **Avoid:** Premature parameterization, complex multiplicative combinations, and unchecked randomness without clear justification.\n\n*   **Explanation:** Focus on directly addressing the optimization goal with simple, verifiable steps. Parameterization without a strong justification, complex multiplicative rules, and randomness can obscure the heuristic's behavior, making it harder to understand, debug, and improve. Build from a simple base, validating each addition.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}