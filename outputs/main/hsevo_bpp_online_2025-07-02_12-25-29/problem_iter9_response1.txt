```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits, with added robustness
    and direct impact considerations.  It aims to minimize fragmentation
    and promote efficient space utilization, especially focusing on bins
    becoming close to full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed
    item_fits = bins_remain_cap >= item

    # Validation: Ensure no negative remaining capacities sneak in.
    if np.any(bins_remain_cap < 0):
        raise ValueError("Negative bin capacity detected.  Check input data.")
        
    # 1. Close-to-Full Prioritization:  Strongest signal.
    remaining_after_fit = bins_remain_cap - item
    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits  #Sharper peak
    priorities += 2.0 * nearly_full  # Increased weight

    # 2. Preventative Fragmentation Minimization:
    # Prioritize bins where the item fits *reasonably* well, but avoids very tight fits
    # that could cause tiny unusable fragments.
    reasonable_fit = item_fits & (remaining_after_fit > 0.05)  # Avoid tiny fragments
    priorities += 0.8 * reasonable_fit # Moderate boost

    # 3. Bins Larger Than Item Bonus, but Diminishing Returns with size:
    # Encourages using bins, but avoids overly large allocations if better options exist.
    larger_bins = (bins_remain_cap >= item)
    size_difference = bins_remain_cap - item
    # Use a log or sqrt to give diminishing returns for very large empty spaces.
    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins
    priorities += 0.3 * larger_bin_bonus

    # 4. "Desperation" Move: If no bin fits, severely penalize all bins.  This practically forces
    # the algorithm to open a new bin.  This prevents weird oscillations.  Check first if an item fits in any bin.
    if not np.any(item_fits):
        priorities[:] = -1e9  # Huge negative priority
        # Check if there are any bins, to avoid an error if the array is empty.
        if len(priorities) > 0:
           priorities[np.argmin(bins_remain_cap)] = 0  #Allows it to add item to emptiest bin if nothing fits
    else:
        # Zero out priorities for bins where the item doesn't fit. Necessary after the potential "desperation" reset.
        priorities[bins_remain_cap < item] = -1e9

    return priorities
```
