[
  {
    "stdout_filepath": "problem_iter20_response0.txt_stdout.txt",
    "code_path": "problem_iter20_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1e9  # Max priority for perfect fit\n        return priorities\n\n    # Close fit bonus (higher priority for less waste)\n    close_fit_priority = np.exp(-2 * (bins_remain_cap - item)) * item_fits\n\n    # Target fill bonus (reward bins close to full after packing)\n    fill_threshold = 0.9\n    nearly_full_bonus = np.where(item_fits & (1 - remaining_after_fit/bin_capacity >= fill_threshold), 0.5, 0)\n\n    # Fragmentation penalty (avoid small remaining space)\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity <= fragmentation_threshold), -0.25, 0)\n\n    # Combine all factors, normalizing the close fit.\n    priorities = close_fit_priority + nearly_full_bonus + fragmentation_penalty\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response1.txt_stdout.txt",
    "code_path": "problem_iter20_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill and close fit, with fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0 # Assume bin capacity is 1\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits): # Handle edge case: item doesn't fit in any bin\n        priorities[:] = -1e9 # Very low priority\n        priorities[np.argmin(bins_remain_cap)] = 0  # Put in the least full bin if it doesn't fit\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits #Target fill.\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits  # Close fit\n\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit < fragmentation_threshold), -0.3, 0.0)\n\n    priorities = fill_level_priority + close_fit_priority + fragmentation_penalty #Sum up the priorities\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response2.txt_stdout.txt",
    "code_path": "problem_iter20_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill, close fit, and avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_fill_level = 0.9\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target Fill Priority\n    fill_level_diff = np.abs(fill_level - target_fill_level)\n    fill_priority = np.exp(-5 * fill_level_diff) * item_fits\n    priorities += fill_priority\n\n    # Close Fit Priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    priorities[bins_remain_cap < item] = 0  # Infeasible bins\n\n    # Fragmentation Penalty\n    priorities -= 0.1 * bins_remain_cap * item_fits\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill priority\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / bin_capacity)\n    target_fill = 0.9\n    target_bonus = np.exp(-5.0 * np.abs(fill_level - target_fill))\n    priorities += 0.7 * target_bonus * feasible_bins\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response4.txt_stdout.txt",
    "code_path": "problem_iter20_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and fragmentation avoidance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # No fit: put in smallest bin\n    if not np.any(item_fits):\n        priorities[np.argmin(bins_remain_cap)] = 0.1\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response5.txt_stdout.txt",
    "code_path": "problem_iter20_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill target, close fit, avoids fragmentation, normalizes.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    item_fits = bins_remain_cap >= item\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.8, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Penalize bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0\n\n    # Normalize priorities.  Important for balancing factors.\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n    min_remaining_cap = 0.05\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 2.0  # High priority for perfect fit\n        return priorities\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n\n    # Penalize small remaining capacity\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -1.0, 0.0)\n    priorities += low_capacity_penalty\n\n    filling_incentive = (1 - remaining_after_fit) * item_fits * 0.2\n    priorities += filling_incentive\n\n    # If no bin can fit item, return a array of -infinity\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response7.txt_stdout.txt",
    "code_path": "problem_iter20_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response8.txt_stdout.txt",
    "code_path": "problem_iter20_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining close fit, target fill, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    priorities[~item_fits] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    priorities += fill_priority\n\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    small_space_penalty = np.where((remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.5, 0)\n    priorities += small_space_penalty * item_fits\n\n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n        return priorities\n    \n    if np.max(priorities) == np.min(priorities):\n        return priorities\n\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 0.1  # Small bonus for fitting\n\n    # Avoid bins with less than 5% capacity remaining\n    min_remaining_cap = 0.05\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -0.2, 0.0)\n    priorities += low_capacity_penalty * item_fits\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response9.txt_stdout.txt",
    "code_path": "problem_iter20_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill target and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    if not np.any(item_fits):\n        return priorities\n\n    # Target Fill Level\n    target_fill = 0.9\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    deviation_from_target = np.abs(fill_level_after_fit - target_fill)\n    priorities += np.exp(-5 * deviation_from_target) * item_fits\n\n    # Fragmentation Penalty\n    fragmentation_penalty = np.exp(-2 * remaining_after_fit) * item_fits\n    priorities += fragmentation_penalty\n\n    # Fullest bin tie-breaker\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.1 * current_fill_level * item_fits\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1.0\n        return priorities\n    \n    priorities[bins_remain_cap < item] = 0.0\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  }
]