{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.5 * target_bonus * item_fits\n\n\n    #Penalty for large remaining space\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * item_fits\n    priorities += space_left_penalty\n\n    # Desperation strategy: If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by combining close fit, target fill, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    priorities[~item_fits] = -1e9\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    priorities += fill_priority\n\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    small_space_penalty = np.where((remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.5, 0)\n    priorities += small_space_penalty * item_fits\n\n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n        return priorities\n    \n    if np.max(priorities) == np.min(priorities):\n        return priorities\n\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-9)\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 0.1  # Small bonus for fitting\n\n    # Avoid bins with less than 5% capacity remaining\n    min_remaining_cap = 0.05\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -0.2, 0.0)\n    priorities += low_capacity_penalty * item_fits\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version combines closeness-of-fit and fullness with normalization.\n    It prioritizes bins where the item fits, aiming for optimal fill levels,\n    while explicitly handling edge cases and balancing different criteria.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Closeness-of-fit priority (normalized)\n    remaining_after_fit = bins_remain_cap - item\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit)\n    close_fit_priority[~item_fits] = 0  # Zero priority if item doesn't fit\n    close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n\n    # Fullness priority (normalized)\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    fullness_priority = fill_level * item_fits  # Only consider if item fits\n    fullness_priority = fullness_priority / np.max(fullness_priority, initial=1e-9)\n\n    # Combined priority (weighted sum, normalized)\n    priorities = 0.6 * close_fit_priority + 0.4 * fullness_priority\n\n    # Encourage filling bins beyond a threshold\n    filling_threshold = 0.8\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n\n    # Explicitly handle bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Small bonus for bins that can fit the item (prioritize packing something)\n    priorities[item_fits] += 0.1\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version combines closeness-of-fit and fullness, with normalization\n    to balance the factors. It focuses on bins where the item fits and\n    prioritizes those that result in high fill levels or close-to-perfect fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Closeness-of-fit priority (normalized)\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9) # Normalize\n\n    # Fullness priority (normalized) - prioritize higher fill levels\n    fullness_priority = fill_level * item_fits\n    fullness_priority = fullness_priority / np.max(fullness_priority, initial=1e-9) # Normalize\n\n    # Combine priorities (direct combination)\n    priorities = 0.6 * close_fit_priority + 0.4 * fullness_priority  # Weighted average\n\n    # Ensure bins where item doesn't fit have zero priority\n    priorities[bins_remain_cap < item] = 0\n\n    # Small bonus for using any available space\n    priorities[item_fits] += 0.05\n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    # Target fill priority\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / bin_capacity)\n    target_fill = 0.9\n    target_bonus = np.exp(-5.0 * np.abs(fill_level - target_fill))\n    priorities += 0.7 * target_bonus * feasible_bins\n    \n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, target fill, avoids fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1e9  # Max priority for perfect fit\n        return priorities\n\n    # Close fit bonus (higher priority for less waste)\n    close_fit_priority = np.exp(-2 * (bins_remain_cap - item)) * item_fits\n\n    # Target fill bonus (reward bins close to full after packing)\n    fill_threshold = 0.9\n    nearly_full_bonus = np.where(item_fits & (1 - remaining_after_fit/bin_capacity >= fill_threshold), 0.5, 0)\n\n    # Fragmentation penalty (avoid small remaining space)\n    fragmentation_threshold = 0.1\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity <= fragmentation_threshold), -0.25, 0)\n\n    # Combine all factors, normalizing the close fit.\n    priorities = close_fit_priority + nearly_full_bonus + fragmentation_penalty\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version combines closeness-of-fit and fullness after packing, with normalization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n\n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Closeness-of-fit priority (normalized)\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    \n    # Fullness after packing priority (normalized)\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    fullness_priority = fill_level * item_fits\n\n    # Combine and normalize the priorities\n    combined_priority = close_fit_priority + fullness_priority\n    \n    # Normalize priorities to a 0-1 range to avoid domination by either factor.\n    max_priority = np.max(combined_priority)\n    if max_priority > 0:\n        normalized_priority = combined_priority / max_priority\n    else:\n        normalized_priority = combined_priority # All zeros, no normalization needed\n    \n    priorities = normalized_priority\n\n    # Penalize bins where the item doesn't fit by assigning zero priority\n    priorities[bins_remain_cap < item] = 0.0\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill target, close fit, avoids fragmentation, normalizes.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    item_fits = bins_remain_cap >= item\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.8, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Penalize bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0\n\n    # Normalize priorities.  Important for balancing factors.\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n    min_remaining_cap = 0.05\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 2.0  # High priority for perfect fit\n        return priorities\n\n    # Prioritize bins where the item fits\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n\n    # Penalize small remaining capacity\n    low_capacity_penalty = np.where(remaining_after_fit < min_remaining_cap, -1.0, 0.0)\n    priorities += low_capacity_penalty\n\n    filling_incentive = (1 - remaining_after_fit) * item_fits * 0.2\n    priorities += filling_incentive\n\n    # If no bin can fit item, return a array of -infinity\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf)\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and fragmentation avoidance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # No fit: put in smallest bin\n    if not np.any(item_fits):\n        priorities[np.argmin(bins_remain_cap)] = 0.1\n        return priorities\n\n    # Close fit bonus\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n\n    # Fragmentation penalty\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit/bin_capacity < fragmentation_threshold), -0.3, 0.0)\n    priorities += fragmentation_penalty\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on target fill and close fit, with fragmentation penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0 # Assume bin capacity is 1\n\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits): # Handle edge case: item doesn't fit in any bin\n        priorities[:] = -1e9 # Very low priority\n        priorities[np.argmin(bins_remain_cap)] = 0  # Put in the least full bin if it doesn't fit\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    target_fill = 0.8\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits #Target fill.\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits  # Close fit\n\n    fragmentation_threshold = 0.15\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit < fragmentation_threshold), -0.3, 0.0)\n\n    priorities = fill_level_priority + close_fit_priority + fragmentation_penalty #Sum up the priorities\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill target, close fit, avoids fragmentation, normalizes.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n\n    item_fits = bins_remain_cap >= item\n    if not np.any(item_fits):\n        return priorities\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Target fill bonus\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.8, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Penalize bins where the item doesn't fit\n    priorities[bins_remain_cap < item] = 0\n\n    # Normalize priorities.  Important for balancing factors.\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of remaining capacity after placement,\n    the filling threshold, and normalization to balance these factors. It uses a more direct\n    and understandable approach than v1.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    if not np.any(item_fits):\n        return priorities # no bin can contain the item\n\n    # Remaining capacity after adding the item.  Use clipping to avoid negative values\n    remaining_after_fit = np.clip(bins_remain_cap - item, 0, bin_capacity)  # Ensure no negative values\n\n    # Fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Prioritize bins based on closeness of fit (lower remaining capacity is better)\n    # Use inverse of remaining capacity + a small constant for stability.  Normalize.\n    fit_priority = 1.0 / (remaining_after_fit + 0.01)  # Avoid division by zero\n    fit_priority[~item_fits] = 0  # Only consider bins where the item fits\n    fit_priority /= np.sum(fit_priority) + 1e-9 # Normalize to avoid single bin dominance\n\n    # Prioritize bins that reach a filling threshold (e.g., 80%)\n    filling_threshold = 0.8\n    threshold_priority = np.where(fill_level >= filling_threshold, 1.0, 0.0)\n    threshold_priority[~item_fits] = 0\n    threshold_priority /= np.sum(threshold_priority) + 1e-9 # Normalize\n\n    # Combine fit and threshold priorities. Give slightly more weight to fit.\n    priorities = 0.6 * fit_priority + 0.4 * threshold_priority\n\n    # Small bonus to use bins that can at least fit an item, avoiding empty bins\n    larger_bins_bonus = 0.05 * item_fits / (np.sum(item_fits)+ 1e-9)\n    priorities += larger_bins_bonus\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                perfect_fit_priority: float = 7.465168841650064,\n                close_fit_decay: float = 6.792870535909392,\n                target_fill: float = 0.5792050207302496,\n                target_decay: float = 9.97324957051447,\n                target_bonus_weight: float = 0.21483526019194793,\n                large_space_threshold: float = 0.7261569880180845,\n                large_space_penalty: float = -0.5653813421940123,\n                no_fit_penalty: float = -8824463787.539772,\n                bin_capacity: float = 1.0680776423324565) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                perfect_fit_priority: float = 7.465168841650064,\n                close_fit_decay: float = 6.792870535909392,\n                target_fill: float = 0.5792050207302496,\n                target_decay: float = 9.97324957051447,\n                target_bonus_weight: float = 0.21483526019194793,\n                large_space_threshold: float = 0.7261569880180845,\n                large_space_penalty: float = -0.5653813421940123,\n                no_fit_penalty: float = -8824463787.539772,\n                bin_capacity: float = 1.0680776423324565) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and filling.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    \n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = perfect_fit_priority\n        return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}