```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    possible_bins = bins_remain_cap >= item
    if not np.any(possible_bins):
        return priorities # all zeros. This should trigger adding new bin in the higher level function

    # Calculate space utilization if the item were placed in the bin
    utilization = item / bins_remain_cap
    utilization[~possible_bins] = -1  # Mark impossible bins

    # Give high priority to bins that would be filled reasonably well, but not overfilled
    # penalize almost full, empty, or impossible bins
    priorities = np.where(possible_bins, 1 - np.abs(utilization - 0.7), -100) #0.7 is the target remaining ratio

    # Prefer to fill bins that are already somewhat filled
    priorities += bins_remain_cap * 0.01

    # Slight penalty for adding item to bins with very large capacity (prevent too much waste), only if item is smaller than the median capacity
    median_capacity = np.median(bins_remain_cap)
    if item < median_capacity:
       priorities -= (bins_remain_cap > median_capacity) * (bins_remain_cap - median_capacity) * 0.005

    #Very large remaining capacities get very small priority
    priorities -= (bins_remain_cap > item*5)* bins_remain_cap*0.001

    #Ensure that the bins that do not fit the item get a very negative priority, if fit at all is impossible, trigger new bin
    priorities[~possible_bins] = -1000

    return priorities
```
