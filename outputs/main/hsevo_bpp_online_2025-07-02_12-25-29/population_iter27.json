[
  {
    "stdout_filepath": "problem_iter26_response0.txt_stdout.txt",
    "code_path": "problem_iter26_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, target fill, and bin pressure.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Perfect fit bonus\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 1.0\n        return priorities\n    \n    # Close fit bonus\n    fit_difference = np.abs(bins_remain_cap - item)\n    proximity_priority = np.exp(-5 * (fit_difference / bin_capacity)**2) * item_fits\n    priorities += proximity_priority\n    \n    # Target fill bonus: target around 75%\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.5 * target_bonus\n    \n    # Bin selection pressure bonus: favour bins almost full\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.5\n    priorities += bin_pressure_bonus\n\n    # If no bin fits, put in smallest\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    # Normalize priorities\n    if np.any(priorities > 0):\n        priorities /= np.max(priorities)\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response1.txt_stdout.txt",
    "code_path": "problem_iter26_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Perfect fit early exit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n    \n    # Waste penalty, similar to v0\n    remaining_after_fit = bins_remain_cap - item\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities += waste_penalty\n    \n    # Target fill bonus, similar to v1\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n    priorities += 0.7 * target_bonus * item_fits\n\n    # Desperation strategy, if no bin fits\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n    \n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response2.txt_stdout.txt",
    "code_path": "problem_iter26_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, and target utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # Perfect fit gives immediate high priority\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n    \n    # Close fit bonus\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n    \n    # Target utilization bonus\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n    \n    # If no bin can fit item, return a array of -infinity\n    if not np.any(item_fits):\n        priorities = np.full_like(priorities, -np.inf)\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response3.txt_stdout.txt",
    "code_path": "problem_iter26_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill level.\"\"\"\n    bin_capacity = 1.0\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n\n    if not np.any(item_fits):\n        return -np.ones_like(bins_remain_cap) * 1e9\n    \n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.9\n\n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n\n    # Normalize priorities\n    close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n    fill_priority = fill_priority / np.max(fill_priority, initial=1e-9)\n    \n    priorities = 0.6 * close_fit_priority + 0.4 * fill_priority\n    \n    priorities[~item_fits] = -1e9\n\n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n    \n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response4.txt_stdout.txt",
    "code_path": "problem_iter26_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Hybrid heuristic: close fit, target fill, and bin pressure.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    item_fits = bins_remain_cap >= item\n    bin_capacity = 1.0\n\n    # 1. Close Fit Priority: Exponentially favor bins close to item size.\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # 2. Target Fill Bonus: Reward bins approaching a target fill level.\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.5*target_bonus\n\n    # 3. Bin Selection Pressure: Encourage filling existing bins.\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.3\n    priorities += bin_pressure_bonus\n\n\n    # 4.  Slight bonus for non-empty bins\n    non_empty_bonus = np.where(bins_remain_cap < bin_capacity, 0.1, 0.0) * item_fits\n    priorities += non_empty_bonus\n\n\n    # No fit handling : Put item into the bin with largest remain capcity.\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmax(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response5.txt_stdout.txt",
    "code_path": "problem_iter26_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    target_utilization = 0.9\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n\n    # High priority for perfect fit\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0\n        return priorities\n\n    # Prioritize bins where the item fits initially\n    priorities[item_fits] += 1.0\n\n    # Target utilization bonus with exponential decay\n    utilization = (bin_capacity - remaining_after_fit) / bin_capacity\n    utilization_diff = np.abs(utilization - target_utilization)\n    utilization_bonus = np.exp(-5 * utilization_diff) * item_fits\n    priorities += utilization_bonus\n\n    # Minimize wasted space by penalizing larger gaps, exponentially\n    wasted_space = np.abs(remaining_after_fit) * item_fits\n    wasted_space_penalty = np.exp(-5 * wasted_space) * item_fits\n    priorities += wasted_space_penalty\n\n    # Add a small bonus for bins which are larger than the item\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response6.txt_stdout.txt",
    "code_path": "problem_iter26_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n    \n    priorities[~item_fits] = -1e9  # Very low priority if item doesn't fit\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    target_fill = 0.9\n    fill_diff = np.abs(fill_level - target_fill)\n    fill_priority = np.exp(-10 * fill_diff) * item_fits\n    \n    close_fit = np.abs(remaining_after_fit)\n    close_fit_priority = np.exp(-5 * close_fit) * item_fits\n    \n\n    # Normalize priorities\n    if np.any(item_fits):\n        close_fit_priority = close_fit_priority / np.max(close_fit_priority, initial=1e-9)\n        fill_priority = fill_priority / np.max(fill_priority, initial=1e-9)\n\n    priorities = 0.6 * close_fit_priority + 0.4 * fill_priority\n\n    priorities[~item_fits] = -1e9\n    \n    perfect_fit_bins = np.abs(remaining_after_fit) < 1e-6\n    if np.any(perfect_fit_bins):\n        priorities[:] = -1e9\n        priorities[perfect_fit_bins] = 1e9\n        return priorities\n    \n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response7.txt_stdout.txt",
    "code_path": "problem_iter26_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Waste minimization priority\n    remaining_after_fit = bins_remain_cap - item\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities = waste_penalty\n\n    # Target fill bonus\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    target_fill = 0.8\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill)) * item_fits\n    priorities += 0.7 * target_bonus\n\n    # No-fit handling: put in smallest bin\n    if not np.any(item_fits):\n        priorities[:] = -1e9\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines proximity to item size, filling threshold, and bin pressure.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # Proximity to item size\n    fit_difference = bins_remain_cap - item\n    proximity_priority = np.exp(-5 * (fit_difference)**2) * item_fits\n    priorities += proximity_priority\n\n    # Filling Threshold\n    filling_threshold = 0.8\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.75, 0.0)\n    priorities += threshold_bonus\n\n    # Bin Selection Pressure\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.5\n    priorities += bin_pressure_bonus\n\n    # Ensure zero priority if item doesn't fit\n    priorities[bins_remain_cap < item] = 0.0\n    \n    # Small preference for non-empty bins\n    non_empty_bonus = np.where(bins_remain_cap < bin_capacity, 0.1, 0.0) * item_fits\n    priorities += non_empty_bonus\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response9.txt_stdout.txt",
    "code_path": "problem_iter26_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and target fill.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # No fit: put in smallest bin\n    if not np.any(item_fits):\n        priorities[:] = -1e9 #make all bins have very low priority\n        if len(priorities) > 0:\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Cost function based on remaining capacity: penalize wasted space\n    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities += waste_penalty\n\n    # Target fill bonus\n    target_fill = 0.8\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority * 0.5 # lower weight target fill\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response0.txt_stdout.txt",
    "code_path": "problem_iter27_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors,\n    including space utilization, fragmentation, a filling threshold,\n    and a preference for bins that leave minimal wasted space. It also\n    introduces a small element of randomness to avoid local optima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n    filling_threshold = 0.70 # Slightly reduced threshold\n\n    # Item fits check\n    item_fits = bins_remain_cap >= item\n\n    # Immediate disqualification\n    priorities[~item_fits] = -1.0  # Negative priority if it doesn't fit\n\n    # Remaining capacity after placing item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Filling level after placing item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Threshold Bonus: Strong incentive to cross threshold\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 2.0, 0.0)\n    priorities += threshold_bonus\n\n    # Primary objective: Minimize wasted space (residual)\n    waste_priority = np.exp(-10 * remaining_after_fit) * item_fits # Higher exponent\n    priorities += waste_priority\n\n    # Bins closer to full get higher priority\n    fullness_priority = fill_level * item_fits * 0.5\n    priorities += fullness_priority\n\n    # Small bonus to use non-empty bins\n    priorities += 0.1 * item_fits \n    \n    # Add small random noise to potentially escape local optima\n    priorities += 0.01 * np.random.rand(len(bins_remain_cap))\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response1.txt_stdout.txt",
    "code_path": "problem_iter27_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version focuses on a balance between tight packing and avoiding excessive fragmentation.\n    It prioritizes bins where the item fits, with a preference for bins that result in a\n    remaining capacity close to a target residual.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n    \n    # Item fits mask\n    item_fits = bins_remain_cap >= item\n    \n    # If no bin fits, return all zeros\n    if not np.any(item_fits):\n        return priorities\n    \n    # Target residual capacity (e.g., aiming for ~20% empty space)\n    target_residual = 0.2 * bin_capacity\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Prioritize bins with remaining capacity closest to target_residual\n    residual_priority = np.exp(-5 * np.abs(remaining_after_fit - target_residual)) * item_fits # Exponential decay around target\n    priorities += residual_priority\n    \n    # Bonus for bins that result in a high fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    high_fill_bonus = np.where(item_fits & (fill_level > 0.8), 0.5, 0.0)\n    priorities += high_fill_bonus\n\n    # Add a small penalty for bins that are left with very little space after the item is added\n    # helps to balance fragmentation\n    small_residual_penalty = np.where(item_fits & (remaining_after_fit < 0.1), -0.2, 0.0)\n    priorities += small_residual_penalty\n    \n    # Ensure non-fitting bins have zero priority\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Normalize priorities to make sure they are in a reasonable range\n    if np.any(priorities > 0):\n      priorities = priorities / np.max(priorities)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response2.txt_stdout.txt",
    "code_path": "problem_iter27_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    - Whether the item fits.\n    - How much space is left after adding the item (lower is better, but not zero).\n    - A filling ratio target to encourage bins to reach a target fill level.\n    - Avoidance of bins that would become too empty after the addition of item\n      (promotes consolidation over fragmentation).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n    target_fill_ratio = 0.9\n    min_rem_cap = 0.1\n\n    # 1. Item fits constraint:  Bins where the item doesn't fit get zero priority\n    item_fits = bins_remain_cap >= item\n    priorities[~item_fits] = 0\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n\n    # 2. Prioritize bins which will have remaining capacity above min_rem_cap, otherwise de-prioritize them.\n    valid_rem_cap = remaining_after_fit > min_rem_cap\n    priorities[~valid_rem_cap & item_fits] *= 0.5 # Reduce the priorities.\n    \n    # 3. Remaining capacity after fit: smaller is better, but avoid zero\n    # Use an exponential function to heavily prioritize bins with small remaining capacity\n    remaining_priority = np.exp(-5 * remaining_after_fit) * item_fits\n    priorities += remaining_priority\n\n    # 4. Target fill ratio:  Reward bins approaching the target fill ratio\n    current_fill_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    fill_ratio_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    #Calculate difference between fill ratio and target fill ratio\n    fill_diff = np.abs(fill_ratio_after_fit - target_fill_ratio)\n    target_priority = np.exp(-5 * fill_diff) * item_fits\n    priorities += target_priority\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response3.txt_stdout.txt",
    "code_path": "problem_iter27_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. How much free space would be left after placing the item (minimize wasted space).\n    3. A fill-level target (attempt to fill bins close to a desired level).\n\n    It aims to balance packing items effectively while minimizing fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n\n    # 1. Item Fit:  Prioritize bins where the item fits.\n    item_fits = bins_remain_cap >= item\n    priorities[~item_fits] = -1  # Very low priority if it doesn't fit\n\n    # 2. Minimize Wasted Space: Prioritize bins that leave minimal remaining space.\n    remaining_after_fit = bins_remain_cap - item\n    waste_penalty = np.abs(remaining_after_fit)  # Closer to zero is better\n\n    # Scale and invert the waste penalty to create a priority boost.  We want lower waste to have higher priority.\n    waste_priority = np.exp(-5 * waste_penalty) * item_fits\n    priorities += waste_priority\n\n    # 3. Fill Level Target: Encourage bins to reach a target fill level.\n    target_fill_level = 0.8  # Aim for bins to be around 80% full\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    future_fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Calculate how close the future fill level is to the target.\n    fill_level_diff = np.abs(future_fill_level - target_fill_level)\n\n    # Boost priority for bins that get closer to the target fill level.\n    fill_level_priority = np.exp(-5 * fill_level_diff) * item_fits\n    priorities += 0.7 * fill_level_priority\n\n    # Small bonus for larger bins that have enough room\n    priorities += 0.05 * item_fits\n    \n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.008775428799367,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response4.txt_stdout.txt",
    "code_path": "problem_iter27_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Whether the item fits.\n    2.  How much space is left after placing the item (lower is better, indicating tighter packing).\n    3.  A penalty for excessive fragmentation (very small remaining space).\n    4.  Bonus for approaching a target fill level.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    target_fill = 0.9  # Aim for bins to be around 90% full\n    min_fill = 0.5\n\n    # Check if item fits in each bin\n    item_fits = bins_remain_cap >= item\n\n    # Remaining capacity after adding the item (only for bins where it fits)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[~item_fits] = np.inf  # effectively ignore bins where item doesn't fit\n\n    # 1. Prioritize fitting the item:\n    priorities[item_fits] += 1.0\n\n    # 2. Reward bins with less remaining space after fitting (tighter packing)\n    # Use an exponential to heavily favor bins with small remaining space,\n    # but only if the item fits.\n    packing_efficiency = np.exp(-5 * remaining_after_fit)\n    priorities[item_fits] += packing_efficiency[item_fits]\n\n    # 3. Penalize bins that will result in excessive fragmentation.  Avoid making\n    #    bins with very small remaining space, if possible.\n    fragmentation_penalty = np.where(remaining_after_fit < 0.1, -0.5, 0) #big penalty for tiny space\n    priorities += fragmentation_penalty\n\n    # 4. Give a bonus for bins that approach the target fill level\n    # Calculate current fill level after adding item (only where it fits)\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Bonus for approaching target fill level.\n    target_bonus = np.exp(-5 * np.abs(fill_level - target_fill))\n    priorities[item_fits] += 0.75 * target_bonus[item_fits]\n\n    #Add small bonus if fill_level after adding is higher than min_fill\n    min_fill_bonus = np.where(fill_level > min_fill, 0.25, 0)\n    priorities[item_fits] += min_fill_bonus[item_fits]\n    \n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  }
]