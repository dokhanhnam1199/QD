{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on fit and fullness using exponential decay.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = 0\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Add negative infinite priority for invalid bins\n    priorities[~possible_bins] = -np.inf\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on wasted space, fullness, and exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Wasted space calculation (exclude infeasible)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Penalize nearly full bins exponentially\n    nearly_full_penalty = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Combine rewards and penalties\n    priorities = close_fit_reward * nearly_full_penalty\n\n    # Encourage filling bins already somewhat full + randomness\n    priorities += bins_remain_cap * 0.01 + np.random.normal(0, 0.01, size=bins_remain_cap.shape)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first one prioritizes both close fit and resulting fullness, while the last one prioritizes wasted space, fullness, and exploration (adding noise). The first one uses a simple addition of exponential decays, while the last uses a product of exponential decays and adds a small exploration term.\n\n(2nd best) vs (second worst), we see that the second prioritizes wasted space and fullness, adding a boost for almost full bins. The second-worst also considers wasted space and fullness, but it combines close fit and fullness through multiplication and adds exploration through noise.\n\nComparing (1st) vs (2nd), we see that the first one uses a simple addition of `close_fit` and `nearly_full` priorities, while the second focuses on `waste` and adds a priority boost when the bin is almost full. The first uses `-np.inf` for infeasible bins while the second immediately returns when all bins are infeasible.\n\n(3rd) vs (4th), we see that the third calculates a closeness of fit, rewards nearly full bins, penalizes bins that remain far from full, and considers a minimum utilization threshold.  The fourth simply combines closeness of fit and near fullness without considering utilization or thresholds.\n\nComparing (second worst) vs (worst), we see the only difference is the comment.\n\nOverall: The better heuristics seem to focus on directly combining closeness of fit and fullness, often using exponential decay to prioritize bins. They also incorporate mechanisms to avoid fragmentation, either through a minimum utilization threshold or by penalizing bins that will remain mostly empty after an item is added. The worse heuristics tend to multiply the priority scores (reward and penalty) together and adds noise to encourage exploration, which appears to be less effective in this context. Also the best heuristics directly assign -inf to infeasible bins.\n- \nHere's a redefinition of \"Current self-reflection,\" geared towards effective heuristic design:\n\n*   **Keywords:** Direct factors, additive combinations, exponential decay, infeasibility handling, fragmentation exploration (additive).\n*   **Advice:** Focus on additive combinations of clear, relevant factors. Use exponential decay for parameter tuning. Explicitly penalize infeasibility.\n*   **Avoid:** Multiplicative combinations, excessive randomness that overshadows core heuristic logic.\n*   **Explanation:** Prioritize simple, interpretable rules, focusing on additive combinations of relevant factors. Control randomness to ensure heuristic reliability.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}