{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version balances fill level targets, close fit, and bin usage efficiency,\n    with a focus on avoiding excessive fragmentation and promoting bin completion.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n\n    # Target fill level: Aim for bins close to this fill level after packing\n    target_fill = 0.9\n    fill_level_after = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Priority for bins nearing target fill level\n    target_fill_priority = np.exp(-10 * np.abs(fill_level_after - target_fill)) * item_fits\n    priorities += 0.8 * target_fill_priority\n\n    # Close fit bonus, stronger than before\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-15 * close_fit) * item_fits\n    priorities += close_fit_priority\n\n    # Bonus for filling bins past a minimum threshold, but only if it doesn't exceed the target.\n    min_fill = 0.6\n    min_fill_bonus = np.where(item_fits & (fill_level_after >= min_fill) & (fill_level_after <= target_fill), 0.5, 0.0)\n    priorities += min_fill_bonus\n\n    # Discourage leaving very small gaps (fragmentation)\n    small_gap_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < 0.1), -0.3, 0.0) # Reduced Penalty\n    priorities += small_gap_penalty\n\n    # Prioritize using almost-empty bins if the item is large\n    large_item_threshold = 0.7\n    almost_empty_bonus = np.where((bins_remain_cap > 0.9) & (item >= large_item_threshold), 0.4, 0.0) # Increased Bonus\n    priorities += almost_empty_bonus\n\n    # Set priority to 0 for bins where the item doesn't fit\n    priorities[~item_fits] = 0.0\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first heuristic is simpler, focusing on close fit, target fill, and fragmentation avoidance with fixed parameters, while the 20th dynamically adjusts parameters based on item size, offering potentially better adaptability but at the cost of increased complexity.\nComparing (2nd) vs (19th), the second heuristic gives bonus to bins larger than the item while the 19th adds early exit when perfectly fit bin is found. The 19th also has a stronger penalty for bins with large remaining space.\nComparing (3rd) vs (4th), these two heuristics are identical.\nComparing (19th) vs (20th), we see the 19th heuristic has early exit when perfectly fit bin is found while 20th heuristic has early exit if no bins can fit the item. The 20th dynamically adjusts parameters. Also, the 20th heuristic assigns -inf penalty to bins where item doesn't fit. Overall: The better heuristics prioritize a balance of simplicity and effectiveness, using targeted bonuses and penalties related to fill level, fit, and fragmentation. Early exits and handling of edge cases (like no fitting bins) are also helpful. More complex, dynamic approaches might offer benefits, but increase the risk of overfitting or computational overhead.\n- \nOkay, let's refine \"current self-reflection\" to guide better heuristic design, steering clear of the pitfalls of \"ineffective self-reflection.\"\n\nHere's a revised breakdown:\n\n*   **Keywords:** Clarity, directness, balance, adaptability, edge case handling, interpretability, evaluation, validation, parameterization.\n\n*   **Advice:** Prioritize clear, direct combinations of relevant factors; validate inputs early; explicitly handle edge cases (e.g., infeasibility); use parameterization judiciously for flexibility, but maintain interpretability.\n\n*   **Avoid:** Unnecessary complexity, multiplicative combinations, opaque calculations, unchecked randomness, overlooking the objective function, over-parameterization.\n\n*   **Explanation:** Focus on simplicity, directness, and validation. Design clear, interpretable rules, address edge cases effectively, and prioritize comprehensive evaluation to assess the impact of each change.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}