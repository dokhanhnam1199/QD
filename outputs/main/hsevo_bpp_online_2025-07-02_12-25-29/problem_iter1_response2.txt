```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by gravitational attraction: Larger remaining capacity (mass) attracts more strongly,
    but the attraction diminishes with distance (difference between item size and remaining capacity).
    Also incorporates a penalty for bins where the item doesn't fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the difference between bin capacity and item size.  A smaller
    # positive difference means a tighter fit.  Use 0 for bins where the item does not fit.
    difference = bins_remain_cap - item
    difference = np.where(difference >= 0, difference, np.inf) # Inf if item doesn't fit, otherwise the gap

    # Create a baseline priority based on inverse difference (smaller gap is better, avoid overflow)
    priorities = np.where(difference != np.inf, 1 / (difference + 0.0001), -np.inf)

    # Enhance priority: larger capacity is also attractive (Newtonian Gravitation concept):
    priorities = priorities * (bins_remain_cap**0.5)

    # Penalize bins where the item does not fit.
    priorities = np.where(difference == np.inf, -np.inf, priorities)

    return priorities
```
