```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that minimize wasted space after packing the item.
    It uses a cost function based on remaining capacity to guide the packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item fits
    item_fits = bins_remain_cap >= item
    
    # Calculate remaining capacity after adding the item
    remaining_after_fit = bins_remain_cap - item
    
    # Cost function based on remaining capacity: penalize wasted space
    # The closer to zero, the better the fit.  Use exponential decay to
    # heavily penalize large remaining capacities.  Only consider bins
    # where the item fits.
    waste_penalty = np.exp(-5 * remaining_after_fit) * item_fits
    
    # Invert the penalty to get a priority (lower waste = higher priority)
    priorities = waste_penalty

    # Small bonus for bins where we can fit the item at all, 
    # to prioritize using bins over leaving items unpacked.
    priorities += 0.1 * item_fits

    return priorities
```
