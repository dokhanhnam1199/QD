```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using wasted space, fullness, and infeasibility."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Infeasible bins get -inf priority
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf

    # Wasted space calculation (exclude infeasible)
    wasted_space = bins_remain_cap - item
    wasted_space[infeasible_mask] = np.inf

    # Reward close fits exponentially
    close_fit_reward = np.exp(-2 * wasted_space)

    # Reward nearly full bins exponentially
    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same capacity
    utilization = (bin_size - wasted_space) / bin_size
    nearly_full_reward = np.exp(-2 * np.abs(wasted_space)) # more sensitive

    # Combine rewards and penalties additively
    priorities = close_fit_reward + nearly_full_reward

    # Penalize bins that remain far from full. Encourage utilization.
    empty_penalty = np.exp(-5 * (1 - utilization))
    priorities += empty_penalty  # reduced impact

    # Minimum utilization threshold to reduce extreme fragmentation
    min_utilization_threshold = 0.2
    mask = utilization < min_utilization_threshold
    priorities[mask] = -np.inf

    return priorities
```
