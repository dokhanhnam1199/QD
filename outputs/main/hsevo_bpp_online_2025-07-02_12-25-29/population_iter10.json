[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines filling threshold, close fit, and wasted space considerations.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    filling_threshold = 0.75\n    bin_capacity = 1.0\n\n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = 0  # Set priority to 0 rather than -inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines close fit, utilization, fragmentation, and validation for bin selection.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasibility Handling:\n    feasible_bins = bins_remain_cap >= item\n    if not np.any(feasible_bins):\n        return priorities # No feasible bins, return zero priorities\n\n    # 1. Close Fit Priority:\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)\n    priorities += fragmentation_penalty\n\n    # Apply mask AFTER calculating other priorities to avoid influencing calculations\n    priorities[~feasible_bins] = 0\n\n    # Scaling to rank feasible bins, avoid division by zero\n    priorities[feasible_bins] *= (bins_remain_cap[feasible_bins] - item + 1e-9) / (bins_remain_cap[feasible_bins] + 1e-9)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.9760670123653865,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fit, fullness, and bin utilization.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = 0\n\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.5 * bin_utilization\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities considering fit, fill threshold, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get zero priority\n    item_fits = bins_remain_cap >= item\n    priorities[~item_fits] = 0.0\n\n    # Filling threshold bonus\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n    \n    # Close fit reward\n    wasted_space = bins_remain_cap - item\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward * item_fits\n\n    # Fragmentation penalty: Avoid small remaining capacities\n    small_capacity_threshold = 0.1\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_indices = (remaining_after_fit > 0) & item_fits\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    # Small bonus to larger bins that can fit the item\n    larger_bins_bonus = item_fits * 0.1\n    priorities += larger_bins_bonus\n    \n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.078579976067022,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Combines filling threshold, close fit, and avoids fragmentation.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    filling_threshold = 0.75\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    priorities[bins_remain_cap < item] = 0\n\n    small_remaining = remaining_after_fit < 0.1\n    priorities[item_fits & small_remaining] -= 0.5\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit, fullness, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority (sharper decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)\n    priorities[~possible_bins] = 0  # Infeasible bins get zero priority\n\n    # Fullness reward (sharper decay)\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Already Occupied preference (reduced coefficient)\n    already_occupied = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities += 0.5 * already_occupied\n\n    # Fragmentation penalty (fragments smaller than 0.1)\n    small_fragment_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_fragment_indices = np.where((bins_remain_cap >= item) & (remaining_after_fit > 0) & (remaining_after_fit < 0.1))\n    small_fragment_penalty[small_fragment_indices] = -1\n    priorities += small_fragment_penalty\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on closeness of fit and utilization.\n    Addresses infeasibility and potential division-by-zero errors.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # 1. Closeness of fit\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit_diff)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. High Utilization\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # 3. Scale based on remaining capacity after fit\n    priorities[bins_remain_cap >= item] *= (bins_remain_cap[bins_remain_cap >= item] - item + 0.0001) / (bins_remain_cap[bins_remain_cap >= item] + 0.0001)\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.656960510570408,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering filling threshold, close fit, and error handling.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n\n    item_fits = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    priorities[bins_remain_cap < item] = 0\n\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n    \n    # Penalize bins that would leave a very small remaining capacity (fragmentation)\n    small_remaining = remaining_after_fit < 0.1\n    priorities[item_fits & small_remaining] -= 0.25 \n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines filling threshold and close-fit reward for bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Infeasible bins get zero priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = 0\n\n    # Close-fit reward using exponential decay\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n    close_fit_reward = np.exp(-5*np.abs(wasted_space))\n    priorities += close_fit_reward * (bins_remain_cap >= item)\n\n    # Filling threshold bonus.\n    filling_threshold = 0.75\n    bin_capacity = 1.0\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where((bins_remain_cap >= item) & (fill_level >= filling_threshold), 0.5, 0.0)\n    priorities += threshold_bonus\n    \n    # Small bonus for larger bins that fit item.\n    larger_bins = bins_remain_cap >= item\n    priorities += 0.1 * larger_bins\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit, fullness, and a target fullness, robustly.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf  # Infeasible bins get -inf\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = np.exp(-close_fit)\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Bonus for bins close to a target fullness after placement\n    target_remaining = 0.1\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - target_remaining))\n    priorities[feasible_bins] += almost_full_bonus * 0.5\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Whether the item fits.\n    2.  How close the resulting fill level is to an ideal target.\n    3.  A penalty for bins that would become nearly empty.\n    4.  A bonus for bins that would become nearly full.\n    5. Validation to check if item fits.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    \n    # Check if the item fits in any of the bins, if not return all zero priorities\n    if np.all(bins_remain_cap < item):\n        return priorities\n    \n    # 1. Item Fit Check\n    item_fits = bins_remain_cap >= item\n    \n    # Set priority to 0 for bins where item doesn't fit\n    priorities[~item_fits] = 0.0\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # 2. Target Fill Level\n    target_fill = 0.85\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    fill_level_priority = np.exp(-5 * np.abs(fill_level_after_fit - target_fill)) * item_fits\n    priorities += fill_level_priority\n    \n    # 3. Nearly Empty Penalty\n    nearly_empty_threshold = 0.2\n    nearly_empty = remaining_after_fit / bin_capacity > nearly_empty_threshold\n    priorities[nearly_empty & item_fits] -= 0.2 # Reduced penalty for stability.\n\n    # 4. Nearly Full Bonus\n    nearly_full_threshold = 0.95\n    nearly_full = fill_level_after_fit >= nearly_full_threshold\n    priorities[nearly_full & item_fits] += 0.5\n    \n    # 5. Prioritize larger bins that can accomodate the item.\n    larger_bins = bins_remain_cap >= item\n    priorities += 0.1 * larger_bins\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits, with added robustness\n    and direct impact considerations.  It aims to minimize fragmentation\n    and promote efficient space utilization, especially focusing on bins\n    becoming close to full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    item_fits = bins_remain_cap >= item\n\n    # Validation: Ensure no negative remaining capacities sneak in.\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.  Check input data.\")\n        \n    # 1. Close-to-Full Prioritization:  Strongest signal.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits  #Sharper peak\n    priorities += 2.0 * nearly_full  # Increased weight\n\n    # 2. Preventative Fragmentation Minimization:\n    # Prioritize bins where the item fits *reasonably* well, but avoids very tight fits\n    # that could cause tiny unusable fragments.\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)  # Avoid tiny fragments\n    priorities += 0.8 * reasonable_fit # Moderate boost\n\n    # 3. Bins Larger Than Item Bonus, but Diminishing Returns with size:\n    # Encourages using bins, but avoids overly large allocations if better options exist.\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    # Use a log or sqrt to give diminishing returns for very large empty spaces.\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n\n    # 4. \"Desperation\" Move: If no bin fits, severely penalize all bins.  This practically forces\n    # the algorithm to open a new bin.  This prevents weird oscillations.  Check first if an item fits in any bin.\n    if not np.any(item_fits):\n        priorities[:] = -1e9  # Huge negative priority\n        # Check if there are any bins, to avoid an error if the array is empty.\n        if len(priorities) > 0:\n           priorities[np.argmin(bins_remain_cap)] = 0  #Allows it to add item to emptiest bin if nothing fits\n    else:\n        # Zero out priorities for bins where the item doesn't fit. Necessary after the potential \"desperation\" reset.\n        priorities[bins_remain_cap < item] = -1e9\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.108496210610296,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can fit item, return all zeros\n    if not np.any(item_fits):\n        return priorities\n        \n    # Filling threshold after adding the item\n    filling_threshold = 0.75\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Bonus for bins meeting filling threshold\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority (exponential decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Near full priority (exponential decay)\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    # Prioritize bins with smallest remaining capacity among feasible bins\n    smallest_remaining = np.where(item_fits, -bins_remain_cap, 0) #Negate to make smallest *most* desirable\n    priorities += smallest_remaining\n\n    # Sanity check: Ensure no negative priorities.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.487435181491823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1.  Best Fit: Prioritizes bins with the smallest remaining capacity after adding the item.\n    2.  Filling Threshold: Provides a bonus for bins that reach a desired fill level.\n    3.  Avoidance of Fragmentation: Discourages placing items in bins where it leaves\n        a small unused space.\n    4. Prevents selecting Infeasible bins.\n    5. Validates feasibility during runtime.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0\n\n    # Feasibility check: Ensure item fits in the bin\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return all zeros immediately\n    if not np.any(item_fits):\n        return priorities\n    \n    # Best Fit Priority: reward small remaining capacity.\n    remaining_after_fit = bins_remain_cap - item\n    best_fit_priority = np.where(item_fits, bin_capacity - remaining_after_fit, 0.0)  # Use remaining capacity directly\n    priorities += best_fit_priority\n\n    # Filling Threshold Priority: reward bins close to full.\n    filling_threshold = 0.75\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(item_fits & (fill_level_after_fit >= filling_threshold), 0.5, 0.0)  # Scale the bonus\n    priorities += threshold_bonus\n\n    # Fragmentation Avoidance: Penality for leaving tiny gaps.\n    fragmentation_threshold = 0.1  # Tune this parameter\n    fragmentation_penalty = np.where(item_fits & (remaining_after_fit > 0) & (remaining_after_fit < fragmentation_threshold), -0.2, 0.0)  # Penalize, but not too harshly\n    priorities += fragmentation_penalty\n\n    # Infeasible Bin Handling: Explicitly set priority to zero\n    priorities[bins_remain_cap < item] = 0.0\n\n    # Validation: Check for negative priorities and cap at zero. (defensive programming)\n    priorities = np.maximum(priorities, 0.0)\n    \n    # Final Scaling: Ensure meaningful values\n    priorities = priorities/np.max(priorities) if np.max(priorities) > 0 else priorities # Scale between zero and one.\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Whether the item fits.\n    2. Remaining capacity after placing the item (favoring tighter fits).\n    3. A filling threshold to encourage bins to reach a desirable fill level.\n    4. A penalty for excessive fragmentation.\n    5. A bonus for almost filling up the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0\n    item_fits = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros.\n    if not np.any(item_fits):\n        return priorities\n\n    # 1. Feasibility check: Only consider bins where the item fits.\n    feasible_bins = bins_remain_cap[item_fits]\n    feasible_indices = np.where(item_fits)[0]\n\n    # 2. Remaining capacity priority: Higher priority to bins that leave less space.\n    remaining_capacity_priority = 1 - (feasible_bins - item) / bin_capacity\n    priorities[feasible_indices] += remaining_capacity_priority\n\n    # 3. Filling threshold: Reward bins that cross a certain threshold after placement.\n    filling_threshold = 0.75\n    remaining_after_fit = feasible_bins - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    threshold_bonus = np.where(fill_level >= filling_threshold, 0.5, 0.0)  # Adjusted bonus\n    priorities[feasible_indices] += threshold_bonus\n\n    # 4. Fragmentation penalty: Penalize bins that would leave very small remaining space.\n    fragmentation_penalty = np.where(remaining_after_fit < 0.1, -0.2, 0.0) #Adjusted penalty and threshold\n    priorities[feasible_indices] += fragmentation_penalty\n\n    # 5. Nearly Full Bonus : Give bins a boost if they are almost full.\n    almost_full_bonus = np.where(remaining_after_fit <= 0.05, 0.3, 0.0) #Adjusted threshold and bonus\n    priorities[feasible_indices] += almost_full_bonus\n\n    # Validation: Ensure priorities are non-negative.  Important to keep\n    # for heuristics where we subtract factors.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.198244914240141,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_hs2.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                filling_threshold: float = 0.3821922224501979,\n                close_fit_exponent: float = 7.042742591468164,\n                nearly_full_exponent: float = 13.861413706721073,\n                nearly_full_weight: float = 0.5061108094116068,\n                larger_bins_weight: float = 0.3051014755364687,\n                bin_capacity: float = 1.559847732378378) -> np.ndarray:\n    \"\"\"Combines filling threshold, close fit, and wasted space considerations.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    remaining_after_fit = bins_remain_cap - item\n    item_fits = bins_remain_cap >= item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-close_fit_exponent * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = 0  # Set priority to 0 rather than -inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    nearly_full = np.exp(-nearly_full_exponent * np.abs(remaining_after_fit)) * item_fits\n    priorities += nearly_full_weight * nearly_full\n\n    larger_bins = (bins_remain_cap >= item)\n    priorities += larger_bins_weight * larger_bins\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9888312724371757,
    "exec_success": true
  }
]