{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on close fit, target fill, and early exit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    # Early exit: If there's a bin that fits the item perfectly, prioritize it highly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    if np.any(perfect_fit):\n        priorities[perfect_fit] = 10.0  # High priority for perfect fit\n        return priorities\n\n    if not np.any(feasible_bins):\n        if len(priorities) > 0:\n            priorities[:] = -1e9\n            priorities[np.argmin(bins_remain_cap)] = 0\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-7.0 * close_fit)\n    priorities += close_fit_priority * feasible_bins\n\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = 1.0 - (remaining_after_fit / 1.0) #scale remaining capacity to 0-1\n    target_fill = 0.75\n    target_bonus = np.exp(-10.0 * np.abs(fill_level - target_fill))\n\n    priorities += 0.5 * target_bonus * feasible_bins\n\n    # Moderate penalty for leaving too much space\n    bin_capacity = 1.0\n    space_left_penalty = np.where(remaining_after_fit > 0.5 * bin_capacity, -0.5, 0.0) * feasible_bins\n    priorities += space_left_penalty\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    - Ability to fit the item.\n    - Closeness to a target fill level (around 90%).\n    - Avoiding excessive fragmentation (remaining space).\n    - A tie-breaker for the fullest bin so far.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Check which bins can accommodate the item\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can fit the item, return an array of zeros.\n    if not np.any(item_fits):\n        return priorities\n        \n\n    # 1. Target Fill Level: Prioritize bins that will be close to 90% full.\n    target_fill = 0.9\n    remaining_after_fit = bins_remain_cap - item\n    fill_level_after_fit = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Calculate deviation from target fill; smaller deviation is better\n    deviation_from_target = np.abs(fill_level_after_fit - target_fill)\n    \n    # Give higher priority to bins closer to the target fill\n    target_priority = np.exp(-5 * deviation_from_target) * item_fits\n    priorities += target_priority\n\n    # 2. Fragmentation Penalty: Penalize bins that leave too much empty space.\n    fragmentation_penalty = np.exp(-2 * remaining_after_fit) * item_fits # Smaller remaining is better\n    priorities += fragmentation_penalty\n\n    # 3. Tie-breaker: Prioritize the fullest bin (smallest remaining cap) if multiple bins are suitable\n    # This encourages filling bins completely before starting new ones. Only apply to viable bins.\n    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    priorities += 0.1 * current_fill_level * item_fits  # Small bonus for current fill.\n\n\n    # Ensure priorities for bins that don't fit the item are zero.\n    priorities[bins_remain_cap < item] = 0.0\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that the 1st prioritizes bins based on space utilization, fragmentation and filling threshold. The 2nd prioritizes bins based on close fit, filling and avoids fragmentation. However, the 2nd has an early exit for perfect fit. The 2nd also has a penalty for leaving large remaining space.\n\nComparing (3rd) vs (4th), they are identical.\n\nComparing (5th) vs (6th), they are identical.\n\nComparing (7th) vs (8th), we see that the 7th prioritizes bins based on fill target, fit and fragmentation with early exits and the 8th prioritizes bins based on whether the item fits, remaining capacity, filling threshold and penalizing bins that are already too full.\n\nComparing (9th) vs (10th), we see that the 9th prioritizes bins based on close fit, target fill and avoids fragmentation and takes `bin_capacity` as an argument and the 10th combines target fill, close fit and handles edge cases.\n\nComparing (11th) vs (12th), we see that the 11th prioritizes bins that results in a fill level closest to a target and the 12th prioritizes bins based on a combination of factors like ability to fit item, target fill level, avoiding excessive fragmentation and a tie-breaker for the fullest bin so far.\n\nComparing (13th) vs (14th), we see that the 13th prioritizes bins considering close fit, target fill, and fragmentation with early exit with adjusted penalties. The 14th prioritizes bins based on a combination of factors like ability to fit item, target fill level, avoiding excessive fragmentation and a tie-breaker for the fullest bin so far.\n\nComparing (15th, 16th, 17th, 18th) they only implement early exit of perfect fit.\nComparing (19th) vs (20th), they are identical.\n\nOverall: The better heuristics tend to consider more factors such as fragmentation, target fill level, and close fit. They also implement early exits for perfect fit scenarios and handle edge cases where no bins can fit the item. Penalties for large remaining space and small remaining space after fit are also important.\n- \nOkay, let's redefine \"Current self-reflection\" to make it more effective for designing bin packing heuristics. We'll focus on actionable insights and avoid the pitfalls of the \"Ineffective self-reflection\" examples.\n\nHere's a refined version:\n\n*   **Keywords:** Directness, combination, normalization, exploration, clear objectives, gradual refinement.\n\n*   **Advice:** Prioritize direct combinations of closeness-of-fit and fullness. Use normalization to balance different criteria and facilitate exploration of the design space. Handle edge cases explicitly (e.g., no fit bins).\n\n*   **Avoid:** Multiplicative combinations, premature complexity, relying solely on randomness, neglecting the optimization objective.\n\n*   **Explanation:** Design heuristics that are both clear and effective. Begin with a simple core and add complexity cautiously. Ensure factors like fill level and fit contribute directly to the optimization goal, and normalize priorities across different factors.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}