```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with remaining capacity closest to the item size
    while avoiding excessive fragmentation. It incorporates a filling threshold
    and a bin-selection pressure to consolidate items into fewer bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = 1.0
    item_fits = bins_remain_cap >= item

    # 1. Proximity to item size: Favor bins that are a close fit for the item.
    #    This reduces fragmentation. Use a quadratic penalty for the difference.
    fit_difference = bins_remain_cap - item
    proximity_priority = np.exp(-5 * (fit_difference / bin_capacity)**2) * item_fits
    priorities += proximity_priority

    # 2. Filling Threshold: Reward bins that, after adding the item, exceed a
    #    certain fill threshold.  This promotes efficient bin utilization.
    filling_threshold = 0.8 # aim for 80% fill
    remaining_after_fit = bins_remain_cap - item
    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity
    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 0.75, 0.0)
    priorities += threshold_bonus


    # 3. Bin Selection Pressure: Add a bonus for bins that are already partially full.
    #    This encourages filling existing bins before opening new ones. The fuller
    #    the bin, the higher the bonus, up to a point.

    current_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity
    bin_pressure_bonus = np.clip(current_fill_level, 0, 0.9) * item_fits * 0.5 # Max bonus of 0.45
    priorities += bin_pressure_bonus


    # 4. Avoidance of bins where item doesn't fit. Ensure priority is strictly zero.
    priorities[bins_remain_cap < item] = 0.0
    
    # 5. Slight preference for non-empty bins
    non_empty_bonus = np.where(bins_remain_cap < bin_capacity, 0.1, 0.0) * item_fits
    priorities += non_empty_bonus


    return priorities
```
