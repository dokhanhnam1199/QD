```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version improves upon v1 by dynamically adjusting parameters
    based on item size and remaining bin capacities. It focuses on a
    stronger balance between close fit and filling thresholds, with an
    early exit for obviously unsuitable bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed

    # Early exit: If no bins can fit the item, return all zeros.
    if np.all(bins_remain_cap < item):
        return priorities

    # Filling threshold, dynamically adjusted based on item size.
    # Smaller items encourage higher fill levels.
    filling_threshold = 0.7 + 0.2 * min(item, 0.3)  # Threshold between 0.7 and 0.9

    remaining_after_fit = bins_remain_cap - item
    item_fits = bins_remain_cap >= item
    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity

    # Bonus for meeting the filling threshold.  Increased bonus for larger items.
    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0 + item, 0.0)
    priorities += threshold_bonus

    # Close fit priority.  Adjust the exponent based on item size to make it more/less sensitive.
    close_fit = np.abs(bins_remain_cap - item)
    close_fit_sensitivity = 5 + 5 * item  # Scale sensitivity with item size (larger items -> more sensitive)
    close_fit_priority = np.exp(-close_fit_sensitivity * close_fit)
    priorities += close_fit_priority * item_fits

    # Very strong penalty for bins where item doesn't fit (set to -inf to ensure never selected).
    priorities[bins_remain_cap < item] = -np.inf

    # Encourage bins to become nearly full, scale reward by the *remaining* space.
    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits
    priorities += 0.5 * nearly_full * (1 - remaining_after_fit) # Prefer bins with less remaining space

    return priorities
```
