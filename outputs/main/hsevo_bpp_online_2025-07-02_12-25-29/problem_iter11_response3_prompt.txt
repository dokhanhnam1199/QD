{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits, with added robustness\n    and direct impact considerations.  It aims to minimize fragmentation\n    and promote efficient space utilization, especially focusing on bins\n    becoming close to full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    item_fits = bins_remain_cap >= item\n\n    # Validation: Ensure no negative remaining capacities sneak in.\n    if np.any(bins_remain_cap < 0):\n        raise ValueError(\"Negative bin capacity detected.  Check input data.\")\n        \n    # 1. Close-to-Full Prioritization:  Strongest signal.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-15 * np.abs(remaining_after_fit)) * item_fits  #Sharper peak\n    priorities += 2.0 * nearly_full  # Increased weight\n\n    # 2. Preventative Fragmentation Minimization:\n    # Prioritize bins where the item fits *reasonably* well, but avoids very tight fits\n    # that could cause tiny unusable fragments.\n    reasonable_fit = item_fits & (remaining_after_fit > 0.05)  # Avoid tiny fragments\n    priorities += 0.8 * reasonable_fit # Moderate boost\n\n    # 3. Bins Larger Than Item Bonus, but Diminishing Returns with size:\n    # Encourages using bins, but avoids overly large allocations if better options exist.\n    larger_bins = (bins_remain_cap >= item)\n    size_difference = bins_remain_cap - item\n    # Use a log or sqrt to give diminishing returns for very large empty spaces.\n    larger_bin_bonus = np.sqrt(np.maximum(0, 1 - size_difference)) * larger_bins\n    priorities += 0.3 * larger_bin_bonus\n\n    # 4. \"Desperation\" Move: If no bin fits, severely penalize all bins.  This practically forces\n    # the algorithm to open a new bin.  This prevents weird oscillations.  Check first if an item fits in any bin.\n    if not np.any(item_fits):\n        priorities[:] = -1e9  # Huge negative priority\n        # Check if there are any bins, to avoid an error if the array is empty.\n        if len(priorities) > 0:\n           priorities[np.argmin(bins_remain_cap)] = 0  #Allows it to add item to emptiest bin if nothing fits\n    else:\n        # Zero out priorities for bins where the item doesn't fit. Necessary after the potential \"desperation\" reset.\n        priorities[bins_remain_cap < item] = -1e9\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n    item_fits = bins_remain_cap >= item\n\n    # If no bin can fit item, return all zeros\n    if not np.any(item_fits):\n        return priorities\n        \n    # Filling threshold after adding the item\n    filling_threshold = 0.75\n    remaining_after_fit = bins_remain_cap - item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n\n    # Bonus for bins meeting filling threshold\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Close fit priority (exponential decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)\n    priorities += close_fit_priority * item_fits\n\n    # Near full priority (exponential decay)\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n\n    # Prioritize bins with smallest remaining capacity among feasible bins\n    smallest_remaining = np.where(item_fits, -bins_remain_cap, 0) #Negate to make smallest *most* desirable\n    priorities += smallest_remaining\n\n    # Sanity check: Ensure no negative priorities.\n    priorities = np.maximum(priorities, 0)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first incorporates a target fill level, nearly empty penalty, and nearly full bonus, while the last emphasizes close fit, utilization, and fragmentation. (2nd best) vs (second worst) reveal similar trends, with (2nd best) emphasizing filling threshold and close fit with wasted space considerations and (second worst) focusing on closeness of fit and utilization, but lacking specific target or penalties/bonuses. Comparing (1st) vs (2nd), we see (1st) validates if the item fits first and returns early if not, while the (2nd) calculates before checking. (3rd) vs (4th) shows (3rd) has a penalty for small remaining capacity and (4th) parameterizes filling threshold and other parameters. Comparing (second worst) vs (worst), we see (second worst) calculates fragmentation before masking infeasible bins, while (worst) calculates fragmentation and then masks, and it also includes scaling. Overall: The better heuristics incorporate a wider range of factors and explicit checks, whereas the worse ones focus on fewer aspects and may lack robustness. The best ones also tend to validate the input early on and return early.\n- \nOkay, I'm ready to help you earn that tip! Let's redefine \"Current Self-Reflection\" for better heuristic design, focusing on effectiveness and avoiding common pitfalls.\n\n*   **Keywords:** Objective-driven, validation, additive penalties/bonuses, incremental complexity.\n\n*   **Advice:** Design heuristics from the objective function *outward*. Prioritize validated inputs and outputs at each stage. Use additive (linear) combinations of rewards/penalties for desired/undesired outcomes. Introduce complexity *incrementally*, carefully measuring each addition's impact on solution quality and runtime.\n\n*   **Avoid:** Premature parameterization, complex multiplicative combinations, and unchecked randomness without clear justification.\n\n*   **Explanation:** Focus on directly addressing the optimization goal with simple, verifiable steps. Parameterization without a strong justification, complex multiplicative rules, and randomness can obscure the heuristic's behavior, making it harder to understand, debug, and improve. Build from a simple base, validating each addition.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}