[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness, using exponential decay and inf for infeasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = np.exp(-close_fit)\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Add a bonus for bins that will be almost full after placing the item\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - 0.1)) # Target 0.1 remaining\n    priorities[feasible_bins] += almost_full_bonus * 0.5\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and resulting fullness additively.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Boost priority for bins that are almost full after adding the item\n    remaining_capacity = bins_remain_cap - item\n    almost_full = (remaining_capacity >=0) & (remaining_capacity < (0.1 * bins_remain_cap))\n    close_to_full_boost = np.zeros_like(bins_remain_cap, dtype=float)\n    close_to_full_boost[almost_full] = 0.5  # Boost priority\n\n    # Combine rewards\n    priorities = close_fit_reward + close_to_full_boost\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on closeness of fit, fullness, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # 1. Closeness of fit (exponential decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. Reward nearly full bins after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # 3. Penalize low utilization, encourage fuller bins\n    bin_size = np.max(bins_remain_cap)\n    utilization = (bin_size - remaining_after_fit) / bin_size\n    empty_penalty = np.exp(-5 * (1 - utilization))\n    priorities = priorities * empty_penalty\n    \n    min_utilization_threshold = 0.2\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = 0\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and resulting fullness, add small exploration.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities[feasible_bins] = np.exp(-close_fit[feasible_bins])\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Add small exploration\n    priorities += np.random.normal(0, 0.001, size=bins_remain_cap.shape)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 34.12445153570005,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = -np.inf\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and resulting fullness additively.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  # Avoid errors later\n\n    # Reward close fit (small wasted space)\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Reward bins that will be nearly full\n    nearly_full_reward = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Additively combine the rewards for final priority\n    priorities = close_fit_reward + nearly_full_reward\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 86.58755484643,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit, fullness, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Closeness of fit (higher priority for bins where the item fits well)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  #avoid error on infeasible bins\n\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward\n\n    # Fill level after adding the item (encourage full bins)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[infeasible_mask] = np.inf\n    fill_level = 1 - np.abs(remaining_after_fit) / np.max(bins_remain_cap) # Scale to bin size\n    priorities += fill_level * 0.75 # Weigh fill level\n\n    # Avoid small remaining capacities (reduce fragmentation)\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_capacity_threshold = 0.1  # Fraction of max bin capacity\n    \n    valid_indices = (remaining_after_fit > 0) & (remaining_after_fit != np.inf)\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 84.98205025927405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using wasted space, fullness, and infeasibility.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Wasted space calculation (exclude infeasible)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-2 * wasted_space)\n\n    # Reward nearly full bins exponentially\n    bin_size = np.max(bins_remain_cap)  # Assuming all bins have the same capacity\n    utilization = (bin_size - wasted_space) / bin_size\n    nearly_full_reward = np.exp(-2 * np.abs(wasted_space)) # more sensitive\n\n    # Combine rewards and penalties additively\n    priorities = close_fit_reward + nearly_full_reward\n\n    # Penalize bins that remain far from full. Encourage utilization.\n    empty_penalty = np.exp(-5 * (1 - utilization))\n    priorities += empty_penalty  # reduced impact\n\n    # Minimum utilization threshold to reduce extreme fragmentation\n    min_utilization_threshold = 0.2\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = -np.inf\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness, additively combined.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Reward bins with capacity close to item size\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n\n    # Penalize bins where the item doesn't fit\n    priorities[~possible_bins] = -np.inf\n\n    # Reward bins that become nearly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Closeness of fit: Bins with remaining capacity close to the item size get higher priority.\n    2. Fill percentage: Bins that become nearly full after adding the item are also prioritized.\n    3. Avoidance of small remaining capacity: Bins that would leave very small remaining capacity\n       are penalized to reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = 0\n\n    # Reward bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay for close fit\n\n    # Reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-5 * np.abs(remaining_after_fit))  # Stronger weight on nearly full\n    priorities += nearly_full\n\n    # Penalize bins that would leave a very small remaining capacity (fragmentation)\n    small_remaining = remaining_after_fit < 0.1  # Define \"small\" as less than 0.1\n    priorities[~cannot_fit & small_remaining] -= 0.5  # Reduce priority for small remaining\n\n    # Prioritize bins with higher utilization after placement\n    utilization = (bins_remain_cap - item) / 1.0  # Calculate utilization (assuming bin size of 1.0)\n    priorities += np.clip(1 - np.abs(utilization),0,1) #Linear reward to bins almost full after packing.\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a bin-selection pressure.\n    It prioritizes bins where the item almost fits perfectly and bins that would be filled close to full if the item were added.\n    A bin-selection pressure is added to encourage using bins that are already somewhat full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Also reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Add a bin-selection pressure: encourage using bins that are already somewhat full.\n    # This helps to consolidate items and potentially reduce the overall number of bins used.\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap)) #Normalize remaining capacity\n\n    priorities += 0.5 * bin_utilization #Scale utilization so it doesn't dominate\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a slight preference\n    for bins that are already somewhat full. It also adds a penalty for creating\n    very small fragments.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit: Prioritize bins where the item almost fits perfectly.\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay\n\n    # 2. Infeasibility: Penalize bins where the item doesn't fit (assign zero priority).\n    priorities[bins_remain_cap < item] = 0\n\n    # 3. Nearly Full: Reward bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full\n\n    # 4. Already Occupied: Slight preference for bins that are already somewhat full.\n    #    This encourages filling existing bins before opening new ones.\n    already_occupied = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Normalized remaining capacity\n    priorities += 0.5 * already_occupied # Reduced coefficient\n\n    # 5. Fragmentation Penalty: Penalize bins where the item would leave a very small fragment.\n    small_fragment_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_fragment_indices = np.where((bins_remain_cap >= item) & (remaining_after_fit > 0) & (remaining_after_fit < 0.1)) # Fragments smaller than 0.1\n    small_fragment_penalty[small_fragment_indices] = -1 # Penalty \n    priorities += small_fragment_penalty\n\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and bin fill level\n    after item placement. It prioritizes bins that provide a close fit and lead\n    to high bin utilization while minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit Priority:\n    # Prioritize bins where item size is close to remaining capacity.\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)  # Sharper decay for better fit\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    # Prioritize bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    # Penalize bins that would leave significant wasted space after adding the item.\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)  # Larger remaining gets larger penalty. The decay is smaller, such that we still account for this factor.\n    priorities += fragmentation_penalty\n\n    # 4. Infeasibility Handling:\n    # Set priority to zero for bins where the item doesn't fit.\n    priorities[bins_remain_cap < item] = 0\n\n    # 5. Scale to better rank feasible candidates.\n    priorities[bins_remain_cap >= item] *= (bins_remain_cap[bins_remain_cap >= item] - item + 0.0001) / (bins_remain_cap[bins_remain_cap >= item] + 0.0001)\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.956122856003196,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_hs1.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                filling_threshold: float = 0.09828587701262215,\n                bin_capacity: float = 1.7887301452079374,\n                close_fit_decay: float = 7.651916482429452,\n                nearly_full_decay: float = 4.195013695678419,\n                nearly_full_weight: float = 0.001819948638818153,\n                larger_bins_bonus: float = 0.44434280728208353,\n                threshold_bonus_weight: float = 0.12899367313752863) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        filling_threshold: The filling threshold (e.g., 75% full) after adding the item.\n        bin_capacity: The capacity of the bin.\n        close_fit_decay: Exponential decay factor for close fit priority.\n        nearly_full_decay: Exponential decay factor for nearly full reward.\n        nearly_full_weight: Weight of the nearly full reward.\n        larger_bins_bonus: Small bonus for bins larger than the item.\n        threshold_bonus_weight: Weight of the threshold bonus.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), threshold_bonus_weight, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-close_fit_decay * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-nearly_full_decay * np.abs(remaining_after_fit)) * item_fits\n    priorities += nearly_full_weight * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += larger_bins_bonus * larger_bins\n\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9389708815317115,
    "exec_success": true
  }
]