{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a filling threshold.\n    It prioritizes bins where the item fits, leading to a fill level above a certain threshold,\n    while also considering bins that offer a close fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Define a filling threshold (e.g., 75% full) after adding the item\n    filling_threshold = 0.75\n    bin_capacity = 1.0  # Assuming bin capacity is 1.0, modify as needed\n\n    # Calculate remaining capacity after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    \n    # Identify bins where the item fits\n    item_fits = bins_remain_cap >= item\n    \n    # Calculate fill level after adding the item\n    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity\n    \n    # Give a bonus to bins that meet the filling threshold after item placement\n    threshold_bonus = np.where(item_fits & (fill_level >= filling_threshold), 1.0, 0.0)\n    priorities += threshold_bonus\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-5 * close_fit)  # Exponential decay around perfect fit\n    priorities += close_fit_priority * item_fits  # Only consider if the item fits\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Reward bins that become nearly full after adding the item, but less aggressively\n    nearly_full = np.exp(-10 * np.abs(remaining_after_fit)) * item_fits\n    priorities += 0.5 * nearly_full\n    \n    # Add a small bonus for bins which are larger than the item, to prioritize packing\n    # something rather than nothing.\n    larger_bins = (bins_remain_cap >= item)\n    priorities += 0.1 * larger_bins\n\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a slight preference\n    for bins that are already somewhat full. It also adds a penalty for creating\n    very small fragments.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit: Prioritize bins where the item almost fits perfectly.\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay\n\n    # 2. Infeasibility: Penalize bins where the item doesn't fit (assign zero priority).\n    priorities[bins_remain_cap < item] = 0\n\n    # 3. Nearly Full: Reward bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full\n\n    # 4. Already Occupied: Slight preference for bins that are already somewhat full.\n    #    This encourages filling existing bins before opening new ones.\n    already_occupied = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Normalized remaining capacity\n    priorities += 0.5 * already_occupied # Reduced coefficient\n\n    # 5. Fragmentation Penalty: Penalize bins where the item would leave a very small fragment.\n    small_fragment_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_fragment_indices = np.where((bins_remain_cap >= item) & (remaining_after_fit > 0) & (remaining_after_fit < 0.1)) # Fragments smaller than 0.1\n    small_fragment_penalty[small_fragment_indices] = -1 # Penalty \n    priorities += small_fragment_penalty\n\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a bin-selection pressure.\n    It prioritizes bins where the item almost fits perfectly and bins that would be filled close to full if the item were added.\n    A bin-selection pressure is added to encourage using bins that are already somewhat full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)  # Exponential decay around perfect fit\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    priorities[bins_remain_cap < item] = 0\n\n    # Also reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Add a bin-selection pressure: encourage using bins that are already somewhat full.\n    # This helps to consolidate items and potentially reduce the overall number of bins used.\n    bin_utilization = 1 - (bins_remain_cap / np.max(bins_remain_cap)) #Normalize remaining capacity\n\n    priorities += 0.5 * bin_utilization #Scale utilization so it doesn't dominate\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit, fullness, and fragmentation.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Closeness of fit (higher priority for bins where the item fits well)\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  #avoid error on infeasible bins\n\n    close_fit_reward = np.exp(-np.abs(wasted_space)*2)\n    priorities += close_fit_reward\n\n    # Fill level after adding the item (encourage full bins)\n    remaining_after_fit = bins_remain_cap - item\n    remaining_after_fit[infeasible_mask] = np.inf\n    fill_level = 1 - np.abs(remaining_after_fit) / np.max(bins_remain_cap) # Scale to bin size\n    priorities += fill_level * 0.75 # Weigh fill level\n\n    # Avoid small remaining capacities (reduce fragmentation)\n    small_capacity_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_capacity_threshold = 0.1  # Fraction of max bin capacity\n    \n    valid_indices = (remaining_after_fit > 0) & (remaining_after_fit != np.inf)\n    small_capacity_penalty[valid_indices] = np.exp(-remaining_after_fit[valid_indices] / small_capacity_threshold)\n    priorities[valid_indices] -= small_capacity_penalty[valid_indices]* 0.5\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Closeness of fit: Bins with remaining capacity close to the item size get higher priority.\n    2. Fill percentage: Bins that become nearly full after adding the item are also prioritized.\n    3. Avoidance of small remaining capacity: Bins that would leave very small remaining capacity\n       are penalized to reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = 0\n\n    # Reward bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay for close fit\n\n    # Reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-5 * np.abs(remaining_after_fit))  # Stronger weight on nearly full\n    priorities += nearly_full\n\n    # Penalize bins that would leave a very small remaining capacity (fragmentation)\n    small_remaining = remaining_after_fit < 0.1  # Define \"small\" as less than 0.1\n    priorities[~cannot_fit & small_remaining] -= 0.5  # Reduce priority for small remaining\n\n    # Prioritize bins with higher utilization after placement\n    utilization = (bins_remain_cap - item) / 1.0  # Calculate utilization (assuming bin size of 1.0)\n    priorities += np.clip(1 - np.abs(utilization),0,1) #Linear reward to bins almost full after packing.\n    \n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and a slight preference\n    for bins that are already somewhat full. It also adds a penalty for creating\n    very small fragments.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit: Prioritize bins where the item almost fits perfectly.\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay\n\n    # 2. Infeasibility: Penalize bins where the item doesn't fit (assign zero priority).\n    priorities[bins_remain_cap < item] = 0\n\n    # 3. Nearly Full: Reward bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full\n\n    # 4. Already Occupied: Slight preference for bins that are already somewhat full.\n    #    This encourages filling existing bins before opening new ones.\n    already_occupied = 1 - (bins_remain_cap / np.max(bins_remain_cap)) # Normalized remaining capacity\n    priorities += 0.5 * already_occupied # Reduced coefficient\n\n    # 5. Fragmentation Penalty: Penalize bins where the item would leave a very small fragment.\n    small_fragment_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    small_fragment_indices = np.where((bins_remain_cap >= item) & (remaining_after_fit > 0) & (remaining_after_fit < 0.1)) # Fragments smaller than 0.1\n    small_fragment_penalty[small_fragment_indices] = -1 # Penalty \n    priorities += small_fragment_penalty\n\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on closeness of fit, fullness, and fragmentation.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # 1. Closeness of fit (exponential decay)\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-2 * close_fit)\n    priorities[bins_remain_cap < item] = 0\n\n    # 2. Reward nearly full bins after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-2 * np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # 3. Penalize low utilization, encourage fuller bins\n    bin_size = np.max(bins_remain_cap)\n    utilization = (bin_size - remaining_after_fit) / bin_size\n    empty_penalty = np.exp(-5 * (1 - utilization))\n    priorities = priorities * empty_penalty\n    \n    min_utilization_threshold = 0.2\n    mask = utilization < min_utilization_threshold\n    priorities[mask] = 0\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. Closeness of fit: Bins with remaining capacity close to the item size get higher priority.\n    2. Fill percentage: Bins that become nearly full after adding the item are also prioritized.\n    3. Avoidance of small remaining capacity: Bins that would leave very small remaining capacity\n       are penalized to reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins where the item doesn't fit (assign zero priority)\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = 0\n\n    # Reward bins where the item almost fits perfectly\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities += np.exp(-2 * close_fit)  # Sharper exponential decay for close fit\n\n    # Reward bins that become nearly full after adding the item\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-5 * np.abs(remaining_after_fit))  # Stronger weight on nearly full\n    priorities += nearly_full\n\n    # Penalize bins that would leave a very small remaining capacity (fragmentation)\n    small_remaining = remaining_after_fit < 0.1  # Define \"small\" as less than 0.1\n    priorities[~cannot_fit & small_remaining] -= 0.5  # Reduce priority for small remaining\n\n    # Prioritize bins with higher utilization after placement\n    utilization = (bins_remain_cap - item) / 1.0  # Calculate utilization (assuming bin size of 1.0)\n    priorities += np.clip(1 - np.abs(utilization),0,1) #Linear reward to bins almost full after packing.\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and resulting fullness additively.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf\n\n    # Reward close fits exponentially\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Boost priority for bins that are almost full after adding the item\n    remaining_capacity = bins_remain_cap - item\n    almost_full = (remaining_capacity >=0) & (remaining_capacity < (0.1 * bins_remain_cap))\n    close_to_full_boost = np.zeros_like(bins_remain_cap, dtype=float)\n    close_to_full_boost[almost_full] = 0.5  # Boost priority\n\n    # Combine rewards\n    priorities = close_fit_reward + close_to_full_boost\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fit and fullness, using exponential decay and inf for infeasibility.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n    priorities[~feasible_bins] = -np.inf\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    close_fit = np.abs(bins_remain_cap[feasible_bins] - item)\n    priorities[feasible_bins] = np.exp(-close_fit)\n\n    remaining_after_fit = bins_remain_cap[feasible_bins] - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities[feasible_bins] += nearly_full\n\n    # Add a bonus for bins that will be almost full after placing the item\n    almost_full_bonus = np.exp(-np.abs(remaining_after_fit - 0.1)) # Target 0.1 remaining\n    priorities[feasible_bins] += almost_full_bonus * 0.5\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and bin fill level\n    after item placement. It prioritizes bins that provide a close fit and lead\n    to high bin utilization while minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit Priority:\n    # Prioritize bins where item size is close to remaining capacity.\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)  # Sharper decay for better fit\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    # Prioritize bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    # Penalize bins that would leave significant wasted space after adding the item.\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)  # Larger remaining gets larger penalty. The decay is smaller, such that we still account for this factor.\n    priorities += fragmentation_penalty\n\n    # 4. Infeasibility Handling:\n    # Set priority to zero for bins where the item doesn't fit.\n    priorities[bins_remain_cap < item] = 0\n\n    # 5. Scale to better rank feasible candidates.\n    priorities[bins_remain_cap >= item] *= (bins_remain_cap[bins_remain_cap >= item] - item + 0.0001) / (bins_remain_cap[bins_remain_cap >= item] + 0.0001)\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers space utilization, fragmentation, and bin fill level\n    after item placement. It prioritizes bins that provide a close fit and lead\n    to high bin utilization while minimizing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Close Fit Priority:\n    # Prioritize bins where item size is close to remaining capacity.\n    close_fit_diff = np.abs(bins_remain_cap - item)\n    close_fit_priority = np.exp(-2 * close_fit_diff)  # Sharper decay for better fit\n    priorities += close_fit_priority\n\n    # 2. High Utilization Priority:\n    # Prioritize bins that become nearly full after adding the item.\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_priority = np.exp(-2 * np.abs(remaining_after_fit)) # Sharper decay\n    priorities += nearly_full_priority\n\n    # 3. Fragmentation Penalty:\n    # Penalize bins that would leave significant wasted space after adding the item.\n    fragmentation_penalty = np.exp(-0.5 * remaining_after_fit)  # Larger remaining gets larger penalty. The decay is smaller, such that we still account for this factor.\n    priorities += fragmentation_penalty\n\n    # 4. Infeasibility Handling:\n    # Set priority to zero for bins where the item doesn't fit.\n    priorities[bins_remain_cap < item] = 0\n\n    # 5. Scale to better rank feasible candidates.\n    priorities[bins_remain_cap >= item] *= (bins_remain_cap[bins_remain_cap >= item] - item + 0.0001) / (bins_remain_cap[bins_remain_cap >= item] + 0.0001)\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on close fit and resulting fullness, additively.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    possible_bins = bins_remain_cap >= item\n\n    if not np.any(possible_bins):\n        return priorities\n\n    # Close fit priority\n    close_fit = np.abs(bins_remain_cap - item)\n    priorities = np.exp(-close_fit)\n    priorities[~possible_bins] = -np.inf # Infeasible bins get -inf priority\n\n    # Fullness reward\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full = np.exp(-np.abs(remaining_after_fit))\n    priorities += nearly_full\n\n    # Encourage filling bins already somewhat full\n    priorities += bins_remain_cap * 0.01\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on wasted space and resulting fullness additively.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Infeasible bins get -inf priority\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Calculate wasted space if item were placed in each bin\n    wasted_space = bins_remain_cap - item\n    wasted_space[infeasible_mask] = np.inf  # Avoid errors later\n\n    # Reward close fit (small wasted space)\n    close_fit_reward = np.exp(-wasted_space)\n\n    # Reward bins that will be nearly full\n    nearly_full_reward = np.exp(-1 / (wasted_space + 1e-9))\n\n    # Additively combine the rewards for final priority\n    priorities = close_fit_reward + nearly_full_reward\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}