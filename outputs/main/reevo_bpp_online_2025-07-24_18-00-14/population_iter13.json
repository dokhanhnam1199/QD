[
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity ratio after adding the item\n    remaining_cap_ratio = (bins_remain_cap - item) / bin_capacity\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_ratio, -np.inf)\n    \n    # Apply non-linear transformation to amplify differences\n    priorities = np.where(valid_bins_mask, 1 - np.power(remaining_cap_ratio, 0.5), priorities)\n    \n    # Normalize priorities for valid bins to ensure comparability\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the waste after adding the item to valid bins\n    waste_after_addition = np.where(valid_bins_mask, bins_remain_cap - item, np.inf)\n    \n    # Assign priority based on waste after addition\n    priorities = -waste_after_addition / bin_capacity\n    \n    # Apply non-linear transformation to prioritize bins with less waste\n    priorities = np.where(valid_bins_mask, np.tanh(-priorities * 10), -np.inf)\n    \n    # Normalize priorities for valid bins to ensure comparability\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_cap = bins_remain_cap - item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap / capacity, -np.inf)\n    \n    # Apply exponential decay to prioritize tighter fits\n    priorities = np.where(valid_bins_mask, np.exp(priorities), priorities)\n    \n    # Normalize priorities for valid bins to ensure comparability\n    min_priority = np.min(priorities[valid_bins_mask])\n    max_priority = np.max(priorities[valid_bins_mask])\n    \n    if max_priority != min_priority:\n        priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to valid bins with less remaining capacity after addition\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -np.inf)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.22241631426408,
    "token_count": 144.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the waste if the item is added to each valid bin\n    waste = np.where(valid_bins_mask, bins_remain_cap - item, bin_capacity)\n    \n    # Assign high priority to bins that result in less waste\n    priorities = np.where(valid_bins_mask, -waste, -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the relative remaining capacity after adding the item\n    relative_remain_cap = (bins_remain_cap - item) / bin_capacity\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, relative_remain_cap, -np.inf)\n    \n    # Apply non-linear transformation to amplify differences\n    priorities = np.where(valid_bins_mask, np.tanh(relative_remain_cap * 10), priorities)\n    \n    # Shift and scale priorities to [0, 1] range for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n        else:\n            priorities = np.where(valid_bins_mask, 1.0, priorities)\n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response6.txt_stdout.txt",
    "code_path": "problem_iter12_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    # Apply non-linear transformation to amplify differences\n    priorities = np.where(valid_bins_mask, np.exp(-priorities / bin_capacity), priorities)\n    \n    # Normalize priorities for valid bins to ensure comparability\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response7.txt_stdout.txt",
    "code_path": "problem_iter12_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Identify bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the fill level of bins after adding the item\n    fill_level_after_addition = (bin_capacity - (bins_remain_cap - item)) / bin_capacity\n    \n    # Assign a priority score based on the fill level\n    priorities = np.where(valid_bins_mask, fill_level_after_addition, -np.inf)\n    \n    # Normalize priorities for valid bins to be within [0, 1]\n    min_fill_level = np.min(fill_level_after_addition[valid_bins_mask])\n    max_fill_level = np.max(fill_level_after_addition[valid_bins_mask])\n    \n    if max_fill_level != min_fill_level:\n        normalized_priorities = (fill_level_after_addition - min_fill_level) / (max_fill_level - min_fill_level)\n        priorities = np.where(valid_bins_mask, normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n11\n3\n116.75790004038474\n87.22241631426408\n144\n"
  },
  {
    "stdout_filepath": "problem_iter12_response8.txt_stdout.txt",
    "code_path": "problem_iter12_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities[valid_bins_mask] = 1 - (valid_priorities - min_priority) / (max_priority - min_priority)\n        else:\n            priorities[valid_bins_mask] = 1\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.22241631426408,
    "token_count": 144.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the negative remaining capacity after adding the item for valid bins\n    neg_remaining_cap_after_addition = np.where(valid_bins_mask, -(bins_remain_cap - item), -np.inf)\n    \n    # Apply exponential transformation to prioritize bins that fit items tightly\n    priorities = np.exp(neg_remaining_cap_after_addition / item)\n    \n    # Normalize priorities for valid bins to ensure comparability\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), 0)\n    \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.22241631426408,
    "token_count": 144.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    relative_remain_cap = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins based on relative remaining capacity\n    priorities = np.where(valid_bins_mask, np.exp(-relative_remain_cap), -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities = np.where(valid_bins_mask, normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.60231981213285,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response1.txt_stdout.txt",
    "code_path": "problem_iter13_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, np.exp(-remaining_cap_after_addition / bins_remain_cap), -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    min_priority = np.min(valid_priorities)\n    max_priority = np.max(valid_priorities)\n    \n    if max_priority != min_priority:\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n        priorities = np.where(valid_bins_mask, normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.60231981213285,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the ratio of item size to the remaining capacity\n    ratio = item / bins_remain_cap\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Apply a non-linear transformation (exponential decay) to the ratio for valid bins\n    priorities = np.where(valid_bins_mask, np.exp(-ratio), -np.inf)\n    \n    # Normalize priorities for valid bins\n    min_ratio = np.min(ratio[valid_bins_mask])\n    max_ratio = np.max(ratio[valid_bins_mask])\n    \n    if max_ratio != min_ratio:\n        normalized_priorities = (ratio - min_ratio) / (max_ratio - min_ratio)\n        priorities = np.where(valid_bins_mask, 1 - normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.60231981213285,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, np.exp(-remaining_cap_after_addition / bins_remain_cap), -np.inf)\n    \n    # Normalize priorities for valid bins\n    priorities_valid = priorities[valid_bins_mask]\n    min_priority, max_priority = np.min(priorities_valid), np.max(priorities_valid)\n    \n    if max_priority != min_priority:\n        priorities_valid = (priorities_valid - min_priority) / (max_priority - min_priority)\n        priorities = np.where(valid_bins_mask, priorities_valid, priorities)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.60231981213285,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response4.txt_stdout.txt",
    "code_path": "problem_iter13_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, np.exp(-remaining_cap_after_addition / bins_remain_cap), -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities = np.where(valid_bins_mask, normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 116.75790004038474,
    "mi": 87.60231981213285,
    "token_count": 146.0,
    "exec_success": true
  }
]