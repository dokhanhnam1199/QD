[
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, (bins_remain_cap - remaining_cap_after_addition) / bin_capacity, -np.inf)\n    \n    # Apply non-linear transformation to priorities for valid bins\n    priorities = np.where(valid_bins_mask, np.log(1 + priorities), priorities)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    min_priority = np.min(valid_priorities)\n    max_priority = np.max(valid_priorities)\n    \n    if max_priority != min_priority:\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n        priorities = np.where(valid_bins_mask, normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    relative_remaining_cap = (bins_remain_cap - item) / bins_remain_cap\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = relative_remaining_cap >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, relative_remaining_cap, -np.inf)\n    \n    # Apply non-linear transformation to encourage tighter packing\n    priorities = np.where(valid_bins_mask, np.exp(-5 * priorities), priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 34.86917501586544,
    "mi": 69.89270581461254,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Step 1: Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Step 2: Identify bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Step 3: Assign a base priority score to each bin based on its remaining capacity ratio\n    base_priority = np.where(valid_bins_mask, 1 - remaining_cap_after_addition / bins_remain_cap, -np.inf)\n    \n    # Step 4: Apply a non-linear transformation to the base priority for valid bins\n    priorities = np.where(valid_bins_mask, np.power(base_priority, 2), base_priority)\n    \n    # Step 5: Normalize the priorities for valid bins to ensure they are within a comparable range\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 34.86917501586544,
    "mi": 69.89270581461254,
    "token_count": 63.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    relative_remaining_cap = remaining_cap_after_addition / bin_capacity\n    priorities = np.where(valid_bins_mask, -relative_remaining_cap, -np.inf)\n    \n    # Apply non-linear transformation to encourage packing items tightly\n    priorities = np.where(valid_bins_mask, -np.power(priorities, 2), priorities)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities[valid_bins_mask] = normalized_priorities\n    \n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, (bins_remain_cap - remaining_cap_after_addition) / bin_capacity, -np.inf)\n    \n    # Apply non-linear transformation to encourage packing items tightly\n    priorities = np.where(valid_bins_mask, np.power(priorities, 2), priorities)\n    \n    # Incorporate relative remaining capacity to guide the optimization\n    relative_remaining_cap = bins_remain_cap / bin_capacity\n    priorities = np.where(valid_bins_mask, priorities * (1 - relative_remaining_cap), priorities)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities[valid_bins_mask] = normalized_priorities\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition / bin_capacity, -np.inf)\n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition / bin_capacity, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    priorities = np.where(valid_bins_mask, 1 - priorities, priorities)\n    \n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    relative_remaining_cap = bins_remain_cap / bin_capacity\n    priorities = np.where(valid_bins_mask, 1 - relative_remaining_cap, -np.inf)\n    \n    # Apply non-linear transformation to encourage packing items tightly\n    priorities = np.where(valid_bins_mask, np.power(priorities, 2), priorities)\n    \n    # Normalize priorities for valid bins to balance exploration and exploitation\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities[valid_bins_mask] = normalized_priorities\n    \n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    relative_remaining_cap = bins_remain_cap / bin_capacity\n    priorities = np.where(valid_bins_mask, -relative_remaining_cap, -np.inf)\n    \n    # Apply non-linear transformation to encourage packing items tightly\n    priorities = np.where(valid_bins_mask, np.exp(priorities), priorities)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities[valid_bins_mask] = normalized_priorities\n    \n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n4\n1\n34.86917501586544\n69.89270581461254\n63\n"
  },
  {
    "stdout_filepath": "problem_iter6_response9.txt_stdout.txt",
    "code_path": "problem_iter6_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, item / (bins_remain_cap + 1e-8), -np.inf)\n    \n    # No need to normalize priorities as the relative order is maintained\n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 34.86917501586544,
    "mi": 69.89270581461254,
    "token_count": 63.0,
    "exec_success": true
  }
]