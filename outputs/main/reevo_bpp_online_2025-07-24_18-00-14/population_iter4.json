[
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign low priority to invalid bins\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    if np.any(valid_bins_mask):\n        # Calculate a nuanced score that considers both remaining capacity and item-to-bin size ratio\n        remaining_cap_ratio = remaining_cap_after_addition[valid_bins_mask] / bin_capacity\n        item_to_bin_ratio = item / bins_remain_cap[valid_bins_mask]\n        \n        # Calculate scores using a non-linear transformation\n        scores = np.exp(-(remaining_cap_ratio ** 2)) * item_to_bin_ratio\n        \n        # Normalize the scores\n        min_score = np.min(scores)\n        max_score = np.max(scores)\n        if max_score != min_score:\n            normalized_scores = (scores - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(scores)\n        \n        # Update priorities for valid bins\n        priorities = np.where(valid_bins_mask, normalized_scores, priorities)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign low priority to invalid bins\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For valid bins, calculate a nuanced score that considers both remaining capacity ratio and item-to-bin size ratio\n    if np.any(valid_bins_mask):\n        remaining_cap_ratio = remaining_cap_after_addition[valid_bins_mask] / bin_capacity\n        item_to_bin_ratio = item / bins_remain_cap[valid_bins_mask]\n        \n        # Apply non-linear transformation to the ratios\n        score = np.exp(-remaining_cap_ratio) * np.sqrt(item_to_bin_ratio)\n        \n        # Normalize the scores\n        min_score = np.min(score)\n        max_score = np.max(score)\n        if max_score != min_score:\n            normalized_scores = (score - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(score)\n        \n        # Update priorities for valid bins\n        priorities = np.where(valid_bins_mask, normalized_scores, priorities)\n    \n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response2.txt_stdout.txt",
    "code_path": "problem_iter4_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign priority based on remaining capacity after addition\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -np.inf)\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.0,
    "mi": 86.22626174415105,
    "token_count": 117.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, np.zeros_like(bins_remain_cap), -np.inf)\n    \n    # Calculate a nuanced score that considers both remaining capacity and item-to-bin size ratio\n    if np.any(valid_bins_mask):\n        valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n        remaining_ratio = remaining_cap_after_addition[valid_bins_mask] / bin_capacities\n        item_to_bin_ratio = item / valid_bins_remain_cap\n        \n        # Using a combination of the remaining capacity ratio and item-to-bin size ratio\n        scores = -remaining_ratio + item_to_bin_ratio ** 0.5\n        \n        # Normalize the scores\n        min_score = np.min(scores)\n        max_score = np.max(scores)\n        if max_score != min_score:\n            normalized_scores = (scores - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(scores)\n        \n        priorities = np.where(valid_bins_mask, normalized_scores, priorities)\n    \n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Component 1: Encourage packing items tightly\n    tightness_component = np.where(valid_bins_mask, -remaining_cap_after_addition / bin_capacities, -np.inf)\n    \n    # Component 2: Consider the item-to-bin size ratio\n    item_to_bin_ratio_component = np.where(valid_bins_mask, item / bins_remain_cap, 0)\n    \n    # Component 3: Penalize bins that are nearly empty\n    bin_utilization_component = np.where(valid_bins_mask, (bin_capacities - bins_remain_cap) / bin_capacities, 0)\n    \n    # Combine the components non-linearly\n    priorities = tightness_component + 0.1 * (item_to_bin_ratio_component ** 0.5) + 0.2 * np.tanh(bin_utilization_component)\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response5.txt_stdout.txt",
    "code_path": "problem_iter4_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition ** 2, -np.inf)\n    \n    # Factor 1: Encourage packing items tightly\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    if max_remaining_cap != min_remaining_cap:\n        normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        tightness_factor = -(normalized_priorities ** 1.5)\n    else:\n        tightness_factor = np.where(valid_bins_mask, -1, -np.inf)  # All valid bins have the same priority\n    \n    # Factor 2: Consider the item-to-bin size ratio\n    item_to_bin_ratio = item / bins_remain_cap\n    ratio_factor = np.where(valid_bins_mask, item_to_bin_ratio, 0)\n    \n    # Factor 3: Encourage using bins that are already filled a lot\n    bin_fill_level = (bin_capacity - bins_remain_cap) / bin_capacity\n    fill_level_factor = np.where(valid_bins_mask, bin_fill_level, 0)\n    \n    # Combine the factors with different weights\n    priorities = np.where(valid_bins_mask, 0.6 * tightness_factor + 0.2 * ratio_factor + 0.2 * fill_level_factor, priorities)\n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response6.txt_stdout.txt",
    "code_path": "problem_iter4_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: Capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Component 1: Prioritize bins that leave less remaining capacity after adding the item\n    remaining_cap_priority = np.where(valid_bins_mask, -remaining_cap_after_addition ** 2, -np.inf)\n    \n    # Component 2: Consider the item-to-bin size ratio\n    item_to_bin_ratio = item / bins_remain_cap\n    ratio_priority = np.where(valid_bins_mask, item_to_bin_ratio ** 0.5, 0)\n    \n    # Component 3: Encourage using newer bins (lower index) when possible\n    bin_usage_priority = -np.arange(len(bins_remain_cap)) / len(bins_remain_cap)\n    bin_usage_priority = np.where(valid_bins_mask, bin_usage_priority, 0)\n    \n    # Combine the priority components\n    priorities = remaining_cap_priority + 0.1 * ratio_priority + 0.05 * bin_usage_priority\n    \n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -np.inf)\n    \n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 76.0,
    "mi": 86.22626174415105,
    "token_count": 117.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_full_cap: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_full_cap: The full capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, 0.0, -np.inf)\n    \n    # Calculate nuanced scores considering both remaining capacity and item-to-bin size ratio\n    if np.any(valid_bins_mask):\n        item_to_bin_ratio = item / bins_remain_cap[valid_bins_mask]\n        remaining_cap_ratio = remaining_cap_after_addition[valid_bins_mask] / bin_full_cap\n        scores = np.exp(-(remaining_cap_ratio)) * item_to_bin_ratio\n        priorities[valid_bins_mask] = scores\n    \n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_full_cap'\n10\n2\n76.0\n86.22626174415105\n117\n"
  },
  {
    "stdout_filepath": "problem_iter4_response9.txt_stdout.txt",
    "code_path": "problem_iter4_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign low priority to invalid bins\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # Calculate a nuanced score that considers both remaining capacity and item-to-bin size ratio for valid bins\n    if np.any(valid_bins_mask):\n        remaining_cap_ratio = remaining_cap_after_addition[valid_bins_mask] / bin_capacity\n        item_to_bin_ratio = item / bins_remain_cap[valid_bins_mask]\n        valid_priorities = np.exp(-remaining_cap_ratio) * item_to_bin_ratio\n        priorities[valid_bins_mask] = valid_priorities\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n2\n76.0\n86.22626174415105\n117\n"
  }
]