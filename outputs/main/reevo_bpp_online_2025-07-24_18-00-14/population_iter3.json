[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can hold the item, prioritize those with the least remaining capacity\n                          (bins_remain_cap - remaining_after_addition) / bin_capacity - (remaining_after_addition / bin_capacity) ** 2, \n                          # For bins that cannot hold the item, assign a very low priority\n                          -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  # Check if there are any bins that can hold the item\n        priorities = np.where(priorities != -np.inf, priorities - max_priority, priorities)\n    \n    return priorities",
    "response_id": 0,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition) / bin_capacity, -np.inf)\n    \n    # Calculate the ratio of item size to bin remaining capacity\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Calculate the fill ratio of the bin before adding the item\n    fill_ratios_before = 1 - bins_remain_cap / bin_capacity\n    \n    # Combine the factors: ability to fit, ratio of item size to remaining capacity, and fill ratio before addition\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios) + np.log(1 + fill_ratios_before), priorities)\n    \n    # Add a small random noise to break ties\n    priorities = priorities + np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 1,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacities: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacities: Array of total capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    utilization_ratios = (bin_capacities - bins_remain_cap + item) / bin_capacities\n    \n    # Combine the two factors: the ability to fit the item and the utilization ratio after adding the item\n    priorities = np.where(can_fit, priorities + np.log(1 + utilization_ratios), priorities)\n    \n    # Add a slight edge to bins with more remaining capacity to avoid overly packed bins\n    priorities = np.where(can_fit, priorities + np.log(1 + bins_remain_cap / bin_capacities), priorities)\n    \n    return priorities",
    "response_id": 2,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacities'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    tightness = -np.abs(remaining_after_addition)\n    \n    # Calculate the ratio of item size to bin remaining capacity\n    epsilon = 1e-6\n    item_to_remain_ratio = item / (bins_remain_cap + epsilon)\n    \n    # Calculate the ratio of bin used capacity to total bin capacity\n    used_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    \n    # Combine the factors: ability to fit, tightness, item to remaining capacity ratio, and used ratio\n    priorities = np.where(can_fit, tightness + np.log(1 + item_to_remain_ratio) + used_ratio, -np.inf)\n    \n    # Add a small random noise to break ties\n    priorities = priorities + np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 3,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: Capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have enough capacity and are most full\n    priorities = np.where(can_fit, 1 - (bins_remain_cap / bin_capacity), -np.inf)\n    \n    # Add a small noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priorities = np.where(can_fit, priorities + noise, -np.inf)\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item, using a non-linear transformation\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition)**0.5, -np.inf)\n    \n    # Calculate the ratio of item size to bin remaining capacity, avoiding division by zero\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Calculate the fill level of each bin\n    fill_levels = 1 - bins_remain_cap / bin_capacity\n    \n    # Combine multiple factors: the ability to fit the item, the ratio of item size to bin capacity, and the fill level\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios) + np.log(1 + fill_levels), priorities)\n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The total capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # Calculate the ratio of item size to bin remaining capacity\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Calculate the fill rate of the bin after adding the item\n    fill_rates = (bin_capacity - remaining_after_addition) / bin_capacity\n    \n    # Combine the three factors: the ability to fit the item, the ratio of item size to bin remaining capacity, and the fill rate\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios) + np.log(1 + fill_rates), priorities)\n    \n    return priorities",
    "response_id": 6,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # Calculate the ratio of item size to bin remaining capacity\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Calculate the fill rate of the bin before adding the item\n    fill_rates = 1 - bins_remain_cap / bin_capacity\n    \n    # Combine the three factors: the ability to fit the item, the ratio of item size to bin remaining capacity, and the fill rate\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios) + np.log(1 + fill_rates), priorities)\n    \n    return priorities",
    "response_id": 7,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition) / bin_capacity, -np.inf)\n    \n    # Calculate the ratio of item size to the original bin capacity\n    item_to_bin_ratio = item / bin_capacity\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + 1 / (item_to_bin_ratio + 1e-6)), priorities)\n    \n    # Add a small random noise to break ties\n    priorities = priorities + np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, \n                          -(remaining_capacities / bin_capacity),  # Encourage filling bins to capacity\n                          -1e6)\n    \n    # Introduce a nuanced tie-breaking mechanism that considers both the remaining capacity and the bin's fill level\n    fill_levels = 1 - (bins_remain_cap / bin_capacity)\n    priorities += np.where(remaining_capacities >= 0, \n                           -1e-3 * fill_levels + 1e-6 * np.random.uniform(size=len(bins_remain_cap)),  # Add a small random noise\n                           0)\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n10\n1\n165.05865002596164\n84.5120309879694\n117\n"
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -np.inf)\n    \n    # Calculate a nuanced score that considers both remaining capacity and item-to-bin size ratio\n    valid_priorities = np.exp(-(remaining_cap_after_addition[valid_bins_mask] / bins_remain_cap[valid_bins_mask])) * (item / bins_remain_cap[valid_bins_mask])\n    \n    # Normalize the nuanced scores\n    if len(valid_priorities) > 0:\n        min_score = np.min(valid_priorities)\n        max_score = np.max(valid_priorities)\n        if max_score != min_score:\n            normalized_scores = (valid_priorities - min_score) / (max_score - min_score)\n        else:\n            normalized_scores = np.ones_like(valid_priorities)\n        priorities = np.where(valid_bins_mask, normalized_scores, priorities)\n    \n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 183.31714900750262,
    "mi": 83.34838069446452,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition ** 2, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    \n    if max_remaining_cap != min_remaining_cap:\n        normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        # Apply non-linear transformation to priorities\n        priorities = np.where(valid_bins_mask, -(normalized_priorities ** 1.5), priorities)\n    \n    # Consider the ratio of item size to bin remaining capacity\n    item_to_bin_ratio = item / bins_remain_cap\n    ratio_priorities = np.where(valid_bins_mask, item_to_bin_ratio, 0)\n    # Combine the priorities with the ratio\n    priorities = np.where(valid_bins_mask, priorities + 0.1 * ratio_priorities, priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 183.31714900750262,
    "mi": 83.34838069446452,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    # and use non-linear transformation to differentiate between similar packing solutions\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    \n    if max_remaining_cap != min_remaining_cap:\n        normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        # Apply a non-linear transformation to the normalized priorities\n        non_linear_priorities = 1 - np.power(normalized_priorities, 2)\n        priorities = np.where(valid_bins_mask, non_linear_priorities, priorities)\n    else:\n        # If all valid bins have the same remaining capacity, assign the same priority\n        priorities = np.where(valid_bins_mask, 1.0, priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 183.31714900750262,
    "mi": 83.34838069446452,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition ** 2, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    \n    if max_remaining_cap != min_remaining_cap:\n        normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        # Combine size ratio and remaining capacity factors with non-linear transformation\n        size_ratio_factor = (item / bins_remain_cap) ** 0.5\n        priorities = np.where(valid_bins_mask, -(normalized_priorities * 0.7 + size_ratio_factor * 0.3), priorities)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.836457917830076,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 183.31714900750262,
    "mi": 83.34838069446452,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition ** 2, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    \n    if max_remaining_cap != min_remaining_cap:\n        normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        # Apply a non-linear transformation to the normalized priorities\n        priorities = np.where(valid_bins_mask, -(normalized_priorities ** 1.5), priorities)\n    \n    # Consider the item-to-bin size ratio\n    item_to_bin_ratio = item / bins_remain_cap\n    ratio_priorities = np.where(valid_bins_mask, item_to_bin_ratio, 0)\n    # Combine the two priorities\n    priorities = np.where(valid_bins_mask, priorities + 0.1 * ratio_priorities, priorities)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 183.31714900750262,
    "mi": 83.34838069446452,
    "token_count": 178.0,
    "exec_success": true
  }
]