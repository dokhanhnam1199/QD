[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign priority based on remaining capacity after packing the item\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the relative remaining capacity after adding the item for valid bins\n    relative_remain_cap = np.where(valid_bins_mask, (bins_remain_cap - item) / bins_remain_cap, np.inf)\n    \n    # Assign high priority to valid bins based on relative remaining capacity\n    priorities = np.exp(-relative_remain_cap)\n    \n    # Normalize priorities for valid bins to be between 0 and 1\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities = np.where(valid_bins_mask, normalized_priorities, 0)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign priority based on remaining capacity after packing the item\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign priority based on remaining capacity after packing\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    # Normalize priorities for valid bins to be between 0 and 1\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        priorities[valid_bins_mask] = (valid_priorities - np.min(valid_priorities)) / (np.max(valid_priorities) - np.min(valid_priorities) + 1e-8)\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: Capacity of the bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate a tightness score for valid bins, higher is better\n    tightness_score = np.where(valid_bins_mask, 1 - (bins_remain_cap - item) / bin_capacity, -np.inf)\n    \n    # Apply exponential transformation to emphasize the difference in tightness\n    priorities = np.exp(tightness_score)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), 0)\n    \n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n12\n3\n165.05865002596164\n85.41135020331826\n170\n"
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the relative remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign high priority to valid bins based on the relative remaining capacity\n    priorities = np.where(valid_bins_mask, 1 - remaining_cap_after_addition / bin_capacity, -np.inf)\n    \n    # Introduce a slight modification to prioritize bins that are less full before adding the item\n    priorities = np.where(valid_bins_mask, priorities * (1 - (bin_capacity - bins_remain_cap) / bin_capacity), priorities)\n    \n    # Normalize priorities for valid bins\n    priorities_valid = priorities[valid_bins_mask]\n    min_priority, max_priority = np.min(priorities_valid), np.max(priorities_valid)\n    \n    if max_priority != min_priority:\n        priorities_valid = (priorities_valid - min_priority) / (max_priority - min_priority)\n        priorities = np.where(valid_bins_mask, priorities_valid, priorities)\n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n12\n3\n165.05865002596164\n85.41135020331826\n170\n"
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Initialize priorities with -inf for all bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    \n    # For valid bins, calculate the relative remaining capacity after adding the item\n    relative_remain_cap = (bins_remain_cap[valid_bins_mask] - item) / bins_remain_cap[valid_bins_mask]\n    \n    # Assign high priority to valid bins based on relative remaining capacity\n    priorities[valid_bins_mask] = np.exp(-relative_remain_cap)\n    \n    # Normalize priorities for valid bins\n    if np.any(valid_bins_mask):\n        min_priority = np.min(priorities[valid_bins_mask])\n        max_priority = np.max(priorities[valid_bins_mask])\n        if max_priority != min_priority:\n            priorities[valid_bins_mask] = (priorities[valid_bins_mask] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign priority based on remaining capacity after placing the item\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign priority based on the remaining capacity after adding the item\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    return priorities",
    "response_id": 8,
    "obj": 149.30195452732352,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 165.05865002596164,
    "mi": 85.41135020331826,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        bin_capacity: The capacity of each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Calculate the relative remaining capacity after adding the item\n    relative_remain_cap = np.where(valid_bins_mask, (bins_remain_cap - item) / bin_capacity, -1)\n    \n    # Apply a non-linear transformation to the relative remaining capacity for valid bins\n    priorities = np.where(valid_bins_mask, np.exp(-((1 - relative_remain_cap) ** 2)), -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities = np.where(valid_bins_mask, normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 9,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\nTypeError: priority_v2() missing 1 required positional argument: 'bin_capacity'\n12\n3\n165.05865002596164\n85.41135020331826\n170\n"
  }
]