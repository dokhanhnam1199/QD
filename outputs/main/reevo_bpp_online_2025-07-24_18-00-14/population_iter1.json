[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remain_cap_after_item = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remain_cap_after_item >= 0, remain_cap_after_item, -1e6)\n    \n    # Add a small noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priorities += noise\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    \n    if max_remaining_cap != min_remaining_cap:\n        normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        priorities = np.where(valid_bins_mask, -normalized_priorities, priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can't fit the item get a priority of -inf\n    priorities = np.where(remaining_after_addition >= 0, \n                          # Prioritize bins that have less remaining capacity after addition\n                          -remaining_after_addition, \n                          # Use a very low priority for bins that can't fit the item\n                          -np.inf)\n    \n    # Normalize the priorities to be between 0 and 1 for bins that can fit the item\n    valid_bins = priorities != -np.inf\n    if np.any(valid_bins):\n        min_priority = np.min(priorities[valid_bins])\n        max_priority = np.max(priorities[valid_bins])\n        if max_priority != min_priority:\n            priorities[valid_bins] = (priorities[valid_bins] - min_priority) / (max_priority - min_priority)\n    \n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Create a mask to handle bins that have enough capacity\n    mask = remaining_capacities >= 0\n    \n    # Assign high priority to bins with enough capacity and low priority to bins without enough capacity\n    priorities = np.where(mask, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priorities for bins with enough capacity\n    max_remaining_capacity = np.max(bins_remain_cap)\n    priorities = np.where(mask, priorities / max_remaining_capacity, priorities)\n    \n    # Add a small random noise to break ties\n    priorities = priorities + np.random.uniform(0, 1e-6, size=len(priorities))\n    \n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, -np.abs(bins_remain_cap - item), -1e6)\n    \n    # Introduce a slight bias towards bins that are less full to avoid always choosing the same bin\n    priorities += np.where(remaining_capacities >= 0, bins_remain_cap / np.max(bins_remain_cap), 0)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -1e6)\n    \n    # Further prioritize bins that have a remaining capacity closest to 0\n    priorities = np.where(remaining_capacities >= 0, -np.abs(remaining_capacities), priorities)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can fit the item\n    valid_bins_mask = remaining_after_addition >= 0\n    \n    # Initialize priorities with negative infinity for bins that cannot fit the item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    # For bins that can fit the item, calculate priority based on remaining capacity\n    priorities[valid_bins_mask] = remaining_after_addition[valid_bins_mask] / bins_remain_cap[valid_bins_mask]\n    \n    # Add a small random noise to break ties\n    priorities += np.random.normal(scale=1e-6, size=len(bins_remain_cap))\n    \n    return priorities",
    "response_id": 8,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 26, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n8\n1\n89.92418250750748\n81.97081516275108\n112\n"
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_cap_after_addition >= 0, \n                          # For bins that can accommodate the item, prioritize those with less remaining capacity\n                          -np.abs(remaining_cap_after_addition - item / 2), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 9,
    "obj": 9.254088552054245,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Encourage bins that will have a smaller remaining capacity after addition\n    priorities = np.where(remaining_after_addition >= 0, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priorities to avoid extreme values\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:\n        priorities = priorities - max_priority\n    \n    return priorities",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item will have a non-negative remaining capacity\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that can fit the item and have the least remaining capacity\n    priorities = np.where(can_fit, -remaining_after_addition, -np.inf)\n    \n    # Normalize the priorities to avoid extremely large values\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:\n        priorities = priorities - max_priority\n    \n    return priorities",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can hold the item, prioritize those with the least remaining capacity\n                          -np.abs(remaining_after_addition), \n                          # For bins that cannot hold the item, assign a very low priority\n                          -np.inf)\n    \n    # Normalize the priorities to ensure they are on the same scale\n    max_priority = np.max(priorities)\n    if max_priority != -np.inf:  # Check if there are any bins that can hold the item\n        priorities = np.where(priorities != -np.inf, priorities - max_priority, priorities)\n    \n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priorities = np.where(remaining_after_addition >= 0, \n                          # For bins that can accommodate the item, \n                          # prioritize those with the least remaining capacity after addition\n                          -np.abs(remaining_after_addition), \n                          # For bins that cannot accommodate the item, assign a very low priority\n                          -np.inf)\n    \n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that have enough capacity, prioritize the one with the least remaining capacity after addition\n    enough_capacity = bins_remain_cap >= item\n    priorities_enough = -remaining_cap_after_addition\n    \n    # For bins that don't have enough capacity, assign a very low priority\n    priorities_not_enough = np.full_like(bins_remain_cap, -np.inf)\n    \n    # Combine the priorities\n    priorities = np.where(enough_capacity, priorities_enough, priorities_not_enough)\n    \n    return priorities",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have enough capacity and are most full\n    priorities = np.where(can_fit, bins_remain_cap - remaining_after_addition, -np.inf)\n    \n    # Normalize the priorities to avoid very large numbers\n    priorities = np.where(can_fit, priorities / bins_remain_cap, -np.inf)\n    \n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_capacities = bins_remain_cap - item\n    \n    # Initialize priority scores with negative infinity for bins that cannot fit the item\n    priorities = np.where(remaining_capacities >= 0, bins_remain_cap - item, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    if max_priority != -np.inf:  # Check if there are bins that can fit the item\n        priorities = (priorities - min_priority) / (max_priority - min_priority)\n    else:\n        priorities = np.zeros_like(priorities)\n    \n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Priority is higher if the bin's remaining capacity is closer to the item size (First-Fit Decreasing inspiration)\n    # and also higher if the bin has a larger remaining capacity (to avoid nearly full bins)\n    priorities = np.where(can_fit, 1 / (1 + np.abs(remaining_after_addition)), -np.inf)\n    \n    # To further differentiate between bins that can fit the item, we give a slight edge to bins with more remaining capacity after addition\n    priorities = np.where(can_fit, priorities + remaining_after_addition / bins_remain_cap, priorities)\n    \n    return priorities",
    "response_id": 24,
    "obj": 85.25129637016356,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item should have higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item (best fit)\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid assigning the same priority to all bins that can fit the item,\n    # we add a small random noise to the priorities\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priorities += noise\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Bins that can fit the item get a higher priority\n    can_fit = remaining_after_addition >= 0\n    \n    # Prioritize bins that have just enough capacity for the item\n    priorities = np.where(can_fit, -np.abs(remaining_after_addition), -np.inf)\n    \n    # To avoid division by zero, we add a small value to bins_remain_cap before calculating the ratio\n    epsilon = 1e-6\n    ratios = item / (bins_remain_cap + epsilon)\n    \n    # Combine the two factors: the ability to fit the item and the ratio of item size to bin capacity\n    priorities = np.where(can_fit, priorities + np.log(1 + ratios), priorities)\n    \n    return priorities",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 89.92418250750748,
    "mi": 81.97081516275108,
    "token_count": 112.0,
    "exec_success": true
  }
]