[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        max_priority = np.max(valid_priorities)\n        priorities = np.where(valid_bins_mask, priorities / max_priority, priorities)\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign priority based on the remaining capacity after adding the item\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -np.inf)\n    \n    # Apply non-linear transformation to priorities for valid bins\n    priorities = np.where(valid_bins_mask, np.power(priorities / bins_remain_cap, 2), priorities)\n    \n    # Normalize priorities to have a clearer distinction between valid bins\n    finite_priorities = priorities[np.isfinite(priorities)]\n    if len(finite_priorities) > 0:\n        min_priority = np.min(finite_priorities)\n        max_priority = np.max(finite_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(np.isfinite(priorities), (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    remaining_cap_after_addition = np.where(valid_bins_mask, bins_remain_cap - item, np.inf)\n    \n    # Normalize remaining capacity after addition for valid bins\n    min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n    max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n    \n    if max_remaining_cap != min_remaining_cap:\n        normalized_remaining_cap = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n        priorities = np.where(valid_bins_mask, 1 - normalized_remaining_cap, -np.inf)\n    else:\n        priorities = np.where(valid_bins_mask, 1, -np.inf)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Identify bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign a priority score based on the remaining capacity ratio\n    priority = np.where(valid_bins_mask, 1 - remaining_cap_after_addition / bins_remain_cap, -np.inf)\n    \n    # Normalize the priorities for valid bins\n    valid_priority = priority[valid_bins_mask]\n    if len(valid_priority) > 0:\n        min_priority = np.min(valid_priority)\n        max_priority = np.max(valid_priority)\n        if max_priority != min_priority:\n            priority = np.where(valid_bins_mask, (priority - min_priority) / (max_priority - min_priority), priority)\n    \n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 5,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the relative remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -np.square(remaining_cap_after_addition / bins_remain_cap), -np.inf)\n    \n    # Apply a non-linear transformation to further encourage tight packing\n    priorities = np.where(valid_bins_mask, -np.power(remaining_cap_after_addition / bins_remain_cap, 3), priorities)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority), priorities)\n    \n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Identify bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign a base priority score to each bin based on its remaining capacity ratio\n    base_priority = np.where(valid_bins_mask, 1 - remaining_cap_after_addition / bins_remain_cap, -np.inf)\n    \n    # Apply a non-linear transformation to the base priority for valid bins to amplify differences\n    priorities = np.where(valid_bins_mask, np.power(base_priority, 3), base_priority)\n    \n    # Normalize the priorities for valid bins to ensure they are within a comparable range\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            priorities = np.where(valid_bins_mask, (priorities - min_priority) / (max_priority - min_priority + 1e-8), priorities)\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign priority scores directly using a non-linear transformation\n    priorities = np.where(valid_bins_mask, -np.power(remaining_cap_after_addition / item, 2), -np.inf)\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, bins_remain_cap - item, -np.inf)\n    \n    # Normalize priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            priorities[valid_bins_mask] = normalized_priorities\n    \n    return priorities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 92.0,
    "mi": 89.18083276676171,
    "token_count": 125.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize priorities for valid bins and apply non-linear transformation\n    valid_priorities = priorities[valid_bins_mask]\n    min_priority = np.min(valid_priorities)\n    max_priority = np.max(valid_priorities)\n    \n    if max_priority != min_priority:\n        normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n        # Apply a non-linear transformation to amplify differences\n        transformed_priorities = np.power(normalized_priorities, 2)\n        priorities = np.where(valid_bins_mask, -transformed_priorities, priorities)\n    \n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.9848878378053,
    "mi": 86.66032306233689,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -np.inf)\n    \n    # Directly apply a non-linear transformation to valid bins' priorities\n    priorities = np.where(valid_bins_mask, -np.exp(-priorities / item), priorities)\n    \n    return priorities",
    "response_id": 1,
    "obj": 149.30195452732352,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.9848878378053,
    "mi": 86.66032306233689,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -np.inf)\n    \n    # Directly apply non-linear transformation to valid bin priorities to amplify differences\n    priorities = np.where(valid_bins_mask, -np.exp(-priorities / item), priorities)\n    \n    return priorities",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.9848878378053,
    "mi": 86.66032306233689,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize priorities for valid bins to encourage packing items tightly\n    if np.any(valid_bins_mask):\n        min_remaining_cap = np.min(remaining_cap_after_addition[valid_bins_mask])\n        max_remaining_cap = np.max(remaining_cap_after_addition[valid_bins_mask])\n        \n        if max_remaining_cap != min_remaining_cap:\n            normalized_priorities = (remaining_cap_after_addition - min_remaining_cap) / (max_remaining_cap - min_remaining_cap)\n            # Apply non-linear transformation to amplify differences\n            transformed_priorities = np.exp(-5 * normalized_priorities)\n            priorities = np.where(valid_bins_mask, transformed_priorities, priorities)\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.9848878378053,
    "mi": 86.66032306233689,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that can accommodate the item\n    valid_bins_mask = remaining_cap_after_addition >= 0\n    \n    # Assign high priority to valid bins and low priority to invalid bins\n    priorities = np.where(valid_bins_mask, remaining_cap_after_addition, -np.inf)\n    \n    # Normalize and apply non-linear transformation to priorities for valid bins\n    valid_priorities = priorities[valid_bins_mask]\n    if len(valid_priorities) > 0:\n        min_priority = np.min(valid_priorities)\n        max_priority = np.max(valid_priorities)\n        if max_priority != min_priority:\n            normalized_priorities = (valid_priorities - min_priority) / (max_priority - min_priority)\n            # Apply a non-linear transformation to amplify differences\n            transformed_priorities = np.exp(-5 * normalized_priorities)\n            priorities = np.where(valid_bins_mask, transformed_priorities, priorities)\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 122.9848878378053,
    "mi": 86.66032306233689,
    "token_count": 152.0,
    "exec_success": true
  }
]