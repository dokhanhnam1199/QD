import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 2.5999480164076983e-09, fill_sigmoid_scale: float = 8.939245454346539, fill_sigmoid_center: float = 0.5995972309417228, stability_weight: float = 0.07068582234461435) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function prioritizes bins based on a combination of factors,
    aiming for a balance between minimizing waste, maximizing fill, and maintaining
    stability. It refines the approach in priority_v1 by using a more targeted
    strategy for each component.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        epsilon: Small value to avoid division by zero (default: 1e-9).
        fill_sigmoid_scale: Scaling factor for the fill ratio sigmoid (default: 5.0).
        fill_sigmoid_center: Center point for the fill ratio sigmoid (default: 0.5).
        stability_weight: Weight of the stability component (default: 0.1).

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Waste Minimization (Primary Goal)
    waste = bins_remain_cap - item
    # Only consider bins where the item fits
    feasible_bins = waste >= 0
    if not np.any(feasible_bins):
        return priorities # No feasible bin, return all zeros

    # Prioritize bins with minimal waste using a reciprocal function. Clipping
    # waste at a small value prevents overly large priorities for nearly full bins.
    clipped_waste = np.clip(waste[feasible_bins], a_min=epsilon, a_max=None)  # Ensure waste is never zero.
    waste_priority = 1 / clipped_waste
    priorities[feasible_bins] += waste_priority

    # 2. Fill Level Encouragement (Secondary, conditional on feasibility)
    # Encourage filling the bin as much as possible, relative to its *original* size.
    # This helps prevent fragmenting larger bins early on.
    fill_ratio = item / (bins_remain_cap[feasible_bins] + epsilon)

    # Use a sigmoid function to gently reward higher fill ratios, but prevent extreme values.
    # Sigmoid squashes the fill_ratio to be between 0 and 1
    fill_priority = 1 / (1 + np.exp(-fill_sigmoid_scale * (fill_ratio - fill_sigmoid_center))) # Steep sigmoid centered at fill_ratio=0.5
    priorities[feasible_bins] += fill_priority
    
    # 3. Stability (Tertiary) - Prefer bins close to item size, but with a small weight
    stability = -np.abs(bins_remain_cap[feasible_bins] - item)
    # Scale stability to have a smaller impact
    stability_priority = stability * stability_weight
    priorities[feasible_bins] += stability_priority

    return priorities
