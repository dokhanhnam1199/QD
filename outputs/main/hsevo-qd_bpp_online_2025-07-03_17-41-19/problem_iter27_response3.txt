```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A refined priority function for online bin packing, considering best-fit,
    remaining capacity, and a reward for filling bins effectively. It also includes
    a penalty for creating small residual spaces.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.

    Returns:
        np.ndarray: An array of priority scores for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # 1. Feasibility Check
    fit_mask = bins_remain_cap >= item
    if not np.any(fit_mask):
        return priorities - np.inf  # All bins are infeasible

    # 2. Best-Fit Prioritization (Waste Minimization)
    waste = bins_remain_cap - item
    waste[~fit_mask] = np.inf  # Penalize infeasible bins
    best_fit_priority = -waste  # Lower waste = higher priority

    # 3. Remaining Capacity Consideration (Balance Utilization)
    capacity_priority = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)

    # 4. Fill Ratio Reward (Encourage Efficient Packing)
    fill_ratio = item / (bins_remain_cap + epsilon)
    fill_reward = np.exp(-np.abs(fill_ratio - 1))  # Reward close to full utilization

    # 5. Small Residual Penalty (Avoid Fragmentation)
    residual = bins_remain_cap - item
    small_residual_penalty = np.where(
        (residual > 0) & (residual < 0.1 * np.max(bins_remain_cap)),  # Avoid magic numbers
        -10 * (0.1 * np.max(bins_remain_cap) - residual),  # Strong penalty for small residuals
        0,  # No penalty otherwise
    )

    # 6. Combine Priorities (Weighted Sum)
    priorities = np.where(
        fit_mask,
        (0.4 * best_fit_priority) + (0.3 * capacity_priority) + (0.2 * fill_reward) + (0.1 * small_residual_penalty),
        -np.inf,
    )

    return priorities
```
