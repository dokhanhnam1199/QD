```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Improved priority function for online bin packing, emphasizing balanced bin utilization and penalizing near-full bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # 1. Feasibility Mask:  Bins that can accommodate the item.
    fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return -inf priorities.
    if not np.any(fit_mask):
        return priorities - np.inf

    # 2. Waste Minimization (Best-Fit):  Favor bins with minimal remaining space after packing.
    waste = bins_remain_cap - item
    waste_priority = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)
    priorities = np.where(fit_mask, priorities + 0.4 * waste_priority, priorities)  # Higher weight

    # 3. Capacity Balancing: Encourage filling bins to a moderate level, avoiding both empty and nearly-full bins.
    capacity_ratio = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)
    capacity_priority = np.exp(-np.abs(capacity_ratio - 0.5) * 4)  # Gaussian-like preference around 50%
    priorities = np.where(fit_mask, priorities + 0.3 * capacity_priority, priorities)

    # 4. Fill Density Reward:  Reward bins that will be filled reasonably well by the item.  Penalize near-full bins strongly.
    fill_ratio = item / (bins_remain_cap + epsilon)
    nearly_full_penalty = np.where(fill_ratio > 0.9, -10, 0)  # Strong penalty for bins nearing capacity
    fill_density_reward = np.where(fit_mask, np.exp(-np.abs(fill_ratio - 0.75) * 4) + nearly_full_penalty, -np.inf)
    priorities = np.where(fit_mask, priorities + 0.3 * fill_density_reward, priorities)

    return priorities
```
