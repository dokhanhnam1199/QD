{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function refines the bin selection process by:\n    1.  Best Fit Emphasis: Strongly prioritizes bins where the item fits with minimal waste. This is the core principle of Best-Fit heuristics.\n    2.  Remaining Capacity Consideration: Balances the \"Best Fit\" with a preference for bins that still have substantial capacity, avoiding premature fragmentation.\n    3.  Item Size Normalization: Normalize the item size to better reflect its significance relative to bin capacity.\n    4.  Capacity Threshold: Introduces a threshold for considering bins. Bins with very small remaining capacity relative to item size are heavily penalized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Best Fit Emphasis: Minimize waste\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)  # Normalized waste for better comparison. Exp to prioritize smaller waste.\n    # 2. Remaining Capacity Consideration: Balance best fit with available space.\n    # Prioritize bins with more remaining capacity (avoid excessive fragmentation)\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)  # Normalize remaining capacity\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)  # Add capacity as a secondary factor. Multiply by 0.5 so it doesn't override best-fit.\n\n    # 3. Item Size Normalization\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon) # normalize to largest bin to give it context.\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n\n    # 4. Capacity Threshold: Penalize bins that are almost full\n    threshold = 0.1  # If remaining capacity is less than 10% of bin size, penalize.\n    small_capacity_penalty = np.where(bins_remain_cap / (np.max(bins_remain_cap) + epsilon) < threshold, -10, 0) #severe penalty\n    priorities += small_capacity_penalty\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function refines the bin selection process by:\n    1.  Best Fit Emphasis: Strongly prioritizes bins where the item fits with minimal waste. This is the core principle of Best-Fit heuristics.\n    2.  Remaining Capacity Consideration: Balances the \"Best Fit\" with a preference for bins that still have substantial capacity, avoiding premature fragmentation.\n    3.  Item Size Normalization: Normalize the item size to better reflect its significance relative to bin capacity.\n    4.  Capacity Threshold: Introduces a threshold for considering bins. Bins with very small remaining capacity relative to item size are heavily penalized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Best Fit Emphasis: Minimize waste\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)  # Normalized waste for better comparison. Exp to prioritize smaller waste.\n    # 2. Remaining Capacity Consideration: Balance best fit with available space.\n    # Prioritize bins with more remaining capacity (avoid excessive fragmentation)\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)  # Normalize remaining capacity\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)  # Add capacity as a secondary factor. Multiply by 0.5 so it doesn't override best-fit.\n\n    # 3. Item Size Normalization\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon) # normalize to largest bin to give it context.\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n\n    # 4. Capacity Threshold: Penalize bins that are almost full\n    threshold = 0.1  # If remaining capacity is less than 10% of bin size, penalize.\n    small_capacity_penalty = np.where(bins_remain_cap / (np.max(bins_remain_cap) + epsilon) < threshold, -10, 0) #severe penalty\n    priorities += small_capacity_penalty\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function refines the bin selection process by:\n    1.  Best Fit Emphasis: Strongly prioritizes bins where the item fits with minimal waste. This is the core principle of Best-Fit heuristics.\n    2.  Remaining Capacity Consideration: Balances the \"Best Fit\" with a preference for bins that still have substantial capacity, avoiding premature fragmentation.\n    3.  Item Size Normalization: Normalize the item size to better reflect its significance relative to bin capacity.\n    4.  Capacity Threshold: Introduces a threshold for considering bins. Bins with very small remaining capacity relative to item size are heavily penalized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Best Fit Emphasis: Minimize waste\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)  # Normalized waste for better comparison. Exp to prioritize smaller waste.\n    # 2. Remaining Capacity Consideration: Balance best fit with available space.\n    # Prioritize bins with more remaining capacity (avoid excessive fragmentation)\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)  # Normalize remaining capacity\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)  # Add capacity as a secondary factor. Multiply by 0.5 so it doesn't override best-fit.\n\n    # 3. Item Size Normalization\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon) # normalize to largest bin to give it context.\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n\n    # 4. Capacity Threshold: Penalize bins that are almost full\n    threshold = 0.1  # If remaining capacity is less than 10% of bin size, penalize.\n    small_capacity_penalty = np.where(bins_remain_cap / (np.max(bins_remain_cap) + epsilon) < threshold, -10, 0) #severe penalty\n    priorities += small_capacity_penalty\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and fill level considerations for bin selection.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste: Exponential penalty for wasted space, hard penalty for overfill.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-10 * waste / item), -np.inf)\n    priorities += waste_penalty\n\n    # Fill Level: Sigmoid reward for filling bins, avoid overfilling.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = 1 / (1 + np.exp(5 - 10 * fill_ratio))\n    priorities += fill_reward\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling.\n    3. Item Fit: A stronger focus on how well the item fits relative to the bin's capacity.\n    4. Bin Utilization: Directly incentivize using bins that have already been started.\n    5. Number of items: Approximated by remaining space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste), -np.inf)  # Exponential decay for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)  # linear reward, harsh penalty. Experiment different functions\n    priorities += fill_reward\n\n    # Item Fit: How well the item fits, using a scaled sigmoid function.\n    item_fit = 1 / (1 + np.exp(5 * (waste / (item + epsilon) - 0.5))) # Experiment with the scaling factor 5 and offset 0.5\n    item_fit = np.where(waste >= 0, item_fit, 0) # Only consider if item fits.\n    priorities += item_fit\n\n    # Bin Utilization: Encourage using bins that are already partially filled.\n    bin_utilization = 1 - bins_remain_cap # scale between zero and one\n    priorities += bin_utilization\n    \n    # Number of items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap) # Lower remaining cap equals larger item_density, less filled\n    priorities += 0.1 * item_density\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and a modified fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste minimization: Smaller waste is better\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste, -np.inf)\n    priorities += waste_penalty\n\n    # Modified fill ratio: Encourages fuller bins but dampens very full bins\n    fill_ratio = item / (bins_remain_cap + item + epsilon)  # Normalized by item size\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)\n    priorities += fill_reward\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with adjusted weights and new considerations:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space. Uses a more aggressive penalty for larger waste.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Modified to focus on bins that are close to being filled by this item.\n    3. Bin Utilization: Aims to balance the distribution of items across bins to avoid clustering.\n    4. Best Fit Heuristic Influence: Directly rewards bins that provide a very tight fit, emulating best-fit behavior.\n    5. Avoidance of Near-Empty Bins: Discourages placing items into bins that are still almost completely empty unless no other choice is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.  Aggressive penalty for waste.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste**2, -np.inf)  # Quadratic penalty for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much. Focus on bins that are close to being filled.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(1 - np.abs(1 - fill_ratio)), -np.inf) # Reward when fill ratio is close to 1\n    priorities += fill_reward\n\n    # Bin Utilization: Try to balance utilization across bins\n    utilization = 1 - bins_remain_cap  # Assuming bin capacity is normalized to 1.  Higher utilization is better.\n    utilization_reward = np.exp(utilization)\n    priorities += 0.1 * utilization_reward # scale down to balance relative to other heuristics\n\n    # Best Fit Heuristic Influence: Directly reward bins that provide a near-perfect fit.\n    best_fit_bonus = np.where(np.abs(waste) < 0.05, 10, 0) # Substantial reward for very small waste\n    priorities += best_fit_bonus\n\n    # Avoidance of Near-Empty Bins: Discourage putting items into near-empty bins unless necessary\n    near_empty_penalty = np.where(bins_remain_cap > 0.9, -1, 0) # Penalize if almost empty.\n    priorities += near_empty_penalty\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_exp_scale: float = 0.7689715119248567, fill_exp_scale: float = 0.7967806647402089, density_exp_scale: float = 1.1915806622742056, stability_weight: float = 0.240849797356982, epsilon: float = 6.42850688735192e-08) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling (impossible but included for completeness).\n    3. Number of Items: Accounts for how many items are already present in bins (not directly accessible in online BPP). We approximate using the amount of available space. Sparsely filled bins are encouraged, up to a point. Densely filled bins discouraged.\n    4. Stability: Favors bins that are closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_exp_scale: Scaling factor for the waste exponential.\n        fill_exp_scale: Scaling factor for the fill exponential.\n        density_exp_scale: Scaling factor for the density exponential.\n        stability_weight: Weight of the stability component.\n        epsilon: Small value to avoid division by zero and log of zero\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste * waste_exp_scale), -np.inf)  # Exponential decay for waste, harsh penalty for overfill. Negative inf indicates bin won't fit\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio * fill_exp_scale), -np.inf)\n    priorities += fill_reward\n\n    # Number of Items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap * density_exp_scale) # Lower remaining cap equals larger item_density, less filled\n    priorities += item_density\n    # Stability (Closeness to Item Size):\n\n    stability = -np.abs(bins_remain_cap - item) * stability_weight\n    priorities += stability\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling (impossible but included for completeness).\n    3. Number of Items: Accounts for how many items are already present in bins (not directly accessible in online BPP). We approximate using the amount of available space. Sparsely filled bins are encouraged, up to a point. Densely filled bins discouraged.\n    4. Stability: Favors bins that are closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste), -np.inf)  # Exponential decay for waste, harsh penalty for overfill. Negative inf indicates bin won't fit\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio), -np.inf)\n    priorities += fill_reward\n\n    # Number of Items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap) # Lower remaining cap equals larger item_density, less filled\n    priorities += item_density\n    # Stability (Closeness to Item Size):\n\n    stability = -np.abs(bins_remain_cap - item)\n    priorities += stability\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with adjusted weights and new considerations:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space. Uses a more aggressive penalty for larger waste.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Modified to focus on bins that are close to being filled by this item.\n    3. Bin Utilization: Aims to balance the distribution of items across bins to avoid clustering.\n    4. Best Fit Heuristic Influence: Directly rewards bins that provide a very tight fit, emulating best-fit behavior.\n    5. Avoidance of Near-Empty Bins: Discourages placing items into bins that are still almost completely empty unless no other choice is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.  Aggressive penalty for waste.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste**2, -np.inf)  # Quadratic penalty for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much. Focus on bins that are close to being filled.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(1 - np.abs(1 - fill_ratio)), -np.inf) # Reward when fill ratio is close to 1\n    priorities += fill_reward\n\n    # Bin Utilization: Try to balance utilization across bins\n    utilization = 1 - bins_remain_cap  # Assuming bin capacity is normalized to 1.  Higher utilization is better.\n    utilization_reward = np.exp(utilization)\n    priorities += 0.1 * utilization_reward # scale down to balance relative to other heuristics\n\n    # Best Fit Heuristic Influence: Directly reward bins that provide a near-perfect fit.\n    best_fit_bonus = np.where(np.abs(waste) < 0.05, 10, 0) # Substantial reward for very small waste\n    priorities += best_fit_bonus\n\n    # Avoidance of Near-Empty Bins: Discourage putting items into near-empty bins unless necessary\n    near_empty_penalty = np.where(bins_remain_cap > 0.9, -1, 0) # Penalize if almost empty.\n    priorities += near_empty_penalty\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros\n\n    # Prioritize bins with minimal waste using a reciprocal function. Clipping\n    # waste at a small value prevents overly large priorities for nearly full bins.\n    clipped_waste = np.clip(waste[feasible_bins], a_min=epsilon, a_max=None)  # Ensure waste is never zero.\n    waste_priority = 1 / clipped_waste\n    priorities[feasible_bins] += waste_priority\n\n    # 2. Fill Level Encouragement (Secondary, conditional on feasibility)\n    # Encourage filling the bin as much as possible, relative to its *original* size.\n    # This helps prevent fragmenting larger bins early on.\n    fill_ratio = item / (bins_remain_cap[feasible_bins] + epsilon)\n\n    # Use a sigmoid function to gently reward higher fill ratios, but prevent extreme values.\n    # Sigmoid squashes the fill_ratio to be between 0 and 1\n    fill_priority = 1 / (1 + np.exp(-5 * (fill_ratio - 0.5))) # Steep sigmoid centered at fill_ratio=0.5\n    priorities[feasible_bins] += fill_priority\n    \n    # 3. Stability (Tertiary) - Prefer bins close to item size, but with a small weight\n    stability = -np.abs(bins_remain_cap[feasible_bins] - item)\n    # Scale stability to have a smaller impact\n    stability_priority = stability * 0.1\n    priorities[feasible_bins] += stability_priority\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with refined weighting and a focus on avoiding edge-case penalties:\n    1.  Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.  Uses a more nuanced penalty.\n    2.  Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Exponential reward for fill ratio.\n    3.  Balance: Encourages a more balanced distribution of items across bins, especially when bins are similarly filled.\n    4.  Adaptability: Introduces a parameter (alpha) to adjust the relative importance of waste vs. fill level.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n    alpha = 0.5  # Adjust the weight of waste vs. fill (0 to 1)\n\n    # Waste: Prioritize bins where the item fits relatively well, minimizing wasted space.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)  # Exponential decay scaled by item size\n    priorities += alpha * waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio), -np.inf)\n    priorities += (1 - alpha) * fill_reward\n\n    # Balance: Encourages a more balanced distribution of items. Avoid extreme fill levels early on.\n    # This helps in scenarios where bins have similar remaining capacities.\n    bin_utilization = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon)) # Relative to the fullest bin\n    balance_reward = np.exp(-np.abs(bin_utilization - 0.5)) # Target around 50% utilization.  Avoids being too greedy.\n    priorities += 0.1 * balance_reward  # Smaller weight.  Balance is secondary.\n\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_clip_min: float = 1.6617846807395032e-09,\n                fill_sigmoid_scale: float = 9.493317672830546, fill_sigmoid_center: float = 0.7654453973055002,\n                stability_weight: float = 0.05972327746087532) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_clip_min: Small value to avoid division by zero when calculating waste priority.\n        fill_sigmoid_scale: Scale of the sigmoid function used for fill priority.\n        fill_sigmoid_center: Center point of the sigmoid function.\n        stability_weight: Weight of the stability component in the overall priority.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = waste_clip_min  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_clip_min: float = 1.6617846807395032e-09,\n                fill_sigmoid_scale: float = 9.493317672830546, fill_sigmoid_center: float = 0.7654453973055002,\n                stability_weight: float = 0.05972327746087532) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_clip_min: Small value to avoid division by zero when calculating waste priority.\n        fill_sigmoid_scale: Scale of the sigmoid function used for fill priority.\n        fill_sigmoid_center: Center point of the sigmoid function.\n        stability_weight: Weight of the stability component in the overall priority.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = waste_clip_min  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}