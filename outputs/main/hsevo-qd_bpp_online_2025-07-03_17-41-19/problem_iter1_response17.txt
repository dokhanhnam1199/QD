```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Heuristic 1: First-Fit Decreasing (FFD) Inspired: Prefer bins where the remaining space is closest to the item size
    # Idea: Minimize wasted space by trying to fill bins completely. A quantum leap of efficiency!
    diff = np.abs(bins_remain_cap - item)
    priority_ffd = -diff  # Lower difference = higher priority. We want those close fits, like matching amplitudes!
    priority_ffd[bins_remain_cap < item] = -np.inf  # Cannot place here. Like a barrier potential the particle can't overcome!

    # Heuristic 2: Balance Bin Usage: Penalize bins that are nearly full or nearly empty.
    # Idea: Avoid extreme fragmentation. Think of it as maintaining a stable superposition of bin utilization.
    normalized_cap = bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)
    priority_balance = -np.abs(normalized_cap - 0.5)  # Maximize around 0.5, penalize extremes

    # Heuristic 3: Prioritize bins with higher capacity if the item is small
    #If item is small pack into larger capacity bins
    if item < np.mean(bins_remain_cap):
      priority_capacity = bins_remain_cap/np.max(bins_remain_cap)
    else:
      priority_capacity = np.zeros_like(bins_remain_cap)

    # Combine the heuristics. We sum the priorities to allow for interactions
    # like quantum interference! Experiment with weights. This requires empirical tuning.
    total_priority = priority_ffd + 0.5* priority_balance + 0.1 * priority_capacity # Weighted sum, like amplitudes combining!


    return total_priority
```
