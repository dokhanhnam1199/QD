import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, waste_exp_scale: float = 1.3042896471692695, fill_exp_scale: float = 0.5015014983601641, density_exp_scale: float = 0.22385975626738464, stability_weight: float = 0.44126567486600565, epsilon: float = 1.9802610646319678e-07) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers multiple factors:
    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.
    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling (impossible but included for completeness).
    3. Number of Items: Accounts for how many items are already present in bins (not directly accessible in online BPP). We approximate using the amount of available space. Sparsely filled bins are encouraged, up to a point. Densely filled bins discouraged.
    4. Stability: Favors bins that are closest to the item size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.
        waste_exp_scale: Scaling factor for the waste exponential decay.
        fill_exp_scale: Scaling factor for the fill ratio exponential reward.
        density_exp_scale: Scaling factor for the item density exponential decay.
        stability_weight: Weight of the stability term.
        epsilon: Small value to avoid division by zero and log of zero

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)


    # Waste: Prioritize bins where the item fits relatively well.
    waste = bins_remain_cap - item
    waste_penalty = np.where(waste >= 0, np.exp(-waste * waste_exp_scale), -np.inf)  # Exponential decay for waste, harsh penalty for overfill. Negative inf indicates bin won't fit
    priorities += waste_penalty

    # Fill Level: Encourage filling bins, but not too much.
    fill_ratio = item / (bins_remain_cap + epsilon)
    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio * fill_exp_scale), -np.inf)
    priorities += fill_reward

    # Number of Items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled
    item_density = np.exp(-bins_remain_cap * density_exp_scale) # Lower remaining cap equals larger item_density, less filled
    priorities += item_density
    # Stability (Closeness to Item Size):

    stability = -np.abs(bins_remain_cap - item) * stability_weight
    priorities += stability

    return priorities
