```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A priority function for online bin packing that balances best-fit,
    remaining capacity, and encourages bins to be filled more evenly.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Identify bins where the item fits
    fit_mask = bins_remain_cap >= item

    # If no bin fits, return a vector of -inf (or a very small value)
    if not np.any(fit_mask):
        return np.full_like(bins_remain_cap, -np.inf)
    
    # 1. Best-Fit Component (Minimize Waste)
    waste = bins_remain_cap - item
    waste_penalty = np.where(fit_mask, -waste, np.inf)  # Smaller waste is better
    priorities = np.where(fit_mask, priorities + waste_penalty, priorities)

    # 2. Capacity Utilization Component (Fill bins more fully)
    fill_ratio = item / (bins_remain_cap + epsilon)
    fill_reward = np.where(fit_mask, fill_ratio, -np.inf)  # Higher fill ratio is better
    priorities = np.where(fit_mask, priorities + 2*fill_reward, priorities) # higher weight
    
    # 3. Balance Bin Levels (Encourage even distribution of items)
    average_capacity = np.mean(bins_remain_cap)
    capacity_diff = np.abs(bins_remain_cap - average_capacity)
    capacity_balance_penalty = np.where(fit_mask, -capacity_diff, np.inf)  # Closer to average is better
    priorities = np.where(fit_mask, priorities + 0.5*capacity_balance_penalty, priorities) # reduced weight

    # 4. Small Item in Large Bin Penalty (avoid this)
    size_ratio = item / (bins_remain_cap + epsilon)
    small_item_large_bin_penalty = np.where(fit_mask, size_ratio, -np.inf)
    priorities = np.where(fit_mask, priorities - 0.1* small_item_large_bin_penalty, priorities)
    
    return priorities
```
