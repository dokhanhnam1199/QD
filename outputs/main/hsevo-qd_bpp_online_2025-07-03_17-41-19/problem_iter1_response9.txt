```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
       This version prioritizes bins with remaining capacity slightly larger
       than the item size, but penalizes bins that are either too full or
       too empty after packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            # Base priority: how much space will be left
            remaining_space = capacity - item

            # Heuristic 1: Prioritize bins where remaining space is small, but not too small.
            # Aim for bins where a future, potentially smaller, item could still fit.
            priority = np.exp(-np.abs(remaining_space - item/2)) #Gaussian centered on item/2 remaining

            # Heuristic 2: Penalize bins that are near full after packing.
            # Prevents overly fragmented bins if possible
            if remaining_space < 0.1:  #Small tolerance
                priority *= 0.5 #Reduced penalty

            # Heuristic 3: Slightly Penalize bins with large remaining capacity (Avoid making overly empty bins)
            if remaining_space > item * 1.5: # If remaining space exceeds item by 50% then penalize it
               priority *= 0.8


            priorities[i] = priority
        else:
            priorities[i] = -1.0  # Impossible to pack

    return priorities
```
