```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with capacity slightly larger than the item,
    but penalizes bins that are either too small or much larger.  It also 
    includes a random component to occasionally explore less obvious choices.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give a high base priority to bins that can fit the item.
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] += 1.0

    # Prefer bins where the remaining capacity after placing the item is small.
    remaining_capacity = bins_remain_cap - item
    remaining_capacity[~fit_mask] = np.inf  # Penalize bins that cannot fit.
    priorities[fit_mask] += np.exp(-remaining_capacity[fit_mask])

    # Penalize bins where the item would fill a very small portion (avoid fragmentation)
    capacity_ratios = item / bins_remain_cap
    priorities[fit_mask] -= (capacity_ratios[fit_mask] < 0.1) * 0.5

    # Penalize bins that are filled a huge proportion by this item (if capacity ratio > 0.9)
    priorities[fit_mask] -= (capacity_ratios[fit_mask] > 0.9) * 0.5

    # Add a small random component for exploration.
    priorities += np.random.rand(len(bins_remain_cap)) * 0.1

    return priorities
```
