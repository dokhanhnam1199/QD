{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with refined weighting and scaling:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.  Uses a more sensitive exponential decay.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Uses a sigmoid function for smoother behavior.\n    3. Bin Utilization: Directly rewards bins that have been used to some extent, encouraging balanced usage.\n    4. Stability: Favors bins that are closest to the item size, scaled by the item size itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-10 * waste / item), -np.inf)  # More sensitive exponential decay, scaled by item size. Harsh penalty for overfill.\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.  Sigmoid function\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = 1 / (1 + np.exp(5 - 10 * fill_ratio)) # Sigmoid centered around fill_ratio = 0.5\n    priorities += fill_reward\n\n    # Bin Utilization: Reward bins that have some items in them already\n    utilization = (1 - bins_remain_cap) # Previously available capacity\n    utilization_reward = np.where(utilization > 0, np.tanh(utilization), 0) #tanh squashes the values and 0 if it is new bin.\n    priorities += 0.5 * utilization_reward\n\n    # Stability (Closeness to Item Size): Scaled by item size\n    stability = -np.abs(bins_remain_cap - item) / (item + epsilon)\n    priorities += 0.25 * stability\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with refined weighting and a focus on avoiding edge-case penalties:\n    1.  Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.  Uses a more nuanced penalty.\n    2.  Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Exponential reward for fill ratio.\n    3.  Balance: Encourages a more balanced distribution of items across bins, especially when bins are similarly filled.\n    4.  Adaptability: Introduces a parameter (alpha) to adjust the relative importance of waste vs. fill level.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n    alpha = 0.5  # Adjust the weight of waste vs. fill (0 to 1)\n\n    # Waste: Prioritize bins where the item fits relatively well, minimizing wasted space.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)  # Exponential decay scaled by item size\n    priorities += alpha * waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio), -np.inf)\n    priorities += (1 - alpha) * fill_reward\n\n    # Balance: Encourages a more balanced distribution of items. Avoid extreme fill levels early on.\n    # This helps in scenarios where bins have similar remaining capacities.\n    bin_utilization = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon)) # Relative to the fullest bin\n    balance_reward = np.exp(-np.abs(bin_utilization - 0.5)) # Target around 50% utilization.  Avoids being too greedy.\n    priorities += 0.1 * balance_reward  # Smaller weight.  Balance is secondary.\n\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros\n\n    # Prioritize bins with minimal waste using a reciprocal function. Clipping\n    # waste at a small value prevents overly large priorities for nearly full bins.\n    clipped_waste = np.clip(waste[feasible_bins], a_min=epsilon, a_max=None)  # Ensure waste is never zero.\n    waste_priority = 1 / clipped_waste\n    priorities[feasible_bins] += waste_priority\n\n    # 2. Fill Level Encouragement (Secondary, conditional on feasibility)\n    # Encourage filling the bin as much as possible, relative to its *original* size.\n    # This helps prevent fragmenting larger bins early on.\n    fill_ratio = item / (bins_remain_cap[feasible_bins] + epsilon)\n\n    # Use a sigmoid function to gently reward higher fill ratios, but prevent extreme values.\n    # Sigmoid squashes the fill_ratio to be between 0 and 1\n    fill_priority = 1 / (1 + np.exp(-5 * (fill_ratio - 0.5))) # Steep sigmoid centered at fill_ratio=0.5\n    priorities[feasible_bins] += fill_priority\n    \n    # 3. Stability (Tertiary) - Prefer bins close to item size, but with a small weight\n    stability = -np.abs(bins_remain_cap[feasible_bins] - item)\n    # Scale stability to have a smaller impact\n    stability_priority = stability * 0.1\n    priorities[feasible_bins] += stability_priority\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and fill level to improve priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste minimization: Smaller waste is better\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste, -np.inf)\n    priorities += waste_penalty\n\n    # Fill level: Encourages fuller bins\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)\n    priorities += fill_reward\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with adjusted weights and new considerations:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space. Uses a more aggressive penalty for larger waste.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Modified to focus on bins that are close to being filled by this item.\n    3. Bin Utilization: Aims to balance the distribution of items across bins to avoid clustering.\n    4. Best Fit Heuristic Influence: Directly rewards bins that provide a very tight fit, emulating best-fit behavior.\n    5. Avoidance of Near-Empty Bins: Discourages placing items into bins that are still almost completely empty unless no other choice is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.  Aggressive penalty for waste.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste**2, -np.inf)  # Quadratic penalty for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much. Focus on bins that are close to being filled.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(1 - np.abs(1 - fill_ratio)), -np.inf) # Reward when fill ratio is close to 1\n    priorities += fill_reward\n\n    # Bin Utilization: Try to balance utilization across bins\n    utilization = 1 - bins_remain_cap  # Assuming bin capacity is normalized to 1.  Higher utilization is better.\n    utilization_reward = np.exp(utilization)\n    priorities += 0.1 * utilization_reward # scale down to balance relative to other heuristics\n\n    # Best Fit Heuristic Influence: Directly reward bins that provide a near-perfect fit.\n    best_fit_bonus = np.where(np.abs(waste) < 0.05, 10, 0) # Substantial reward for very small waste\n    priorities += best_fit_bonus\n\n    # Avoidance of Near-Empty Bins: Discourage putting items into near-empty bins unless necessary\n    near_empty_penalty = np.where(bins_remain_cap > 0.9, -1, 0) # Penalize if almost empty.\n    priorities += near_empty_penalty\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and fill level to improve priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste minimization: Smaller waste is better\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste, -np.inf)\n    priorities += waste_penalty\n\n    # Fill level: Encourages fuller bins\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)\n    priorities += fill_reward\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling.\n    3. Item Fit: A stronger focus on how well the item fits relative to the bin's capacity.\n    4. Bin Utilization: Directly incentivize using bins that have already been started.\n    5. Number of items: Approximated by remaining space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste), -np.inf)  # Exponential decay for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)  # linear reward, harsh penalty. Experiment different functions\n    priorities += fill_reward\n\n    # Item Fit: How well the item fits, using a scaled sigmoid function.\n    item_fit = 1 / (1 + np.exp(5 * (waste / (item + epsilon) - 0.5))) # Experiment with the scaling factor 5 and offset 0.5\n    item_fit = np.where(waste >= 0, item_fit, 0) # Only consider if item fits.\n    priorities += item_fit\n\n    # Bin Utilization: Encourage using bins that are already partially filled.\n    bin_utilization = 1 - bins_remain_cap # scale between zero and one\n    priorities += bin_utilization\n    \n    # Number of items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap) # Lower remaining cap equals larger item_density, less filled\n    priorities += 0.1 * item_density\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with refined weighting and scaling:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.  Uses a more sensitive exponential decay.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Uses a sigmoid function for smoother behavior.\n    3. Bin Utilization: Directly rewards bins that have been used to some extent, encouraging balanced usage.\n    4. Stability: Favors bins that are closest to the item size, scaled by the item size itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-10 * waste / item), -np.inf)  # More sensitive exponential decay, scaled by item size. Harsh penalty for overfill.\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.  Sigmoid function\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = 1 / (1 + np.exp(5 - 10 * fill_ratio)) # Sigmoid centered around fill_ratio = 0.5\n    priorities += fill_reward\n\n    # Bin Utilization: Reward bins that have some items in them already\n    utilization = (1 - bins_remain_cap) # Previously available capacity\n    utilization_reward = np.where(utilization > 0, np.tanh(utilization), 0) #tanh squashes the values and 0 if it is new bin.\n    priorities += 0.5 * utilization_reward\n\n    # Stability (Closeness to Item Size): Scaled by item size\n    stability = -np.abs(bins_remain_cap - item) / (item + epsilon)\n    priorities += 0.25 * stability\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling.\n    3. Item Fit: A stronger focus on how well the item fits relative to the bin's capacity.\n    4. Bin Utilization: Directly incentivize using bins that have already been started.\n    5. Number of items: Approximated by remaining space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste), -np.inf)  # Exponential decay for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)  # linear reward, harsh penalty. Experiment different functions\n    priorities += fill_reward\n\n    # Item Fit: How well the item fits, using a scaled sigmoid function.\n    item_fit = 1 / (1 + np.exp(5 * (waste / (item + epsilon) - 0.5))) # Experiment with the scaling factor 5 and offset 0.5\n    item_fit = np.where(waste >= 0, item_fit, 0) # Only consider if item fits.\n    priorities += item_fit\n\n    # Bin Utilization: Encourage using bins that are already partially filled.\n    bin_utilization = 1 - bins_remain_cap # scale between zero and one\n    priorities += bin_utilization\n    \n    # Number of items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap) # Lower remaining cap equals larger item_density, less filled\n    priorities += 0.1 * item_density\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros\n\n    # Prioritize bins with minimal waste using a reciprocal function. Clipping\n    # waste at a small value prevents overly large priorities for nearly full bins.\n    clipped_waste = np.clip(waste[feasible_bins], a_min=epsilon, a_max=None)  # Ensure waste is never zero.\n    waste_priority = 1 / clipped_waste\n    priorities[feasible_bins] += waste_priority\n\n    # 2. Fill Level Encouragement (Secondary, conditional on feasibility)\n    # Encourage filling the bin as much as possible, relative to its *original* size.\n    # This helps prevent fragmenting larger bins early on.\n    fill_ratio = item / (bins_remain_cap[feasible_bins] + epsilon)\n\n    # Use a sigmoid function to gently reward higher fill ratios, but prevent extreme values.\n    # Sigmoid squashes the fill_ratio to be between 0 and 1\n    fill_priority = 1 / (1 + np.exp(-5 * (fill_ratio - 0.5))) # Steep sigmoid centered at fill_ratio=0.5\n    priorities[feasible_bins] += fill_priority\n    \n    # 3. Stability (Tertiary) - Prefer bins close to item size, but with a small weight\n    stability = -np.abs(bins_remain_cap[feasible_bins] - item)\n    # Scale stability to have a smaller impact\n    stability_priority = stability * 0.1\n    priorities[feasible_bins] += stability_priority\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}