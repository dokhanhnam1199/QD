```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers multiple factors:
    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.
       Uses a more nuanced approach with different penalty levels.
    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling.
       Focuses on a narrower, more effective fill range.
    3. Item Fragmentation: Discourages leaving small gaps, especially if many bins have small gaps.
    4. Best Fit Emphasis: Heavily prioritizes bins that provide a nearly perfect fit.
    5. Capacity Threshold: Bins below a certain threshold are penalized to prefer filling bins with more space first.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to avoid division by zero and log of zero
    bin_capacity = np.max(bins_remain_cap) + item # Assuming all bins have the same capacity

    # Waste: Prioritize bins where the item fits relatively well. Stronger penalty for large waste.
    waste = bins_remain_cap - item
    fit = waste >= 0
    priorities[~fit] = -np.inf  # Impossible to fit

    waste = waste[fit]
    bins_remain_cap_fit = bins_remain_cap[fit]

    # Calculate waste penalties, with different scales depending on waste size
    waste_penalty = np.zeros_like(waste, dtype=float)
    waste_penalty[waste <= 0.1 * bin_capacity] = 5 # Excellent fit
    waste_penalty[(waste > 0.1 * bin_capacity) & (waste <= 0.3 * bin_capacity)] = 2 # Good fit
    waste_penalty[waste > 0.3 * bin_capacity] = -1  # Avoid larger waste

    priorities[fit] += waste_penalty

    # Fill Level: Encourage filling bins, but not too much.
    fill_ratio = item / (bins_remain_cap_fit + epsilon) # Use only bins where the item fits
    fill_reward = np.exp(-np.abs(fill_ratio - 0.9)) # Target fill ratio close to 0.9, penalize deviation.

    priorities[fit] += fill_reward # Apply only to feasible bins


    # Item Fragmentation: Discourage small gaps. Give a slight penalty if a small gap will remain
    small_gap_penalty = np.where((bins_remain_cap_fit - item) > 0 & (bins_remain_cap_fit - item) < 0.2 * bin_capacity, -0.5, 0) #Small gap up to 20%
    priorities[fit] += small_gap_penalty


    # Best Fit Emphasis: If there is a near-perfect fit, prioritize that bin.
    best_fit_threshold = 0.05 * bin_capacity  # Consider a fit "near-perfect" if waste is less than 5% of capacity
    best_fit_bonus = np.where(waste >= 0, np.exp(-waste / best_fit_threshold), 0)
    priorities[fit] += best_fit_bonus

    #Capacity Threshold: Prefer filling bins that have more space to start
    capacity_threshold_penalty = np.where(bins_remain_cap_fit > 0.5 * bin_capacity, 0.5, -0.25) # If more than 50% cap give small reward, otherwise penalty
    priorities[fit] += capacity_threshold_penalty

    return priorities
```
