```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by gravitational potential and a touch of thermal equilibrium.
    Higher capacity bins receive a higher priority. We want to use larger bins more.
    We discourage nearly full bins if better alternatives are available

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Avoid division by zero.
    bins_remain_cap = np.clip(bins_remain_cap, 1e-9, None)

    # Term 1: Favor bins with remaining capacity close to the item size (fitting well).
    fit_score = np.exp(-np.abs(bins_remain_cap - item) / item)

    # Term 2: Higher remaining capacity yields higher priority (more space to work with later).
    capacity_score = bins_remain_cap

    # Term 3: Penalize bins where the item would fill it close to capacity. Avoid too much wastage.
    # Temperature term regulates sensitivity.
    temperature = np.mean(bins_remain_cap)  # adaptive temperature
    fill_ratio = item / bins_remain_cap
    wastage_penalty = np.exp((fill_ratio -1) / (temperature + 1e-9))
    wastage_penalty = np.clip(wastage_penalty,0,1)

    priorities = fit_score * capacity_score * (1-wastage_penalty)

    return priorities
```
