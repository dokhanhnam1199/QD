```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the challenge of isolating radium and polonium, this function considers both
    the proximity to a 'perfect fit' and the minimization of wasted space, much like separating
    trace elements through meticulous chemical processes. Bins close to full capacity after the item is added
    are prioritized to reduce the overall bin count. Like focusing on the most radioactive fractions,
    bins with sufficient capacity get higher consideration. Avoid overflowing (like unwanted radiation exposure),
    thus bins with too small capacity receive zero priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Consider bins where the item fits
    feasible_bins = bins_remain_cap >= item

    if np.any(feasible_bins):
      remaining_after_fit = bins_remain_cap[feasible_bins] - item
      # Prioritize bins that minimize wasted space *relative to the original capacity*. Small remainders increase the priority.
      # Consider it as effective volume usage.
      priorities[feasible_bins] = (1 - (remaining_after_fit / bins_remain_cap[feasible_bins]))
      # Add a bonus for bins nearly filled to reduce the overall bin count. If the bin is above a certain capacity, a small bonus is applied.
      nearly_filled = remaining_after_fit <= 0.1 * bins_remain_cap[feasible_bins]  #Adjust for more or less aggressive bin packing
      priorities[feasible_bins][nearly_filled] += 0.2 #Adjust bonus as needed

      # Avoid bins with zero or close to zero remaining capacity, since other heuristics already deal with almost full bins.

    return priorities
```
