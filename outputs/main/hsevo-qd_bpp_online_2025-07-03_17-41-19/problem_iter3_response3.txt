```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers multiple factors with refined weighting:
    1. Waste: Prioritizes bins where the item fits well, minimizing wasted space. Uses a more nuanced penalty.
    2. Fill Level: Encourages filling bins as much as possible, but strongly penalizes overfilling.
    3. Remaining Capacity Ratio: A novel approach that considers the ratio of the item size to the remaining capacity. Bins with capacities slightly larger than the item are favored.
    4. Balance: Promotes a balanced utilization of bins by considering the average remaining capacity.
    5. Item Size: Smaller items should prioritize bins with smaller capacities to maximize packing density.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to avoid division by zero

    # Waste: Prioritize bins where the item fits relatively well, minimizing wasted space.
    waste = bins_remain_cap - item
    waste_priority = np.where(waste >= 0, np.exp(-2 * waste / (item + epsilon)), -np.inf)  # Exponential decay, scaled by item size
    priorities += waste_priority

    # Fill Level: Encourage filling bins, but not too much.
    fill_ratio = item / (bins_remain_cap + epsilon)
    fill_priority = np.where(fill_ratio <= 1, np.exp(fill_ratio), -np.inf) # exponential increase until ratio ==1, -inf if it doesnt fit.
    priorities += fill_priority

    # Remaining Capacity Ratio: Favors bins that have capacity slightly larger than the item size
    capacity_ratio = bins_remain_cap / (item + epsilon)
    capacity_priority = np.exp(-np.abs(capacity_ratio - 1))  # Gaussian-like preference for bins with remaining capacity close to item size.
    priorities += 0.7 * capacity_priority  # Reduced weight since waste already covers similar territory

    # Balance: Encourages balanced utilization of all bins
    avg_remain_cap = np.mean(bins_remain_cap)
    balance_priority = np.exp(-np.abs(bins_remain_cap - avg_remain_cap) / (avg_remain_cap + epsilon)) # gaussian around mean remaining capacity
    priorities += 0.3 * balance_priority

    # Item size priority: Smaller items should be packed into smaller bins, assuming enough space.
    size_priority = -np.abs(bins_remain_cap - item)
    if item < 0.3:  #scale of 0 to 1 is assumed for the size of the bins and items.
      priorities += 0.5 * size_priority

    return priorities
```
