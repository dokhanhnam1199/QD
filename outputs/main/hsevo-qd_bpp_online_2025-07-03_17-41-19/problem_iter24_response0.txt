```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A refined priority function for online bin packing that balances best-fit,
    remaining capacity, and item size considerations with carefully chosen weights
    and handling of edge cases.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # 1. Best-Fit Consideration (Waste Minimization)
    waste = bins_remain_cap - item
    fit_mask = waste >= 0
    # Exponential penalty for waste, scaled by item size. Smaller waste relative to item is better.
    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)

    # 2. Remaining Capacity Consideration (Encourage utilization of fuller bins)
    # Sigmoid function to give more weight to bins with higher remaining capacity, but plateauing effect.
    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)
    priorities = np.where(fit_mask, priorities + 0.4 * (1 / (1 + np.exp(-5 * (capacity_factor - 0.5)))), priorities)

    # 3. Item Size Consideration (Favor bins that accommodate the item well relative to their capacity)
    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon)
    # Linear reward for smaller normalized item size.
    priorities = np.where(fit_mask, priorities + 0.15 * (1 - normalized_item_size), priorities)

    # 4. Fill Ratio (Reward bins that are filled well by the item)
    fill_ratio = item / (bins_remain_cap + epsilon)
    # Reward a fill ratio closer to 1.
    fill_reward = np.where(fit_mask & (fill_ratio <= 1), np.exp(-5 * np.abs(1 - fill_ratio)), -np.inf)
    priorities = np.where(fit_mask, priorities + 0.3 * fill_reward, priorities)
    
    # 5. Handling edge cases: Give a small priority boost to bins that are nearly full
    nearly_full = (bins_remain_cap > 0) & (bins_remain_cap <= (0.1 * item + epsilon))
    priorities = np.where(fit_mask & nearly_full, priorities + 0.05, priorities)

    return priorities
```
