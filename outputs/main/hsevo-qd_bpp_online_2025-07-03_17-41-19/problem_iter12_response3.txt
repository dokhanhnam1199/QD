```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers multiple factors:
    1.  Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space. Uses a refined penalty.
    2.  Fill Level: Encourages filling bins as much as possible, but penalizes overfilling.
    3.  Balance: Aims to balance the utilization of bins, avoiding extreme differences in fill levels. This helps in distributing the load more evenly.
    4. Stability: Favors bins that closely match item size but only when a good fit is possible.
    5. Bin Preference: Introduces a minor preference for bins that are already partially filled, promoting the consolidation of items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to avoid division by zero and log of zero

    # Waste: Prioritize bins where the item fits relatively well.  Softer penalty
    waste = bins_remain_cap - item
    waste_penalty = np.where(waste >= 0, -waste**2, -np.inf)  # Quadratic penalty for waste, harsh penalty for overfill
    priorities += waste_penalty

    # Fill Level: Encourage filling bins, but not too much. Stronger reward
    fill_ratio = item / (bins_remain_cap + epsilon)
    fill_reward = np.where(fill_ratio <= 1, fill_ratio**2, -np.inf) # Square the ratio to give greater priority to almost full bins
    priorities += fill_reward

    # Balance: Encourages similar fill levels across bins.
    mean_remaining_capacity = np.mean(bins_remain_cap)
    balance_reward = -np.abs(bins_remain_cap - mean_remaining_capacity) # Prioritizes bins close to the average fill level
    priorities += 0.1 * balance_reward # Reduced weight to avoid dominating other factors.

    # Stability (Closeness to Item Size, but only if waste is small):
    stability = np.where(waste >= 0, -np.abs(bins_remain_cap - item), 0) # Only prioritize stability if the item fits
    priorities += 0.2 * stability # Reduced weight to avoid dominating other factors.

    # Bin Preference: A minor preference for partially filled bins
    bin_preference = np.where(bins_remain_cap < np.max(bins_remain_cap), 0.01, 0)  # Small bonus for non-empty bins
    priorities += bin_preference

    return priorities
```
