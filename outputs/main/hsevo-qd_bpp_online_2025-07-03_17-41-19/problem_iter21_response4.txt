```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines best-fit, remaining capacity, and item size considerations
    for bin selection, with a focus on stability and avoidance of over-engineered
    non-linearities.

    This version prioritizes a balance between filling bins well and avoiding
    excessive fragmentation.  It avoids overly aggressive non-linear
    transformations and focuses on more direct mathematical modeling.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small constant to prevent division by zero and improve stability.

    # 1. Feasibility check: Can the item fit in the bin?
    fit_mask = bins_remain_cap >= item

    # If no bin can fit item, return -inf priorities.
    if not np.any(fit_mask):
        return np.full_like(bins_remain_cap, -np.inf)

    # 2. Waste Calculation and Prioritization (Best-Fit component):
    waste = bins_remain_cap - item
    # Prioritize bins with smaller waste.  Using a linear model for simplicity
    # and interpretability.  Scale by the max capacity to make it relative.
    waste_penalty = waste / (np.max(bins_remain_cap[fit_mask]) + epsilon) # Only scale by max capacity among valid bins
    priorities = np.where(fit_mask, -waste_penalty, -np.inf) # Use negative waste as priority

    # 3. Remaining Capacity Bonus (Capacity consideration):
    # Bins with higher remaining capacity are slightly favored (but only if they fit).
    # This helps distribute items more evenly and avoids filling bins completely
    # prematurely. Use a linear model.
    capacity_bonus = bins_remain_cap / (np.max(bins_remain_cap[fit_mask]) + epsilon) #Only scale by max capacity among valid bins
    priorities = np.where(fit_mask, priorities + 0.3 * capacity_bonus, priorities)

    # 4. Item Size Consideration:  Favor bins that result in fill level close to a target
    # avoid placing tiny items in very large bins (fragmentation).
    fill_ratio = item / (bins_remain_cap + epsilon)

    # Target fill ratio (e.g., aim for bins to be roughly half-full after placing the item).
    target_fill_ratio = 0.75

    # Reward bins where the fill ratio is close to the target.  Use a simple
    # absolute difference.
    fill_reward = -np.abs(fill_ratio - target_fill_ratio)
    priorities = np.where(fit_mask, priorities + 0.2 * fill_reward, priorities)

    return priorities
```
