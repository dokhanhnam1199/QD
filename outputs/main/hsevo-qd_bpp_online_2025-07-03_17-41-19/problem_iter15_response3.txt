```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers multiple factors, focusing on simplicity,
    interpretability and efficiency.  It refines the previous version based
    on principles of iterative refinement and problem-specific adaptation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to avoid division by zero

    # 1. Feasibility: Disqualify bins where the item doesn't fit.
    feasible_bins = bins_remain_cap >= item
    priorities[~feasible_bins] = -np.inf  # Assign lowest possible priority to infeasible bins

    # 2. Waste Minimization (for feasible bins): Prioritize bins with least waste.
    waste = bins_remain_cap - item
    priorities[feasible_bins] = -waste[feasible_bins]  # Lower waste = higher priority.  Simple and direct.

    # 3. Fill Level: Encourage higher fill levels, but only for bins that *can* accommodate the item.
    fill_ratio = item / (bins_remain_cap + epsilon)
    # Apply fill ratio only to bins where the item can fit.  This avoids skewing
    # the priority with bins that are too small.
    priorities[feasible_bins] += fill_ratio[feasible_bins]


    # No need for complex functions like exp or stability considerations
    # as they add complexity without demonstrable benefit in this online scenario.
    # The core heuristic prioritizes fitting the item with minimal waste and maximum fill.

    return priorities
```
