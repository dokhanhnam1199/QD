{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function refines the bin selection process by:\n    1.  Best Fit Emphasis: Strongly prioritizes bins where the item fits with minimal waste. This is the core principle of Best-Fit heuristics.\n    2.  Remaining Capacity Consideration: Balances the \"Best Fit\" with a preference for bins that still have substantial capacity, avoiding premature fragmentation.\n    3.  Item Size Normalization: Normalize the item size to better reflect its significance relative to bin capacity.\n    4.  Capacity Threshold: Introduces a threshold for considering bins. Bins with very small remaining capacity relative to item size are heavily penalized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Best Fit Emphasis: Minimize waste\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)  # Normalized waste for better comparison. Exp to prioritize smaller waste.\n    # 2. Remaining Capacity Consideration: Balance best fit with available space.\n    # Prioritize bins with more remaining capacity (avoid excessive fragmentation)\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)  # Normalize remaining capacity\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)  # Add capacity as a secondary factor. Multiply by 0.5 so it doesn't override best-fit.\n\n    # 3. Item Size Normalization\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon) # normalize to largest bin to give it context.\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n\n    # 4. Capacity Threshold: Penalize bins that are almost full\n    threshold = 0.1  # If remaining capacity is less than 10% of bin size, penalize.\n    small_capacity_penalty = np.where(bins_remain_cap / (np.max(bins_remain_cap) + epsilon) < threshold, -10, 0) #severe penalty\n    priorities += small_capacity_penalty\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with adjusted weights and new considerations:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space. Uses a more aggressive penalty for larger waste.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Modified to focus on bins that are close to being filled by this item.\n    3. Bin Utilization: Aims to balance the distribution of items across bins to avoid clustering.\n    4. Best Fit Heuristic Influence: Directly rewards bins that provide a very tight fit, emulating best-fit behavior.\n    5. Avoidance of Near-Empty Bins: Discourages placing items into bins that are still almost completely empty unless no other choice is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.  Aggressive penalty for waste.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste**2, -np.inf)  # Quadratic penalty for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much. Focus on bins that are close to being filled.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(1 - np.abs(1 - fill_ratio)), -np.inf) # Reward when fill ratio is close to 1\n    priorities += fill_reward\n\n    # Bin Utilization: Try to balance utilization across bins\n    utilization = 1 - bins_remain_cap  # Assuming bin capacity is normalized to 1.  Higher utilization is better.\n    utilization_reward = np.exp(utilization)\n    priorities += 0.1 * utilization_reward # scale down to balance relative to other heuristics\n\n    # Best Fit Heuristic Influence: Directly reward bins that provide a near-perfect fit.\n    best_fit_bonus = np.where(np.abs(waste) < 0.05, 10, 0) # Substantial reward for very small waste\n    priorities += best_fit_bonus\n\n    # Avoidance of Near-Empty Bins: Discourage putting items into near-empty bins unless necessary\n    near_empty_penalty = np.where(bins_remain_cap > 0.9, -1, 0) # Penalize if almost empty.\n    priorities += near_empty_penalty\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the top heuristic considers waste, remaining capacity, item size normalization, and capacity threshold, using carefully weighted combinations and normalization techniques. In contrast, the bottom heuristic uses a simple log ratio of item size to remaining capacity. (2nd) is identical to (1st). Comparing (1st) vs (4th), the top heuristic uses a more sophisticated combination of waste minimization, remaining capacity and item size normalization with capacity threshold, while the (4th) heuristic combines waste minimization and fill level considerations with less nuanced penalties and rewards. (5th) considers waste, fill level, item fit, bin utilization, and number of items (approximated by remaining space). (6th) considers waste minimization and a modified fill ratio. (7th) considers waste, fill level, bin utilization, best fit heuristic influence, and avoidance of near-empty bins. (8th) considers waste, fill level, number of items, and stability and uses scaling factors. Comparing (8th) vs (9th), (8th) has scaling factors as parameters and (9th) doesn't. Comparing (7th) vs (10th), they are identical. Comparing (11th) vs (15th), (11th) considers waste minimization, fill level encouragement and stability, while (15th) is a simplified one. Comparing (13th) vs (14th), they are identical. Overall: The better heuristics incorporate multiple factors with careful weighting and normalization, and avoid edge-case penalties.\n- \nOkay, let's refine \"Current Self-Reflection\" for designing better heuristics, avoiding pitfalls of \"Ineffective Self-Reflection\":\n\n*   **Keywords:** Relevant factors, mathematical modeling, weighting, edge cases, robustness, scaling, feasibility constraints.\n\n*   **Advice:** Prioritize incorporating *all* truly relevant factors *directly* instead of approximating; use appropriate (but not necessarily complex or non-linear) mathematical models, and carefully tune weights. Ensure robustness.\n\n*   **Avoid:** Over-reliance on non-linear functions (exponential, sigmoid, etc.) *without strong justification*; Approximating missing data when direct incorporation is feasible; Premature optimization of parameters.\n\n*   **Explanation:** Focus on a solid foundation. Accurately represent the problem's core elements mathematically, handle boundary conditions gracefully, and only add complexity *after* a simple, robust heuristic exists.\n\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}