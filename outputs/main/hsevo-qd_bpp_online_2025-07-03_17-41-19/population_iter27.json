[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling (impossible but included for completeness).\n    3. Number of Items: Accounts for how many items are already present in bins (not directly accessible in online BPP). We approximate using the amount of available space. Sparsely filled bins are encouraged, up to a point. Densely filled bins discouraged.\n    4. Stability: Favors bins that are closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste), -np.inf)  # Exponential decay for waste, harsh penalty for overfill. Negative inf indicates bin won't fit\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio), -np.inf)\n    priorities += fill_reward\n\n    # Number of Items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap) # Lower remaining cap equals larger item_density, less filled\n    priorities += item_density\n    # Stability (Closeness to Item Size):\n\n    stability = -np.abs(bins_remain_cap - item)\n    priorities += stability\n\n    return priorities",
    "response_id": 2,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 95.90827503317318,
    "mi": 81.36634323366762,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and fill level to improve priority.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste minimization: Smaller waste is better\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste, -np.inf)\n    priorities += waste_penalty\n\n    # Fill level: Encourages fuller bins\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)\n    priorities += fill_reward\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 112.58797503894243,
    "mi": 86.1647151103729,
    "token_count": 123.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with refined weighting and scaling:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.  Uses a more sensitive exponential decay.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Uses a sigmoid function for smoother behavior.\n    3. Bin Utilization: Directly rewards bins that have been used to some extent, encouraging balanced usage.\n    4. Stability: Favors bins that are closest to the item size, scaled by the item size itself.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-10 * waste / item), -np.inf)  # More sensitive exponential decay, scaled by item size. Harsh penalty for overfill.\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.  Sigmoid function\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = 1 / (1 + np.exp(5 - 10 * fill_ratio)) # Sigmoid centered around fill_ratio = 0.5\n    priorities += fill_reward\n\n    # Bin Utilization: Reward bins that have some items in them already\n    utilization = (1 - bins_remain_cap) # Previously available capacity\n    utilization_reward = np.where(utilization > 0, np.tanh(utilization), 0) #tanh squashes the values and 0 if it is new bin.\n    priorities += 0.5 * utilization_reward\n\n    # Stability (Closeness to Item Size): Scaled by item size\n    stability = -np.abs(bins_remain_cap - item) / (item + epsilon)\n    priorities += 0.25 * stability\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 351.5549000980772,
    "mi": 74.18627975849658,
    "token_count": 210.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_exp_scale: float = 0.7689715119248567, fill_exp_scale: float = 0.7967806647402089, density_exp_scale: float = 1.1915806622742056, stability_weight: float = 0.240849797356982, epsilon: float = 6.42850688735192e-08) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling (impossible but included for completeness).\n    3. Number of Items: Accounts for how many items are already present in bins (not directly accessible in online BPP). We approximate using the amount of available space. Sparsely filled bins are encouraged, up to a point. Densely filled bins discouraged.\n    4. Stability: Favors bins that are closest to the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_exp_scale: Scaling factor for the waste exponential.\n        fill_exp_scale: Scaling factor for the fill exponential.\n        density_exp_scale: Scaling factor for the density exponential.\n        stability_weight: Weight of the stability component.\n        epsilon: Small value to avoid division by zero and log of zero\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste * waste_exp_scale), -np.inf)  # Exponential decay for waste, harsh penalty for overfill. Negative inf indicates bin won't fit\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio * fill_exp_scale), -np.inf)\n    priorities += fill_reward\n\n    # Number of Items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap * density_exp_scale) # Lower remaining cap equals larger item_density, less filled\n    priorities += item_density\n    # Stability (Closeness to Item Size):\n\n    stability = -np.abs(bins_remain_cap - item) * stability_weight\n    priorities += stability\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 252.6150117466338,
    "mi": 69.03585810861566,
    "token_count": 195.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with adjusted weights and new considerations:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space. Uses a more aggressive penalty for larger waste.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Modified to focus on bins that are close to being filled by this item.\n    3. Bin Utilization: Aims to balance the distribution of items across bins to avoid clustering.\n    4. Best Fit Heuristic Influence: Directly rewards bins that provide a very tight fit, emulating best-fit behavior.\n    5. Avoidance of Near-Empty Bins: Discourages placing items into bins that are still almost completely empty unless no other choice is available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.  Aggressive penalty for waste.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste**2, -np.inf)  # Quadratic penalty for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much. Focus on bins that are close to being filled.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(1 - np.abs(1 - fill_ratio)), -np.inf) # Reward when fill ratio is close to 1\n    priorities += fill_reward\n\n    # Bin Utilization: Try to balance utilization across bins\n    utilization = 1 - bins_remain_cap  # Assuming bin capacity is normalized to 1.  Higher utilization is better.\n    utilization_reward = np.exp(utilization)\n    priorities += 0.1 * utilization_reward # scale down to balance relative to other heuristics\n\n    # Best Fit Heuristic Influence: Directly reward bins that provide a near-perfect fit.\n    best_fit_bonus = np.where(np.abs(waste) < 0.05, 10, 0) # Substantial reward for very small waste\n    priorities += best_fit_bonus\n\n    # Avoidance of Near-Empty Bins: Discourage putting items into near-empty bins unless necessary\n    near_empty_penalty = np.where(bins_remain_cap > 0.9, -1, 0) # Penalize if almost empty.\n    priorities += near_empty_penalty\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 499.7586317660004,
    "mi": 68.15120292310573,
    "token_count": 230.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and a modified fill ratio.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste minimization: Smaller waste is better\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, -waste, -np.inf)\n    priorities += waste_penalty\n\n    # Modified fill ratio: Encourages fuller bins but dampens very full bins\n    fill_ratio = item / (bins_remain_cap + item + epsilon)  # Normalized by item size\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)\n    priorities += fill_reward\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 250.25142037603445,
    "mi": 82.60183036870474,
    "token_count": 161.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors, with refined weighting and a focus on avoiding edge-case penalties:\n    1.  Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.  Uses a more nuanced penalty.\n    2.  Fill Level: Encourages filling bins as much as possible, but penalizes overfilling. Exponential reward for fill ratio.\n    3.  Balance: Encourages a more balanced distribution of items across bins, especially when bins are similarly filled.\n    4.  Adaptability: Introduces a parameter (alpha) to adjust the relative importance of waste vs. fill level.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n    alpha = 0.5  # Adjust the weight of waste vs. fill (0 to 1)\n\n    # Waste: Prioritize bins where the item fits relatively well, minimizing wasted space.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste / (item + epsilon)), -np.inf)  # Exponential decay scaled by item size\n    priorities += alpha * waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, np.exp(fill_ratio), -np.inf)\n    priorities += (1 - alpha) * fill_reward\n\n    # Balance: Encourages a more balanced distribution of items. Avoid extreme fill levels early on.\n    # This helps in scenarios where bins have similar remaining capacities.\n    bin_utilization = 1 - (bins_remain_cap / (np.max(bins_remain_cap) + epsilon)) # Relative to the fullest bin\n    balance_reward = np.exp(-np.abs(bin_utilization - 0.5)) # Target around 50% utilization.  Avoids being too greedy.\n    priorities += 0.1 * balance_reward  # Smaller weight.  Balance is secondary.\n\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 25.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 612.824129633614,
    "mi": 69.64650112258727,
    "token_count": 325.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers multiple factors:\n    1. Waste: Prioritizes bins where the item fits relatively well, minimizing wasted space.\n    2. Fill Level: Encourages filling bins as much as possible, but penalizes overfilling.\n    3. Item Fit: A stronger focus on how well the item fits relative to the bin's capacity.\n    4. Bin Utilization: Directly incentivize using bins that have already been started.\n    5. Number of items: Approximated by remaining space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero and log of zero\n\n    # Waste: Prioritize bins where the item fits relatively well.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-waste), -np.inf)  # Exponential decay for waste, harsh penalty for overfill\n    priorities += waste_penalty\n\n    # Fill Level: Encourage filling bins, but not too much.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fill_ratio <= 1, fill_ratio, -np.inf)  # linear reward, harsh penalty. Experiment different functions\n    priorities += fill_reward\n\n    # Item Fit: How well the item fits, using a scaled sigmoid function.\n    item_fit = 1 / (1 + np.exp(5 * (waste / (item + epsilon) - 0.5))) # Experiment with the scaling factor 5 and offset 0.5\n    item_fit = np.where(waste >= 0, item_fit, 0) # Only consider if item fits.\n    priorities += item_fit\n\n    # Bin Utilization: Encourage using bins that are already partially filled.\n    bin_utilization = 1 - bins_remain_cap # scale between zero and one\n    priorities += bin_utilization\n    \n    # Number of items (Approximated by remaining space): Encourages placing items in bins that were sparsely filled\n    item_density = np.exp(-bins_remain_cap) # Lower remaining cap equals larger item_density, less filled\n    priorities += 0.1 * item_density\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 17.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 421.96572261594497,
    "mi": 75.8467657579968,
    "token_count": 221.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros\n\n    # Prioritize bins with minimal waste using a reciprocal function. Clipping\n    # waste at a small value prevents overly large priorities for nearly full bins.\n    clipped_waste = np.clip(waste[feasible_bins], a_min=epsilon, a_max=None)  # Ensure waste is never zero.\n    waste_priority = 1 / clipped_waste\n    priorities[feasible_bins] += waste_priority\n\n    # 2. Fill Level Encouragement (Secondary, conditional on feasibility)\n    # Encourage filling the bin as much as possible, relative to its *original* size.\n    # This helps prevent fragmenting larger bins early on.\n    fill_ratio = item / (bins_remain_cap[feasible_bins] + epsilon)\n\n    # Use a sigmoid function to gently reward higher fill ratios, but prevent extreme values.\n    # Sigmoid squashes the fill_ratio to be between 0 and 1\n    fill_priority = 1 / (1 + np.exp(-5 * (fill_ratio - 0.5))) # Steep sigmoid centered at fill_ratio=0.5\n    priorities[feasible_bins] += fill_priority\n    \n    # 3. Stability (Tertiary) - Prefer bins close to item size, but with a small weight\n    stability = -np.abs(bins_remain_cap[feasible_bins] - item)\n    # Scale stability to have a smaller impact\n    stability_priority = stability * 0.1\n    priorities[feasible_bins] += stability_priority\n\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 157.89111045234063,
    "mi": 79.49610190474412,
    "token_count": 167.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines waste minimization and fill level considerations for bin selection.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Waste: Exponential penalty for wasted space, hard penalty for overfill.\n    waste = bins_remain_cap - item\n    waste_penalty = np.where(waste >= 0, np.exp(-10 * waste / item), -np.inf)\n    priorities += waste_penalty\n\n    # Fill Level: Sigmoid reward for filling bins, avoid overfilling.\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = 1 / (1 + np.exp(5 - 10 * fill_ratio))\n    priorities += fill_reward\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 222.9388339674094,
    "mi": 79.52044149581245,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response4.txt_stdout.txt",
    "code_path": "problem_iter18_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function refines the bin selection process by:\n    1.  Best Fit Emphasis: Strongly prioritizes bins where the item fits with minimal waste. This is the core principle of Best-Fit heuristics.\n    2.  Remaining Capacity Consideration: Balances the \"Best Fit\" with a preference for bins that still have substantial capacity, avoiding premature fragmentation.\n    3.  Item Size Normalization: Normalize the item size to better reflect its significance relative to bin capacity.\n    4.  Capacity Threshold: Introduces a threshold for considering bins. Bins with very small remaining capacity relative to item size are heavily penalized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small value to avoid division by zero\n\n    # 1. Best Fit Emphasis: Minimize waste\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)  # Normalized waste for better comparison. Exp to prioritize smaller waste.\n    # 2. Remaining Capacity Consideration: Balance best fit with available space.\n    # Prioritize bins with more remaining capacity (avoid excessive fragmentation)\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)  # Normalize remaining capacity\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)  # Add capacity as a secondary factor. Multiply by 0.5 so it doesn't override best-fit.\n\n    # 3. Item Size Normalization\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon) # normalize to largest bin to give it context.\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n\n    # 4. Capacity Threshold: Penalize bins that are almost full\n    threshold = 0.1  # If remaining capacity is less than 10% of bin size, penalize.\n    small_capacity_penalty = np.where(bins_remain_cap / (np.max(bins_remain_cap) + epsilon) < threshold, -10, 0) #severe penalty\n    priorities += small_capacity_penalty\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 14.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 289.9853819512694,
    "mi": 67.61475162641615,
    "token_count": 211.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_clip_min: float = 1.6617846807395032e-09,\n                fill_sigmoid_scale: float = 9.493317672830546, fill_sigmoid_center: float = 0.7654453973055002,\n                stability_weight: float = 0.05972327746087532) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_clip_min: Small value to avoid division by zero when calculating waste priority.\n        fill_sigmoid_scale: Scale of the sigmoid function used for fill priority.\n        fill_sigmoid_center: Center point of the sigmoid function.\n        stability_weight: Weight of the stability component in the overall priority.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = waste_clip_min  # Small value to avoid division by zero\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "mi": 74.18426101931979,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response6.txt_stdout.txt",
    "code_path": "problem_iter20_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit and remaining capacity considerations for bin selection.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    waste = bins_remain_cap - item\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)\n\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon)\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fit_mask & (fill_ratio <= 1), np.exp(1 - np.abs(1 - fill_ratio)), -np.inf)\n    priorities = np.where(fit_mask, priorities + 0.2 * fill_reward, priorities)\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.008775428799367,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 169.6436125266828,
    "mi": 89.51228121262838,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response0.txt_stdout.txt",
    "code_path": "problem_iter21_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A refined priority function for online bin packing that considers:\n    - Waste (lower waste is better)\n    - Bin utilization (higher utilization is better)\n    - Item size relative to bin size (favors bins well-suited to the item)\n    - Remaining capacity relative to average capacity.\n\n    This version avoids excessive use of exponentials and focuses on a more direct\n    combination of relevant factors, with careful handling of edge cases.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9  # Small constant to avoid division by zero\n\n    # Feasibility check: Can the item fit in the bin?\n    fit_mask = bins_remain_cap >= item\n\n    if not np.any(fit_mask):\n        return priorities  # No feasible bins, all priorities remain 0\n\n    # 1. Waste:  Smaller waste is better.  We only consider waste for feasible bins.\n    waste = bins_remain_cap - item\n    waste_priority = np.where(fit_mask, 1 - (waste / (np.max(bins_remain_cap[fit_mask]) + epsilon)), 0) # Normalize waste\n    waste_priority = np.where(waste_priority < 0, 0, waste_priority) #ensure waste priority is non-negative\n\n    # 2. Utilization: Higher utilization (item size / bin capacity) is better.\n    utilization = item / (bins_remain_cap + epsilon)\n    utilization_priority = np.where(fit_mask, utilization, 0) # Only consider utilization of feasible bins.\n\n    # 3. Item size relative to average remaining capacity.\n    avg_remaining_capacity = np.mean(bins_remain_cap)\n    size_difference = np.abs(item - avg_remaining_capacity)\n    size_priority = 1 - (size_difference / (np.max(bins_remain_cap) + epsilon))\n    size_priority = np.clip(size_priority, 0, 1) # ensure size_priority is between 0 and 1\n\n    # 4. Remaining capacity relative to other bin capacity:\n    capacity_ratio = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)\n\n\n    # Combine the priorities with weights.  Experiment with these weights.\n    priorities = (\n        0.4 * waste_priority +\n        0.3 * utilization_priority +\n        0.1 * size_priority +\n        0.2 * capacity_ratio\n    )\n\n    # Infeasible bins get a very low priority\n    priorities = np.where(fit_mask, priorities, -np.inf)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 238.04106876125107,
    "mi": 70.27210733815168,
    "token_count": 234.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                epsilon: float = 4.793285405837202e-10, \n                fill_sigmoid_scale: float = 4.51408525366892,\n                fill_sigmoid_center: float = 0.5647920172644034,\n                stability_weight: float = 0.10071478901863083) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero. Default is 1e-9.\n        fill_sigmoid_scale: Scale of the sigmoid function for fill priority. Default is 5.\n        fill_sigmoid_center: Center of the sigmoid function for fill priority. Default is 0.5.\n        stability_weight: Weight of the stability priority. Default is 0.1.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "mi": 81.97618904364712,
    "token_count": 99.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response7.txt_stdout.txt",
    "code_path": "problem_iter23_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, capacity, and item size for bin priority.\n    Prioritizes bins that minimize waste, have sufficient capacity, \n    and accommodate the item size effectively.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Best Fit: Exponentially prefer smaller waste\n    waste = bins_remain_cap - item\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    # Capacity Consideration: Favor bins with more remaining capacity\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)\n\n    # Item Size Normalization: Give context to item's relative size.\n    normalized_item_size = item / (np.max(bins_remain_cap) + epsilon)\n    priorities = np.where(fit_mask, priorities + 0.1 * (1 - normalized_item_size), priorities)\n    \n    #Small Capacity Threshold: Penalize bins that are almost full\n    threshold = 0.1\n    small_capacity_penalty = np.where(bins_remain_cap / (np.max(bins_remain_cap) + epsilon) < threshold, -10, 0)\n    priorities += small_capacity_penalty\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 18.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 305.0,
    "mi": 79.72602230832827,
    "token_count": 205.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response2.txt_stdout.txt",
    "code_path": "problem_iter24_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Refines bin selection by prioritizing bins that offer a good fit while also\n    considering the overall fill level and penalizing near-full bins less harshly.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    waste = bins_remain_cap - item\n    fit_mask = waste >= 0\n\n    # Best-fit component with a sharper preference for tighter fits\n    priorities = np.where(fit_mask, np.exp(-2 * waste / (item + epsilon)), -np.inf)\n\n    # Capacity-aware component, boosted for emptier bins, but softened\n    max_cap = np.max(bins_remain_cap) + epsilon\n    capacity_factor = bins_remain_cap / max_cap\n    priorities = np.where(fit_mask, priorities + 0.3 * np.sqrt(capacity_factor), priorities) # Soften with sqrt\n\n    # Item size normalization (still useful), slightly reduced weight\n    normalized_item_size = item / max_cap\n    priorities = np.where(fit_mask, priorities + 0.05 * (1 - normalized_item_size), priorities)\n\n    # Fill ratio reward, but with reduced penalty for near-full bins\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fit_mask & (fill_ratio <= 1), np.exp(-np.abs(1 - fill_ratio)), -np.inf) # Reduced penalty exponent\n    priorities = np.where(fit_mask, priorities + 0.15 * fill_reward, priorities) # Slightly lower weight\n\n    # Add a small bonus for bins with significantly larger capacity than the item\n    large_capacity_bonus = np.where(fit_mask & (bins_remain_cap > 2 * item), 0.05, 0)\n    priorities = np.where(fit_mask, priorities + large_capacity_bonus, priorities)\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.028719585161557,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 412.53150435559246,
    "mi": 83.14023989715702,
    "token_count": 266.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter25_response0.txt_stdout.txt",
    "code_path": "problem_iter25_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 4.094056941257985e-09, fill_sigmoid_scale: float = 6.956433094835324, fill_sigmoid_center: float = 0.7072584977051273, stability_weight: float = 0.2266114000045233) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function prioritizes bins based on a combination of factors,\n    aiming for a balance between minimizing waste, maximizing fill, and maintaining\n    stability. It refines the approach in priority_v1 by using a more targeted\n    strategy for each component.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Small value to avoid division by zero.\n        fill_sigmoid_scale: Scale of the sigmoid function for fill ratio.\n        fill_sigmoid_center: Center of the sigmoid function for fill ratio.\n        stability_weight: Weight of the stability component.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Waste Minimization (Primary Goal)\n    waste = bins_remain_cap - item\n    # Only consider bins where the item fits\n    feasible_bins = waste >= 0\n    if not np.any(feasible_bins):\n        return priorities # No feasible bin, return all zeros",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "mi": 58.983248902374136,
    "token_count": 95.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter26_response8.txt_stdout.txt",
    "code_path": "problem_iter26_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on best fit, capacity, and fill ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n\n    # Best Fit: Minimize waste (similar to priority_v0)\n    waste = bins_remain_cap - item\n    fit_mask = waste >= 0\n    priorities = np.where(fit_mask, np.exp(-waste / (item + epsilon)), -np.inf)\n\n    # Remaining Capacity Consideration (similar to priority_v0)\n    capacity_factor = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)\n    priorities = np.where(fit_mask, priorities + 0.5 * capacity_factor, priorities)\n\n    # Fill Ratio: Encourages fuller bins (similar to priority_v1 but adjusted)\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_reward = np.where(fit_mask, fill_ratio, -np.inf) #consider only valid bins\n    priorities = np.where(fit_mask, priorities + 0.3 * fill_reward, priorities)\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 235.53074858920888,
    "mi": 58.95686827703473,
    "token_count": 177.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter27_response1.txt_stdout.txt",
    "code_path": "problem_iter27_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    A refined priority function for online bin packing, balancing best-fit,\n    remaining capacity, and fill ratio while addressing edge cases.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    epsilon = 1e-9\n    max_bin_capacity = np.max(bins_remain_cap) + epsilon\n\n    # Feasibility mask: Only consider bins that can accommodate the item\n    fit_mask = bins_remain_cap >= item\n\n    # 1. Best-Fit Prioritization (Waste Minimization)\n    waste = bins_remain_cap - item\n    waste = np.clip(waste, 0, max_bin_capacity)  # Ensure waste is within bounds\n    waste_penalty = np.where(fit_mask, -waste / max_bin_capacity, -np.inf) # Normalize and penalize waste\n    priorities = np.where(fit_mask, priorities + waste_penalty, priorities)\n\n    # 2. Remaining Capacity Reward (Balance Utilization)\n    capacity_ratio = bins_remain_cap / max_bin_capacity\n    capacity_reward = np.where(fit_mask, 0.3 * capacity_ratio, -np.inf) # Normalize and reward high capacity bins\n    priorities = np.where(fit_mask, priorities + capacity_reward, priorities)\n\n    # 3. Fill Ratio Optimization (Target Near-Perfect Fill)\n    fill_ratio = item / (bins_remain_cap + epsilon)\n    fill_difference = np.abs(1 - fill_ratio)\n    fill_reward = np.where(fit_mask, -np.abs(fill_difference), -np.inf)\n    priorities = np.where(fit_mask, priorities + 0.5 * fill_reward, priorities)\n    # Encourage bins that get filled closest to full.\n\n    # 4. Item Size Consideration (Small Items into Smaller Bins)\n    item_size_factor = item / max_bin_capacity\n    item_size_reward = np.where(fit_mask, 0.1 * (1 - item_size_factor), -np.inf)\n    priorities = np.where(fit_mask, priorities + item_size_reward, priorities)\n\n    # 5. Prioritize almost full bins. Give a boost if item fits nearly perfectly\n    almost_full_bonus = np.where(fit_mask & (waste < 0.1 * max_bin_capacity), 0.5, 0) # big reward\n    priorities = np.where(fit_mask, priorities + almost_full_bonus, priorities)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 24.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 494.2667786696707,
    "mi": 79.77356702511722,
    "token_count": 297.0,
    "exec_success": true
  }
]