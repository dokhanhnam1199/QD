```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers:
    1.  Waste Ratio: Prioritizes bins with minimal waste relative to bin size.
    2.  Capacity Usage: Encourages higher bin utilization, but avoids overfilling.
    3.  Item Fit: Bins that are just big enough to fit the item get a boost.
    4.  Remaining Capacity: Moderately empty bins are slightly favored.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    # Waste Ratio: Penalize waste relative to bin size
    waste = bins_remain_cap - item
    waste_ratio = waste / (bins_remain_cap + epsilon)
    waste_penalty = np.where(waste >= 0, -waste_ratio, -np.inf)  # Harsh penalty for overfill
    priorities += waste_penalty

    # Capacity Usage: Reward filling bins, but avoid overflowing
    capacity_usage = item / (bins_remain_cap + epsilon)
    capacity_reward = np.where(capacity_usage <= 1, capacity_usage, -np.inf)
    priorities += capacity_reward

    # Item Fit: Give bins that barely fit the item a bonus
    item_fit = np.exp(-np.abs(waste))  # Higher score if waste is small (close fit)
    item_fit = np.where(waste >= 0, item_fit, 0) # only award if waste >= 0.
    priorities += item_fit

    # Remaining Capacity: Slightly favor bins with more remaining space, up to a limit
    remaining_capacity_bonus = np.exp(-bins_remain_cap/np.max(bins_remain_cap+epsilon)) # normalized.
    priorities += 0.1*remaining_capacity_bonus  # Scale down to avoid dominating other factors

    return priorities
```
