```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines best-fit, remaining capacity, and a bin-usefulness factor for bin selection.

    This version aims to improve upon v1 by:
    1. Emphasizing bins that are already somewhat filled (bin_usefulness).
    2. Reducing sensitivity to very small capacity differences.
    3. Adapting the capacity factor based on item size.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9
    max_cap = np.max(bins_remain_cap) + epsilon

    waste = bins_remain_cap - item
    fit_mask = waste >= 0

    # Best-fit component: prioritize bins where the item fits with minimal waste.
    # Use a quadratic penalty for waste to be less sensitive to small differences and more sensitive to large ones.
    waste_penalty = np.where(fit_mask, np.exp(- (waste**2) / (item**2 + epsilon)), -np.inf) # Reduced sensitivity. exp(-waste^2) instead of exp(-waste)
    priorities = np.where(fit_mask, waste_penalty, priorities)


    # Capacity factor: favor bins with higher remaining capacity, but adapt it based on item size.
    # If the item is large, focus more on finding *any* suitable bin.
    # If the item is small, consider a preference for bins that are already somewhat full
    item_size_ratio = item / max_cap
    capacity_weight = 0.3 * (1 - item_size_ratio)  # Reduce influence for larger items
    capacity_factor = bins_remain_cap / max_cap # Normalize the remaining cap
    priorities = np.where(fit_mask, priorities + capacity_weight * capacity_factor, priorities) # Reduce the influence of this factor for large items


    # Bin usefulness factor: Incentivize filling bins that are already partially used.
    # This can help consolidate items and reduce fragmentation.  Avoid adding item to empty bins.
    filled_amount = max_cap - bins_remain_cap
    bin_usefulness = np.where(fit_mask, filled_amount / max_cap, 0) #Consider already filled amount.
    usefulness_weight = 0.2
    priorities = np.where(fit_mask, priorities + usefulness_weight * bin_usefulness, priorities)


    # Fill ratio reward, adjusted to prevent division by zero and to focus on near-perfect fits.
    fill_ratio = item / (bins_remain_cap + epsilon) #add a small epsilon to avoid division by zero
    fill_reward = np.where(fit_mask & (fill_ratio <= 1), np.exp(-5 * np.abs(1 - fill_ratio)), -np.inf) #Focus on near-perfect fits
    priorities = np.where(fit_mask, priorities + 0.25 * fill_reward, priorities) # bump up the weight slightly

    return priorities
```
