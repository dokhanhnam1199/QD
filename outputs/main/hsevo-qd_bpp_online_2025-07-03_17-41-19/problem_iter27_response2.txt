```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A refined priority function that balances best-fit, capacity utilization,
    and item size relative to bin size. It incorporates explicit penalties
    for near-misses and rewards for efficient packing, with careful normalization
    and scaling to improve robustness.

    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9

    waste = bins_remain_cap - item
    fit_mask = waste >= 0

    # Initialize with a large negative value for bins that cannot fit the item
    priorities = np.where(~fit_mask, -1e9, priorities)

    # Best-fit component: Prefer bins with minimal waste
    waste_normalized = waste / (item + epsilon)  # Normalize by item size
    best_fit_priority = np.exp(-waste_normalized)
    priorities = np.where(fit_mask, priorities + best_fit_priority, priorities)

    # Remaining capacity component: Favor bins with higher remaining capacity
    # but only to a certain extent (avoid placing small items in huge bins).
    capacity_normalized = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)
    capacity_priority = np.clip(capacity_normalized, 0, 0.8)  # Cap benefit
    priorities = np.where(fit_mask, priorities + 0.3 * capacity_priority, priorities)

    # Item size component: Encourage packing larger items early by penalizing
    # bins that are significantly larger than the item.
    item_size_normalized = item / (np.max(bins_remain_cap) + epsilon)
    item_size_priority = 1 - np.abs(item_size_normalized - capacity_normalized) #similarity with bin size
    priorities = np.where(fit_mask, priorities + 0.2 * item_size_priority, priorities)


    # Fill ratio component: Reward bins that are filled well by the item.
    fill_ratio = item / (bins_remain_cap + epsilon)
    fill_reward = np.exp(-np.abs(1 - fill_ratio) * 3)  # Sharper reward curve
    priorities = np.where(fit_mask, priorities + 0.5 * fill_reward, priorities)


    # Penalty for bins that are only slightly larger than the item.
    near_miss_threshold = 0.1  # Adjust as needed
    near_miss_penalty = np.where(
        fit_mask & (waste / item < near_miss_threshold),
        -0.5,  # Moderate penalty
        0
    )
    priorities = np.where(fit_mask, priorities + near_miss_penalty, priorities)

    return priorities
```
