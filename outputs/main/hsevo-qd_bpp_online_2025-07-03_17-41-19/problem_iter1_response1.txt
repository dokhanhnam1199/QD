```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal remaining space,
    but also penalizes bins that are significantly larger than the item. It introduces a "resonance"
    concept - optimal packing occurs when the bin's remaining capacity "resonates" with the item's size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # First, identify bins that can fit the item
    valid_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins):
        # If no bin can fit, return a negative priority for all, indicating impossibility. Favor the fullest bin.
        priorities = bins_remain_cap - np.max(bins_remain_cap) -1 # less full bins get more negative numbers.
        return priorities

    # Calculate the wasted space if the item is placed in each bin
    wasted_space = bins_remain_cap - item

    # Calculate a "resonance" factor.  Bins with less waste have a higher base priority.
    # We want to normalize the wasted space so that smaller waste has higher priority, approaching 1.
    # A possible normalization is e^(-wasted_space/item). If waste is 0, the factor is 1.
    # The higher the wasted space, the factor approaches 0.
    resonance_factor = np.exp(-wasted_space / item)

    # Also add a scaling based on how close the item is to fully filling the bin.
    # This gives preference to more filled bins *after* considering waste, and accounts
    # for the first-fit mentality. The ratio of item to bin capacity measures fullness.
    # It naturally handles different magnitude scales of item/bin pairs.
    fullness_factor = item / bins_remain_cap

    # Combine the factors. The weights can be tuned.
    priorities[valid_bins] = resonance_factor[valid_bins] + fullness_factor[valid_bins]

    # Further incentivize bins that are close to capacity, without actually overflow
    priorities[valid_bins] += np.where(valid_bins, 0.1 * (bins_remain_cap[valid_bins] / np.max(bins_remain_cap[valid_bins])), 0)
    return priorities
```
