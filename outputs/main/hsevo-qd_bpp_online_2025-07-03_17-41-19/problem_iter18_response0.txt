```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function prioritizes minimizing waste and balancing bin utilization.
    It focuses on simplicity and effectiveness for online bin packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Small value to avoid division by zero

    # 1. Waste Minimization: Primary goal is to find the best fit.
    waste = bins_remain_cap - item
    fit_mask = waste >= 0
    
    # If no bin fits, return low priority for all
    if not np.any(fit_mask):
        return np.full_like(bins_remain_cap, -np.inf)

    #Prioritize bins where the item fits relatively well, minimizing wasted space.
    waste_score = np.where(fit_mask, np.exp(-waste), -np.inf) # bins that don't fit get -inf
    priorities += waste_score
    
    # 2. Bin Utilization: Encourage balanced utilization of bins.
    # We want to avoid having some bins almost full and others almost empty.
    # Penalize bins that are already too full.
    fill_level = (bins_remain_cap - item) / (1 - item + epsilon)
    fill_penalty = np.where(fit_mask, np.exp(-np.abs(fill_level)), -np.inf)
    priorities += fill_penalty

    return priorities
```
