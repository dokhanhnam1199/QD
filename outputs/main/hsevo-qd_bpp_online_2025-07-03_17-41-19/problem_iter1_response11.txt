```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function considers both the space utilization and fragmentation.
    It gives higher priority to bins that can accommodate the item without
    leaving too much unused space (good utilization), while also penalizing
    bins where the item would leave very little space (high fragmentation risk).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Consider only bins where item fits
    mask = bins_remain_cap >= item
    eligible_bins_remain_cap = bins_remain_cap[mask]

    if len(eligible_bins_remain_cap) == 0:
        return priorities  # No suitable bins, all priorities remain 0.

    # Utilization Score: Higher score for better utilization
    utilization = item / eligible_bins_remain_cap
    utilization_score = utilization

    # Fragmentation Penalty: Penalize bins leaving very small space.
    remaining_space = eligible_bins_remain_cap - item
    fragmentation_penalty = np.exp(-remaining_space)

    # Combine Utilization and Fragmentation scores
    combined_score = utilization_score - fragmentation_penalty

    # Apply the combined scores to the original array (only where the item fits).
    priorities[mask] = combined_score

    return priorities
```
