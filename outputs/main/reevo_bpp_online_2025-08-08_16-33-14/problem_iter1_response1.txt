```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit strategy.

    In Best Fit, we prioritize bins that have just enough remaining capacity
    to fit the item. This aims to leave larger remaining capacities in other
    bins for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more preferred bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    # Calculate the remaining capacity after placing the item
    remaining_after_fit = bins_remain_cap - item

    # We only consider bins where the item can actually fit
    can_fit_mask = remaining_after_fit >= 0

    # For bins where the item fits, assign a priority.
    # The ideal bin (Best Fit) is the one that results in the smallest non-negative remaining capacity.
    # We want to maximize the "closeness" to zero remaining capacity without going negative.
    # A simple way to achieve this is to use the negative of the remaining capacity.
    # A larger (less negative) value means closer to zero remaining capacity.
    # To avoid division by zero or issues with zero remaining capacity, we can add a small epsilon,
    # or ensure that a perfect fit (0 remaining) gets a very high priority.
    # Let's try a score that is high for perfect fits and decreases as the remaining capacity increases.
    # A large positive score for perfect fits, and for others, a score based on how close they are to fitting perfectly.

    # Let's define a score that prioritizes bins with the smallest positive remaining capacity after fitting.
    # We want to maximize (bins_remain_cap - item) such that it's >= 0.
    # So, if remaining_after_fit is 0, that's the best.
    # If remaining_after_fit is 0.1, that's better than 0.5.

    # We can invert the remaining_after_fit for fitting bins and normalize or scale it.
    # A common heuristic approach is to use the negative of the remaining capacity if positive,
    # as this rewards bins that have "just enough" space.

    # Using a score that is negative of remaining_after_fit for fitting bins.
    # The smaller the remaining_after_fit (closer to 0), the larger (less negative) the priority.
    # We will flip this to get higher scores for better bins.

    # Let's use the reciprocal of (remaining_after_fit + epsilon) for bins that fit.
    # This makes smaller remaining capacities yield higher scores.
    # Adding a small epsilon to avoid division by zero for perfect fits.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit[can_fit_mask] + epsilon)

    # For bins where the item doesn't fit, their priority remains 0.
    # If we want to explicitly disfavor them further, we could assign a negative value,
    # but 0 is sufficient as it will be lower than any positive priority.

    return priorities
```
