```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid strategy.

    This strategy combines the "Best Fit" approach (minimizing remaining capacity)
    with a stochastic element to encourage exploration of less obviously optimal bins.
    It also prioritizes bins that are "almost full" to potentially group smaller items
    more efficiently.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Determine which bins can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit, return all zeros

    fitting_bins_caps = bins_remain_cap[can_fit_mask]

    # Strategy 1: Best Fit - prioritize bins that will have the least remaining capacity
    # This is a common greedy strategy for BPP.
    remaining_after_fit = fitting_bins_caps - item
    # We want to minimize remaining_after_fit, so higher priority for smaller remaining capacity.
    # Add a small constant to avoid division by zero if remaining_after_fit is 0.
    best_fit_scores = 1.0 / (1.0 + remaining_after_fit)

    # Strategy 2: "Almost Full" bins - prioritize bins that are very close to being full
    # This can help consolidate smaller items and leave larger capacities open.
    # We define "almost full" as having a remaining capacity between 0 and a small threshold.
    almost_full_threshold = 0.1 * np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 0.1
    almost_full_mask_subset = (fitting_bins_caps > 0) & (fitting_bins_caps <= almost_full_threshold)
    almost_full_scores = np.zeros_like(fitting_bins_caps)
    almost_full_scores[almost_full_mask_subset] = 0.5 # Assign a moderate priority

    # Strategy 3: Exploration - add a small random component to encourage trying different bins
    # This is inspired by exploration in reinforcement learning.
    exploration_factor = 0.1
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor

    # Combine scores. A bin is good if it's a good best-fit OR it's almost full.
    # We use a weighted sum, prioritizing best fit more.
    combined_scores = (0.7 * best_fit_scores) + (0.3 * almost_full_scores) + random_scores

    # Assign the calculated scores to the corresponding bins
    priorities[can_fit_mask] = combined_scores

    # Ensure bins that cannot fit have a priority of 0
    priorities[~can_fit_mask] = 0

    return priorities
```
