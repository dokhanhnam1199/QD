```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit heuristic approach.

    This strategy prioritizes bins that can accommodate the item and, after placing the item,
    leave the minimal possible remaining capacity in the bin. This aims to achieve a "tight fit".

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a more preferred bin.
    """
    # Initialize priorities to zero.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that have enough remaining capacity to fit the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros. The caller will handle creating a new bin.
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity *after* placing the item in the bins that can fit it.
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # To prioritize bins with minimal leftover capacity (best fit), we want to assign
    # higher scores to bins where `remaining_after_placement` is smaller.
    # A common way to achieve this is to use the inverse of the remaining capacity.
    # A small epsilon is added to avoid division by zero if an item perfectly fills a bin.
    epsilon = 1e-9
    priorities[can_fit_mask] = 1.0 / (remaining_after_placement + epsilon)

    return priorities
```
