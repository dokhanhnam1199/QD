```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a refined priority function for the online Bin Packing Problem (BPP).
    This version focuses on a clear hierarchy: perfect fits first, then bins
    that leave minimal remaining capacity (tight fits), followed by general
    best-fit strategy, with an added component for exploring less-filled bins
    to potentially improve future packing.

    Scoring Logic:
    1. Perfect Fit: remaining capacity is zero (within epsilon). Highest priority.
    2. Tight Fit: remaining capacity is positive but less than the item size.
       Priority is inversely proportional to the remaining space.
    3. Loose Fit: remaining capacity is greater than or equal to the item size.
       Priority is inversely proportional to the remaining space, but with a
       lower base value than tight fits.
    4. Exploration Component: A small, scaled random value is added to all
       eligible bins to encourage exploration of less-filled bins.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of priority scores for each bin. Higher score means higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_indices = np.where(can_fit_mask)[0]
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    epsilon = 1e-9  # For numerical stability and checking perfect fits

    # Initialize scores for the fitting bins
    scores = np.zeros_like(remaining_after_fit)

    # --- Define score components for different fit types ---

    # 1. Perfect Fit: Assign a very high, distinct score.
    perfect_fit_mask = (remaining_after_fit < epsilon)
    scores[perfect_fit_mask] = 1e6

    # 2. Tight Fit: remaining_after_fit is positive but small relative to item.
    #    Let's define "tight" as remaining space < item * 0.5 (half the item size).
    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit < item * 0.5)
    # Score inversely proportional to remaining space. Add epsilon to avoid division by zero.
    scores[tight_fit_mask] = 100.0 / (remaining_after_fit[tight_fit_mask] + epsilon)

    # 3. Loose Fit: remaining_after_fit >= item * 0.5
    loose_fit_mask = (remaining_after_fit >= item * 0.5)
    # Score inversely proportional to remaining space, but with a lower base magnitude.
    scores[loose_fit_mask] = 50.0 / (remaining_after_fit[loose_fit_mask] + epsilon)

    # --- Add Exploration Component ---
    # A small random value to encourage exploration.
    # Scale it based on the typical range of scores to maintain relative priorities.
    # Find a reference score magnitude (e.g., max score from non-perfect fits).
    non_perfect_scores = scores[~perfect_fit_mask]
    max_non_perfect_score = np.max(non_perfect_scores) if np.any(non_perfect_scores) else 50.0 # Default if only perfect fits exist

    # Exploration factor: small percentage of the max non-perfect score
    exploration_factor = 0.1
    random_jitter = np.random.uniform(0, exploration_factor * max_non_perfect_score, size=scores.shape)

    # Add jitter, ensuring it doesn't reduce the priority of perfect fits significantly
    # and is applied only to non-perfect fits to keep perfect fits dominant.
    scores[~perfect_fit_mask] += random_jitter[~perfect_fit_mask]

    # Ensure scores are non-negative
    scores[scores < 0] = 0

    # Assign calculated scores back to the original priority array
    priorities[fitting_bins_indices] = scores

    return priorities
```
