```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an improved hybrid strategy.

    This strategy prioritizes bins that offer a tight fit (minimizing leftover capacity)
    while also considering bins that leave a moderate amount of space for future, potentially
    larger items. It aims to balance exploiting near-perfect fits with exploring options that
    maintain flexibility. A bias is introduced to favor bins that are not nearly full to
    encourage a more even distribution of items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the current item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]

    # Strategy 1: Tight Fit (Best Fit)
    # Calculate the capacity remaining *after* placing the item. We want to minimize this.
    remaining_after_fit = fitting_bins_caps - item
    # Score: Higher score for smaller remaining_after_fit. Add epsilon for stability.
    best_fit_score = 1.0 / (1.0 + remaining_after_fit + 1e-9)

    # Strategy 2: Moderate Space Preference
    # This strategy aims to favor bins that leave a "useful" amount of space,
    # not too little (already covered by best_fit_score) and not too much.
    # A common heuristic is to prefer bins that were already somewhat full,
    # as filling them further is more efficient than filling nearly empty bins.
    # We'll use a score that rewards bins that have more capacity initially,
    # scaled by the overall maximum capacity to normalize.
    # This encourages using bins that are already partially filled.
    max_cap_overall = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0
    # Score increases with initial bin capacity, encouraging use of less empty bins.
    space_preference_score = fitting_bins_caps / max_cap_overall

    # Combine strategies using a weighted sum.
    # Prioritize tight fits (best_fit_score) with a secondary preference
    # for bins that are not nearly empty (space_preference_score).
    # The weight (0.3 here) balances these two objectives. A higher weight
    # means more emphasis on leaving space/using less full bins.
    weight_space_preference = 0.3
    combined_score_subset = best_fit_score + weight_space_preference * space_preference_score

    # Assign the calculated scores to the corresponding bins
    priorities[can_fit_mask] = combined_score_subset

    # Ensure bins that cannot fit have a priority of 0
    priorities[~can_fit_mask] = 0

    return priorities
```
