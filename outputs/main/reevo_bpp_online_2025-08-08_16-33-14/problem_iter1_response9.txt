```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Softmax-Based Fit strategy.

    The priority is higher for bins that have remaining capacity greater than or equal to the item size,
    and among those, it's higher for bins with less remaining capacity (to promote filling bins).
    Softmax is applied to these scores to get a probability distribution over the bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize scores to a very small negative number to ensure unfit bins get low softmax scores
    scores = np.full_like(bins_remain_cap, -np.inf)

    # Consider only bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign a score inversely proportional to remaining capacity
    # This favors bins that are closer to being full, promoting tighter packing.
    # We add a small epsilon to avoid division by zero if a bin has exactly the item's size.
    scores[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)

    # Apply softmax to convert scores into probabilities (priorities)
    # Subtract the maximum score before exponentiation to prevent numerical overflow
    exp_scores = np.exp(scores - np.max(scores))
    priorities = exp_scores / np.sum(exp_scores)

    # Handle cases where no bin can fit the item (e.g., if the item is too large for all bins)
    # In such a scenario, exp_scores would be all zeros, leading to NaNs from division by zero sum.
    # We can assign a uniform low priority or signal this condition, but for this function,
    # returning zeros is a reasonable default indicating no good placement.
    if np.sum(priorities) == 0:
        return np.zeros_like(bins_remain_cap)

    return priorities
```
