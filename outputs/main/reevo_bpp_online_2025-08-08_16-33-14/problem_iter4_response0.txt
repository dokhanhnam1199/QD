```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined hybrid strategy.

    This strategy refines the 'Best Fit' and 'Almost Full' criteria.
    It prioritizes bins that have a remaining capacity closest to the item size (Best Fit).
    It also favors bins that are "tightly packed" after the item is placed, meaning
    the remaining capacity is small. A small additive factor is used to provide
    higher priority to bins that become exactly full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        # If no bin can fit, return scores that reflect no valid placement
        return scores

    fitting_bins_caps = bins_remain_cap[can_fit_mask]

    # Criterion 1: Best Fit - prioritize bins that will have the least remaining capacity
    # after the item is placed. This means minimizing (bins_remain_cap - item).
    # Higher score for smaller (bins_remain_cap - item).
    # To ensure bins that become exactly full (remaining capacity = 0) get the highest
    # priority among fitting bins, we can use a score that is the negative of the
    # remaining capacity after fitting.
    # Score = -(remaining_capacity_after_fit)
    # This naturally gives 0 for exact fits, and negative scores for bins with residual space.
    remaining_after_fit = fitting_bins_caps - item
    best_fit_priority = -remaining_after_fit

    # Criterion 2: Tight Packing - Prioritize bins that are already quite full,
    # such that placing the item makes them *even more* tightly packed.
    # This can be thought of as favoring bins where the current remaining capacity
    # is only slightly larger than the item size.
    # A simpler interpretation aligning with "closeness to full" after fit:
    # We already captured this with Best Fit.
    # Let's refine: prioritize bins that, after placing the item, leave very little space.
    # The `best_fit_priority` already does this.

    # Let's introduce a small bonus for exact fits to ensure they are strongly preferred.
    # If remaining_after_fit is 0, the best_fit_priority is 0.
    # We can add a small epsilon to it for exact fits.
    # A small epsilon added to the "best fit" score for exact fits.
    # This ensures exact fits are slightly preferred over bins that leave a tiny bit of space.
    epsilon_for_exact_fit = 1e-6
    tight_packing_priority = best_fit_priority + (best_fit_priority == 0) * epsilon_for_exact_fit

    # Combine criteria: Primarily Best Fit, with a slight boost for exact fits.
    # Since `best_fit_priority` already sorts correctly (higher for smaller remaining),
    # and exact fits have the highest score (0), the `tight_packing_priority`
    # directly reflects the desired ordering.

    # Assign the computed priorities to the fitting bins
    scores[can_fit_mask] = tight_packing_priority

    # Non-fitting bins remain at -np.inf, ensuring they are never chosen if a fit exists.

    return scores
```
