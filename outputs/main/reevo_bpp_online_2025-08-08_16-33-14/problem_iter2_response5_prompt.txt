{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a First Fit Decreasing-like strategy.\n\n    This heuristic prioritizes bins that can fit the item and, among those,\n    prioritizes bins that will have the least remaining capacity *after*\n    placing the item. This aims to pack items tightly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate the remaining capacity after placement.\n    # We want to prioritize bins where placing the item leaves the LEAST remaining capacity.\n    # This is equivalent to prioritizing bins with smaller remaining capacity *after* placement.\n    # A higher score means higher priority. So, we can use the negative of the\n    # remaining capacity, or some transformation of it.\n    # Let's assign a score based on how \"tightly\" it fits. A tighter fit (less remaining capacity)\n    # should have a higher priority.\n    # So, we can use: -(remaining_capacity - item_size).\n    # This means if a bin has remaining capacity of 10 and item is 3, remaining is 7. Score is -7.\n    # If a bin has remaining capacity of 5 and item is 3, remaining is 2. Score is -2.\n    # -2 is greater than -7, so the bin with remaining capacity 5 is preferred.\n    # However, we only want to consider bins that *can* fit the item.\n    # For bins that cannot fit, the priority remains 0.\n\n    # Calculate the remaining capacity for bins that can fit the item\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize tighter fits, we want smaller remaining_after_placement values to have higher scores.\n    # So, we can use negative of remaining_after_placement.\n    # However, simply assigning -(remaining_after_placement) might lead to issues if all values are negative or very large.\n    # A common approach for \"best fit\" (which this is similar to) is to prioritize by\n    # the size of the remaining capacity. The smaller the remaining capacity, the better.\n    # So, if we have `bins_remain_cap` and `item`, we are looking for the smallest\n    # `bins_remain_cap[i] - item` where `bins_remain_cap[i] >= item`.\n    # This smallest difference corresponds to the \"best fit\".\n    # We can assign priority as 1 / (remaining_after_placement + epsilon) for a higher value for smaller remaining.\n    # Or, a simpler way: we want to maximize (bin_remain_cap - item). This is not quite right.\n    # We want to minimize (bin_remain_cap - item).\n    # So, if we assign priority as `- (bin_remain_cap[i] - item)`, a smaller positive difference\n    # leads to a larger negative number, which is what we want to avoid.\n    #\n    # Let's reconsider: First Fit means iterate through bins and pick the first one that fits.\n    # This is not exactly First Fit, but more of a \"Best Fit\" like approach in terms of prioritization.\n    # The prompt implies a priority score for *each* bin, then picking the highest.\n    # For a First Fit strategy, the priority would be based on the *order* of the bins, not their capacity.\n    # The prompt asks for a priority function that returns scores for *each* bin.\n    #\n    # Let's reinterpret \"First Fit strategy\" in the context of assigning priorities.\n    # Perhaps it means: if a bin *can* fit the item, it gets a high priority.\n    # If multiple bins can fit, how do we prioritize? The \"First Fit\" aspect might imply\n    # prioritizing bins that have been open longer or are earlier in the list.\n    #\n    # Let's try to combine First Fit and capacity.\n    # First Fit often implies using the earliest available bin that fits.\n    # In an online scenario where we are given `bins_remain_cap`, it implies the order matters.\n    # So, a bin earlier in the array that fits is generally preferred.\n    # However, the question asks for a \"priority score\" for *each* bin.\n    #\n    # Let's consider a \"Best Fit\" approach disguised as a priority function for a \"First Fit strategy\":\n    # The idea is to make the \"best fitting\" bins have a higher priority.\n    # \"Best fitting\" means minimizing `bins_remain_cap[i] - item`.\n    #\n    # So, if `bins_remain_cap[i] >= item`:\n    # Priority_i = a value that is higher for smaller `bins_remain_cap[i] - item`.\n    # Let's assign priority as `1 / (bins_remain_cap[i] - item + 1e-9)` to avoid division by zero\n    # and give higher priority to smaller remaining capacities.\n    # Bins that cannot fit get 0 priority.\n\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit) strategy.\n\n    The Inverse Distance (Proximity Fit) strategy prioritizes bins that are\n    \"close\" to fitting the current item. A bin is considered a good fit if its\n    remaining capacity is just slightly larger than the item's size. This\n    minimizes wasted space in the bin.\n\n    The priority is calculated as: 1 / (1 + |remaining_capacity - item_size|).\n    This formula gives higher priority to bins where the difference between\n    remaining capacity and item size is smaller (closer to zero).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and each bin's remaining capacity.\n    # We only consider bins where the item can actually fit.\n    fit_mask = bins_remain_cap >= item\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate priorities. Add a small epsilon to the denominator to avoid division by zero\n    # if a bin has exactly the same remaining capacity as the item.\n    # The \"+ 1\" in the denominator ensures that the priority is always less than or equal to 1.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[fit_mask] = 1.0 / (1.0 + diff[fit_mask])\n\n    return priorities\n\n[Reflection]\nPrioritize bins with minimal remaining capacity after packing. Inverse distance offers better proximity.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}