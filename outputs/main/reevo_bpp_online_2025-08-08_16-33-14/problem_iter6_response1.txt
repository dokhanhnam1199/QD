```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved hybrid priority function for online Bin Packing Problem (BPP).
    This version strictly prioritizes perfect fits, then tight fits (remaining capacity
    close to the item size), and then "best fit" style remaining capacity, while
    still allowing for exploration.

    Scoring Logic:
    1. Perfect Fit: remaining capacity is zero. Highest priority.
    2. Tight Fit: remaining capacity is positive but less than or equal to the item size.
       Higher priority than other fits, scaled inversely with remaining space.
    3. Best Fit (remaining): remaining capacity is greater than the item size.
       Priority decreases as remaining capacity increases.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define score components
    epsilon = 1e-9  # For handling perfect fits and avoiding division by zero

    # Initialize scores for different fit categories
    perfect_fit_scores = np.zeros_like(remaining_after_fit)
    tight_fit_scores = np.zeros_like(remaining_after_fit)
    best_fit_scores = np.zeros_like(remaining_after_fit)

    # 1. Perfect Fit: Highest priority.
    perfect_mask = (remaining_after_fit < epsilon)
    perfect_fit_scores[perfect_mask] = 100.0  # High fixed score for perfect fits

    # 2. Tight Fit: Prioritize bins that leave little room after packing,
    #    specifically when remaining capacity is <= item size.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= item)
    # Score decreases as remaining_after_fit increases within the tight range.
    # Use inverse relationship: 1 / (1 + remaining_space). A larger remaining space means lower score.
    # Adding a small constant to the denominator to avoid issues if remaining_after_fit is very close to 0.
    tight_fit_scores[tight_mask] = 10.0 / (1.0 + remaining_after_fit[tight_mask])

    # 3. Best Fit (remaining): For bins where remaining capacity is > item size.
    #    Priority decreases as remaining capacity increases.
    best_fit_mask = (remaining_after_fit > item)
    # Use a decaying function. (1 / (1 + remaining_space)).
    # This gives higher scores to bins with less remaining space among this category.
    best_fit_scores[best_fit_mask] = 5.0 / (1.0 + remaining_after_fit[best_fit_mask])

    # Combine scores using weights to reflect the priority order: Perfect > Tight > Best Fit
    combined_scores = (
        perfect_fit_scores * 1.0 +  # Max weight for perfect fits
        tight_fit_scores * 0.7 +    # Significant weight for tight fits
        best_fit_scores * 0.3       # Lower weight for general best fits
    )

    # Add a small random component for exploration to all fitting bins
    # This helps in breaking ties and exploring less obvious choices occasionally.
    exploration_factor = 0.05
    # Scale random score by the maximum possible score to maintain relative priorities.
    max_possible_score = 100.0 + (10.0 / (1.0 + epsilon)) * 0.7 + (5.0 / (1.0 + item)) * 0.3
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor * max_possible_score
    combined_scores += random_scores

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = combined_scores

    return priorities
```
