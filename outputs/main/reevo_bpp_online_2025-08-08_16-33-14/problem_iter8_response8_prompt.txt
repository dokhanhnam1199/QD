{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements a refined priority function for online Bin Packing Problem,\n    prioritizing exact fits, then tighter fits, and penalizing overly large\n    remaining capacities. Includes a small random component for exploration.\n\n    Scoring logic:\n    1. Exact Fit: Highest priority (e.g., score of 1.0).\n    2. Tight Fit: Prioritize bins leaving minimal remaining capacity (e.g., inverse of remaining capacity).\n    3. Moderate Fit: Prioritize bins leaving some space, but less than loose fits.\n    4. Loose Fit: Lowest priority, but still assign a small positive score.\n    5. Exploration: Add a small random value to break ties and encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components based on remaining capacity after fit.\n    epsilon = 1e-9\n\n    # 1. Exact Fit: Highest priority\n    # Bins where remaining capacity is practically zero after fitting the item.\n    exact_fit_mask = (remaining_after_fit < epsilon)\n    priorities[can_fit_mask][exact_fit_mask] = 1.0\n\n    # 2. Tight Fit: Prioritize bins leaving minimal remaining capacity\n    # Remaining capacity is small but positive. Score is inversely proportional to remaining capacity.\n    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item * 0.5) # Threshold for \"tight\"\n    # Use a scaled inverse to give higher scores to smaller remaining capacities.\n    # Add a small constant to the denominator to avoid division by zero and to\n    # differentiate scores for very small remaining capacities.\n    priorities[can_fit_mask][tight_fit_mask] = 0.8 / (remaining_after_fit[tight_fit_mask] + epsilon)\n\n    # 3. Moderate Fit: Prioritize bins leaving some space, but not excessive.\n    # Remaining capacity is larger than tight fit threshold.\n    moderate_fit_mask = (remaining_after_fit > item * 0.5) & (remaining_after_fit <= item * 2.0) # Threshold for \"moderate\"\n    # Lower scores than tight fits, still inversely related to remaining capacity.\n    priorities[can_fit_mask][moderate_fit_mask] = 0.4 / (remaining_after_fit[moderate_fit_mask] + epsilon)\n\n    # 4. Loose Fit: Lowest priority, but still assign a small positive score.\n    # Remaining capacity is significantly larger than the item.\n    loose_fit_mask = (remaining_after_fit > item * 2.0)\n    # Assign a small constant score to encourage exploration of these bins if others are not ideal.\n    priorities[can_fit_mask][loose_fit_mask] = 0.1\n\n    # 5. Exploration: Add a small random component to break ties and encourage exploration.\n    exploration_factor = 0.05 # Reduced exploration factor\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor\n    priorities[can_fit_mask] += random_scores\n\n    # Ensure no score exceeds the highest priority (e.g., 1.0 plus random)\n    priorities[can_fit_mask] = np.minimum(priorities[can_fit_mask], 1.0 + exploration_factor)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a refined strategy.\n\n    This strategy prioritizes bins that are a \"good fit\" for the item,\n    meaning the remaining capacity after placing the item is small but not\n    excessively so (to avoid over-packing). It also gives a slight bonus\n    for bins that become exactly full.\n\n    The priority is calculated as:\n    1. For bins that can fit the item:\n       - Calculate `remaining_after_fit = bins_remain_cap - item`.\n       - If `remaining_after_fit` is very close to zero (perfect fit), assign a high score.\n       - If `remaining_after_fit` is small but positive (tight fit), assign a high score,\n         inversely proportional to `remaining_after_fit`.\n       - If `remaining_after_fit` is larger, assign a lower score.\n       - Penalize bins that become *too* full after placing the item, e.g.,\n         if `remaining_after_fit` is negative (which shouldn't happen if `can_fit_mask` is correct,\n         but as a conceptual extension).\n\n    A scoring function is designed to favor smaller `remaining_after_fit`,\n    with a special high score for `remaining_after_fit` close to zero,\n    and a decay for larger `remaining_after_fit`.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    epsilon = 1e-9  # For handling near-zero remaining capacities\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        # If no bin can fit, return scores that reflect no valid placement\n        return scores\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Priority Calculation:\n    # We want higher scores for smaller remaining_after_fit.\n    # Exact fits (remaining_after_fit near 0) should have the highest priority.\n    # Tight fits (small positive remaining_after_fit) should be next.\n    # Loose fits (larger remaining_after_fit) should have lower priority.\n\n    # Strategy: Use a score that is inversely proportional to (remaining_after_fit + epsilon)\n    # to favor smaller values. Add a bonus for exact fits.\n    # Let's use `1.0 / (remaining_after_fit + epsilon)` as a base.\n    # For exact fits (remaining_after_fit near 0), this value will be large.\n    # For tight fits, it will be slightly smaller.\n    # For loose fits, it will be much smaller.\n\n    # A potential issue: very small remaining_after_fit could lead to huge scores.\n    # We can cap the score or use a function that saturates.\n    # Alternatively, we can define categories.\n\n    # Let's try a tiered approach:\n    # 1. Perfect/Exact Fit: remaining_after_fit < epsilon\n    # 2. Tight Fit: epsilon <= remaining_after_fit <= item_size * tightness_factor\n    # 3. Good Fit: item_size * tightness_factor < remaining_after_fit <= item_size * good_factor\n    # 4. Loose Fit: remaining_after_fit > item_size * good_factor\n\n    # Scoring:\n    # Perfect Fit: Highest score (e.g., 100)\n    # Tight Fit: High score, inversely proportional to remaining_after_fit. Add a small penalty for being *too* tight.\n    # Good Fit: Medium score, inversely proportional to remaining_after_fit.\n    # Loose Fit: Low score.\n\n    # Defining factors for categorization\n    tightness_factor = 1.5  # Bins remaining capacity up to 1.5 * item size are considered \"tight\"\n    good_fit_factor = 3.0   # Bins remaining capacity up to 3.0 * item size are considered \"good\"\n\n    # Calculate base score for all fitting bins: inverse of remaining capacity + epsilon\n    # This favors smaller remaining capacity.\n    # Adding `epsilon` to avoid division by zero and ensure even zero remaining gets a score.\n    base_scores = 1.0 / (remaining_after_fit + epsilon)\n\n    # Adjust scores based on categories:\n    # Perfect fits get a significant bonus.\n    # Tight fits get a good score.\n    # Good fits get a moderate score.\n    # Loose fits get a low score.\n\n    # Create score adjustments for each category\n    perfect_fit_mask = (remaining_after_fit < epsilon)\n    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= tightness_factor * item)\n    good_fit_mask = (remaining_after_fit > tightness_factor * item) & (remaining_after_fit <= good_fit_factor * item)\n    loose_fit_mask = (remaining_after_fit > good_fit_factor * item)\n\n    # Assign base scores and then modify for category\n    category_scores = np.zeros_like(remaining_after_fit)\n\n    # Perfect Fit: Highest priority\n    category_scores[perfect_fit_mask] = 100.0\n    # Add the base score here to give some preference within perfect fits if epsilon is not exactly 0\n    category_scores[perfect_fit_mask] += base_scores[perfect_fit_mask]\n\n    # Tight Fit: Prioritize, but scale down from perfect.\n    # Use base score and scale it. A factor of 0.7 for example.\n    category_scores[tight_fit_mask] = base_scores[tight_fit_mask] * 0.8\n\n    # Good Fit: Lower priority than tight.\n    category_scores[good_fit_mask] = base_scores[good_fit_mask] * 0.4\n\n    # Loose Fit: Lowest priority.\n    category_scores[loose_fit_mask] = base_scores[loose_fit_mask] * 0.1\n\n    # Ensure perfect fits remain dominant, even if base_scores are low for other categories.\n    # If remaining_after_fit is very small, base_scores can be very large.\n    # We need to ensure that smaller *positive* remaining_after_fit is better.\n    # The current `base_scores = 1.0 / (remaining_after_fit + epsilon)` already does this.\n\n    # Let's refine the scoring for tight and good fits to be more directly based on remaining capacity.\n    # We want smaller remaining_after_fit to be better.\n    # For tight fits: Priority = C1 - C2 * remaining_after_fit\n    # For good fits: Priority = C3 - C4 * remaining_after_fit (with C3, C4 smaller than C1, C2)\n\n    # Let's use a simple piecewise scoring:\n    final_fitting_scores = np.zeros_like(remaining_after_fit)\n\n    # Perfect Fit: Very high score for bins that leave almost no space.\n    perfect_fit_bonus = 1000.0\n    final_fitting_scores[perfect_fit_mask] = perfect_fit_bonus + (epsilon - remaining_after_fit[perfect_fit_mask])\n\n    # Tight Fit: Prefer smaller remaining capacity. A linear decay from a high value.\n    # Let's set a maximum score for tight fits and linearly decrease it.\n    max_tight_score = 500.0\n    # Scale remaining_after_fit relative to item size for linear decay.\n    # The slope determines how quickly priority drops.\n    # We want priority to be high when remaining_after_fit is small, and lower as it approaches tightness_factor * item.\n    slope_tight = (max_tight_score - 50.0) / (tightness_factor * item + epsilon) # Ensure slope is reasonable\n    final_fitting_scores[tight_fit_mask] = max_tight_score - slope_tight * remaining_after_fit[tight_fit_mask]\n\n    # Good Fit: Similar logic but with lower scores and potentially shallower slope.\n    max_good_score = 100.0\n    slope_good = (max_good_score - 10.0) / (good_fit_factor * item - tightness_factor * item + epsilon)\n    final_fitting_scores[good_fit_mask] = max_good_score - slope_good * remaining_after_fit[good_fit_mask]\n\n    # Loose Fit: Very low score, possibly just a small constant.\n    final_fitting_scores[loose_fit_mask] = 10.0 - (remaining_after_fit[loose_fit_mask] / (item + epsilon)) * 5.0 # Penalize larger remaining\n\n    # Clip scores to be non-negative and ensure they don't go below a minimum.\n    final_fitting_scores = np.maximum(final_fitting_scores, 0.1) # Ensure some minimal priority\n\n    # Assign the computed priorities to the fitting bins\n    scores[can_fit_mask] = final_fitting_scores\n\n    return scores\n\n[Reflection]\nPrioritize exact fits, then tight fits. Penalize excessive remaining capacity. Balance exploration and exploitation.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}