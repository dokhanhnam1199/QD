{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for packing an item into bins, prioritizing tight fits.\n\n    This heuristic prioritizes bins that can accommodate the item. Among those,\n    it assigns a higher priority to bins that will have the least remaining\n    capacity after packing (i.e., a tighter fit). Bins that are too small\n    for the item receive a priority of 0.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.\n\n    Returns:\n        A NumPy array of the same size as bins_remain_cap, where each element\n        is the priority score for placing the item in the corresponding bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that have enough remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return all zeros.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # For bins that can fit the item, calculate the remaining capacity *after* packing.\n    # The goal is to minimize this remaining capacity for a tighter fit.\n    remaining_after_packing = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize tighter fits (smaller remaining_after_packing), we can use\n    # the negative of the remaining capacity. Since priority functions typically\n    # aim to maximize the score, we can transform this. A common strategy is to\n    # use a large value minus the remaining capacity, ensuring that smaller\n    # remaining capacities yield higher scores. Using the maximum available\n    # capacity as the large constant helps normalize scores relative to bin sizes.\n    # The `bins_remain_cap[can_fit_mask].max()` is used to ensure that even\n    # with the subtraction, the priority remains positive and is scaled by\n    # the general magnitude of bin capacities.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask].max() - remaining_after_packing\n\n    # Add a strong preference for bins that result in exactly zero remaining capacity\n    # (perfect fits). This can be achieved by adding a very large constant to these.\n    exact_fit_mask = (remaining_after_packing == 0)\n    if np.any(exact_fit_mask):\n        # A large epsilon to ensure exact fits are always preferred over near-fits.\n        priorities[can_fit_mask][exact_fit_mask] += 1e9\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements a hybrid priority function for online Bin Packing Problem.\n    This version refines the scoring by categorizing fits:\n    1. Perfect Fit (zero remaining capacity).\n    2. Tight Fit (remaining capacity <= item size).\n    3. Good Fit (remaining capacity > item size but not excessively large).\n    4. Loose Fit (remaining capacity is very large).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components based on remaining capacity after fit\n    # We want to prioritize smaller remaining_after_fit.\n    # Add a small epsilon to avoid division by zero for perfect fits.\n    epsilon = 1e-9\n\n    # Scores for different fit categories\n    perfect_fit_scores = np.zeros_like(remaining_after_fit)\n    tight_fit_scores = np.zeros_like(remaining_after_fit)\n    good_fit_scores = np.zeros_like(remaining_after_fit)\n    loose_fit_scores = np.zeros_like(remaining_after_fit)\n\n    # Thresholds for 'good fit' and 'loose fit'\n    # Threshold 1: Maximum remaining capacity for a 'tight' fit (relative to item size)\n    tight_threshold = item\n    # Threshold 2: Maximum remaining capacity for a 'good' fit (relative to item size)\n    # This aims to leave a decent amount of space, e.g., up to 3 times the item size.\n    good_threshold = 3.0 * item\n\n    # Assign scores based on categories\n    # Perfect Fit: highest priority\n    perfect_mask = (remaining_after_fit < epsilon)\n    perfect_fit_scores[perfect_mask] = 10.0\n\n    # Tight Fit: prioritize bins that leave little room but not zero\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_threshold)\n    tight_fit_scores[tight_mask] = 5.0 / (1.0 + remaining_after_fit[tight_mask]) # Scaled best-fit\n\n    # Good Fit: prioritize bins that leave a moderate amount of room\n    # This encourages leaving space for future items.\n    good_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= good_threshold)\n    # For good fits, we want remaining_after_fit to be as small as possible within this range.\n    # We can use a inverse relationship, but scaled differently.\n    good_fit_scores[good_mask] = 2.0 / (1.0 + remaining_after_fit[good_mask])\n\n    # Loose Fit: lowest priority among fitting bins, provide minimal boost for exploration\n    loose_mask = (remaining_after_fit > good_threshold)\n    loose_fit_scores[loose_mask] = 0.5 / (1.0 + remaining_after_fit[loose_mask])\n\n    # Combine scores. Weights are heuristic and can be tuned.\n    # Prioritize perfect > tight > good > loose.\n    combined_scores = (\n        perfect_fit_scores * 1.0 +\n        tight_fit_scores * 0.8 +\n        good_fit_scores * 0.5 +\n        loose_fit_scores * 0.2\n    )\n\n    # Add a small random component for exploration to all fitting bins\n    exploration_factor = 0.1\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor\n    combined_scores += random_scores\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities\n\n[Reflection]\nExperiment with score functions, thresholds, and explore randomization for better bin packing heuristics.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}