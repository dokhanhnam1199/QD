```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a refined priority function for online Bin Packing Problem,
    prioritizing exact fits, then tighter fits, and penalizing overly large
    remaining capacities. Includes a small random component for exploration.

    Scoring logic:
    1. Exact Fit: Highest priority (large positive score).
    2. Tight Fit: Prioritize bins leaving minimal remaining capacity (decreasing positive score).
    3. Moderate Fit: Prioritize bins leaving some space, but less than loose fits (lower positive score).
    4. Loose Fit: Lowest priority, but still assign a small positive score.
    5. Exploration: Add a small random component to break ties and encourage exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    epsilon = 1e-9  # For handling near-zero remaining capacities

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return scores  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define scoring tiers and parameters
    perfect_fit_threshold = epsilon
    tight_fit_threshold = item * 1.5  # Bins where remaining is up to 1.5 * item size
    moderate_fit_threshold = item * 3.0 # Bins where remaining is up to 3.0 * item size

    # Base scores for different tiers
    perfect_fit_score = 1000.0
    tight_fit_base_score = 500.0
    moderate_fit_base_score = 100.0
    loose_fit_base_score = 10.0

    # Calculate priority for fitting bins
    fitting_scores = np.zeros_like(remaining_after_fit)

    # 1. Exact Fit
    exact_fit_mask = (remaining_after_fit < perfect_fit_threshold)
    fitting_scores[exact_fit_mask] = perfect_fit_score + (perfect_fit_threshold - remaining_after_fit[exact_fit_mask])

    # 2. Tight Fit
    tight_fit_mask = (remaining_after_fit >= perfect_fit_threshold) & (remaining_after_fit <= tight_fit_threshold)
    # Linear decrease in score with increasing remaining capacity within this range
    # The slope should ensure that as remaining_after_fit approaches tight_fit_threshold, the score approaches a lower value.
    # Let's aim for a score of ~tight_fit_base_score/2 at the threshold.
    score_decay_tight = (tight_fit_base_score - loose_fit_base_score) / (tight_fit_threshold - perfect_fit_threshold + epsilon)
    fitting_scores[tight_fit_mask] = tight_fit_base_score - score_decay_tight * (remaining_after_fit[tight_fit_mask] - perfect_fit_threshold)

    # 3. Moderate Fit
    moderate_fit_mask = (remaining_after_fit > tight_fit_threshold) & (remaining_after_fit <= moderate_fit_threshold)
    score_decay_moderate = (moderate_fit_base_score - loose_fit_base_score) / (moderate_fit_threshold - tight_fit_threshold + epsilon)
    fitting_scores[moderate_fit_mask] = moderate_fit_base_score - score_decay_moderate * (remaining_after_fit[moderate_fit_mask] - tight_fit_threshold)

    # 4. Loose Fit
    loose_fit_mask = (remaining_after_fit > moderate_fit_threshold)
    # Score decreases linearly but at a slower rate, also penalizing very large remaining capacities.
    score_decay_loose = loose_fit_base_score / (item + epsilon) # A simple decay factor
    fitting_scores[loose_fit_mask] = loose_fit_base_score - score_decay_loose * (remaining_after_fit[loose_fit_mask] - moderate_fit_threshold)

    # Ensure scores are non-negative and have a minimum positive value
    fitting_scores = np.maximum(fitting_scores, 0.1)

    # 5. Exploration: Add a small random component
    exploration_factor = 0.05  # Small random noise to break ties
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor * (fitting_scores.max() - fitting_scores.min() + epsilon)
    fitting_scores += random_scores

    # Assign the computed priorities to the fitting bins
    scores[can_fit_mask] = fitting_scores

    return scores
```
