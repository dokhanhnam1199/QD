```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for online Bin Packing Problem.
    This version prioritizes tight fits by favoring bins that leave minimal
    remaining capacity, but introduces a penalty for bins that would be *too* full,
    meaning the remaining capacity is very close to zero. It categorizes fits
    to assign different levels of priority.

    Scoring logic:
    1. Perfect Fit (remaining capacity is effectively zero): High priority.
    2. Tight Fit (remaining capacity is small but positive): Moderate to high priority,
       inversely proportional to remaining capacity.
    3. Good Fit (remaining capacity is moderate): Lower priority, inversely proportional
       to remaining capacity.
    4. Loose Fit (remaining capacity is large): Lowest priority among fitting bins.

    A penalty is applied to 'tight' and 'perfect' fits if the remaining capacity
    is below a certain small threshold, discouraging over-packing that might
    make subsequent small items unplaceable.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define constants for scoring and penalty
    epsilon = 1e-6  # For considering near-zero remaining capacity
    # Threshold for applying the "too full" penalty.
    # This is a small absolute value, intended to avoid situations where
    # only a tiny sliver of space remains.
    too_full_threshold = 0.1 * item  # e.g., 10% of item size or a small absolute value

    # Calculate base scores favoring smaller remaining capacity
    # Use 1/(1+x) which is high for small x and decreases as x increases.
    # Add epsilon to denominator to prevent division by zero.
    base_scores = 1.0 / (1.0 + remaining_after_fit + epsilon)

    # Apply penalty for bins that become "too full" after packing
    # The penalty is higher when remaining_after_fit is smaller (closer to zero)
    # Penalize bins where remaining_after_fit < too_full_threshold
    penalty_scores = np.zeros_like(remaining_after_fit)
    too_full_mask = remaining_after_fit < too_full_threshold
    # The penalty should be proportional to how much below the threshold it is.
    # We scale it to ensure it can significantly reduce the priority.
    penalty_scores[too_full_mask] = (too_full_threshold - remaining_after_fit[too_full_mask]) / too_full_threshold
    
    # Combine base scores with penalties.
    # A higher base score (good fit) is reduced if the bin is too full.
    # We want to subtract the penalty. The multiplier (e.g., 0.8) controls the penalty strength.
    combined_scores = base_scores - (0.8 * penalty_scores)

    # Normalize scores to ensure they are non-negative and have a meaningful range.
    # Cap scores at 0 to avoid negative priorities.
    priorities[can_fit_mask] = np.maximum(0, combined_scores)

    # Further refinement: Add a small boost for bins that are "just right"
    # rather than perfectly full or very loose.
    # This is a more subtle adjustment than the penalty.
    # Let's define a target remaining capacity, e.g., a small fraction of the bin capacity
    # or a small absolute value.
    # For simplicity, let's use a similar logic as the penalty but as a boost.
    # Bins with remaining capacity slightly above zero (but not too full) might get a small boost.
    # A Gaussian-like function centered around a small positive value could work.
    # For this iteration, let's stick to the penalty on "too full" as the primary refinement.

    # Optionally, add a small random perturbation for exploration/tie-breaking
    exploration_noise = np.random.normal(0, 0.05, len(fitting_bins_caps))
    priorities[can_fit_mask] += exploration_noise
    # Ensure priorities remain non-negative after adding noise
    priorities[can_fit_mask] = np.maximum(0, priorities[can_fit_mask])


    # Ensure bins that cannot fit have a priority of 0 (already handled by initialization)
    # priorities[~can_fit_mask] = 0

    return priorities
```
