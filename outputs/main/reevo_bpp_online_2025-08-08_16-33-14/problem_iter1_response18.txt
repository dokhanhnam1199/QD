```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    This heuristic prioritizes bins that can fit the item, with a bias towards
    bins that would leave less remaining capacity (i.e., a tighter fit).
    A small epsilon probability is used to explore other bins that might not
    be the best immediate fit but could be beneficial in the long run.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.1  # Exploration probability
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, assign a priority based on the tightness of the fit.
    # A tighter fit (smaller remaining capacity after packing) gets a higher score.
    # We use the negative of the remaining capacity to achieve this.
    # Adding a small constant to avoid log(0) issues or negative infinity if capacity is exactly item size.
    # We invert this to make smaller remaining capacities (better fits) have higher priority.
    tight_fit_priority = - (bins_remain_cap[can_fit_mask] - item) + 1e-9
    priorities[can_fit_mask] = tight_fit_priority

    # Introduce exploration: with probability epsilon, all bins get an equal (low) priority.
    # This encourages trying bins that might not be the immediate best choice.
    num_bins = len(bins_remain_cap)
    explore_indices = np.random.choice(num_bins, size=int(num_bins * epsilon), replace=False)
    
    # Assign a baseline priority to all bins for exploration,
    # slightly lower than the "best" greedy choices to encourage exploration
    # without completely disregarding good fits.
    baseline_priority = np.min(tight_fit_priority) - 1 if np.any(can_fit_mask) else 0

    priorities[explore_indices] = baseline_priority

    return priorities
```
