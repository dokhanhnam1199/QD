[Prior reflection]
Prioritize perfect/tight fits. Quadratically reward snugness. Adapt thresholds and penalties to item/bin state. Tune scaling factors and decay. Balance exploration/exploitation for better bin packing.

[Code]
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an advanced priority function for the online Bin Packing Problem,
    incorporating quadratic rewards for snug fits, adaptive thresholds,
    and a more nuanced penalty for wasted space, along with a small
    exploration component.

    The priority is calculated as follows:
    1. Bins that cannot fit the item receive a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.
       b. Tight Fits (remaining capacity after packing is small and positive):
          Priority increases quadratically with how small the remaining capacity is.
          This strongly rewards snug fits.
       c. Good Fits (remaining capacity after packing is moderate): Priority
          decreases with remaining capacity, but with a gentler decay than tight fits.
       d. Wasteful Fits (remaining capacity after packing is large):
          Penalized, with the penalty increasing more sharply for larger
          amounts of wasted space relative to the item size.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    epsilon = 1e-9  # Tolerance for floating-point comparisons

    # Adaptive thresholds:
    # Tight fit: remaining capacity is less than a fraction of the item size.
    # This threshold scales with the item size.
    tight_fit_threshold = 0.5 * item
    # Wasteful fit: remaining capacity is more than twice the item size.
    wasteful_threshold = 2.0 * item

    scores = np.zeros_like(remaining_after_fit)

    # 1. Perfect Fits: Highest priority.
    perfect_mask = (remaining_after_fit < epsilon)
    scores[perfect_mask] = 100.0

    # 2. Tight Fits: Quadratically reward snugness.
    # Priority = Base + k * (1 - (remaining_capacity / tight_fit_threshold))^2
    # This rewards smaller remaining capacities more strongly.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)
    if np.any(tight_mask):
        # Normalize remaining capacity within the tight fit range
        normalized_remaining = remaining_after_fit[tight_mask] / tight_fit_threshold
        # Quadratic reward: higher for smaller normalized remaining capacity
        scores[tight_mask] = 70.0 * (1.0 - normalized_remaining)**2 + 10.0 # Base score of 10

    # 3. Good Fits: Priority decreases linearly with remaining capacity, with a decay factor.
    # These are bins that fit, but are not "tight" and not yet "wasteful".
    good_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)
    if np.any(good_mask):
        # Linear decay: higher priority for smaller remaining capacity
        # Scale factor for decay, making priority decrease slower than tight fits.
        decay_factor = 15.0
        scores[good_mask] = decay_factor * (1.0 - (remaining_after_fit[good_mask] / wasteful_threshold))

    # 4. Wasteful Fits: Penalized. The penalty increases with the excess space.
    # Penalty is inversely proportional to (excess_space / item_size + constant)
    wasteful_mask = (remaining_after_fit > wasteful_threshold)
    if np.any(wasteful_mask):
        # Penalty strength is adjusted to make larger gaps significantly worse.
        penalty_strength = 5.0
        scores[wasteful_mask] = 5.0 / (1.0 + penalty_strength * (remaining_after_fit[wasteful_mask] / item))

    # Ensure all calculated scores are non-negative.
    scores[scores < 0] = 0

    # Exploration component: Add small random jitter to break ties and encourage exploration.
    # The jitter is scaled to be a small fraction of the typical score range.
    exploration_jitter_scale = 0.05 # 5% of the max base score (100)
    jitter = np.random.uniform(-exploration_jitter_scale * 100.0, exploration_jitter_scale * 100.0, size=len(scores))
    final_scores = scores + jitter

    # Ensure jitter doesn't make scores negative.
    final_scores[final_scores < 0] = 0

    priorities[can_fit_mask] = final_scores

    return priorities
```
