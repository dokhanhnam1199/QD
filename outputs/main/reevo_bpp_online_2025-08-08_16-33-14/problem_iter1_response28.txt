```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Epsilon-Greedy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 0.2  # Exploration rate
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Determine which bins can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit, return all zeros (though in a real scenario, a new bin would be opened)
    if not np.any(can_fit_mask):
        return priorities

    # Greedy choice: favor bins with minimal remaining capacity after fitting the item
    # This is the "exploitation" part
    remaining_caps_after_fit = bins_remain_cap[can_fit_mask] - item
    # Assign a high priority to bins that leave less remaining capacity
    greedy_priorities = 1.0 / (1.0 + remaining_caps_after_fit)

    # Epsilon-Greedy: explore by assigning random priorities to some bins
    # The "exploration" part
    num_to_explore = max(1, int(epsilon * np.sum(can_fit_mask))) # Ensure at least one is explored if possible

    # Randomly select bins to explore
    explore_indices_in_subset = np.random.choice(
        np.arange(np.sum(can_fit_mask)),
        size=num_to_explore,
        replace=False
    )
    # Create random priorities for the explored bins
    random_priorities = np.random.rand(num_to_explore)

    # Combine greedy and random choices
    # Initially, all priorities for fitting bins are zero.
    # We'll assign greedy priorities first, then overwrite with random ones for exploration.
    priorities[can_fit_mask] = greedy_priorities

    # Replace greedy priorities with random priorities for the selected exploration bins
    original_indices_to_explore = np.where(can_fit_mask)[0][explore_indices_in_subset]
    priorities[original_indices_to_explore] = random_priorities

    # Ensure that bins that cannot fit the item have a priority of 0
    priorities[~can_fit_mask] = 0

    return priorities
```
