{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using an improved hybrid strategy.\n\n    This strategy prioritizes bins that offer a tight fit (minimizing leftover capacity)\n    while also considering bins that leave a moderate amount of space for future, potentially\n    larger items. It aims to balance exploiting near-perfect fits with exploring options that\n    maintain flexibility. A bias is introduced to favor bins that are not nearly full to\n    encourage a more even distribution of items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the current item\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n\n    # Strategy 1: Tight Fit (Best Fit)\n    # Calculate the capacity remaining *after* placing the item. We want to minimize this.\n    remaining_after_fit = fitting_bins_caps - item\n    # Score: Higher score for smaller remaining_after_fit. Add epsilon for stability.\n    best_fit_score = 1.0 / (1.0 + remaining_after_fit + 1e-9)\n\n    # Strategy 2: Moderate Space Preference\n    # This strategy aims to favor bins that leave a \"useful\" amount of space,\n    # not too little (already covered by best_fit_score) and not too much.\n    # A common heuristic is to prefer bins that were already somewhat full,\n    # as filling them further is more efficient than filling nearly empty bins.\n    # We'll use a score that rewards bins that have more capacity initially,\n    # scaled by the overall maximum capacity to normalize.\n    # This encourages using bins that are already partially filled.\n    max_cap_overall = np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1.0\n    # Score increases with initial bin capacity, encouraging use of less empty bins.\n    space_preference_score = fitting_bins_caps / max_cap_overall\n\n    # Combine strategies using a weighted sum.\n    # Prioritize tight fits (best_fit_score) with a secondary preference\n    # for bins that are not nearly empty (space_preference_score).\n    # The weight (0.3 here) balances these two objectives. A higher weight\n    # means more emphasis on leaving space/using less full bins.\n    weight_space_preference = 0.3\n    combined_score_subset = best_fit_score + weight_space_preference * space_preference_score\n\n    # Assign the calculated scores to the corresponding bins\n    priorities[can_fit_mask] = combined_score_subset\n\n    # Ensure bins that cannot fit have a priority of 0\n    priorities[~can_fit_mask] = 0\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements a refined priority function for online Bin Packing Problem,\n    incorporating a more nuanced scoring system based on fit tightness\n    and penalizing overly large remaining capacities.\n\n    Scoring logic:\n    1. Perfect Fit: Highest priority.\n    2. Tight Fit: Prioritize bins leaving minimal remaining capacity (but not zero).\n    3. Moderate Fit: Prioritize bins leaving some space but not excessive.\n    4. Loose Fit: Least priority, but still assign a small score to encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components based on remaining capacity after fit.\n    # A small epsilon to differentiate from true zero for perfect fits.\n    epsilon = 1e-9\n\n    # Thresholds for categorizing fits (relative to item size for better scaling)\n    # Bins with remaining_after_fit < epsilon are perfect fits.\n    # Bins with epsilon <= remaining_after_fit <= item are tight fits.\n    # Bins with item < remaining_after_fit <= 2*item are moderate fits.\n    # Bins with remaining_after_fit > 2*item are loose fits.\n\n    # Score for perfect fits (highest priority)\n    perfect_fit_score_val = 10.0\n    perfect_mask = (remaining_after_fit < epsilon)\n    priorities[can_fit_mask][perfect_mask] = perfect_fit_score_val\n\n    # Score for tight fits (prioritize smaller remaining capacity)\n    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item)\n    # Inverse relationship with remaining capacity, scaled to avoid large values.\n    # Adding 1 to denominator to prevent division by zero if remaining_after_fit is exactly 0 (handled by epsilon).\n    # The larger the remaining_after_fit, the lower the score.\n    priorities[can_fit_mask][tight_fit_mask] = 5.0 / (1.0 + remaining_after_fit[tight_fit_mask])\n\n    # Score for moderate fits (prefer smaller remaining capacity within this range)\n    moderate_fit_mask = (remaining_after_fit > item) & (remaining_after_fit <= 2.0 * item)\n    # Similar inverse relationship, but with a lower base score than tight fits.\n    priorities[can_fit_mask][moderate_fit_mask] = 2.0 / (1.0 + remaining_after_fit[moderate_fit_mask])\n\n    # Score for loose fits (penalize very large remaining capacities)\n    loose_fit_mask = (remaining_after_fit > 2.0 * item)\n    # Assign a very small positive score to encourage exploration, but less than tighter fits.\n    # This score decreases rapidly as remaining capacity increases.\n    priorities[can_fit_mask][loose_fit_mask] = 0.5 / (1.0 + remaining_after_fit[loose_fit_mask])\n\n    # Add a small random component for exploration. This helps to break ties and\n    # explore different bin choices when scores are very similar.\n    exploration_factor = 0.1\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor\n    priorities[can_fit_mask] += random_scores\n\n    return priorities\n\n[Reflection]\nPrioritize exact fits, then tighter fits. Penalize large remaining capacities. Explore randomly.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}