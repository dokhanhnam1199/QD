```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid strategy.

    This strategy prioritizes bins that offer a "tight fit" (minimizing leftover capacity),
    while also encouraging exploration by giving a slight boost to bins that are not too full,
    leaving more room for potentially larger future items. It also introduces a mechanism
    to avoid bins that are *too* close to being full, which might prevent fitting
    future items of moderate size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Determine which bins can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit, return all zeros

    fitting_bins_caps = bins_remain_cap[can_fit_mask]

    # Strategy 1: Tight Fit (Best Fit heuristic)
    # Prioritize bins that will have the least remaining capacity after packing.
    remaining_after_fit = fitting_bins_caps - item
    # Higher score for smaller remaining_after_fit. Adding 1.0 prevents division by zero.
    tight_fit_scores = 1.0 / (1.0 + remaining_after_fit)

    # Strategy 2: Encouraging Exploration / Avoiding Over-saturation
    # Boost bins that have a "good amount" of remaining space, but not too much.
    # This helps to keep some bins with ample space open for potentially larger future items.
    # We define "good amount" as being larger than the item itself, but not exceeding a certain fraction of the bin's total capacity.
    # Let's also slightly penalize bins that are *too* close to being full (e.g., remaining_after_fit < 0.1 * item),
    # as these might become unusable for many future items.

    # Calculate a penalty for bins that are almost full
    # Penalty is higher for smaller remaining capacities.
    almost_full_penalty_threshold = 0.1 * item
    penalty_scores = np.zeros_like(fitting_bins_caps)
    # Apply penalty if remaining capacity is small and positive
    nearly_full_mask = (remaining_after_fit > 0) & (remaining_after_fit <= almost_full_penalty_threshold)
    # The penalty is inversely proportional to how close it is to the threshold, scaled.
    # We want a larger negative score for smaller `remaining_after_fit`.
    penalty_scores[nearly_full_mask] = -0.5 * (1 - (remaining_after_fit[nearly_full_mask] / almost_full_penalty_threshold))

    # Add a small boost for bins with moderate remaining capacity (encourages exploration).
    # Bins with remaining capacity significantly larger than the item but not excessively large.
    # Let's say remaining capacity is between 1x and 5x the item size.
    exploration_boost_min = item
    exploration_boost_max = 5 * item
    exploration_mask = (remaining_after_fit > exploration_boost_min) & (remaining_after_fit <= exploration_boost_max)
    exploration_scores = np.zeros_like(fitting_bins_caps)
    # Boost is higher for capacity closer to `exploration_boost_min`.
    exploration_scores[exploration_mask] = 0.1 * (1 - (remaining_after_fit[exploration_mask] - exploration_boost_min) / (exploration_boost_max - exploration_boost_min))


    # Combine scores: Prioritize tight fit, apply penalty for nearly full bins, and add exploration boost.
    # Weights are chosen to balance these strategies.
    combined_scores = (0.8 * tight_fit_scores) + penalty_scores + exploration_scores

    # Assign the calculated scores to the corresponding bins
    priorities[can_fit_mask] = combined_scores

    return priorities
```
