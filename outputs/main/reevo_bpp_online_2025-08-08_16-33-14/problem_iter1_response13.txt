```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The "Almost Full Fit" strategy prioritizes bins that can accommodate the item
    and have a remaining capacity that is just slightly larger than the item's size.
    This aims to leave larger gaps in other bins for potentially larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Consider only bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "tightness" of the fit: how much space is left after adding the item
    # We want this value to be small for the "almost full" bins.
    # We add a small epsilon to avoid division by zero if a bin is exactly full after adding the item.
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # To prioritize bins that are "almost full" (small remaining capacity),
    # we can invert the remaining_after_fit or use a function that assigns higher
    # values to smaller remaining capacities. A simple inversion with a small
    # offset can work.
    # We want smaller positive values of (bins_remain_cap - item) to have higher priority.
    # For example, if remaining_after_fit is 0.1, priority should be high.
    # If remaining_after_fit is 1.0, priority should be lower.
    # Using 1 / (remaining_after_fit + epsilon) is one way.
    # Another way is to use a penalty for larger remaining capacities.
    # Let's define "almost full" as having remaining capacity within a small margin of 0.
    
    # Option 1: Invert the remaining capacity after fit. A smaller value means a tighter fit.
    # Add a small constant to avoid division by zero and to ensure positive priorities.
    # Higher value means higher priority.
    epsilon = 1e-9
    # If remaining_after_fit is very close to 0, 1/epsilon becomes large, giving high priority.
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit + epsilon)

    # Option 2 (Alternative): Use a penalty function.
    # Penalize bins that have a lot of leftover space.
    # Let's try to make bins that have remaining_after_fit = 0 the highest priority,
    # and then decrease priority as remaining_after_fit increases.
    # We could use something like `np.exp(-k * remaining_after_fit)` where k is a scaling factor.
    # Or a simpler linear penalty: `max_remaining_after_fit - remaining_after_fit`.
    # Let's stick to the inverse for now as it's a common heuristic approach for "tight fit".

    # For bins that cannot fit the item, their priority remains 0 (or effectively negative if we consider strict ordering).
    # The logic here is that if an item cannot fit, it shouldn't be considered for placement.
    
    return priorities
```
