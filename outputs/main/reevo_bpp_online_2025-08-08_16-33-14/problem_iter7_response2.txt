```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for the online Bin Packing Problem.
    This version prioritizes perfect fits, then tight fits, penalizes wasted space,
    and incorporates an adaptive penalty for suboptimal fits. It also adds a
    small stochastic element for exploration.

    The priority is calculated as follows:
    1. Bins that cannot fit the item receive a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity is exactly 0 after packing): Highest priority.
       b. Tight Fits (remaining capacity is small): High priority, inversely proportional
          to the remaining capacity. Encourages filling bins.
       c. Moderate Fits: Priority decreases as remaining capacity increases, but less
          steeply than tight fits.
       d. Wasteful Fits (remaining capacity is large): Penalized, with the penalty
          increasing with the amount of wasted space.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: An array of the remaining capacities of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element is the
        priority score for the corresponding bin. Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define thresholds adaptively.
    # Epsilon for floating point comparisons
    epsilon = 1e-9

    # Threshold for "tight" fits: remaining space is less than or equal to the item size.
    # This prioritizes bins that are already somewhat full.
    tight_fit_threshold = item

    # Threshold for "wasteful" fits: remaining space is significantly larger than item size.
    # Let's define this as more than twice the item size. This is a tunable parameter.
    wasteful_threshold = 2.0 * item

    # Calculate scores for fitting bins
    scores = np.zeros_like(remaining_after_fit, dtype=float)

    # 1. Perfect Fits: Highest priority. Assign a very high fixed score.
    perfect_mask = (remaining_after_fit < epsilon)
    scores[perfect_mask] = 1000.0

    # 2. Tight Fits: High priority, inversely proportional to remaining capacity.
    # Using a function like 1/(1+x) or e^(-kx) gives a decreasing priority.
    # Scale it to provide a good range relative to perfect fits.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)
    scores[tight_mask] = 500.0 / (1.0 + remaining_after_fit[tight_mask] * 2.0)

    # 3. Moderate Fits: Priority decreases as remaining capacity increases, but less steeply.
    # This is for bins that aren't perfect or tight, but not overly wasteful.
    moderate_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)
    scores[moderate_mask] = 100.0 / (1.0 + np.sqrt(remaining_after_fit[moderate_mask]))

    # 4. Wasteful Fits: Significantly penalized.
    # The penalty increases with the excess space.
    wasteful_mask = (remaining_after_fit > wasteful_threshold)
    # We want to strongly discourage these. The penalty should grow faster than linear.
    # A quadratic or exponential penalty could be used. Here, we use a factor
    # that grows with the ratio of wasted space to the item size.
    penalty_factor = 5.0  # Controls the severity of the penalty
    scores[wasteful_mask] = 50.0 / (1.0 + remaining_after_fit[wasteful_mask] / item) # Base score for wasteful
    penalty = penalty_factor * (remaining_after_fit[wasteful_mask] - wasteful_threshold) / (item + epsilon)
    scores[wasteful_mask] -= penalty

    # Ensure scores are non-negative. If a penalty made a score negative, clamp it to 0.
    scores[scores < 0] = 0

    # Add a small random jitter for exploration. This helps break ties and
    # explore potentially suboptimal but beneficial placements in the long run.
    exploration_strength = 0.05  # Controls the magnitude of the random jitter
    jitter = np.random.uniform(-exploration_strength, exploration_strength, size=scores.shape) * (np.max(scores) + epsilon)
    final_scores = scores + jitter

    # Update the priorities array with the calculated scores for the fitting bins
    priorities[can_fit_mask] = final_scores

    return priorities
```
