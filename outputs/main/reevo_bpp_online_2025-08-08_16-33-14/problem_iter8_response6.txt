```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for the online Bin Packing Problem (BPP).

    This heuristic aims to balance several strategic objectives:
    1.  **Tight Fit (Best Fit principle):** Prioritize bins that leave the minimum
        remaining capacity after packing the item. This aims to minimize immediate
        wasted space. The priority is inversely proportional to the remaining capacity.
    2.  **Avoid Over-Saturation (Penalty):** Penalize bins that will have very little
        remaining capacity after packing. This aims to prevent a bin from becoming
        too full too quickly, leaving it unusable for even small future items. The
        penalty is stronger for bins that become almost completely full.
    3.  **Encourage Exploration (Boost):** Provide a slight boost to bins that will
        have a moderate amount of remaining capacity. This encourages utilizing a
        wider range of bins, potentially leading to better overall packing by
        distributing items more evenly. The boost is applied to bins that will
        have remaining capacity between `item` and `k * item` (e.g., k=2).

    The function calculates priority scores only for bins that can fit the item.
    Bins that cannot fit the item receive a score of 0.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining capacity
                         of a bin.

    Returns:
        A numpy array of the same size as `bins_remain_cap`, containing the priority
        score for each bin. Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the current item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item, return all zeros.

    # Get the remaining capacities of bins that can fit the item
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # --- Calculate Priority Components ---

    # 1. Tight Fit Score: Prioritize bins with less remaining space.
    # Use 1 / (remaining_capacity + epsilon) to give higher scores to smaller remainders.
    # Epsilon prevents division by zero for perfect fits.
    tight_fit_scores = 1.0 / (remaining_after_fit + 1e-9)

    # 2. Over-Saturation Penalty: Penalize bins that become nearly full.
    # Define a threshold for "nearly full", e.g., remaining capacity < 0.1 * item.
    # The penalty should be more aggressive for smaller remaining capacities.
    penalty_threshold = 0.1 * item
    penalty_scores = np.zeros_like(fitting_bins_caps)

    # Apply penalty to bins where remaining capacity is positive but very small
    nearly_full_mask = (remaining_after_fit > 0) & (remaining_after_fit <= penalty_threshold)
    if np.any(nearly_full_mask):
        # Linear penalty: closer to 0 remaining capacity = higher penalty (more negative score)
        # Max penalty (-1.0) for remaining_after_fit=0, min penalty (0.0) for remaining_after_fit=penalty_threshold
        penalty_scores[nearly_full_mask] = -1.0 * (1.0 - (remaining_after_fit[nearly_full_mask] / penalty_threshold))

    # 3. Exploration Boost: Encourage bins that leave a moderate amount of space.
    # Define a range for moderate remaining space, e.g., item <= remaining < 2 * item.
    # This aims to avoid overly tight fits (handled by tight_fit_scores) and
    # overly spacious fits (which might be better for larger items).
    boost_min_remaining = item
    boost_max_remaining = 2.0 * item  # Tunable parameter for boost range
    exploration_scores = np.zeros_like(fitting_bins_caps)

    # Apply boost to bins within the moderate range
    boost_mask = (remaining_after_fit > boost_min_remaining) & (remaining_after_fit <= boost_max_remaining)
    if np.any(boost_mask):
        # Boost is highest for remaining_after_fit close to boost_min_remaining
        # and decreases as it approaches boost_max_remaining.
        # Normalize remaining capacity within the boost range [0, 1]
        normalized_remaining = (remaining_after_fit[boost_mask] - boost_min_remaining) / (boost_max_remaining - boost_min_remaining)
        # Apply a decreasing boost function, e.g., linear decay
        exploration_scores[boost_mask] = 0.2 * (1.0 - normalized_remaining) # Tunable boost strength (e.g., 0.2)

    # --- Combine Scores with Weights ---
    # Weights can be tuned to prioritize different strategies.
    # Tight fit is primary, penalty is secondary, boost is tertiary.
    weight_tight_fit = 1.0
    weight_penalty = 1.0 # Penalty is naturally negative, so its weight affects magnitude
    weight_exploration = 1.0

    combined_scores = (weight_tight_fit * tight_fit_scores) + \
                      (weight_penalty * penalty_scores) + \
                      (weight_exploration * exploration_scores)

    # Assign the calculated scores back to the original priority array
    priorities[can_fit_mask] = combined_scores

    return priorities
```
