```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit Decreasing-like strategy.

    This heuristic prioritizes bins that can fit the item and, among those,
    prioritizes bins that will have the least remaining capacity *after*
    placing the item. This aims to pack items tightly and minimize wasted space.

    The priority is calculated as: 1 / (1 + remaining_capacity_after_placement).
    This formula gives higher priority to bins where the remaining capacity
    after placing the item is smaller.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity for bins that can fit the item
    # If an item cannot fit, the remaining capacity is effectively infinite in terms of priority.
    # For fitting bins, calculate the remaining capacity after placement.
    remaining_after_placement = np.where(can_fit_mask, bins_remain_cap - item, np.inf)

    # To prioritize bins with minimal remaining capacity after placement,
    # we use the inverse of (1 + remaining_capacity_after_placement).
    # Adding 1 ensures the denominator is always at least 1, and the inverse
    # means smaller remaining capacities get higher priorities.
    # np.inf will result in a priority of 0, correctly indicating these bins are not preferred.
    # Use a small epsilon for numerical stability if remaining_after_placement can be very close to zero.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Avoid division by zero for bins that can fit.
    # If remaining_after_placement is 0, the priority should be maximal.
    # The current formula 1 / (1 + 0) = 1, which is correct.
    # For bins that cannot fit, remaining_after_placement is np.inf, resulting in 0 priority.
    fit_mask_valid = can_fit_mask # Mask for bins that can fit
    if np.any(fit_mask_valid):
        priorities[fit_mask_valid] = 1.0 / (1.0 + remaining_after_placement[fit_mask_valid])

    return priorities
```
