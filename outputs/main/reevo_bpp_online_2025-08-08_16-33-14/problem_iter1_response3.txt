```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit strategy.

    The Almost Full Fit strategy prioritizes bins that are almost full,
    meaning they have a small remaining capacity after accommodating the current item.
    This aims to leave larger remaining capacities in other bins for potentially
    larger future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Consider only bins that can fit the item
    available_bins_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros (or handle as an error/new bin creation)
    if not np.any(available_bins_mask):
        return priorities

    # Calculate the remaining capacity *after* placing the item
    remaining_after_placement = bins_remain_cap[available_bins_mask] - item

    # The priority is inversely proportional to the remaining capacity after placement.
    # We want bins with smaller remaining capacity (i.e., bins that get *almost full*)
    # to have higher priority.
    # To avoid division by zero if remaining capacity is 0, we can add a small epsilon.
    epsilon = 1e-9
    priorities[available_bins_mask] = 1.0 / (remaining_after_placement + epsilon)

    # Optionally, we can normalize the priorities to a range like [0, 1]
    # This can sometimes help if the raw priority values are very large or very small.
    # For a priority function, raw values are often fine, but normalization can be an option.
    # if np.max(priorities[available_bins_mask]) > 0:
    #     priorities[available_bins_mask] /= np.max(priorities[available_bins_mask])

    return priorities
```
