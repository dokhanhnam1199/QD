```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    In Best Fit, we aim to place the item in the bin that leaves the least
    remaining capacity after the item is placed. This minimizes wasted space
    in that particular bin, ideally leading to fewer bins being used overall.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more preferred bin. Bins that cannot fit the
        item are given a very low priority (negative infinity).
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)  # Initialize with very low priority

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after placing the item in eligible bins
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # For Best Fit, we want the bin that results in the *smallest* positive remaining capacity.
    # This means the negative of the remaining capacity will give us the highest score
    # for the tightest fits. Larger negative values mean a tighter fit.
    # We can directly assign these values as priorities.
    priorities[can_fit_mask] = -remaining_after_fit

    return priorities
```
