```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a refined priority function for online Bin Packing Problem,
    prioritizing perfect fits, then tight fits, and categorizing other fits based on thresholds.

    This version aims to achieve a balance between filling bins tightly and leaving
    sufficient space for future items by using distinct scoring for different
    remaining capacity scenarios.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define scoring weights and thresholds for different fit categories.
    # These values are heuristic and can be tuned for performance.
    epsilon = 1e-9  # To handle perfect fits and avoid division by zero
    perfect_fit_score = 10.0
    tight_fit_weight = 0.8
    tight_threshold = item * 0.1  # Up to 10% of item size remaining
    good_fit_weight = 0.5
    good_threshold = item * 0.5  # Up to 50% of item size remaining
    loose_fit_weight = 0.2

    # Calculate scores for each fitting bin
    scores = np.zeros_like(fitting_bins_caps)

    # Perfect Fit: Highest priority
    perfect_mask = (remaining_after_fit < epsilon)
    scores[perfect_mask] = perfect_fit_score

    # Tight Fit: Prioritize bins that leave very little but non-zero space.
    tight_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= tight_threshold)
    scores[tight_mask] = tight_fit_weight / (1.0 + remaining_after_fit[tight_mask])

    # Good Fit: Prioritize bins that leave a moderate amount of space.
    good_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= good_threshold)
    scores[good_mask] = good_fit_weight / (1.0 + remaining_after_fit[good_mask])

    # Loose Fit: Bins with significant remaining space, lower priority.
    loose_mask = (remaining_after_fit > good_threshold)
    scores[loose_mask] = loose_fit_weight / (1.0 + remaining_after_fit[loose_mask])

    # Assign the calculated scores to the original priority array
    priorities[can_fit_mask] = scores

    return priorities
```
