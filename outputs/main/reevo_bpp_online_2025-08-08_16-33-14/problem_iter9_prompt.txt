{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Prior reflection]\nPrioritize perfect/tight fits. Quadratically reward snugness. Adapt thresholds and penalties to item/bin state. Tune scaling factors and decay. Balance exploration/exploitation for better bin packing.\n\n[Code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved priority function for the online Bin Packing Problem,\n    focusing on prioritizing tight fits, penalizing wasted space effectively,\n    and using adaptive thresholds based on item size and bin capacities.\n\n    The priority is calculated as follows:\n    1. Bins that cannot fit the item receive a priority of 0.\n    2. For bins that can fit the item:\n       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.\n       b. Tight Fits (remaining capacity after packing is small and positive):\n          High priority, inversely proportional to the remaining capacity. This\n          encourages filling bins as much as possible.\n       c. Good Fits (remaining capacity after packing is moderate): Priority\n          decreases as remaining capacity increases, but at a slower rate than\n          tight fits.\n       d. Wasteful Fits (remaining capacity after packing is large):\n          Significantly penalized to strongly discourage using bins that would\n          leave substantial empty space. The penalty increases with the amount\n          of wasted space relative to the item size.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.\n\n    Returns:\n        A NumPy array of the same size as bins_remain_cap, where each element\n        represents the priority score for placing the item in the corresponding bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define thresholds adaptively, primarily based on item size for relative comparison.\n    epsilon = 1e-9  # Tolerance for floating-point comparisons\n\n    # Threshold for \"tight\" fits: remaining space is less than the item size.\n    # This encourages using bins that are already somewhat filled.\n    tight_fit_threshold = item\n\n    # Threshold for \"wasteful\" fits: remaining space is significantly larger than item size.\n    # Using a factor of the item size helps in relative comparison across different item sizes.\n    # A factor of 3.0 means if the remaining space is more than 3 times the item size, it's wasteful.\n    wasteful_threshold = 3.0 * item\n\n    # --- Scoring Logic ---\n    scores = np.zeros_like(remaining_after_fit)\n\n    # 1. Perfect Fits: Highest priority. Assign a very high score.\n    perfect_mask = (remaining_after_fit < epsilon)\n    scores[perfect_mask] = 1000.0\n\n    # 2. Tight Fits: High priority, inversely proportional to remaining capacity.\n    # Use a steep decay function, e.g., 1/(1+x), scaled to provide a good range.\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)\n    # Scale factor for the reciprocal to modulate the steepness of the priority drop-off.\n    scores[tight_mask] = 50.0 / (1.0 + remaining_after_fit[tight_mask] * 4.0)\n\n    # 3. Good Fits: Priority decreases with remaining capacity, but less steeply.\n    # These are bins that fit, but are not \"tight\" and not yet \"wasteful\".\n    good_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)\n    # Use a less steep decay, like 1/(1+sqrt(x)), to retain more relative priority.\n    scores[good_mask] = 25.0 / (1.0 + np.sqrt(remaining_after_fit[good_mask]))\n\n    # 4. Wasteful Fits: Significantly penalized.\n    # These bins have remaining space significantly larger than the item.\n    wasteful_mask = (remaining_after_fit > wasteful_threshold)\n    # Penalize based on how much excess space is left, normalized by item size.\n    # A linear or exponential penalty can be used. Here, we use a rational function\n    # that decreases rapidly as remaining_after_fit increases.\n    # The penalty is subtracted from a base score to ensure that even wasteful bins\n    # that *could* fit still get a non-zero (though low) initial score before penalty.\n    base_wasteful_score = 10.0\n    penalty_strength = 2.0  # Controls how aggressively large remaining capacities are penalized.\n    scores[wasteful_mask] = base_wasteful_score / (1.0 + penalty_strength * (remaining_after_fit[wasteful_mask] / item))\n\n    # Ensure all calculated scores are non-negative.\n    scores[scores < 0] = 0\n\n    # Add a small amount of random jitter to scores of bins with very similar calculated priorities.\n    # This helps to break ties randomly and can improve exploration without a strict exploration bonus.\n    exploration_jitter_scale = 0.01  # Controls the magnitude of the jitter relative to max possible score.\n    max_potential_score = 1000.0 # An estimate of the highest possible score.\n    jitter = np.random.uniform(-exploration_jitter_scale * max_potential_score, exploration_jitter_scale * max_potential_score, size=len(scores))\n    final_scores = scores + jitter\n\n    # Ensure jitter doesn't make scores negative.\n    final_scores[final_scores < 0] = 0\n\n    # Assign the calculated scores to the corresponding bins in the original priority array.\n    priorities[can_fit_mask] = final_scores\n\n    return priorities\n\n[Improved code]\nPlease write a mutated function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}