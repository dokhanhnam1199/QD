{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved hybrid priority function for online Bin Packing Problem.\n    This version refines the scoring by categorizing fits and using a more\n    nuanced approach to score within categories, while also incorporating\n    an element of randomness for exploration.\n\n    Categories and Scoring Logic:\n    1. Perfect Fit (remaining_after_fit = 0): Highest priority. Score is a high constant.\n    2. Tight Fit (0 < remaining_after_fit <= item): Prioritize bins that leave minimal space.\n       Score is inversely proportional to remaining capacity, scaled for high importance.\n    3. Moderate Fit (item < remaining_after_fit <= 2*item): Prioritize bins that leave some space,\n       but not too much. Score is inversely proportional to remaining capacity, with a moderate scale.\n    4. Loose Fit (remaining_after_fit > 2*item): Lowest priority among fitting bins.\n       Score is inversely proportional to remaining capacity, scaled low, to still encourage\n       using larger bins if no better options exist, but with less preference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    # Get remaining capacities only for bins that can fit the item\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # --- Scoring Logic ---\n    epsilon = 1e-9 # For handling perfect fits and numerical stability\n\n    # Define score components\n    scores = np.zeros_like(remaining_after_fit, dtype=float)\n\n    # Category 1: Perfect Fit (remaining_after_fit is almost zero)\n    perfect_fit_mask = (remaining_after_fit < epsilon)\n    scores[perfect_fit_mask] = 100.0 # Highest priority\n\n    # Category 2: Tight Fit (0 < remaining_after_fit <= item)\n    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item)\n    if np.any(tight_fit_mask):\n        # Prioritize smaller remaining capacity within this category\n        # Higher score for smaller denominator (1 + remaining)\n        scores[tight_fit_mask] = 10.0 / (1.0 + remaining_after_fit[tight_fit_mask])\n\n    # Category 3: Moderate Fit (item < remaining_after_fit <= 2*item)\n    moderate_fit_mask = (remaining_after_fit > item) & (remaining_after_fit <= 2.0 * item)\n    if np.any(moderate_fit_mask):\n        # Moderate priority, still inversely proportional to remaining capacity\n        scores[moderate_fit_mask] = 5.0 / (1.0 + remaining_after_fit[moderate_fit_mask])\n\n    # Category 4: Loose Fit (remaining_after_fit > 2*item)\n    loose_fit_mask = (remaining_after_fit > 2.0 * item)\n    if np.any(loose_fit_mask):\n        # Lower priority, but still inversely proportional\n        scores[loose_fit_mask] = 1.0 / (1.0 + remaining_after_fit[loose_fit_mask])\n\n    # --- Exploration Component ---\n    exploration_factor = 0.05 # Small random noise to encourage exploring different bins\n    random_scores = np.random.rand(len(remaining_after_fit)) * exploration_factor * (1 + scores) # Scale noise with existing score\n    \n    # Add exploration to all fitting bins\n    scores += random_scores\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved priority function for online Bin Packing Problem,\n    prioritizing tight fits and using simpler, well-defined thresholds.\n\n    The function assigns scores to bins based on how well they fit an item:\n    1. Perfect Fit: Bin's remaining capacity is exactly zero after packing. Highest priority.\n    2. Tight Fit: Bin's remaining capacity after packing is small (<= item size). High priority.\n    3. Moderate Fit: Bin's remaining capacity after packing is larger than item size but not excessively so (<= 2 * item size). Medium priority.\n    4. Loose Fit: Bin's remaining capacity after packing is large (> 2 * item size). Lowest priority.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: A numpy array containing the remaining capacity of each bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        is the priority score for the corresponding bin. Higher scores indicate\n        higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define thresholds for categorizing fits relative to the item size\n    epsilon = 1e-9  # For floating-point comparisons, especially for perfect fits\n    tight_threshold = item\n    moderate_threshold = 2.0 * item\n\n    # Initialize scores for different fit categories\n    perfect_fit_scores = np.zeros_like(remaining_after_fit)\n    tight_fit_scores = np.zeros_like(remaining_after_fit)\n    moderate_fit_scores = np.zeros_like(remaining_after_fit)\n    loose_fit_scores = np.zeros_like(remaining_after_fit)\n\n    # Calculate scores for each category:\n    # Perfect Fit: Highest score, indicating minimal waste.\n    perfect_mask = (remaining_after_fit < epsilon)\n    perfect_fit_scores[perfect_mask] = 10.0\n\n    # Tight Fit: Prioritize bins that leave little remaining capacity after packing.\n    # Score is inversely proportional to the remaining capacity, encouraging fuller bins.\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_threshold)\n    tight_fit_scores[tight_mask] = 5.0 / (1.0 + remaining_after_fit[tight_mask])\n\n    # Moderate Fit: Bins that leave a moderate amount of space.\n    # Score decreases as remaining capacity increases, but less steeply than tight fits.\n    moderate_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= moderate_threshold)\n    moderate_fit_scores[moderate_mask] = 2.0 / (1.0 + remaining_after_fit[moderate_mask])\n\n    # Loose Fit: Bins that leave a significant amount of space.\n    # These are less preferred, so they receive a low base score.\n    loose_mask = (remaining_after_fit > moderate_threshold)\n    loose_fit_scores[loose_mask] = 1.0 / (1.0 + remaining_after_fit[loose_mask])\n\n    # Combine scores using weights to reflect the priority order: Perfect > Tight > Moderate > Loose.\n    # Weights are tuned to emphasize tighter fits.\n    combined_scores = (\n        perfect_fit_scores * 1.0 +\n        tight_fit_scores * 0.8 +\n        moderate_fit_scores * 0.5 +\n        loose_fit_scores * 0.2\n    )\n\n    # Add a small stochastic component for exploration.\n    # This helps in occasional selection of less optimal bins, potentially leading to better overall packing.\n    exploration_factor = 0.05\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor\n    combined_scores += random_scores\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities\n\n[Reflection]\nPrioritize tighter fits, tune scaling factors, and consider a weighted combination of fit categories.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}