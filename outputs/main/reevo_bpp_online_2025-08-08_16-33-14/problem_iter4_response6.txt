```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an enhanced priority function for online Bin Packing Problem.
    This version uses a combination of 'best fit' and 'first fit' tendencies,
    incorporating a penalty for bins that leave an excessive amount of remaining space.
    It also includes a stronger emphasis on perfect fits and a more nuanced
    scoring for near-perfect fits.

    The priority is calculated as follows:
    1. Bins that cannot fit the item get a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.
       b. Near-Perfect Fits (remaining capacity after packing is small): High priority,
          inversely proportional to the remaining capacity.
       c. Other Fits: Priority decreases as the remaining capacity increases,
          with a steeper drop-off for larger remaining capacities.
       d. A "wastefulness" penalty is applied to bins that leave a lot of space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define score components and thresholds
    epsilon = 1e-9
    # Threshold for "near-perfect" fits - e.g., leaving space less than 10% of bin capacity
    # or less than item size, whichever is smaller and positive.
    near_perfect_threshold = min(0.1 * bins_remain_cap.max(), item) if bins_remain_cap.max() > 0 else item
    # Threshold for "wasteful" bins - e.g., leaving space more than 50% of bin capacity
    # or more than 2 * item size.
    wasteful_threshold = max(0.5 * bins_remain_cap.max(), 2.0 * item) if bins_remain_cap.max() > 0 else 2.0 * item

    # Calculate base scores
    base_scores = np.zeros_like(remaining_after_fit)

    # 1. Perfect Fits: Highest priority
    perfect_mask = (remaining_after_fit < epsilon)
    base_scores[perfect_mask] = 1000.0

    # 2. Near-Perfect Fits: High priority, inversely proportional to remaining capacity
    near_perfect_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= near_perfect_threshold)
    # Use a concave function to give diminishing returns as remaining capacity increases
    # Ensure we don't divide by zero or get excessively large numbers.
    base_scores[near_perfect_mask] = 50.0 / (1.0 + remaining_after_fit[near_perfect_mask] * 10.0)

    # 3. Other Fits: Priority decreases with remaining capacity
    other_mask = ~perfect_mask & ~near_perfect_mask
    # A function that decreases rapidly for larger gaps.
    # We want to favor bins that leave less space.
    # (1 / (1 + x)) or (1 / (1 + x^2)) are good candidates.
    # Let's use a slightly more aggressive decay for larger gaps.
    # Add a small constant to avoid division by zero if remaining_after_fit is 0
    # (though perfect_mask should handle this).
    base_scores[other_mask] = 10.0 / (1.0 + remaining_after_fit[other_mask]**1.5)

    # 4. Wastefulness Penalty: Reduce priority for bins that leave too much space
    wasteful_mask = (remaining_after_fit > wasteful_threshold)
    # Apply a penalty that is proportional to how much they exceed the wasteful threshold.
    penalty = 5.0 * (remaining_after_fit[wasteful_mask] - wasteful_threshold) / (fitting_bins_caps[wasteful_mask] + epsilon)
    base_scores[wasteful_mask] -= penalty

    # Ensure scores are not negative (though penalty is designed not to make them so easily)
    base_scores[base_scores < 0] = 0

    # Add a small random component for exploration to all fitting bins
    # This helps in escaping local optima and exploring different packing configurations.
    exploration_factor = 0.05
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor * np.max(base_scores + epsilon)
    final_scores = base_scores + random_scores

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = final_scores

    return priorities
```
