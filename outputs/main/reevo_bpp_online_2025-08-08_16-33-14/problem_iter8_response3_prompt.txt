{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved priority function for the online Bin Packing Problem.\n    This version prioritizes perfect fits, then tight fits, penalizes wasted space,\n    and incorporates an adaptive penalty for suboptimal fits. It also adds a\n    small stochastic element for exploration.\n\n    The priority is calculated as follows:\n    1. Bins that cannot fit the item receive a priority of 0.\n    2. For bins that can fit the item:\n       a. Perfect Fits (remaining capacity is exactly 0 after packing): Highest priority.\n       b. Tight Fits (remaining capacity is small): High priority, inversely proportional\n          to the remaining capacity. Encourages filling bins.\n       c. Moderate Fits: Priority decreases as remaining capacity increases, but less\n          steeply than tight fits.\n       d. Wasteful Fits (remaining capacity is large): Penalized, with the penalty\n          increasing with the amount of wasted space.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: An array of the remaining capacities of each bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element is the\n        priority score for the corresponding bin. Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define thresholds adaptively.\n    # Epsilon for floating point comparisons\n    epsilon = 1e-9\n\n    # Threshold for \"tight\" fits: remaining space is less than or equal to the item size.\n    # This prioritizes bins that are already somewhat full.\n    tight_fit_threshold = item\n\n    # Threshold for \"wasteful\" fits: remaining space is significantly larger than item size.\n    # Let's define this as more than twice the item size. This is a tunable parameter.\n    wasteful_threshold = 2.0 * item\n\n    # Calculate scores for fitting bins\n    scores = np.zeros_like(remaining_after_fit, dtype=float)\n\n    # 1. Perfect Fits: Highest priority. Assign a very high fixed score.\n    perfect_mask = (remaining_after_fit < epsilon)\n    scores[perfect_mask] = 1000.0\n\n    # 2. Tight Fits: High priority, inversely proportional to remaining capacity.\n    # Using a function like 1/(1+x) or e^(-kx) gives a decreasing priority.\n    # Scale it to provide a good range relative to perfect fits.\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)\n    scores[tight_mask] = 500.0 / (1.0 + remaining_after_fit[tight_mask] * 2.0)\n\n    # 3. Moderate Fits: Priority decreases as remaining capacity increases, but less steeply.\n    # This is for bins that aren't perfect or tight, but not overly wasteful.\n    moderate_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)\n    scores[moderate_mask] = 100.0 / (1.0 + np.sqrt(remaining_after_fit[moderate_mask]))\n\n    # 4. Wasteful Fits: Significantly penalized.\n    # The penalty increases with the excess space.\n    wasteful_mask = (remaining_after_fit > wasteful_threshold)\n    # We want to strongly discourage these. The penalty should grow faster than linear.\n    # A quadratic or exponential penalty could be used. Here, we use a factor\n    # that grows with the ratio of wasted space to the item size.\n    penalty_factor = 5.0  # Controls the severity of the penalty\n    scores[wasteful_mask] = 50.0 / (1.0 + remaining_after_fit[wasteful_mask] / item) # Base score for wasteful\n    penalty = penalty_factor * (remaining_after_fit[wasteful_mask] - wasteful_threshold) / (item + epsilon)\n    scores[wasteful_mask] -= penalty\n\n    # Ensure scores are non-negative. If a penalty made a score negative, clamp it to 0.\n    scores[scores < 0] = 0\n\n    # Add a small random jitter for exploration. This helps break ties and\n    # explore potentially suboptimal but beneficial placements in the long run.\n    exploration_strength = 0.05  # Controls the magnitude of the random jitter\n    jitter = np.random.uniform(-exploration_strength, exploration_strength, size=scores.shape) * (np.max(scores) + epsilon)\n    final_scores = scores + jitter\n\n    # Update the priorities array with the calculated scores for the fitting bins\n    priorities[can_fit_mask] = final_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved hybrid priority function for online Bin Packing Problem (BPP).\n    This version strictly prioritizes perfect fits, then tight fits (remaining capacity\n    close to the item size), and then \"best fit\" style remaining capacity, while\n    still allowing for exploration.\n\n    Scoring Logic:\n    1. Perfect Fit: remaining capacity is zero. Highest priority.\n    2. Tight Fit: remaining capacity is positive but less than or equal to the item size.\n       Higher priority than other fits, scaled inversely with remaining space.\n    3. Best Fit (remaining): remaining capacity is greater than the item size.\n       Priority decreases as remaining capacity increases.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components\n    epsilon = 1e-9  # For handling perfect fits and avoiding division by zero\n\n    # Initialize scores for different fit categories\n    perfect_fit_scores = np.zeros_like(remaining_after_fit)\n    tight_fit_scores = np.zeros_like(remaining_after_fit)\n    best_fit_scores = np.zeros_like(remaining_after_fit)\n\n    # 1. Perfect Fit: Highest priority.\n    perfect_mask = (remaining_after_fit < epsilon)\n    perfect_fit_scores[perfect_mask] = 100.0  # High fixed score for perfect fits\n\n    # 2. Tight Fit: Prioritize bins that leave little room after packing,\n    #    specifically when remaining capacity is <= item size.\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= item)\n    # Score decreases as remaining_after_fit increases within the tight range.\n    # Use inverse relationship: 1 / (1 + remaining_space). A larger remaining space means lower score.\n    # Adding a small constant to the denominator to avoid issues if remaining_after_fit is very close to 0.\n    tight_fit_scores[tight_mask] = 10.0 / (1.0 + remaining_after_fit[tight_mask])\n\n    # 3. Best Fit (remaining): For bins where remaining capacity is > item size.\n    #    Priority decreases as remaining capacity increases.\n    best_fit_mask = (remaining_after_fit > item)\n    # Use a decaying function. (1 / (1 + remaining_space)).\n    # This gives higher scores to bins with less remaining space among this category.\n    best_fit_scores[best_fit_mask] = 5.0 / (1.0 + remaining_after_fit[best_fit_mask])\n\n    # Combine scores using weights to reflect the priority order: Perfect > Tight > Best Fit\n    combined_scores = (\n        perfect_fit_scores * 1.0 +  # Max weight for perfect fits\n        tight_fit_scores * 0.7 +    # Significant weight for tight fits\n        best_fit_scores * 0.3       # Lower weight for general best fits\n    )\n\n    # Add a small random component for exploration to all fitting bins\n    # This helps in breaking ties and exploring less obvious choices occasionally.\n    exploration_factor = 0.05\n    # Scale random score by the maximum possible score to maintain relative priorities.\n    max_possible_score = 100.0 + (10.0 / (1.0 + epsilon)) * 0.7 + (5.0 / (1.0 + item)) * 0.3\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor * max_possible_score\n    combined_scores += random_scores\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities\n\n[Reflection]\nPrioritize perfect fits, then tight fits, and use a consistent decay for others.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}