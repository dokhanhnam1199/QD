```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved hybrid priority function for online Bin Packing Problem.
    This version prioritizes perfect fits, then tight fits, and finally good fits,
    while incorporating an exploration mechanism.

    Priority Hierarchy:
    1. Perfect Fit: Bin's remaining capacity is exactly zero after placement. Highest priority.
    2. Tight Fit: Bin's remaining capacity after placement is small (<= item size). High priority, inversely proportional to remaining capacity.
    3. Good Fit: Bin's remaining capacity after placement is moderate (> item size and <= 2 * item size). Medium priority, inversely proportional to remaining capacity.
    4. Loose Fit: Bin's remaining capacity after placement is large (> 2 * item size). Lowest priority among fitting bins, but still offers a base score.

    An exploration bonus is added to all bins that can fit the item to encourage
    diversification and avoid getting stuck in local optima.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Bins that cannot fit the item will have a priority score of 0.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    epsilon = 1e-9  # Tolerance for floating-point comparisons, especially for perfect fits

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item, return all zeros

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define scoring for different fit categories
    perfect_fit_score = 100.0
    tight_fit_base_score = 10.0
    good_fit_base_score = 5.0
    loose_fit_base_score = 1.0

    # Thresholds for categorizing fits relative to the item size
    tight_threshold = item
    good_threshold = 2.0 * item

    # Calculate scores for fitting bins
    scores = np.zeros_like(fitting_bins_caps, dtype=float)

    # 1. Perfect Fit: Highest priority
    perfect_mask = np.abs(remaining_after_fit) < epsilon
    scores[perfect_mask] = perfect_fit_score

    # 2. Tight Fit: Prioritize bins that leave little room after the perfect fits are handled.
    # Score is inversely proportional to remaining capacity to favor tighter packing.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_threshold)
    if np.any(tight_mask):
        scores[tight_mask] = tight_fit_base_score / (1.0 + remaining_after_fit[tight_mask])

    # 3. Good Fit: Bins that fit the item but leave more space than tight fits.
    # Score is also inversely proportional but with a lower base score.
    good_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= good_threshold)
    if np.any(good_mask):
        scores[good_mask] = good_fit_base_score / (1.0 + remaining_after_fit[good_mask])

    # 4. Loose Fit: Bins that fit the item but leave a significant amount of space.
    # These get a minimal score to still be considered if other options are worse.
    loose_mask = remaining_after_fit > good_threshold
    if np.any(loose_mask):
        scores[loose_mask] = loose_fit_base_score / (1.0 + remaining_after_fit[loose_mask])

    # Add a small, uniform exploration bonus to all fitting bins to encourage diversity.
    # This is a fixed small value added to all fitting bins, making them slightly
    # more likely to be chosen and breaking ties.
    exploration_bonus = 0.1
    scores += exploration_bonus

    # Assign calculated scores to the 'priorities' array for the fitting bins
    priorities[can_fit_mask] = scores

    return priorities
```
