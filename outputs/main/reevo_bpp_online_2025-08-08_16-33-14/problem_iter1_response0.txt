```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit Decreasing-like strategy.

    This heuristic prioritizes bins that can fit the item and, among those,
    prioritizes bins that will have the least remaining capacity *after*
    placing the item. This aims to pack items tightly.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after placement.
    # We want to prioritize bins where placing the item leaves the LEAST remaining capacity.
    # This is equivalent to prioritizing bins with smaller remaining capacity *after* placement.
    # A higher score means higher priority. So, we can use the negative of the
    # remaining capacity, or some transformation of it.
    # Let's assign a score based on how "tightly" it fits. A tighter fit (less remaining capacity)
    # should have a higher priority.
    # So, we can use: -(remaining_capacity - item_size).
    # This means if a bin has remaining capacity of 10 and item is 3, remaining is 7. Score is -7.
    # If a bin has remaining capacity of 5 and item is 3, remaining is 2. Score is -2.
    # -2 is greater than -7, so the bin with remaining capacity 5 is preferred.
    # However, we only want to consider bins that *can* fit the item.
    # For bins that cannot fit, the priority remains 0.

    # Calculate the remaining capacity for bins that can fit the item
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # To prioritize tighter fits, we want smaller remaining_after_placement values to have higher scores.
    # So, we can use negative of remaining_after_placement.
    # However, simply assigning -(remaining_after_placement) might lead to issues if all values are negative or very large.
    # A common approach for "best fit" (which this is similar to) is to prioritize by
    # the size of the remaining capacity. The smaller the remaining capacity, the better.
    # So, if we have `bins_remain_cap` and `item`, we are looking for the smallest
    # `bins_remain_cap[i] - item` where `bins_remain_cap[i] >= item`.
    # This smallest difference corresponds to the "best fit".
    # We can assign priority as 1 / (remaining_after_placement + epsilon) for a higher value for smaller remaining.
    # Or, a simpler way: we want to maximize (bin_remain_cap - item). This is not quite right.
    # We want to minimize (bin_remain_cap - item).
    # So, if we assign priority as `- (bin_remain_cap[i] - item)`, a smaller positive difference
    # leads to a larger negative number, which is what we want to avoid.
    #
    # Let's reconsider: First Fit means iterate through bins and pick the first one that fits.
    # This is not exactly First Fit, but more of a "Best Fit" like approach in terms of prioritization.
    # The prompt implies a priority score for *each* bin, then picking the highest.
    # For a First Fit strategy, the priority would be based on the *order* of the bins, not their capacity.
    # The prompt asks for a priority function that returns scores for *each* bin.
    #
    # Let's reinterpret "First Fit strategy" in the context of assigning priorities.
    # Perhaps it means: if a bin *can* fit the item, it gets a high priority.
    # If multiple bins can fit, how do we prioritize? The "First Fit" aspect might imply
    # prioritizing bins that have been open longer or are earlier in the list.
    #
    # Let's try to combine First Fit and capacity.
    # First Fit often implies using the earliest available bin that fits.
    # In an online scenario where we are given `bins_remain_cap`, it implies the order matters.
    # So, a bin earlier in the array that fits is generally preferred.
    # However, the question asks for a "priority score" for *each* bin.
    #
    # Let's consider a "Best Fit" approach disguised as a priority function for a "First Fit strategy":
    # The idea is to make the "best fitting" bins have a higher priority.
    # "Best fitting" means minimizing `bins_remain_cap[i] - item`.
    #
    # So, if `bins_remain_cap[i] >= item`:
    # Priority_i = a value that is higher for smaller `bins_remain_cap[i] - item`.
    # Let's assign priority as `1 / (bins_remain_cap[i] - item + 1e-9)` to avoid division by zero
    # and give higher priority to smaller remaining capacities.
    # Bins that cannot fit get 0 priority.

    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)

    return priorities
```
