```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an advanced priority function for the online Bin Packing Problem,
    emphasizing quadratically rewarded snugness, adaptive thresholds, and
    balancing exploration with exploitation.

    The priority is calculated as follows:
    1. Bins that cannot fit the item receive a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.
       b. Tight Fits (remaining capacity after packing is small and positive):
          High priority, quadratically rewarded as remaining capacity decreases.
       c. Good Fits (remaining capacity after packing is moderate): Priority
          decreases with remaining capacity, but with a gentler curve.
       d. Wasteful Fits (remaining capacity after packing is large):
          Significantly penalized. The penalty scales with the square of the
          excess capacity relative to the item size.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define thresholds adaptively.
    epsilon = 1e-9  # Tolerance for floating-point comparisons

    # Threshold for "tight" fits: remaining space is up to the item size.
    tight_fit_threshold = item

    # Threshold for "wasteful" fits: remaining space is significantly larger than item size.
    # Using a factor of the item size for relative comparison.
    wasteful_threshold = 2.0 * item # Reduced threshold for stricter "wasteful" definition

    # --- Scoring Logic ---
    scores = np.zeros_like(remaining_after_fit)

    # 1. Perfect Fits: Highest priority.
    perfect_mask = (remaining_after_fit < epsilon)
    scores[perfect_mask] = 100.0  # Reduced base score for perfect fits

    # 2. Tight Fits: Quadratically rewarded as remaining capacity decreases.
    # Higher reward for smaller remaining space.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)
    # Quadratic decay: (1 - remaining_after_fit / tight_fit_threshold)^2 * scale
    # This rewards smaller remaining_after_fit more significantly.
    tight_rewards = (1.0 - remaining_after_fit[tight_mask] / tight_fit_threshold)
    scores[tight_mask] = 50.0 * (tight_rewards**2) # Scale factor for tight fits

    # 3. Good Fits: Priority decreases with remaining capacity, but with a gentler curve.
    # Linear decrease for bins that are not tight but not yet wasteful.
    good_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)
    # Linear decay: max_good_score - (remaining_after_fit / wasteful_threshold) * max_good_score
    scores[good_mask] = 30.0 - (remaining_after_fit[good_mask] / wasteful_threshold) * 30.0
    scores[good_mask] = np.maximum(scores[good_mask], 1.0) # Ensure a minimum score for good fits

    # 4. Wasteful Fits: Significantly penalized.
    # Penalty increases with the square of the excess capacity relative to item size.
    wasteful_mask = (remaining_after_fit > wasteful_threshold)
    # Penalty function: - (excess_capacity / item_size)^2 * penalty_strength
    # This strongly discourages large remaining spaces.
    excess_capacity = remaining_after_fit[wasteful_mask] - wasteful_threshold
    penalty_strength = 5.0  # Controls how aggressively large remaining capacities are penalized.
    scores[wasteful_mask] = 1.0 - penalty_strength * (excess_capacity / item)**2
    scores[wasteful_mask] = np.maximum(scores[wasteful_mask], 0.1) # Ensure a minimum score even for wasteful

    # Ensure all calculated scores are non-negative.
    scores[scores < 0] = 0

    # Add exploration jitter: small random noise to scores to break ties and encourage exploration.
    # Jitter scale is relative to the range of potential scores (0 to 100).
    exploration_jitter_scale = 0.05
    jitter = np.random.uniform(-exploration_jitter_scale * 100.0, exploration_jitter_scale * 100.0, size=len(scores))
    final_scores = scores + jitter

    # Ensure jitter doesn't make scores negative.
    final_scores[final_scores < 0] = 0

    # Assign the calculated scores to the corresponding bins in the original priority array.
    priorities[can_fit_mask] = final_scores

    return priorities
```
