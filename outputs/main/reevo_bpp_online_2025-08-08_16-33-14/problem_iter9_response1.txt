```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for the online Bin Packing Problem,
    focusing on prioritizing tight fits, penalizing wasted space effectively,
    and using adaptive thresholds based on item size and bin capacities.
    This version introduces quadratic rewards for snugness and adaptive penalties.

    The priority is calculated as follows:
    1. Bins that cannot fit the item receive a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.
       b. Tight Fits (remaining capacity after packing is small and positive):
          Quadratically rewarded based on how close it is to a perfect fit.
       c. Good Fits (remaining capacity after packing is moderate): Priority
          decreases as remaining capacity increases, with a less aggressive decay.
       d. Wasteful Fits (remaining capacity after packing is large):
          Penalized based on the relative excess capacity compared to the item size.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        represents the priority score for placing the item in the corresponding bin.
        Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define thresholds adaptively, primarily based on item size for relative comparison.
    epsilon = 1e-9  # Tolerance for floating-point comparisons

    # Threshold for "tight" fits: remaining space is less than the item size.
    tight_fit_threshold = item

    # Threshold for "wasteful" fits: remaining space is significantly larger than item size.
    # Using a factor of the item size helps in relative comparison across different item sizes.
    # A factor of 3.0 means if the remaining space is more than 3 times the item size, it's wasteful.
    wasteful_threshold = 3.0 * item

    # --- Scoring Logic ---
    scores = np.zeros_like(remaining_after_fit, dtype=float)

    # 1. Perfect Fits: Highest priority. Assign a very high score.
    perfect_mask = (remaining_after_fit < epsilon)
    scores[perfect_mask] = 100.0  # Base score for perfect fit

    # 2. Tight Fits: Quadratically rewarded for snugness.
    # The closer to zero remaining capacity, the higher the reward.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)
    # Quadratic reward: reward increases as remaining_after_fit decreases.
    # The term (1 - remaining_after_fit[tight_mask] / tight_fit_threshold) is between 0 and 1.
    # Squaring it makes the reward higher for smaller remaining capacities.
    # Add a base value to ensure non-perfect tight fits have priority.
    tight_rewards = 1.0 - (remaining_after_fit[tight_mask] / tight_fit_threshold)
    scores[tight_mask] = 20.0 + 50.0 * (tight_rewards**2) # Quadratic reward

    # 3. Good Fits: Priority decreases with remaining capacity, but less steeply.
    # These are bins that fit, but are not "tight" and not yet "wasteful".
    good_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)
    # Use a decaying function, e.g., logarithmic, to give decreasing priority.
    # Adding 1 to the remaining capacity to avoid log(0) and to ensure decay starts slowly.
    scores[good_mask] = 15.0 / np.log1p(remaining_after_fit[good_mask]) # Logarithmic decay

    # 4. Wasteful Fits: Penalized based on relative excess capacity.
    # These bins have remaining space significantly larger than the item.
    wasteful_mask = (remaining_after_fit > wasteful_threshold)
    # Penalty is inversely proportional to the remaining capacity relative to item size.
    # A larger excess ratio leads to a stronger penalty (lower score).
    # The term (remaining_after_fit[wasteful_mask] / item) is > 3.0.
    penalty_factor = 5.0 # Controls how aggressive the penalty is.
    scores[wasteful_mask] = 5.0 / (1.0 + penalty_factor * (remaining_after_fit[wasteful_mask] / item)) # Rational penalty

    # Ensure all calculated scores are non-negative.
    scores[scores < 0] = 0

    # Add a small amount of random jitter to scores of bins with very similar calculated priorities.
    # This helps to break ties randomly and can improve exploration.
    exploration_jitter_scale = 0.05  # Controls the magnitude of the jitter relative to the score range.
    # Calculate jitter relative to the maximum possible score in the 'scores' array,
    # or a reasonable upper bound if scores can be highly variable.
    max_score_estimate = 100.0 # A safe upper bound for our scores
    jitter = np.random.uniform(-exploration_jitter_scale * max_score_estimate, exploration_jitter_scale * max_score_estimate, size=len(scores))
    final_scores = scores + jitter

    # Ensure jitter doesn't make scores negative.
    final_scores[final_scores < 0] = 0

    # Assign the calculated scores to the corresponding bins in the original priority array.
    priorities[can_fit_mask] = final_scores

    return priorities
```
