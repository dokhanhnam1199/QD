```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit strategy.

    The Best Fit strategy prioritizes bins that leave the minimum remaining capacity
    after placing the item. This strategy aims to fill bins as much as possible,
    potentially reducing the total number of bins used.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros. The calling function
    # would typically handle creating a new bin in this scenario.
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity after placing the item in suitable bins
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # The priority is the negative of the remaining capacity after placement.
    # We use the negative because we want the *minimum* remaining capacity
    # to have the highest priority (i.e., the most negative value).
    # Higher priority values mean the bin is a better fit.
    priorities[can_fit_mask] = -remaining_after_placement

    return priorities
```
