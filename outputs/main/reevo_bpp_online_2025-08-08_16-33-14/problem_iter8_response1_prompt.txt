{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements a refined priority function for online Bin Packing Problem,\n    prioritizing exact fits, then tighter fits, and penalizing overly large\n    remaining capacities. Includes a small random component for exploration.\n\n    Scoring logic:\n    1. Exact Fit: Highest priority (e.g., score of 1.0).\n    2. Tight Fit: Prioritize bins leaving minimal remaining capacity (e.g., inverse of remaining capacity).\n    3. Moderate Fit: Prioritize bins leaving some space, but less than loose fits.\n    4. Loose Fit: Lowest priority, but still assign a small positive score.\n    5. Exploration: Add a small random value to break ties and encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components based on remaining capacity after fit.\n    epsilon = 1e-9\n\n    # 1. Exact Fit: Highest priority\n    # Bins where remaining capacity is practically zero after fitting the item.\n    exact_fit_mask = (remaining_after_fit < epsilon)\n    priorities[can_fit_mask][exact_fit_mask] = 1.0\n\n    # 2. Tight Fit: Prioritize bins leaving minimal remaining capacity\n    # Remaining capacity is small but positive. Score is inversely proportional to remaining capacity.\n    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item * 0.5) # Threshold for \"tight\"\n    # Use a scaled inverse to give higher scores to smaller remaining capacities.\n    # Add a small constant to the denominator to avoid division by zero and to\n    # differentiate scores for very small remaining capacities.\n    priorities[can_fit_mask][tight_fit_mask] = 0.8 / (remaining_after_fit[tight_fit_mask] + epsilon)\n\n    # 3. Moderate Fit: Prioritize bins leaving some space, but not excessive.\n    # Remaining capacity is larger than tight fit threshold.\n    moderate_fit_mask = (remaining_after_fit > item * 0.5) & (remaining_after_fit <= item * 2.0) # Threshold for \"moderate\"\n    # Lower scores than tight fits, still inversely related to remaining capacity.\n    priorities[can_fit_mask][moderate_fit_mask] = 0.4 / (remaining_after_fit[moderate_fit_mask] + epsilon)\n\n    # 4. Loose Fit: Lowest priority, but still assign a small positive score.\n    # Remaining capacity is significantly larger than the item.\n    loose_fit_mask = (remaining_after_fit > item * 2.0)\n    # Assign a small constant score to encourage exploration of these bins if others are not ideal.\n    priorities[can_fit_mask][loose_fit_mask] = 0.1\n\n    # 5. Exploration: Add a small random component to break ties and encourage exploration.\n    exploration_factor = 0.05 # Reduced exploration factor\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor\n    priorities[can_fit_mask] += random_scores\n\n    # Ensure no score exceeds the highest priority (e.g., 1.0 plus random)\n    priorities[can_fit_mask] = np.minimum(priorities[can_fit_mask], 1.0 + exploration_factor)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved priority function for the online Bin Packing Problem,\n    focusing on tighter fits and stronger penalties for wasted space.\n\n    Priority calculation:\n    1. Bins that cannot fit the item get a priority of 0.\n    2. For bins that can fit the item:\n       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.\n       b. Tight Fits (small remaining capacity): High priority, decreasing quadratically\n          with remaining capacity to favor very snug fits.\n       c. Moderate Fits (medium remaining capacity): Moderate priority, decreasing\n          linearly with remaining capacity.\n       d. Wasteful Fits (large remaining capacity): Significantly penalized to strongly\n          discourage selection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates a higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define thresholds adaptively based on item size\n    epsilon = 1e-9\n    \n    # Threshold for \"tight\" fits: remaining space is close to zero.\n    # Let's define tight as less than or equal to 10% of the item size.\n    tight_fit_threshold = 0.1 * item\n\n    # Threshold for \"wasteful\" fits: remaining space is significantly larger than item size.\n    # Let's define wasteful as more than 2 times the item size.\n    wasteful_threshold = 2.0 * item\n\n    # Calculate scores\n    scores = np.zeros_like(remaining_after_fit)\n\n    # 1. Perfect Fits: Highest priority\n    perfect_mask = (remaining_after_fit < epsilon)\n    scores[perfect_mask] = 100.0\n\n    # 2. Tight Fits: High priority, decreasing quadratically with remaining capacity\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)\n    # Score: higher for smaller remaining_after_fit\n    # Using 1 / (1 + k*x^2) where k=5 to emphasize very small remaining spaces.\n    scores[tight_mask] = 80.0 * (1.0 / (1.0 + 5.0 * remaining_after_fit[tight_mask]**2))\n\n    # 3. Moderate Fits: Priority decreases linearly with remaining capacity\n    moderate_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)\n    # Score: higher for smaller remaining_after_fit\n    # Using 1 / (1 + k*x) where k=1 for a linear decay.\n    scores[moderate_mask] = 50.0 * (1.0 / (1.0 + remaining_after_fit[moderate_mask]))\n\n    # 4. Wasteful Fits: Significantly penalized\n    wasteful_mask = (remaining_after_fit > wasteful_threshold)\n    # Penalize based on how much excess space is left relative to item size.\n    # The penalty should be substantial to deter selection.\n    # Penalty = base_penalty + factor * (excess_space / item_size)\n    # The score will be negative.\n    scores[wasteful_mask] = -10.0 - 15.0 * (remaining_after_fit[wasteful_mask] / (item + epsilon))\n\n    # Ensure scores are non-negative for non-penalized categories, though wasteful can be negative.\n    # Scores for perfect, tight, moderate should ideally stay positive.\n    scores[tight_mask & (scores < 0)] = 0 # Should not happen with current formula, but good safety.\n    scores[moderate_mask & (scores < 0)] = 0\n\n    # Add a small random jitter for exploration. This helps break ties and explore.\n    exploration_factor = 0.05 # Jitter is 5% of the maximum possible score range (approx).\n    # Max score is 100, min can be negative. Let's base jitter on potential positive range.\n    max_positive_score = 100.0\n    jitter = np.random.rand(len(scores)) * exploration_factor * max_positive_score\n    final_scores = scores + jitter\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = final_scores\n\n    return priorities\n\n[Reflection]\nPenalize waste more, reward snug fits quadratically, adapt thresholds.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}