```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins that can perfectly fit the item,
    giving them the highest priority. Among bins that can fit, it
    then prioritizes those with less remaining capacity (tighter fit),
    as this aligns with the First Fit strategy of filling bins as much
    as possible. Bins that cannot fit the item are given a priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign a priority based on how tightly they fit.
    # We want to prioritize bins with less remaining capacity (tighter fit).
    # A simple way to achieve this is to assign a priority that is the inverse
    # of the remaining capacity (or a value derived from it).
    # To give exact fits the highest priority, we can use a large base value
    # and then subtract the remaining capacity.
    # If a bin fits the item exactly, the remaining capacity after fitting will be 0.
    # The value `bins_remain_cap[can_fit_mask] - item` represents the remaining capacity
    # *after* placing the item. A smaller value is better.
    # To make it a priority score where higher is better, we can negate this or
    # use a ranking strategy.
    # Let's use a strategy where perfect fits get the highest score, and among
    # non-perfect fits, the ones that leave less space are prioritized.

    # Calculate the remaining capacity *after* placing the item
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # Assign priorities:
    # A high base score for bins that fit.
    # A penalty for the amount of remaining space, so smaller remaining space is better.
    # Using the negative of remaining_after_fit will naturally rank tighter fits higher.
    # Let's assign a base priority to all fitting bins and then adjust based on remaining space.
    # A simple approach: assign a score inversely proportional to the remaining capacity,
    # but ensuring exact fits get the highest scores.
    # One way is to use the remaining capacity directly as priority, so smaller is better.
    # Then, we can invert it for our "higher is better" priority score.

    # Let's try assigning priority based on the 'emptiness' introduced by the item.
    # The less space left, the higher the priority.
    # For a bin with capacity C and item size I, the remaining space is C-I.
    # We want to prioritize smaller (C-I).
    # So, a priority score could be - (C-I). A smaller (C-I) results in a higher priority.

    # Create a score that is higher for bins with less remaining capacity after fitting.
    # We can use `bins_remain_cap[can_fit_mask] - item`. A smaller value here means a better fit.
    # To convert this to a "higher priority is better" score, we can take the negative.
    # To differentiate exact fits from others, we can add a small bonus.

    # Option 1: Simple inverse of remaining space (tighter fits get higher priority)
    # `bins_remain_cap[can_fit_mask] - item` will be >= 0.
    # We want smaller values here to have higher priority.
    # So, `- (bins_remain_cap[can_fit_mask] - item)` works.
    # For exact fits (remaining capacity is 0), priority is 0.
    # For bins with capacity 10 and item 3, remaining is 7, priority is -7.
    # For bins with capacity 10 and item 7, remaining is 3, priority is -3.
    # This means the tighter fit (-3) gets a higher priority than the looser fit (-7).
    # This seems reasonable.

    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    # Alternative strategy: rank bins by remaining capacity, with exact fits being special.
    # Let's assign a large positive value to exact fits, and for others,
    # use the negative remaining capacity.
    # exact_fit_mask = (bins_remain_cap == item) & can_fit_mask
    # priorities[exact_fit_mask] = 1e9  # Large value for exact fits
    # non_exact_fit_mask = can_fit_mask & ~exact_fit_mask
    # if np.any(non_exact_fit_mask):
    #     priorities[non_exact_fit_mask] = -(bins_remain_cap[non_exact_fit_mask] - item)

    # The first approach is simpler and still adheres to the spirit of First Fit
    # by prioritizing tighter fits. Let's stick with that.

    return priorities
```
