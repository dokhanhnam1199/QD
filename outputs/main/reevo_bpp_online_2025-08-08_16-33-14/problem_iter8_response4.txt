```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for online Bin Packing Problem,
    prioritizing tighter fits and using a weighted combination of fit categories.

    The function assigns scores to bins based on how well they fit an item:
    1. Perfect Fit: Bin's remaining capacity is exactly zero after packing. Highest priority.
    2. Tight Fit: Bin's remaining capacity after packing is small (<= item size). High priority.
    3. Moderate Fit: Bin's remaining capacity after packing is larger than item size but not excessively so (<= 2 * item size). Medium priority.
    4. Loose Fit: Bin's remaining capacity after packing is large (> 2 * item size). Lowest priority.

    The scoring is refined by:
    - Prioritizing tighter fits more strongly.
    - Using a weighted combination of scores from different fit categories.
    - Tuning scaling factors for better discrimination between categories.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for the corresponding bin. Higher scores indicate
        higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define thresholds for categorizing fits relative to the item size
    epsilon = 1e-9  # For floating-point comparisons, especially for perfect fits
    tight_threshold = item
    moderate_threshold = 2.0 * item

    # Initialize scores for different fit categories
    perfect_fit_scores = np.zeros_like(remaining_after_fit)
    tight_fit_scores = np.zeros_like(remaining_after_fit)
    moderate_fit_scores = np.zeros_like(remaining_after_fit)
    loose_fit_scores = np.zeros_like(remaining_after_fit)

    # Calculate scores for each category with adjusted scaling:
    # Perfect Fit: Highest score, indicating minimal waste.
    perfect_mask = (remaining_after_fit < epsilon)
    perfect_fit_scores[perfect_mask] = 10.0  # Strongest priority

    # Tight Fit: Prioritize bins that leave little remaining capacity after packing.
    # Score is inversely proportional to the remaining capacity, encouraging fuller bins.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_threshold)
    # Scaled by 1 + remaining capacity, higher score for smaller remaining capacity
    tight_fit_scores[tight_mask] = 5.0 / (1.0 + remaining_after_fit[tight_mask]) 

    # Moderate Fit: Bins that leave a moderate amount of space.
    # Score decreases as remaining capacity increases, but less steeply than tight fits.
    moderate_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= moderate_threshold)
    moderate_fit_scores[moderate_mask] = 3.0 / (1.0 + remaining_after_fit[moderate_mask]) 

    # Loose Fit: Bins that leave a significant amount of space.
    # These are less preferred, so they receive a low base score.
    loose_mask = (remaining_after_fit > moderate_threshold)
    loose_fit_scores[loose_mask] = 1.5 / (1.0 + remaining_after_fit[loose_mask])

    # Combine scores using weights to reflect the priority order: Perfect > Tight > Moderate > Loose.
    # Weights are tuned to emphasize tighter fits more significantly.
    combined_scores = (
        perfect_fit_scores * 1.0 +
        tight_fit_scores * 0.8 +
        moderate_fit_scores * 0.4 +
        loose_fit_scores * 0.1
    )

    # Add a small stochastic component for exploration.
    # This helps in occasional selection of less optimal bins, potentially leading to better overall packing.
    # The exploration factor is kept small to not override the primary scoring logic.
    exploration_factor = 0.03
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor
    combined_scores += random_scores

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = combined_scores

    return priorities
```
