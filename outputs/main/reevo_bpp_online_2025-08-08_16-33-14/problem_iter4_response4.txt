```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a hybrid strategy.

    This strategy prioritizes bins that offer a "tight fit" (minimizing leftover capacity)
    while also encouraging exploration by giving a slight boost to bins that are not too full,
    leaving more room for potentially larger future items. It also introduces a mechanism
    to avoid bins that are *too* close to being full, which might prevent fitting
    future items of moderate size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Determine which bins can fit the item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit, return all zeros

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Strategy 1: Tight Fit - prioritize bins that will have the least remaining capacity.
    # Higher score for smaller remaining capacity. Adding a small constant to the denominator
    # to ensure positivity and avoid division by zero. The `1.0 +` acts as a baseline score.
    tight_fit_scores = 1.0 / (1.0 + remaining_after_fit)

    # Strategy 2: Exploration Boost - encourage bins that have a moderate amount of leftover space.
    # This helps avoid "over-filling" bins too aggressively with small items, potentially
    # leaving them less useful for future, larger items.
    # We define "moderate" leftover space as being greater than a small epsilon,
    # but not excessively large. For simplicity, we'll give a small constant boost if
    # there's any positive remaining space, making it slightly more attractive than
    # a bin that would be filled to exact capacity (if that were possible).
    # The boost should be less than the tight_fit_score gain from reducing remaining space.
    exploration_boost_amount = 0.1
    exploration_scores = np.zeros_like(fitting_bins_caps)
    # Boost bins that have some room, but not bins that are exactly filled.
    exploration_scores[remaining_after_fit > 1e-6] = exploration_boost_amount


    # Strategy 3: Penalty for Over-tightness - discourage bins that would become
    # extremely full, leaving very little room for future items.
    # This penalty is applied when `remaining_after_fit` is very small, indicating
    # a nearly full bin. The penalty is higher the closer it is to zero remaining space.
    # A threshold is used to define "too tight".
    overtight_threshold = 0.1 # A small fraction of the item size, or absolute small value
    overtight_penalty_scale = 0.5 # How strongly to penalize over-tightness
    overtight_penalty = np.zeros_like(fitting_bins_caps)

    # Apply penalty if remaining capacity is less than the threshold
    penalty_mask = remaining_after_fit < overtight_threshold
    # The penalty is proportional to how much less than the threshold it is.
    # Normalize the penalty to be between 0 and overtight_penalty_scale.
    overtight_penalty[penalty_mask] = overtight_penalty_scale * (overtight_threshold - remaining_after_fit[penalty_mask]) / overtight_threshold

    # Combine scores:
    # Weight tight_fit_scores more heavily, add exploration boost, and subtract overtight penalty.
    # The goal is to achieve a balance: prioritize tightest fits, but not at the expense
    # of creating unusable bins with minimal remaining space.
    # Weights are heuristic and can be tuned.
    tight_fit_weight = 0.7
    exploration_weight = 0.3

    combined_scores = (tight_fit_weight * tight_fit_scores) + (exploration_weight * exploration_scores) - overtight_penalty

    # Assign the calculated scores to the corresponding bins
    priorities[can_fit_mask] = combined_scores

    # Ensure priorities are non-negative. While the logic above should generally produce
    # positive scores, it's good practice to clip any potential negatives.
    priorities[can_fit_mask] = np.maximum(0, priorities[can_fit_mask])

    return priorities
```
