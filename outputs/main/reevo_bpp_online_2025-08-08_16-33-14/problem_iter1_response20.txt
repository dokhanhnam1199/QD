```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins that can fit the item, and among those,
    it prefers bins that will have the least remaining capacity after packing
    the item (i.e., aiming for a tighter fit). If an item doesn't fit into any
    bin, all priorities are 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Find bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # For bins that can fit, calculate a "tightness" score.
    # A higher score means a tighter fit (less remaining capacity).
    # We use the negative of remaining capacity after packing, so larger negative numbers (tighter fit) become higher priority.
    # To ensure positive priorities for max-heap selection, we can invert the measure.
    # A good approach is to assign a large positive value to bins that can fit and then penalize them based on remaining capacity.
    # Let's assign a base priority if it fits, and then a bonus for a tighter fit.
    # Option 1: Inverse remaining capacity (higher means better fit)
    # To avoid division by zero, add a small epsilon or handle 0 remaining capacity specifically.
    # If remaining capacity is 0, this is the best fit.

    # Calculate remaining capacity after packing the item
    remaining_after_packing = bins_remain_cap[can_fit_mask] - item

    # The priority should be higher for bins that result in less remaining capacity.
    # A simple inverse relationship could work: higher remaining capacity means lower priority.
    # To make it work with typical maximization heuristics (higher score = better),
    # we can use something like 1 / (1 + remaining_capacity).
    # Or, a large constant minus remaining capacity. Let's use the latter for simplicity and to avoid division by small numbers.
    # We want the smallest remaining capacity to have the highest priority.
    # Let's assign a priority inversely proportional to the remaining capacity + a small epsilon to avoid division by zero.
    # A simpler approach that favors tighter fits is to assign a high score to bins that leave less space.

    # Assign a base priority if it fits, then subtract the remaining space to favor tighter fits.
    # The larger the value, the higher the priority.
    # Let's use a strategy where a tighter fit gets a higher priority.
    # We can assign a value related to the 'goodness' of the fit.
    # For example, the inverse of the remaining capacity, but that can lead to huge values.
    # A common approach is to simply prioritize bins that result in the smallest leftover space.
    # So, for bins that can fit: priority = - (remaining_capacity_after_packing)
    # To ensure positive scores for maximization, we can add a large constant.
    # Let's use the reciprocal of the remaining capacity after packing, plus a base value.

    # Calculate remaining capacities *after* placing the item
    remaining_after_packing = bins_remain_cap[can_fit_mask] - item

    # Higher priority for smaller remaining capacity.
    # Use the negative of remaining capacity, and add a constant to make it positive.
    # The value `bins_remain_cap[can_fit_mask].max()` serves as a large constant.
    # This means bins that become nearly full (small `remaining_after_packing`) get higher priority.
    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask].max() - remaining_after_packing

    # If there are bins with exactly 0 remaining capacity after packing, they should have the absolute highest priority.
    # Let's boost their priority.
    exact_fit_mask = (remaining_after_packing == 0)
    if np.any(exact_fit_mask):
        # Add an extra large value to exact fits
        priorities[can_fit_mask][exact_fit_mask] += 1e9

    return priorities
```
