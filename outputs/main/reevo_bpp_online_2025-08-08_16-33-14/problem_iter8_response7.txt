```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for the online Bin Packing Problem (BPP).
    This version strongly emphasizes perfect fits, penalizes significant wasted space,
    and uses adaptive thresholds that are more sensitive to the item size and
    the distribution of remaining capacities.

    The priority for each bin is calculated as follows:
    1. Bins that cannot fit the item receive a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity after packing is ~0): Receive the highest
          priority score, indicating minimal waste.
       b. Tight Fits (remaining capacity after packing is small, relative to item size):
          Receive high priority. The priority is inversely proportional to the
          remaining capacity, encouraging fuller bins.
       c. Moderate Fits (remaining capacity is larger than tight but not yet wasteful):
          Receive medium priority, with a decay that is less steep than tight fits.
       d. Wasteful Fits (remaining capacity is significantly large, relative to item size):
          Receive a heavily penalized score to strongly discourage their selection.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for the corresponding bin. Higher scores indicate
        higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define thresholds adaptively and with strong emphasis on item size
    epsilon = 1e-9  # For floating-point comparisons

    # Threshold for "perfect" fit: remaining capacity is effectively zero.
    perfect_fit_threshold = epsilon

    # Threshold for "tight" fit: remaining capacity is small, ideally less than or equal to item size.
    # This promotes filling bins as much as possible.
    tight_fit_threshold = item

    # Threshold for "wasteful" fit: remaining capacity is large.
    # We define "large" relative to the item size to make it adaptive.
    # A good heuristic is remaining space being significantly more than the item size.
    # Let's use 2 * item size as a starting point for "wasteful".
    wasteful_threshold = 2.0 * item

    # Calculate scores for the fitting bins
    scores = np.zeros_like(remaining_after_fit)

    # Category 1: Perfect Fits (Highest Priority)
    perfect_mask = (remaining_after_fit <= perfect_fit_threshold)
    scores[perfect_mask] = 1000.0  # Assign a very high score

    # Category 2: Tight Fits (High Priority)
    # These bins leave a small amount of space, ideally close to 0 but not perfect.
    # Priority is inversely proportional to remaining capacity to favor fuller bins.
    tight_mask = (remaining_after_fit > perfect_fit_threshold) & (remaining_after_fit <= tight_fit_threshold)
    # Using a function like 1/(1+x) or similar, scaled for a good range.
    # Smaller remaining_after_fit should yield higher scores.
    scores[tight_mask] = 50.0 / (1.0 + (remaining_after_fit[tight_mask] / item) * 2.0)

    # Category 3: Moderate Fits (Medium Priority)
    # These bins leave more space than tight fits but are not yet considered wasteful.
    # Priority decays more slowly than for tight fits.
    moderate_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)
    # Using a function like 1/(1+sqrt(x)) or similar.
    scores[moderate_mask] = 20.0 / (1.0 + np.sqrt(remaining_after_fit[moderate_mask] / item))

    # Category 4: Wasteful Fits (Low Priority / Penalized)
    # These bins leave a large amount of unused space.
    wasteful_mask = (remaining_after_fit > wasteful_threshold)
    # Penalize these bins significantly. The penalty should increase with excess space.
    # The score will be a base score minus a penalty that grows with excess capacity.
    # We want to strongly discourage these.
    base_score_wasteful = 5.0 # Small base score for potentially needing a new bin later
    penalty_factor = 15.0 # Controls how aggressively wasteful bins are penalized
    # Normalize penalty by item size to maintain some scale invariance.
    penalty = penalty_factor * (remaining_after_fit[wasteful_mask] - wasteful_threshold) / (item + epsilon)
    scores[wasteful_mask] = base_score_wasteful - penalty

    # Ensure all scores are non-negative
    scores[scores < 0] = 0

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = scores

    return priorities
```
