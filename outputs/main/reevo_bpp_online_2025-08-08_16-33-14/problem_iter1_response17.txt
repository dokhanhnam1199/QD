```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit strategy.

    In Random Fit, we randomly select a bin from the available bins that can
    accommodate the item. The priority function here will assign a higher
    priority to bins that have enough capacity for the item, and among those,
    it will give a slight preference to bins that will leave less remaining
    capacity after placing the item (i.e., better fit). The randomness is
    introduced by adding a small random noise.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    sufficient_capacity_mask = bins_remain_cap >= item

    # For bins with sufficient capacity, assign a priority based on how well they fit.
    # A better fit means less remaining capacity after placing the item.
    # We want higher priority for smaller remaining capacity.
    # Therefore, priority is inversely proportional to (bins_remain_cap - item).
    # We can achieve this by assigning a value like 1 / (bins_remain_cap - item + epsilon)
    # or more simply, by assigning a value that is lower for larger remaining capacities.
    # Let's use the negative of the remaining capacity after placing the item.
    # The "best" fit (minimum remaining capacity) will have the highest negative value,
    # which when adjusted will give higher priority.

    # A simple approach for "better fit" could be to assign a score based on
    # the remaining capacity *after* placing the item. Lower is better.
    # To make it a priority (higher is better), we can invert this.
    # For example, (max_possible_remaining - actual_remaining_after_fit).
    # A simpler heuristic is to favor bins that will be *almost full* after fitting.
    # So, prioritize bins where `bins_remain_cap - item` is small.

    # Let's assign a base priority to bins that can fit the item.
    # Then, we can add a bonus for a tighter fit.

    # Assign a higher score to bins that can fit the item.
    # For bins that can fit, calculate the "tightness" of the fit.
    # A tighter fit means bins_remain_cap - item is smaller.
    # Let's assign a score that's high for tight fits and low for loose fits.
    # We can use the reciprocal of the remaining capacity after fitting.
    # Ensure we don't divide by zero if a bin becomes exactly full.

    fitting_bins_indices = np.where(sufficient_capacity_mask)[0]

    if fitting_bins_indices.size > 0:
        # Calculate the remaining capacity *after* placing the item for fitting bins
        remaining_after_fit = bins_remain_cap[fitting_bins_indices] - item

        # Assign a base priority to bins that can fit. A common strategy
        # in bin packing is to try and fill bins as much as possible.
        # We can use the inverse of the remaining capacity as a proxy for "goodness of fit".
        # Smaller remaining capacity means better fit.
        # We want higher priority for better fits, so we can use something like:
        # priority = 1 / (remaining_capacity + epsilon) or a linear scale that
        # increases with tightness.

        # Let's use a simple score that rewards tighter fits.
        # If remaining_after_fit is 0, it's the best fit. If it's large, it's a loose fit.
        # We want higher scores for smaller remaining_after_fit.
        # A simple transformation: max_possible_residual - actual_residual
        # Where max_possible_residual is some upper bound, or simply that
        # any positive remaining capacity contributes to a score.
        # Let's try assigning a score proportional to the negative of remaining capacity,
        # then adding a random component for the "Random Fit" aspect.

        # For bins that can fit, their priority is based on how little capacity
        # will be left. A smaller `bins_remain_cap - item` should get higher priority.
        # Let's assign a score that is 100 - (remaining_capacity_after_fit)
        # This way, 0 remaining capacity gets priority 100, and so on.
        # To ensure it's "Random Fit", we add a small random noise to all valid bins.
        # This noise should be structured to give *some* preference but not deterministic.

        # Let's assign priority proportional to (bin_capacity - item).
        # No, we want to penalize bins that leave a lot of space.
        # So we want to reward bins that leave little space.
        # Score = (Bin_Capacity - item) reversed, maybe?
        # Or use a function that increases as (bin_capacity - item) decreases.

        # For Random Fit, the key is random selection among feasible bins.
        # We can assign a uniform high priority to all feasible bins, and then
        # randomly pick among them. Or, we can add randomness to the priority scores.

        # Let's make priority related to how full the bin will become.
        # Prioritize bins that will be closer to full.
        # Score = (Bin_Capacity - item). Higher score means more is used.
        # If capacity is 10, item is 7. Remaining is 3. We want this to have higher priority than
        # capacity 10, item 2. Remaining is 8.
        # So, priority score could be related to `item / bins_remain_cap`. No, this is wrong.

        # Let's use the complementary idea: priority is higher for bins that will have
        # *less* remaining capacity after the item is placed.
        # So, priority is higher for smaller values of `bins_remain_cap[i] - item`.
        # Let's define a score: `score = 1.0 / (bins_remain_cap[i] - item + 1e-6)` for fitting bins.
        # This gives higher scores to bins that are nearly full.

        # Random Fit: give all fitting bins equal high priority and then randomly pick one.
        # Or, add a random noise to the priorities of fitting bins.

        # Let's assign a baseline priority to all bins that fit.
        # Then, for a tighter fit, give a small bonus.
        # And for "Random Fit", add random noise.

        # Assign a base score for fitting bins. Let's say 1.
        # Then add a bonus for tighter fit. Tighter fit means `bins_remain_cap - item` is small.
        # Let's make the bonus proportional to the inverse of remaining capacity.
        # bonus = 1 / (bins_remain_cap[i] - item + 1e-6)  -- but this can be very large.

        # Simpler approach: Assign a score based on the remaining capacity *after* fitting.
        # We want bins that leave less capacity to have higher priority.
        # Let's assign `priority = (max_capacity_possible) - (bins_remain_cap[i] - item)`.
        # This doesn't quite capture the "random fit" well.

        # For Random Fit, we typically iterate through bins and pick the first one that fits.
        # If we want a priority function, we should give some weight.
        # A simple "Random Fit" heuristic: give a random priority to all bins that can fit.
        # For example, assign a random number between 0 and 1 to bins that fit.
        # Or, assign a random priority value, perhaps emphasizing the best fits slightly.

        # Let's create a base priority for bins that fit.
        # We want to prioritize bins that have less space remaining *after* the item is placed.
        # So, if bin_rem_cap = 10, item = 7, remaining = 3.
        # If bin_rem_cap = 10, item = 2, remaining = 8.
        # We prefer the first case (remaining = 3) for a tighter fit.
        # A higher priority should go to smaller remaining capacity.
        # Let's use a priority inversely related to remaining capacity after fit.
        # A simple way: `priority = some_large_value - (bins_remain_cap - item)` for fitting bins.

        # A more direct "Random Fit" priority would be to simply assign a random number
        # to all bins that fit, and a zero to those that don't.
        # The highest random number among fitting bins wins.

        # Option 1: Assign random scores to fitting bins.
        random_scores = np.random.rand(bins_remain_cap.shape[0])
        priorities[sufficient_capacity_mask] = random_scores[sufficient_capacity_mask]

        # Option 2: Give a slight preference to better fits, then add randomness.
        # For bins that can fit, calculate remaining capacity after placement.
        # `remaining_after_fit = bins_remain_cap[sufficient_capacity_mask] - item`
        # A good fit means `remaining_after_fit` is small.
        # Let's assign a score that increases as `remaining_after_fit` decreases.
        # `fit_score = 1.0 / (remaining_after_fit + 1e-6)`
        # Now add randomness to this fit_score.
        # `priorities[sufficient_capacity_mask] = fit_score + np.random.rand(fitting_bins_indices.size) * 0.1`

        # For a simple "Random Fit", assigning random priorities to feasible bins is appropriate.
        # The higher the random priority, the more likely that bin is chosen among feasible ones.
        # This means the selection will be random among available bins.

        # Let's assign a value that is based on the remaining capacity but also randomized.
        # A simple "Random Fit" prioritizes any bin that fits, and the selection is random among them.
        # So, assigning a random priority to all bins that fit effectively achieves this.

        # The core of Random Fit is to randomly select an eligible bin.
        # If we need a priority score for *each* bin, then for eligible bins,
        # we should assign scores such that a random selection is likely.
        # A uniform random score for all eligible bins achieves this.

        # Let's refine this: assign a high random score to bins that fit.
        # This makes them more likely to be chosen than bins that don't fit.
        # The selection among those with high random scores will be random.
        priorities = np.zeros_like(bins_remain_cap, dtype=float)
        eligible_bins = np.where(bins_remain_cap >= item)[0]

        if eligible_bins.size > 0:
            # Assign a random priority to each eligible bin.
            # Higher random numbers increase the chance of selection.
            priorities[eligible_bins] = np.random.rand(eligible_bins.shape[0])
        else:
            # If no bin can fit the item, this function might not be called,
            # or it implies an unsolveable state for this item.
            # Return zeros or signal an error as appropriate.
            pass

    return priorities
```
