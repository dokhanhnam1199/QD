```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved priority function for the online Bin Packing Problem.

    This heuristic aims to balance several objectives:
    1. **Tight Fit (Best Fit):** Prioritize bins that leave the minimum remaining capacity
       after packing the item. This minimizes wasted space in the short term.
    2. **Avoid Over-Saturation (Penalty):** Penalize bins that will have very little
       remaining capacity after packing. This prevents a bin from becoming unusable
       for even small future items.
    3. **Encourage Exploration (Boost):** Provide a slight boost to bins that will have
       a moderate amount of remaining capacity. This encourages utilizing a wider
       range of bins, potentially leading to better overall packing.

    The function calculates priority scores for bins that can fit the item. Bins that
    cannot fit the item receive a score of 0.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining capacity
                         of a bin.

    Returns:
        A numpy array of the same size as `bins_remain_cap`, containing the priority
        score for each bin. Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the current item
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item, return all zeros.

    # Get the remaining capacities of bins that can fit the item
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # --- Priority Components ---

    # 1. Tight Fit Score (Inverse of remaining capacity + epsilon to avoid division by zero)
    # Higher score for smaller remaining_after_fit.
    tight_fit_scores = 1.0 / (remaining_after_fit + 1e-9)

    # 2. Over-Saturation Penalty
    # Penalize bins where remaining_after_fit is very small.
    # Define "very small" as a fraction of the item size, e.g., less than 10% of item size.
    # The penalty should be more severe for smaller remaining capacities.
    penalty_threshold = 0.1 * item
    penalty_scores = np.zeros_like(fitting_bins_caps)

    # Apply penalty to bins that are nearly full
    nearly_full_mask = (remaining_after_fit > 0) & (remaining_after_fit <= penalty_threshold)
    if np.any(nearly_full_mask):
        # Calculate penalty: -1 for the smallest remaining capacity, 0 for the threshold.
        # This penalizes bins that are *really* full more heavily.
        penalty_scores[nearly_full_mask] = -1.0 * (1.0 - (remaining_after_fit[nearly_full_mask] / penalty_threshold))

    # 3. Exploration Boost
    # Boost bins that leave a moderate amount of space. This space should be
    # at least the size of the item itself, but not excessively large.
    # Let's define the boost range from `item` to `2 * item` remaining capacity.
    boost_min_remaining = item
    boost_max_remaining = 3 * item  # Tunable parameter
    exploration_scores = np.zeros_like(fitting_bins_caps)

    boost_mask = (remaining_after_fit > boost_min_remaining) & (remaining_after_fit <= boost_max_remaining)
    if np.any(boost_mask):
        # The boost is highest when remaining_after_fit is close to boost_min_remaining
        # and decreases as it approaches boost_max_remaining.
        # Normalize the remaining capacity within the boost range.
        normalized_remaining = (remaining_after_fit[boost_mask] - boost_min_remaining) / (boost_max_remaining - boost_min_remaining)
        # Invert the normalized value to give higher boost to smaller remaining capacities in this range.
        exploration_scores[boost_mask] = 0.5 * (1.0 - normalized_remaining) # Tunable boost strength

    # --- Combine Scores ---
    # Assign weights to balance the strategies.
    # Tight fit is the primary driver, penalty reduces priority for near-full bins,
    # exploration boost slightly increases priority for moderately spacious bins.
    combined_scores = (1.0 * tight_fit_scores) + penalty_scores + exploration_scores

    # Assign the calculated scores to the corresponding bins in the main priorities array
    priorities[can_fit_mask] = combined_scores

    return priorities
```
