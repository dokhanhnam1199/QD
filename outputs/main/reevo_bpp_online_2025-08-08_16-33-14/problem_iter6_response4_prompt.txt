{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements a refined priority function for the online Bin Packing Problem,\n    focusing on a more nuanced \"best fit\" strategy with penalized over-fitting.\n\n    The function categorizes bins based on their remaining capacity relative to the item size:\n    1. Perfect Fit: Remaining capacity is zero (or very close to it). Highest priority.\n    2. Tight Fit: Remaining capacity is positive but not excessively large. Prioritized by\n       how little space is left (closer to zero is better).\n    3. Moderate Fit: Remaining capacity is larger, but still leaves a \"reasonable\" amount\n       of space. These bins are prioritized less than tight fits, but more than loose fits.\n    4. Loose Fit: Remaining capacity is very large. Lowest priority among fitting bins,\n       with a small bonus to encourage exploration of potentially useful large spaces.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the current item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Epsilon for handling floating-point comparisons, especially for perfect fits.\n    epsilon = 1e-6\n\n    # --- Scoring Components ---\n    # We aim to create scores where higher values mean higher priority.\n\n    # Perfect Fit: Highest priority. Give a large, fixed score.\n    perfect_fit_score_value = 100.0\n    perfect_mask = (remaining_after_fit < epsilon)\n    priorities[can_fit_mask][perfect_mask] = perfect_fit_score_value\n\n    # Tight Fit: Bins where remaining capacity is positive but small.\n    # These are good candidates for \"best fit\".\n    # Prioritize bins that leave LESS remaining space (closer to zero).\n    # Use a score that is inversely proportional to remaining capacity,\n    # but avoid division by zero by adding 1.\n    # Penalize bins that leave *too much* space within this \"tight\" category.\n    # We define \"tight\" as remaining_after_fit <= item size.\n    tight_threshold = item\n    tight_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= tight_threshold)\n    if np.any(tight_mask):\n        # Score is inversely proportional to remaining space.\n        # Add a small constant to avoid division by zero if remaining_after_fit is exactly 0 (though epsilon handles this)\n        # Higher score for smaller remaining_after_fit.\n        tight_scores = 1.0 / (remaining_after_fit[tight_mask] + epsilon)\n        # Scale these scores to be lower than perfect fits, but still high.\n        priorities[can_fit_mask][tight_mask] += tight_scores * 5.0 # Scaled down\n\n    # Moderate Fit: Bins where remaining capacity is larger than \"tight\" but not excessively so.\n    # We want to encourage fits that leave *some* room, but not vast amounts.\n    # Let's define \"moderate\" as remaining_after_fit > item size and up to, say, 2*item size.\n    moderate_threshold = 2.0 * item\n    moderate_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= moderate_threshold)\n    if np.any(moderate_mask):\n        # Score inversely proportional to remaining space, but with a smaller weight.\n        # This encourages using bins that don't leave *too much* excess.\n        moderate_scores = 1.0 / (remaining_after_fit[moderate_mask] + epsilon)\n        # Scale these scores lower than tight fits.\n        priorities[can_fit_mask][moderate_mask] += moderate_scores * 2.0 # Scaled down further\n\n    # Loose Fit: Bins with very large remaining capacity.\n    # These are least preferred for \"best fit\" but might be needed.\n    # Give them a very low priority, but a small positive score for exploration.\n    # Define \"loose\" as remaining_after_fit > 2*item size.\n    loose_mask = (remaining_after_fit > moderate_threshold)\n    if np.any(loose_mask):\n        # Give a small constant boost to these bins.\n        # Could also use an inverse relationship scaled very low.\n        loose_scores = 0.1 # Small constant boost for exploration\n        priorities[can_fit_mask][loose_mask] += loose_scores\n\n    # --- Adjustments and Exploration ---\n    # Add a small stochastic component to all fitting bins to encourage exploration\n    # and break ties. The factor should be small enough not to override deterministic preferences.\n    exploration_noise_factor = 0.05\n    if np.any(can_fit_mask):\n        noise = np.random.rand(len(fitting_bins_caps)) * exploration_noise_factor\n        priorities[can_fit_mask] += noise\n\n    # Ensure no negative priorities and normalize if needed (optional, but good practice for some algorithms)\n    priorities = np.maximum(priorities, 0)\n\n    # For bins that cannot fit the item, their priority remains 0.\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a hybrid strategy.\n\n    This strategy prioritizes bins that offer a \"tight fit\" (minimizing leftover capacity),\n    while also encouraging exploration by giving a slight boost to bins that are not too full,\n    leaving more room for potentially larger future items. It also introduces a mechanism\n    to avoid bins that are *too* close to being full, which might prevent fitting\n    future items of moderate size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Determine which bins can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit, return all zeros\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n\n    # Strategy 1: Tight Fit (Best Fit heuristic)\n    # Prioritize bins that will have the least remaining capacity after packing.\n    remaining_after_fit = fitting_bins_caps - item\n    # Higher score for smaller remaining_after_fit. Adding 1.0 prevents division by zero.\n    tight_fit_scores = 1.0 / (1.0 + remaining_after_fit)\n\n    # Strategy 2: Encouraging Exploration / Avoiding Over-saturation\n    # Boost bins that have a \"good amount\" of remaining space, but not too much.\n    # This helps to keep some bins with ample space open for potentially larger future items.\n    # We define \"good amount\" as being larger than the item itself, but not exceeding a certain fraction of the bin's total capacity.\n    # Let's also slightly penalize bins that are *too* close to being full (e.g., remaining_after_fit < 0.1 * item),\n    # as these might become unusable for many future items.\n\n    # Calculate a penalty for bins that are almost full\n    # Penalty is higher for smaller remaining capacities.\n    almost_full_penalty_threshold = 0.1 * item\n    penalty_scores = np.zeros_like(fitting_bins_caps)\n    # Apply penalty if remaining capacity is small and positive\n    nearly_full_mask = (remaining_after_fit > 0) & (remaining_after_fit <= almost_full_penalty_threshold)\n    # The penalty is inversely proportional to how close it is to the threshold, scaled.\n    # We want a larger negative score for smaller `remaining_after_fit`.\n    penalty_scores[nearly_full_mask] = -0.5 * (1 - (remaining_after_fit[nearly_full_mask] / almost_full_penalty_threshold))\n\n    # Add a small boost for bins with moderate remaining capacity (encourages exploration).\n    # Bins with remaining capacity significantly larger than the item but not excessively large.\n    # Let's say remaining capacity is between 1x and 5x the item size.\n    exploration_boost_min = item\n    exploration_boost_max = 5 * item\n    exploration_mask = (remaining_after_fit > exploration_boost_min) & (remaining_after_fit <= exploration_boost_max)\n    exploration_scores = np.zeros_like(fitting_bins_caps)\n    # Boost is higher for capacity closer to `exploration_boost_min`.\n    exploration_scores[exploration_mask] = 0.1 * (1 - (remaining_after_fit[exploration_mask] - exploration_boost_min) / (exploration_boost_max - exploration_boost_min))\n\n\n    # Combine scores: Prioritize tight fit, apply penalty for nearly full bins, and add exploration boost.\n    # Weights are chosen to balance these strategies.\n    combined_scores = (0.8 * tight_fit_scores) + penalty_scores + exploration_scores\n\n    # Assign the calculated scores to the corresponding bins\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities\n\n[Reflection]\nPrioritize tight fits, penalize near-full bins, and boost moderate remaining capacities.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}