{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved priority function for the online Bin Packing Problem,\n    focusing on tighter fits and stronger penalties for wasted space.\n\n    Priority calculation:\n    1. Bins that cannot fit the item get a priority of 0.\n    2. For bins that can fit the item:\n       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.\n       b. Tight Fits (small remaining capacity): High priority, decreasing quadratically\n          with remaining capacity to favor very snug fits.\n       c. Moderate Fits (medium remaining capacity): Moderate priority, decreasing\n          linearly with remaining capacity.\n       d. Wasteful Fits (large remaining capacity): Significantly penalized to strongly\n          discourage selection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates a higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define thresholds adaptively based on item size\n    epsilon = 1e-9\n    \n    # Threshold for \"tight\" fits: remaining space is close to zero.\n    # Let's define tight as less than or equal to 10% of the item size.\n    tight_fit_threshold = 0.1 * item\n\n    # Threshold for \"wasteful\" fits: remaining space is significantly larger than item size.\n    # Let's define wasteful as more than 2 times the item size.\n    wasteful_threshold = 2.0 * item\n\n    # Calculate scores\n    scores = np.zeros_like(remaining_after_fit)\n\n    # 1. Perfect Fits: Highest priority\n    perfect_mask = (remaining_after_fit < epsilon)\n    scores[perfect_mask] = 100.0\n\n    # 2. Tight Fits: High priority, decreasing quadratically with remaining capacity\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_fit_threshold)\n    # Score: higher for smaller remaining_after_fit\n    # Using 1 / (1 + k*x^2) where k=5 to emphasize very small remaining spaces.\n    scores[tight_mask] = 80.0 * (1.0 / (1.0 + 5.0 * remaining_after_fit[tight_mask]**2))\n\n    # 3. Moderate Fits: Priority decreases linearly with remaining capacity\n    moderate_mask = ~perfect_mask & ~tight_mask & (remaining_after_fit <= wasteful_threshold)\n    # Score: higher for smaller remaining_after_fit\n    # Using 1 / (1 + k*x) where k=1 for a linear decay.\n    scores[moderate_mask] = 50.0 * (1.0 / (1.0 + remaining_after_fit[moderate_mask]))\n\n    # 4. Wasteful Fits: Significantly penalized\n    wasteful_mask = (remaining_after_fit > wasteful_threshold)\n    # Penalize based on how much excess space is left relative to item size.\n    # The penalty should be substantial to deter selection.\n    # Penalty = base_penalty + factor * (excess_space / item_size)\n    # The score will be negative.\n    scores[wasteful_mask] = -10.0 - 15.0 * (remaining_after_fit[wasteful_mask] / (item + epsilon))\n\n    # Ensure scores are non-negative for non-penalized categories, though wasteful can be negative.\n    # Scores for perfect, tight, moderate should ideally stay positive.\n    scores[tight_mask & (scores < 0)] = 0 # Should not happen with current formula, but good safety.\n    scores[moderate_mask & (scores < 0)] = 0\n\n    # Add a small random jitter for exploration. This helps break ties and explore.\n    exploration_factor = 0.05 # Jitter is 5% of the maximum possible score range (approx).\n    # Max score is 100, min can be negative. Let's base jitter on potential positive range.\n    max_positive_score = 100.0\n    jitter = np.random.rand(len(scores)) * exploration_factor * max_positive_score\n    final_scores = scores + jitter\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = final_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved priority function for the online Bin Packing Problem.\n\n    This heuristic aims to balance several objectives:\n    1. **Tight Fit (Best Fit):** Prioritize bins that leave the minimum remaining capacity\n       after packing the item. This minimizes wasted space in the short term.\n    2. **Avoid Over-Saturation (Penalty):** Penalize bins that will have very little\n       remaining capacity after packing. This prevents a bin from becoming unusable\n       for even small future items.\n    3. **Encourage Exploration (Boost):** Provide a slight boost to bins that will have\n       a moderate amount of remaining capacity. This encourages utilizing a wider\n       range of bins, potentially leading to better overall packing.\n\n    The function calculates priority scores for bins that can fit the item. Bins that\n    cannot fit the item receive a score of 0.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element is the remaining capacity\n                         of a bin.\n\n    Returns:\n        A numpy array of the same size as `bins_remain_cap`, containing the priority\n        score for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can accommodate the current item\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item, return all zeros.\n\n    # Get the remaining capacities of bins that can fit the item\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # --- Priority Components ---\n\n    # 1. Tight Fit Score (Inverse of remaining capacity + epsilon to avoid division by zero)\n    # Higher score for smaller remaining_after_fit.\n    tight_fit_scores = 1.0 / (remaining_after_fit + 1e-9)\n\n    # 2. Over-Saturation Penalty\n    # Penalize bins where remaining_after_fit is very small.\n    # Define \"very small\" as a fraction of the item size, e.g., less than 10% of item size.\n    # The penalty should be more severe for smaller remaining capacities.\n    penalty_threshold = 0.1 * item\n    penalty_scores = np.zeros_like(fitting_bins_caps)\n\n    # Apply penalty to bins that are nearly full\n    nearly_full_mask = (remaining_after_fit > 0) & (remaining_after_fit <= penalty_threshold)\n    if np.any(nearly_full_mask):\n        # Calculate penalty: -1 for the smallest remaining capacity, 0 for the threshold.\n        # This penalizes bins that are *really* full more heavily.\n        penalty_scores[nearly_full_mask] = -1.0 * (1.0 - (remaining_after_fit[nearly_full_mask] / penalty_threshold))\n\n    # 3. Exploration Boost\n    # Boost bins that leave a moderate amount of space. This space should be\n    # at least the size of the item itself, but not excessively large.\n    # Let's define the boost range from `item` to `2 * item` remaining capacity.\n    boost_min_remaining = item\n    boost_max_remaining = 3 * item  # Tunable parameter\n    exploration_scores = np.zeros_like(fitting_bins_caps)\n\n    boost_mask = (remaining_after_fit > boost_min_remaining) & (remaining_after_fit <= boost_max_remaining)\n    if np.any(boost_mask):\n        # The boost is highest when remaining_after_fit is close to boost_min_remaining\n        # and decreases as it approaches boost_max_remaining.\n        # Normalize the remaining capacity within the boost range.\n        normalized_remaining = (remaining_after_fit[boost_mask] - boost_min_remaining) / (boost_max_remaining - boost_min_remaining)\n        # Invert the normalized value to give higher boost to smaller remaining capacities in this range.\n        exploration_scores[boost_mask] = 0.5 * (1.0 - normalized_remaining) # Tunable boost strength\n\n    # --- Combine Scores ---\n    # Assign weights to balance the strategies.\n    # Tight fit is the primary driver, penalty reduces priority for near-full bins,\n    # exploration boost slightly increases priority for moderately spacious bins.\n    combined_scores = (1.0 * tight_fit_scores) + penalty_scores + exploration_scores\n\n    # Assign the calculated scores to the corresponding bins in the main priorities array\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities\n\n[Reflection]\nPrioritize tight fits, penalize over-saturation, and optionally boost exploration.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}