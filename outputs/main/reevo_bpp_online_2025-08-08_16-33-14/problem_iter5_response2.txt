```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a refined priority function for online Bin Packing Problem,
    incorporating a more nuanced scoring system based on fit tightness
    and penalizing overly large remaining capacities.

    Scoring logic:
    1. Perfect Fit: Highest priority.
    2. Tight Fit: Prioritize bins leaving minimal remaining capacity (but not zero).
    3. Moderate Fit: Prioritize bins leaving some space but not excessive.
    4. Loose Fit: Least priority, but still assign a small score to encourage exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define score components based on remaining capacity after fit.
    # A small epsilon to differentiate from true zero for perfect fits.
    epsilon = 1e-9

    # Thresholds for categorizing fits (relative to item size for better scaling)
    # Bins with remaining_after_fit < epsilon are perfect fits.
    # Bins with epsilon <= remaining_after_fit <= item are tight fits.
    # Bins with item < remaining_after_fit <= 2*item are moderate fits.
    # Bins with remaining_after_fit > 2*item are loose fits.

    # Score for perfect fits (highest priority)
    perfect_fit_score_val = 10.0
    perfect_mask = (remaining_after_fit < epsilon)
    priorities[can_fit_mask][perfect_mask] = perfect_fit_score_val

    # Score for tight fits (prioritize smaller remaining capacity)
    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item)
    # Inverse relationship with remaining capacity, scaled to avoid large values.
    # Adding 1 to denominator to prevent division by zero if remaining_after_fit is exactly 0 (handled by epsilon).
    # The larger the remaining_after_fit, the lower the score.
    priorities[can_fit_mask][tight_fit_mask] = 5.0 / (1.0 + remaining_after_fit[tight_fit_mask])

    # Score for moderate fits (prefer smaller remaining capacity within this range)
    moderate_fit_mask = (remaining_after_fit > item) & (remaining_after_fit <= 2.0 * item)
    # Similar inverse relationship, but with a lower base score than tight fits.
    priorities[can_fit_mask][moderate_fit_mask] = 2.0 / (1.0 + remaining_after_fit[moderate_fit_mask])

    # Score for loose fits (penalize very large remaining capacities)
    loose_fit_mask = (remaining_after_fit > 2.0 * item)
    # Assign a very small positive score to encourage exploration, but less than tighter fits.
    # This score decreases rapidly as remaining capacity increases.
    priorities[can_fit_mask][loose_fit_mask] = 0.5 / (1.0 + remaining_after_fit[loose_fit_mask])

    # Add a small random component for exploration. This helps to break ties and
    # explore different bin choices when scores are very similar.
    exploration_factor = 0.1
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor
    priorities[can_fit_mask] += random_scores

    return priorities
```
