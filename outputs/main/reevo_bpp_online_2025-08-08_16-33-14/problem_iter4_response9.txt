```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved hybrid priority function for online Bin Packing Problem.
    This version refines the scoring by prioritizing perfect fits, then tight fits,
    and then good fits, while still allowing for exploration.

    Categories:
    1. Perfect Fit: remaining capacity is zero. Highest priority.
    2. Tight Fit: remaining capacity is small, specifically <= item size. High priority.
    3. Good Fit: remaining capacity is moderate, specifically > item size but <= 2 * item size. Medium priority.
    4. Loose Fit: remaining capacity is large, specifically > 2 * item size. Lower priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define score components based on remaining capacity after fit
    epsilon = 1e-9  # For handling perfect fits and avoiding division by zero

    # Initialize scores for different fit categories
    perfect_fit_scores = np.zeros_like(remaining_after_fit)
    tight_fit_scores = np.zeros_like(remaining_after_fit)
    good_fit_scores = np.zeros_like(remaining_after_fit)
    loose_fit_scores = np.zeros_like(remaining_after_fit)

    # Thresholds for categorizing fits (relative to item size)
    tight_threshold = item
    good_threshold = 2.0 * item

    # Assign scores based on categories, prioritizing perfect > tight > good > loose
    # Perfect Fit: Highest score.
    perfect_mask = (remaining_after_fit < epsilon)
    perfect_fit_scores[perfect_mask] = 100.0

    # Tight Fit: Prioritize bins that leave little room, scaled inversely with remaining space.
    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_threshold)
    # Score decreases as remaining_after_fit increases within the tight range.
    tight_fit_scores[tight_mask] = 10.0 / (1.0 + remaining_after_fit[tight_mask])

    # Good Fit: Prioritize bins that leave a moderate amount of room, scaled less aggressively.
    good_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= good_threshold)
    # Score decreases as remaining_after_fit increases within the good range.
    good_fit_scores[good_mask] = 5.0 / (1.0 + remaining_after_fit[good_mask])

    # Loose Fit: Lowest priority among fitting bins, provide minimal boost for exploration.
    loose_mask = (remaining_after_fit > good_threshold)
    loose_fit_scores[loose_mask] = 1.0 / (1.0 + remaining_after_fit[loose_mask])

    # Combine scores using weights to reflect the priority order
    combined_scores = (
        perfect_fit_scores * 1.0 +
        tight_fit_scores * 0.7 +
        good_fit_scores * 0.4 +
        loose_fit_scores * 0.1
    )

    # Add a small random component for exploration to all fitting bins
    # This helps in breaking ties and exploring less obvious choices occasionally.
    exploration_factor = 0.05
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor
    combined_scores += random_scores

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = combined_scores

    return priorities
```
