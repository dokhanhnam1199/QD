```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for packing an item into bins, prioritizing tight fits.

    This heuristic prioritizes bins that can accommodate the item. Among those,
    it assigns a higher priority to bins that will have the least remaining
    capacity after packing (i.e., a tighter fit). Bins that are too small
    for the item receive a priority of 0.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
        Higher scores indicate a more desirable bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that have enough remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros.
    if not np.any(can_fit_mask):
        return priorities

    # For bins that can fit the item, calculate the remaining capacity *after* packing.
    # The goal is to minimize this remaining capacity for a tighter fit.
    remaining_after_packing = bins_remain_cap[can_fit_mask] - item

    # To prioritize tighter fits (smaller remaining_after_packing), we can use
    # the negative of the remaining capacity. Since priority functions typically
    # aim to maximize the score, we can transform this. A common strategy is to
    # use a large value minus the remaining capacity, ensuring that smaller
    # remaining capacities yield higher scores. Using the maximum available
    # capacity as the large constant helps normalize scores relative to bin sizes.
    # The `bins_remain_cap[can_fit_mask].max()` is used to ensure that even
    # with the subtraction, the priority remains positive and is scaled by
    # the general magnitude of bin capacities.
    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask].max() - remaining_after_packing

    # Add a strong preference for bins that result in exactly zero remaining capacity
    # (perfect fits). This can be achieved by adding a very large constant to these.
    exact_fit_mask = (remaining_after_packing == 0)
    if np.any(exact_fit_mask):
        # A large epsilon to ensure exact fits are always preferred over near-fits.
        priorities[can_fit_mask][exact_fit_mask] += 1e9

    return priorities
```
