```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a refined priority function for online Bin Packing Problem,
    prioritizing exact fits, then tighter fits, and penalizing overly large
    remaining capacities. Includes a small random component for exploration.

    Scoring logic:
    1. Exact Fit: Highest priority (e.g., score of 1.0).
    2. Tight Fit: Prioritize bins leaving minimal remaining capacity (e.g., inverse of remaining capacity).
    3. Moderate Fit: Prioritize bins leaving some space, but less than loose fits.
    4. Loose Fit: Lowest priority, but still assign a small positive score.
    5. Exploration: Add a small random value to break ties and encourage exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # Define score components based on remaining capacity after fit.
    epsilon = 1e-9

    # 1. Exact Fit: Highest priority
    # Bins where remaining capacity is practically zero after fitting the item.
    exact_fit_mask = (remaining_after_fit < epsilon)
    priorities[can_fit_mask][exact_fit_mask] = 1.0

    # 2. Tight Fit: Prioritize bins leaving minimal remaining capacity
    # Remaining capacity is small but positive. Score is inversely proportional to remaining capacity.
    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item * 0.5) # Threshold for "tight"
    # Use a scaled inverse to give higher scores to smaller remaining capacities.
    # Add a small constant to the denominator to avoid division by zero and to
    # differentiate scores for very small remaining capacities.
    priorities[can_fit_mask][tight_fit_mask] = 0.8 / (remaining_after_fit[tight_fit_mask] + epsilon)

    # 3. Moderate Fit: Prioritize bins leaving some space, but not excessive.
    # Remaining capacity is larger than tight fit threshold.
    moderate_fit_mask = (remaining_after_fit > item * 0.5) & (remaining_after_fit <= item * 2.0) # Threshold for "moderate"
    # Lower scores than tight fits, still inversely related to remaining capacity.
    priorities[can_fit_mask][moderate_fit_mask] = 0.4 / (remaining_after_fit[moderate_fit_mask] + epsilon)

    # 4. Loose Fit: Lowest priority, but still assign a small positive score.
    # Remaining capacity is significantly larger than the item.
    loose_fit_mask = (remaining_after_fit > item * 2.0)
    # Assign a small constant score to encourage exploration of these bins if others are not ideal.
    priorities[can_fit_mask][loose_fit_mask] = 0.1

    # 5. Exploration: Add a small random component to break ties and encourage exploration.
    exploration_factor = 0.05 # Reduced exploration factor
    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor
    priorities[can_fit_mask] += random_scores

    # Ensure no score exceeds the highest priority (e.g., 1.0 plus random)
    priorities[can_fit_mask] = np.minimum(priorities[can_fit_mask], 1.0 + exploration_factor)

    return priorities
```
