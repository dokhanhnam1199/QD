```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Inverse Distance strategy.

    This strategy prioritizes bins that are a close fit to the item's size.
    It calculates a priority score based on the inverse of (1 + difference) for bins
    where remaining_capacity is greater than or equal to the item size.
    The score is designed to be less sensitive to extreme differences compared to v0,
    and avoids potential division by zero issues more robustly than v1 by adding 1 to the denominator
    and ensuring the difference is non-negative.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Find bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit, calculate the difference between remaining capacity and item size.
    # We are interested in how "tight" the fit is.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    differences = fitting_bins_remain_cap - item
    
    # Calculate priority using inverse of (1 + difference).
    # This ensures that bins with smaller differences (better fits) get higher priorities.
    # Adding 1 to the denominator prevents division by zero when the item perfectly fills a bin.
    # The addition of 1 also acts as a small baseline priority for all fitting bins.
    priorities[can_fit_mask] = 1.0 / (1.0 + differences)
    
    return priorities
```
