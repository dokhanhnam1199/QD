```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a refined priority function for the online Bin Packing Problem.
    This version aims for more nuanced prioritization by tuning thresholds,
    decay functions, and penalty factors, while maintaining the core logic
    of favoring tight fits and penalizing waste.

    Priority Calculation:
    1. Bins that cannot fit the item receive a priority of 0.
    2. For bins that can fit the item:
       a. Perfect Fits (remaining capacity after packing is near zero): Highest priority.
       b. Tight Fits (remaining capacity after packing is small and positive):
          High priority, with a rapidly decreasing score as remaining capacity grows.
          This encourages filling bins as much as possible without leaving
          trivial amounts of space.
       c. Moderate Fits (remaining capacity is larger but not excessively so):
          Medium priority, with a slower decay than tight fits. This allows
          selection of bins that are not optimally filled but are still
          reasonable choices.
       d. Wasteful Fits (remaining capacity is significantly larger than the item):
          Heavily penalized. The penalty increases with the amount of excess
          space, strongly discouraging the selection of bins with substantial
          unused capacity.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array containing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for the corresponding bin. Higher scores indicate
        higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # --- Tuned Parameters ---
    epsilon = 1e-9  # For floating-point comparisons

    # Thresholds:
    # 'tight_fit_max_rem': Max remaining capacity to be considered a "tight fit".
    # A value close to 'item' or slightly larger to allow for slight overfill due to rounding or
    # to encourage using bins that have *just enough* space. Let's set it to 1.2 * item.
    tight_fit_max_rem = 1.2 * item

    # 'moderate_fit_max_rem': Max remaining capacity for a "moderate fit".
    # Anything above this, but still able to fit the item, is considered "wasteful".
    # This threshold should be significantly larger than 'tight_fit_max_rem'.
    # Let's set it to 2.5 * item, aiming to penalize bins that leave more than double
    # the item's space empty.
    moderate_fit_max_rem = 2.5 * item

    # Score weights and decay factors:
    perfect_fit_score = 100.0
    tight_fit_base_score = 60.0
    tight_fit_decay_factor = 2.0 # Steeper decay for tight fits
    moderate_fit_base_score = 30.0
    moderate_fit_decay_factor = 0.7 # Slower decay for moderate fits
    wasteful_penalty_factor = 15.0 # How strongly we penalize wasteful fits

    # Calculate scores for fitting bins
    scores = np.zeros_like(remaining_after_fit)

    # 1. Perfect Fits: Highest priority
    perfect_mask = (remaining_after_fit < epsilon)
    scores[perfect_mask] = perfect_fit_score

    # 2. Tight Fits: High priority, steep decay
    tight_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= tight_fit_max_rem)
    # Using a function like `base / (1 + k*x^p)` where p > 1 for steep decay.
    scores[tight_mask] = tight_fit_base_score / (1.0 + tight_fit_decay_factor * (remaining_after_fit[tight_mask] / item)**2)

    # 3. Moderate Fits: Medium priority, slower decay
    moderate_mask = (remaining_after_fit > tight_fit_max_rem) & (remaining_after_fit <= moderate_fit_max_rem)
    # Using a function like `base / (1 + k*x^p)` where p < 1 or p=1 for slower decay.
    scores[moderate_mask] = moderate_fit_base_score / (1.0 + (remaining_after_fit[moderate_mask] / item)**0.8)

    # 4. Wasteful Fits: Heavily penalized
    wasteful_mask = (remaining_after_fit > moderate_fit_max_rem)
    # Penalize based on how much "excess" space beyond the moderate threshold is left.
    # The penalty should reduce the score significantly.
    # Penalty = factor * (excess_space / item)
    excess_space = remaining_after_fit[wasteful_mask] - moderate_fit_max_rem
    penalty = wasteful_penalty_factor * (excess_space / item)
    # Start with a base score (lower than moderate) and subtract penalty.
    # Or, directly calculate a negative score or very low positive score.
    # Let's assign a base score and then apply a penalty that can make it negative.
    wasteful_base_score = 5.0
    scores[wasteful_mask] = wasteful_base_score - penalty

    # Ensure scores are non-negative. Any score calculated to be negative becomes 0.
    scores[scores < 0] = 0

    # Add a small, scaled random jitter for exploration.
    # This helps break ties between bins with very similar priority scores.
    # The jitter magnitude is relative to the maximum possible score to ensure it has an effect.
    max_possible_score = perfect_fit_score
    exploration_factor = 0.03 # Reduced exploration to prioritize deterministic logic
    jitter = np.random.rand(len(scores)) * exploration_factor * max_possible_score
    final_scores = scores + jitter

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = final_scores

    return priorities
```
