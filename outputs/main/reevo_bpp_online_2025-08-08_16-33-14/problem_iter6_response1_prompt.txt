{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an enhanced priority function for online Bin Packing Problem.\n    This version uses a combination of 'best fit' and 'first fit' tendencies,\n    incorporating a penalty for bins that leave an excessive amount of remaining space.\n    It also includes a stronger emphasis on perfect fits and a more nuanced\n    scoring for near-perfect fits.\n\n    The priority is calculated as follows:\n    1. Bins that cannot fit the item get a priority of 0.\n    2. For bins that can fit the item:\n       a. Perfect Fits (remaining capacity after packing is 0): Highest priority.\n       b. Near-Perfect Fits (remaining capacity after packing is small): High priority,\n          inversely proportional to the remaining capacity.\n       c. Other Fits: Priority decreases as the remaining capacity increases,\n          with a steeper drop-off for larger remaining capacities.\n       d. A \"wastefulness\" penalty is applied to bins that leave a lot of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components and thresholds\n    epsilon = 1e-9\n    # Threshold for \"near-perfect\" fits - e.g., leaving space less than 10% of bin capacity\n    # or less than item size, whichever is smaller and positive.\n    near_perfect_threshold = min(0.1 * bins_remain_cap.max(), item) if bins_remain_cap.max() > 0 else item\n    # Threshold for \"wasteful\" bins - e.g., leaving space more than 50% of bin capacity\n    # or more than 2 * item size.\n    wasteful_threshold = max(0.5 * bins_remain_cap.max(), 2.0 * item) if bins_remain_cap.max() > 0 else 2.0 * item\n\n    # Calculate base scores\n    base_scores = np.zeros_like(remaining_after_fit)\n\n    # 1. Perfect Fits: Highest priority\n    perfect_mask = (remaining_after_fit < epsilon)\n    base_scores[perfect_mask] = 1000.0\n\n    # 2. Near-Perfect Fits: High priority, inversely proportional to remaining capacity\n    near_perfect_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= near_perfect_threshold)\n    # Use a concave function to give diminishing returns as remaining capacity increases\n    # Ensure we don't divide by zero or get excessively large numbers.\n    base_scores[near_perfect_mask] = 50.0 / (1.0 + remaining_after_fit[near_perfect_mask] * 10.0)\n\n    # 3. Other Fits: Priority decreases with remaining capacity\n    other_mask = ~perfect_mask & ~near_perfect_mask\n    # A function that decreases rapidly for larger gaps.\n    # We want to favor bins that leave less space.\n    # (1 / (1 + x)) or (1 / (1 + x^2)) are good candidates.\n    # Let's use a slightly more aggressive decay for larger gaps.\n    # Add a small constant to avoid division by zero if remaining_after_fit is 0\n    # (though perfect_mask should handle this).\n    base_scores[other_mask] = 10.0 / (1.0 + remaining_after_fit[other_mask]**1.5)\n\n    # 4. Wastefulness Penalty: Reduce priority for bins that leave too much space\n    wasteful_mask = (remaining_after_fit > wasteful_threshold)\n    # Apply a penalty that is proportional to how much they exceed the wasteful threshold.\n    penalty = 5.0 * (remaining_after_fit[wasteful_mask] - wasteful_threshold) / (fitting_bins_caps[wasteful_mask] + epsilon)\n    base_scores[wasteful_mask] -= penalty\n\n    # Ensure scores are not negative (though penalty is designed not to make them so easily)\n    base_scores[base_scores < 0] = 0\n\n    # Add a small random component for exploration to all fitting bins\n    # This helps in escaping local optima and exploring different packing configurations.\n    exploration_factor = 0.05\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor * np.max(base_scores + epsilon)\n    final_scores = base_scores + random_scores\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = final_scores\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Implements an improved hybrid priority function for online Bin Packing Problem.\n    This version refines the scoring by prioritizing perfect fits, then tight fits,\n    and then good fits, while still allowing for exploration.\n\n    Categories:\n    1. Perfect Fit: remaining capacity is zero. Highest priority.\n    2. Tight Fit: remaining capacity is small, specifically <= item size. High priority.\n    3. Good Fit: remaining capacity is moderate, specifically > item size but <= 2 * item size. Medium priority.\n    4. Loose Fit: remaining capacity is large, specifically > 2 * item size. Lower priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    fitting_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities  # No bin can fit the item\n\n    fitting_bins_caps = bins_remain_cap[can_fit_mask]\n    remaining_after_fit = fitting_bins_caps - item\n\n    # Define score components based on remaining capacity after fit\n    epsilon = 1e-9  # For handling perfect fits and avoiding division by zero\n\n    # Initialize scores for different fit categories\n    perfect_fit_scores = np.zeros_like(remaining_after_fit)\n    tight_fit_scores = np.zeros_like(remaining_after_fit)\n    good_fit_scores = np.zeros_like(remaining_after_fit)\n    loose_fit_scores = np.zeros_like(remaining_after_fit)\n\n    # Thresholds for categorizing fits (relative to item size)\n    tight_threshold = item\n    good_threshold = 2.0 * item\n\n    # Assign scores based on categories, prioritizing perfect > tight > good > loose\n    # Perfect Fit: Highest score.\n    perfect_mask = (remaining_after_fit < epsilon)\n    perfect_fit_scores[perfect_mask] = 100.0\n\n    # Tight Fit: Prioritize bins that leave little room, scaled inversely with remaining space.\n    tight_mask = (remaining_after_fit > epsilon) & (remaining_after_fit <= tight_threshold)\n    # Score decreases as remaining_after_fit increases within the tight range.\n    tight_fit_scores[tight_mask] = 10.0 / (1.0 + remaining_after_fit[tight_mask])\n\n    # Good Fit: Prioritize bins that leave a moderate amount of room, scaled less aggressively.\n    good_mask = (remaining_after_fit > tight_threshold) & (remaining_after_fit <= good_threshold)\n    # Score decreases as remaining_after_fit increases within the good range.\n    good_fit_scores[good_mask] = 5.0 / (1.0 + remaining_after_fit[good_mask])\n\n    # Loose Fit: Lowest priority among fitting bins, provide minimal boost for exploration.\n    loose_mask = (remaining_after_fit > good_threshold)\n    loose_fit_scores[loose_mask] = 1.0 / (1.0 + remaining_after_fit[loose_mask])\n\n    # Combine scores using weights to reflect the priority order\n    combined_scores = (\n        perfect_fit_scores * 1.0 +\n        tight_fit_scores * 0.7 +\n        good_fit_scores * 0.4 +\n        loose_fit_scores * 0.1\n    )\n\n    # Add a small random component for exploration to all fitting bins\n    # This helps in breaking ties and exploring less obvious choices occasionally.\n    exploration_factor = 0.05\n    random_scores = np.random.rand(len(fitting_bins_caps)) * exploration_factor\n    combined_scores += random_scores\n\n    # Assign the calculated scores to the corresponding bins in the original priority array\n    priorities[can_fit_mask] = combined_scores\n\n    return priorities\n\n[Reflection]\nPrioritize perfect fits. Use item size for thresholds. Weight categories for nuanced scores.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}