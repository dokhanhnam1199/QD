```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements an improved hybrid priority function for online Bin Packing Problem.
    This version refines the scoring by categorizing fits and using a more
    nuanced approach to score within categories, while also incorporating
    an element of randomness for exploration.

    Categories and Scoring Logic:
    1. Perfect Fit (remaining_after_fit = 0): Highest priority. Score is a high constant.
    2. Tight Fit (0 < remaining_after_fit <= item): Prioritize bins that leave minimal space.
       Score is inversely proportional to remaining capacity, scaled for high importance.
    3. Moderate Fit (item < remaining_after_fit <= 2*item): Prioritize bins that leave some space,
       but not too much. Score is inversely proportional to remaining capacity, with a moderate scale.
    4. Loose Fit (remaining_after_fit > 2*item): Lowest priority among fitting bins.
       Score is inversely proportional to remaining capacity, scaled low, to still encourage
       using larger bins if no better options exist, but with less preference.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities  # No bin can fit the item

    # Get remaining capacities only for bins that can fit the item
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    remaining_after_fit = fitting_bins_caps - item

    # --- Scoring Logic ---
    epsilon = 1e-9 # For handling perfect fits and numerical stability

    # Define score components
    scores = np.zeros_like(remaining_after_fit, dtype=float)

    # Category 1: Perfect Fit (remaining_after_fit is almost zero)
    perfect_fit_mask = (remaining_after_fit < epsilon)
    scores[perfect_fit_mask] = 100.0 # Highest priority

    # Category 2: Tight Fit (0 < remaining_after_fit <= item)
    tight_fit_mask = (remaining_after_fit >= epsilon) & (remaining_after_fit <= item)
    if np.any(tight_fit_mask):
        # Prioritize smaller remaining capacity within this category
        # Higher score for smaller denominator (1 + remaining)
        scores[tight_fit_mask] = 10.0 / (1.0 + remaining_after_fit[tight_fit_mask])

    # Category 3: Moderate Fit (item < remaining_after_fit <= 2*item)
    moderate_fit_mask = (remaining_after_fit > item) & (remaining_after_fit <= 2.0 * item)
    if np.any(moderate_fit_mask):
        # Moderate priority, still inversely proportional to remaining capacity
        scores[moderate_fit_mask] = 5.0 / (1.0 + remaining_after_fit[moderate_fit_mask])

    # Category 4: Loose Fit (remaining_after_fit > 2*item)
    loose_fit_mask = (remaining_after_fit > 2.0 * item)
    if np.any(loose_fit_mask):
        # Lower priority, but still inversely proportional
        scores[loose_fit_mask] = 1.0 / (1.0 + remaining_after_fit[loose_fit_mask])

    # --- Exploration Component ---
    exploration_factor = 0.05 # Small random noise to encourage exploring different bins
    random_scores = np.random.rand(len(remaining_after_fit)) * exploration_factor * (1 + scores) # Scale noise with existing score
    
    # Add exploration to all fitting bins
    scores += random_scores

    # Assign the calculated scores to the corresponding bins in the original priority array
    priorities[can_fit_mask] = scores

    return priorities
```
