[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing (FFD) inspired: Prefer bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6) # avoid division by zero\n\n        # Boost bins with minimal remaining capacity after adding the item, but also penalize nearly full bins\n        remaining_capacity_after_fit = bins_remain_cap[fit_mask] - item\n        normalized_remaining = remaining_capacity_after_fit / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else remaining_capacity_after_fit #Handle cases when np.max is zero.\n        priorities[fit_mask] += 1 - np.abs(normalized_remaining - 0.5) # give boost around 0.5.\n    \n    # Penalize bins that can't fit the item\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf # Mark bins that cannot fit with negative infinity\n\n    return priorities",
    "response_id": 27,
    "obj": 1.1667331471878786,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: assign -inf to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Prioritize snug fits and penalize waste\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        slack = bins_remain_cap[feasible_bins] - item\n        # Higher priority for smaller slack (snug fit)\n        priorities[feasible_bins] = 1.0 / (slack + 1e-6)\n\n        # Normalize remaining capacity after placing item\n        remaining_capacity_after = bins_remain_cap[feasible_bins] - item\n        max_capacity = np.max(bins_remain_cap)\n        if max_capacity > 0:\n            normalized_remaining = remaining_capacity_after / max_capacity\n        else:\n            normalized_remaining = remaining_capacity_after  # Avoid division by zero if max_capacity is 0\n\n        # Reward balance: prioritize bins where the normalized remaining capacity is around 0.5\n        balance_bonus = 1.0 - np.abs(normalized_remaining - 0.5)\n        priorities[feasible_bins] += balance_bonus\n\n        # Perfect fit bonus\n        perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n        priorities[feasible_bins][perfect_fit] += 2.0  # Significant bonus for perfect fit\n\n    return priorities",
    "response_id": 9,
    "obj": 1.1667331471878786,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 175.93083758004835,
    "mi": 83.67209807088305,
    "token_count": 199.0,
    "exec_success": true
  }
]