```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Give a high priority to bins where the item fits
    fits = item <= bins_remain_cap
    priorities[fits] += 1

    # Give higher priority to bins with less remaining capacity (First Fit Decreasing heuristic inspired)
    # But only if the item fits
    priorities[fits] += (1 / (bins_remain_cap[fits] + 1e-9))  #avoid division by zero
    
    # Penalize bins where the remaining capacity is very close to item size
    # to avoid external fragmentation
    close_fit = np.abs(bins_remain_cap - item) < 0.1
    priorities[close_fit] -= 0.5  # Moderate penalty

    # Give negative priority to bins that are too full (item doesn't fit). This should already be close to zero since it doesnt fit and we initialized to 0, but let's force it just in case
    doesnt_fit = item > bins_remain_cap
    priorities[doesnt_fit] = -1e9

    return priorities
```
