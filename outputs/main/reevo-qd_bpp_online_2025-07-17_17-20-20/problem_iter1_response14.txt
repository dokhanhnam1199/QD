```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # 1. Feasibility: Only consider bins that can fit the item.
    feasible_bins = bins_remain_cap >= item
    
    if not np.any(feasible_bins):
        #If no bin can fit, return the remaining capacities as negative values.
        #This will prioritize the largest capacity bin if splitting becomes unavoidable later
        priorities = bins_remain_cap - np.max(bins_remain_cap) -1 # ensure a bin is always selected (most empty)
        return priorities

    
    # 2. Remaining Capacity: Prioritize bins with smaller remaining capacity
    #    after placing the item (First Fit Decreasing idea). This encourages filling up bins.
    remaining_capacities_after_fit = bins_remain_cap[feasible_bins] - item
    priorities[feasible_bins] = -remaining_capacities_after_fit # smaller remain capacity gives higher priority. Negative since we want the biggest negative number (smallest remain capacity after fit).

    
    # 3. Percentage Full: Penalize bins that become too full after adding the item. Avoids creating bins that are almost full.
    fill_ratios = (bins_remain_cap[feasible_bins] - remaining_capacities_after_fit) / (bins_remain_cap[feasible_bins] + item) #ratio between bin_remain_cap and new_bin_cap
    overfill_penalty = np.zeros_like(fill_ratios, dtype=float)

    overfill_penalty[fill_ratios > 0.95] = -1000 * (fill_ratios[fill_ratios > 0.95] - 0.95)  # Heavily penalize bins that will be over 95% full after adding item

    priorities[feasible_bins] += overfill_penalty

    
    # 4. Balance factor to prioritize partially filled bins
    average_bin_level = np.mean(bins_remain_cap)
    balance_factor = 0.0

    if average_bin_level > 0: # prevents ZeroDivisionError.

      balance_bonus = np.zeros_like(bins_remain_cap, dtype=float)
      balance_bonus[feasible_bins] = (item) / (bins_remain_cap[feasible_bins] + item) * balance_factor

      priorities[feasible_bins] += balance_bonus

    return priorities
```
