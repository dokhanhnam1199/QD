```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Only consider bins that can fit the item.
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        # If no bin can fit, return the remaining capacities as negative values.
        # This will prioritize the largest capacity bin if splitting becomes unavoidable later
        priorities = bins_remain_cap - np.max(bins_remain_cap) - 1  # ensure a bin is always selected (most empty)
        return priorities

    # 2. Remaining Capacity: Prioritize bins with smaller remaining capacity
    #    after placing the item (First Fit Decreasing idea). This encourages filling up bins.
    remaining_capacities_after_fit = bins_remain_cap[feasible_bins] - item
    priorities[feasible_bins] = -remaining_capacities_after_fit  # smaller remain capacity gives higher priority. Negative since we want the biggest negative number (smallest remain capacity after fit).

    # 3. Avoid Overfilling: Heavily penalize bins that will be too full after adding the item.
    fill_ratios = (bins_remain_cap[feasible_bins] - remaining_capacities_after_fit) / np.max(bins_remain_cap)  # Use max_cap for consistent scaling.
    overfill_penalty = np.zeros_like(fill_ratios, dtype=float)
    overfill_threshold = 0.95
    overfill_penalty[fill_ratios > overfill_threshold] = -1000 * (fill_ratios[fill_ratios > overfill_threshold] - overfill_threshold)

    priorities[feasible_bins] += overfill_penalty

    # 4. Balancing: Give a slight bonus to bins that are neither too full nor too empty.
    # This is a subtle adjustment to encourage a more even distribution.
    bin_fullness = (np.max(bins_remain_cap) - bins_remain_cap[feasible_bins]) / np.max(bins_remain_cap)
    balance_bonus = np.zeros_like(bin_fullness, dtype=float)
    balance_lower_threshold = 0.2
    balance_upper_threshold = 0.8
    balance_bonus[(bin_fullness > balance_lower_threshold) & (bin_fullness < balance_upper_threshold)] = 1  # small bonus

    priorities[feasible_bins] += balance_bonus
    
    #Perfect Fit Bonus:
    perfect_fit = np.isclose(remaining_capacities_after_fit, 0)
    priorities[feasible_bins][perfect_fit] += 500
    return priorities
```
