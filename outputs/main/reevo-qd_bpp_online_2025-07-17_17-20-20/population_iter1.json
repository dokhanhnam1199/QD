[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing heuristic inspired priority: prefer bins where item fits best\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        priorities[fit_mask] = bins_remain_cap[fit_mask] - item  # Smaller difference is better\n\n        # Break ties using the Fill Rate idea to penalize bins that would have low fill-rate with the item\n        fill_rates = item / bins_remain_cap[fit_mask]\n        priorities[fit_mask] -= fill_rates # Higher fill rates (closer to 1.0) are preferred, subtract a small negative number.\n\n    else:\n        # If item doesn't fit into any bin, give all very small negative priorities.\n        priorities[:] = -1e9  # Very low priority for bins where it doesn't fit\n\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Assign zero priority to bins that can't fit the item.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Mark as infeasible\n    \n    # 2. Best Fit Criterion: Prioritize bins with smallest remaining capacity AFTER adding the item.\n    feasible_mask = ~infeasible_mask\n    remaining_after_fit = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -np.abs(remaining_after_fit) # Prioritize smaller remaining\n\n    # 3. Avoid Fragmentation: Penalize bins that will have a small remainder\n    small_remainder_threshold = 0.1 #adjust threshold if necessary\n    small_remainder_mask = (remaining_after_fit > 0) & (remaining_after_fit < small_remainder_threshold)\n    priorities[feasible_mask][small_remainder_mask] -= 0.5 # Reduce the priority for small remainders. Tune this value.\n    \n    # 4. Bonus for Perfect Fit: If a bin has a perfect fit, give it the highest priority.\n    perfect_fit_mask = (bins_remain_cap == item)\n    priorities[perfect_fit_mask] = np.inf\n    \n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very low priority to bins that cannot fit the item.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf  # Assign lowest priority to infeasible bins\n\n    # For feasible bins, calculate priority based on remaining capacity after adding the item.\n    feasible_bins = ~infeasible_bins\n    remaining_capacity_after_fit = bins_remain_cap[feasible_bins] - item\n\n    # Prioritize bins where the remaining capacity is close to 0 (First Fit Decreasing principle).\n    # Avoids creating bins with very little space left, which is hard to fill later.\n    priorities[feasible_bins] = np.exp(-remaining_capacity_after_fit)\n\n    # Add a small bonus to bins that are already somewhat full.\n    # Encourages filling existing bins instead of opening new ones if there's a close choice\n    fullness_bonus = (1 - bins_remain_cap / bins_remain_cap.max()) # scale to [0,1]\n    priorities += 0.1*fullness_bonus\n\n    #Add another term favoring small remaining capacity bins, but scaling inverse with remaining capacity\n    priorities[feasible_bins] += 0.5/(0.01 + remaining_capacity_after_fit)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing-like heuristic: Prioritize bins that can fit the item closely.\n    # Avoid bins that are too full or too empty after packing.\n    \n    # Give high priority to bins where the remaining capacity after packing\n    # is a small fraction of the bin size.\n    \n    fit_indices = bins_remain_cap >= item\n    \n    if np.any(fit_indices):\n        remaining_after_fit = bins_remain_cap[fit_indices] - item\n        \n        # Normalize remaining capacity to [0, 1] by dividing by bins' full capacity\n        normalized_remaining = remaining_after_fit / (bins_remain_cap[fit_indices] + item - remaining_after_fit)  #Assuming initial_capcity is approximately bins_remain_cap[fit_indices] + item - remaining_after_fit (corrected equation)\n        \n        # Use inverse of remaining fraction as priority: closer to full -> higher priority\n        priorities[fit_indices] = 1.0 - normalized_remaining # Prioritize smaller remaining space\n    \n        # Add bonus priority to almost full bins\n\n        almost_full = (bins_remain_cap[fit_indices] - item) < 0.1 # if remaining space is less than 0.1 after packing.\n        priorities[fit_indices][almost_full] += 0.5 # Boosts priority\n\n    \n    \n    # Penalize bins that can't fit the item heavily\n    priorities[bins_remain_cap < item] = -1e9\n    \n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            priorities[i] = (item / cap) + (1 / (waste + 1e-6)) # Maximize item occupancy, minimize waste\n        else:\n            priorities[i] = -np.inf  # Cannot fit\n\n    return priorities",
    "response_id": 4,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997604999953 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Very high priority for bins that can fit the item almost perfectly\n    fit_almost_perfectly = (bins_remain_cap - item) >= 0\n    almost_perfect_fit_indices = np.where(fit_almost_perfectly)[0]\n    \n    for i in almost_perfect_fit_indices:\n        priorities[i] = 100 - np.abs(bins_remain_cap[i] - item) # Prioritize closer fit\n\n    # Medium priority for bins that can fit the item but not perfectly\n    fit_indices = np.where(bins_remain_cap >= item)[0]\n\n    for i in fit_indices:\n        if i not in almost_perfect_fit_indices:\n             priorities[i] = 50 - (bins_remain_cap[i] - item)\n\n    # Low priority (negative) to avoid fragmentation. This discourages use of bins that are already very empty.\n    empty_bins_indices = np.where(bins_remain_cap > 2*item)[0]\n\n    for i in empty_bins_indices:\n      if priorities[i] == 0:\n        priorities[i] = -1 * (bins_remain_cap[i] / np.max(bins_remain_cap)) \n    \n    return priorities",
    "response_id": 5,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999973869000314 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit-Decreasing heuristic component: Prefer bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1  # Give a base priority if it can fit.\n\n    # Best-Fit heuristic component: Prefer bins with smallest remaining capacity after placing item, if it fits.\n    remaining_space = bins_remain_cap - item\n    remaining_space[~can_fit] = np.inf  # Penalize bins that cannot fit\n    priorities[can_fit] += 1.0 / (remaining_space[can_fit] + 1e-6) # Avoid division by zero\n\n    # Avoid fragmentation: try to fill up near empty bins or nearly full bins\n    near_empty = (bins_remain_cap > 0) & (bins_remain_cap < 0.1)  # Bins almost empty \n    priorities[near_empty] += 0.5\n\n    near_full = can_fit & (remaining_space >= 0) & (remaining_space < 0.1)\n    priorities[near_full] += 1 # Higher priority for bins that will be filled close to max cap.\n\n    # Penalize bins where the item would cause the bin to be nearly full\n    almost_full = (bins_remain_cap >= item) & (bins_remain_cap < item + 0.1)\n    priorities[almost_full] -= 0.2  # Slightly less preferable to avoid excessive near-full bins\n\n    # Soft penalty for bins which we can place our item with room > 0.5\n    roomy_fit = can_fit & (bins_remain_cap > item + 0.5)\n    priorities[roomy_fit] -= 0.05 # avoid this when possible\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Feasibility check: assign -inf to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n    \n    # Prioritize bins with smallest remaining capacity *greater* than item.\n    # This tends to fill bins as much as possible before opening new ones.\n    # Use a large negative number to ensure feasible bins with small remaining\n    # capacity are preferred to almost-full bins.\n\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n      priorities[feasible_bins] = -bins_remain_cap[feasible_bins]\n    \n    # Add a bonus to bins where the item would fill it perfectly. This helps\n    # minimize fragmentation.\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] += 10  # A large positive bonus.\n    \n    # Add a small bonus based on how much the bin is already filled.\n    # Encourages using partially filled bins\n    priorities += (1 - (bins_remain_cap / np.max(bins_remain_cap))) * 0.1 # Small bonus\n    \n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate waste if the item is placed in the bin.  Use large number if item does not fit.\n    waste = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n\n    # Prioritize bins where the item fits best (smallest waste). Avoid fragmentation.\n    priorities = -waste\n\n    # Add a bonus for bins that are almost full after adding the item. Try to fill bins up.\n    almost_full_threshold = 0.1  # Define \"almost full\" (e.g., within 10% of capacity)\n    is_almost_full = (bins_remain_cap >= item) & (waste <= almost_full_threshold)\n    priorities[is_almost_full] += 10 # subatantial boost to bins that are almost full after the add.\n\n    # Penalize bins where the item doesn't fit (to a very low score.)\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # Small random number to break ties (helps exploration)\n    priorities += np.random.rand(len(bins_remain_cap)) * 0.001\n    \n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can accommodate the item\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # If the item can fit, prioritize bins with less remaining capacity (First-Fit Decreasing heuristic influence)\n    priorities[can_fit] += (1 / (bins_remain_cap[can_fit] + 1e-9))  # Add a small constant to avoid division by zero\n    \n    #If bin has enough space and it has minimum wasted space, then prioritize it (Best-Fit heuristic influence)\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Mark bins that cannot fit as infinite waste\n\n    min_waste_bins = waste == np.min(waste)\n    priorities[min_waste_bins & can_fit] += 2 # Higher priority for Best-Fit that can actually accommodate the item.\n        \n    return priorities",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # First Fit Decreasing heuristic inspiration: Prefer bins with least wasted space\n            waste = cap - item\n            priorities[i] = 1 / (waste + 1e-6)  # Avoid division by zero\n\n            # Additionally prefer bins that are already relatively full\n            priorities[i] += (1 - (cap / np.max(bins_remain_cap))) * 0.5 # Scale factor to give lesser importance\n\n            # A small bonus to use bins that are already have some items\n            if cap < np.max(bins_remain_cap):  #Assuming completely empty bin would be equal to max cap.\n               priorities[i] += 0.1 # small constant bonus\n        else:\n            priorities[i] = -1e9  # Very low priority if item doesn't fit\n\n    return priorities",
    "response_id": 10,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.999974529999236 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility: Disqualify bins that can't fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf  # Or a very large negative number\n\n    # 2. Best Fit Criterion: Prefer bins with the smallest remaining space after placement, but only if feasible\n    feasible_mask = ~infeasible_mask\n    remaining_space = bins_remain_cap[feasible_mask] - item\n\n    # Apply a non-linear transformation to remaining_space to emphasize near-perfect fits\n    # Small remaining space gets a high priority; larger spaces get progressively lower priority\n    # Adding a small constant to avoid division by zero, and clipping to avoid extremely high values.\n\n    priorities[feasible_mask] = -np.clip(remaining_space / (bins_remain_cap[feasible_mask] + 0.001), -1, 1)\n\n    # 3. Smallest Bin Preference (Tie-breaker): if there are multiple bins that are close, choose smallest.\n    # To make this relative, divide remaining space by bin capacity and exponentiate\n    # Sort of exponential decay based on free space and original bin sizes\n    # Add only to feasible bins, avoiding creating negative values.\n    # Normalize between 0 and 1.\n    normalized_capacities = bins_remain_cap[feasible_mask] / np.max(bins_remain_cap)\n    priorities[feasible_mask] += np.exp(-normalized_capacities*10) /10\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins that can fit the item.\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] += 1.0\n\n    # Prioritize bins where the item fits relatively well.  Avoid bins that are only *just* big enough.\n    relative_fit = (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # smaller value better fit.\n    priorities[fit_mask] += np.exp(-10*relative_fit) # Decay quickly if the bin is too big for the item relative to its size\n    \n    # Penalize bins that would become too full after adding the item (leave some safety margin, say 10%).\n    almost_full_mask = (bins_remain_cap - item) < 0.1\n    priorities[almost_full_mask] -= 0.5\n\n    #If no bins fit, try to use the bin that can fit the largest chunk of the item.\n    if np.all(bins_remain_cap < item):\n      priorities = bins_remain_cap\n\n    return priorities",
    "response_id": 12,
    "obj": 4.457518946948548,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Large items should be placed in bins that fit them reasonably well\n    fit_score = np.where(bins_remain_cap >= item, bins_remain_cap - item, -np.inf)\n    \n    # Bins that are already somewhat full are prioritized\n    fullness_score = bins_remain_cap  # The smaller this value, the more full the bin is\n    \n    #Combine the metrics\n    priorities = -fit_score / np.mean(bins_remain_cap) - fullness_score / np.std(bins_remain_cap)\n\n    # If no bin can fit, assign equal priority to all bins to randomly pick\n    if np.all(bins_remain_cap < item):\n        priorities = np.ones_like(bins_remain_cap, dtype=float) / len(bins_remain_cap)\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # 1. Feasibility: Only consider bins that can fit the item.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        #If no bin can fit, return the remaining capacities as negative values.\n        #This will prioritize the largest capacity bin if splitting becomes unavoidable later\n        priorities = bins_remain_cap - np.max(bins_remain_cap) -1 # ensure a bin is always selected (most empty)\n        return priorities\n\n    \n    # 2. Remaining Capacity: Prioritize bins with smaller remaining capacity\n    #    after placing the item (First Fit Decreasing idea). This encourages filling up bins.\n    remaining_capacities_after_fit = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -remaining_capacities_after_fit # smaller remain capacity gives higher priority. Negative since we want the biggest negative number (smallest remain capacity after fit).\n\n    \n    # 3. Percentage Full: Penalize bins that become too full after adding the item. Avoids creating bins that are almost full.\n    fill_ratios = (bins_remain_cap[feasible_bins] - remaining_capacities_after_fit) / (bins_remain_cap[feasible_bins] + item) #ratio between bin_remain_cap and new_bin_cap\n    overfill_penalty = np.zeros_like(fill_ratios, dtype=float)\n\n    overfill_penalty[fill_ratios > 0.95] = -1000 * (fill_ratios[fill_ratios > 0.95] - 0.95)  # Heavily penalize bins that will be over 95% full after adding item\n\n    priorities[feasible_bins] += overfill_penalty\n\n    \n    # 4. Balance factor to prioritize partially filled bins\n    average_bin_level = np.mean(bins_remain_cap)\n    balance_factor = 0.0\n\n    if average_bin_level > 0: # prevents ZeroDivisionError.\n\n      balance_bonus = np.zeros_like(bins_remain_cap, dtype=float)\n      balance_bonus[feasible_bins] = (item) / (bins_remain_cap[feasible_bins] + item) * balance_factor\n\n      priorities[feasible_bins] += balance_bonus\n\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # First-Fit-Decreasing inspired approach: prioritize bins that can fit the item\n    # and have relatively low remaining capacity after fitting the item.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_after_fit = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1 / (remaining_after_fit + 1e-9)  # Avoid division by zero\n\n        # Bonus for bins that are almost full after packing\n        almost_full = (remaining_after_fit / item) < 0.1\n        priorities[valid_bins][almost_full] *= 2  # Double priority for bins that are almost full\n    else:\n        # If no bins can fit, penalize all bins heavily. It encourages opening a new bin.\n        priorities[:] = -1e9  # Large negative value\n\n    return priorities",
    "response_id": 15,
    "obj": 4.198244914240141,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Encourage filling bins that are close to full after placing the item.\n            fill_ratio_after = item / cap\n            priorities[i] = 1 - fill_ratio_after\n\n            # Give higher priority to bins that are closer to the item size\n            priorities[i] += np.exp(-np.abs(cap - item))\n\n            # Penalize bins with very large capacities (avoid very empty bins).\n            priorities[i] -= (cap / np.max(bins_remain_cap)) * 0.1 if bins_remain_cap.size > 0 else 0\n        else:\n            priorities[i] = -np.inf  # Cannot fit\n\n    return priorities",
    "response_id": 16,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997588000042 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First-Fit Decreasing inspired priority: Prefer bins that can fit the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1.0\n\n    # Give higher priority to bins with smaller remaining capacity among those that can fit.\n    # This tries to fill bins more completely.\n    small_cap_bonus = np.where(can_fit, 1.0 / (bins_remain_cap + 1e-6), 0.0)\n    priorities += small_cap_bonus\n    \n    # Penalize bins that are significantly larger than the item\n    waste_penalty = np.where(can_fit, np.exp(-bins_remain_cap + item), 0.0)\n    priorities -= waste_penalty\n\n    #Extreme penalty if the bins does not fit the item\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] -= 1000 #Large negative penalty so item can never get placed\n\n    return priorities",
    "response_id": 17,
    "obj": 10.341045073793383,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a high priority to bins where the item fits\n    fits = item <= bins_remain_cap\n    priorities[fits] += 1\n\n    # Give higher priority to bins with less remaining capacity (First Fit Decreasing heuristic inspired)\n    # But only if the item fits\n    priorities[fits] += (1 / (bins_remain_cap[fits] + 1e-9))  #avoid division by zero\n    \n    # Penalize bins where the remaining capacity is very close to item size\n    # to avoid external fragmentation\n    close_fit = np.abs(bins_remain_cap - item) < 0.1\n    priorities[close_fit] -= 0.5  # Moderate penalty\n\n    # Give negative priority to bins that are too full (item doesn't fit). This should already be close to zero since it doesnt fit and we initialized to 0, but let's force it just in case\n    doesnt_fit = item > bins_remain_cap\n    priorities[doesnt_fit] = -1e9\n\n    return priorities",
    "response_id": 18,
    "obj": 5.195452732349436,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins that minimize waste, but also consider filling nearly full bins\n            priorities[i] = (cap*item) / (waste + 0.0001) # Avoid division by zero\n        else:\n            priorities[i] = -1e9  # Very low priority for bins that can't fit the item\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Prioritize bins that can fit the item\n    fit_mask = bins_remain_cap >= item\n    priorities[fit_mask] = 1  # Basic priority for fitting\n\n    # Adjust priority based on remaining capacity after fitting\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n    \n    # Give higher priority to bins with smaller remaining capacity (First Fit Decreasing like)\n    # But avoid bins that would become too empty (to avoid fragmentation)\n    \n    \n    # Small capacity = high priority if large than threshold, to avoid large fragementation\n    threshold = 0.1\n    priorities[fit_mask] += np.where(remaining_after_fit > bins_remain_cap[fit_mask] * threshold, remaining_after_fit,0) # If the remaining capacity is very small after putting the item, than add larger priorities\n    \n    \n    return priorities",
    "response_id": 20,
    "obj": 149.19226166733148,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give a very low priority to bins that cannot fit the item\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # Calculate the waste if the item is placed in the bin\n    waste = bins_remain_cap - item\n    \n    # Prioritize bins with smaller waste (First-Fit Decreasing heuristic inspired)\n    priorities[bins_remain_cap >= item] = -waste[bins_remain_cap >= item]\n    \n    # Add a small bonus for bins that are nearly full after adding the item to discourage creating very empty bins (balance between best fit and almost full)\n    nearly_full_threshold = 0.1  # e.g., if remaining capacity after placing the item is less than 10% of the bin size\n    is_nearly_full = (waste > 0) & (waste <= nearly_full_threshold)  # waste must be positive and smaller than nearly_full_threshold\n    priorities[is_nearly_full] += 10 # added bonus to make it higher priority if it almost fills the bin. Adjust this value\n    \n    # Handle the case where the item perfectly fits (highest priority)\n    perfect_fit = waste == 0\n    priorities[perfect_fit] = np.inf\n    \n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Immediate Fit: High priority if item fits perfectly\n    perfect_fit = np.isclose(bins_remain_cap, item)\n    priorities[perfect_fit] = 1000  # Very high priority\n    \n    # First Fit Decreasing Intuition\n    can_fit = bins_remain_cap >= item\n    priorities[~can_fit] = -1000 # Penalize if it cannot fit.\n    \n    # Maximize space utilization, but avoid fragmentation\n    # Penalize small remainders. sqrt to scale down the effect\n    remainders = bins_remain_cap - item\n    remainders[remainders < 0] = 0\n    \n    priorities[can_fit] += bins_remain_cap[can_fit] - 10*np.sqrt(remainders[can_fit])\n\n    # Prioritize bins that are not too full or too empty (middle ground). Avoids the extreme cases early on.\n\n    bin_fullness = 1 - bins_remain_cap / np.max(bins_remain_cap) # Scale fullness between 0 and 1\n    priorities[can_fit] += -np.abs(bin_fullness[can_fit] - 0.5) * 10 # Moderate penalty\n\n    return priorities",
    "response_id": 22,
    "obj": 52.01435979258079,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Initialize with a low priority for bins that can't fit the item.\n    priorities[bins_remain_cap < item] = -np.inf\n    \n    # For bins that can fit, prioritize based on the remaining capacity after placing the item.\n    # Smaller remaining capacity gets higher priority (First Fit Decreasing heuristic principle)\n    \n    remaining_capacities = bins_remain_cap - item\n    \n    # Avoid zero division\n    remaining_capacities[remaining_capacities <= 0] = 1e-6  # Set very small positive value for zero remaining capacities\n    \n    priorities[bins_remain_cap >= item] = 1 / remaining_capacities[bins_remain_cap >= item]  # Inverse of remaining capacity\n\n    # Further incentivize bins that are close to being full after packing, without overflowing\n    # This also penalizes bins where the remaining capacity will be large, resulting in fragmentation\n    \n    capacities_fit = bins_remain_cap[bins_remain_cap >= item]\n    item_fit = item\n\n    priorities[bins_remain_cap >= item] = (1 / remaining_capacities[bins_remain_cap >= item]) * (item_fit / capacities_fit) \n\n    # A slightly higher score for bins that are almost full without exceeding capacity.\n    almost_full = (bins_remain_cap >= item) & (remaining_capacities <= 0.1 * bins_remain_cap)\n    priorities[almost_full] *= 2 # Give bins almost full a slightly bigger nudge to the top.\n\n    return priorities",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First-Fit Decreasing heuristic: prefer bins that can accommodate the item with minimal waste.\n    # Give high priority to bins where the remaining capacity after adding the item is small.\n    \n    valid_bins = bins_remain_cap >= item\n    \n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = -remaining_space  # Smaller remaining space -> higher priority. Use negative sign\n        \n        # Modify to prioritize bins close to fully filling. Prioritize bins whose post-packing fullness is high, but don't OVERFILL.\n\n        fullness = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins] #Post-packing\n        priorities[valid_bins] = fullness\n\n        #Bins that make close to 1 when added to existing size should have top priority.\n        priorities[valid_bins] = 1 / (remaining_space + 1e-9)\n        \n        #Adjust to strongly discourage wasting large space in nearly full bins, otherwise, use residual space as proxy of the quality\n        \n        large_waste_threshold = 0.5 #Define what counts as significantly wasted capacity for residual space penalty\n        priorities[valid_bins] = -np.abs((bins_remain_cap[valid_bins]-item) -large_waste_threshold)\n            \n    else:\n        # If no bin can accommodate the item, assign the same low priority to all bins.\n        priorities[:] = -np.inf\n        \n    return priorities",
    "response_id": 24,
    "obj": 4.11846828879138,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if item <= cap:\n            # Calculate the wasted space if the item is placed in this bin.\n            wasted_space = cap - item\n            # Give higher priority to bins where the item fits with less wasted space.\n            # Also, give higher priority to bins that are nearly full.\n            priorities[i] = (1 / (wasted_space + 1e-6)) + (cap / np.sum(bins_remain_cap) if np.sum(bins_remain_cap) > 0 else 0)\n            \n            # Add a bonus for bins where the item fits perfectly\n            if wasted_space < 1e-6: #consider very small wastes as perfect fits.\n              priorities[i] += 1\n\n        else:\n            priorities[i] = -np.inf  # Cannot fit, so give lowest priority.\n    return priorities",
    "response_id": 25,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Command '['python3', '-u', '/home/dokhanhnam1199/QD/problems/bpp_online/eval.py', '5000', '/home/dokhanhnam1199/QD', 'train']' timed out after 49.99997918000008 seconds"
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Big enough to fit heuristic: Prioritize bins that can accommodate the item.\n    can_fit = bins_remain_cap >= item\n    priorities[can_fit] += 1\n\n    # Remaining capacity heuristic: Prioritize bins with smallest remaining capacity after adding the item (minimize waste).\n    remaining_capacity_after_fit = bins_remain_cap - item\n    remaining_capacity_after_fit[~can_fit] = np.inf # Set to infinity if it doesn't fit to avoid it being picked\n    priorities[can_fit] += (1 / (remaining_capacity_after_fit[can_fit] + 1e-9)) # Add inverse of remaining capacity to priority\n\n    # Filling percentage heuristic: Prioritize bins that will be filled closest to 100%\n    filling_percentage = (item / bins_remain_cap) * can_fit # zero if it doesn't fit.\n    priorities[can_fit] += filling_percentage[can_fit]\n\n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing (FFD) inspired: Prefer bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6) # avoid division by zero\n\n        # Boost bins with minimal remaining capacity after adding the item, but also penalize nearly full bins\n        remaining_capacity_after_fit = bins_remain_cap[fit_mask] - item\n        normalized_remaining = remaining_capacity_after_fit / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else remaining_capacity_after_fit #Handle cases when np.max is zero.\n        priorities[fit_mask] += 1 - np.abs(normalized_remaining - 0.5) # give boost around 0.5.\n    \n    # Penalize bins that can't fit the item\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf # Mark bins that cannot fit with negative infinity\n\n    return priorities",
    "response_id": 27,
    "obj": 1.1667331471878786,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            waste = cap - item\n            # Prioritize bins where the item fits and minimizes waste. A small waste is better.\n            priorities[i] = 1 / (waste + 0.0001)  # Add a small constant to avoid division by zero.\n\n            # Bonus for bins that are close to being filled completely (but not overfilled)\n            if waste < 0.1:  #tune the threshold\n                priorities[i] += 5  #tune the bonus amount\n\n        else:\n            priorities[i] = -1000 #Very negative priority, so that item can never be added to bin\n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining space after placing the item in each bin\n    remaining_space = bins_remain_cap - item\n\n    # Give high priority to bins where the item fits\n    fit_mask = remaining_space >= 0\n    priorities[fit_mask] = 1  # Base priority for bins that fit\n\n    # Prioritize bins with less wasted space when item fits\n    priorities[fit_mask] += (bins_remain_cap[fit_mask] - item) / bins_remain_cap[fit_mask]  # Ratio of wasted space\n\n    # Penalize bins where the item doesn't fit heavily\n    priorities[~fit_mask] = -10 * (item - bins_remain_cap[~fit_mask])  # Penalty increases with excess\n\n    return priorities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  }
]