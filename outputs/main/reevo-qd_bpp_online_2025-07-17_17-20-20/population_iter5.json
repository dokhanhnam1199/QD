[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First Fit Decreasing (FFD) inspired: Prefer bins that can fit the item snugly\n    fit_mask = bins_remain_cap >= item\n    if np.any(fit_mask):\n        slack = bins_remain_cap[fit_mask] - item\n        priorities[fit_mask] = 1 / (slack + 1e-6) # avoid division by zero\n\n        # Boost bins with minimal remaining capacity after adding the item, but also penalize nearly full bins\n        remaining_capacity_after_fit = bins_remain_cap[fit_mask] - item\n        normalized_remaining = remaining_capacity_after_fit / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else remaining_capacity_after_fit #Handle cases when np.max is zero.\n        priorities[fit_mask] += 1 - np.abs(normalized_remaining - 0.5) # give boost around 0.5.\n    \n    # Penalize bins that can't fit the item\n    no_fit_mask = bins_remain_cap < item\n    priorities[no_fit_mask] = -np.inf # Mark bins that cannot fit with negative infinity\n\n    return priorities",
    "response_id": 27,
    "obj": 1.1667331471878786,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 118.59257041502654,
    "mi": 75.92681040850096,
    "token_count": 113.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: assign -inf to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Prioritize snug fits and penalize waste\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        slack = bins_remain_cap[feasible_bins] - item\n        # Higher priority for smaller slack (snug fit)\n        priorities[feasible_bins] = 1.0 / (slack + 1e-6)\n\n        # Normalize remaining capacity after placing item\n        remaining_capacity_after = bins_remain_cap[feasible_bins] - item\n        max_capacity = np.max(bins_remain_cap)\n        if max_capacity > 0:\n            normalized_remaining = remaining_capacity_after / max_capacity\n        else:\n            normalized_remaining = remaining_capacity_after  # Avoid division by zero if max_capacity is 0\n\n        # Reward balance: prioritize bins where the normalized remaining capacity is around 0.5\n        balance_bonus = 1.0 - np.abs(normalized_remaining - 0.5)\n        priorities[feasible_bins] += balance_bonus\n\n        # Perfect fit bonus\n        perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n        priorities[feasible_bins][perfect_fit] += 2.0  # Significant bonus for perfect fit\n\n    return priorities",
    "response_id": 9,
    "obj": 1.1667331471878786,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 175.93083758004835,
    "mi": 83.67209807088305,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    bin_capacity = np.max(bins_remain_cap) #assumed bins have equal capacity equal to max of bins_remain_cap\n\n    # Infeasible bins get punished harshly\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # Feasible bins get prioritized\n    feasible_mask = bins_remain_cap >= item\n    if np.any(feasible_mask):\n        remaining_capacity_after_fit = bins_remain_cap[feasible_mask] - item\n\n        # Normalize the remaining capacity\n        normalized_remaining = remaining_capacity_after_fit / bin_capacity\n\n        # Reward near-full bins (small remaining capacity) strongly. The closer to 0 normalized_remaining is, the higher the score.\n        priorities[feasible_mask] += (1 - normalized_remaining)**2 # Quadratic to emphasize small remaining capacity\n\n        # Penalize excessive waste (large remaining capacity). Penalty increases with normalized_remaining.\n        priorities[feasible_mask] -= normalized_remaining\n\n        # Inverse slack for nuanced bin prioritization: Favors bins with tighter fits.\n        slack = bins_remain_cap[feasible_mask] - item\n        priorities[feasible_mask] += 1 / (slack + 1e-6) # Avoid division by zero\n\n        #Add randomness for exploration of different solutions.\n        priorities[feasible_mask] += np.random.rand(np.sum(feasible_mask)) * 0.01\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 201.18251441994926,
    "mi": 81.6541397675193,
    "token_count": 172.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response4.txt_stdout.txt",
    "code_path": "problem_iter4_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: assign -inf to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Prioritize snug fits and penalize waste\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        slack = bins_remain_cap[feasible_bins] - item\n        # Higher priority for smaller slack (snug fit)\n        priorities[feasible_bins] = 1.0 / (slack + 1e-6)\n\n        # Normalize remaining capacity after placing item\n        remaining_capacity_after = bins_remain_cap[feasible_bins] - item\n        max_capacity = np.max(bins_remain_cap)\n        if max_capacity > 0:\n            normalized_remaining = remaining_capacity_after / max_capacity\n        else:\n            normalized_remaining = 0  # Avoid division by zero if max_capacity is 0. Assign 0 as a default\n\n        # Reward balance: prioritize bins where the normalized remaining capacity is around 0.5\n        balance_bonus = np.exp(-np.abs(normalized_remaining - 0.5)**2 / 0.08)  # Gaussian-like bonus\n        priorities[feasible_bins] += balance_bonus\n\n        # Perfect fit bonus\n        perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n        priorities[feasible_bins][perfect_fit] += 3.0  # Significant bonus for perfect fit\n\n        # Add a small bonus for using almost full bins\n        almost_full = (bins_remain_cap[feasible_bins] - item) < (0.1 * max_capacity if max_capacity > 0 else 0.1)\n        priorities[feasible_bins][almost_full] += 0.5\n\n    return priorities",
    "response_id": 4,
    "obj": 0.8476266453929,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 162.53496664211536,
    "mi": 84.75612852497784,
    "token_count": 159.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Feasibility check: assign -inf to bins that can't fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    # Prioritize feasible bins\n    feasible_bins = ~infeasible_bins\n    if np.any(feasible_bins):\n        slack = bins_remain_cap[feasible_bins] - item\n\n        # Snug fit reward\n        snug_fit_reward = 1.0 / (slack + 0.001)  # Avoid division by zero, make it impactful\n        priorities[feasible_bins] += snug_fit_reward\n\n        # Moderate remaining capacity reward\n        total_capacity = np.max(bins_remain_cap)  # Get Total capacity by finding the maximum value\n        if total_capacity > 0:\n          normalized_remaining = (bins_remain_cap[feasible_bins] - item) / total_capacity\n          moderate_capacity_reward = np.exp(-((normalized_remaining - 0.5) ** 2) / 0.04) # Bias towards 0.5\n          priorities[feasible_bins] += 0.5 * moderate_capacity_reward\n\n        # Perfect fit bonus\n        perfect_fit = np.isclose(bins_remain_cap[feasible_bins], item)\n        priorities[feasible_bins][perfect_fit] += 2.0\n\n        # Small random reward\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n\n    return priorities",
    "response_id": 0,
    "obj": 1.1966493817311528,
    "SLOC": 14.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 284.3458750793272,
    "mi": 81.17844283928773,
    "token_count": 222.0,
    "exec_success": true
  }
]