```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    bin_capacity = np.max(bins_remain_cap)

    # Feasibility Mask: filter bins that can contain item
    fit_mask = bins_remain_cap >= item

    # If there are feasible bins:
    if np.any(fit_mask):
        # Slack: unused capacity after item is put into bin
        slack = bins_remain_cap[fit_mask] - item
        
        # Inverse Slack: prioritize bins that fit the item better. Add a small value to prevent division by zero.
        priorities[fit_mask] += 1 / (slack + 1e-6)

        # Normalized Remaining Capacity: Normalize by largest bin capacity.
        normalized_remaining = (bins_remain_cap[fit_mask] - item) / bin_capacity if bin_capacity > 0 else (bins_remain_cap[fit_mask] - item)

        # Reward near-full bins and penalize bins that are too empty or too full.
        priorities[fit_mask] += np.exp(-np.abs(normalized_remaining - 0.2)**2 / 0.02)  # Reward bins with around 20% remaining capacity after placing item. The narrower width concentrates the reward
        
        # Maximize occupancy: Bonus for using a large portion of bin
        priorities[fit_mask] += (1 - normalized_remaining)

    # If there are infeasible bins:
    infeasible_mask = bins_remain_cap < item
    priorities[infeasible_mask] = -np.inf # Large penalty for bins that cannot fit

    # Add small amount of noise to priorities:
    priorities += np.random.normal(0, 0.001, size=priorities.shape)

    return priorities
```
