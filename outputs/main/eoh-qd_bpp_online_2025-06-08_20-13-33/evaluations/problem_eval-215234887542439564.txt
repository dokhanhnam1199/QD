def priority_v3(item, bins_remain_cap):
    """{This algorithm prioritizes bins based primarily on how full the bin will be *after* placing the item, while still penalizing bins that can't fit the item.}"""
    priority = []
    for cap in bins_remain_cap:
        if cap >= item:
            fullness_after_placement = 1 - (cap - item)  # How full the bin is after placing the item
            priority_score = fullness_after_placement # Prioritize based on fullness after placement
        else:
            priority_score = -1  # Assign a negative priority if the item doesn't fit
        priority.append(priority_score)
    return priority
