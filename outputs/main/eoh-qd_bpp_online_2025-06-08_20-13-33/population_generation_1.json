[
     {
          "algorithm": "Assign a priority score to each bin based on its remaining capacity relative to the item size, favoring bins with remaining capacity slightly larger than the item size.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{Assign a priority score to each bin based on its remaining capacity relative to the item size, favoring bins with remaining capacity slightly larger than the item size.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority.append(1.0 / (cap - item + 0.1)) # Prioritize bins with smaller differences between cap and item size\n    else:\n      priority.append(-1.0) # Disqualify bins that cannot fit the item\n\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 74.00879436282185
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on the remaining capacity and item size, favoring bins that can accommodate the item with minimal wasted space and penalizing those that would lead to excessive fragmentation or rejection.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates the priority of each bin based on the remaining capacity and item size, favoring bins that can accommodate the item with minimal wasted space and penalizing those that would lead to excessive fragmentation or rejection.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority.append(1 / (cap - item + 0.0001))  # Minimize wasted space\n        else:\n            priority.append(-1000)  # Penalize infeasible bins\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 74.00879436282185
     },
     {
          "algorithm": "The algorithm assigns a priority score to each bin based on its remaining capacity, favoring bins that can accommodate the item without excessive waste, and penalizing bins that are nearly full or too large.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{The algorithm assigns a priority score to each bin based on its remaining capacity, favoring bins that can accommodate the item without excessive waste, and penalizing bins that are nearly full or too large.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      waste = cap - item\n      priority.append(1 / (waste + 0.1)) \n    else:\n      priority.append(-1000)\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 74.00879436282185
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and wasted space if the item is placed in the bin, preferring bins that can accommodate the item with minimal wasted space while also considering bins that are already relatively full.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and wasted space if the item is placed in the bin, preferring bins that can accommodate the item with minimal wasted space while also considering bins that are already relatively full.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            # Give higher priority to bins with less wasted space and bins that are already relatively full.\n            priority_score = 1 / (wasted_space + 0.0001) + (1 - cap)  #Adding small value to avoid dividing by 0 and normalizing the wasted space.\n        else:\n            priority_score = -1  # Assign a negative priority if the item doesn't fit\n        priority.append(priority_score)\n    return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 74.00879436282185
     },
     {
          "algorithm": "This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins where the remaining capacity is close to a predetermined threshold, or favoring almost full bins if the item is large.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on the remaining capacity after placing the item, favoring bins where the remaining capacity is close to a predetermined threshold, or favoring almost full bins if the item is large.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if item <= cap:\n      remaining_cap = cap - item\n      if item > 0.5:\n        priority.append(100-remaining_cap if remaining_cap >=0 else -100)\n      else:\n          target_cap = 0.25\n          priority.append(max(0, 100 - abs(remaining_cap - target_cap)*10))\n    else:\n      priority.append(-100)\n  return priority",
          "objective": 4.04866,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "Assign a priority score to each bin based on a combination of remaining capacity, wasted space, and a penalty for nearly full bins to balance space utilization and bin count.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{Assign a priority score to each bin based on a combination of remaining capacity, wasted space, and a penalty for nearly full bins to balance space utilization and bin count.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      if wasted_space == 0:\n          wasted_space_score = 100\n      else:\n          wasted_space_score = 100/(wasted_space + 0.001) \n\n      # Penalize bins that become very full after placing the item\n      if cap - item < 0.1:  # Assuming bin size is normalized to 1\n        penalty = -50\n      else:\n        penalty = 0\n      \n      priority_score = wasted_space_score + penalty\n      priority.append(priority_score)\n    else:\n      priority.append(-float('inf'))  # Not feasible, assign lowest priority\n  return priority",
          "objective": 4.4276,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of factors: how well the item fits (using a ratio of item size to remaining capacity), how full the bin would be after packing, and a bonus for bins that are already relatively full.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm calculates the priority of each bin based on a combination of factors: how well the item fits (using a ratio of item size to remaining capacity), how full the bin would be after packing, and a bonus for bins that are already relatively full.}\n    \"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if item <= cap:\n            fit_ratio = item / cap  # How well the item fits into the remaining space\n            fullness_after_pack = (cap - item) / 100 # How full the bin will be after packing\n            \n            # Bonus for bins that are already relatively full\n            full_bin_bonus = 0\n            if cap < 25: #arbitrary value\n                full_bin_bonus = 0.5\n\n            priority = fit_ratio + (1 - fullness_after_pack) + full_bin_bonus\n        else:\n            priority = -1  # Impossible to pack\n\n        priorities.append(priority)\n    return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm assigns a priority score to each bin based on how much space would be wasted if the item is placed in that bin, favoring bins that would be filled more completely, and also considering the current fill level of the bin and the item size to penalize bins that are already too full or would be almost empty after placement.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm assigns a priority score to each bin based on how much space would be wasted if the item is placed in that bin, favoring bins that would be filled more completely, and also considering the current fill level of the bin and the item size to penalize bins that are already too full or would be almost empty after placement.}\n    \"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            fill_ratio = item / cap\n            \n            # Prioritize bins with less waste. Add a small penalty for nearly empty or nearly full bins\n            priority = 1 / (waste + 0.0001) + fill_ratio - abs(fill_ratio - 0.5)/5\n\n            priorities.append(priority)\n        else:\n            priorities.append(-1)  # Assign very low priority if the item doesn't fit\n\n    return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a weighted sum of remaining capacity and wasted space if the item is placed in the bin, favoring bins with smaller wasted space and higher remaining capacity.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on a weighted sum of remaining capacity and wasted space if the item is placed in the bin, favoring bins with smaller wasted space and higher remaining capacity.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      # Assign priority based on remaining capacity and wasted space.\n      # Higher remaining capacity and lower wasted space are favored.\n      priority = (cap * 0.7) - (wasted_space * 0.3)\n      priorities.append(priority)\n    else:\n      priorities.append(-1)  # Assign -1 priority if the item doesn't fit.\n  return priority",
          "objective": 4.48744,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm assigns a priority score to each bin based on how much empty space would remain after packing the item, favoring bins that would be filled close to full but not overfilled, and also factoring in existing fill levels.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm assigns a priority score to each bin based on how much empty space would remain after packing the item, favoring bins that would be filled close to full but not overfilled, and also factoring in existing fill levels.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      remaining_space = cap - item\n      if remaining_space == 0:\n          priority.append(1000) #perfect fit\n      else:\n          priority.append(100/(remaining_space+0.0001) + cap) # high score if remaining_space is low and also proportional to existing capacity\n    else:\n      priority.append(-1)\n  return priority",
          "objective": 84.77264,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, prioritizing bins with sufficient capacity and minimal wasted space.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, prioritizing bins with sufficient capacity and minimal wasted space.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            wasted_space = cap - item\n            priority_score = cap + (1.0 / (wasted_space + 0.00001)) # Adding a small constant to prevent division by zero.\n            priority.append(priority_score)\n        else:\n            priority.append(-1)  # Assign a low priority if the bin cannot accommodate the item\n    return priority",
          "objective": 86.58755,
          "other_inf": null,
          "SLOC": 10.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 74.00879436282185
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins with closer remaining capacity to item size and less waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm calculates the priority of each bin based on a combination of remaining capacity and the wasted space if the item is placed in the bin, favoring bins with closer remaining capacity to item size and less waste.}\n    \"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            waste = cap - item\n            priority.append(cap - waste/2 ) # Modified priority\n        else:\n            priority.append(-1)\n    return priority",
          "objective": 149.30195,
          "other_inf": null,
          "SLOC": 9.0,
          "cyclomatic_complexity": 3.0,
          "halstead": 46.50699332842308
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin by considering both remaining capacity and how much of the bin is filled after placing the item, prioritizing bins that can accommodate the item well without excessive waste.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin by considering both remaining capacity and how much of the bin is filled after placing the item, prioritizing bins that can accommodate the item well without excessive waste.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_ratio = (item / (bins_remain_cap[0] + cap))\n      remaining_ratio = (cap - item) / bins_remain_cap[0]\n      priority.append(fill_ratio - remaining_ratio)\n    else:\n      priority.append(-1)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a weighted combination of remaining capacity and the fill ratio after placing the item.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on a weighted combination of remaining capacity and the fill ratio after placing the item.}\"\"\"\n  priorities = []\n  for capacity in bins_remain_cap:\n    if capacity >= item:\n      fill_ratio = (capacity - item) / (sum(bins_remain_cap) - item) if (sum(bins_remain_cap) - item) > 0 else 0 # Prevent zero division\n      priority = capacity - item + 0.1 * fill_ratio\n    else:\n      priority = -1 \n    priorities.append(priority)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with closer fits and lower wasted space while penalizing bins that are too full.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and wasted space if the item is placed in the bin, favoring bins with closer fits and lower wasted space while penalizing bins that are too full.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      wasted_space = cap - item\n      priority_score = (1.0 / (wasted_space + 0.1)) + (item / (cap + 0.1)) #Adding 0.1 to denominators to avoid division by zero\n      priority.append(priority_score)\n    else:\n      priority.append(-1000) # Penalize bins that cannot fit the item\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a weighted sum of remaining capacity closeness and how full the bin would be after packing the item, favoring bins that are nearly full after packing and penalizing bins that would be nearly empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm prioritizes bins based on a weighted sum of remaining capacity closeness and how full the bin would be after packing the item, favoring bins that are nearly full after packing and penalizing bins that would be nearly empty.}\"\"\"\n  priorities = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      fill_percentage_after = (1 - (cap - item) / 100)\n      closeness = 100 - abs(cap - item)\n      score = 0.7 * fill_percentage_after + 0.3 * closeness\n    else:\n      score = -1000 \n    priorities.append(score)\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates the priority of each bin based on the remaining capacity and the item size, favoring bins that can accommodate the item with minimal waste and penalizing those that are too full or too empty.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates the priority of each bin based on the remaining capacity and the item size, favoring bins that can accommodate the item with minimal waste and penalizing those that are too full or too empty.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority.append((cap - item) / (sum(bins_remain_cap)/len(bins_remain_cap))) # Reduced waste, normalized by average bin capacity\n    else:\n      priority.append(-1000) # Large negative priority if bin is too full\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and how well the item fits, favoring bins with slightly more capacity than the item size while penalizing those with much larger or smaller capacities.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"{This algorithm prioritizes bins based on a combination of remaining capacity and how well the item fits, favoring bins with slightly more capacity than the item size while penalizing those with much larger or smaller capacities.}\"\"\"\n    priority = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            priority_score = (\n                1 / (abs(cap - item) + 0.01)\n            )  \n        else:\n            priority_score = -1000  # Very low priority if item doesn't fit\n        priority.append(priority_score)\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm calculates a priority score for each bin based on a combination of remaining capacity and how well the item fits, favoring bins with enough space but also prioritizing those where the item fills a significant portion of the remaining capacity.",
          "code": "def priority_v2(item, bins_remain_cap):\n  \"\"\"{This algorithm calculates a priority score for each bin based on a combination of remaining capacity and how well the item fits, favoring bins with enough space but also prioritizing those where the item fills a significant portion of the remaining capacity.}\"\"\"\n  priority = []\n  for cap in bins_remain_cap:\n    if cap >= item:\n      priority_score = (item / cap) + (cap - item) / max(bins_remain_cap) #Ratio filled and remaining space.\n      priority.append(priority_score)\n    else:\n      priority.append(-1)  # Assign a low priority if the item doesn't fit\n  return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     },
     {
          "algorithm": "This algorithm prioritizes bins based on a combination of remaining capacity and how well the item fits, favoring bins with enough space and a close fit.",
          "code": "def priority_v2(item, bins_remain_cap):\n    \"\"\"\n    {This algorithm prioritizes bins based on a combination of remaining capacity and how well the item fits, favoring bins with enough space and a close fit.}\n    \"\"\"\n    priorities = []\n    for cap in bins_remain_cap:\n        if cap >= item:\n            fit_ratio = item / cap\n            priorities.append(fit_ratio)\n        else:\n            priorities.append(-1)\n    return priority",
          "objective": Infinity,
          "other_inf": null,
          "SLOC": null,
          "cyclomatic_complexity": null,
          "halstead": null
     }
]