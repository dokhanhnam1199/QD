{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Improved priority function focusing on reducing fragmentation and maximizing bin utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        return np.zeros_like(bins_remain_cap) - np.inf\n\n    bin_capacity = np.max(bins_remain_cap)\n\n    # 1. Fill Ratio Maximization (Aggressive)\n    fill_ratio = item / bins_remain_cap\n    fill_ratio[~eligible_bins] = -np.inf\n    priorities = 1.5 * fill_ratio  # Increased fill ratio importance.\n\n    # 2. Encourage existing fill (but less aggressively than fill ratio).\n    existing_fill = 1 - (bins_remain_cap / bin_capacity)\n    priorities[eligible_bins] += 0.2 * existing_fill[eligible_bins]\n\n    # 3. Fragmentation Penalty (Adaptive and more sensitive)\n    gap_size = bins_remain_cap - item\n    small_gap = gap_size < (0.2 * bin_capacity)\n    avg_item_size = np.mean(item) if isinstance(item, np.ndarray) else item\n    penalty_factor = 0.2 + 0.1 * (avg_item_size / bin_capacity)  # Increased base penalty.\n    priorities[small_gap & eligible_bins] -= penalty_factor\n\n    # 4. Near-Perfect Fit Reward (More significant reward)\n    near_perfect_fit = np.isclose(bins_remain_cap, item, rtol=1e-05, atol=1e-06)\n    priorities[near_perfect_fit & eligible_bins] += 0.05\n\n    # 5. Prioritize larger remaining capacity (slightly adjusted weight)\n    priorities[eligible_bins] += 0.05 * (bins_remain_cap[eligible_bins] / bin_capacity)\n\n    # 6. Significant penalty for bins that become nearly full, with dynamic threshold\n    min_useful_capacity = 0.15 * bin_capacity\n    nearly_full = gap_size < min_useful_capacity\n    priorities[nearly_full & eligible_bins] -= 0.15  # Increased penalty\n\n    # 7. Look-Ahead Fragmentation Penalty (Relative to smallest item) - Enhanced penalty.\n    min_item_size = np.min(item) if isinstance(item, np.ndarray) else item\n    if min_item_size > 0:\n        very_small_gap = gap_size < (0.4 * min_item_size)  # Reduced threshold\n        priorities[very_small_gap & eligible_bins] -= 0.2  # Increased penalty\n\n    # 8. Reward bins close to half-full (Balance utilization with future flexibility)\n    half_full_range_lower = 0.4 * bin_capacity\n    half_full_range_upper = 0.6 * bin_capacity\n\n    close_to_half = (bins_remain_cap >= (item + half_full_range_lower)) & (bins_remain_cap <= (item + half_full_range_upper))\n    priorities[close_to_half & eligible_bins] += 0.08  # Moderate reward\n\n    # 9. Scale and Clip\n    priorities = np.clip(priorities, -1, 1)\n\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, let's redefine self-reflection for better heuristic design, focusing on actionable insights and avoiding common pitfalls.\n\nHere's a breakdown:\n\n*   **Keywords:** Objective functions, problem structure, iterative refinement, ablation studies, generalization, adaptability, computational cost, exploration-exploitation balance.\n\n*   **Advice:** Focus on understanding *why* a heuristic works (or doesn't). Analyze performance across diverse problem instances to identify weaknesses and opportunities for improvement. Prioritize adaptability and computational efficiency in design.\n\n*   **Avoid:** Premature complexity, reliance on isolated performance metrics, lack of problem structure analysis, and neglecting computational cost.\n\n*   **Explanation:** Effective self-reflection involves deeply understanding the problem, the heuristic's limitations, and how design choices influence generalization and computational efficiency. Iteratively refine based on rigorous analysis and ablation, always questioning the value of added complexity.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}