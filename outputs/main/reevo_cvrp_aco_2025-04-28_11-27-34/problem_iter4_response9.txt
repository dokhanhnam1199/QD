```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates global angle information, stochasticity, adaptive sparsification, and a Gaussian-like demand factor.

    Args:
        distance_matrix: A NumPy array representing the distance between nodes.
        coordinates: A NumPy array of node coordinates (x, y).
        demands: A NumPy array of node demands.
        capacity: The capacity of each vehicle.

    Returns:
        A NumPy array of the same shape as the distance_matrix, representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angle costs (encourage smoother routes - global info)
    angle_costs = np.zeros((n, n, n))
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if i != j and i != k and j != k:
                    v1 = coordinates[j] - coordinates[i]
                    v2 = coordinates[k] - coordinates[i]
                    dot_product = np.dot(v1, v2)
                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                    if magnitudes > 0:
                        angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))
                        angle_costs[i, j, k] = angle
                    else:
                        angle_costs[i, j, k] = np.pi  # Penalize if nodes are the same

    # Calculate combined heuristic values
    for i in range(n):
        for j in range(n):
            if i != j:
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)

                # Gaussian-like demand factor (centered around half capacity)
                demand_factor = np.exp(-((demands[i] + demands[j]) / (2 * capacity) - 0.5) ** 2 / 0.08)

                # Angle consideration: Favoring routes that avoid sharp turns.
                angle_penalty = 0.0
                for k in range(n):  # Penalize smaller angles by averaging
                    if i != k and j != k:
                        angle_penalty += angle_costs[i, j, k]
                angle_penalty /= (n - 2 + 1e-6)
                angle_factor = np.exp(-((angle_penalty - np.pi/2) / (np.pi/4))**2) #gaussian centered at pi/2

                # Stochasticity: Add a small random value
                stochastic_factor = np.random.uniform(0.5, 1.5)

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * stochastic_factor

    # Adaptive Sparsification (based on average degree)
    avg_degree = int(np.sqrt(n))  # Desired average degree
    for i in range(n):
        row = heuristic_matrix[i, :].copy()
        indices = np.argpartition(row, -avg_degree)[-avg_degree:]
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristic_matrix[i, mask] = 0.0

    np.fill_diagonal(heuristic_matrix, 0)
    return heuristic_matrix
```
