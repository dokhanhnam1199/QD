```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling.

    This version combines distance, demand, and angular considerations to estimate edge desirability.
    It also sparsifies the matrix by zeroing out unpromising edges.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands for each node (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of edge desirability (n x n).  Values closer to 1 are more promising.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.5
    sparsification_threshold = 2.0 # Threshold for relative distance to filter edges

    # Calculate angle between each node and the depot (node 0)
    depot_coords = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):
        vector = coordinates[i] - depot_coords
        angles[i] = np.arctan2(vector[1], vector[0])  # Angle in radians

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics[i, j] = 0  # No self-loops
                continue

            # Distance factor (inverse relationship)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6) # Adding a small constant to prevent division by zero

            # Demand factor (higher demand makes an edge less desirable if capacity is close)
            demand_factor = 1.0 - min(1.0, demands[i] / capacity) if i != 0 else 1.0  # Depot has "no demand penalty"
            demand_factor *= 1.0 - min(1.0, demands[j] / capacity) if j != 0 else 1.0

            # Angle factor: penalize large changes in angles from depot
            angle_diff = abs(angles[i] - angles[j])
            angle_factor = 1.0 - min(1.0, angle_diff / np.pi) # Normalize to 0-1 range

            # Combine factors
            heuristics[i, j] = (distance_weight * distance_factor +
                                 demand_weight * demand_factor +
                                 angle_weight * angle_factor)

            # Sparsification:  Zero out edges that are "too long" relative to the nearest neighbor
            nearest_neighbor_dist = np.partition(distance_matrix[i, :], 2)[1] # distance to the second nearest neighbor
            if distance_matrix[i, j] > sparsification_threshold * nearest_neighbor_dist:
                heuristics[i, j] = 0

    # Normalize to [0, 1] (after sparsification)
    max_heuristic = np.max(heuristics)
    if max_heuristic > 0:
        heuristics /= max_heuristic
    else:
        # Handle the case where all heuristics are zero (unlikely but possible)
        heuristics = np.ones_like(heuristics) * 0.1

    return heuristics
```
