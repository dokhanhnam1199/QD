```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP based on stochastic solution sampling principles.
    Combines distance, demand, and angle considerations for edge prioritization.

    Args:
        distance_matrix: Distance matrix between nodes.
        coordinates: Euclidean coordinates of nodes.
        demands: Demand of each node.
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as distance_matrix, indicating the
        prior probability/promisingness of including each edge in a solution.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (tuned through experimentation)
    distance_weight = 0.5  # Higher value prioritizes shorter distances
    demand_weight = 0.3  # Higher value penalizes edges connecting nodes with high demands relative to capacity
    angle_weight = 0.2  # Higher value prefers edges that don't cause sharp turns

    # Calculate angle cost
    angle_cost_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                # For each pair of nodes i and j, assess if forming the edges to them
                # from a third node k, would lead to a sharp turn.

                angles = []
                for k in range(n):
                    if k != i and k != j:
                        # Calculate angle between vectors ki and kj
                        vec_ki = coordinates[i] - coordinates[k]
                        vec_kj = coordinates[j] - coordinates[k]

                        norm_ki = np.linalg.norm(vec_ki)
                        norm_kj = np.linalg.norm(vec_kj)

                        if norm_ki > 0 and norm_kj > 0:
                            cos_angle = np.dot(vec_ki, vec_kj) / (norm_ki * norm_kj)
                            angle = np.arccos(np.clip(cos_angle, -1.0, 1.0))  # Clip for numerical stability
                            angles.append(angle)

                if angles:
                    angle_cost_matrix[i, j] = np.mean(angles) # Use average as a general score. Small angle value = big cost
                else:
                    angle_cost_matrix[i, j] = np.pi  # Maximum penalty if no other nodes available


    # Normalize demands relative to capacity
    normalized_demands = demands / capacity

    for i in range(n):
        for j in range(n):
            if i != j:
                # Edge desirability score
                distance_score = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero
                demand_score = 1 - min(1.0, normalized_demands[i] + normalized_demands[j]) # Penalize high total demands

                heuristic_matrix[i, j] = (
                    distance_weight * distance_score +
                    demand_weight * demand_score +
                    angle_weight * (1/(angle_cost_matrix[i, j]+1e-6))
                )

    # Sparsification: Zero out edges unlikely to be in the solution (Optional, but helpful)
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20) # Dynamic thresholding for sparsification
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
