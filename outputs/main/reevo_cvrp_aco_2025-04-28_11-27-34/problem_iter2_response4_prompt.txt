{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling. CVRP requires finding the shortest path that visits all given nodes and returns to the starting node. Each node has a demand and each vehicle has a capacity. The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity. When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.\nThe `heuristics` function takes as input a distance matrix (shape: n by n), Euclidean coordinates of nodes (shape: n by 2), a vector of customer demands (shape: n), and the integer capacity of vehicle capacity. It returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the distance_matrix. The depot node is indexed by 0.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n x 2).\n        demands (np.ndarray): Vector of customer demands (shape: n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Calculate savings for each edge (Clark-Wright savings heuristic)\n    savings_matrix = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]\n            savings_matrix[j, i] = savings_matrix[i, j]  # Ensure symmetry\n\n    # Combine distance and savings information.  Also, add demand based factor\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Inverse distance (shorter distances are better)\n                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Add small constant to avoid division by zero\n                \n                # Savings factor (higher savings are better). Handle depot node.\n                savings_factor = 0.0\n                if i != 0 and j != 0:  #Only compute if not starting from the depot\n                  savings_factor = savings_matrix[i, j]\n                \n                demand_factor = 1.0\n                if i != 0 and j!= 0: # Only factor in when going from one customer to another\n                  demand_factor = 1 / (demands[i] + demands[j] + 1e-6) #penalize for large demand for the customers i and j\n\n                heuristic_matrix[i, j] = distance_factor + savings_factor * 0.5 + demand_factor * 0.1  # Weigh the factors\n\n\n    # Sparsify the matrix: remove less promising edges\n    # Option 1: Keep only the k-nearest neighbors for each node\n    k = int(np.sqrt(n))  # Dynamic k based on problem size. Tune if needed\n    for i in range(n):\n        # Get the indices of the k smallest distances from node i\n        nearest_neighbors = np.argsort(distance_matrix[i, :])[1:k+1]  # Exclude itself and take the k nearest\n        \n        # Zero out all but the k nearest neighbors in the heuristic matrix\n        for j in range(n):\n            if j not in nearest_neighbors and i != j:\n                heuristic_matrix[i, j] = 0.0\n\n    #Option 2: Thresholding. Remove edges that do not exceed a certain threshold\n\n    #normalizing the heuristic matrix\n    max_heuristic = np.max(heuristic_matrix)\n\n    if max_heuristic > 0:\n      heuristic_matrix = heuristic_matrix / max_heuristic\n    threshold = 0.1 #Remove edges with very low probabilities (tuneable).\n\n    heuristic_matrix[heuristic_matrix < threshold] = 0.0\n\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) using a combination of factors.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).\n        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).\n        demands (np.ndarray): Demand of each customer (n).\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Heuristic factors:\n    # 1. Distance: Shorter distances are more promising.\n    distance_factor = 1 / (distance_matrix + 1e-6)  # Avoid division by zero\n\n    # 2. Angle: Edges that create sharp turns are less promising.\n    angle_factor = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Calculate angles between edges (depot -> i) and (i -> j)\n                vector1 = coordinates[i] - coordinates[0]\n                vector2 = coordinates[j] - coordinates[i]\n\n                # Normalize vectors\n                norm1 = np.linalg.norm(vector1)\n                norm2 = np.linalg.norm(vector2)\n                if norm1 > 0 and norm2 > 0:  # avoid division by 0.\n                    vector1 = vector1 / norm1\n                    vector2 = vector2 / norm2\n                    dot_product = np.dot(vector1, vector2)\n                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Clip to avoid errors\n                    angle_factor[i, j] = 1 - (angle / np.pi) # closer to 1 when it is straight\n\n    # 3. Demand: Edges connecting nodes with higher demands might be less promising if vehicle is almost full.\n    demand_factor = np.ones((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j and i != 0 and j !=0: #avoid edge from depot to depot. \n                demand_factor[i, j] = 1 / (demands[i] + demands[j] + 1e-6) #penalize higher demand\n\n    # Combine factors\n    heuristic_matrix = distance_factor * angle_factor * demand_factor\n\n    # Sparsify: Remove edges that are very long or unlikely to be in the solution.\n    # This reduces the search space and can improve performance.\n    distance_threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)  # 75th percentile\n    heuristic_matrix[distance_matrix > distance_threshold] = 0\n    np.fill_diagonal(heuristic_matrix, 0) # Ensure depot->depot edge is excluded.\n    #Normalize heuristic matrix\n\n    max_heuristic = np.max(heuristic_matrix)\n    if max_heuristic > 0:\n        heuristic_matrix = heuristic_matrix / max_heuristic\n\n    return heuristic_matrix\n\n[Reflection]\nAngles, adaptive thresholds, and multiplicative factor combination are key improvements.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}