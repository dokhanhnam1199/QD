```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) using a multiplicative combination of factors,
    Gaussian demand scaling, adaptive sparsification, and improved depot handling.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each customer (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance Factor (Inverse Distance)
    distance_factor = 1 / (distance_matrix + 1e-6)

    # 2. Depot Proximity Factor (Improved)
    depot_proximity_factor = np.zeros((n, n))
    depot_distances = distance_matrix[0, 1:]  # Distances from depot to customers
    avg_depot_distance = np.mean(depot_distances)
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                depot_proximity_factor[i, j] = np.exp(-0.5 * (distance_matrix[0, i] + distance_matrix[0, j]) / (avg_depot_distance + 1e-6))
            else:
                depot_proximity_factor[i,j] = 0.0


    # 3. Angle Factor (Improved)
    angle_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                v1 = coordinates[i] - coordinates[0]  # Vector from depot to node i
                v2 = coordinates[j] - coordinates[i]  # Vector from node i to node j

                norm1 = np.linalg.norm(v1)
                norm2 = np.linalg.norm(v2)

                if norm1 > 0 and norm2 > 0:
                    v1_norm = v1 / norm1
                    v2_norm = v2 / norm2
                    dot_product = np.dot(v1_norm, v2_norm)
                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))
                    angle_factor[i, j] = 1 - (angle / np.pi)
                else:
                    angle_factor[i,j] = 0.5  #If very close to depot.


    # 4. Demand-Capacity Scaling Factor (Gaussian-like and penalize high demand)
    demand_factor = np.ones((n, n))
    for i in range(1, n):  # Customers only
        for j in range(1, n):  # Customers only
            if i != j:
                combined_demand = demands[i] + demands[j]
                # More aggressive penalty for exceeding capacity
                if combined_demand > capacity:
                     demand_factor[i, j] = 0.1 * np.exp(-0.5 * ((combined_demand / capacity) - 1)**2) # Much lower prob
                else:
                    demand_factor[i, j] = np.exp(-0.5 * ((combined_demand / capacity) - 0.75)**2)  # Gaussian around a fraction of capacity

    # 5. Randomness Factor (Optional) - Removed for simplicity and focus on core factors

    # Combine factors multiplicatively
    heuristic_matrix = distance_factor * depot_proximity_factor * angle_factor * demand_factor

    # Adaptive Sparsification based on quantiles (Improved - focus on top edges)
    max_heuristic_value = np.max(heuristic_matrix) #Get max value before zeroing edges.
    sparsification_threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.50) # Keep top 50% edges

    heuristic_matrix[heuristic_matrix < sparsification_threshold] = 0
    np.fill_diagonal(heuristic_matrix, 0)  # Ensure depot->depot edge is excluded

    #Boost depot edges to leave depot.
    for i in range(1,n):
        heuristic_matrix[0,i] *= 1.1

    # Normalization
    if max_heuristic_value > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic_value

    return heuristic_matrix
```
