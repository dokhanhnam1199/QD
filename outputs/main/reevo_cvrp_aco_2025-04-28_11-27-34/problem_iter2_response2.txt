```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function calculates a matrix of edge weights representing the "promise" of including each edge in a solution.
    It combines several factors to estimate edge suitability, including distance, demand, angle, and a stochastic element.

    Args:
        distance_matrix (np.ndarray): A matrix (n x n) representing the distances between each pair of nodes.
        coordinates (np.ndarray): A matrix (n x 2) containing the Euclidean coordinates of each node.
        demands (np.ndarray): A vector (n) representing the demand of each node.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix (n x n) of edge weights representing the promise of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angle costs (encourage smoother routes)
    angle_costs = np.zeros((n, n, n))
    for i in range(n):
        for j in range(n):
            for k in range(n):
                if i != j and i != k and j != k:
                    v1 = coordinates[j] - coordinates[i]
                    v2 = coordinates[k] - coordinates[i]
                    dot_product = np.dot(v1, v2)
                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                    if magnitudes > 0:
                        angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))
                        angle_costs[i, j, k] = angle
                    else:
                        angle_costs[i, j, k] = np.pi  # Penalize if nodes are the same

    # Calculate combined heuristic values
    for i in range(n):
        for j in range(n):
            if i != j:
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)
                demand_factor = np.exp(-((demands[i] + demands[j]) / (2 * capacity) - 0.5) ** 2 / 0.08)

                # Angle consideration: Favoring routes that form angles far from straight lines.
                angle_penalty = 0.0
                for k in range(n):  # penalize smaller angles by averaging
                    if i != k and j != k:
                        angle_penalty += angle_costs[i, j, k]
                angle_penalty /= (n - 2 + 1e-6)
                angle_factor = angle_penalty

                # Stochasticity: Add a small random value
                stochastic_factor = np.random.uniform(0.5, 1.5)  # Random number between 0.5 and 1.5

                heuristic_matrix[i, j] = distance_factor * demand_factor * angle_factor * stochastic_factor

    # Adaptive Sparsification
    avg_degree = int(np.sqrt(n))  # Desired average degree
    for i in range(n):
        row = heuristic_matrix[i, :].copy()
        indices = np.argpartition(row, -avg_degree)[-avg_degree:]
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristic_matrix[i, mask] = 0.0

    np.fill_diagonal(heuristic_matrix, 0)
    return heuristic_matrix
```
