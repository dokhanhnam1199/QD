```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function calculates a matrix of edge weights representing the "promise" of including each edge in a solution.
    It combines several factors to estimate edge suitability, including distance, demand, a global angle consideration, and stochasticity.

    Args:
        distance_matrix (np.ndarray): A matrix (n x n) representing the distances between each pair of nodes.
        coordinates (np.ndarray): A matrix (n x 2) containing the Euclidean coordinates of each node.
        demands (np.ndarray): A vector (n) representing the demand of each node.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix (n x n) of edge weights representing the promise of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angle costs (encourage smoother routes) - Global context
    angle_costs = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                angles = []
                for k in range(n):
                    if i != k and j != k:
                        v1 = coordinates[j] - coordinates[i]
                        v2 = coordinates[k] - coordinates[i]
                        dot_product = np.dot(v1, v2)
                        magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)
                        if magnitudes > 0:
                            angle = np.arccos(np.clip(dot_product / magnitudes, -1.0, 1.0))
                            angles.append(angle)
                        else:
                            angles.append(np.pi)  # Penalize if nodes are the same

                angle_costs[i, j] = np.mean(angles) if angles else np.pi  # Average angle cost

    # Calculate combined heuristic values
    distance_factor = 1.0 / (distance_matrix + 1e-6)  # Avoid division by zero
    demand_factor = 1.0 / (demands[:, None] + demands[None, :] + 1e-6) #Avoid division by zero

    # Angle consideration: Favoring routes that form angles far from straight lines.
    angle_factor = angle_costs

    # Stochasticity: Add a small random value
    stochastic_factor = np.random.uniform(0.5, 1.5, size=(n,n))  # Random number between 0.5 and 1.5

    heuristic_matrix = distance_factor * demand_factor * angle_factor * stochastic_factor


    # Sparsify the matrix (optional, but often helpful)
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 20)  # Keep top 80%
    heuristic_matrix[heuristic_matrix < threshold] = 0
    np.fill_diagonal(heuristic_matrix, 0)
    return heuristic_matrix
```
