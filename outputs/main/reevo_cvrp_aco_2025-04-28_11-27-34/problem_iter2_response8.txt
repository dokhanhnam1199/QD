```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version refines the factors used to determine edge promise, including distance,
    angle between nodes, demand considerations, and introduces more sophisticated sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (tunable)
    distance_weight = 0.4  # Weight for distance factor
    angle_weight = 0.3     # Weight for angle factor
    demand_weight = 0.3    # Weight for demand factor
    sparsification_threshold = int(np.sqrt(n))  # Dynamic threshold based on problem size
    depot_proximity_weight = 0.1 #Weight for proximity to depot
    
    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Inverse of distance
                distance_factor = 1 / (distance_matrix[i, j] + 1e-9)

                # Angle factor: Penalize sharp turns.  More robust handling of depot connections.
                if i != 0 and j != 0:
                    v1 = coordinates[i] - coordinates[0]
                    v2 = coordinates[j] - coordinates[i]
                    v1_norm = np.linalg.norm(v1)
                    v2_norm = np.linalg.norm(v2)
                    if v1_norm > 0 and v2_norm > 0:
                        dot_product = np.dot(v1, v2)
                        angle = np.arccos(np.clip(dot_product / (v1_norm * v2_norm), -1.0, 1.0)) #Clip to avoid domain errors
                        angle_factor = 1 - (angle / np.pi)
                    else:
                        angle_factor = 0.5 # Default if a node is very close to the depot
                else:
                    angle_factor = 0.8  # Slightly incentivize depot connections

                # Demand factor: Consider remaining capacity
                remaining_capacity_i = capacity - demands[i] if i!=0 else capacity #Treat the depot as having full capacity
                remaining_capacity_j = capacity - demands[j] if j!=0 else capacity
                demand_compatibility = np.exp(-((demands[i] + demands[j]) / (2*capacity))**2 / 0.1)
                demand_factor = demand_compatibility

                # Depot proximity factor: Incentive to connect to nodes closer to the depot
                depot_distance_sum = distance_matrix[0, i] + distance_matrix[0, j] if (i != 0 and j != 0) else distance_matrix[0, i] if i!=0 else distance_matrix[0,j] if j!=0 else 0.0
                depot_proximity = np.exp(-depot_distance_sum / (np.mean(distance_matrix[0,:])+ 1e-9)) #Normalize the distance

                # Combine factors with weights
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor +
                    angle_weight * angle_factor +
                    demand_weight * demand_factor +
                    depot_proximity_weight * depot_proximity
                )

    # Sparsification: Adaptive thresholding and masking
    for i in range(n):
        row = heuristic_matrix[i, :].copy()
        # Exclude the self-loop (i, i)
        row[i] = -np.inf  # Ensure self-loop is not selected

        # Select top k neighbors
        indices = np.argpartition(row, -sparsification_threshold)[-sparsification_threshold:]

        # Zero out the rest
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristic_matrix[i, mask] = 0.0
    
    return heuristic_matrix
```
