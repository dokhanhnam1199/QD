```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle considerations to determine edge desirability.
    It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    distance_importance = 1.0
    demand_importance = 0.5
    angle_importance = 0.2
    capacity_threshold = 0.9  # Maximum allowable demand relative to capacity for single customer

    # Calculate angle cost (penalizes sharp turns)
    angle_cost = np.zeros((n, n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                for k in range(n):
                    if k != i and k != j:
                        v1 = coordinates[j] - coordinates[i]
                        v2 = coordinates[k] - coordinates[j]
                        v1_u = v1 / np.linalg.norm(v1) if np.linalg.norm(v1) > 0 else v1
                        v2_u = v2 / np.linalg.norm(v2) if np.linalg.norm(v2) > 0 else v2
                        angle = np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))
                        angle_cost[i, j, k] = angle
                        angle_cost[j, k, i] = angle


    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Shorter distances are more promising
                distance_factor = 1 / distance_matrix[i, j] if distance_matrix[i, j] > 0 else 0

                # Demand factor: Penalize edges connecting to high-demand nodes if exceeding the capacity threshold
                demand_factor = 1.0
                if demands[i] > capacity_threshold * capacity or demands[j] > capacity_threshold * capacity:
                    demand_factor = 0.1  # Heavily penalize high demand nodes

                # Angle factor: Encourages smoother routes
                avg_angle_cost = 0.0
                count = 0
                for k in range(n):
                    if k != i and k != j:
                         avg_angle_cost += angle_cost[i, j, k]
                         count += 1
                if count > 0:
                  avg_angle_cost /= count

                angle_factor = 1/(1 + avg_angle_cost) # smaller avg angle leads to a higher factor

                heuristic_matrix[i, j] = (
                    distance_importance * distance_factor +
                    demand_importance * demand_factor +
                    angle_importance * angle_factor
                )

    # Sparsify the matrix (set unpromising edges to zero)
    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2 # dynamically adjust threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0  # Remove less promising edges
    np.fill_diagonal(heuristic_matrix, 0)  # Ensure no self-loops
    return heuristic_matrix
```
