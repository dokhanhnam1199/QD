```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate savings for each pair of customers
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]  # Symmetry

    # Calculate normalized demand scores (higher is worse). depot demand is ignored
    normalized_demands = demands / capacity

    # Calculate distance-based heuristic with demand penalty
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = (
                    (1 / distance_matrix[i, j])
                    * (1 - normalized_demands[i])
                    * (1 - normalized_demands[j])
                )
                # Consider savings in conjunction
                if i > 0 and j > 0:
                    heuristic_matrix[i, j] *= (1 + savings_matrix[i,j] / np.max(savings_matrix))

    # Sparsify the matrix: remove edges that are not promising enough

    #Threshold is mean plus some multiple of standard deviation
    mean_heuristic = np.mean(heuristic_matrix)
    std_heuristic = np.std(heuristic_matrix)
    threshold = mean_heuristic - 0.5 * std_heuristic # Adjust the factor to control sparsity

    heuristic_matrix[heuristic_matrix < threshold] = 0 # Set less promising elements to 0

    #Ensure edges to depot (node 0) are always considered. This prevents disconnected tours.
    for i in range(1, n):
        if heuristic_matrix[0, i] == 0:
            heuristic_matrix[0, i] = 0.1 * np.max(heuristic_matrix)
        if heuristic_matrix[i, 0] == 0:
            heuristic_matrix[i, 0] = 0.1 * np.max(heuristic_matrix)

    return heuristic_matrix
```
