```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version refines the factors used to determine edge promise, including distance,
    angle between nodes, demand considerations, depot proximity, and incorporates adaptive sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (tunable)
    distance_weight = 0.4  # Weight for distance factor
    angle_weight = 0.3     # Weight for angle factor
    demand_weight = 0.2    # Weight for demand factor
    depot_proximity_weight = 0.1 #Weight for proximity to depot
    sparsification_threshold = int(np.sqrt(n))  # Dynamic threshold based on problem size

    # Normalize the coordinates to a smaller range for more stable angle calculations
    coordinates = coordinates / np.max(np.abs(coordinates))

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Inverse of distance
                distance_factor = 1 / (distance_matrix[i, j] + 1e-9)

                # Angle factor: Penalize sharp turns.  More robust handling of depot connections.
                if i != 0 and j != 0:
                    v1 = coordinates[i] - coordinates[0]
                    v2 = coordinates[j] - coordinates[i]
                    v1_norm = np.linalg.norm(v1)
                    v2_norm = np.linalg.norm(v2)
                    if v1_norm > 0 and v2_norm > 0:
                        dot_product = np.dot(v1, v2)
                        angle = np.arccos(np.clip(dot_product / (v1_norm * v2_norm), -1.0, 1.0)) #Clip to avoid domain errors
                        angle_factor = 1 - (angle / np.pi)
                    else:
                        angle_factor = 0.5 # Default if a node is very close to the depot
                else:
                    angle_factor = 0.7  # Slightly incentivize depot connections, less aggressive

                # Demand factor: Consider remaining capacity, and penalize high demand connections more
                demand_compatibility = np.exp(-((demands[i] + demands[j]) / (2*capacity))**2 / 0.05) # Sharper penalization
                demand_factor = demand_compatibility

                # Depot proximity factor: Incentive to connect to nodes closer to the depot
                depot_distance_sum = distance_matrix[0, i] + distance_matrix[0, j] if (i != 0 and j != 0) else distance_matrix[0, i] if i!=0 else distance_matrix[0,j] if j!=0 else 0.0
                depot_proximity = np.exp(-depot_distance_sum / (np.mean(distance_matrix[0,:])+ 1e-9)) #Normalize the distance

                # Combine factors with weights
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor +
                    angle_weight * angle_factor +
                    demand_weight * demand_factor +
                    depot_proximity_weight * depot_proximity
                )

    # Sparsification: Adaptive thresholding and masking.  Prioritize depot connections.
    for i in range(n):
        row = heuristic_matrix[i, :].copy()
        # Exclude the self-loop (i, i)
        row[i] = -np.inf  # Ensure self-loop is not selected

        # Prioritize depot connections
        if i != 0: # Don't prioritize depot leaving
            row[0] *= 1.2 # Slightly boost connection to depot.

        # Select top k neighbors
        indices = np.argpartition(row, -sparsification_threshold)[-sparsification_threshold:]

        # Zero out the rest
        mask = np.ones(n, dtype=bool)
        mask[indices] = False
        heuristic_matrix[i, mask] = 0.0
        
    # Normalize the matrix to [0, 1] range
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        heuristic_matrix /= max_val

    return heuristic_matrix
```
