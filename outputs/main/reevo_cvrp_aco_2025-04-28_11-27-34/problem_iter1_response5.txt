```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to determine the desirability of including each edge
    in a solution and sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate a combined heuristic score for each edge
    for i in range(n):
        for j in range(n):
            if i != j:
                # Factor 1: Inverse distance (closer nodes are generally better)
                distance_factor = 1 / distance_matrix[i, j]

                # Factor 2: Demand consideration (edges connecting nodes with high demand might be less desirable if they isolate routes )
                demand_factor_i = 1 / (demands[i] + 1e-6)  # Avoid division by zero
                demand_factor_j = 1 / (demands[j] + 1e-6)

                # Factor 3: Angle penalty (penalize sharp turns to encourage smoother routes). Higher the angles, more the penalty.
                angle_penalty = 0.0
                if i != 0 and j != 0:
                    #Calculate the angle between the edges depot-i and i-j to penalise sharp turn from depot to the client node
                    depot_x, depot_y = coordinates[0]
                    xi, yi = coordinates[i]
                    xj, yj = coordinates[j]

                    vector1 = np.array([depot_x - xi, depot_y - yi])
                    vector2 = np.array([xj - xi, yj - yi])

                    norm_vector1 = np.linalg.norm(vector1)
                    norm_vector2 = np.linalg.norm(vector2)

                    if norm_vector1 > 0 and norm_vector2 > 0:
                        dot_product = np.dot(vector1, vector2)
                        cosine_angle = dot_product / (norm_vector1 * norm_vector2)
                        angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0))  # Clip to avoid invalid arccos input
                        angle_penalty = angle
                        
                # Factor 4: Depot proximity. Edges to depot get higher values
                depot_proximity_i = 1/ (distance_matrix[i, 0] + 1e-6)
                depot_proximity_j = 1/ (distance_matrix[j, 0] + 1e-6)

                # Combine the factors (adjust weights as needed)
                heuristic_matrix[i, j] = (
                    0.5 * distance_factor +
                    0.15 * (demand_factor_i + demand_factor_j) +
                    0.15 * (1 / (angle_penalty+ 1e-6)) +
                    0.1 * (depot_proximity_i + depot_proximity_j)
                )


    # Sparsify the matrix (set unpromising edges to zero)

    # Method 1: Keep only top k edges for each node

    k = int(np.sqrt(n)) #Parameter can be tuned, ensures each node connects to some node, while sparsifying the matrix
    for i in range(n):
        row = heuristic_matrix[i, :].copy() #Copy to avoid modifying during sorting and indexing
        indices = np.argsort(row)[::-1]  # Indices of sorted values in descending order
        cutoff = indices[min(k, n-1)]
        heuristic_matrix[i, np.where(np.argsort(row) < cutoff)[0]] = 0 #Keep indices from 0 upto minimum index of k, n-1


    # Ensure depot is always connected
    for i in range(1, n):
        if heuristic_matrix[0,i] == 0:
          heuristic_matrix[0,i] = 0.0000001
        if heuristic_matrix[i,0] == 0:
          heuristic_matrix[i,0] = 0.0000001

    return heuristic_matrix
```
