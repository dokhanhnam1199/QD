```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for solving the Capacitated Vehicle Routing Problem (CVRP)
    via stochastic solution sampling.

    This version combines several factors to determine how promising it is to select an edge,
    including distance, demand, and node proximity. It also sparsifies the matrix
    by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                   (same shape as distance_matrix).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_importance = 0.5
    demand_importance = 0.3
    proximity_importance = 0.2
    sparsity_threshold = 0.1  # Adjust to control sparsity. Smaller -> more sparse


    # Calculate depot proximity for each node
    depot_distances = distance_matrix[0, :]
    normalized_depot_distances = (depot_distances - np.min(depot_distances)) / (np.max(depot_distances) - np.min(depot_distances) + 1e-9)  # Avoid division by zero

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor (normalized and inverted)
                distance_factor = 1 / (distance_matrix[i, j] + 1e-9)  # Avoid division by zero
                distance_factor = (distance_factor - np.min(1 / (distance_matrix[distance_matrix > 0] + 1e-9))) / (np.max(1 / (distance_matrix[distance_matrix > 0] + 1e-9)) - np.min(1 / (distance_matrix[distance_matrix > 0] + 1e-9)) + 1e-9) #normalize and handle zeros


                # Demand factor (consider demands of both nodes)
                demand_factor = 1 - min(demands[i] + demands[j], capacity) / capacity #closer to 1 the better. needs to be between 0 and 1.

                # Proximity factor (prefer edges where both nodes are close to the depot)
                proximity_factor = 1 - (normalized_depot_distances[i] + normalized_depot_distances[j]) / 2 #lower depot distance is better, needs to be between 0 and 1

                # Combine factors
                heuristic_value = (
                    distance_importance * distance_factor
                    + demand_importance * demand_factor
                    + proximity_importance * proximity_factor
                )

                heuristic_matrix[i, j] = heuristic_value

    # Sparsify the matrix (set low-value elements to zero)
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], sparsity_threshold) # Compute a threshold

    heuristic_matrix[heuristic_matrix < threshold] = 0
    np.fill_diagonal(heuristic_matrix, 0) #remove loops

    return heuristic_matrix
```
