```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) using a combination of factors.
    Version 4: Refines factor combinations with adaptive weights, dynamic sparsification based on problem size and demand,
    prioritizes depot proximity with a Gaussian decay, uses refined angle calculations with edge case handling,
    employs a demand factor that considers remaining vehicle capacity, and introduces controlled randomness scaled by distance.
    Normalization and edge case handling are improved for stability and performance.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Demand of each customer (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Distance Factor (Shorter distances are better)
    distance_factor = 1 / (distance_matrix + 1e-9)

    # 2. Depot Proximity Factor (Gaussian decay around depot, scaled by average depot distance)
    depot_distances = distance_matrix[0, 1:]
    avg_depot_distance = np.mean(depot_distances) if depot_distances.size > 0 else 0.0
    depot_proximity_factor = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            depot_proximity_factor[i, j] = np.exp(-((distance_matrix[0, i] + distance_matrix[j, 0]) / (2 * (avg_depot_distance + 1e-9)))**2)

    # 3. Angle Factor (Penalize sharp turns, handle edge cases at the depot)
    angle_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                v1 = coordinates[i] - coordinates[0]  # Vector from depot to i
                v2 = coordinates[j] - coordinates[i]  # Vector from i to j

                norm1 = np.linalg.norm(v1)
                norm2 = np.linalg.norm(v2)

                if norm1 > 0 and norm2 > 0:
                    v1_norm = v1 / norm1
                    v2_norm = v2 / norm2
                    dot_product = np.dot(v1_norm, v2_norm)
                    angle = np.arccos(np.clip(dot_product, -1.0, 1.0))
                    angle_factor[i, j] = 1 - (angle / np.pi)
                else:
                    angle_factor[i, j] = 0.5  # Handle cases when i or j is the depot

    # 4. Demand Factor (Considers remaining capacity, discourages overloading)
    demand_factor = np.ones((n, n))
    for i in range(n):
        for j in range(n):
            if i != j and i != 0 and j != 0:
                # Encourages pairings that leave sufficient capacity.
                demand_sum = demands[i] + demands[j]
                demand_factor[i, j] = np.exp(-(demand_sum / (capacity + 1e-9))**2) #Normalized to vehicle capacity

    # 5. Randomness (Introduce stochasticity scaled by distance)
    randomness_factor = np.random.normal(1, 0.1 * distance_factor, size=(n, n)) #Scale randomness inversely with distance
    randomness_factor = np.clip(randomness_factor, 0.5, 1.5)  # Limit randomness range

    # Adaptive Weights
    distance_weight = 0.4
    depot_proximity_weight = 0.2
    angle_weight = 0.2
    demand_weight = 0.2

    # Combine factors multiplicatively with adaptive weights
    heuristic_matrix = (distance_factor**distance_weight) * \
                       (depot_proximity_factor**depot_proximity_weight) * \
                       (angle_factor**angle_weight) * \
                       (demand_factor**demand_weight) * randomness_factor

    # Adaptive Sparsification (Dynamic quantile based on problem size and demand characteristics)
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        heuristic_matrix = heuristic_matrix / max_heuristic  # Normalize to [0, 1]
        #Quantile threshold based on problem size and average demand.
        avg_demand = np.mean(demands[1:])
        quantile_threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], min(0.5 + (n / 2000) + (avg_demand / capacity)/4 , 0.95)) #Adjust threshold

        heuristic_matrix[heuristic_matrix < quantile_threshold] = 0

    np.fill_diagonal(heuristic_matrix, 0)  # No self-loops

    return heuristic_matrix
```
