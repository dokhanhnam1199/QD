```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines distance, demand, and angle considerations to create a more informed prior
    for edge selection. It also sparsifies the matrix by setting unpromising elements to zero.

    Args:
        distance_matrix: Distance matrix (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: Vector of customer demands (shape: n).
        capacity: Vehicle capacity.

    Returns:
        Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters to control the influence of each factor
    distance_factor = 1.0
    demand_factor = 1.0
    angle_factor = 0.5
    capacity_margin_factor = 0.5

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance component: Inverse of distance
                distance_heuristic = distance_factor / distance_matrix[i, j]

                # Demand component:  Consider demand at destination.  Favor smaller demands initially
                demand_heuristic = 1.0 / (demands[j] + 1e-6)  # Add a small constant to avoid division by zero
                if demands[i] + demands[j] > capacity:
                    demand_heuristic = 0.0 #Very discourage if node demand exceeds capacity.

                # Angle component: Penalize sharp turns.
                angle_heuristic = 1.0
                if i != 0:
                    #compute angles only if we are not at depot.
                    #vector from i to depot
                    v1 = coordinates[0] - coordinates[i]
                    #vector from i to j
                    v2 = coordinates[j] - coordinates[i]

                    #Cosine of angle between vectors
                    dot_product = np.dot(v1, v2)
                    magnitudes = np.linalg.norm(v1) * np.linalg.norm(v2)

                    if magnitudes > 0: #avoid divison by zero if points coincide.
                      cosine_angle = dot_product / magnitudes
                      #Angle is between 0 and pi
                      angle = np.arccos(np.clip(cosine_angle, -1.0, 1.0)) #Clip for numerical stability

                      angle_heuristic = 1.0 / (angle + 1e-6) #prefer small turns (angles)
                      angle_heuristic = np.exp(-angle * angle_factor)  #exponential decay of desirability for larger angles


                # Combine the heuristics
                heuristic_matrix[i, j] = (
                    distance_heuristic +
                    demand_heuristic * demand_factor+
                    angle_heuristic * angle_factor
                )

    #Sparsify:  Set unpromising elements to zero
    #Keep only top K edges from each node
    K = int(np.sqrt(n)) #Number of neighbors proportional to sqrt of n
    for i in range(n):
      row = heuristic_matrix[i, :]
      indices = np.argsort(row)[::-1] #Sort and reverse
      threshold = row[indices[min(K, n-1)]] if K < n else 0.0 #Handle K > n cases

      heuristic_matrix[i, :] = np.where(heuristic_matrix[i, :] >= threshold, heuristic_matrix[i,:], 0.0)
    return heuristic_matrix
```
