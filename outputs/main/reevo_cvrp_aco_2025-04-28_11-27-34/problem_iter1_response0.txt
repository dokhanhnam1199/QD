```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This function combines several factors to determine how promising it is to select an edge,
    including distance, demand, and angle relative to the depot.  It also sparsifies the matrix
    by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution
                      (shape: same as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (can be tuned)
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.2
    capacity_threshold = 0.8  #Edges with both nodes with individual demand greater than % of the capacity is pruned.

    # Calculate angle of each node relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    #Create a mask to ignore direct returns from the depot back to depot.
    depot_mask = np.ones((n,n))
    depot_mask[0,0] = 0
    
    # Create an edge pruning mask if demands exceed vehicle capacity
    demand_pruning_mask = np.ones((n,n))

    for i in range(n):
      for j in range(n):
        if demands[i] > capacity * capacity_threshold or demands[j] > capacity * capacity_threshold:
            demand_pruning_mask[i,j] = 0
        if i == j:
            demand_pruning_mask[i,j] = 0 # Ensure no node self-loops

    for i in range(n):
        for j in range(n):
            if i != j and i != 0 and j !=0 : # Do not select routes from or to depot initially except return to the depot from other places.
                distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero
                demand_factor = np.exp(-demands[i] / capacity) * np.exp(-demands[j] / capacity)  # Favor edges with lower demand nodes
                angle_diff = np.abs(angles[i] - angles[j])
                angle_factor = np.exp(-angle_diff) # penalize large angle differences to favor smoother routes.


                heuristic_matrix[i, j] = (
                        distance_weight * distance_factor +
                        demand_weight * demand_factor +
                        angle_weight * angle_factor
                )
                
    #Prioritize return to the depot
    for i in range(1, n):
        heuristic_matrix[i,0] = np.mean(heuristic_matrix) * 2 # Set to a high value but not inf

    heuristic_matrix = heuristic_matrix * depot_mask * demand_pruning_mask

    # Sparsify the matrix (set unpromising edges to zero)
    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.1 # small percentage of the non-zero averages.
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
