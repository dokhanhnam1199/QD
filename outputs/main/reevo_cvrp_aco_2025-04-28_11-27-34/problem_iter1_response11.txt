```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distance between each pair of nodes.
        coordinates: A numpy array of shape (n, 2) representing the Euclidean coordinates of each node.
        demands: A numpy array of shape (n,) representing the demand of each node.
        capacity: An integer representing the capacity of each vehicle.

    Returns:
        A numpy array of shape (n, n) representing the prior indicators of how promising it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate savings matrix
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j] #make it symmetric

    # Normalize savings and distance
    normalized_savings = savings_matrix / np.max(savings_matrix) if np.max(savings_matrix) != 0 else savings_matrix
    normalized_distance = 1 / (distance_matrix / np.max(distance_matrix))

    # Demand factor: penalize edges connecting nodes with high demands
    demand_factor = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            demand_factor[i, j] = 1 / (demands[i] + demands[j]) if (demands[i] + demands[j]) > 0 else 1.0

    normalized_demand = demand_factor/np.max(demand_factor) if np.max(demand_factor) != 0 else demand_factor

    # Node proximity to depot
    depot_proximity = np.zeros((n,n))
    for i in range(1,n): #exclude depot
        for j in range(1,n): #exclude depot
            depot_proximity[i,j] = 1/(distance_matrix[0,i] + distance_matrix[0,j]) if (distance_matrix[0,i] + distance_matrix[0,j]) != 0 else 1

    normalized_proximity = depot_proximity/np.max(depot_proximity) if np.max(depot_proximity) !=0 else depot_proximity

    # Combine factors
    heuristic_matrix = 0.5 * normalized_savings + 0.3 * normalized_distance + 0.1 * normalized_demand + 0.1*normalized_proximity

    # Sparsify the matrix: set small values to zero
    threshold = np.quantile(heuristic_matrix, 0.25) # Keep top 75%
    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Ensure no connections from/to the same node
    for i in range(n):
        heuristic_matrix[i, i] = 0

    return heuristic_matrix
```
