```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version combines several factors to determine the promise of an edge, including distance,
    angle between nodes, demand considerations, and sparsification.

    Args:
        distance_matrix (np.ndarray): Distance matrix between nodes (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    distance_weight = 0.5  # Weight for distance factor
    angle_weight = 0.3     # Weight for angle factor
    demand_weight = 0.2    # Weight for demand factor
    sparsification_threshold = 3  # Keep only top N promising edges per node (excluding self-loops)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Distance factor: Inverse of distance (shorter distances are more promising)
                distance_factor = 1 / distance_matrix[i, j]

                # Angle factor: Penalize sharp turns (encourages smoother routes)
                # Calculate angle between i, j, and depot (0)
                if i != 0 and j != 0:
                    v1 = coordinates[i] - coordinates[0]
                    v2 = coordinates[j] - coordinates[i]
                    v1_norm = np.linalg.norm(v1)
                    v2_norm = np.linalg.norm(v2)
                    if v1_norm > 0 and v2_norm > 0:
                        dot_product = np.dot(v1, v2)
                        angle = np.arccos(dot_product / (v1_norm * v2_norm))
                        angle_factor = 1 - (angle / np.pi)  # Normalize to [0, 1] (larger is better, straighter line)
                    else:
                        angle_factor = 0.5  # Assign a neutral value if distance from origin is small
                else:
                    angle_factor = 1.0  # give higher score if the edge is connected with the depot.


                # Demand factor: Encourages connecting nodes with compatible demands
                demand_factor = 1 - abs(demands[i] + demands[j]) / (2 * capacity)

                # Combine factors with weights
                heuristic_matrix[i, j] = (
                    distance_weight * distance_factor +
                    angle_weight * angle_factor +
                    demand_weight * demand_factor
                )

    # Sparsification: Keep only the most promising edges
    for i in range(n):
        row = heuristic_matrix[i, :]
        # Find indices of top N largest values, excluding self-loop
        indices = np.argsort(row)[-(sparsification_threshold+1):]

        # Reset values for nodes not in the indices list to zero
        for j in range(n):
            if i != j and j not in indices:
                heuristic_matrix[i, j] = 0

    return heuristic_matrix
```
