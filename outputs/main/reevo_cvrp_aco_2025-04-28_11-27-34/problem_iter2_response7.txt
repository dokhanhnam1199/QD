```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for CVRP that combines distance, demand, and angle information.
    It sparsifies the matrix by setting unpromising elements to zero after normalization.

    Args:
        distance_matrix: Distance matrix (n x n).
        coordinates: Euclidean coordinates of nodes (n x 2).
        demands: Customer demands (n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as the distance_matrix, indicating the
        promise of each edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (can be tuned)
    distance_weight = 0.5
    demand_weight = 0.3
    angle_weight = 0.2
    sparsification_threshold = 0.1  # remove edges below this threshold

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor (normalized)
            distance_factor = 1 / (distance_matrix[i, j] + 1e-6)  # Avoid division by zero

            # Demand factor: Favor edges connecting nodes with compatible demands
            # Penalize edges that would easily lead to capacity violations
            demand_factor = 1 - min(1, (demands[i] + demands[j]) / (2 * capacity))

            # Angle factor: Favor edges that don't create sharp turns
            # Calculate the angle between the edge (i, j) and the x-axis.
            angle = np.arctan2(coordinates[j, 1] - coordinates[i, 1], coordinates[j, 0] - coordinates[i, 0])

            closest_node_angle_diff = np.inf  # initialize to maximum value
            for k in range(n):
                if k != i and k != j:  # avoid current node, or node j
                    temp_angle = np.arctan2(coordinates[k, 1] - coordinates[i, 1], coordinates[k, 0] - coordinates[i, 0])
                    angle_diff = np.abs(angle - temp_angle)  # take smallest turn

                    if angle_diff < closest_node_angle_diff:
                        closest_node_angle_diff = angle_diff

            angle_factor = 1 - min(1, closest_node_angle_diff / np.pi)  # map from [0, pi] -> [0, 1]. larger = good

            # Overall heuristic value
            heuristic_value = (
                distance_weight * distance_factor
                + demand_weight * demand_factor
                + angle_weight * angle_factor
            )

            heuristic_matrix[i, j] = heuristic_value

    # Sparsification: Remove unpromising edges
    max_val = np.max(heuristic_matrix)

    if max_val > 0:  # avoid divide by 0
        heuristic_matrix = heuristic_matrix / max_val  # Normalize matrix

        heuristic_matrix[heuristic_matrix < sparsification_threshold] = 0

    return heuristic_matrix
```
