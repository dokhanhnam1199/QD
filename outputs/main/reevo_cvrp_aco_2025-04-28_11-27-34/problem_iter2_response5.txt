```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:

    """
    A heuristic function for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.

    This version incorporates several factors to assess the desirability of including each edge in a solution:
    - Distance: Shorter distances are generally preferred.
    - Demand: Edges connecting nodes with high demands might be less desirable if they risk exceeding vehicle capacity early.
    - Closeness to Depot: Edges connecting nodes far from the depot might be penalized, encouraging vehicles to return to the depot more frequently.
    - Savings: Savings from merging two routes.
    - Sparsification:  Sets low-probability edges to zero to focus on promising connections.

    Args:
        distance_matrix (np.ndarray): A matrix of distances between all nodes (n x n).
        coordinates (np.ndarray): A matrix of node coordinates (n x 2).
        demands (np.ndarray): A vector of customer demands (n).
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix of heuristic values, indicating the desirability of each edge (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Parameters (tunable)
    distance_weight = 1.0
    demand_weight = 0.5
    depot_proximity_weight = 0.5
    savings_weight = 0.5
    sparsification_threshold = 0.1  # Adjust this value for more or less sparsification

    # Calculate savings matrix
    savings_matrix = np.zeros((n, n))
    for i in range(1, n):
        for j in range(i + 1, n):
            savings_matrix[i, j] = distance_matrix[0, i] + distance_matrix[0, j] - distance_matrix[i, j]
            savings_matrix[j, i] = savings_matrix[i, j]  # Savings matrix is symmetric

    # Normalize the distance matrix (important for scaling)
    max_distance = np.max(distance_matrix)
    normalized_distance_matrix = distance_matrix / (max_distance + 1e-6) #Avoid div by zero.

    max_savings = np.max(savings_matrix)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance factor: inversely proportional to distance
            distance_factor = distance_weight / (normalized_distance_matrix[i, j] + 1e-6)  # Adding a small constant to avoid division by zero

            # Demand factor: Penalize edges that connect to nodes with higher demands
            demand_factor = 1.0 - demand_weight * (demands[i] + demands[j]) / (2 * capacity + 1e-6)  # Scaled relative to the capcity

            # Depot proximity factor: Encourage returns to depot
            depot_distance_i = distance_matrix[i, 0] #Distance from node i to depot
            depot_distance_j = distance_matrix[j, 0] #Distance from node j to depot

            depot_proximity_factor = 1.0 - depot_proximity_weight * (depot_distance_i + depot_distance_j) / (2 * max_distance + 1e-6)

            #Savings factor
            savings_factor = 0.0
            if max_savings > 0:
                savings_factor = savings_weight * savings_matrix[i,j]/max_savings

            # Combine the factors
            heuristic_matrix[i, j] = distance_factor * max(0, demand_factor) * max(0, depot_proximity_factor) + savings_factor

    # Sparsification: Zero out low-probability edges
    max_heuristic = np.max(heuristic_matrix)
    if max_heuristic > 0:
        threshold = sparsification_threshold * max_heuristic
        heuristic_matrix[heuristic_matrix < threshold] = 0.0

    return heuristic_matrix
```
