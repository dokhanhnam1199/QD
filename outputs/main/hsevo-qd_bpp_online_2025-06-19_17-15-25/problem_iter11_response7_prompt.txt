{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that are already relatively full, to reduce fragmentation.\n    It also includes a small random component to encourage exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        small_random_component_weight: Weight of the small random component. Default is 0.01.\n        not_fit_priority: Priority given to bins where the item doesn't fit. Default is -1e9.\n        division_eps: Epsilon value to avoid division by zero. Default is 1e-9.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item.\n    remaining_capacity = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits and leaves minimal waste.\n    fit_indices = remaining_capacity >= 0\n    if np.any(fit_indices):\n        # Prioritize bins that are already relatively full.  We want to minimize fragmentation.\n        # The smaller the remaining capacity after adding the item, the higher the priority.\n        priorities[fit_indices] = (bins_remain_cap[fit_indices] - remaining_capacity[fit_indices]) / bins_remain_cap[fit_indices] + 1 / (remaining_capacity[fit_indices] + division_eps) # (bins_remain_cap[fit_indices] - remaining_capacity[fit_indices]) / bins_remain_cap[fit_indices]   # Avoid division by zero\n        \n        # Add a small random component to encourage exploration and escape local optima\n        priorities[fit_indices] += np.random.rand(np.sum(fit_indices)) * small_random_component_weight\n    \n    # Give a very low priority (or negative) to bins where the item doesn't fit.\n    priorities[remaining_capacity < 0] = not_fit_priority  # Large negative value\n    \n    # Normalize the priorities\n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    elif np.sum(priorities) < 0:\n        priorities = priorities - np.min(priorities)\n        priorities = priorities / np.sum(priorities)\n    \n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item.\n    remaining_capacity = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits and leaves minimal waste.\n    fit_indices = remaining_capacity >= 0\n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (remaining_capacity[fit_indices] + 1e-9)  # Avoid division by zero\n    \n    # Give a very low priority (or negative) to bins where the item doesn't fit.\n    priorities[remaining_capacity < 0] = -1e9  # Large negative value\n        \n    # Normalize the priorities\n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    elif np.sum(priorities) < 0:\n      priorities = priorities - np.min(priorities)\n      priorities = priorities / np.sum(priorities)\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic prioritizes fullness, fit, adaptive scaling, and randomness, normalizing the priorities, while the worst simply calculates the negative log of the ratio of item size to remaining bin capacity without considering fit or fullness. Comparing (2nd best) vs (second worst) (2nd) vs (19th) are identical to (1st) vs (20th). Comparing (1st) vs (2nd), they are identical, indicating redundancy. (3rd) vs (4th) are also identical to (1st) vs (2nd). Comparing (second worst) vs (worst), the heuristics are identical, meaning they produce the same result. The better heuristics include more factors like fullness, scaling, and randomness, while the worse heuristics focus solely on a ratio and lack normalization or handling of infeasible bins. The best heuristics also explicitly handle cases where the item doesn't fit. Heuristics 9 and 13 are attempts at incorporating multiple factors with weighting and dynamic adjustment, but they fall lower in the ranking, possibly due to overcomplexity or less effective weighting strategies.\n\nOverall: The better performing heuristics balance multiple factors, including fit, fullness, scaling, and randomness, while effectively penalizing infeasible solutions and normalizing priorities. Simpler heuristics that only consider a single factor, like capacity ratio, perform poorly. Attempts at more complex, multi-factor heuristics need careful weighting and dynamic adjustment to outperform simpler, well-balanced approaches. Code duplication exists in the list.\n- \nOkay, I understand! Let's redefine \"Current Self-Reflection\" to be *more* effective for designing better heuristics, keeping your preferences in mind and avoiding the pitfalls of ineffective self-reflection.\n\nHere's a refined approach to self-reflection for heuristic design:\n\n*   **Keywords:** Multi-faceted evaluation, adaptive scaling, constraint satisfaction, rigorous validation, exploration/exploitation balance.\n\n*   **Advice:** Critically examine the heuristic's performance considering trade-offs between competing objectives (e.g., fit vs. fullness). Investigate adaptive scaling of parameters based on real-time feedback from the search process. Design clear metrics to measure performance.\n\n*   **Avoid:** Superficial constraint consideration, normalization without justification, solely relying on penalties for infeasibility, ignoring validation.\n\n*   **Explanation:** Move beyond simply *considering* factors to actively *evaluating* their interplay. Adaptive scaling should be data-driven and validated, not arbitrary. Emphasize rigorous validation to prevent overfitting.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}