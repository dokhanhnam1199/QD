{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item.\n    remaining_capacity = bins_remain_cap - item\n    \n    # Give high priority to bins where the item fits and leaves minimal waste.\n    fit_indices = remaining_capacity >= 0\n    if np.any(fit_indices):\n        priorities[fit_indices] = 1 / (remaining_capacity[fit_indices] + 1e-9)  # Avoid division by zero\n    \n    # Give a very low priority (or negative) to bins where the item doesn't fit.\n    priorities[remaining_capacity < 0] = -1e9  # Large negative value\n        \n    # Normalize the priorities\n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    elif np.sum(priorities) < 0:\n      priorities = priorities - np.min(priorities)\n      priorities = priorities / np.sum(priorities)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first 10 functions are identical and perform normalization to the priorities while the last 10 only calculates a log ratio of item size to remaining bin capacity. This normalization is key. The first 10 functions also prioritize bins where the item fits and leaves minimal waste, and penalize bins where the item doesn't fit with a large negative priority. The last functions prioritize bins based on the log ratio of item size to remaining capacity. Thus, the last functions fail to consider the case where an item does not fit.\nComparing (1st) vs (11th), we see the first function performs normalization. Normalization may allow the algorithm to better compare bins on a relative basis.\n\nOverall: The best heuristics consider whether an item fits into a bin and explicitly penalize bins where it doesn't fit. Also, normalization is a crucial part of a good heuristic because it allows comparison of bins on a relative basis.\n- \nOkay, let's refine \"Current self-reflection\" to make it more effective for heuristic design, focusing on actionable insights and avoiding pitfalls.\n\nHere's a redefined approach:\n\n*   **Keywords:** Solution space analysis, Constraint handling, Adaptive penalties, Iterative refinement.\n*   **Advice:** Systematically explore the solution space's structure. Adapt penalty magnitudes based on search progress. Decompose the problem and address sub-problems using tailored heuristics.\n*   **Avoid:** Premature convergence, rigid penalty schemes, neglecting problem-specific structure, relying solely on intuition without experimentation.\n*   **Explanation:** Heuristics should evolve from understanding the problem's landscape. Don't get stuck; vary your approach and adapt penalties during the search process to guide towards feasibility and optimality.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}