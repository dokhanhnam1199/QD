{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins by fit, fullness, adaptive scaling, and exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    fit_indices = remaining_capacity >= 0\n\n    if np.any(fit_indices):\n        # Fullness factor\n        fullness = (bins_remain_cap[fit_indices].max() - bins_remain_cap[fit_indices]) / (bins_remain_cap[fit_indices].max() + 1e-9) # Avoid divide by zero\n\n        # Remaining capacity factor\n        remaining_cap_priority = 1.0 / (remaining_capacity[fit_indices] + 0.01) # small remaining get high priority\n\n        # Combine fullness and remaining capacity.\n        combined_priority = fullness + remaining_cap_priority\n\n        # Adaptive scaling based on item size and remaining capacity\n        scale = np.mean(bins_remain_cap[fit_indices]) + item\n        priorities[fit_indices] = combined_priority / scale\n\n        # Exploration strategy: item-size aware randomness\n        exploration_strength = min(0.1, item)\n        exploration_bonus = np.random.rand(np.sum(fit_indices)) * exploration_strength\n        priorities[fit_indices] += exploration_bonus\n    else:\n        priorities = np.full_like(priorities, -1e9)\n        return priorities\n    \n\n    # Penalize bins where the item doesn't fit\n    priorities[remaining_capacity < 0] = -1e9\n\n    # Normalize priorities, handling edge cases\n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    elif np.sum(priorities) < 0:\n        min_priority = np.min(priorities)\n        priorities = priorities - min_priority\n        priorities = priorities / np.sum(priorities) if np.sum(priorities) > 0 else np.zeros_like(priorities)\n\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, here's a redefined \"Current Self-Reflection\" distilled into actionable advice for heuristic design, along with what to avoid, and a rationale:\n\n*   **Keywords:** Multi-factor, Adaptive Scaling, Exploration, Normalization, Edge Cases, Validation.\n*   **Advice:** Integrate multiple relevant factors using adaptive scaling to dynamically adjust priorities, incorporate controlled randomness for exploration, and rigorously handle edge cases. Validate through testing.\n*   **Avoid:** Oversimplification (raw ratios), over-complication (too many unvalidated dynamic weights), fixed constants, ignoring constraints/edge cases.\n*   **Explanation:** Combine diverse criteria for a comprehensive evaluation. Adaptive scaling adjusts to problem characteristics. Exploration prevents getting stuck in local optima. Normalization ensures consistent probability-based selection. Robust edge case handling guarantees reliability. Thorough validation is critical for effectiveness.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}