{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                bins_remain_cap: np.ndarray,\n                randomness_strength: float = 0.09055507501984036,\n                no_fit_priority: float = -1668213914.7516727,\n                epsilon: float = 4.1062069920696874e-09) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness, fit, adaptive scaling, and randomness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    fit_indices = remaining_capacity >= 0\n\n    if np.any(fit_indices):\n        # Adaptive scaling based on average remaining capacity of bins where the item fits.\n        scale = np.mean(bins_remain_cap[fit_indices])\n        priorities[fit_indices] = (bins_remain_cap[fit_indices] / scale) / (remaining_capacity[fit_indices] + epsilon)\n\n        # Introduce randomness for exploration.\n        priorities[fit_indices] += np.random.rand(np.sum(fit_indices)) * randomness_strength\n\n    # Very low priority to bins where item doesn't fit.\n    priorities[remaining_capacity < 0] = no_fit_priority\n\n    # Normalize priorities to ensure they sum to 1 (or handle negative priorities).\n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    elif np.sum(priorities) < 0:\n        priorities = priorities - np.min(priorities)\n        priorities = priorities / np.sum(priorities)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins based on remaining capacity, fit, item size, and bin occupancy, with adaptive scaling and exploration.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    fit_indices = remaining_capacity >= 0\n\n    if np.any(fit_indices):\n        # 1. Prioritize bins with tighter fit, encouraging better space utilization\n        fit_priority = 1 / (remaining_capacity[fit_indices] + 1e-9)\n\n        # 2. Prioritize bins with higher occupancy (more items already packed), aiming to consolidate packings\n        occupancy_priority = (bins_remain_cap[fit_indices].max() - bins_remain_cap[fit_indices]) / (bins_remain_cap[fit_indices].max()+ 1e-9)\n\n        # 3. Adaptive scaling based on the item size relative to average remaining capacity.  Larger items favor almost full bins\n        scale = np.mean(bins_remain_cap[fit_indices])\n        item_size_priority = (item / (scale + 1e-9)) \n\n        #4. Combine priorities with weights. Dynamically adjust weights based on performance characteristics (omitted for simplicity but crucial in a real-world scenario).\n        alpha, beta, gamma = 0.6, 0.3, 0.1 # Weights can be dynamically tuned. Experiment with different values to improve performance.\n        priorities[fit_indices] = alpha * fit_priority + beta * occupancy_priority + gamma * item_size_priority\n        \n        # 5. Constrained Random Exploration: Add small noise only to promising bins\n        exploration_noise = np.random.rand(np.sum(fit_indices)) * 0.01\n        priorities[fit_indices] += exploration_noise\n\n    # Very low priority to bins where item doesn't fit\n    priorities[remaining_capacity < 0] = -1e9\n    \n    # Normalize priorities to a probability distribution\n    if np.sum(priorities) > 0:\n        priorities = priorities / np.sum(priorities)\n    elif np.sum(priorities) < 0:\n          priorities = priorities - np.min(priorities)\n          priorities = priorities / np.sum(priorities)\n\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic incorporates fullness, remaining capacity, adaptive scaling based on item size, and a refined exploration strategy using randomness, along with normalization. The worst heuristic only calculates a ratio of item size to remaining capacity and takes the negative logarithm. (2nd best) vs (second worst), the second worst only use log ratios. Comparing (1st) vs (2nd), we see the code is identical, implying their performance is extremely close, maybe identical. (3rd) vs (4th), these are also identical, suggesting the ranking might be based on subtle differences not apparent in the code itself or is incorrect. Comparing (second worst) vs (worst), both use log ratios, but the worst lacks any handling of edge cases or normalization. Comparing (1st) vs (11th), the 1st one uses fullness factor, Remaining capacity factor, combined priority, Adaptive scaling based on item size and Refined exploration strategy. The 11th one just calculates the remaining capacity and applies a simple priority based on it. Overall: The better heuristics prioritize a combination of factors like fullness, remaining capacity, and adaptive scaling, use a bit of randomness for exploration and normalization of priorities, while penalizing invalid placements. The weaker heuristics rely on simpler metrics or fail to normalize, potentially leading to suboptimal solutions.\n- \nOkay, let's refine \"Current Self-Reflection\" to be more effective in guiding heuristic design.\n\n*   **Keywords:** Multi-factor, adaptive, robust, experimental.\n*   **Advice:** Focus on creating heuristics that are adaptable to specific problem instance characteristics. Experiment to find the best parameters.\n*   **Avoid:** Oversimplification and over-complication. Avoid prematurely fixing parameters.\n*   **Explanation:** Prioritize a balanced approach to heuristic design that considers fit, fullness, randomness, normalization, and penalty. Make your heuristics more dynamic.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}