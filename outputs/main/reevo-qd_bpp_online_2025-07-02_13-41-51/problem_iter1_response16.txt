```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Heuristic 1: First Fit Decreasing (FFD) inspired
    # Prioritize bins that can accommodate the item with the least waste.
    
    waste = bins_remain_cap - item
    
    # Give a high priority to bins where waste is minimal and positive
    priorities = -np.abs(waste)
    priorities[waste < 0] = -np.inf # Disqualify bins that are too small.

    # Heuristic 2: Try to balance the load
    # Add a bonus to bins that are relatively empty compared to others
    
    mean_cap = np.mean(bins_remain_cap) if len(bins_remain_cap) > 0 else 0 #Avoid division by zero.

    #Bins closer to the mean have slightly higher priority, trying to balance the load.
    distance_from_mean = -np.abs(bins_remain_cap - mean_cap)
    priorities += 0.1 * distance_from_mean

    # Heuristic 3: Avoid fragmentation
    # Penalize bins where adding the item would leave a small remaining capacity
    
    small_waste_threshold = 0.1  # Define what constitutes a "small" waste (e.g., 10% of bin size)
    
    # Apply a penalty if remaining capacity is close to the small_waste_threshold
    priorities[np.logical_and(waste > 0, waste <= small_waste_threshold)] -= 0.5
        
    return priorities
```
