```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Eliminate bins that can't fit the item.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf  # Very low priority

    # Only calculate priority for bins that *can* hold the item
    feasible_bins_indices = np.where(~infeasible_bins)[0]

    if feasible_bins_indices.size > 0:

        # 2. Remaining capacity after insertion: Smaller is better, use reciprocal
        remaining_cap_after_insertion = bins_remain_cap[feasible_bins_indices] - item
        priorities[feasible_bins_indices] = 1.0 / (remaining_cap_after_insertion + 1e-9)
        
        # 3. Best Fit sweet spot bonus. Target fills of 60-90% after placement
        fill_target_lower = 0.6
        fill_target_upper = 0.9
        
        post_fill_level = (bins_remain_cap[feasible_bins_indices] - item) / bins_remain_cap.max()

        sweet_spot_bonus = np.where(
            (post_fill_level >= fill_target_lower) & (post_fill_level <= fill_target_upper),
            2.0, # Substantially increase priority for ideal fills
            0.0
        )

        priorities[feasible_bins_indices] += sweet_spot_bonus

        # 4. First-Fit tiebreaker: Give a *very* small bonus to earlier bins.
        # Makes it more deterministic and less prone to wild swings
        index_bonus = (bins_remain_cap.size - feasible_bins_indices) / bins_remain_cap.size * 0.01
        priorities[feasible_bins_indices] += index_bonus

        # 5. High fragmentation penalty: Heavily penalize bins that will be left with *very* small amounts of space.  Reduces external fragmentation
        frag_threshold = 0.1 # If remaining capacity after insertion is less than 10% of bin size
        fragmented_bins = (bins_remain_cap[feasible_bins_indices] - item) / bins_remain_cap.max() < frag_threshold
        priorities[feasible_bins_indices[fragmented_bins]] -= 1.0
            
    return priorities
```
