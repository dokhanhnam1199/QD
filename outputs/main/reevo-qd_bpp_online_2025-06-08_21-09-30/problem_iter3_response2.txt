```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility: Eliminate bins that can't fit the item.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf  # Very low priority

    # Only calculate priority for bins that *can* hold the item
    feasible_bins_indices = np.where(~infeasible_bins)[0]

    if feasible_bins_indices.size > 0:
        # 2. Best Fit: Prioritize bins with the smallest remaining capacity after insertion.
        remaining_cap_after_insertion = bins_remain_cap[feasible_bins_indices] - item
        priorities[feasible_bins_indices] = -remaining_cap_after_insertion # Smaller remaining cap is better

        # 3. Sweet Spot Bonus: Reward fills that leave a "sweet spot" of remaining capacity.
        fill_ratio_after = remaining_cap_after_insertion / bins_remain_cap.max()
        sweet_spot_lower = 0.2
        sweet_spot_upper = 0.6 # Adjust upper bound slightly
        sweet_spot_bonus = np.where(
            (fill_ratio_after >= sweet_spot_lower) & (fill_ratio_after <= sweet_spot_upper),
            1.0,  # Bonus for being in the sweet spot
            0.0
        )
        priorities[feasible_bins_indices] += sweet_spot_bonus

        # 4. Fragmentation Penalty: Penalize bins that were already close to full before insertion to discourage creating very small leftover spaces. Make it dependent on item size.
        almost_full_threshold = 0.85
        already_full = bins_remain_cap[feasible_bins_indices] / bins_remain_cap.max() > almost_full_threshold
        penalty_amount = item  # Penalty scales with item size.  Larger items cause more penalty if put in an almost full bin
        priorities[feasible_bins_indices[already_full]] -= penalty_amount


        # 5. First-Fit Tiebreaker:  Add a tiny bonus based on bin index to favor earlier bins, but ONLY if the current priorities are closely matched (small tolerance). This helps avoid large disruptions caused by the index bonus.
        max_priority = np.max(priorities[feasible_bins_indices])
        priority_range = max_priority - np.min(priorities[feasible_bins_indices])
        
        if priority_range < 0.1: # Reduce the bonus for very small diffs.
            index_bonus = (bins_remain_cap.size - feasible_bins_indices) / bins_remain_cap.size * 0.05  # Even smaller bonus
            priorities[feasible_bins_indices] += index_bonus


    return priorities
```
