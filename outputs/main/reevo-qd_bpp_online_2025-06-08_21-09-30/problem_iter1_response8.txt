```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Immediate Fit: High priority for bins that can fit the item exactly.
    immediate_fit = (bins_remain_cap == item)
    priorities[immediate_fit] = 1000

    # Near Fit: High priority if remaining capacity is slightly greater than the item size
    near_fit = (bins_remain_cap > item) & (bins_remain_cap <= 1.1 * item)
    priorities[near_fit] = 500 + (bins_remain_cap[near_fit] - item)  #Smaller difference gives higher priority.

    # Sufficient Space: Give some priority to bins that have enough space. Prioritize lower remaining capacity.
    sufficient_space = (bins_remain_cap > item) & ~near_fit
    priorities[sufficient_space] = 100 + (1 - bins_remain_cap[sufficient_space]/np.max(bins_remain_cap)) * 50  # scale to maximum remaining capacity. The fuller the higher the priority.

    # Avoid large waste: Penalize bins with very large remaining capacity compared to item size
    large_waste = bins_remain_cap > 3 * item
    priorities[large_waste] = -100

    # Impossible to fit.
    impossible = bins_remain_cap < item
    priorities[impossible] = -1000
    
    return priorities
```
