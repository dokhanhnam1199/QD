```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with remaining capacity slightly larger than the item size
    to reduce fragmentation. If the item doesn't fit, the priority is set to a very low value.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity < item:
            priorities[i] = -np.inf  # Very low priority if it doesn't fit
        else:
            # Priority is higher when the remaining capacity is slightly larger than the item.
            # The smaller the waste (capacity - item), the higher the priority, but not too small
            waste = capacity - item
            if waste == 0:
                priorities[i] = 100 # perfect fit should be high priority
            elif waste < 0.1 :
              priorities[i] = 50 # very small waste a good choice
            elif waste < 0.3:
              priorities[i] = 25 # relatively small waste
            else:
                priorities[i] = 1 / waste #inverse proportion to the waste amount

    return priorities
```
