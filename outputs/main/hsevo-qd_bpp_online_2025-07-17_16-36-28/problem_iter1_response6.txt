```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item snugly (small wasted space),
    but also avoids bins that are almost full to reduce fragmentation.
    It incorporates a sigmoid function to balance these two aspects.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate wasted space for each bin
    wasted_space = bins_remain_cap - item

    # Bins that can't fit the item get a very low priority
    priorities = np.where(wasted_space < 0, -np.inf, 0.0)

    # For bins that *can* fit the item:

    # 1. Calculate "snugness":  Inversely proportional to wasted space.  Smaller waste is better.
    # Avoid division by zero by adding a small epsilon.
    snugness = 1 / (wasted_space + 1e-9)
    snugness = np.nan_to_num(snugness, nan=0.0, posinf=0.0, neginf=0.0)  # Handle potential infinities.

    # 2. Calculate "fragmentation risk": high when the remaining capacity is close to the item size.
    #  This is where the sigmoid comes in.
    #  Sigmoid will be close to 1 when item size approaches bin capacity, and close to 0 if its almost empty.
    # Higher sigmoid means bins which has smaller space compared to item
    sigmoid_input = 5 * (bins_remain_cap - item) / bins_remain_cap  # Scale the difference
    fragmentation_risk = 1 / (1 + np.exp(-sigmoid_input))  # Sigmoid function


    # 3. Combine snugness and fragmentation risk
    priorities = np.where(wasted_space >= 0, snugness * (1-fragmentation_risk), priorities)

    return priorities
```
