```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    A Tesla-inspired heuristic leveraging remaining capacity and wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the wasted space if the item is placed in each bin.
    wasted_space = bins_remain_cap - item

    # Prioritize bins that can accommodate the item. Bins that can't will receive -inf priority
    priorities[bins_remain_cap < item] = -np.inf
    
    #if item is smaller than the remain cap of all bins:
    if np.all(bins_remain_cap >= item):
        #if there is one exact match bin (remain_cap == item) return 1 for this bin
        if np.any(bins_remain_cap == item):
          idx = np.where(bins_remain_cap == item)[0]
          priorities[idx] = 1
          return priorities
        #If no exact match, favor bins with slightly larger remain_cap.

        diff = bins_remain_cap - item
        min_diff = np.min(diff)
        idx = np.where(diff == min_diff)[0]
        priorities[idx] = 0.9
        return priorities

    #prioritze using remaining capacity in an intelligent fashion
    valid_bins = bins_remain_cap >= item
    if np.any(valid_bins):
      # Utilize the Golden Ratio to reward nearly-full bins after insertion.
      golden_ratio = (1 + np.sqrt(5)) / 2
      fill_ratios = item / bins_remain_cap[valid_bins]
      
      # Apply a non-linear transformation to emphasize near-perfect fits. This emulates resonance.
      priorities[valid_bins] = np.exp(fill_ratios*golden_ratio)
      # Penalize wasted space, as an imperfection. A little imperfection can be tolerated.
      priorities[valid_bins] -= (wasted_space[valid_bins] / np.max(bins_remain_cap)) * 0.5  #A bit imperfection will be penalized less than a very big imperfection
      priorities[valid_bins] = np.nan_to_num(priorities[valid_bins], nan=-np.inf) #remove NaN values
    
    return priorities
```
