```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A more sophisticated priority function for online bin packing, incorporating
    adaptive strategies and nuanced weighting to improve performance.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap - item >= 0

    if not np.any(valid_bins):
        return priorities

    # Base priority for valid bins
    priorities[valid_bins] = 1.0

    # Minimize wasted space (adaptive weighting)
    wasted_space = bins_remain_cap[valid_bins] - item
    fill_ratios = (bins_remain_cap[valid_bins] - wasted_space) / bins_remain_cap[valid_bins]

    # Boost priority for bins that will be filled well
    priorities[valid_bins] += fill_ratios * 2.0

    #Prioritize bins that are close to being full, but not too close
    almost_full = (wasted_space < 0.1 * np.mean(bins_remain_cap))
    priorities[valid_bins][almost_full] -= 0.5 # slight de-prioritization of almost full bins


    # Target a 'sweet spot' fill level (adaptive based on item size)
    target_fill = 0.75 #Aim for 75% fill
    sweet_spot_diff = np.abs(fill_ratios - target_fill)
    priorities[valid_bins] += 1.0 / (1e-6 + sweet_spot_diff)

    # Encourage spreading items across bins (with a slight bias towards fuller bins)
    bin_utilization = 1 - (bins_remain_cap / np.sum(bins_remain_cap))
    priorities[valid_bins] += bin_utilization[valid_bins]


    # Introduce controlled randomness (simulated annealing-inspired)
    temperature = 0.1  # Adjust for exploration vs. exploitation
    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * temperature

    return priorities
```
