```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """A heuristic for online bin packing that combines multiple strategies.

    This heuristic prioritizes bins based on a combination of factors:
    1.  Whether the item fits in the bin.
    2.  How much wasted space is created if the item is placed in the bin.
    3.  A measure of how close the resulting bin capacity is to a target level.
    4.  Remaining Capcity of bins (scaled)
    5.  Exploration using a random factor, weighted by item size.
    6.  Penalizes using nearly full bins.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap - item >= 0

    if not np.any(valid_bins):
        return priorities

    # Base priority for bins that fit the item
    priorities[valid_bins] = 1.0

    # Minimize wasted space
    wasted_space = bins_remain_cap[valid_bins] - item
    priorities[valid_bins] += 1.0 / (1e-6 + wasted_space)

    # Target a capacity level.  Let's target 2/3 full
    target_capacity = np.mean(bins_remain_cap) * (2/3)
    capacity_diff = np.abs(bins_remain_cap[valid_bins] - item - target_capacity)
    priorities[valid_bins] += 1.0 / (1e-6 + capacity_diff)

    # Spread items across bins (use squared remaining capacity)
    scaled_bins = bins_remain_cap[valid_bins]**2
    priorities[valid_bins] += scaled_bins / (np.sum(scaled_bins) + 1e-6)

    # Encourage exploration using a random factor, weighted by item size
    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01 * item

    # Penalize using nearly full bins.  This helps in avoiding a situation
    # where a lot of bins are almost full, making it hard to pack later items.
    nearly_full = bins_remain_cap < item + 0.1  # Adjust threshold as needed
    priorities[nearly_full] -= 0.5 # Reduce priority, but don't make it negative unless other factors are low

    return priorities
```
