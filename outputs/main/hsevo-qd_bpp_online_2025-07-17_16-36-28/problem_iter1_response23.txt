```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space.
    It heavily penalizes bins that cannot fit the item, and rewards bins where the remaining space
    after packing the item is close to zero (but not zero).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Penalize bins that cannot fit the item
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -np.inf  # Strongly discourage infeasible solutions

    # Reward bins that can fit the item, prioritizing those with minimal wasted space
    feasible_bins = bins_remain_cap >= item
    remaining_space = bins_remain_cap[feasible_bins] - item
    
    # Calculate a score based on the inverse of the remaining space
    # We add a small constant to avoid division by zero when the item fits perfectly.
    # Square the inverse to further emphasize the effect of smaller remaining space.
    
    priorities[feasible_bins] = (1 / (remaining_space + 0.0001))**2
    
    # Optionally add a bonus for filling the bin more completely
    # This helps discriminate between bins that both have small remaining space, 
    # favouring bins that have been used before rather than an empty one
    bin_used = bins_remain_cap < 1  #Assuming that bin has capacity 1
    priorities[bin_used] = priorities[bin_used] + 0.1 


    return priorities
```
