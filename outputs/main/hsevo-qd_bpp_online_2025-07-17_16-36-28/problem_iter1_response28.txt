```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item relatively snugly,
    but also avoids bins that are too close in capacity (risk of future issues).
    It combines factors like remaining capacity, space utilization, and
    a penalty for bins almost fully filled.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First, only consider bins where the item fits
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities  # No suitable bin. All priorities are 0.

    # Calculate utilization ratio (item size / bin capacity)
    utilization_ratios = np.where(valid_bins, item / bins_remain_cap, 0)

    # Give higher priority to bins with higher utilization (but less than 1)
    priorities[valid_bins] = utilization_ratios[valid_bins]

    # Penalize bins that would be almost full after placing the item
    almost_full_threshold = 0.95  # Adjust as needed. If closer to 1 it aggressively penalizes nearly full.
    remaining_after_placement = bins_remain_cap - item
    almost_full_penalty = np.where(remaining_after_placement > 0, np.where((bins_remain_cap - item) / bins_remain_cap < (1 - almost_full_threshold), -10, 0), 0)  #Large penalty for almost full. Added a >0 to make the code runnable

    priorities += almost_full_penalty

    # Boost bins that are relatively large and can fit item more than minimal, for balance
    large_bin_boost = np.where(valid_bins, np.log(bins_remain_cap / item), 0) #favor bins with higher capacity left compared to size of the item
    priorities += large_bin_boost
    return priorities
```
