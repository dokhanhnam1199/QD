```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A refined priority function for online bin packing that combines several strategies:
    1. Feasibility: Only consider bins that can fit the item.
    2. Wasted Space: Prioritize bins that minimize wasted space.
    3. Fill Level Target: Encourages bins to reach a target fill level (e.g., 75%).
    4. Fragmentation Avoidance: Discourages placing items in bins that would lead to small remaining spaces.
    5. Bin Utilization Balance: Attempts to distribute items across bins to achieve more uniform utilization.
    6. Adaptive Weights: Adjusts the importance of different factors based on bin states.
    7. Controlled Randomness: Introduces a small amount of randomness to break ties and encourage exploration.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap - item >= 0

    if not np.any(valid_bins):
        return priorities

    valid_indices = np.where(valid_bins)[0]
    remaining_capacities = bins_remain_cap[valid_bins]

    # 1. Feasibility (already handled by valid_bins)
    priorities[valid_bins] += 1.0

    # 2. Minimize Wasted Space
    wasted_space = remaining_capacities - item
    priorities[valid_bins] += 1.0 / (1e-6 + wasted_space)

    # 3. Fill Level Target (e.g., 75% full)
    target_fill = 0.75
    bin_size = bins_remain_cap.max() + item #Approximation of bin size
    target_capacity = bin_size * target_fill
    fill_diff = np.abs((bin_size - remaining_capacities) - target_capacity)
    priorities[valid_bins] += 1.0 / (1e-6 + fill_diff)

    # 4. Fragmentation Avoidance
    fragmentation_threshold = bin_size * 0.1  # Avoid creating spaces smaller than 10% of bin size
    fragmentation_penalty = np.where(wasted_space < fragmentation_threshold, -0.5, 0)  # Negative priority for fragmentation
    priorities[valid_bins] += fragmentation_penalty
    
    # 5. Bin Utilization Balance
    utilization_std = np.std(bins_remain_cap)
    priorities[valid_bins] += 1.0 / (1e-6 + utilization_std) #More uniform utilization is favored

    # 6. Adaptive Weights (example: prioritize minimizing wasted space for nearly full bins)
    nearly_full = remaining_capacities < bin_size * 0.2 #Bins that are more than 80% full
    if np.any(nearly_full):
          priorities[valid_bins][nearly_full] += 2.0 / (1e-6 + wasted_space[nearly_full])  #Increased imporance of space
    
    # 7. Controlled Randomness
    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01

    return priorities
```
