```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function introduces a few heuristics inspired by physical principles,
    particularly energy minimization and potential barriers.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # 1. Energy Landscape:  A bin close to full represents a lower "energy state".
    #   We want to minimize "energy" (waste).  So, higher remaining capacity means higher "energy".
    energy = bins_remain_cap

    # 2. Quantum Tunneling (modified): Bins slightly too small might still be good if we consider "tunneling".
    #    In reality, we're approximating how items might fit together, even if individually they seem too big.
    tunneling_potential = np.where(bins_remain_cap >= item, 1.0, np.exp(-100 * (item - bins_remain_cap)**2)) #High penalty if much smaller than the item size.

    # 3. Heaviside Step Function with some Smoothing (inspired by Fermi-Dirac statistics):
    #    Bins that *can* fit the item get a significant boost, encouraging use of those bins first.
    fit_probability = 0.5 * (1 + np.tanh(100 * (bins_remain_cap - item)))

    # 4.  Inverted "energy" with tunneling and fitting factors modulating the priority
    priorities = (1/ (energy + 1e-9)) * tunneling_potential * fit_probability # Added small constant for numerical stability

    return priorities
```
