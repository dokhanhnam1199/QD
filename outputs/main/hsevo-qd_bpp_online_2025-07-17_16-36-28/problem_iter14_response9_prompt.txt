{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Assign priority to bins based on fit, wasted space, and occupancy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap >= item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 1\n\n    remaining_cap = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] += 1.0 / (1e-6 + remaining_cap)\n    \n    mean_cap = np.mean(bins_remain_cap)\n    priorities[valid_bins] += 1.0 / (1e-6 + np.abs(remaining_cap - mean_cap / 2))\n\n    scaled_cap = bins_remain_cap[valid_bins]**2\n    priorities[valid_bins] += scaled_cap / np.sum(scaled_cap + 1e-6)\n    \n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    An enhanced priority function for the online bin packing problem.\n\n    This version incorporates adaptive elements and problem-specific knowledge\n    to achieve improved packing efficiency. It considers aspects like\n    remaining capacity distribution, item size relative to bin sizes, and\n    introduces a dynamic exploration factor.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap - item >= 0\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Base priority for valid bins\n    priorities[valid_bins] = 1.0\n\n    # Minimize wasted space - scaled by item size\n    wasted_space = bins_remain_cap[valid_bins] - item\n    priorities[valid_bins] += item / (1e-6 + wasted_space)\n\n    # Encourage filling bins closer to a target level (e.g., 75% full)\n    target_fill = 0.75  # Adjust as needed\n    bin_size = bins_remain_cap.max() + item # Assuming all bins have same initial capacity\n    target_capacity = target_fill * bin_size\n\n    fill_level_diff = np.abs(bins_remain_cap[valid_bins] - (bin_size - item) - target_capacity)\n    priorities[valid_bins] += 1.0 / (1e-6 + fill_level_diff)\n\n    # Balance bin usage - penalize bins with significantly larger remaining capacity\n    capacity_ratio = bins_remain_cap[valid_bins] / (bin_size + 1e-6)\n    priorities[valid_bins] += (1 - capacity_ratio)**2  # Higher priority for fuller bins\n\n    # Adaptive exploration factor: Adjusts randomness based on problem state\n    # More randomness when bins are relatively empty or very full\n    avg_capacity = np.mean(bins_remain_cap)\n    exploration_factor = np.clip(1 - np.abs(bins_remain_cap[valid_bins] - avg_capacity) / (bin_size + 1e-6), 0.01, 0.1) # Scale exploration with difference from mean capacity\n\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * exploration_factor\n\n    # Favor bins that are close to the item size\n    size_difference = np.abs(bins_remain_cap[valid_bins] - item)\n    priorities[valid_bins] += 1.0 / (1e-6 + size_difference)\n    \n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the best heuristic incorporates fit, waste, fill level, and spread, while the worst only considers the ratio of item size to remaining capacity. The best also utilizes adaptive exploration with randomness, while the worst relies solely on logarithmic ratios.\n\nComparing (2nd) vs (19th), the same code is repeated, indicating that these heuristics are of equal (presumably poor) quality. They are also identical to (1st), showing an error in the ranking.\n\nComparing (1st) vs (4th), both consider fit, waste, half-full target, and spread. However, (1st) has adaptive exploration that increases randomness for nearly full bins, using `np.where`, while (4th) uses a fixed small random component.\n\nComparing (4th) vs (11th), (4th) targets a half-full state and scales bin remaining capacity, whereas (11th) only considers fit, waste, and a basic spread mechanism.\n\nComparing (9th) vs (10th), (9th) uses a fit ratio and energy landscape concept, potentially leading to instability with `-np.inf`. (10th) employs adaptive weighting for wasted space, dynamic adjustment for target fill, a bin fragmentation penalty, and controlled exploration (simulated annealing).\n\nComparing (17th) vs (18th), both introduce a large number of tunable parameters, but (18th) also includes weights for each component and a scaling exponent for the half-full target. However, neither includes any actual computations, so their relative ranking is moot.\n\nOverall: The better heuristics incorporate more factors (fit, waste, fill level, spread), use adaptive exploration strategies, and dynamically adjust weights. The worse heuristics tend to oversimplify the problem, lack adaptability, or introduce instability. Sophistication alone doesn't guarantee success. Simply adding tunable parameters without implementing the core logic doesn't improve performance.\n- \nHere's a redefined approach to \"Current Self-Reflection\" for designing better heuristics:\n\n*   **Keywords:** Problem context, dynamic weighting, adaptive exploration, performance measurement.\n\n*   **Advice:** Focus on designing heuristics that dynamically adapt to the specific problem instance and phase. Prioritize measurable performance improvements over theoretical elegance.\n\n*   **Avoid:** Premature optimization, reliance on static parameters, ignoring the problem's nuances and edge cases.\n\n*   **Explanation:** Effective self-reflection analyzes *why* a heuristic works or fails in specific scenarios, guiding iterative refinement informed by empirical data. Don't just consider factors; understand their *impact* and interaction.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}