{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fits\n    valid_bins = remaining_cap_after_add >= 0\n    priorities[valid_bins] = 1\n\n    #Prioritize bins that will have the least wasted space\n    wasted_space = remaining_cap_after_add[valid_bins]\n    priorities[valid_bins] += 1.0 / (1e-6 + wasted_space)\n\n    # Try to spread items across bins if possible, less important when nearing full bins\n    priorities[valid_bins] += bins_remain_cap[valid_bins] / np.sum(bins_remain_cap[valid_bins] + 1e-6)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Reward bins where the item fits. Prioritize bins that are closer to a perfect fit.\n            # The closer the item size is to the remaining capacity, the higher the priority.\n            # Adding a small penalty to almost full bins\n            fit_ratio = item / cap\n            priorities[i] = (1 - abs(fit_ratio - 1)) - 0.01*(cap-item)\n\n            #Alternatively we can try this as well which is more deterministic:\n            #priorities[i] = 1/(cap - item + 0.000001)  # Avoid division by zero. Prefer smaller remaining space after insertion\n\n        else:\n            # Item doesn't fit, so very low priority.  Set to a large negative value\n            priorities[i] = -np.inf\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Reward bins where the item fits. Prioritize bins that are closer to a perfect fit.\n            # The closer the item size is to the remaining capacity, the higher the priority.\n            # Adding a small penalty to almost full bins\n            fit_ratio = item / cap\n            priorities[i] = (1 - abs(fit_ratio - 1)) - 0.01*(cap-item)\n\n            #Alternatively we can try this as well which is more deterministic:\n            #priorities[i] = 1/(cap - item + 0.000001)  # Avoid division by zero. Prefer smaller remaining space after insertion\n\n        else:\n            # Item doesn't fit, so very low priority.  Set to a large negative value\n            priorities[i] = -np.inf\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n    \n    # Give a high priority to bins where the item fits\n    valid_bins = remaining_cap_after_add >= 0\n    priorities[valid_bins] = 1\n\n    #Prioritize bins that will have the least wasted space\n    wasted_space = remaining_cap_after_add[valid_bins]\n    priorities[valid_bins] += 1.0 / (1e-6 + wasted_space)\n\n    # Try to spread items across bins if possible, less important when nearing full bins\n    priorities[valid_bins] += bins_remain_cap[valid_bins] / np.sum(bins_remain_cap[valid_bins] + 1e-6)\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A bin is only feasible if the item fits.\n    feasible_bins = bins_remain_cap >= item\n\n    # If no bin can fit item, assign minimum priority (this should ideally never happen).\n    if not np.any(feasible_bins):\n        return priorities - np.inf  # Assign very low priority to all bins\n\n    # Prioritize bins that can fit the item and have the least remaining capacity after packing, but not too little.\n    remaining_capacity_after_packing = bins_remain_cap - item\n    # Bins which cannot fit have rem cap as negative. Convert to infinity so that feasible is always preferred\n    remaining_capacity_after_packing[remaining_capacity_after_packing < 0] = np.inf\n\n    # Give higher priority to bins with low remaining capacity *after* packing\n    priorities = -remaining_capacity_after_packing\n\n    # Add a bonus to bins whose remaining capacity after packing is still significant\n    # This prevents bins from being overly packed. Set the target to ~ 1/3 or 1/4 bin usage\n    capacity_target = np.mean(bins_remain_cap)/3\n    bonus = np.exp(-np.abs(remaining_capacity_after_packing - capacity_target))\n\n    priorities = priorities + bonus\n\n\n    # Zero out priority for infeasible bins\n    priorities[~feasible_bins] = -np.inf\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins with remaining capacity slightly larger than the item size\n    to reduce fragmentation. If the item doesn't fit, the priority is set to a very low value.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity < item:\n            priorities[i] = -np.inf  # Very low priority if it doesn't fit\n        else:\n            # Priority is higher when the remaining capacity is slightly larger than the item.\n            # The smaller the waste (capacity - item), the higher the priority, but not too small\n            waste = capacity - item\n            if waste == 0:\n                priorities[i] = 100 # perfect fit should be high priority\n            elif waste < 0.1 :\n              priorities[i] = 50 # very small waste a good choice\n            elif waste < 0.3:\n              priorities[i] = 25 # relatively small waste\n            else:\n                priorities[i] = 1 / waste #inverse proportion to the waste amount\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item snugly (small wasted space),\n    but also avoids bins that are almost full to reduce fragmentation.\n    It incorporates a sigmoid function to balance these two aspects.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate wasted space for each bin\n    wasted_space = bins_remain_cap - item\n\n    # Bins that can't fit the item get a very low priority\n    priorities = np.where(wasted_space < 0, -np.inf, 0.0)\n\n    # For bins that *can* fit the item:\n\n    # 1. Calculate \"snugness\":  Inversely proportional to wasted space.  Smaller waste is better.\n    # Avoid division by zero by adding a small epsilon.\n    snugness = 1 / (wasted_space + 1e-9)\n    snugness = np.nan_to_num(snugness, nan=0.0, posinf=0.0, neginf=0.0)  # Handle potential infinities.\n\n    # 2. Calculate \"fragmentation risk\": high when the remaining capacity is close to the item size.\n    #  This is where the sigmoid comes in.\n    #  Sigmoid will be close to 1 when item size approaches bin capacity, and close to 0 if its almost empty.\n    # Higher sigmoid means bins which has smaller space compared to item\n    sigmoid_input = 5 * (bins_remain_cap - item) / bins_remain_cap  # Scale the difference\n    fragmentation_risk = 1 / (1 + np.exp(-sigmoid_input))  # Sigmoid function\n\n\n    # 3. Combine snugness and fragmentation risk\n    priorities = np.where(wasted_space >= 0, snugness * (1-fragmentation_risk), priorities)\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that have enough space for the item\n    but avoids bins that are *too* empty after the item is placed,\n    to maximize bin utilization and reduce fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the item\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        #If no bin can accomodate, assign uniform priority based on space left\n        priorities = bins_remain_cap\n        return priorities\n\n    # Calculate remaining capacity after placing the item in valid bins\n    remaining_cap = bins_remain_cap[valid_bins] - item\n\n    # High priority to bins that would be well-utilized\n    # After filling the bin.\n    # Penalize bins that would have too little capacity remaining\n    utilization = 1 - (remaining_cap / bins_remain_cap[valid_bins])\n    priorities[valid_bins] = utilization # Basic utilisation score\n\n    # Further adjustments to the priority:\n    # 1. Bins with capacity almost equal to the item size get higher priority (First Fit heuristic tweak)\n    almost_full = np.isclose(bins_remain_cap[valid_bins], item, rtol=0.05) #within 5%\n    priorities[valid_bins][almost_full] += 0.5\n\n    #2. Penalize bins that after putting the item would be too empty, creating fragmenation\n    # Here, if the resulting remaining capacity is more than, say, 50% of the total bin size, we penalize.\n    too_empty = remaining_cap > 0.5 * np.max(bins_remain_cap) #Compare remaining space to max remaining space\n    priorities[valid_bins][too_empty] -= 0.25\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins with remaining capacity closest to the item size,\n    but also considers bins that can accommodate multiple items of similar size.\n    Uses a combination of absolute difference in remaining capacity and a normalized capacity factor.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between remaining capacity and item size\n    diff = np.abs(bins_remain_cap - item)\n\n    # Calculate a capacity factor.  Bins with very small capacity compared to item size get a very low factor. Bins that can take item more than once also get penalized\n    capacity_factor = np.clip(bins_remain_cap / item, 0.1, 1.5) # Lower clipping to avoid infinite priority.\n\n    # Combine the difference and capacity factor to calculate the priority\n    priorities = capacity_factor / (1 + diff) # Dividing by (1 + diff) ensures that smaller differences yield higher priority\n\n    #Set priority to 0 for bins that can't fit the item\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item snugly (small wasted space),\n    but also avoids bins that are almost full to reduce fragmentation.\n    It incorporates a sigmoid function to balance these two aspects.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate wasted space for each bin\n    wasted_space = bins_remain_cap - item\n\n    # Bins that can't fit the item get a very low priority\n    priorities = np.where(wasted_space < 0, -np.inf, 0.0)\n\n    # For bins that *can* fit the item:\n\n    # 1. Calculate \"snugness\":  Inversely proportional to wasted space.  Smaller waste is better.\n    # Avoid division by zero by adding a small epsilon.\n    snugness = 1 / (wasted_space + 1e-9)\n    snugness = np.nan_to_num(snugness, nan=0.0, posinf=0.0, neginf=0.0)  # Handle potential infinities.\n\n    # 2. Calculate \"fragmentation risk\": high when the remaining capacity is close to the item size.\n    #  This is where the sigmoid comes in.\n    #  Sigmoid will be close to 1 when item size approaches bin capacity, and close to 0 if its almost empty.\n    # Higher sigmoid means bins which has smaller space compared to item\n    sigmoid_input = 5 * (bins_remain_cap - item) / bins_remain_cap  # Scale the difference\n    fragmentation_risk = 1 / (1 + np.exp(-sigmoid_input))  # Sigmoid function\n\n\n    # 3. Combine snugness and fragmentation risk\n    priorities = np.where(wasted_space >= 0, snugness * (1-fragmentation_risk), priorities)\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the celestial dance, favor the 'closest fit' whilst avoiding outright collisions.\n    Bins with capacity slightly exceeding the item size are to be given preference,\n    mimicking the delicate balance of planetary orbits.\n    Furthermore, severely penalize placing the item in nearly full bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Award points for bins that can fit the item.  If not, keep at 0.\n    fit_mask = bins_remain_cap >= item\n    \n    #Heuristics to adjust prioritiy based on remaining capacity\n    remaining_diff = bins_remain_cap - item\n    priorities[fit_mask] = 1.0 / (remaining_diff[fit_mask] + 0.0001)  # Inverse of remaining difference\n\n    # Penalize near-full bins severely\n    nearly_full_mask = bins_remain_cap < 0.1 #Bins with less than 0.1 remaining capacity\n    priorities[nearly_full_mask] = -1e9\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Employing a heuristic inspired by gravitational potential energy\n    and a dash of spring-like force to achieve more refined bin packing.\n    A lower potential energy (more filled bin) indicates higher priority,\n    but we add a 'spring force' term penalizing near-overflowing bins.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Gravitational Potential Energy analogy: Lower energy is preferred (more filled)\n    potential_energy = bins_remain_cap\n\n    # Spring-like force: Penalize bins that are too close to overflowing (small remaining capacity).\n    #This will simulate resistance when a bin is almost full, and it prevents to fill up such bin.\n    spring_constant = 1.0  # Adjust to control the strength of the spring force\n    spring_force = np.where(bins_remain_cap < item, -np.inf, spring_constant * (item - bins_remain_cap))\n    #Use spring_force = -np.exp(-bins_remain_cap+item) instead of spring_force = spring_constant * (item - bins_remain_cap) when overflow situation could happen.\n    # Total priority combines \"gravitational\" and \"spring\" terms, inverting the sum for maximization.\n\n    priorities = - (potential_energy + spring_force) #high score for high density after packing, penalty for overflow.\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function introduces a few heuristics inspired by physical principles,\n    particularly energy minimization and potential barriers.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # 1. Energy Landscape:  A bin close to full represents a lower \"energy state\".\n    #   We want to minimize \"energy\" (waste).  So, higher remaining capacity means higher \"energy\".\n    energy = bins_remain_cap\n\n    # 2. Quantum Tunneling (modified): Bins slightly too small might still be good if we consider \"tunneling\".\n    #    In reality, we're approximating how items might fit together, even if individually they seem too big.\n    tunneling_potential = np.where(bins_remain_cap >= item, 1.0, np.exp(-100 * (item - bins_remain_cap)**2)) #High penalty if much smaller than the item size.\n\n    # 3. Heaviside Step Function with some Smoothing (inspired by Fermi-Dirac statistics):\n    #    Bins that *can* fit the item get a significant boost, encouraging use of those bins first.\n    fit_probability = 0.5 * (1 + np.tanh(100 * (bins_remain_cap - item)))\n\n    # 4.  Inverted \"energy\" with tunneling and fitting factors modulating the priority\n    priorities = (1/ (energy + 1e-9)) * tunneling_potential * fit_probability # Added small constant for numerical stability\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic considers:\n        1. Space utilization (closeness of item size to remaining capacity).\n        2. Avoidance of near-full bins unless necessary (discourages filling almost full bins further).\n        3. Preference for bins that can accommodate the item comfortably,\n           but not too much waste, i.e., balance.\n        4. Introduce a stochastic element for exploration and escape local optima, especially when bins are very similar.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate space utilization.  Prefer higher utilization, but penalize overfilling.\n    utilization = item / bins_remain_cap\n    utilization = np.clip(utilization, 0, 1) # cap it\n\n    # Calculate remaining space after adding the item.\n    remaining_space = bins_remain_cap - item\n    remaining_space[remaining_space < 0] = -1  # Make invalid (cannot accommodate) zero (it will then have small priority.\n\n    # Give preference to bins that can accommodate the item (positive remaining space).\n    valid_mask = remaining_space >= 0\n    priorities[valid_mask] += 1.0  # Base priority for valid bins\n\n    # Heuristic for space utilization for available slots:\n    #  - We prefer higher utilization (item_size / remaining_capacity) up to some point\n    #  - After that we give preference to slots that create a bin neither too full, nor too empty.\n    utilization_available = utilization[valid_mask]\n    remaining_available = remaining_space[valid_mask]\n\n    # Score based on space-left after fitting:\n    priorities[valid_mask] += np.exp(-np.abs(remaining_available - item / 2))  # Bell curve shaped prefrence around item/2\n\n    # Boost with utilization score (how well this item fills a bin), without going over 1.\n    priorities[valid_mask] += utilization_available\n    # Avoid near-full bins unless very small space available (discourage too full)\n\n    almost_full_bins_id = (remaining_available < (0.05 * item))\n    if almost_full_bins_id.any():\n      priorities[valid_mask][almost_full_bins_id] -= 0.5 # Penality\n\n    # Introduce a bit of randomness to avoid getting stuck in local minima:\n\n    priorities += np.random.normal(0, 0.001, size=priorities.shape)\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic considers:\n        1. Space utilization (closeness of item size to remaining capacity).\n        2. Avoidance of near-full bins unless necessary (discourages filling almost full bins further).\n        3. Preference for bins that can accommodate the item comfortably,\n           but not too much waste, i.e., balance.\n        4. Introduce a stochastic element for exploration and escape local optima, especially when bins are very similar.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate space utilization.  Prefer higher utilization, but penalize overfilling.\n    utilization = item / bins_remain_cap\n    utilization = np.clip(utilization, 0, 1) # cap it\n\n    # Calculate remaining space after adding the item.\n    remaining_space = bins_remain_cap - item\n    remaining_space[remaining_space < 0] = -1  # Make invalid (cannot accommodate) zero (it will then have small priority.\n\n    # Give preference to bins that can accommodate the item (positive remaining space).\n    valid_mask = remaining_space >= 0\n    priorities[valid_mask] += 1.0  # Base priority for valid bins\n\n    # Heuristic for space utilization for available slots:\n    #  - We prefer higher utilization (item_size / remaining_capacity) up to some point\n    #  - After that we give preference to slots that create a bin neither too full, nor too empty.\n    utilization_available = utilization[valid_mask]\n    remaining_available = remaining_space[valid_mask]\n\n    # Score based on space-left after fitting:\n    priorities[valid_mask] += np.exp(-np.abs(remaining_available - item / 2))  # Bell curve shaped prefrence around item/2\n\n    # Boost with utilization score (how well this item fills a bin), without going over 1.\n    priorities[valid_mask] += utilization_available\n    # Avoid near-full bins unless very small space available (discourage too full)\n\n    almost_full_bins_id = (remaining_available < (0.05 * item))\n    if almost_full_bins_id.any():\n      priorities[valid_mask][almost_full_bins_id] -= 0.5 # Penality\n\n    # Introduce a bit of randomness to avoid getting stuck in local minima:\n\n    priorities += np.random.normal(0, 0.001, size=priorities.shape)\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic considers:\n        1. Space utilization (closeness of item size to remaining capacity).\n        2. Avoidance of near-full bins unless necessary (discourages filling almost full bins further).\n        3. Preference for bins that can accommodate the item comfortably,\n           but not too much waste, i.e., balance.\n        4. Introduce a stochastic element for exploration and escape local optima, especially when bins are very similar.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate space utilization.  Prefer higher utilization, but penalize overfilling.\n    utilization = item / bins_remain_cap\n    utilization = np.clip(utilization, 0, 1) # cap it\n\n    # Calculate remaining space after adding the item.\n    remaining_space = bins_remain_cap - item\n    remaining_space[remaining_space < 0] = -1  # Make invalid (cannot accommodate) zero (it will then have small priority.\n\n    # Give preference to bins that can accommodate the item (positive remaining space).\n    valid_mask = remaining_space >= 0\n    priorities[valid_mask] += 1.0  # Base priority for valid bins\n\n    # Heuristic for space utilization for available slots:\n    #  - We prefer higher utilization (item_size / remaining_capacity) up to some point\n    #  - After that we give preference to slots that create a bin neither too full, nor too empty.\n    utilization_available = utilization[valid_mask]\n    remaining_available = remaining_space[valid_mask]\n\n    # Score based on space-left after fitting:\n    priorities[valid_mask] += np.exp(-np.abs(remaining_available - item / 2))  # Bell curve shaped prefrence around item/2\n\n    # Boost with utilization score (how well this item fills a bin), without going over 1.\n    priorities[valid_mask] += utilization_available\n    # Avoid near-full bins unless very small space available (discourage too full)\n\n    almost_full_bins_id = (remaining_available < (0.05 * item))\n    if almost_full_bins_id.any():\n      priorities[valid_mask][almost_full_bins_id] -= 0.5 # Penality\n\n    # Introduce a bit of randomness to avoid getting stuck in local minima:\n\n    priorities += np.random.normal(0, 0.001, size=priorities.shape)\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item relatively snugly,\n    but also avoids bins that are too close in capacity (risk of future issues).\n    It combines factors like remaining capacity, space utilization, and\n    a penalty for bins almost fully filled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, only consider bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No suitable bin. All priorities are 0.\n\n    # Calculate utilization ratio (item size / bin capacity)\n    utilization_ratios = np.where(valid_bins, item / bins_remain_cap, 0)\n\n    # Give higher priority to bins with higher utilization (but less than 1)\n    priorities[valid_bins] = utilization_ratios[valid_bins]\n\n    # Penalize bins that would be almost full after placing the item\n    almost_full_threshold = 0.95  # Adjust as needed. If closer to 1 it aggressively penalizes nearly full.\n    remaining_after_placement = bins_remain_cap - item\n    almost_full_penalty = np.where(remaining_after_placement > 0, np.where((bins_remain_cap - item) / bins_remain_cap < (1 - almost_full_threshold), -10, 0), 0)  #Large penalty for almost full. Added a >0 to make the code runnable\n\n    priorities += almost_full_penalty\n\n    # Boost bins that are relatively large and can fit item more than minimal, for balance\n    large_bin_boost = np.where(valid_bins, np.log(bins_remain_cap / item), 0) #favor bins with higher capacity left compared to size of the item\n    priorities += large_bin_boost\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item relatively snugly,\n    but also avoids bins that are too close in capacity (risk of future issues).\n    It combines factors like remaining capacity, space utilization, and\n    a penalty for bins almost fully filled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, only consider bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No suitable bin. All priorities are 0.\n\n    # Calculate utilization ratio (item size / bin capacity)\n    utilization_ratios = np.where(valid_bins, item / bins_remain_cap, 0)\n\n    # Give higher priority to bins with higher utilization (but less than 1)\n    priorities[valid_bins] = utilization_ratios[valid_bins]\n\n    # Penalize bins that would be almost full after placing the item\n    almost_full_threshold = 0.95  # Adjust as needed. If closer to 1 it aggressively penalizes nearly full.\n    remaining_after_placement = bins_remain_cap - item\n    almost_full_penalty = np.where(remaining_after_placement > 0, np.where((bins_remain_cap - item) / bins_remain_cap < (1 - almost_full_threshold), -10, 0), 0)  #Large penalty for almost full. Added a >0 to make the code runnable\n\n    priorities += almost_full_penalty\n\n    # Boost bins that are relatively large and can fit item more than minimal, for balance\n    large_bin_boost = np.where(valid_bins, np.log(bins_remain_cap / item), 0) #favor bins with higher capacity left compared to size of the item\n    priorities += large_bin_boost\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can fit the item relatively snugly,\n    but also avoids bins that are too close in capacity (risk of future issues).\n    It combines factors like remaining capacity, space utilization, and\n    a penalty for bins almost fully filled.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, only consider bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities  # No suitable bin. All priorities are 0.\n\n    # Calculate utilization ratio (item size / bin capacity)\n    utilization_ratios = np.where(valid_bins, item / bins_remain_cap, 0)\n\n    # Give higher priority to bins with higher utilization (but less than 1)\n    priorities[valid_bins] = utilization_ratios[valid_bins]\n\n    # Penalize bins that would be almost full after placing the item\n    almost_full_threshold = 0.95  # Adjust as needed. If closer to 1 it aggressively penalizes nearly full.\n    remaining_after_placement = bins_remain_cap - item\n    almost_full_penalty = np.where(remaining_after_placement > 0, np.where((bins_remain_cap - item) / bins_remain_cap < (1 - almost_full_threshold), -10, 0), 0)  #Large penalty for almost full. Added a >0 to make the code runnable\n\n    priorities += almost_full_penalty\n\n    # Boost bins that are relatively large and can fit item more than minimal, for balance\n    large_bin_boost = np.where(valid_bins, np.log(bins_remain_cap / item), 0) #favor bins with higher capacity left compared to size of the item\n    priorities += large_bin_boost\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}