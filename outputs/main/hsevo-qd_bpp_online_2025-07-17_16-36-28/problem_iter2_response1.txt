```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines utilization, wasted space, and randomness for priority."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    # Utilization: item size / bin capacity.
    utilization = item / bins_remain_cap
    # Bins that can't fit have zero utilization.
    utilization[bins_remain_cap < item] = 0
    # Wasted space.
    wasted_space = bins_remain_cap - item
    wasted_space[wasted_space < 0] = np.inf  # Infeasible bins have infinite wasted space.

    # Reward bins where the item fits.
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] += 1  # Base priority for feasible bins.

    # Prefer better utilization and penalize wasted space.
    priorities[fit_mask] += utilization[fit_mask] - 0.1 * wasted_space[fit_mask]

    # Penalize near-full bins.
    almost_full = (wasted_space > 0) & (wasted_space < 0.05 * item)
    priorities[almost_full] -= 0.5

    # Add a small amount of noise for exploration.
    priorities += np.random.normal(0, 0.001, size=priorities.shape)
    return priorities
```
