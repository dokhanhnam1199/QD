```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Prioritizes bins that can accommodate the item with minimal waste,
    and penalizes bins that are nearly full or would result in significant wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify feasible bins (bins with enough capacity)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        # If no bin can fit the item, assign a small negative priority to all bins
        # to indicate that none are suitable.  A separate placement strategy
        # would need to be invoked to deal with this (e.g., create a new bin).
        priorities[:] = -1e9  # Large negative value
        return priorities


    # Calculate waste (remaining capacity after placing the item) for feasible bins
    waste = bins_remain_cap - item
    waste[~feasible_bins] = np.inf  # Set waste to infinity for infeasible bins so they don't affect calculations

    # Reward bins with small waste
    # Use a non-linear function to strongly reward small waste and less strongly reward larger waste.
    priorities[feasible_bins] = np.exp(-waste[feasible_bins])


    # Penalize near-full bins *before* the item is placed (risk of creating very small unusable space)
    near_full_threshold = 0.9  # A bin is considered near-full if it's filled beyond this ratio

    # A bin should be penalized if item + occupied > total capacity *near_full_threshold
    # which is equivalent to current_capacity > item_size + total_capacity*(1 - near_full_threshold)
    very_small_space_threshold = item / 1000  #Avoid numerical instability when dividing by zero.
    # Penalize bins if they have very little space after placing items.
    penalized_bins = feasible_bins & ((bins_remain_cap - item) < very_small_space_threshold)
    priorities[penalized_bins] -= 100

    # Greatly penalized if the item doesnt fit.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] -= 1e12

    # Reward more full bins, but only when waste will not be near empty.
    space_utilization_threshold = 0.25
    bins_without_excessive_waste = (waste > bins_remain_cap*space_utilization_threshold)
    priorities[bins_without_excessive_waste & feasible_bins] += bins_remain_cap[bins_without_excessive_waste & feasible_bins]

    return priorities
```
