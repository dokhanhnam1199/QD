```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fit_priority: float = 1.39, wasted_space_epsilon: float = 1e-6, half_full_target: float = 0.5, half_full_weight: float = 0.5, spread_weight: float = 0.2, random_weight: float = 0.01) -> np.ndarray:
    """Calculates bin priorities considering fit, wasted space, target fill, spread, and randomness."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities

    # Fit Priority
    priorities[valid_bins] += fit_priority

    # Wasted Space Priority
    remaining_after_fit = bins_remain_cap[valid_bins] - item
    wasted_space_priority = 1 / (remaining_after_fit + wasted_space_epsilon)
    priorities[valid_bins] += wasted_space_priority

    # Half-Full Target Priority
    bin_capacity = bins_remain_cap[valid_bins] + item  # Capacity if item added
    fill_level = (bin_capacity - remaining_after_fit) / bin_capacity
    half_full_diff = np.abs(fill_level - half_full_target)
    half_full_priority = 1 / (half_full_diff + wasted_space_epsilon)
    priorities[valid_bins] += half_full_weight * half_full_priority

    # Spread Priority (prefer bins with higher initial remaining capacity)
    spread_priority = bins_remain_cap[valid_bins] / np.sum(bins_remain_cap[valid_bins]) if np.sum(bins_remain_cap[valid_bins]) > 0 else np.zeros_like(bins_remain_cap[valid_bins])
    priorities[valid_bins] += spread_weight * spread_priority
    
    # Random Component
    random_component = np.random.rand(np.sum(valid_bins)) * random_weight
    priorities[valid_bins] += random_component

    return priorities
```
