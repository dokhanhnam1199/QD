```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the celestial dance, favor the 'closest fit' whilst avoiding outright collisions.
    Bins with capacity slightly exceeding the item size are to be given preference,
    mimicking the delicate balance of planetary orbits.
    Furthermore, severely penalize placing the item in nearly full bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Award points for bins that can fit the item.  If not, keep at 0.
    fit_mask = bins_remain_cap >= item
    
    #Heuristics to adjust prioritiy based on remaining capacity
    remaining_diff = bins_remain_cap - item
    priorities[fit_mask] = 1.0 / (remaining_diff[fit_mask] + 0.0001)  # Inverse of remaining difference

    # Penalize near-full bins severely
    nearly_full_mask = bins_remain_cap < 0.1 #Bins with less than 0.1 remaining capacity
    priorities[nearly_full_mask] = -1e9

    return priorities
```
