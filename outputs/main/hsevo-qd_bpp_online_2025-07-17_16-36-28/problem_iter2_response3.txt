```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines best aspects of v0 and v1: wasted space, utilization,
    and a soft penalty for almost-full bins. Prioritizes snug fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    valid_bins = bins_remain_cap >= item
    if not np.any(valid_bins):
        return priorities

    remaining_after_add = bins_remain_cap - item
    utilization_ratios = np.where(valid_bins, item / bins_remain_cap, 0)

    priorities[valid_bins] = utilization_ratios[valid_bins]


    almost_full_threshold = 0.95
    almost_full_penalty = np.where(remaining_after_add[valid_bins] > 0, np.where((bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins] < (1 - almost_full_threshold), -0.5, 0), 0)  #Soft penalty
    priorities[valid_bins] += almost_full_penalty


    wasted_space = remaining_after_add[valid_bins]
    priorities[valid_bins] += 0.1/ (1e-6 + wasted_space) # Scale it

    return priorities
```
