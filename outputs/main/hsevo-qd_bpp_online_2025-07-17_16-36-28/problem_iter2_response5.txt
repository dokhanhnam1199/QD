```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines snug fit, avoids near-full bins, and considers wasted space.
    Prioritizes bins that fit the item well, penalizes almost full bins,
    and boosts bins based on remaining capacity relative to item size.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities

    # Utilization ratio, favoring snug fits.
    utilization_ratios = np.where(valid_bins, item / bins_remain_cap, 0)
    priorities[valid_bins] = utilization_ratios[valid_bins]

    # Penalize almost-full bins to avoid fragmentation.
    remaining_after_placement = bins_remain_cap - item
    almost_full_threshold = 0.95
    almost_full_penalty = np.where(remaining_after_placement > 0,
                                    np.where(remaining_after_placement / bins_remain_cap < (1 - almost_full_threshold), -10, 0), 0)
    priorities += almost_full_penalty

    # Boost larger bins that can accommodate the item comfortably.
    waste = bins_remain_cap - item
    waste_boost = np.where(valid_bins, np.exp(-waste), 0) # Add exponential boost. Smaller waste larger the boost.
    priorities += waste_boost

    return priorities
```
