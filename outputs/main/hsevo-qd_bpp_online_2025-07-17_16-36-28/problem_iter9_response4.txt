```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A more sophisticated priority function for online bin packing, incorporating
    adaptive strategies, nuanced weighting, and controlled exploration.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap - item >= 0

    if not np.any(valid_bins):
        return priorities

    # 1. Feasibility Boost: Ensure only valid bins are considered.
    priorities[valid_bins] += 1.0

    # 2. Wasted Space Minimization (Adaptive Weighting):
    wasted_space = bins_remain_cap[valid_bins] - item
    # Softer penalty for slightly exceeding, to allow for better distribution later
    wasted_space_priority = 1.0 / (1e-6 + wasted_space)

    # Make it adaptive based on item size: If item is small, waste matters more.
    wasted_space_weight = min(1.0, item)  # Scale down priority for larger items
    priorities[valid_bins] += wasted_space_priority * wasted_space_weight

    # 3. Target Fill Level (Dynamic Adjustment):
    target_fill = np.mean(bins_remain_cap) / 2.0 # Attempt to target half full
    fill_diff = np.abs(bins_remain_cap[valid_bins] - item - target_fill)
    fill_priority = 1.0 / (1e-6 + fill_diff)

    # Dynamic weight based on how full bins are.  If all bins are nearly full,
    # the fill difference matters less.
    fill_weight = 1 - (np.mean(bins_remain_cap) / np.max(bins_remain_cap))
    priorities[valid_bins] += fill_priority * fill_weight

    # 4. Bin Fragmentation Penalty (Nuanced):
    # Encourages filling bins that already have items. The more items, the more important.
    # This is a very simplistic proxy, but we lack history in an online context.
    occupied_space = np.max(bins_remain_cap) - bins_remain_cap[valid_bins]
    fragmentation_priority = occupied_space / (np.max(bins_remain_cap) + 1e-6)
    priorities[valid_bins] += fragmentation_priority

    # 5. Encourage Spread (Non-linear Scaling):
    # Encourages using empty bins, but not too strongly if other bins are filling up nicely.
    empty_bin_bonus = (np.max(bins_remain_cap) - bins_remain_cap[valid_bins])**2
    priorities[valid_bins] += empty_bin_bonus / (np.sum(empty_bin_bonus) + 1e-6)

    # 6. Controlled Exploration (Simulated Annealing):
    temperature = 0.1 # Higher values cause more exploration
    random_noise = np.random.rand(np.sum(valid_bins)) * temperature
    priorities[valid_bins] += random_noise

    # 7. Prioritize bins closer to item sizes.
    size_diff = np.abs(bins_remain_cap[valid_bins] - item)
    size_priority = 1.0 / (1e-6 + size_diff)
    size_weight = 0.5 # Adjust the weight given to size preference.
    priorities[valid_bins] += size_priority * size_weight


    return priorities
```
