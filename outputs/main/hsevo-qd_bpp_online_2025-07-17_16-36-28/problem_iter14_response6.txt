```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Calculates bin priorities considering fit, waste, fill level, and spread."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Fit: High priority if the item fits
    remaining_cap_after_add = bins_remain_cap - item
    valid_bins = remaining_cap_after_add >= 0
    priorities[valid_bins] = 1.0

    # Waste: Prioritize bins with minimal wasted space
    wasted_space = remaining_cap_after_add[valid_bins]
    priorities[valid_bins] += 1.0 / (1e-6 + wasted_space)

    # Fill level: Target half-full bins
    bin_size = bins_remain_cap + item  # Approximates original bin size. Correct if item fits or it is the first item
    half_full_diff = np.abs(bins_remain_cap[valid_bins] - bin_size[valid_bins]/ 2) #abs value of (current_remaining_cap - half of the bin size)
    priorities[valid_bins] += 1.0 / (1e-6 + half_full_diff)

    # Spread: Encourage even distribution
    priorities[valid_bins] += bins_remain_cap[valid_bins] / (np.sum(bins_remain_cap[valid_bins]) + 1e-6)
    
    # Adaptive Randomness: Increase randomness for bins nearing full
    near_full = bins_remain_cap < 0.1 * bin_size #check near full for valid bin only
    random_component = np.random.rand(len(bins_remain_cap)) * 0.01
    priorities[valid_bins & near_full] += random_component[valid_bins & near_full]  #Add adaptive exploration only when near full

    return priorities
```
