```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with capacity slightly larger than the item size,
    but penalizes bins that are either too small or much larger. This encourages
    more efficient packing and avoids fragmentation. It uses a combination of
    relative fullness and a penalty for large empty space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity < item:
            priorities[i] = -np.inf  # Cannot fit, lowest priority
        else:
            # Calculate the relative fullness if the item is placed in the bin
            fullness = item / capacity

            # Give higher priority to bins that are relatively full after placing the item.
            # Avoids large wasted space if capacity is significantly larger than item.
            # Small amount of unused capacity is preferred.  Experimented values are chosen.
            # Also scale with item size so large items avoid "overfilling" bins

            unused_penalty = np.exp(- (capacity - item) / (0.1*item+0.1)) # Higher capacity lead to lower value.

            priorities[i] = fullness * unused_penalty # Encourage fitting items but penalized waste
    return priorities
```
