{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n\n    # Give a high priority to bins where the item fits\n    valid_bins = remaining_cap_after_add >= 0\n    if not np.any(valid_bins):\n        return priorities # No valid bins, all priorities remain 0\n\n    priorities[valid_bins] = 1\n\n    # Prioritize bins that will have the least wasted space\n    wasted_space = remaining_cap_after_add[valid_bins]\n    priorities[valid_bins] += 1.0 / (1e-6 + wasted_space)\n\n    # Prioritize bins closer to half-full after adding the item\n    half_full_diff = np.abs(remaining_cap_after_add[valid_bins] - np.mean(bins_remain_cap) / 2) # Try to make bins uniformly occupied\n    priorities[valid_bins] += 1.0 / (1e-6 + half_full_diff)\n\n    #Scale the bin_remain_cap to emphasize almost full bins\n    scaled_bins_remain_cap = bins_remain_cap[valid_bins]**2\n\n    # Try to spread items across bins if possible, less important when nearing full bins\n    priorities[valid_bins] += scaled_bins_remain_cap / np.sum(scaled_bins_remain_cap + 1e-6)\n\n    # Add a small random component to break ties and explore different solutions\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                bins_remain_cap: np.ndarray,\n                fit_priority: float = 1.3920066404433198,\n                wasted_space_epsilon: float = 4.827875296811026e-06,\n                half_full_epsilon: float = 7.010850237263482e-06,\n                spread_epsilon: float = 6.740380158224467e-06,\n                random_component_weight: float = 0.010327684384234433) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        fit_priority: Priority to give valid bins.\n        wasted_space_epsilon: Epsilon to avoid division by zero when prioritizing least wasted space.\n        half_full_epsilon: Epsilon to avoid division by zero when prioritizing bins closer to half-full.\n        spread_epsilon: Epsilon to avoid division by zero when spreading items across bins.\n        random_component_weight: Weight of the random component added to break ties.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate remaining capacity after adding the item\n    remaining_cap_after_add = bins_remain_cap - item\n\n    # Give a high priority to bins where the item fits\n    valid_bins = remaining_cap_after_add >= 0\n    if not np.any(valid_bins):\n        return priorities # No valid bins, all priorities remain 0\n\n### Analyze & experience\n- Comparing (1st) vs (19th), we see the first one considers multiple factors like wasted space, closeness to half-full, and spreading items, while the 19th uses only the ratio of item size to remaining capacity and its logarithm. The first one also handles the case where no bins can fit the item, while the 19th does not.\n\nComparing (2nd) vs (20th), we see the same as above.\n\nComparing (7th) vs (14th), we see that 7th prioritizes bins based on fit ratio and disincentivizes largely empty bins, setting a low priority for bins where the item doesn't fit by assigning -np.inf. 14th prioritizes bins where items fit and then prioritizes the bins with least wasted space.\n\nComparing (15th) vs (16th), the main difference is 15th has the function to prioritize but it is never used to prioritize the bins.\n\nComparing (1st) vs (2nd), (3rd) vs (4th), (5th) vs (6th), they are exactly the same. The ranking between them is not based on their code.\n\nComparing (9th) vs (11th), (13th) vs (14th), they are exactly the same.\n\nComparing (10th) vs (12th), (7th) vs (8th), they are exactly the same.\n\nOverall: The better heuristics consider multiple factors, including whether the item fits, wasted space, target fill level (e.g., half-full), and spreading items across bins. They also handle edge cases, such as when no bins can fit the item or when division by zero might occur. The best heuristics use a combination of rules and tunable parameters to adapt to specific problem instances. A crucial aspect is assigning priorities effectively based on these factors and using appropriate scaling or normalization. Randomness is also important for breaking ties.\n- \nOkay, let's refine \"Current self-reflection\" to create a more potent guide for designing heuristics:\n\n*   **Keywords:** Adaptive learning, robust exploration, problem-specific knowledge, computational efficiency.\n\n*   **Advice:** Focus on *learning* from iterations. Adapt heuristic strategies based on problem instance characteristics and performance feedback. Rigorously test and validate.\n\n*   **Avoid:** Blind parameter tuning, static strategies, neglecting problem-specific insights, premature optimization for speed.\n\n*   **Explanation:** Move beyond generic strategies. Design heuristics that intelligently adapt, incorporating problem understanding for robust, effective solutions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}