```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic considers:
        1. Space utilization (closeness of item size to remaining capacity).
        2. Avoidance of near-full bins unless necessary (discourages filling almost full bins further).
        3. Preference for bins that can accommodate the item comfortably,
           but not too much waste, i.e., balance.
        4. Introduce a stochastic element for exploration and escape local optima, especially when bins are very similar.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate space utilization.  Prefer higher utilization, but penalize overfilling.
    utilization = item / bins_remain_cap
    utilization = np.clip(utilization, 0, 1) # cap it

    # Calculate remaining space after adding the item.
    remaining_space = bins_remain_cap - item
    remaining_space[remaining_space < 0] = -1  # Make invalid (cannot accommodate) zero (it will then have small priority.

    # Give preference to bins that can accommodate the item (positive remaining space).
    valid_mask = remaining_space >= 0
    priorities[valid_mask] += 1.0  # Base priority for valid bins

    # Heuristic for space utilization for available slots:
    #  - We prefer higher utilization (item_size / remaining_capacity) up to some point
    #  - After that we give preference to slots that create a bin neither too full, nor too empty.
    utilization_available = utilization[valid_mask]
    remaining_available = remaining_space[valid_mask]

    # Score based on space-left after fitting:
    priorities[valid_mask] += np.exp(-np.abs(remaining_available - item / 2))  # Bell curve shaped prefrence around item/2

    # Boost with utilization score (how well this item fills a bin), without going over 1.
    priorities[valid_mask] += utilization_available
    # Avoid near-full bins unless very small space available (discourage too full)

    almost_full_bins_id = (remaining_available < (0.05 * item))
    if almost_full_bins_id.any():
      priorities[valid_mask][almost_full_bins_id] -= 0.5 # Penality

    # Introduce a bit of randomness to avoid getting stuck in local minima:

    priorities += np.random.normal(0, 0.001, size=priorities.shape)
    return priorities
```
