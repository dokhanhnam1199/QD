import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining shortest path information with edge proximity, prioritizing paths through nodes with shorter overall distances to other nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    # Calculate node proximity based on total distance to other nodes
    node_proximity = np.sum(distance_matrix, axis=0)

    # Floyd-Warshall Algorithm to find shortest paths
    shortest_paths = distance_matrix.copy()
    for k in range(n):
        for i in range(n):
            for j in range(n):
                shortest_paths[i, j] = min(shortest_paths[i, j], shortest_paths[i, k] + shortest_paths[k, j])

    # Combine shortest path and node proximity information
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristics_matrix[i, j] = (1 / (shortest_paths[i, j] + 1e-9)) + (1 / (node_proximity[i] + node_proximity[j] + 1e-9))

    return heuristics_matrix
