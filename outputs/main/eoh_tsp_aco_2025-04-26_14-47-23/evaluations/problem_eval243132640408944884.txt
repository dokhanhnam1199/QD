import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm iteratively samples random partial tours, evaluates their promise based on a combination of tour length and connectivity to unvisited nodes, and updates a heuristic matrix to favor edges present in promising partial tours.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_samples = 1000
    partial_tour_length = n // 2

    for _ in range(num_samples):
        # Generate a random partial tour
        start_node = np.random.randint(n)
        unvisited = list(range(n))
        unvisited.remove(start_node)
        tour = [start_node]

        for _ in range(min(partial_tour_length - 1, n-1)): # Ensure partial tour does not exceed n
            
            distances = distance_matrix[tour[-1], unvisited]
            probabilities = 1 / (distances + 1e-6)  # Avoid division by zero
            probabilities /= np.sum(probabilities)
            
            next_node = np.random.choice(unvisited, p=probabilities)
            tour.append(next_node)
            unvisited.remove(next_node)
            
        # Calculate partial tour distance
        tour_distance = 0
        for i in range(len(tour) - 1):
            tour_distance += distance_matrix[tour[i], tour[i + 1]]
        
        #Connectivity score to remaining nodes
        connectivity_score = 0
        if unvisited:
            for node in tour:
                connectivity_score += np.sum(1 / (distance_matrix[node, unvisited] + 1e-6))

        #Promise of this partial tour
        promise = (1 / (tour_distance + 1e-6)) + connectivity_score

        # Update heuristics matrix
        for i in range(len(tour) - 1):
            heuristics_matrix[tour[i], tour[i + 1]] += promise
            heuristics_matrix[tour[i + 1], tour[i]] += promise

    return heuristics_matrix
