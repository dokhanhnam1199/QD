import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristics matrix based on the inverse of the distance matrix, enhanced by adding a term that encourages exploration of less traveled edges, modulated by the standard deviation of edge usage in sampled tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1 / (distance_matrix + 1e-9)
    num_samples = 100
    sampled_tours = []
    for _ in range(num_samples):
        tour = np.random.permutation(n)
        sampled_tours.append(tour)

    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    for tour in sampled_tours:
        for i in range(n - 1):
            edge_counts[tour[i], tour[i + 1]] += 1
            edge_counts[tour[i + 1], tour[i]] += 1
        edge_counts[tour[-1], tour[0]] += 1
        edge_counts[tour[0], tour[-1]] += 1

    edge_usage_std = np.std(edge_counts)
    heuristics_matrix += (edge_usage_std / (edge_counts + 1e-9))
    return heuristics_matrix
