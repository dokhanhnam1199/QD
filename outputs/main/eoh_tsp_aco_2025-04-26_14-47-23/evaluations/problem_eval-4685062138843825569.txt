import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm to evolve a population of TSP solutions, where the fitness of each solution is inversely proportional to its tour length, and the heuristics matrix is constructed by averaging the edge frequencies of the best solutions in the final generation.}"""
    n = distance_matrix.shape[0]
    population_size = 50
    num_generations = 100
    mutation_rate = 0.05
    
    def create_initial_population(size, n):
        population = []
        for _ in range(size):
            permutation = np.random.permutation(n)
            population.append(permutation)
        return population
    
    def calculate_fitness(population, distance_matrix):
        fitness_scores = []
        for individual in population:
            tour_length = 0
            for i in range(n - 1):
                tour_length += distance_matrix[individual[i], individual[i + 1]]
            tour_length += distance_matrix[individual[-1], individual[0]]
            fitness_scores.append(1 / (tour_length + 1e-9)) # Invert to make higher fitness better
        return np.array(fitness_scores)

    def crossover(parent1, parent2):
        start = np.random.randint(n)
        end = np.random.randint(start + 1, n + 1)
        
        child = np.zeros(n, dtype=int) - 1
        child[start:end] = parent1[start:end]
        
        remaining_indices = np.where(child == -1)[0]
        
        parent2_ptr = 0
        for i in range(len(remaining_indices)):
          while parent2[parent2_ptr] in child:
            parent2_ptr +=1
          child[remaining_indices[i]] = parent2[parent2_ptr]
          parent2_ptr += 1
        
        return child
    
    def mutate(individual, mutation_rate):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(n, 2, replace=False)
            individual[i], individual[j] = individual[j], individual[i]
        return individual

    population = create_initial_population(population_size, n)

    for _ in range(num_generations):
        fitness_scores = calculate_fitness(population, distance_matrix)
        probabilities = fitness_scores / np.sum(fitness_scores)
        
        new_population = []
        for _ in range(population_size):
            parent1_idx = np.random.choice(population_size, p=probabilities)
            parent2_idx = np.random.choice(population_size, p=probabilities)
            child = crossover(population[parent1_idx], population[parent2_idx])
            child = mutate(child, mutation_rate)
            new_population.append(child)
        
        population = np.array(new_population)

    fitness_scores = calculate_fitness(population, distance_matrix)
    best_indices = np.argsort(fitness_scores)[-population_size // 5:]  #Select top 20%

    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for idx in best_indices:
        best_tour = population[idx]
        for i in range(n):
            node1 = best_tour[i]
            node2 = best_tour[(i + 1) % n]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= len(best_indices)
    return heuristics_matrix
