import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by iteratively improving random tours using 2-opt swaps and recording edge frequencies.}"""
    n = distance_matrix.shape[0]
    num_iterations = 100
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for _ in range(num_iterations):
        # Initialize a random tour
        tour = np.random.permutation(n)
        
        # Perform 2-opt swaps to improve the tour
        for _ in range(100):  # Number of 2-opt iterations per tour
            i = np.random.randint(n)
            j = np.random.randint(n)
            if i == j:
                continue
            
            if i > j:
                i, j = j, i
                
            # Calculate current tour length
            current_length = 0
            for k in range(n - 1):
                current_length += distance_matrix[tour[k], tour[k+1]]
            current_length += distance_matrix[tour[n-1], tour[0]]

            # Create a new tour with a 2-opt swap
            new_tour = np.concatenate((tour[:i], tour[i:j+1][::-1], tour[j+1:]))

            # Calculate new tour length
            new_length = 0
            for k in range(n - 1):
                new_length += distance_matrix[new_tour[k], new_tour[k+1]]
            new_length += distance_matrix[new_tour[n-1], new_tour[0]]

            # Accept the new tour if it's shorter
            if new_length < current_length:
                tour = new_tour
        
        # Update the heuristics matrix with edge frequencies of the improved tour
        for i in range(n):
            node1 = tour[i]
            node2 = tour[(i + 1) % n]
            heuristics_matrix[node1, node2] += 1
            heuristics_matrix[node2, node1] += 1

    heuristics_matrix /= num_iterations
    return heuristics_matrix
