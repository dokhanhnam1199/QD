import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a greedy approach to build a tour, iteratively adding the nearest unvisited node, and the heuristic matrix reflects the inverse of the number of times each edge is used in the greedy tours generated from different starting nodes.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    for start_node in range(n):
        current_node = start_node
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)
        tour = [current_node]

        while unvisited_nodes:
            nearest_node = None
            min_distance = float('inf')

            for neighbor in unvisited_nodes:
                distance = distance_matrix[current_node, neighbor]
                if distance < min_distance:
                    min_distance = distance
                    nearest_node = neighbor

            tour.append(nearest_node)
            unvisited_nodes.remove(nearest_node)
            current_node = nearest_node

        # Update heuristic matrix
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i + 1]] += 1
            heuristics_matrix[tour[i + 1], tour[i]] += 1
        heuristics_matrix[tour[-1], tour[0]] += 1
        heuristics_matrix[tour[0], tour[-1]] += 1

    # Invert the frequency to represent desirability (lower frequency = more desirable)
    heuristics_matrix = 1.0 / (heuristics_matrix + 1e-9)

    return heuristics_matrix
