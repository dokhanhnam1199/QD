import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random tours, computes the frequency of each edge appearing in the sampled tours, and then combines this frequency with a measure of edge desirability based on distance to produce a matrix of heuristic values indicating the likelihood of an edge being in the optimal tour.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        
        # Count edges in the tour
        for i in range(n):
            u = tour[i]
            v = tour[(i + 1) % n]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1
    
    # Normalize edge counts
    edge_frequencies = edge_counts / num_samples
    
    # Heuristic values: combine frequency with inverse of distance
    heuristics_matrix = edge_frequencies / (distance_matrix + 1e-9)  # Avoid division by zero
    
    return heuristics_matrix
