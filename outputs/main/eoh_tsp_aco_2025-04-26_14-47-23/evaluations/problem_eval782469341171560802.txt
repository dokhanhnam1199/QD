import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples random paths and updates a heuristics matrix based on the frequency of edges appearing in the best paths found so far.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 1000
    top_paths_to_keep = 10

    best_paths = []
    best_path_lengths = []

    for _ in range(num_iterations):
        path = np.random.permutation(n)
        path_length = 0
        for i in range(n - 1):
            path_length += distance_matrix[path[i], path[i+1]]
        path_length += distance_matrix[path[-1], path[0]]

        if len(best_paths) < top_paths_to_keep:
            best_paths.append(path)
            best_path_lengths.append(path_length)
        else:
            max_length_index = np.argmax(best_path_lengths)
            if path_length < best_path_lengths[max_length_index]:
                best_paths[max_length_index] = path
                best_path_lengths[max_length_index] = path_length

    for path in best_paths:
        for i in range(n - 1):
            heuristics_matrix[path[i], path[i+1]] += 1
            heuristics_matrix[path[i+1], path[i]] += 1  # Assuming symmetric matrix
        heuristics_matrix[path[-1], path[0]] += 1
        heuristics_matrix[path[0], path[-1]] += 1

    return heuristics_matrix
