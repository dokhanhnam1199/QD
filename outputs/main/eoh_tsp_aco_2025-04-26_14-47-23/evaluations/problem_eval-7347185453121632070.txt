import numpy as np

def heuristics_v2(distance_matrix):
    """
    {This algorithm initializes a heuristics matrix based on the inverse of the distance matrix, then iteratively refines it by sampling random tours, and increasing the heuristic value for edges present in shorter tours.}
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = 1.0 / (distance_matrix + np.eye(n))
    np.fill_diagonal(heuristics_matrix, 0)

    num_iterations = 1000
    num_samples = 100

    for _ in range(num_iterations):
        tour_lengths = []
        tours = []

        for _ in range(num_samples):
            start_node = np.random.randint(n)
            unvisited_nodes = list(range(n))
            unvisited_nodes.remove(start_node)
            current_node = start_node
            tour = [start_node]

            while unvisited_nodes:
                probabilities = heuristics_matrix[current_node, unvisited_nodes]
                probabilities /= np.sum(probabilities)  # Normalize probabilities

                next_node_index = np.random.choice(len(unvisited_nodes), p=probabilities)
                next_node = unvisited_nodes[next_node_index]
                
                tour.append(next_node)
                unvisited_nodes.pop(next_node_index)
                current_node = next_node

            tour.append(start_node)  # Return to the starting node

            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[i+1]]

            tour_lengths.append(tour_length)
            tours.append(tour)
        
        # Find the shortest tour in this sample and boost heuristics for its edges
        best_tour_index = np.argmin(tour_lengths)
        best_tour = tours[best_tour_index]
        
        for i in range(n):
            u, v = best_tour[i], best_tour[i+1]
            heuristics_matrix[u, v] += 0.1
            heuristics_matrix[v, u] += 0.1

    return heuristics_matrix
