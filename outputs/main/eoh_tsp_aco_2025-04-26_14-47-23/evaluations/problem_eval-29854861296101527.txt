import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines shortest-path information with edge-similarity considerations to construct a heuristic matrix that favors edges belonging to diverse and shorter routes.}"""
    n = distance_matrix.shape[0]
    shortest_path_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Initialize path costs with direct distances
                path_costs = np.full(n, np.inf)
                path_costs[i] = 0
                unvisited = set(range(n))

                while unvisited:
                    current_node = min(unvisited, key=lambda node: path_costs[node])
                    if path_costs[current_node] == np.inf:
                        break # No path found
                    unvisited.remove(current_node)

                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] != 0:
                            new_cost = path_costs[current_node] + distance_matrix[current_node, neighbor]
                            if new_cost < path_costs[neighbor]:
                                path_costs[neighbor] = new_cost

                shortest_path_matrix[i, j] = path_costs[j]
    
    edge_similarity = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                similarities = []
                for k in range(n):
                    if k != i and k != j:
                        similarities.append(np.exp(-np.abs(distance_matrix[i,k] - distance_matrix[j,k])))
                edge_similarity[i, j] = np.mean(similarities) if similarities else 0

    heuristics_matrix = (1 / (shortest_path_matrix + 1e-9)) + edge_similarity
    return heuristics_matrix
