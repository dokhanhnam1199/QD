import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a solution by randomly swapping nodes in the current best path and accepting the change if it improves the total path length, combined with simulated annealing to escape local optima.}"""
    n = distance_matrix.shape[0]
    num_iterations = 1000
    initial_temperature = 100
    cooling_rate = 0.95

    # Initialize with a random tour
    current_tour = np.random.permutation(n)
    best_tour = current_tour.copy()

    def calculate_tour_length(tour):
        length = 0
        for i in range(n - 1):
            length += distance_matrix[tour[i], tour[i + 1]]
        length += distance_matrix[tour[-1], tour[0]]
        return length

    best_tour_length = calculate_tour_length(best_tour)
    temperature = initial_temperature

    for _ in range(num_iterations):
        # Generate a neighbor by swapping two random cities
        i, j = np.random.choice(n, 2, replace=False)
        new_tour = current_tour.copy()
        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]
        new_tour_length = calculate_tour_length(new_tour)

        # Acceptance criterion (Metropolis)
        if new_tour_length < best_tour_length:
            best_tour = new_tour.copy()
            best_tour_length = new_tour_length
            current_tour = new_tour.copy()
        else:
            # Simulated Annealing: Accept worse solutions with a probability
            delta = new_tour_length - best_tour_length
            acceptance_probability = np.exp(-delta / temperature)
            if np.random.rand() < acceptance_probability:
                current_tour = new_tour.copy()
            #else: keep current tour
        temperature *= cooling_rate

    #Create heuristics_matrix based on the best tour
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
      node1 = best_tour[i]
      node2 = best_tour[(i+1)%n]
      heuristics_matrix[node1,node2] = 1
      heuristics_matrix[node2,node1] = 1

    return heuristics_matrix
