import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve promising tours and derive edge frequencies from the best individuals to guide the TSP solution.}"""
    n = distance_matrix.shape[0]
    population_size = 100
    num_generations = 50
    mutation_rate = 0.01

    # Initialize population
    population = [np.random.permutation(n) for _ in range(population_size)]

    def calculate_fitness(tour):
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[-1], tour[0]]
        return 1.0 / (tour_length + 1e-9)  # Inverse of tour length

    def crossover(parent1, parent2):
        start = np.random.randint(0, n)
        end = np.random.randint(start + 1, n + 1)
        child = np.zeros(n, dtype=int) - 1
        child[start:end] = parent1[start:end]
        
        # Fill in remaining elements from parent2, maintaining order
        index_parent2 = 0
        for i in range(n):
            if child[i] == -1:
                while parent2[index_parent2] in child:
                    index_parent2 += 1
                child[i] = parent2[index_parent2]
                index_parent2 += 1
        return child

    def mutate(tour):
        if np.random.rand() < mutation_rate:
            i, j = np.random.choice(n, 2, replace=False)
            tour[i], tour[j] = tour[j], tour[i]
        return tour

    # Evolve population
    for _ in range(num_generations):
        # Calculate fitness for each tour
        fitness_scores = [calculate_fitness(tour) for tour in population]

        # Select parents based on fitness (roulette wheel selection)
        probabilities = fitness_scores / np.sum(fitness_scores)
        indices = np.arange(population_size)
        parents_indices = np.random.choice(indices, size=population_size, replace=True, p=probabilities)
        parents = [population[i] for i in parents_indices]

        # Create new population through crossover and mutation
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = parents[i]
            parent2 = parents[i+1]
            child1 = crossover(parent1, parent2)
            child2 = crossover(parent2, parent1)
            new_population.append(mutate(child1))
            new_population.append(mutate(child2))
        
        population = new_population

    # Evaluate final population and select the best tours
    fitness_scores = [calculate_fitness(tour) for tour in population]
    best_tours_indices = np.argsort(fitness_scores)[-population_size // 10:] # top 10%
    best_tours = [population[i] for i in best_tours_indices]

    # Count edge occurrences in best tours
    edge_counts = np.zeros((n, n))
    for tour in best_tours:
        for i in range(n - 1):
            edge_counts[tour[i], tour[i+1]] += 1
            edge_counts[tour[i+1], tour[i]] += 1
        edge_counts[tour[-1], tour[0]] += 1
        edge_counts[tour[0], tour[-1]] += 1

    # Normalize edge counts to get heuristics matrix
    heuristics_matrix = edge_counts / len(best_tours)

    return heuristics_matrix
