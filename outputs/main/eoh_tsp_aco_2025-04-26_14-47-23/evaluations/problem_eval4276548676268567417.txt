import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm refines a heuristic matrix by iteratively adjusting edge weights based on shortest path computations and reinforcement learning principles.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float) / (distance_matrix + 1e-9)
    learning_rate = 0.1
    discount_factor = 0.9
    num_iterations = 1000

    for _ in range(num_iterations):
        # Select a random node
        start_node = np.random.randint(n)

        # Compute shortest paths from the starting node
        shortest_paths = dijkstra(distance_matrix, start_node)

        # Update the heuristic matrix based on shortest paths
        for i in range(n):
            for j in range(i + 1, n):
                reward = -distance_matrix[i, j]
                if shortest_paths[i] + distance_matrix[i, j] == shortest_paths[j] or \
                   shortest_paths[j] + distance_matrix[j, i] == shortest_paths[i]:
                    reward = 1.0/distance_matrix[i,j]  # Positive reward if on a shortest path
                else:
                   reward = -distance_matrix[i,j] # Negative reward if not on a shortest path

                heuristics_matrix[i, j] += learning_rate * (reward - heuristics_matrix[i, j])
                heuristics_matrix[j, i] = heuristics_matrix[i, j]

        # Ensure non-negativity
        heuristics_matrix[heuristics_matrix < 1e-9] = 1e-9

    return heuristics_matrix

def dijkstra(distance_matrix, start_node):
    """Compute shortest path distances from a starting node."""
    n = distance_matrix.shape[0]
    distances = np.full(n, np.inf)
    distances[start_node] = 0
    visited = np.zeros(n, dtype=bool)

    for _ in range(n):
        # Find the unvisited node with the smallest distance
        min_distance = np.inf
        min_node = -1
        for node in range(n):
            if not visited[node] and distances[node] < min_distance:
                min_distance = distances[node]
                min_node = node

        if min_node == -1:
            break

        visited[min_node] = True

        # Update distances to neighbors
        for neighbor in range(n):
            if not visited[neighbor] and distance_matrix[min_node, neighbor] != np.inf:
                new_distance = distances[min_node] + distance_matrix[min_node, neighbor]
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance

    return heuristics_matrix
