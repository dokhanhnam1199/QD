import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples multiple random tours, computes the frequency of each edge appearing in the sampled tours, and combines this frequency with a measure of edge desirability based on distance, further penalizing edges that are consistently far apart in random tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    edge_distances = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_samples):
        # Generate a random tour
        tour = np.random.permutation(n)
        
        # Count edges in the tour and calculate the "distance" between nodes in the tour
        for i in range(n):
            u = tour[i]
            v = tour[(i + 1) % n]
            edge_counts[u, v] += 1
            edge_counts[v, u] += 1
            
            tour_distance = 0
            
            # Find distance in the tour (clockwise or counter-clockwise, whichever is shorter)
            u_index = np.where(tour == u)[0][0]
            v_index = np.where(tour == v)[0][0]
            
            if u_index < v_index:
                tour_distance = v_index - u_index
            else:
                tour_distance = (n - u_index) + v_index
            
            edge_distances[u, v] += tour_distance
            edge_distances[v, u] += tour_distance
    
    # Normalize edge counts and distances
    edge_frequencies = edge_counts / num_samples
    average_edge_distances = edge_distances / num_samples
    
    # Heuristic values: combine frequency with inverse of distance and a penalty for average tour distance
    heuristics_matrix = edge_frequencies / (distance_matrix + 1e-9) / (average_edge_distances + 1)
    
    return heuristics_matrix
