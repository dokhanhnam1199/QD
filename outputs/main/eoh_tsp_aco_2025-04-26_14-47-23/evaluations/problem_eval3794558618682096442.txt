import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm simulates a population of agents constructing tours, probabilistically selecting edges based on their inverse distance and a dynamic attractiveness score derived from the relative frequency of edge usage in shorter tours observed during the simulation.}"""
    n = distance_matrix.shape[0]
    num_agents = 30
    num_iterations = 80
    attractiveness = np.ones_like(distance_matrix, dtype=float)
    edge_usage_counts = np.zeros_like(distance_matrix, dtype=int)
    shortest_tour_length = float('inf')
    shortest_tour = None

    for iteration in range(num_iterations):
        agent_tours = []
        agent_tour_lengths = []

        for agent in range(num_agents):
            current_node = np.random.randint(n)
            tour = [current_node]
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(current_node)

            while unvisited_nodes:
                probabilities = np.zeros(n)
                for neighbor in range(n):
                    if neighbor in unvisited_nodes:
                        probabilities[neighbor] = attractiveness[current_node, neighbor] / (distance_matrix[current_node, neighbor] + 1e-9)

                if np.sum(probabilities) == 0:
                    next_node = np.random.choice(list(unvisited_nodes))
                else:
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(range(n), p=probabilities)

                tour.append(next_node)
                unvisited_nodes.remove(next_node)
                current_node = next_node

            tour_length = 0
            for i in range(n - 1):
                tour_length += distance_matrix[tour[i], tour[i + 1]]
            tour_length += distance_matrix[tour[-1], tour[0]]

            agent_tours.append(tour)
            agent_tour_lengths.append(tour_length)

            if tour_length < shortest_tour_length:
                shortest_tour_length = tour_length
                shortest_tour = tour
        
        if shortest_tour is not None:
            for i in range(n - 1):
                u = shortest_tour[i]
                v = shortest_tour[i+1]
                edge_usage_counts[u, v] += 1
                edge_usage_counts[v, u] += 1
            edge_usage_counts[shortest_tour[-1], shortest_tour[0]] += 1
            edge_usage_counts[shortest_tour[0], shortest_tour[-1]] += 1
        
        #update attractiveness based on edge usage in best tours
        for i in range(n):
            for j in range(n):
                attractiveness[i,j] = 1 + edge_usage_counts[i,j]

    heuristics_matrix = attractiveness / (distance_matrix + 1e-9)
    return heuristics_matrix
