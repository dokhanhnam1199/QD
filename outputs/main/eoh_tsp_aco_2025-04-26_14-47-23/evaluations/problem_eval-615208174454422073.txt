import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a modified simulated annealing approach with adaptive temperature and edge weighting to refine a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1 / (distance_matrix + 1e-9)  # Initialize with inverse distance
    temperature = 1.0
    cooling_rate = 0.995
    num_iterations = 1000
    edge_weight_increment = 0.1
    edge_weight_decrement = 0.05

    for _ in range(num_iterations):
        # Randomly select two edges to swap
        i, j = np.random.choice(n, 2, replace=False)
        k, l = np.random.choice(n, 2, replace=False)

        # Calculate the change in tour length after swapping
        delta = (distance_matrix[i, k] + distance_matrix[j, l] -
                 distance_matrix[i, j] - distance_matrix[k, l])

        # Accept the swap if it improves the tour or with a probability based on temperature
        if delta < 0 or np.random.rand() < np.exp(-delta / temperature):
            # Update heuristics matrix to favor the new edges
            heuristics_matrix[i, k] += edge_weight_increment
            heuristics_matrix[k, i] += edge_weight_increment
            heuristics_matrix[j, l] += edge_weight_increment
            heuristics_matrix[l, j] += edge_weight_increment

            # Penalize the old edges
            heuristics_matrix[i, j] -= edge_weight_decrement
            heuristics_matrix[j, i] -= edge_weight_decrement
            heuristics_matrix[k, l] -= edge_weight_decrement
            heuristics_matrix[l, k] -= edge_weight_decrement

            # Adjust temperature based on delta (adaptive cooling)
            if delta < 0:
                temperature *= 1.01  # Increase temperature slightly for improvements
            else:
                temperature *= cooling_rate  # Normal cooling
        else:
            temperature *= cooling_rate

        # Cool the temperature
        temperature = min(temperature, 1.0) # Ensure temperature doesn't exceed initial value

    return heuristics_matrix
