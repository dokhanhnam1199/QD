import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a genetic algorithm approach to evolve a population of tours and extracts edge information from the best-performing tours to create a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    population_size = 100
    num_generations = 50
    mutation_rate = 0.01

    # Initialize population
    population = np.array([np.random.permutation(n) for _ in range(population_size)])

    def calculate_fitness(tour):
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i+1]]
        tour_length += distance_matrix[tour[n-1], tour[0]]
        return -tour_length  # Negative because we want to maximize fitness

    # Evolve population
    for _ in range(num_generations):
        # Evaluate fitness
        fitness_scores = np.array([calculate_fitness(tour) for tour in population])

        # Selection (roulette wheel selection)
        probabilities = fitness_scores - np.min(fitness_scores)
        probabilities = probabilities / np.sum(probabilities)
        indices = np.random.choice(population_size, size=population_size, replace=True, p=probabilities)
        selected_population = population[indices]

        # Crossover (order crossover)
        new_population = []
        for i in range(0, population_size, 2):
            parent1 = selected_population[i]
            parent2 = selected_population[(i + 1) % population_size]
            
            start, end = sorted(np.random.choice(n, size=2, replace=False))
            
            child1 = np.zeros(n, dtype=int)
            child1[start:end+1] = parent1[start:end+1]
            
            child2 = np.zeros(n, dtype=int)
            child2[start:end+1] = parent2[start:end+1]

            remaining1 = [node for node in parent2 if node not in child1]
            remaining2 = [node for node in parent1 if node not in child2]

            child1[:start] = remaining1[:start]
            child1[end+1:] = remaining1[start:]
            child2[:start] = remaining2[:start]
            child2[end+1:] = remaining2[start:]

            new_population.append(child1)
            new_population.append(child2)
        population = np.array(new_population)

        # Mutation (swap mutation)
        for i in range(population_size):
            if np.random.rand() < mutation_rate:
                idx1, idx2 = np.random.choice(n, size=2, replace=False)
                population[i][idx1], population[i][idx2] = population[i][idx2], population[i][idx1]

    # Get the best tour
    fitness_scores = np.array([calculate_fitness(tour) for tour in population])
    best_tour = population[np.argmax(fitness_scores)]

    # Count edge occurrences in the best tour
    edge_counts = np.zeros((n, n))
    for i in range(n - 1):
        edge_counts[best_tour[i], best_tour[i+1]] += 1
        edge_counts[best_tour[i+1], best_tour[i]] += 1
    edge_counts[best_tour[n-1], best_tour[0]] += 1
    edge_counts[best_tour[0], best_tour[n-1]] += 1

    # Normalize edge counts
    edge_frequencies = edge_counts / 1

    # Heuristic values
    heuristics_matrix = edge_frequencies / (distance_matrix + 1e-9)

    return heuristics_matrix
