import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines aspects of ant colony optimization and random sampling by using sampled tours to initialize pheromone levels, which are then iteratively updated and diffused to promote exploration of diverse, high-quality solutions.}"""
    n = distance_matrix.shape[0]
    pheromone_matrix = np.ones_like(distance_matrix, dtype=float)
    num_samples = 500
    sample_weight = 0.2
    rho = 0.1
    diffusion_rate = 0.05

    # Initial pheromone boost from random samples
    for _ in range(num_samples):
        tour = np.random.permutation(n)
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i + 1]]
        tour_length += distance_matrix[tour[-1], tour[0]]

        for i in range(n - 1):
            pheromone_matrix[tour[i], tour[i + 1]] += sample_weight / (tour_length * distance_matrix[tour[i], tour[i + 1]]+ 1e-9)
            pheromone_matrix[tour[i + 1], tour[i]] += sample_weight / (tour_length * distance_matrix[tour[i + 1], tour[i]]+ 1e-9)
        pheromone_matrix[tour[-1], tour[0]] += sample_weight / (tour_length * distance_matrix[tour[-1], tour[0]]+ 1e-9)
        pheromone_matrix[tour[0], tour[-1]] += sample_weight / (tour_length * distance_matrix[tour[0], tour[-1]]+ 1e-9)

    # Iterative pheromone update and diffusion
    num_iterations = 30
    for _ in range(num_iterations):
        # Evaporation
        pheromone_matrix *= (1 - rho)

        # Ant-like tour construction and pheromone deposit
        num_ants = 5
        for _ in range(num_ants):
            current_node = np.random.randint(n)
            tour = [current_node]
            unvisited_nodes = set(range(n))
            unvisited_nodes.remove(current_node)

            while unvisited_nodes:
                probabilities = np.zeros(n)
                for neighbor in range(n):
                    if neighbor in unvisited_nodes:
                        probabilities[neighbor] = pheromone_matrix[current_node, neighbor] / (distance_matrix[current_node, neighbor] + 1e-9)
                
                if np.sum(probabilities) == 0:
                    next_node = np.random.choice(list(unvisited_nodes))
                else:
                    probabilities /= np.sum(probabilities)
                    next_node = np.random.choice(range(n), p=probabilities)

                tour.append(next_node)
                unvisited_nodes.remove(next_node)
                current_node = next_node

            tour_length = 0
            for i in range(n - 1):
                tour_length += distance_matrix[tour[i], tour[i + 1]]
            tour_length += distance_matrix[tour[-1], tour[0]]

            Q = 10
            for i in range(n - 1):
                pheromone_matrix[tour[i], tour[i + 1]] += Q / tour_length
                pheromone_matrix[tour[i + 1], tour[i]] += Q / tour_length
            pheromone_matrix[tour[-1], tour[0]] += Q / tour_length
            pheromone_matrix[tour[0], tour[-1]] += Q / tour_length
            
        # Pheromone diffusion
        temp_pheromone_matrix = np.copy(pheromone_matrix)
        for i in range(n):
            for j in range(n):
                neighbors = []
                if i > 0: neighbors.append((i-1, j))
                if i < n-1: neighbors.append((i+1, j))
                if j > 0: neighbors.append((i, j-1))
                if j < n-1: neighbors.append((i, j+1))
                
                for ni, nj in neighbors:
                    temp_pheromone_matrix[i, j] += diffusion_rate * (pheromone_matrix[ni, nj] - pheromone_matrix[i, j])
        pheromone_matrix = temp_pheromone_matrix
    
    heuristics_matrix = pheromone_matrix / (distance_matrix + 1e-9)
    return heuristics_matrix
