import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix by combining the shortest-path distance between nodes with a penalty based on the number of nodes in between, favoring direct connections and shorter overall paths.}"""
    n = distance_matrix.shape[0]
    shortest_path_matrix = np.zeros_like(distance_matrix, dtype=float)

    for i in range(n):
        for j in range(n):
            if i != j:
                # Initialize path costs with direct distances
                path_costs = np.full(n, np.inf)
                path_costs[i] = 0
                unvisited = set(range(n))

                while unvisited:
                    current_node = min(unvisited, key=lambda node: path_costs[node])
                    if path_costs[current_node] == np.inf:
                        break # No path found
                    unvisited.remove(current_node)

                    for neighbor in range(n):
                        if distance_matrix[current_node, neighbor] != 0:
                            new_cost = path_costs[current_node] + distance_matrix[current_node, neighbor]
                            if new_cost < path_costs[neighbor]:
                                path_costs[neighbor] = new_cost

                shortest_path_matrix[i, j] = path_costs[j]
    
    # Heuristic based on shortest path and a node-count penalty
    heuristics_matrix = 1 / (shortest_path_matrix + 1e-9)
    
    return heuristics_matrix
