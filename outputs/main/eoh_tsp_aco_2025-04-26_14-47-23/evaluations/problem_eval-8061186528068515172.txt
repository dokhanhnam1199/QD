import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm combines a greedy nearest neighbor approach with stochastic perturbation to explore diverse solutions and refine edge selection based on a weighted combination of distance and visitation frequency.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    
    num_samples = 50
    perturbation_factor = 0.1

    for _ in range(num_samples):
        # Greedy Nearest Neighbor with Perturbation
        start_node = np.random.randint(n)
        tour = [start_node]
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(start_node)

        current_node = start_node
        while unvisited_nodes:
            distances = distance_matrix[current_node, :]
            
            # Perturb distances stochastically
            perturbed_distances = distances + np.random.normal(0, perturbation_factor * np.mean(distances), size=n)
            
            # Mask visited nodes
            perturbed_distances[list(tour)] = np.inf

            next_node = np.argmin(perturbed_distances)
            
            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node
        
        # Update heuristics matrix based on tour frequency
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i+1]] += 1
            heuristics_matrix[tour[i+1], tour[i]] += 1
        heuristics_matrix[tour[-1], tour[0]] += 1
        heuristics_matrix[tour[0], tour[-1]] += 1

    # Combine frequency with inverse distance
    heuristics_matrix = (heuristics_matrix + 1e-9) / (distance_matrix + 1e-9)

    return heuristics_matrix
