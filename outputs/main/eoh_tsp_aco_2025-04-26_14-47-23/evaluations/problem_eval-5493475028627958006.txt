import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines a probability matrix for edge selection based on a combination of edge distance and reinforcement learning principles, favoring shorter edges and those frequently included in high-quality sampled tours.}"""
    n = distance_matrix.shape[0]
    probability_matrix = np.ones_like(distance_matrix, dtype=float) / n
    learning_rate = 0.1
    num_samples = 50
    sample_size = n // 2
    
    for _ in range(100):
        sampled_tours = []
        for _ in range(num_samples):
            edges = np.random.choice(n * n, size=sample_size, replace=False, p=probability_matrix.flatten())
            tour_edges = []
            for edge_index in edges:
                i = edge_index // n
                j = edge_index % n
                if i != j:
                    tour_edges.append((i, j))

            sampled_tours.append(tour_edges)
        
        for tour_edges in sampled_tours:
            tour_length = 0
            nodes_visited = set()
            for i, j in tour_edges:
                tour_length += distance_matrix[i, j]
                nodes_visited.add(i)
                nodes_visited.add(j)

            if len(nodes_visited) < n :
                reward = 0
            else:
                reward = 1/ (tour_length + 1e-9)
                
            for i, j in tour_edges:
                probability_matrix[i, j] += learning_rate * (reward - probability_matrix[i, j])
                probability_matrix[j, i] += learning_rate * (reward - probability_matrix[j, i])

        probability_matrix = np.clip(probability_matrix, 0.01, 1)
        probability_matrix /= np.sum(probability_matrix) / (n*n)

    heuristics_matrix = probability_matrix / (distance_matrix + 1e-9)
    return heuristics_matrix
