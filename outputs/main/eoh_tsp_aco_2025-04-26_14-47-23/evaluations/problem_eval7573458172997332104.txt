import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a simulated annealing approach to refine a heuristic matrix based on edge improvements in neighboring tours.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = 1 / (distance_matrix + 1e-9)  # Initialize with inverse distance
    temperature = 1.0
    cooling_rate = 0.995
    num_iterations = 1000

    for _ in range(num_iterations):
        # Randomly select two edges to swap
        i, j = np.random.choice(n, 2, replace=False)
        k, l = np.random.choice(n, 2, replace=False)

        # Calculate the change in tour length after swapping
        delta = (distance_matrix[i, k] + distance_matrix[j, l] -
                 distance_matrix[i, j] - distance_matrix[k, l])

        # Accept the swap if it improves the tour or with a probability based on temperature
        if delta < 0 or np.random.rand() < np.exp(-delta / temperature):
            # Update heuristics matrix to favor the new edges
            heuristics_matrix[i, k] += 0.1
            heuristics_matrix[k, i] += 0.1
            heuristics_matrix[j, l] += 0.1
            heuristics_matrix[l, j] += 0.1

            # Penalize the old edges
            heuristics_matrix[i, j] -= 0.1
            heuristics_matrix[j, i] -= 0.1
            heuristics_matrix[k, l] -= 0.1
            heuristics_matrix[l, k] -= 0.1

        # Cool the temperature
        temperature *= cooling_rate

    return heuristics_matrix
