import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a combination of shortest path information and edge desirability learned from multiple simulated annealing runs to construct a heuristic matrix, prioritizing edges that appear frequently in good solutions and connect nodes with short paths.}"""
    n = distance_matrix.shape[0]
    
    # Shortest path matrix (using Dijkstra's)
    shortest_path_matrix = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                dist = np.inf * np.ones(n)
                dist[i] = 0
                visited = np.zeros(n, dtype=bool)
                for _ in range(n):
                    u = np.argmin(dist + visited * np.inf)
                    visited[u] = True
                    for v in range(n):
                        if not visited[v] and distance_matrix[u, v] != 0:
                            dist[v] = min(dist[v], dist[u] + distance_matrix[u, v])
                shortest_path_matrix[i, j] = dist[j]
    
    # Simulated Annealing to estimate edge frequencies
    num_samples = 50
    temperature = 100
    cooling_rate = 0.95
    edge_counts = np.zeros_like(distance_matrix, dtype=float)
    
    for _ in range(num_samples):
        # Initial solution: random permutation
        current_solution = np.random.permutation(n)
        current_cost = 0
        for i in range(n):
            current_cost += distance_matrix[current_solution[i], current_solution[(i + 1) % n]]
        
        for _ in range(100):  # Inner SA loop
            # Propose a swap
            i, j = np.random.choice(n, 2, replace=False)
            new_solution = current_solution.copy()
            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]
            
            # Calculate new cost
            new_cost = 0
            for k in range(n):
                new_cost += distance_matrix[new_solution[k], new_solution[(k + 1) % n]]
            
            # Accept or reject
            if new_cost < current_cost or np.random.rand() < np.exp((current_cost - new_cost) / temperature):
                current_solution = new_solution
                current_cost = new_cost
            
            temperature *= cooling_rate
        
        # Update edge counts for the best solution found in this run
        for i in range(n):
            node1 = current_solution[i]
            node2 = current_solution[(i + 1) % n]
            edge_counts[node1, node2] += 1
            edge_counts[node2, node1] += 1
    
    edge_frequencies = edge_counts / num_samples

    # Combine shortest path and edge frequency information
    heuristics_matrix = edge_frequencies / (shortest_path_matrix + 1e-9)
    
    return heuristics_matrix
