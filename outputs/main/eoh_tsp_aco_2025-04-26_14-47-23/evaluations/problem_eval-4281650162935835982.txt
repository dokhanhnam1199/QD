import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines edge desirability scores based on short cycles found through a biased random walk, favoring edges with higher desirability in cycle construction.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix, dtype=float)
    num_iterations = 100

    for _ in range(num_iterations):
        start_node = np.random.randint(n)
        current_node = start_node
        path = [start_node]
        visited = {start_node}
        
        for _ in range(n - 1):
            # Probabilistically choose the next node based on heuristics_matrix
            probabilities = heuristics_matrix[current_node, :]
            probabilities[list(visited)] = 0  # Avoid already visited nodes
            probabilities /= np.sum(probabilities)

            if np.isnan(probabilities).any():
                # Handle the case where all probabilities are zero (e.g., only visited nodes left)
                unvisited = [i for i in range(n) if i not in visited]
                if unvisited:
                     next_node = np.random.choice(unvisited)
                else:
                    next_node = start_node
            else:
                next_node = np.random.choice(n, p=probabilities)

            path.append(next_node)
            visited.add(next_node)
            current_node = next_node

        path.append(start_node) #complete the cycle.

        #Update heuristics based on the cycle found.  Favor edges in short cycles.
        cycle_length = len(path)
        for i in range(cycle_length -1):
            node1 = path[i]
            node2 = path[i+1]
            heuristics_matrix[node1, node2] *= 1.1 #Boost edge desirability.
            heuristics_matrix[node2, node1] *= 1.1 #Symmetric
            
            #Normalize.
            heuristics_matrix /= np.mean(heuristics_matrix) #prevent scores exploding.

    return heuristics_matrix
