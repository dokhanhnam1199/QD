import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm constructs a heuristic matrix based on edge usage in iteratively refined tours starting from a greedy nearest neighbor solution.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Greedy Nearest Neighbor Initial Tour
    current_node = 0
    unvisited_nodes = set(range(1, n))
    tour = [0]

    while unvisited_nodes:
        nearest_node = min(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])
        tour.append(nearest_node)
        unvisited_nodes.remove(nearest_node)
        current_node = nearest_node
    tour.append(0)  # Return to starting node

    # 2. Iterative Improvement & Edge Counting
    num_iterations = 100
    for _ in range(num_iterations):
        # a. 2-opt swap
        best_tour = tour[:]
        best_tour_length = calculate_tour_length(distance_matrix, tour)
        for i in range(1, n):
            for j in range(i + 1, n):
                new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
                new_tour_length = calculate_tour_length(distance_matrix, new_tour)
                if new_tour_length < best_tour_length:
                    best_tour = new_tour[:]
                    best_tour_length = new_tour_length

        tour = best_tour[:]

        # b. Update heuristics based on edge usage
        for i in range(n):
            u, v = tour[i], tour[(i + 1) % n]
            heuristics_matrix[u, v] += 1
            heuristics_matrix[v, u] += 1

    # 3. Normalize heuristics matrix
    heuristics_matrix = heuristics_matrix / num_iterations

    return heuristics_matrix

def calculate_tour_length(distance_matrix, tour):
    tour_length = 0
    for i in range(len(tour) - 1):
        tour_length += distance_matrix[tour[i], tour[i+1]]
    return heuristics_matrix
