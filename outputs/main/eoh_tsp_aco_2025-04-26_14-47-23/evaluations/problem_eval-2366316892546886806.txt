import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm estimates edge probabilities by sampling random tours and counting edge occurrences in the shortest tours, then combines this with inverse distance information to generate a heuristic matrix.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    tour_lengths = np.zeros(num_samples)
    tours = np.zeros((num_samples, n), dtype=int)

    for i in range(num_samples):
        tour = np.random.permutation(n)
        tours[i, :] = tour
        tour_length = 0
        for j in range(n - 1):
            tour_length += distance_matrix[tour[j], tour[j+1]]
        tour_length += distance_matrix[tour[n-1], tour[0]]
        tour_lengths[i] = tour_length

    # Select top 10% shortest tours
    cutoff = np.percentile(tour_lengths, 10)
    best_tours = tours[tour_lengths <= cutoff]

    # Count edge occurrences in best tours
    edge_counts = np.zeros((n, n))
    for tour in best_tours:
        for j in range(n - 1):
            edge_counts[tour[j], tour[j+1]] += 1
            edge_counts[tour[j+1], tour[j]] += 1  # Account for undirected edges
        edge_counts[tour[n-1], tour[0]] += 1
        edge_counts[tour[0], tour[n-1]] += 1

    # Normalize edge counts to get probabilities
    edge_probabilities = edge_counts / len(best_tours)

    # Combine probabilities with inverse distance
    heuristics_matrix = edge_probabilities / (distance_matrix + 1e-9)  # Avoid division by zero

    return heuristics_matrix
