import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm uses a nearest neighbor approach with stochasticity and iterative improvement based on 2-opt swaps, incorporating a temperature parameter to control the acceptance of worse solutions.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    num_iterations = 100
    temperature = 1.0
    cooling_rate = 0.99

    for _ in range(num_iterations):
        # Initialize tour with a random starting node
        current_node = np.random.randint(n)
        tour = [current_node]
        unvisited_nodes = set(range(n))
        unvisited_nodes.remove(current_node)

        # Nearest neighbor tour construction with stochasticity
        while unvisited_nodes:
            probabilities = np.zeros(n)
            for neighbor in range(n):
                if neighbor in unvisited_nodes:
                    probabilities[neighbor] = 1 / (distance_matrix[current_node, neighbor] + 1e-9)
            
            if np.sum(probabilities) == 0:
                next_node = np.random.choice(list(unvisited_nodes))
            else:
                probabilities /= np.sum(probabilities)
                next_node = np.random.choice(range(n), p=probabilities)

            tour.append(next_node)
            unvisited_nodes.remove(next_node)
            current_node = next_node

        # Calculate initial tour length
        tour_length = 0
        for i in range(n - 1):
            tour_length += distance_matrix[tour[i], tour[i + 1]]
        tour_length += distance_matrix[tour[-1], tour[0]]

        # 2-opt swap improvement with simulated annealing
        for _ in range(n * 10):
            i = np.random.randint(1, n - 1)
            j = np.random.randint(i + 1, n)

            new_tour = tour[:i] + tour[i:j+1][::-1] + tour[j+1:]
            new_tour_length = 0
            for k in range(n - 1):
                new_tour_length += distance_matrix[new_tour[k], new_tour[k + 1]]
            new_tour_length += distance_matrix[new_tour[-1], new_tour[0]]

            if new_tour_length < tour_length:
                tour = new_tour
                tour_length = new_tour_length
            else:
                # Simulated annealing acceptance criterion
                delta = new_tour_length - tour_length
                if np.random.rand() < np.exp(-delta / temperature):
                    tour = new_tour
                    tour_length = new_tour_length

        # Update heuristics matrix based on the final tour
        for i in range(n - 1):
            heuristics_matrix[tour[i], tour[i + 1]] += 1
            heuristics_matrix[tour[i + 1], tour[i]] += 1
        heuristics_matrix[tour[-1], tour[0]] += 1
        heuristics_matrix[tour[0], tour[-1]] += 1

        temperature *= cooling_rate

    return heuristics_matrix
