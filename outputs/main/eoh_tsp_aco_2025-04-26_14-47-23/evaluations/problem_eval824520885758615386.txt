import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm samples random tours, calculates the total distance of each tour, and then assigns higher probabilities to edges that appear frequently in the shorter tours.}"""
    n = distance_matrix.shape[0]
    num_samples = 1000
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)
    tour_lengths = []
    tours = []

    for _ in range(num_samples):
        tour = np.random.permutation(n)
        tour_distance = 0
        for i in range(n - 1):
            tour_distance += distance_matrix[tour[i], tour[i+1]]
        tour_distance += distance_matrix[tour[-1], tour[0]]

        tour_lengths.append(tour_distance)
        tours.append(tour)

    # Normalize tour lengths to probabilities (shorter tours = higher probability)
    tour_probabilities = np.exp(-np.array(tour_lengths) / np.std(tour_lengths)) #Softmax / Boltzmann selection strategy.
    tour_probabilities /= np.sum(tour_probabilities)

    for i in range(num_samples):
        tour = tours[i]
        probability = tour_probabilities[i]
        for j in range(n - 1):
            heuristics_matrix[tour[j], tour[j+1]] += probability
            heuristics_matrix[tour[j+1], tour[j]] += probability # Since TSP is undirected

        heuristics_matrix[tour[-1], tour[0]] += probability
        heuristics_matrix[tour[0], tour[-1]] += probability # Since TSP is undirected
    return heuristics_matrix
