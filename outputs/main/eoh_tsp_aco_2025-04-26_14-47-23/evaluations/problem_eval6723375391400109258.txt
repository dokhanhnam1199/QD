import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm iteratively refines edge importance scores by sampling tours biased towards edges with higher scores and updating the scores based on the sampled tour's quality.}"""
    n = distance_matrix.shape[0]
    heuristics_matrix = np.ones_like(distance_matrix)
    num_iterations = 100
    num_samples = 10
    alpha = 0.1

    for _ in range(num_iterations):
        edge_usage = np.zeros_like(distance_matrix)
        tour_lengths = []

        for _ in range(num_samples):
            # Sample a tour based on heuristics_matrix
            probabilities = heuristics_matrix.flatten()
            probabilities /= np.sum(probabilities)
            
            tour = []
            unvisited = list(range(n))
            start_node = np.random.choice(unvisited)
            tour.append(start_node)
            unvisited.remove(start_node)
            
            current_node = start_node
            while unvisited:
                weights = heuristics_matrix[current_node, :]
                weights[current_node] = 0
                
                possible_next_nodes = np.array(unvisited)
                
                weights_masked = weights[possible_next_nodes]
                weights_masked[weights_masked < 0] = 0
                
                if np.sum(weights_masked) > 0:
                    weights_masked = weights_masked/np.sum(weights_masked)
                    next_node = np.random.choice(possible_next_nodes, p=weights_masked)
                else:
                    next_node = np.random.choice(unvisited)
                    
                tour.append(next_node)
                unvisited.remove(next_node)
                current_node = next_node
            
            tour.append(start_node)

            # Calculate tour length
            tour_length = 0
            for i in range(n):
                tour_length += distance_matrix[tour[i], tour[(i + 1) % n]]
            tour_lengths.append(tour_length)

            # Update edge usage
            for i in range(n):
                u = tour[i]
                v = tour[(i + 1) % n]
                edge_usage[u, v] += 1
                edge_usage[v, u] += 1

        # Normalize edge usage
        edge_usage /= num_samples
        
        #Update heuristics based on tour quality. Good tours increase edge weights, bad tours decrease them.
        best_tour_length = np.min(tour_lengths)
        
        for i in range(n):
            for j in range(i+1,n):
                if distance_matrix[i,j] > 0:
                    heuristics_matrix[i, j] = (1-alpha)*heuristics_matrix[i,j] + alpha * (edge_usage[i,j] * (best_tour_length/np.mean(tour_lengths)))
                    heuristics_matrix[j, i] = heuristics_matrix[i, j]

    return heuristics_matrix
