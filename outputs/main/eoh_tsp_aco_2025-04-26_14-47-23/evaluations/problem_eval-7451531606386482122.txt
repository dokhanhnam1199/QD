import numpy as np

def heuristics_v2(distance_matrix):
    """{This algorithm computes edge importance by averaging shortest path counts between all node pairs, giving preference to edges frequently used in short paths.}"""
    n = distance_matrix.shape[0]
    shortest_path_counts = np.zeros_like(distance_matrix, dtype=float)

    for start_node in range(n):
        distances = np.full(n, np.inf)
        distances[start_node] = 0
        visited = np.zeros(n, dtype=bool)
        predecessors = {}

        for _ in range(n):
            min_dist = np.inf
            min_node = -1
            for node in range(n):
                if not visited[node] and distances[node] < min_dist:
                    min_dist = distances[node]
                    min_node = node

            if min_node == -1:
                break

            visited[min_node] = True

            for neighbor in range(n):
                if distance_matrix[min_node, neighbor] > 0:
                    new_dist = distances[min_node] + distance_matrix[min_node, neighbor]
                    if new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        predecessors[neighbor] = min_node
                    elif new_dist == distances[neighbor]:
                      if neighbor in predecessors:
                        if not isinstance(predecessors[neighbor], list):
                            predecessors[neighbor]=[predecessors[neighbor]]
                        predecessors[neighbor].append(min_node)
                      else:
                        predecessors[neighbor] = min_node

        def count_paths(node):
          if start_node == node:
            return 1

          if node not in predecessors:
              return 0

          count = 0
          if isinstance(predecessors[node], list):
              for pred in predecessors[node]:
                  count += count_paths(pred)
          else:
              count = count_paths(predecessors[node])
          return count

        def update_counts(node):
            if start_node == node:
                return
            
            if node not in predecessors:
                return

            path_count = count_paths(node)
            
            if isinstance(predecessors[node], list):
              num_preds = len(predecessors[node])
              for pred in predecessors[node]:
                  shortest_path_counts[pred, node] += path_count / num_preds
                  shortest_path_counts[node, pred] += path_count / num_preds
                  update_counts(pred)
            else:
                pred = predecessors[node]
                shortest_path_counts[pred, node] += path_count
                shortest_path_counts[node, pred] += path_count
                update_counts(pred)
        
        update_counts(range(n)[start_node:][0])
        for end_node in range(n):
            update_counts(end_node)
    
    heuristics_matrix = shortest_path_counts / (distance_matrix + 1e-9)
    return heuristics_matrix
