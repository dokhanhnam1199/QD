[
     {
          "algorithm": "This algorithm uses a combination of nearest neighbor and random sampling to generate multiple TSP solutions, then averages the edge usage frequency across these solutions to estimate edge importance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm uses a combination of nearest neighbor and random sampling to generate multiple TSP solutions, then averages the edge usage frequency across these solutions to estimate edge importance.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        path = [start_node]\n\n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = float('inf')\n\n            # Nearest Neighbor selection\n            for neighbor in unvisited_nodes:\n                distance = distance_matrix[current_node, neighbor]\n                if distance < min_distance:\n                    min_distance = distance\n                    nearest_neighbor = neighbor\n                    \n            #Introduce randomness: Either choose nearest neighbor or randomly sample\n            if np.random.rand() < 0.7:  #70% chance of selecting nearest neighbor.\n                next_node = nearest_neighbor\n            else:\n                next_node = np.random.choice(list(unvisited_nodes)) #Random Selection\n\n            path.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        path.append(start_node)  # Return to starting node\n\n        # Update heuristics matrix based on edge usage\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.06177,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples a set of near-optimal TSP solutions using a nearest-neighbor heuristic with stochastic restarts and uses edge frequencies across samples as an indicator of edge desirability.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples a set of near-optimal TSP solutions using a nearest-neighbor heuristic with stochastic restarts and uses edge frequencies across samples as an indicator of edge desirability.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(start_node)\n        path = [start_node]\n        \n        while unvisited_nodes:\n            nearest_neighbor = None\n            min_distance = np.inf\n            for neighbor in unvisited_nodes:\n                dist = distance_matrix[current_node, neighbor]\n                if dist < min_distance:\n                    min_distance = dist\n                    nearest_neighbor = neighbor\n            \n            path.append(nearest_neighbor)\n            unvisited_nodes.remove(nearest_neighbor)\n            current_node = nearest_neighbor\n        \n        path.append(start_node)\n\n        for i in range(n):\n            node1 = path[i]\n            node2 = path[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    heuristics_matrix /= num_samples\n    return heuristics_matrix",
          "objective": 6.13657,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm constructs a heuristics matrix by combining inverse distance with shortest-path-based proximity measures derived from random sampling of near-optimal tours.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm constructs a heuristics matrix by combining inverse distance with shortest-path-based proximity measures derived from random sampling of near-optimal tours.}\"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    \n    # Inverse distance heuristic\n    heuristics_matrix = 1 / (distance_matrix + 1e-9)\n\n    # Sample tours and update heuristics\n    num_samples = 100\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n        \n        while unvisited_nodes:\n            distances = distance_matrix[current_node, list(unvisited_nodes)]\n            probabilities = np.exp(-distances)  # Use inverse distance as probability\n            probabilities /= np.sum(probabilities)\n            \n            next_node = np.random.choice(list(unvisited_nodes), p=probabilities)\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n        \n        tour.append(start_node) # Return to start\n        \n        tour_distance = 0.0\n        for i in range(len(tour) - 1):\n            tour_distance += distance_matrix[tour[i], tour[i+1]]\n\n        # Update heuristics based on tour quality (use inverse distance for now)\n        for i in range(len(tour) - 1):\n            u, v = tour[i], tour[i+1]\n            heuristics_matrix[u, v] += 1.0 / tour_distance\n            heuristics_matrix[v, u] += 1.0 / tour_distance\n    \n    return heuristics_matrix",
          "objective": 6.54022,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples random tours, and updates a heuristic matrix based on the frequency each edge appears in short tours relative to its distance.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm iteratively samples random tours, and updates a heuristic matrix based on the frequency each edge appears in short tours relative to its distance.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n    num_samples = 1000\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour_distance = 0\n        for i in range(n - 1):\n            tour_distance += distance_matrix[tour[i], tour[i + 1]]\n        tour_distance += distance_matrix[tour[-1], tour[0]]\n\n        # Update heuristics matrix\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i + 1]] += 1 / (tour_distance * distance_matrix[tour[i], tour[i + 1]])\n            heuristics_matrix[tour[i + 1], tour[i]] += 1 / (tour_distance * distance_matrix[tour[i + 1], tour[i]])\n        heuristics_matrix[tour[-1], tour[0]] += 1 / (tour_distance * distance_matrix[tour[-1], tour[0]])\n        heuristics_matrix[tour[0], tour[-1]] += 1 / (tour_distance * distance_matrix[tour[0], tour[-1]])\n\n    return heuristics_matrix",
          "objective": 6.68653,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random tours, computes the frequency of each edge appearing in the sampled tours, and then combines this frequency with a measure of edge desirability based on distance to produce a matrix of heuristic values indicating the likelihood of an edge being in the optimal tour.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple random tours, computes the frequency of each edge appearing in the sampled tours, and then combines this frequency with a measure of edge desirability based on distance to produce a matrix of heuristic values indicating the likelihood of an edge being in the optimal tour.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    edge_counts = np.zeros_like(distance_matrix, dtype=float)\n    \n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        \n        # Count edges in the tour\n        for i in range(n):\n            u = tour[i]\n            v = tour[(i + 1) % n]\n            edge_counts[u, v] += 1\n            edge_counts[v, u] += 1\n    \n    # Normalize edge counts\n    edge_frequencies = edge_counts / num_samples\n    \n    # Heuristic values: combine frequency with inverse of distance\n    heuristics_matrix = edge_frequencies / (distance_matrix + 1e-9)  # Avoid division by zero\n    \n    return heuristics_matrix",
          "objective": 6.764,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm iteratively samples random tours, keeps track of edge frequencies, and combines edge frequencies with inverse distance to guide the search towards promising edges.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm iteratively samples random tours, keeps track of edge frequencies, and combines edge frequencies with inverse distance to guide the search towards promising edges.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    edge_counts = np.zeros_like(distance_matrix)\n    \n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        \n        # Update edge counts\n        for i in range(n - 1):\n            edge_counts[tour[i], tour[i+1]] += 1\n            edge_counts[tour[i+1], tour[i]] += 1  # Since the graph is undirected\n        edge_counts[tour[-1], tour[0]] += 1\n        edge_counts[tour[0], tour[-1]] += 1\n    \n    # Combine edge counts with inverse distance\n    heuristics_matrix = (edge_counts / num_samples) / (distance_matrix + 1e-9) # Add a small value to avoid division by zero\n\n    return heuristics_matrix",
          "objective": 6.82341,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm estimates edge probabilities by sampling random tours and counting edge occurrences in the shortest tours, then combines this with inverse distance information to generate a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm estimates edge probabilities by sampling random tours and counting edge occurrences in the shortest tours, then combines this with inverse distance information to generate a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    tour_lengths = np.zeros(num_samples)\n    tours = np.zeros((num_samples, n), dtype=int)\n\n    for i in range(num_samples):\n        tour = np.random.permutation(n)\n        tours[i, :] = tour\n        tour_length = 0\n        for j in range(n - 1):\n            tour_length += distance_matrix[tour[j], tour[j+1]]\n        tour_length += distance_matrix[tour[n-1], tour[0]]\n        tour_lengths[i] = tour_length\n\n    # Select top 10% shortest tours\n    cutoff = np.percentile(tour_lengths, 10)\n    best_tours = tours[tour_lengths <= cutoff]\n\n    # Count edge occurrences in best tours\n    edge_counts = np.zeros((n, n))\n    for tour in best_tours:\n        for j in range(n - 1):\n            edge_counts[tour[j], tour[j+1]] += 1\n            edge_counts[tour[j+1], tour[j]] += 1  # Account for undirected edges\n        edge_counts[tour[n-1], tour[0]] += 1\n        edge_counts[tour[0], tour[n-1]] += 1\n\n    # Normalize edge counts to get probabilities\n    edge_probabilities = edge_counts / len(best_tours)\n\n    # Combine probabilities with inverse distance\n    heuristics_matrix = edge_probabilities / (distance_matrix + 1e-9)  # Avoid division by zero\n\n    return heuristics_matrix",
          "objective": 7.00329,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple near-optimal TSP solutions using a nearest-neighbor heuristic with stochastic restarts and combines the edge frequencies to generate a heuristic matrix.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"{This algorithm samples multiple near-optimal TSP solutions using a nearest-neighbor heuristic with stochastic restarts and combines the edge frequencies to generate a heuristic matrix.}\"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 100\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        start_node = np.random.randint(n)\n        current_node = start_node\n        unvisited_nodes = set(range(n))\n        unvisited_nodes.remove(current_node)\n        tour = [current_node]\n\n        while unvisited_nodes:\n            nearest_neighbors = []\n            for neighbor in unvisited_nodes:\n                nearest_neighbors.append((neighbor, distance_matrix[current_node, neighbor]))\n            \n            nearest_neighbors.sort(key=lambda x: x[1])\n            \n            # Stochasticity: Select from top k nearest neighbors\n            k = min(5, len(nearest_neighbors))\n            selected_neighbor_index = np.random.randint(k)\n            next_node = nearest_neighbors[selected_neighbor_index][0]\n\n            tour.append(next_node)\n            unvisited_nodes.remove(next_node)\n            current_node = next_node\n\n        tour.append(start_node)  # Return to starting node\n\n        # Update heuristics matrix based on edges in the tour\n        for i in range(n):\n            node1 = tour[i]\n            node2 = tour[i+1]\n            heuristics_matrix[node1, node2] += 1\n            heuristics_matrix[node2, node1] += 1\n\n    # Normalize the heuristics matrix\n    heuristics_matrix = heuristics_matrix / num_samples\n    return heuristics_matrix",
          "objective": 7.89924,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a stochastic sampling approach, where it generates multiple random tours, calculates their lengths, and uses the frequency with which each edge appears in the shortest tours as a heuristic indicator.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm uses a stochastic sampling approach, where it generates multiple random tours, calculates their lengths, and uses the frequency with which each edge appears in the shortest tours as a heuristic indicator.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    tour_lengths = []\n    tours = []\n    for _ in range(num_samples):\n        tour = np.random.permutation(n)\n        tour_length = 0\n        for i in range(n - 1):\n            tour_length += distance_matrix[tour[i], tour[i + 1]]\n        tour_length += distance_matrix[tour[-1], tour[0]]\n        tour_lengths.append(tour_length)\n        tours.append(tour)\n\n    # Select the top 10% shortest tours\n    cutoff = np.percentile(tour_lengths, 10)\n    selected_tours = [tours[i] for i in range(num_samples) if tour_lengths[i] <= cutoff]\n\n    # Initialize the heuristics matrix\n    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Count the frequency of each edge in the selected tours\n    for tour in selected_tours:\n        for i in range(n - 1):\n            heuristics_matrix[tour[i], tour[i + 1]] += 1\n            heuristics_matrix[tour[i + 1], tour[i]] += 1\n        heuristics_matrix[tour[-1], tour[0]] += 1\n        heuristics_matrix[tour[0], tour[-1]] += 1\n\n    # Normalize the frequencies\n    heuristics_matrix = heuristics_matrix / len(selected_tours)\n\n    return heuristics_matrix",
          "objective": 14.27969,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm samples multiple random tours, scores each edge based on its frequency in short tours, and returns a matrix indicating edge desirability.",
          "code": "import numpy as np\n\ndef heuristics_v2(distance_matrix):\n    \"\"\"\n    {This algorithm samples multiple random tours, scores each edge based on its frequency in short tours, and returns a matrix indicating edge desirability.}\n    \"\"\"\n    n = distance_matrix.shape[0]\n    num_samples = 1000\n    top_k = 100 \n\n    edge_counts = np.zeros_like(distance_matrix, dtype=float)\n\n    for _ in range(num_samples):\n        # Generate a random tour\n        tour = np.random.permutation(n)\n        tour_distance = 0\n        for i in range(n - 1):\n            tour_distance += distance_matrix[tour[i], tour[i+1]]\n        tour_distance += distance_matrix[tour[-1], tour[0]]\n\n        # Store the tour and its distance\n        if _ == 0:\n            tours = [(tour, tour_distance)]\n        else:\n            tours.append((tour, tour_distance))\n        \n    # Select the top k tours\n    tours = sorted(tours, key=lambda x: x[1])[:top_k]\n        \n    # Update edge counts based on the top k tours\n    for tour, _ in tours:\n        for i in range(n - 1):\n            edge_counts[tour[i], tour[i+1]] += 1\n            edge_counts[tour[i+1], tour[i]] += 1 # Symmetric\n        edge_counts[tour[-1], tour[0]] += 1\n        edge_counts[tour[0], tour[-1]] += 1 # Symmetric\n            \n    # Normalize edge counts to get heuristics matrix\n    heuristics_matrix = edge_counts / top_k\n    \n    return heuristics_matrix",
          "objective": 14.39999,
          "other_inf": null
     }
]