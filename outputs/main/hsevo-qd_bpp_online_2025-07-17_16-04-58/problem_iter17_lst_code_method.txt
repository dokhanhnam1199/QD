{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)  # Initialize with -inf for infeasible bins\n\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # All bins are infeasible\n\n    priorities[feasible_bins] = 0.0  # Reset feasible bins to a base priority of 0\n\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n\n    # Define an ideal remaining capacity.  This is a crucial parameter.\n    # Let's start with aiming for a small, non-zero ideal.\n    ideal_remaining_capacity = 0.1 # was 0.2\n\n    # Calculate the deviation from the ideal remaining capacity.  Smaller is better.\n    deviation = np.abs(remaining_capacity_after_placement - ideal_remaining_capacity)\n\n    # Use the inverse of the deviation as the priority.\n    priorities[feasible_bins] = 1.0 / (deviation + 0.00001)  # Avoid division by zero\n\n    # Add a bonus for bins that would be nearly full after placement.\n    almost_full_threshold = 0.05  # Reduce it to 5%\n    almost_full_bins = (remaining_capacity_after_placement <= almost_full_threshold)\n    priorities[feasible_bins][almost_full_bins] += 5.0 # was 5.0\n\n    # Slightly penalize bins that have a very large remaining capacity. This discourages putting small\n    # items into almost empty bins. Avoids fragmentation.\n    large_capacity_threshold = 0.75\n    large_capacity_bins = bins_remain_cap[feasible_bins] > large_capacity_threshold\n    priorities[feasible_bins][large_capacity_bins] -= 1.0 # was 2.0\n\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility, waste, and item/bin ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space\n\n    # Item/bin ratio to encourage tighter fits\n    ratios = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] += 0.1 * ratios # Tunable weight\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines target capacity, fullness incentives, and fragmentation penalties.\n    Prioritizes bins that are feasible and close to ideal fullness.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = np.inf\n\n    # Target a remaining capacity.\n    target_capacity = 0.1\n    capacity_diff = np.abs(remaining_capacity_after_placement - target_capacity)\n\n    priorities[feasible_bins] = -capacity_diff[feasible_bins]\n\n    # Almost full bonus.\n    almost_full_threshold = 0.05\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 10.0\n\n    # Small capacity penalty.\n    small_capacity_threshold = 0.25\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 5.0\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)  # Initialize with -inf for infeasible bins\n\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # All bins are infeasible\n\n    priorities[feasible_bins] = 0.0  # Reset feasible bins to a base priority of 0\n\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n\n    # Define an ideal remaining capacity.  This is a crucial parameter.\n    # Let's start with aiming for a small, non-zero ideal.\n    ideal_remaining_capacity = 0.1 # was 0.2\n\n    # Calculate the deviation from the ideal remaining capacity.  Smaller is better.\n    deviation = np.abs(remaining_capacity_after_placement - ideal_remaining_capacity)\n\n    # Use the inverse of the deviation as the priority.\n    priorities[feasible_bins] = 1.0 / (deviation + 0.00001)  # Avoid division by zero\n\n    # Add a bonus for bins that would be nearly full after placement.\n    almost_full_threshold = 0.05  # Reduce it to 5%\n    almost_full_bins = (remaining_capacity_after_placement <= almost_full_threshold)\n    priorities[feasible_bins][almost_full_bins] += 5.0 # was 5.0\n\n    # Slightly penalize bins that have a very large remaining capacity. This discourages putting small\n    # items into almost empty bins. Avoids fragmentation.\n    large_capacity_threshold = 0.75\n    large_capacity_bins = bins_remain_cap[feasible_bins] > large_capacity_threshold\n    priorities[feasible_bins][large_capacity_bins] -= 1.0 # was 2.0\n\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill rate with remaining capacity & adds almost full incentive.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1\n\n    # Fill rate component\n    fill_rate = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = fill_rate\n\n    # Remaining capacity component, avoid division by zero\n    priorities[feasible_bins] += 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001)\n\n    # Almost full incentive\n    almost_full_threshold = 0.1\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 3.0\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility, waste, and item/bin ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space\n\n    # Item/bin ratio to encourage tighter fits\n    ratios = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] += 0.1 * ratios # Tunable weight\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1\n\n    # Objective 1: Fill bins as completely as possible\n    # Prioritize bins where the remaining capacity after placement is small.\n    fill_priority = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001)\n    priorities[feasible_bins] += fill_priority\n\n    # Objective 2: Avoid fragmentation (leaving small, unusable spaces)\n    # Penalize bins that would have very small remaining capacity after placement.\n    fragmentation_threshold = 0.15  # Tunable parameter:  Adjust based on item size distribution.\n    fragmented_bins = feasible_bins & (remaining_capacity_after_placement >= 0) & (remaining_capacity_after_placement < fragmentation_threshold)\n    priorities[fragmented_bins] -= 3.0 # Tunable parameter: Strength of penalty\n\n    # Objective 3: Balance load across bins\n    # Prefer bins that are relatively empty (but still feasible) to avoid concentrating items in a few bins.\n    # This can improve packing efficiency in the long run.\n    empty_bin_threshold = 0.7  # Tunable parameter: Define \"relatively empty\" (e.g., > 70% capacity remaining).\n    relatively_empty_bins = feasible_bins & (bins_remain_cap > empty_bin_threshold)\n    priorities[relatively_empty_bins] += 1.5  # Tunable parameter: Strength of preference for empty bins.\n\n    # Objective 4: Reward near perfect fits.\n\n    near_perfect_fit_threshold = 0.05 # Tunable parameter: defines a near perfect fit\n    near_perfect_bins = feasible_bins & (remaining_capacity_after_placement >=0) & (remaining_capacity_after_placement <= near_perfect_fit_threshold)\n    priorities[near_perfect_bins] += 7.0\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, division_epsilon: float = 3.251011962525543e-06,\n                almost_full_threshold: float = 0.07359594924881202, almost_full_boost: float = 4.551124234880866,\n                small_capacity_threshold: float = 0.19085413880719226, small_capacity_penalty: float = 4.089881296997733) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_epsilon: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold below which a bin is considered to have small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, division_epsilon: float = 3.251011962525543e-06,\n                almost_full_threshold: float = 0.07359594924881202, almost_full_boost: float = 4.551124234880866,\n                small_capacity_threshold: float = 0.19085413880719226, small_capacity_penalty: float = 4.089881296997733) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_epsilon: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold below which a bin is considered to have small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}