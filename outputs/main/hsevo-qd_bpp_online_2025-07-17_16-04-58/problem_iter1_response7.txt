```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the 'path integral' formulation: explore multiple possible futures.
    In this case, a superposition of different bin assignments, weighted by
    the "probability" of that assignment leading to a good overall packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    epsilon = 1e-9 # Prevent division by zero, very small number.

    # Heuristic 1: "First Fit Decreasing" adaptation: Favor bins that are already somewhat full, but can still accommodate the item
    space_utilization = (1 - bins_remain_cap / 1.0) # Assuming bins of size 1.0

    # Heuristic 2: Minimize wasted space, but penalize very tight fits to encourage efficient packing later.
    wasted_space = bins_remain_cap - item

    # Heuristic 3: "Level of Uncertainty". Small amount of randomness will ensure that we don't end up in local optima.
    uncertainty = np.random.rand(len(bins_remain_cap)) * 0.01

    # Create a 'potential energy' function that combines these heuristics
    potential_energy = - space_utilization + np.abs(wasted_space) + uncertainty

    # Convert the potential energy into a probability-like distribution
    # We take the exponential to map negative energies to [0, 1] range (probability).
    probabilities = np.exp(-potential_energy)

    # Zero out probabilities where the item doesn't fit
    probabilities[bins_remain_cap < item] = 0.0

    # Normalize to get probabilities (optional, but can help numerical stability).
    total_probability = np.sum(probabilities)
    if total_probability > 0:
        probabilities /= total_probability
    else: # if total probability is zero, assign a small equal probability to each of the bins that will fit item
        eligible_bins = bins_remain_cap >= item
        probabilities[eligible_bins] = 1.0 / np.sum(eligible_bins)

    return probabilities
```
