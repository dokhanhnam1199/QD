{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that have enough remaining capacity to fit the item,\n    favoring those with smaller remaining space (to avoid fragmentation).  Bins that cannot\n    fit the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item fits.\n    fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, assign a small priority to all bins, and favour the fullest.\n    if not np.any(fit_mask):\n      priorities = bins_remain_cap/ np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap, dtype=float)\n      return priorities\n\n    # Calculate remaining space after placing the item in suitable bins.\n    remaining_space = bins_remain_cap[fit_mask] - item\n\n    # Prioritize bins based on the inverse of remaining space to favor small remaining space\n    # After substraction from total, to encourage larger remaining space where fragmentation could be higher.\n    priorities[fit_mask] = 1.0 / (remaining_space + 1e-9) #Add a small value to avoid division by zero.\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that have enough space for the item,\n    and then among those, it prefers bins where the remaining space after\n    adding the item is relatively small, but not too small (to avoid\n    excessive fragmentation). It also introduces a small random element\n    to break ties and encourage exploration of different bin configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter out bins that don't have enough capacity.\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        #If no bins can fit the item, try to find the best fit by minimizing wasted space by creating a score based on remaining space\n        ratios = item / bins_remain_cap\n        priorities = 1 - ratios\n        return priorities\n\n    # Calculate remaining capacity after adding the item for valid bins.\n    remaining_capacity = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins where the remaining capacity is small, but not too small.\n    # The 'ideal' remaining capacity is a fraction of the original capacity,\n    # let's say between 0.1 and 0.3 of the original capacity (assuming bins have capacity 1).\n    ideal_remaining_range = (0.1, 0.3)\n    # create priority that peaks in ideal remaining range, penalizing if less than .1 and penalizing if greater than .3\n    normalized_remaining = np.clip(remaining_capacity,ideal_remaining_range[0],ideal_remaining_range[1])\n    normalized_remaining = (normalized_remaining-ideal_remaining_range[0])/(ideal_remaining_range[1]-ideal_remaining_range[0])\n\n    # Assign priority based on the normalized remaining capacity.  We invert\n    # because lower remaining cap = better, close to zero\n    priorities[valid_bins] = 1 - (remaining_capacity / bins_remain_cap[valid_bins]) # Use remaining space ration\n\n    # Adding a small randomness\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, heavily penalize bins that cannot fit the item\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf  # Assign infinitely low priority to infeasible bins\n\n    # For feasible bins:\n\n    # 1. Calculate the wasted space (remaining capacity after adding item).\n    wasted_space = bins_remain_cap - item\n\n    # 2. Prioritize bins with less wasted space. Smaller wasted space is better.\n    # To avoid division by zero and handle the case where wasted_space is exactly zero,\n    # add a small epsilon to the wasted space.\n    epsilon = 1e-9\n    priorities[~infeasible_bins] = -wasted_space[~infeasible_bins] # Higher priority for lower wasted space\n\n    # 3. Apply a \"gravitational\" pull effect. Give higher priority to bins that are already relatively full.\n    #    The more full, the greater the gravitational force attracting the new item.\n\n    fill_ratios = (bins_remain_cap - wasted_space) / (bins_remain_cap + epsilon)  # Avoid division by zero, and use total bin capacity, if known, can change this.\n    priorities[~infeasible_bins] += fill_ratios[~infeasible_bins] # Higher priority to more full bins.\n\n    # 4. A slight preference to more empty bins to distribute load at start\n    initial_fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities[~infeasible_bins] += 0.1 * initial_fullness[~infeasible_bins]\n\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a combination of factors to determine bin priority. It favors bins\n    where the item fits well (not too much wasted space), but also considers\n    whether the bin is already significantly full (reducing the chance of small\n    items later preventing larger items from being packed). Bins that cannot fit\n    the item receive a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Eliminate bins that cannot fit the item. Assign negative infinity to these\n    cannot_fit = bins_remain_cap < item\n    priorities[cannot_fit] = -np.inf\n\n    # 2. Calculate space utilization if item were placed in each bin.\n    space_utilization = item / bins_remain_cap\n    space_utilization[cannot_fit] = 0  # Avoid division by zero after this point\n\n    # 3. Prioritize bins where item fits well.\n    # Favor bins where the item takes up a substantial portion of the remaining space,\n    # but not so much that it leaves very little space behind.\n    fit_priority = np.exp(-np.abs(space_utilization - 0.8))  # Peaks at space_utilization = 0.8\n\n    # 4. Prioritize bins that are already somewhat full.\n    # This discourages spreading items too thinly across bins, improving chance of future items filling them more fully.\n    fullness_priority = (1 - bins_remain_cap)  # Larger number indicates fuller\n    fullness_priority[cannot_fit] = 0\n\n    # Combine Priorities:\n    priorities = fit_priority + fullness_priority\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the 'path integral' formulation: explore multiple possible futures.\n    In this case, a superposition of different bin assignments, weighted by\n    the \"probability\" of that assignment leading to a good overall packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9 # Prevent division by zero, very small number.\n\n    # Heuristic 1: \"First Fit Decreasing\" adaptation: Favor bins that are already somewhat full, but can still accommodate the item\n    space_utilization = (1 - bins_remain_cap / 1.0) # Assuming bins of size 1.0\n\n    # Heuristic 2: Minimize wasted space, but penalize very tight fits to encourage efficient packing later.\n    wasted_space = bins_remain_cap - item\n\n    # Heuristic 3: \"Level of Uncertainty\". Small amount of randomness will ensure that we don't end up in local optima.\n    uncertainty = np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # Create a 'potential energy' function that combines these heuristics\n    potential_energy = - space_utilization + np.abs(wasted_space) + uncertainty\n\n    # Convert the potential energy into a probability-like distribution\n    # We take the exponential to map negative energies to [0, 1] range (probability).\n    probabilities = np.exp(-potential_energy)\n\n    # Zero out probabilities where the item doesn't fit\n    probabilities[bins_remain_cap < item] = 0.0\n\n    # Normalize to get probabilities (optional, but can help numerical stability).\n    total_probability = np.sum(probabilities)\n    if total_probability > 0:\n        probabilities /= total_probability\n    else: # if total probability is zero, assign a small equal probability to each of the bins that will fit item\n        eligible_bins = bins_remain_cap >= item\n        probabilities[eligible_bins] = 1.0 / np.sum(eligible_bins)\n\n    return probabilities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the 'path integral' formulation: explore multiple possible futures.\n    In this case, a superposition of different bin assignments, weighted by\n    the \"probability\" of that assignment leading to a good overall packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9 # Prevent division by zero, very small number.\n\n    # Heuristic 1: \"First Fit Decreasing\" adaptation: Favor bins that are already somewhat full, but can still accommodate the item\n    space_utilization = (1 - bins_remain_cap / 1.0) # Assuming bins of size 1.0\n\n    # Heuristic 2: Minimize wasted space, but penalize very tight fits to encourage efficient packing later.\n    wasted_space = bins_remain_cap - item\n\n    # Heuristic 3: \"Level of Uncertainty\". Small amount of randomness will ensure that we don't end up in local optima.\n    uncertainty = np.random.rand(len(bins_remain_cap)) * 0.01\n\n    # Create a 'potential energy' function that combines these heuristics\n    potential_energy = - space_utilization + np.abs(wasted_space) + uncertainty\n\n    # Convert the potential energy into a probability-like distribution\n    # We take the exponential to map negative energies to [0, 1] range (probability).\n    probabilities = np.exp(-potential_energy)\n\n    # Zero out probabilities where the item doesn't fit\n    probabilities[bins_remain_cap < item] = 0.0\n\n    # Normalize to get probabilities (optional, but can help numerical stability).\n    total_probability = np.sum(probabilities)\n    if total_probability > 0:\n        probabilities /= total_probability\n    else: # if total probability is zero, assign a small equal probability to each of the bins that will fit item\n        eligible_bins = bins_remain_cap >= item\n        probabilities[eligible_bins] = 1.0 / np.sum(eligible_bins)\n\n    return probabilities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that have enough remaining capacity to fit the item,\n    favoring those with smaller remaining space (to avoid fragmentation).  Bins that cannot\n    fit the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item fits.\n    fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, assign a small priority to all bins, and favour the fullest.\n    if not np.any(fit_mask):\n      priorities = bins_remain_cap/ np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap, dtype=float)\n      return priorities\n\n    # Calculate remaining space after placing the item in suitable bins.\n    remaining_space = bins_remain_cap[fit_mask] - item\n\n    # Prioritize bins based on the inverse of remaining space to favor small remaining space\n    # After substraction from total, to encourage larger remaining space where fragmentation could be higher.\n    priorities[fit_mask] = 1.0 / (remaining_space + 1e-9) #Add a small value to avoid division by zero.\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version considers multiple factors:\n    1.  Remaining capacity: Bins with capacity close to item size are preferred (First Fit Decreasing principle).\n    2.  Penalty for exceeding bin capacity: Heavily penalizes exceeding capacity.\n    3.  Reward for perfect fit: Gives a substantial reward for perfect fit.\n    4.  Normalize priorities to avoid very large/small values.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap < item:\n            # Significant penalty for exceeding capacity. Avoid this at almost all costs.\n            priorities[i] = -float('inf')\n        elif cap == item:\n            # High reward for perfect fit\n            priorities[i] = 1000.0\n        else:\n            # Prioritize bins that have remaining capacity close to item size.  Use exponential scaling.\n            capacity_utilization = item / cap  # fraction of the bin that would be used.\n            priority_score = np.exp(5 * (1 - np.abs(1 - capacity_utilization))) # Peak priority when cap == item\n\n            priorities[i] = priority_score\n\n    # Normalize the priorities to avoid extremely large or small numbers, while preserving ordering.\n    max_priority = np.max(priorities[np.isfinite(priorities)]) #ignore -inf when normalizing.\n    if np.isfinite(max_priority) and max_priority > 0: #avoid 0 division. make sure some values are not -inf.\n        priorities[np.isfinite(priorities)] /= max_priority # Only normalize those that aren't inf\n    \n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins that have enough space for the item,\n    and then among those, it prefers bins where the remaining space after\n    adding the item is relatively small, but not too small (to avoid\n    excessive fragmentation). It also introduces a small random element\n    to break ties and encourage exploration of different bin configurations.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter out bins that don't have enough capacity.\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        #If no bins can fit the item, try to find the best fit by minimizing wasted space by creating a score based on remaining space\n        ratios = item / bins_remain_cap\n        priorities = 1 - ratios\n        return priorities\n\n    # Calculate remaining capacity after adding the item for valid bins.\n    remaining_capacity = bins_remain_cap[valid_bins] - item\n\n    # Prioritize bins where the remaining capacity is small, but not too small.\n    # The 'ideal' remaining capacity is a fraction of the original capacity,\n    # let's say between 0.1 and 0.3 of the original capacity (assuming bins have capacity 1).\n    ideal_remaining_range = (0.1, 0.3)\n    # create priority that peaks in ideal remaining range, penalizing if less than .1 and penalizing if greater than .3\n    normalized_remaining = np.clip(remaining_capacity,ideal_remaining_range[0],ideal_remaining_range[1])\n    normalized_remaining = (normalized_remaining-ideal_remaining_range[0])/(ideal_remaining_range[1]-ideal_remaining_range[0])\n\n    # Assign priority based on the normalized remaining capacity.  We invert\n    # because lower remaining cap = better, close to zero\n    priorities[valid_bins] = 1 - (remaining_capacity / bins_remain_cap[valid_bins]) # Use remaining space ration\n\n    # Adding a small randomness\n    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by black hole physics:\n    Bins nearing capacity (event horizon) have higher priority.\n    Larger items warp the \"spacetime\" (bin capacity) more.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log\n    epsilon = 1e-9\n    valid_bins = bins_remain_cap > epsilon\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        remain_cap_valid = bins_remain_cap[valid_bins]\n        # Calculate \"gravitational potential\" based on remaining capacity.\n        # Bins with capacity closer to item size have higher potential (priority).\n        potential = np.exp(-np.abs(remain_cap_valid - item) / (item + epsilon))\n\n        # Normalize the remaining capacity\n        normalized_cap = remain_cap_valid / np.max(bins_remain_cap)\n\n        # Combine potential with remaining capacity\n        priorities[valid_bins] = potential * (1 - normalized_cap) # Prefer bins that aren't already too full\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by black hole physics:\n    Bins nearing capacity (event horizon) have higher priority.\n    Larger items warp the \"spacetime\" (bin capacity) more.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and negative values in log\n    epsilon = 1e-9\n    valid_bins = bins_remain_cap > epsilon\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    if np.any(valid_bins):\n        remain_cap_valid = bins_remain_cap[valid_bins]\n        # Calculate \"gravitational potential\" based on remaining capacity.\n        # Bins with capacity closer to item size have higher potential (priority).\n        potential = np.exp(-np.abs(remain_cap_valid - item) / (item + epsilon))\n\n        # Normalize the remaining capacity\n        normalized_cap = remain_cap_valid / np.max(bins_remain_cap)\n\n        # Combine potential with remaining capacity\n        priorities[valid_bins] = potential * (1 - normalized_cap) # Prefer bins that aren't already too full\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n    1. Remaining capacity: Bins with remaining capacity closer to the item size are preferred (first-fit-decreasing inspired).\n    2. Waste minimization: A penalty is applied if adding the item leads to excessive waste.\n    3. Number of Items in the bin (Encourage Filling): Give bin with more items in them higher priority. Assume, this data are captured with the reciprocal of available capacity.\n    4. Prevent excessive filling(Regularization): Prevent very full bins to encourage use of multiple bins.\n\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small value to avoid negative infinities later\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Capacity difference: lower difference is better. Add a tiny offset to avoid div by zero.\n    capacity_diff = np.abs(bins_remain_cap - item) + 1e-9\n    priorities += -capacity_diff  # Invert the difference, so smaller is better (higher priority). Add small negative value to all to make lowest value 0\n\n    # Waste minimization: penalize bins if adding the item leads to substantial waste.\n    potential_waste = bins_remain_cap - item\n    waste_penalty = np.where(potential_waste > 0, -potential_waste, -np.inf)  # Negative waste penalty\n    priorities += waste_penalty\n\n    # Encourage filling: prioritize bins that are already somewhat full (avoid creating many almost-empty bins). We approximate the item_number in bin with its fullness i.e., 1/remaining capacity.\n    fullness_factor = 1.0 / (bins_remain_cap + 1e-9) # Higher value if the bin is fuller\n    priorities += fullness_factor\n\n    # Regularization : if the bin is nearly full, give it some penalty\n    is_nearly_full = np.where(bins_remain_cap < 1.1 * item , -0.5, 0) # 1.1 is somewhat arbitrary here to determine nearness.\n    priorities += is_nearly_full\n\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n    1. Remaining capacity: Bins with remaining capacity closer to the item size are preferred (first-fit-decreasing inspired).\n    2. Waste minimization: A penalty is applied if adding the item leads to excessive waste.\n    3. Number of Items in the bin (Encourage Filling): Give bin with more items in them higher priority. Assume, this data are captured with the reciprocal of available capacity.\n    4. Prevent excessive filling(Regularization): Prevent very full bins to encourage use of multiple bins.\n\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small value to avoid negative infinities later\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Capacity difference: lower difference is better. Add a tiny offset to avoid div by zero.\n    capacity_diff = np.abs(bins_remain_cap - item) + 1e-9\n    priorities += -capacity_diff  # Invert the difference, so smaller is better (higher priority). Add small negative value to all to make lowest value 0\n\n    # Waste minimization: penalize bins if adding the item leads to substantial waste.\n    potential_waste = bins_remain_cap - item\n    waste_penalty = np.where(potential_waste > 0, -potential_waste, -np.inf)  # Negative waste penalty\n    priorities += waste_penalty\n\n    # Encourage filling: prioritize bins that are already somewhat full (avoid creating many almost-empty bins). We approximate the item_number in bin with its fullness i.e., 1/remaining capacity.\n    fullness_factor = 1.0 / (bins_remain_cap + 1e-9) # Higher value if the bin is fuller\n    priorities += fullness_factor\n\n    # Regularization : if the bin is nearly full, give it some penalty\n    is_nearly_full = np.where(bins_remain_cap < 1.1 * item , -0.5, 0) # 1.1 is somewhat arbitrary here to determine nearness.\n    priorities += is_nearly_full\n\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n    1. Remaining capacity: Bins with remaining capacity closer to the item size are preferred (first-fit-decreasing inspired).\n    2. Waste minimization: A penalty is applied if adding the item leads to excessive waste.\n    3. Number of Items in the bin (Encourage Filling): Give bin with more items in them higher priority. Assume, this data are captured with the reciprocal of available capacity.\n    4. Prevent excessive filling(Regularization): Prevent very full bins to encourage use of multiple bins.\n\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small value to avoid negative infinities later\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Capacity difference: lower difference is better. Add a tiny offset to avoid div by zero.\n    capacity_diff = np.abs(bins_remain_cap - item) + 1e-9\n    priorities += -capacity_diff  # Invert the difference, so smaller is better (higher priority). Add small negative value to all to make lowest value 0\n\n    # Waste minimization: penalize bins if adding the item leads to substantial waste.\n    potential_waste = bins_remain_cap - item\n    waste_penalty = np.where(potential_waste > 0, -potential_waste, -np.inf)  # Negative waste penalty\n    priorities += waste_penalty\n\n    # Encourage filling: prioritize bins that are already somewhat full (avoid creating many almost-empty bins). We approximate the item_number in bin with its fullness i.e., 1/remaining capacity.\n    fullness_factor = 1.0 / (bins_remain_cap + 1e-9) # Higher value if the bin is fuller\n    priorities += fullness_factor\n\n    # Regularization : if the bin is nearly full, give it some penalty\n    is_nearly_full = np.where(bins_remain_cap < 1.1 * item , -0.5, 0) # 1.1 is somewhat arbitrary here to determine nearness.\n    priorities += is_nearly_full\n\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n    1. Remaining capacity: Bins with remaining capacity closer to the item size are preferred (first-fit-decreasing inspired).\n    2. Waste minimization: A penalty is applied if adding the item leads to excessive waste.\n    3. Number of Items in the bin (Encourage Filling): Give bin with more items in them higher priority. Assume, this data are captured with the reciprocal of available capacity.\n    4. Prevent excessive filling(Regularization): Prevent very full bins to encourage use of multiple bins.\n\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small value to avoid negative infinities later\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Capacity difference: lower difference is better. Add a tiny offset to avoid div by zero.\n    capacity_diff = np.abs(bins_remain_cap - item) + 1e-9\n    priorities += -capacity_diff  # Invert the difference, so smaller is better (higher priority). Add small negative value to all to make lowest value 0\n\n    # Waste minimization: penalize bins if adding the item leads to substantial waste.\n    potential_waste = bins_remain_cap - item\n    waste_penalty = np.where(potential_waste > 0, -potential_waste, -np.inf)  # Negative waste penalty\n    priorities += waste_penalty\n\n    # Encourage filling: prioritize bins that are already somewhat full (avoid creating many almost-empty bins). We approximate the item_number in bin with its fullness i.e., 1/remaining capacity.\n    fullness_factor = 1.0 / (bins_remain_cap + 1e-9) # Higher value if the bin is fuller\n    priorities += fullness_factor\n\n    # Regularization : if the bin is nearly full, give it some penalty\n    is_nearly_full = np.where(bins_remain_cap < 1.1 * item , -0.5, 0) # 1.1 is somewhat arbitrary here to determine nearness.\n    priorities += is_nearly_full\n\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First consider only bins that can accommodate the item. Others get -inf\n    eligible_bins = bins_remain_cap >= item\n    priorities[~eligible_bins] = -np.inf\n\n    # Among eligible bins, prioritize those with smaller remaining capacity, but not too small\n    # Prioritize based on how much \"waste\" will be created if we place the item\n    waste = bins_remain_cap - item\n    # Penalize very small waste heavily.  Helps to avoid fragmentation. A small constant is introduced to stabilize the score calculation.\n    priorities[eligible_bins] = -np.abs(waste[eligible_bins] - np.mean(waste[eligible_bins]))/(np.std(waste[eligible_bins]) + 1e-6) - 100*(waste[eligible_bins] < 0.1)\n\n    #Prioritize the bins where remain capacity is almost same as item size to avoid small items\n    #priorities = 1 / np.abs(bins_remain_cap - item)\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First consider only bins that can accommodate the item. Others get -inf\n    eligible_bins = bins_remain_cap >= item\n    priorities[~eligible_bins] = -np.inf\n\n    # Among eligible bins, prioritize those with smaller remaining capacity, but not too small\n    # Prioritize based on how much \"waste\" will be created if we place the item\n    waste = bins_remain_cap - item\n    # Penalize very small waste heavily.  Helps to avoid fragmentation. A small constant is introduced to stabilize the score calculation.\n    priorities[eligible_bins] = -np.abs(waste[eligible_bins] - np.mean(waste[eligible_bins]))/(np.std(waste[eligible_bins]) + 1e-6) - 100*(waste[eligible_bins] < 0.1)\n\n    #Prioritize the bins where remain capacity is almost same as item size to avoid small items\n    #priorities = 1 / np.abs(bins_remain_cap - item)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. A Feynman-inspired heuristic.\n\n    This heuristic attempts to balance exploration and exploitation. We want to find a good fit quickly,\n    but also consider other bins to avoid getting stuck in local optima (a deep potential well, as I might say).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Basic Feasibility: Rule out bins that are too small. This is like applying a hard energy cutoff.\n    feasible_bins = bins_remain_cap >= item\n\n    # If there are no feasible bins, signal that by returning -inf for all priorities\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 2. Feynman Path Integral (Sort Of): Consider all possible paths (bins) but weigh them differently.\n    # The closer the item size is to the bin capacity, the better (exploitation). Think of it as minimizing the \"action\"\n    # (wasted space). We also add a small exploration bonus to avoid purely greedy approaches.\n    space_wasted = bins_remain_cap - item\n    space_wasted[space_wasted < 0] = np.inf  # Penalize infeasible bins strongly after the hard cut.\n\n    # This part is like the exponential of the negative action. smaller space wasted means higher \"amplitude\" or priority\n    fit_priority = np.exp(-space_wasted)\n\n    # 3. Encourage Balanced Bin Usage: Give a slight bonus to bins that are relatively empty.\n    #   This is kind of like trying to minimize entanglement between the bins - we don't want a few bins hogging everything.\n    #   We need to normalize it to scale the relative weights.\n\n    normalized_capacities = bins_remain_cap / np.max(bins_remain_cap)  # Range [0, 1]\n    exploration_bonus = 0.1 * normalized_capacities\n\n    # 4. Combine all aspects\n    priorities = feasible_bins * (fit_priority + exploration_bonus)\n\n    # Re-scale, since numpy complains if some of them are 0 and it cannot normalize it\n    # to have unit vector size\n    if np.sum(priorities) == 0:\n        return priorities\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. A Feynman-inspired heuristic.\n\n    This heuristic attempts to balance exploration and exploitation. We want to find a good fit quickly,\n    but also consider other bins to avoid getting stuck in local optima (a deep potential well, as I might say).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Basic Feasibility: Rule out bins that are too small. This is like applying a hard energy cutoff.\n    feasible_bins = bins_remain_cap >= item\n\n    # If there are no feasible bins, signal that by returning -inf for all priorities\n    if not np.any(feasible_bins):\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 2. Feynman Path Integral (Sort Of): Consider all possible paths (bins) but weigh them differently.\n    # The closer the item size is to the bin capacity, the better (exploitation). Think of it as minimizing the \"action\"\n    # (wasted space). We also add a small exploration bonus to avoid purely greedy approaches.\n    space_wasted = bins_remain_cap - item\n    space_wasted[space_wasted < 0] = np.inf  # Penalize infeasible bins strongly after the hard cut.\n\n    # This part is like the exponential of the negative action. smaller space wasted means higher \"amplitude\" or priority\n    fit_priority = np.exp(-space_wasted)\n\n    # 3. Encourage Balanced Bin Usage: Give a slight bonus to bins that are relatively empty.\n    #   This is kind of like trying to minimize entanglement between the bins - we don't want a few bins hogging everything.\n    #   We need to normalize it to scale the relative weights.\n\n    normalized_capacities = bins_remain_cap / np.max(bins_remain_cap)  # Range [0, 1]\n    exploration_bonus = 0.1 * normalized_capacities\n\n    # 4. Combine all aspects\n    priorities = feasible_bins * (fit_priority + exploration_bonus)\n\n    # Re-scale, since numpy complains if some of them are 0 and it cannot normalize it\n    # to have unit vector size\n    if np.sum(priorities) == 0:\n        return priorities\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Heuristic 1: Prefer bins where the item almost perfectly fits (minimizing wasted space)\n    waste = bins_remain_cap - item\n    perfect_fit_bonus = np.exp(-np.abs(waste) / (item + 0.0001)) # Avoid div by zero & scale the bonus\n\n    # Heuristic 2: Higher priority to bins that can fit the item, lower otherwise.  Set -inf when item cannot fit\n    can_fit = bins_remain_cap >= item\n    priorities = np.where(can_fit, perfect_fit_bonus + (bins_remain_cap - item), -np.inf)\n\n    # Heuristic 3: Slightly reward bins that have already been used. Prevents creating too many nearly empty bins at the start.\n    used_bin_bonus = np.where(bins_remain_cap < np.max(bins_remain_cap), 0.1, 0)  # Small constant bonus\n    priorities = priorities + used_bin_bonus\n    \n    #Heuristic 4: Penalize bins close to full\n    almost_full_penalty = np.where((bins_remain_cap > item) & (bins_remain_cap < 1.2 * item) , -0.05 * (1.2 * item - bins_remain_cap), 0) # small penalty for filling too much\n\n    priorities = priorities + almost_full_penalty\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}