```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Aims to balance bin utilization and avoid excessive fragmentation.
    It gives high priority to bins where the item fits reasonably well,
    but not perfectly (to avoid creating almost-empty bins).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Define constants for the ideal fit range.  These should ideally be parameters adjusted
    # using historical information. But alas, I am only designing the priority function and not
    # an entire learning system.

    ideal_fit_lower_bound = 0.6 #60% bin utilization when item is added
    ideal_fit_upper_bound = 0.95 # 95% bin utilization when item is added.  Less than 1 to avoid trivial best fits.


    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            # Calculate utilization after adding the item
            utilization = (item) / cap
            # Priority is higher if the utilization is within the ideal range.
            # We prefer utilization that are close to the 'sweet spot'.
            if ideal_fit_lower_bound <= (1 - (cap - item)) <= ideal_fit_upper_bound:
                priorities[i] = 1 / (abs(1 - (cap - item) - (ideal_fit_lower_bound + ideal_fit_upper_bound) / 2) + 0.001) #closer to middle higher priority, avoids division by zero
            else:
                # Slightly penalize bins with excessive or very little space
                priorities[i] = max(0, 1 - (abs(1 - (cap - item) - (ideal_fit_lower_bound + ideal_fit_upper_bound) / 2)))  # High if near acceptable
        else:
            priorities[i] = -np.inf  # Item does not fit

    return priorities
```
