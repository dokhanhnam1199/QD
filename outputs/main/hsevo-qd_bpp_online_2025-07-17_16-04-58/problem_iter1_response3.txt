```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that have enough remaining capacity to fit the item,
    favoring those with smaller remaining space (to avoid fragmentation).  Bins that cannot
    fit the item are given a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item fits.
    fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, assign a small priority to all bins, and favour the fullest.
    if not np.any(fit_mask):
      priorities = bins_remain_cap/ np.max(bins_remain_cap) if np.max(bins_remain_cap)>0 else np.zeros_like(bins_remain_cap, dtype=float)
      return priorities

    # Calculate remaining space after placing the item in suitable bins.
    remaining_space = bins_remain_cap[fit_mask] - item

    # Prioritize bins based on the inverse of remaining space to favor small remaining space
    # After substraction from total, to encourage larger remaining space where fragmentation could be higher.
    priorities[fit_mask] = 1.0 / (remaining_space + 1e-9) #Add a small value to avoid division by zero.

    return priorities
```
