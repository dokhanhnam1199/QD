```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that have enough space for the item,
    and then among those, it prefers bins where the remaining space after
    adding the item is relatively small, but not too small (to avoid
    excessive fragmentation). It also introduces a small random element
    to break ties and encourage exploration of different bin configurations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Filter out bins that don't have enough capacity.
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        #If no bins can fit the item, try to find the best fit by minimizing wasted space by creating a score based on remaining space
        ratios = item / bins_remain_cap
        priorities = 1 - ratios
        return priorities

    # Calculate remaining capacity after adding the item for valid bins.
    remaining_capacity = bins_remain_cap[valid_bins] - item

    # Prioritize bins where the remaining capacity is small, but not too small.
    # The 'ideal' remaining capacity is a fraction of the original capacity,
    # let's say between 0.1 and 0.3 of the original capacity (assuming bins have capacity 1).
    ideal_remaining_range = (0.1, 0.3)
    # create priority that peaks in ideal remaining range, penalizing if less than .1 and penalizing if greater than .3
    normalized_remaining = np.clip(remaining_capacity,ideal_remaining_range[0],ideal_remaining_range[1])
    normalized_remaining = (normalized_remaining-ideal_remaining_range[0])/(ideal_remaining_range[1]-ideal_remaining_range[0])

    # Assign priority based on the normalized remaining capacity.  We invert
    # because lower remaining cap = better, close to zero
    priorities[valid_bins] = 1 - (remaining_capacity / bins_remain_cap[valid_bins]) # Use remaining space ration

    # Adding a small randomness
    priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01

    return priorities
```
