```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)  # Initialize with -inf

    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities  # All bins infeasible, return -inf priorities

    priorities[feasible_bins] = 0.0  # Set feasible bins to a base priority of 0

    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item

    # Ideal remaining capacity: Aim for a small amount of space left over
    ideal_remaining = 0.1 * item  # A fraction of the item size

    # Calculate the "distance" from the ideal remaining capacity
    distance_from_ideal = np.abs(remaining_capacity_after_placement - ideal_remaining)

    # Prioritize bins closer to the ideal remaining capacity.  Use a smooth function like a Gaussian
    priority_scale = 10.0  # Controls the strength of the preference
    priorities[feasible_bins] = priority_scale * np.exp(-distance_from_ideal**2 / (2 * (0.2 * item)**2)) # Standard Deviation of 0.2 * item

    # Heavily penalize very small remaining capacities to avoid fragmentation
    very_small_threshold = 0.05 * item
    very_small_bins = remaining_capacity_after_placement < very_small_threshold
    priorities[feasible_bins][very_small_bins] -= 50.0

    # Boost nearly full bins, but less aggressively than v1
    almost_full_threshold = 0.1 * item
    almost_full_bins = bins_remain_cap[feasible_bins] < item + almost_full_threshold
    priorities[feasible_bins][almost_full_bins] += 5.0
    return priorities
```
