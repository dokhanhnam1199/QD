```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Combines fullness, fragmentation, and remaining capacity considerations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities

    # --- Objective 1: Fullness ---
    # Encourages filling bins completely
    remaining_capacity_after_placement = bins_remain_cap - item
    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = np.inf  # Mark infeasible bins

    fullness_priority = np.zeros_like(bins_remain_cap, dtype=float)
    fullness_priority[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001)

    # --- Objective 2: Minimize Fragmentation ---
    # Discourages leaving very small spaces in bins
    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)
    small_capacity_threshold = 0.2  # As a ratio of bin capacity.  Adjust as needed
    fragmented_bins = feasible_bins & (remaining_capacity_after_placement < small_capacity_threshold) # Directly use calculated remain capacity
    fragmentation_penalty[fragmented_bins] = -2.0  # Negative penalty for fragmentation

    # --- Objective 3: Target Remaining Capacity ---
    # Avoids filling bins too much (leaving only very tiny spaces) or too little
    target_capacity_priority = np.zeros_like(bins_remain_cap, dtype=float)
    target_range_lower = 0.3  # preferred remaining capacity ratio lower bound
    target_range_upper = 0.7  # preferred remaining capacity ratio upper bound

    ideal_remaining = (target_range_lower + target_range_upper) / 2  # center of the range
    capacity_after_ratio = remaining_capacity_after_placement / 1.0 # Assumes bin size is 1.0
    target_capacity_priority[feasible_bins] = -np.abs(capacity_after_ratio[feasible_bins] - ideal_remaining) # closer to ideal remaining better score


    # --- Adaptive Weights (Simple example: adjust based on item size) ---
    # Larger items: prioritize fullness more (avoid leaving big gaps).
    # Smaller items: prioritize fragmentation less (more flexible placement).

    item_size_ratio = item  # Assuming bin size is 1.0

    fullness_weight = 0.6 + 0.4 * item_size_ratio # Increase weight of fullness as item size increases
    fragmentation_weight = 0.2 - 0.2 * item_size_ratio  # Decrease weight of fragmentation as item size increases
    target_weight = 0.2

    fragmentation_weight = max(0.0, fragmentation_weight) # Ensure weight isn't negative.

    # --- Combine Objectives with Weights ---
    priorities = fullness_weight * fullness_priority + \
                 fragmentation_weight * fragmentation_penalty + \
                 target_weight * target_capacity_priority

    return priorities
```
