```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Uses a combination of factors to determine bin priority. It favors bins
    where the item fits well (not too much wasted space), but also considers
    whether the bin is already significantly full (reducing the chance of small
    items later preventing larger items from being packed). Bins that cannot fit
    the item receive a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Eliminate bins that cannot fit the item. Assign negative infinity to these
    cannot_fit = bins_remain_cap < item
    priorities[cannot_fit] = -np.inf

    # 2. Calculate space utilization if item were placed in each bin.
    space_utilization = item / bins_remain_cap
    space_utilization[cannot_fit] = 0  # Avoid division by zero after this point

    # 3. Prioritize bins where item fits well.
    # Favor bins where the item takes up a substantial portion of the remaining space,
    # but not so much that it leaves very little space behind.
    fit_priority = np.exp(-np.abs(space_utilization - 0.8))  # Peaks at space_utilization = 0.8

    # 4. Prioritize bins that are already somewhat full.
    # This discourages spreading items too thinly across bins, improving chance of future items filling them more fully.
    fullness_priority = (1 - bins_remain_cap)  # Larger number indicates fuller
    fullness_priority[cannot_fit] = 0

    # Combine Priorities:
    priorities = fit_priority + fullness_priority

    return priorities
```
