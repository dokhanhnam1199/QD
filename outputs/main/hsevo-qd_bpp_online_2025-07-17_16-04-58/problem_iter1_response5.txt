```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers several factors:

    1.  Whether the item fits in the bin (otherwise, priority is -infinity).
    2.  How much empty space would be left after adding the item.  We penalize
        bins that would be left with very small remaining capacity, as those
        bins are unlikely to be useful for later items.  We also penalize bins
        with large remaining capacity, as that suggests we're not filling them
        efficiently.  The "sweet spot" is somewhere in between.
    3.  The current fill level of the bin.  We prefer to add items to bins
        that are already relatively full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if item > cap:
            priorities[i] = -np.inf  # Item doesn't fit.

        else:
            remaining_after_fit = cap - item

            # Reward bins where adding the item leads to an OK remaining cap
            # (not too small, not too large).  We use a Gaussian-like penalty.
            ideal_remaining = 0.25  # Ideally, leave 25% of the bin empty.
            penalty_width = 0.25    # Spread of the penalty.
            remaining_penalty = -((remaining_after_fit - ideal_remaining)**2) / (2 * penalty_width**2)


            # Prefer filling partially filled bins more than empty ones
            current_fill_level = 1.0 - (cap / 1.0)  # Assumes bin capacity is 1.0
            fill_level_reward = current_fill_level

            priorities[i] = remaining_penalty + fill_level_reward #+ bin_index_reward

    return priorities
```
