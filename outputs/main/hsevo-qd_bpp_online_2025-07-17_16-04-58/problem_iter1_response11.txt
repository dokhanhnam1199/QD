```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function considers several factors:
    1.  The amount of wasted space if the item is placed in the bin (lower waste is better).
    2.  The absolute remaining capacity (to prioritize bins that are already somewhat full).
    3.  Whether the item fits at all.
    4. A bit of "strategic fragmentation" avoidance.  We don't want to fill nearly-full bins unless really necessary, but neither
       do we want to fill almost-empty bins.
    

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if item <= capacity:
            waste = capacity - item
            # Primary factor: Minimize waste (but use reciprocal so larger values are better)
            # Avoid division by zero by adding a small epsilon
            waste_priority = 1 / (waste + 0.00001)  
            
            # Secondary factor: Reward bins that are already somewhat full
            # to consolidate items and free up totally empty bins. However, do not
            # over prioritize fully-filled bins
            # This is normalized so the max contribution of cap_priority is roughly on the
            # order of the waste_priority, but can be adjusted with some scaling
            cap_priority = capacity # raw capacity

            # Combined priority
            priorities[i] = waste_priority + 0.1 * cap_priority 
            
            # Minor optimization. The goal is to discourage creating highly fragmented bins.
            # If placing the item leads to the bin being almost full (e.g. remaining capacity between 0 and item/4), penalize it somewhat
            if 0 < waste <= item/4:
               priorities[i] -= 0.2 * waste_priority
    
        else:
            # Item doesn't fit, so priority is zero.
            priorities[i] = 0.0
            
    return priorities
```
