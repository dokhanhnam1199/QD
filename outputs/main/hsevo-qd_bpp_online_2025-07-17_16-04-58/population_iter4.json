[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 264.97209216286,
    "mi": 80.41308480637692,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, considers fullness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.1 * fullness_factor\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 102.1865710312585,
    "mi": 91.19510925553107,
    "token_count": 103.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)  # Initialize with -inf for infeasible bins\n\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # All bins are infeasible\n\n    priorities[feasible_bins] = 0.0  # Reset feasible bins to a base priority of 0\n\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n\n    # Define an ideal remaining capacity.  This is a crucial parameter.\n    # Let's start with aiming for a small, non-zero ideal.\n    ideal_remaining_capacity = 0.1 # was 0.2\n\n    # Calculate the deviation from the ideal remaining capacity.  Smaller is better.\n    deviation = np.abs(remaining_capacity_after_placement - ideal_remaining_capacity)\n\n    # Use the inverse of the deviation as the priority.\n    priorities[feasible_bins] = 1.0 / (deviation + 0.00001)  # Avoid division by zero\n\n    # Add a bonus for bins that would be nearly full after placement.\n    almost_full_threshold = 0.05  # Reduce it to 5%\n    almost_full_bins = (remaining_capacity_after_placement <= almost_full_threshold)\n    priorities[feasible_bins][almost_full_bins] += 5.0 # was 5.0\n\n    # Slightly penalize bins that have a very large remaining capacity. This discourages putting small\n    # items into almost empty bins. Avoids fragmentation.\n    large_capacity_threshold = 0.75\n    large_capacity_bins = bins_remain_cap[feasible_bins] > large_capacity_threshold\n    priorities[feasible_bins][large_capacity_bins] -= 1.0 # was 2.0\n\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 161.66617507355795,
    "mi": 75.27752196124096,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.037257819812672566, almost_full_boost: float = 8.60987061574142, small_capacity_threshold: float = 0.40566790926186397, small_capacity_penalty: float = -3.8015043133432296, division_eps: float = 1.6923976863561945e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        almost_full_threshold: Threshold for considering a bin almost full (as a fraction of item size).\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold for considering a bin small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n        division_eps: Epsilon value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "mi": 62.652005992215045,
    "token_count": 97.0,
    "exec_success": true
  }
]