```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that have just enough space for the item,
    avoiding overly large or small gaps.  It also incorporates a randomness
    factor to explore different packing arrangements.  A small penalty is
    added for nearly full bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate remaining capacity after placing the item
    remaining_after = bins_remain_cap - item

    # Initialize priorities
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give high priority to bins where the remaining space is small but non-negative
    # and moderate space available
    near_fit = (remaining_after >= 0)
    space_factor = np.exp(-5 * np.abs(remaining_after / item - 0.2)) * near_fit #Prioritize those with a gap between 0 and 0.4 of item size.  Experiment with values

    priorities = space_factor

    # Penalize bins that are already nearly full (to encourage using emptier bins when possible)
    nearly_full = (bins_remain_cap < 1.1 * item) & (bins_remain_cap >= item)  # Consider as nearly full only if there is a bit extra. Prevents placing items that barely fit if there are better option

    priorities[nearly_full] -= 0.1 #Adjust this penalty, consider zero if you do not want to use it.
    
    # Introduce some randomness to avoid getting stuck in local optima
    randomness = 0.01 * np.random.rand(len(bins_remain_cap))  # Small random noise
    priorities += randomness
    #Prioritize the bins that actually fit.
    priorities[bins_remain_cap < item] = -np.inf

    return priorities
```
