```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on remaining capacity and ideal waste, avoids infeasibility."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        priorities = item - bins_remain_cap  # min diff if no space
        return priorities

    remaining_capacity = bins_remain_cap[valid_bins] - item
    ideal_remaining_range = (0.1, 0.3) # Aim for between 10 to 30% fill.
    
    #Prioritize if remaining cap is within ideal range
    in_ideal_range = (remaining_capacity >= ideal_remaining_range[0]) & (remaining_capacity <= ideal_remaining_range[1])
    priorities[valid_bins] = np.where(in_ideal_range,1,0)

    #Then refine within ideal range
    if np.any(in_ideal_range):
        priorities[valid_bins[in_ideal_range]] = 1- (remaining_capacity[in_ideal_range]- ideal_remaining_range[0])/(ideal_remaining_range[1]- ideal_remaining_range[0])
    
    #If no bins are ideal, favor less waste on valid bins
    if not np.any(in_ideal_range):
        priorities[valid_bins] = 1.0 / (remaining_capacity + 1e-9)

    return priorities
```
