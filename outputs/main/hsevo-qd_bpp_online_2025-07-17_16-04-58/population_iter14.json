[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 264.97209216286,
    "mi": 80.41308480637692,
    "token_count": 178.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, considers fullness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.1 * fullness_factor\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 102.1865710312585,
    "mi": 91.19510925553107,
    "token_count": 103.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)  # Initialize with -inf for infeasible bins\n\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # All bins are infeasible\n\n    priorities[feasible_bins] = 0.0  # Reset feasible bins to a base priority of 0\n\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n\n    # Define an ideal remaining capacity.  This is a crucial parameter.\n    # Let's start with aiming for a small, non-zero ideal.\n    ideal_remaining_capacity = 0.1 # was 0.2\n\n    # Calculate the deviation from the ideal remaining capacity.  Smaller is better.\n    deviation = np.abs(remaining_capacity_after_placement - ideal_remaining_capacity)\n\n    # Use the inverse of the deviation as the priority.\n    priorities[feasible_bins] = 1.0 / (deviation + 0.00001)  # Avoid division by zero\n\n    # Add a bonus for bins that would be nearly full after placement.\n    almost_full_threshold = 0.05  # Reduce it to 5%\n    almost_full_bins = (remaining_capacity_after_placement <= almost_full_threshold)\n    priorities[feasible_bins][almost_full_bins] += 5.0 # was 5.0\n\n    # Slightly penalize bins that have a very large remaining capacity. This discourages putting small\n    # items into almost empty bins. Avoids fragmentation.\n    large_capacity_threshold = 0.75\n    large_capacity_bins = bins_remain_cap[feasible_bins] > large_capacity_threshold\n    priorities[feasible_bins][large_capacity_bins] -= 1.0 # was 2.0\n\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 161.66617507355795,
    "mi": 75.27752196124096,
    "token_count": 174.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.037257819812672566, almost_full_boost: float = 8.60987061574142, small_capacity_threshold: float = 0.40566790926186397, small_capacity_penalty: float = -3.8015043133432296, division_eps: float = 1.6923976863561945e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        almost_full_threshold: Threshold for considering a bin almost full (as a fraction of item size).\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold for considering a bin small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n        division_eps: Epsilon value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 5.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "mi": 62.652005992215045,
    "token_count": 97.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, target capacity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Target remaining capacity: penalize bins far from target\n    target_capacity = 0.2 * np.max(bins_remain_cap) #tunable\n    capacity_diff = np.abs(bins_remain_cap[feasible_bins] - target_capacity)\n    priorities[feasible_bins] -= 0.05 * capacity_diff #tunable\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.01 * fullness_factor #tunable\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 190.19550008653877,
    "mi": 57.5053741208289,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Mark infeasible\n\n    # Target a remaining capacity close to a desirable 'target'.\n    # If it is not possible, a bin with smallest waste.\n    target_capacity = 0.1  # A parameter to tune\n    capacity_diff = np.abs(remaining_capacity_after_placement - target_capacity)\n    capacity_diff[remaining_capacity_after_placement < 0] = np.inf #Exclude infeasible bins from ideal match\n\n    # Primary priority: Closeness to the target capacity\n    priorities[feasible_bins] = -capacity_diff[feasible_bins]\n\n    #Secondary Priorities\n    # 1. Bins close to full are given higher priority (First-Fit-Decreasing principle to avoid waste)\n    almost_full_threshold = 0.05  # Even stricter full threshold\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 10.0 #Increased weight to favor these bins\n\n    # 2. Prevent bins with small capacity by penalizing them\n    small_capacity_threshold = 0.25 #Slightly increased threshold\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 5.0\n\n    # 3. Add a small bonus to bins that are nearly empty. This might encourage early bin fills, reducing the number of bins used at the end\n    nearly_empty_threshold = 0.9\n    nearly_empty_bins = feasible_bins & (bins_remain_cap > nearly_empty_threshold)\n    priorities[nearly_empty_bins] += 2.0\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 280.0,
    "mi": 81.26841719242016,
    "token_count": 194.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "mi": 91.90275452958502,
    "token_count": 102.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on feasibility, waste, and item/bin ratio.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space\n\n    # Item/bin ratio to encourage tighter fits\n    ratios = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] += 0.1 * ratios # Tunable weight\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 208.89318279048564,
    "mi": 79.49986275581973,
    "token_count": 157.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1\n\n    # Core Priority: Fill Rate\n    fill_rate_priority = (item / bins_remain_cap) * feasible_bins\n    priorities[feasible_bins] += fill_rate_priority[feasible_bins] * 2.0  # Weight fill rate\n\n    # Remaining Capacity Optimization: Balance filling and future flexibility\n    remaining_capacity_penalty = np.abs(remaining_capacity_after_placement) * feasible_bins\n    priorities[feasible_bins] -= remaining_capacity_penalty[feasible_bins] * 0.5 # Reduced penalty.\n\n    # Encourage to fill bins with some margin left for smaller items to fit in\n    margin_threshold = 0.3\n    margin_bonus = feasible_bins & (remaining_capacity_after_placement >= item*margin_threshold) & (remaining_capacity_after_placement <= item*(1+margin_threshold))\n    priorities[margin_bonus] += 0.8\n\n    # Prioritize bins that are most close to the item size\n    closest_fit_bonus = feasible_bins * (1 - np.abs(bins_remain_cap - item) / np.max(bins_remain_cap))\n    priorities[feasible_bins] += closest_fit_bonus[feasible_bins] * 1.5\n\n    # Bin diversity - helps to select a diverse set of bins rather than keep filling the same ones all the time\n    diversity_factor = np.random.rand(len(bins_remain_cap)) * 0.1\n    priorities += diversity_factor\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 22.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 284.3458750793272,
    "mi": 80.26274931482773,
    "token_count": 213.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response0.txt_stdout.txt",
    "code_path": "problem_iter10_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, division_epsilon: float = 3.251011962525543e-06,\n                almost_full_threshold: float = 0.07359594924881202, almost_full_boost: float = 4.551124234880866,\n                small_capacity_threshold: float = 0.19085413880719226, small_capacity_penalty: float = 4.089881296997733) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_epsilon: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold below which a bin is considered to have small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 11.60964047443681,
    "mi": 78.46336371509999,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines target capacity, fullness incentives, and fragmentation penalties.\n    Prioritizes bins that are feasible and close to ideal fullness.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = np.inf\n\n    # Target a remaining capacity.\n    target_capacity = 0.1\n    capacity_diff = np.abs(remaining_capacity_after_placement - target_capacity)\n\n    priorities[feasible_bins] = -capacity_diff[feasible_bins]\n\n    # Almost full bonus.\n    almost_full_threshold = 0.05\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 10.0\n\n    # Small capacity penalty.\n    small_capacity_threshold = 0.25\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 5.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 173.06477719407374,
    "mi": 88.34180193744433,
    "token_count": 147.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Multi-objective: fullness, minimizing fragmentation, target remaining capacity.\n    Adaptive weights based on remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1\n\n    # Fullness objective: Prioritize bins that become fuller\n    fullness_priority = (item / bins_remain_cap) * feasible_bins\n    priorities += fullness_priority\n\n    # Fragmentation objective: Penalize bins with small remaining capacity AFTER placement\n    # The penalty is stronger if the item cannot fit well in other bins\n    avg_remaining_capacity = np.mean(bins_remain_cap[feasible_bins]) if np.any(feasible_bins) else 0\n    frag_penalty_factor = np.clip(item / (avg_remaining_capacity + 0.0001), 0.0, 1.0)\n    fragmentation_penalty = np.zeros_like(bins_remain_cap, dtype=float)\n    fragmentation_penalty[feasible_bins] = (item - bins_remain_cap[feasible_bins]) * frag_penalty_factor # Consider item size compared to bin capacity\n    fragmentation_penalty[fragmentation_penalty > 0] *= -1 # Make it a penalty\n    priorities += fragmentation_penalty\n\n    # Target remaining capacity: Add bonus if the bin remains within some desired capacity\n    target_capacity = 0.25  # Aim for remaining capacity around 25% of bin size\n    capacity_diff = np.abs(remaining_capacity_after_placement - target_capacity)\n    capacity_bonus = np.zeros_like(bins_remain_cap, dtype=float)\n    capacity_bonus[feasible_bins] = np.exp(-capacity_diff[feasible_bins]) # Exponential decay\n\n    priorities += capacity_bonus\n\n    # Adaptive weights: Scale priorities based on remaining bin capacities\n    # Bins with more capacity may prefer a slight preference for less full bins\n    capacity_weight = bins_remain_cap / np.max(bins_remain_cap)\n    priorities *= (1.0 + 0.1 * capacity_weight)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 37.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 572.79204545632,
    "mi": 76.03969641423191,
    "token_count": 331.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill rate with remaining capacity & adds almost full incentive.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities\n\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1\n\n    # Fill rate component\n    fill_rate = item / bins_remain_cap[feasible_bins]\n    priorities[feasible_bins] = fill_rate\n\n    # Remaining capacity component, avoid division by zero\n    priorities[feasible_bins] += 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001)\n\n    # Almost full incentive\n    almost_full_threshold = 0.1\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 3.0\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 109.80793556946902,
    "mi": 89.59072148726509,
    "token_count": 121.0,
    "exec_success": true
  }
]