{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, target capacity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Target remaining capacity: penalize bins far from target\n    target_capacity = 0.2 * np.max(bins_remain_cap) #tunable\n    capacity_diff = np.abs(bins_remain_cap[feasible_bins] - target_capacity)\n    priorities[feasible_bins] -= 0.05 * capacity_diff #tunable\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.01 * fullness_factor #tunable\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, target capacity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Target remaining capacity: penalize bins far from target\n    target_capacity = 0.2 * np.max(bins_remain_cap) #tunable\n    capacity_diff = np.abs(bins_remain_cap[feasible_bins] - target_capacity)\n    priorities[feasible_bins] -= 0.05 * capacity_diff #tunable\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.01 * fullness_factor #tunable\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, target capacity.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Target remaining capacity: penalize bins far from target\n    target_capacity = 0.2 * np.max(bins_remain_cap) #tunable\n    capacity_diff = np.abs(bins_remain_cap[feasible_bins] - target_capacity)\n    priorities[feasible_bins] -= 0.05 * capacity_diff #tunable\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.01 * fullness_factor #tunable\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)  # Initialize with -inf for infeasible bins\n\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # All bins are infeasible\n\n    priorities[feasible_bins] = 0.0  # Reset feasible bins to a base priority of 0\n\n    remaining_capacity_after_placement = bins_remain_cap[feasible_bins] - item\n\n\n    # Define an ideal remaining capacity.  This is a crucial parameter.\n    # Let's start with aiming for a small, non-zero ideal.\n    ideal_remaining_capacity = 0.1 # was 0.2\n\n    # Calculate the deviation from the ideal remaining capacity.  Smaller is better.\n    deviation = np.abs(remaining_capacity_after_placement - ideal_remaining_capacity)\n\n    # Use the inverse of the deviation as the priority.\n    priorities[feasible_bins] = 1.0 / (deviation + 0.00001)  # Avoid division by zero\n\n    # Add a bonus for bins that would be nearly full after placement.\n    almost_full_threshold = 0.05  # Reduce it to 5%\n    almost_full_bins = (remaining_capacity_after_placement <= almost_full_threshold)\n    priorities[feasible_bins][almost_full_bins] += 5.0 # was 5.0\n\n    # Slightly penalize bins that have a very large remaining capacity. This discourages putting small\n    # items into almost empty bins. Avoids fragmentation.\n    large_capacity_threshold = 0.75\n    large_capacity_bins = bins_remain_cap[feasible_bins] > large_capacity_threshold\n    priorities[feasible_bins][large_capacity_bins] -= 1.0 # was 2.0\n\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, considers fullness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.1 * fullness_factor\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, considers fullness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.1 * fullness_factor\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins: avoids infeasibility, minimizes waste, considers fullness.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -np.inf\n\n    feasible_bins = ~infeasible_bins\n    wasted_space = bins_remain_cap[feasible_bins] - item\n    priorities[feasible_bins] = -wasted_space # Lower waste is better\n\n    # Encourage filling: slightly prioritize bins that are already somewhat full\n    fullness_factor = 1.0 / (bins_remain_cap[feasible_bins] + 1e-9)\n    priorities[feasible_bins] += 0.1 * fullness_factor\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n    # Calculate remaining capacity AFTER placing the item (if possible)\n    remaining_capacity_after_placement = bins_remain_cap - item\n    remaining_capacity_after_placement[remaining_capacity_after_placement < 0] = -1  # Handle infeasible bins without np.inf\n\n    # Prioritize bins with smaller remaining space AFTER placement.\n    # This encourages filling bins completely.\n    # Also, penalize nearly-full bins more heavily. A slight margin may be desirable to accommodate future items.\n\n    priorities[feasible_bins] = 1.0 / (remaining_capacity_after_placement[feasible_bins] + 0.00001) # Avoid division by zero\n\n    # Boost priority of bins that are close to being full, but only if feasible.\n    almost_full_threshold = 0.1  # e.g., within 10% of item's size. Fine-tune this parameter\n    almost_full_bins = feasible_bins & (bins_remain_cap < item + almost_full_threshold * item)\n    priorities[almost_full_bins] += 5.0  # A larger value to significantly increase the priority\n\n    # Very small capacity bins are penalized harshly but not excluded\n    # Penalizes fragmented fills and may create bin almost full but not full\n    small_capacity_threshold = 0.2\n    small_capacity_bins = feasible_bins & (bins_remain_cap < small_capacity_threshold)\n    priorities[small_capacity_bins] -= 2.0\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.037257819812672566, almost_full_boost: float = 8.60987061574142, small_capacity_threshold: float = 0.40566790926186397, small_capacity_penalty: float = -3.8015043133432296, division_eps: float = 1.6923976863561945e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        almost_full_threshold: Threshold for considering a bin almost full (as a fraction of item size).\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold for considering a bin small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n        division_eps: Epsilon value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                division_eps: float = 9.732649023819426e-05, \n                almost_full_threshold: float = 0.05514897036630821, \n                almost_full_boost: float = 1.9525194226244666, \n                small_capacity_threshold: float = 0.18891923904093197, \n                small_capacity_penalty: float = -0.8401090186751627) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        division_eps: Epsilon value to avoid division by zero.\n        almost_full_threshold: Threshold (as a fraction of item size) to consider a bin \"almost full\".\n        almost_full_boost: Priority boost for \"almost full\" bins.\n        small_capacity_threshold: Threshold for \"small capacity\" bins.\n        small_capacity_penalty: Penalty for \"small capacity\" bins.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.037257819812672566, almost_full_boost: float = 8.60987061574142, small_capacity_threshold: float = 0.40566790926186397, small_capacity_penalty: float = -3.8015043133432296, division_eps: float = 1.6923976863561945e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        almost_full_threshold: Threshold for considering a bin almost full (as a fraction of item size).\n        almost_full_boost: Priority boost for almost full bins.\n        small_capacity_threshold: Threshold for considering a bin small capacity.\n        small_capacity_penalty: Priority penalty for small capacity bins.\n        division_eps: Epsilon value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., all zeros)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Filter bins that can actually accommodate the item\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        # No bin can fit the item. Return low priorities for all. Avoid errors.\n        return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}