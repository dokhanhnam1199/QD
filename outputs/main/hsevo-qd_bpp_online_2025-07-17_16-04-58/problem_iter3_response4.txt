```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins based on a combination of factors:
    1. Ability to accommodate the item.
    2. Closeness to an "ideal" remaining capacity after placement.
    3. Penalties for excessive fragmentation or near-empty bins.
    4. Introducing randomness for exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities

    remaining_capacity_after_placement = bins_remain_cap - item
    remaining_capacity_after_placement[~feasible_bins] = np.inf # Mark infeasible bins with positive infinity.

    # Define an "ideal" remaining capacity.  Here, we'll start with trying to minimize fragmentation.
    ideal_remaining_capacity = 0.0  # Try to fill bins as much as possible.

    # Calculate the deviation from the ideal.  Smaller deviation is better.
    deviation_from_ideal = np.abs(remaining_capacity_after_placement - ideal_remaining_capacity)

    # Assign priorities based on the deviation.  Invert the deviation to make smaller deviations higher priority.
    priorities[feasible_bins] = 1.0 / (deviation_from_ideal[feasible_bins] + 0.00001) # Avoid division by zero

    # Penalize bins that would become nearly empty after placing the item.
    near_empty_threshold = 0.8 # if the remaining capacity of bin is above 80% capacity.
    near_empty_bins = feasible_bins & (remaining_capacity_after_placement > near_empty_threshold)
    priorities[near_empty_bins] -= 3.0 # Harsh penalty for creating nearly empty bins.

    # Introduce a small amount of randomness to encourage exploration.
    priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1

    return priorities
```
