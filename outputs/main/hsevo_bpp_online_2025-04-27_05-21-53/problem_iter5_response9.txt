```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines snug fit, balanced utilization, and adaptive penalties.
    Prioritizes partially filled bins and avoids near overflows, adjust penalty thresholds adaptively.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities

    # 1. Snug Fit Score
    remaining_capacity = bins_remain_cap[feasible_bins] - item
    utilization = item / bins_remain_cap[feasible_bins]
    snug_fit_score = 1.0 - (remaining_capacity / bins_remain_cap[feasible_bins])
    priorities[feasible_bins] += 2 * snug_fit_score

    # 2. Balanced Utilization - Adaptive Target
    current_avg_utilization = np.mean(1 - bins_remain_cap[bins_remain_cap > 0] / np.max(bins_remain_cap)) if np.any(bins_remain_cap > 0) else 0.5
    target_utilization = min(0.8, current_avg_utilization + 0.1)
    expected_utilization = (bins_remain_cap[feasible_bins] - remaining_capacity) / bins_remain_cap[feasible_bins]
    balanced_utilization_score = np.exp(-((expected_utilization - target_utilization)**2) / 0.02)
    priorities[feasible_bins] += 3 * balanced_utilization_score

    # 3. Adaptive Near-Perfect Fit Penalty
    near_perfect_fit_threshold = 0.05 * np.max(bins_remain_cap)
    near_perfect_fit = (remaining_capacity > 0) & (remaining_capacity <= near_perfect_fit_threshold)
    priorities[feasible_bins][near_perfect_fit] -= 5

    # 4. Adaptive Small Remainder Penalty
    small_remainder_threshold = 0.15 * np.max(bins_remain_cap)
    small_remainder = (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold)
    priorities[feasible_bins][small_remainder] -= 3

    # 5. Partially Filled Bonus
    already_filled_threshold_low = 0.2 * np.max(bins_remain_cap)
    already_filled_threshold_high = 0.9 * np.max(bins_remain_cap)
    already_filled = (bins_remain_cap[feasible_bins] > already_filled_threshold_low) & (bins_remain_cap[feasible_bins] < already_filled_threshold_high)
    priorities[feasible_bins][already_filled] += 1

    # 6. Perfect Fit Bonus
    perfect_fit = np.abs(remaining_capacity) < 1e-6
    priorities[feasible_bins][perfect_fit] += 100
    return priorities
```
