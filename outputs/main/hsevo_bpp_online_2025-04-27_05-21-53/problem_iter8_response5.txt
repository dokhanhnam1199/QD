```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                 exploration_weight: float = 0.3,
                 almost_full_boost: float = 2.0,
                 small_remainder_penalty: float = 1.0,
                 near_perfect_fit_penalty: float = 1.5,
                 moderate_fit_bonus: float = 0.9,
                 almost_full_threshold: float = 0.07,
                 small_remainder_threshold: float = 0.025,
                 near_perfect_fit_threshold: float = 0.045,
                 moderate_fit_threshold_low: float = 0.34,
                 moderate_fit_threshold_high: float = 0.78,
                 capacity_usage_exponent: float = 1.5,
                 large_item_penalty: float = 0.5,
                 large_item_threshold: float = 0.8,
                 bin_diversity_penalty: float = 0.5,
                 random_factor: float = 0.01) -> np.ndarray:
    """Combines utilization, exploration, fragmentation penalties, diversity and item size awareness."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Base Priority: Bin Utilization
        utilization = (item / bins_remain_cap) ** capacity_usage_exponent
        priorities[feasible_bins] += utilization[feasible_bins]

        # 2. Encourage Exploration
        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))
        priorities[feasible_bins] += exploration_weight * exploration_factor

        # 3. Fill-Optimization
        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
        priorities[almost_full] += almost_full_boost

        # 4. Fragmentation Penalty
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= small_remainder_penalty

        # 5. Near-Perfect Fit Penalty
        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
        priorities[near_perfect_fit] -= near_perfect_fit_penalty

        # 6. Moderate-Fit Bonus
        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit
        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)
        priorities[moderate_fit] += moderate_fit_bonus

        # 7. Large Item Penalty
        if item > large_item_threshold:
            priorities[feasible_bins] -= large_item_penalty

        # 8. Bin Diversity Penalty
        filled_bins = bins_remain_cap < 1
        if np.sum(filled_bins) > 1:
            filled_bin_utilizations = 1 - bins_remain_cap[filled_bins]
            utilization_std = np.std(filled_bin_utilizations)
            priorities[feasible_bins] -= bin_diversity_penalty / (utilization_std + 1e-6)

        # 9. Stochastic Element
        priorities[feasible_bins] += random_factor * np.random.rand(np.sum(feasible_bins))

    return priorities
```
