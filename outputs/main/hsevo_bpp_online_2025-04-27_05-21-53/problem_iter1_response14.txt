```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    A good heuristic will try to balance bin utilization. It should penalize
    bins with very little remaining capacity more heavily than those that have
    sufficient capacity. It also favors bins that result in a capacity usage
    close to a specific target (e.g., filling bins to be nearly full).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Initialize with a very low value if the item doesn't fit
    priorities[bins_remain_cap < item] = -np.inf

    # Encourage bins that can accommodate the item. A large negative number.
    # target_fill = 0.9  # Attempt to fill bins to approximately 90% capacity
    # Penalize bins with excessive or minimal space after insertion
    for i in range(len(bins_remain_cap)):
      if bins_remain_cap[i] >= item:
        new_cap = bins_remain_cap[i] - item
        priorities[i] = (1 / (abs(new_cap - item/2 + 0.0001))) # Favor bins with remaining close to half the item

        # Give highest priority to bin with tightest fit
        if (bins_remain_cap == item).any():
           index = np.where(bins_remain_cap == item)
           priorities[index] = np.inf
        # Encourage full usage
        elif bins_remain_cap[i] == item:
            priorities[i] = np.inf


    return priorities
```
