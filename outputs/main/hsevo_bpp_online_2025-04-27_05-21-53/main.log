[2025-04-27 05:21:53,851][root][INFO] - Workspace: C:\Users\Nam\Documents\GitHub\HSEvo\outputs\main\hsevo_bpp_online_2025-04-27_05-21-53
[2025-04-27 05:21:53,851][root][INFO] - Project Root: C:\Users\Nam\Documents\GitHub\HSEvo
[2025-04-27 05:21:53,852][root][INFO] - Using LLM: gemini/gemini-2.0-flash
[2025-04-27 05:21:53,852][root][INFO] - Using Algorithm: hsevo
[2025-04-27 05:21:55,989][httpx][INFO] - HTTP Request: GET https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json "HTTP/1.1 200 OK"
[2025-04-27 05:21:57,793][root][INFO] - Problem: bpp_online
[2025-04-27 05:21:57,794][root][INFO] - Problem description: Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
[2025-04-27 05:21:57,799][root][INFO] - Function name: priority
[2025-04-27 05:21:57,800][root][INFO] - Evaluating seed function...
[2025-04-27 05:21:57,800][root][INFO] - Seed function code: 
import numpy as np
import random
import math
import scipy
import torch
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities
[2025-04-27 05:21:57,801][root][INFO] - Iteration 0: Running Code 0
[2025-04-27 05:21:59,582][root][INFO] - Iteration 0: Code Run 0 successful!
[2025-04-27 05:22:00,877][root][INFO] - Iteration 0, response_id 0: Objective value: 149.30195452732352
[2025-04-27 05:22:00,878][root][INFO] - Iteration 0: Elitist: 149.30195452732352
[2025-04-27 05:22:00,878][root][INFO] - Iteration 0 finished...
[2025-04-27 05:22:00,878][root][INFO] - Best obj: 149.30195452732352, Best Code Path: problem_iter0_code0.py
[2025-04-27 05:22:00,879][root][INFO] - LLM usage: prompt_tokens = 0, completion_tokens = 0
[2025-04-27 05:22:00,879][root][INFO] - Function Evals: 1
[2025-04-27 05:22:00,879][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,881][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,883][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,886][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,888][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,889][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,891][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,892][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,893][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,894][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,897][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,899][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,901][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,904][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,906][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,912][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,915][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,916][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,918][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,919][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,921][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,922][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Albert Einstein, relativity theory developer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,924][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Isaac Newton, the father of physics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Isaac Newton, the father of physics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,925][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Marie Curie, pioneer in radioactivity. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,927][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Nikola Tesla, master of electricity. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Nikola Tesla, master of electricity. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,928][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Galileo Galilei, champion of heliocentrism. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,929][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Stephen Hawking, black hole theorist. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,931][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Richard Feynman, quantum mechanics genius. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,934][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Rosalind Franklin, DNA structure revealer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,935][root][INFO] - Initial Population Prompt: 
System Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are Ada Lovelace, computer programming pioneer. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.

def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    ratios = item / bins_remain_cap
    log_ratios = np.log(ratios)
    priorities = -log_ratios
    return priorities

Refer to the format of a trivial design above. Be very creative and give `priority_v2`. Output code only and enclose your code with Python code block: ```python ... ```.

[2025-04-27 05:22:00,959][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:00,959][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:03,961][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:03,964][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:03,966][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:03,967][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:03,969][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:03,972][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:06,845][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:06,851][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:06,852][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:06,853][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:06,855][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:06,855][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:07,000][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:07,002][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:07,003][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:07,003][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:07,005][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:07,006][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:10,330][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:10,333][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:10,334][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:10,334][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:10,337][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:10,339][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:11,530][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:11,534][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:11,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:11,535][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:11,537][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:11,539][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:14,140][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:14,143][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:14,144][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:14,144][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:14,147][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:14,149][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:15,178][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:15,181][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:15,182][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:15,183][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:15,185][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:15,187][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:18,422][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:18,425][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:18,426][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:18,426][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:18,428][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:18,429][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:19,333][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:19,337][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:19,338][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:19,338][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:19,342][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:19,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:22,186][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:22,189][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:22,190][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:22,190][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:22,192][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:22,193][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:22,477][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:22,478][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:22,479][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:22,479][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:22,480][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:22,482][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:26,415][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:26,419][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:26,420][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:26,420][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:26,423][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:26,424][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:26,503][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:26,505][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:26,506][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:26,506][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:26,508][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:26,509][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:30,206][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:30,212][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:30,213][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:30,214][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:30,216][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:30,217][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:31,081][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:31,084][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:31,085][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:31,085][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:31,087][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:31,088][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:32,080][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:32,098][root][INFO] - Attempt 1 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "model": "gemini-2.0-flash",
              "location": "global"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "20s"
      }
    ]
  }
}

[2025-04-27 05:22:34,454][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:34,457][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:34,458][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:34,458][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:34,460][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:34,462][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:35,101][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:36,135][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:36,150][root][INFO] - Attempt 1 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "model": "gemini-2.0-flash",
              "location": "global"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "16s"
      }
    ]
  }
}

[2025-04-27 05:22:36,829][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:36,844][root][INFO] - Attempt 2 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "model": "gemini-2.0-flash",
              "location": "global"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "15s"
      }
    ]
  }
}

[2025-04-27 05:22:39,152][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:39,846][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:40,021][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:40,031][root][INFO] - Attempt 2 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "12s"
      }
    ]
  }
}

[2025-04-27 05:22:41,482][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:41,508][root][INFO] - Attempt 3 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "11s"
      }
    ]
  }
}

[2025-04-27 05:22:43,033][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:43,903][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:43,926][root][INFO] - Attempt 3 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "8s"
      }
    ]
  }
}

[2025-04-27 05:22:44,510][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:45,549][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 429 Too Many Requests"
[2025-04-27 05:22:45,564][root][INFO] - Attempt 4 failed with error: litellm.RateLimitError: litellm.RateLimitError: VertexAIException - {
  "error": {
    "code": 429,
    "message": "You exceeded your current quota, please check your plan and billing details. For more information on this error, head to: https://ai.google.dev/gemini-api/docs/rate-limits.",
    "status": "RESOURCE_EXHAUSTED",
    "details": [
      {
        "@type": "type.googleapis.com/google.rpc.QuotaFailure",
        "violations": [
          {
            "quotaMetric": "generativelanguage.googleapis.com/generate_content_free_tier_requests",
            "quotaId": "GenerateRequestsPerMinutePerProjectPerModel-FreeTier",
            "quotaDimensions": {
              "location": "global",
              "model": "gemini-2.0-flash"
            },
            "quotaValue": "15"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.Help",
        "links": [
          {
            "description": "Learn more about Gemini API quotas",
            "url": "https://ai.google.dev/gemini-api/docs/rate-limits"
          }
        ]
      },
      {
        "@type": "type.googleapis.com/google.rpc.RetryInfo",
        "retryDelay": "7s"
      }
    ]
  }
}

[2025-04-27 05:22:46,929][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:48,566][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:52,178][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:52,181][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:52,183][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:52,183][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:52,184][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:52,185][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:52,508][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:52,513][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:52,514][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:52,514][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:52,515][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:52,516][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:55,162][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:55,165][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:55,166][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:55,166][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:55,169][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:55,170][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:56,296][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:56,300][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:56,301][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:56,301][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:56,304][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:56,306][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:59,300][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:59,303][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:59,304][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:59,304][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:59,307][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:59,308][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:59,642][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:22:59,644][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:22:59,645][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:59,645][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:22:59,645][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:22:59,646][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:03,550][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:03,553][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:03,554][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:03,555][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:03,558][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:23:03,559][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:03,664][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:03,666][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:03,667][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:03,667][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:03,668][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:23:03,668][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:08,250][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:08,253][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:08,255][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:08,255][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:08,257][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:23:08,259][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:08,309][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:08,311][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:08,312][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:08,312][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:08,314][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:23:08,315][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:12,056][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:12,060][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:12,061][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:12,061][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:12,063][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:23:12,065][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:12,527][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:12,529][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:12,530][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:12,530][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:12,532][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:23:12,533][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,194][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:16,197][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:16,198][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,198][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,199][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,671][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:23:16,674][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:23:16,675][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,676][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,681][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:23:16,742][root][INFO] - Iteration 1: Running Code 0
[2025-04-27 05:23:16,888][root][INFO] - Iteration 1: Code Run 0 successful!
[2025-04-27 05:23:16,889][root][INFO] - Iteration 1: Running Code 1
[2025-04-27 05:23:17,047][root][INFO] - Iteration 1: Code Run 1 successful!
[2025-04-27 05:23:17,047][root][INFO] - Iteration 1: Running Code 2
[2025-04-27 05:23:17,189][root][INFO] - Iteration 1: Code Run 2 successful!
[2025-04-27 05:23:17,189][root][INFO] - Iteration 1: Running Code 3
[2025-04-27 05:23:17,347][root][INFO] - Iteration 1: Code Run 3 successful!
[2025-04-27 05:23:17,347][root][INFO] - Iteration 1: Running Code 4
[2025-04-27 05:23:17,507][root][INFO] - Iteration 1: Code Run 4 successful!
[2025-04-27 05:23:17,507][root][INFO] - Iteration 1: Running Code 5
[2025-04-27 05:23:17,666][root][INFO] - Iteration 1: Code Run 5 successful!
[2025-04-27 05:23:17,666][root][INFO] - Iteration 1: Running Code 6
[2025-04-27 05:23:17,852][root][INFO] - Iteration 1: Code Run 6 successful!
[2025-04-27 05:23:17,852][root][INFO] - Iteration 1: Running Code 7
[2025-04-27 05:23:18,025][root][INFO] - Iteration 1: Code Run 7 successful!
[2025-04-27 05:23:18,026][root][INFO] - Iteration 1: Running Code 8
[2025-04-27 05:23:18,204][root][INFO] - Iteration 1: Code Run 8 successful!
[2025-04-27 05:23:18,204][root][INFO] - Iteration 1: Running Code 9
[2025-04-27 05:23:18,396][root][INFO] - Iteration 1: Code Run 9 successful!
[2025-04-27 05:23:18,397][root][INFO] - Iteration 1: Running Code 10
[2025-04-27 05:23:18,969][root][INFO] - Iteration 1: Code Run 10 successful!
[2025-04-27 05:23:18,971][root][INFO] - Iteration 1: Running Code 11
[2025-04-27 05:23:19,541][root][INFO] - Iteration 1: Code Run 11 successful!
[2025-04-27 05:23:19,573][root][INFO] - Iteration 1: Running Code 12
[2025-04-27 05:23:20,010][root][INFO] - Iteration 1: Code Run 12 successful!
[2025-04-27 05:23:20,012][root][INFO] - Iteration 1: Running Code 13
[2025-04-27 05:23:20,586][root][INFO] - Iteration 1: Code Run 13 successful!
[2025-04-27 05:23:20,595][root][INFO] - Iteration 1: Running Code 14
[2025-04-27 05:23:21,282][root][INFO] - Iteration 1: Code Run 14 successful!
[2025-04-27 05:23:21,316][root][INFO] - Iteration 1: Running Code 15
[2025-04-27 05:23:22,246][root][INFO] - Iteration 1: Code Run 15 successful!
[2025-04-27 05:23:22,272][root][INFO] - Iteration 1: Running Code 16
[2025-04-27 05:23:23,274][root][INFO] - Iteration 1: Code Run 16 successful!
[2025-04-27 05:23:23,312][root][INFO] - Iteration 1: Running Code 17
[2025-04-27 05:23:24,206][root][INFO] - Iteration 1: Code Run 17 successful!
[2025-04-27 05:23:24,227][root][INFO] - Iteration 1: Running Code 18
[2025-04-27 05:23:25,353][root][INFO] - Iteration 1: Code Run 18 successful!
[2025-04-27 05:23:25,353][root][INFO] - Iteration 1: Running Code 19
[2025-04-27 05:23:26,335][root][INFO] - Iteration 1: Code Run 19 successful!
[2025-04-27 05:23:26,361][root][INFO] - Iteration 1: Running Code 20
[2025-04-27 05:23:27,066][root][INFO] - Iteration 1: Code Run 20 successful!
[2025-04-27 05:23:27,100][root][INFO] - Iteration 1: Running Code 21
[2025-04-27 05:23:28,098][root][INFO] - Iteration 1: Code Run 21 successful!
[2025-04-27 05:23:28,130][root][INFO] - Iteration 1: Running Code 22
[2025-04-27 05:23:28,998][root][INFO] - Iteration 1: Code Run 22 successful!
[2025-04-27 05:23:29,044][root][INFO] - Iteration 1: Running Code 23
[2025-04-27 05:23:30,028][root][INFO] - Iteration 1: Code Run 23 successful!
[2025-04-27 05:23:30,091][root][INFO] - Iteration 1: Running Code 24
[2025-04-27 05:23:31,115][root][INFO] - Iteration 1: Code Run 24 successful!
[2025-04-27 05:23:31,150][root][INFO] - Iteration 1: Running Code 25
[2025-04-27 05:23:33,324][root][INFO] - Iteration 1: Code Run 25 successful!
[2025-04-27 05:23:33,372][root][INFO] - Iteration 1: Running Code 26
[2025-04-27 05:23:35,415][root][INFO] - Iteration 1: Code Run 26 successful!
[2025-04-27 05:23:35,435][root][INFO] - Iteration 1: Running Code 27
[2025-04-27 05:23:37,762][root][INFO] - Iteration 1: Code Run 27 successful!
[2025-04-27 05:23:37,823][root][INFO] - Iteration 1: Running Code 28
[2025-04-27 05:23:39,435][root][INFO] - Iteration 1: Code Run 28 successful!
[2025-04-27 05:23:39,482][root][INFO] - Iteration 1: Running Code 29
[2025-04-27 05:23:41,385][root][INFO] - Iteration 1: Code Run 29 successful!
[2025-04-27 05:23:41,406][root][INFO] - Iteration 1, response_id 0: Objective value: 4.048663741523748
[2025-04-27 05:23:41,442][root][INFO] - Iteration 1, response_id 1: Objective value: 5.005983246908661
[2025-04-27 05:23:41,459][root][INFO] - Iteration 1, response_id 2: Objective value: 4.048663741523748
[2025-04-27 05:23:41,495][root][INFO] - Iteration 1, response_id 3: Objective value: inf
[2025-04-27 05:23:41,521][root][INFO] - Iteration 1, response_id 4: Objective value: inf
[2025-04-27 05:23:41,541][root][INFO] - Iteration 1, response_id 5: Objective value: 4.048663741523748
[2025-04-27 05:23:41,562][root][INFO] - Iteration 1, response_id 6: Objective value: 4.048663741523748
[2025-04-27 05:23:41,591][root][INFO] - Iteration 1, response_id 7: Objective value: inf
[2025-04-27 05:23:41,671][root][INFO] - Iteration 1, response_id 8: Objective value: 4.487435181491823
[2025-04-27 05:24:31,734][root][INFO] - Error for response_id 9: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.999997100001565 seconds
[2025-04-27 05:24:59,991][root][INFO] - Iteration 1, response_id 10: Objective value: 4.487435181491823
[2025-04-27 05:25:00,015][root][INFO] - Iteration 1, response_id 11: Objective value: 4.048663741523748
[2025-04-27 05:25:50,028][root][INFO] - Error for response_id 12: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.99999620000017 seconds
[2025-04-27 05:25:50,030][root][INFO] - Iteration 1, response_id 13: Objective value: 4.048663741523748
[2025-04-27 05:26:40,039][root][INFO] - Error for response_id 14: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.99999750000097 seconds
[2025-04-27 05:27:30,053][root][INFO] - Error for response_id 15: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.999997099999746 seconds
[2025-04-27 05:27:30,069][root][INFO] - Iteration 1, response_id 16: Objective value: 4.836457917830076
[2025-04-27 05:27:30,071][root][INFO] - Iteration 1, response_id 17: Objective value: 4.048663741523748
[2025-04-27 05:27:30,072][root][INFO] - Iteration 1, response_id 18: Objective value: 4.048663741523748
[2025-04-27 05:28:20,080][root][INFO] - Error for response_id 19: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.99999770000068 seconds
[2025-04-27 05:28:20,083][root][INFO] - Iteration 1, response_id 20: Objective value: 86.58755484643
[2025-04-27 05:29:10,095][root][INFO] - Error for response_id 21: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.99999430000025 seconds
[2025-04-27 05:29:10,097][root][INFO] - Iteration 1, response_id 22: Objective value: 4.048663741523748
[2025-04-27 05:29:10,099][root][INFO] - Iteration 1, response_id 23: Objective value: 4.048663741523748
[2025-04-27 05:30:00,101][root][INFO] - Error for response_id 24: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.99999720000051 seconds
[2025-04-27 05:30:00,104][root][INFO] - Iteration 1, response_id 25: Objective value: 4.048663741523748
[2025-04-27 05:30:00,106][root][INFO] - Iteration 1, response_id 26: Objective value: 149.30195452732352
[2025-04-27 05:30:00,122][root][INFO] - Iteration 1, response_id 27: Objective value: 113.80135620263263
[2025-04-27 05:30:00,133][root][INFO] - Iteration 1, response_id 28: Objective value: inf
[2025-04-27 05:30:00,135][root][INFO] - Iteration 1, response_id 29: Objective value: 5.195452732349436
[2025-04-27 05:30:00,139][root][INFO] - Iteration 1: Elitist: 4.048663741523748
[2025-04-27 05:30:00,139][root][INFO] - Iteration 1 finished...
[2025-04-27 05:30:00,139][root][INFO] - Best obj: 4.048663741523748, Best Code Path: problem_iter1_code0.py
[2025-04-27 05:30:00,140][root][INFO] - LLM usage: prompt_tokens = 9528, completion_tokens = 11799
[2025-04-27 05:30:00,140][root][INFO] - Function Evals: 31
[2025-04-27 05:30:00,142][root][INFO] - Flash reflection Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.

User Prompt: 
### List heuristics
Below is a list of design heuristics ranked from best to worst.
[Heuristics 1st]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This function uses a heuristic inspired by the heliocentric model:
    bins closer in capacity to the item's size are favored, as a more harmonious "fit" is sought,
    akin to the celestial spheres finding their proper place.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the difference between the bin capacity and the item size.
    diffs = np.abs(bins_remain_cap - item)

    # Normalize the differences. A smaller difference yields a higher priority.
    # Add a small epsilon to avoid division by zero and to handle cases where item > bin cap
    epsilon = 1e-9
    priorities = 1 / (diffs + epsilon)

    # Further refine the priority: bins with sufficient capacity should have a significantly increased priority.
    # Bins that cannot contain the item receive zero priority (a 'planetary orbit' that cannot contain the object).
    sufficient_capacity = bins_remain_cap >= item
    priorities = np.where(sufficient_capacity, priorities * (1 + (bins_remain_cap - item) / bins_remain_cap) , 0) # Scale priority by percentage filled if valid

    return priorities

[Heuristics 2nd]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Bins that can't fit get a negative infinite priority
    priorities = np.where(bins_remain_cap < item, -np.inf, 0)

    # For bins that can fit, prioritize those with smallest remaining capacity *after* packing the item. This approximates minimizing wasted space *locally*.

    possible_bins = bins_remain_cap[bins_remain_cap >= item]
    post_fill_waste = possible_bins - item

    #Use Newton's law of cooling analogy. Larger temperature differences(bins with little space after adding the item) should be cooled down quickly(higher priority).
    # We invert it, so the colder temp gets larger values
    priorities[bins_remain_cap >= item] = -post_fill_waste

    #Add a small bias to partially filled bins to encourage them being completely full
    priorities[bins_remain_cap >= item] += 0.01*(bins_remain_cap[bins_remain_cap >= item]/ np.max(bins_remain_cap)) # add a fraction of the remaining capacity compared to maximum capacity to all bins

    return priorities

[Heuristics 3rd]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # A bin is viable only if it has enough capacity for the item.
    viable_bins = bins_remain_cap >= item
    if not np.any(viable_bins):
      return priorities # If no bin can fit, return all zeros

    # Calculate the remaining capacity after adding the item to each viable bin.
    remaining_capacities = bins_remain_cap - item
    remaining_capacities[remaining_capacities < 0 ] = 0 # setting non-viable bins cap to zero, needed for division
    
    # Calculate a "fullness" score for each viable bin.  Bins that are fuller (closer to full) are penalized.
    # Avoid division by zero
    with np.errstate(divide='ignore', invalid='ignore'):  # Handle potential divide by zero. Set invalid to ignore will give us nan, which are handled below
      fullness_scores = np.where(bins_remain_cap > 0, (bins_remain_cap - item) / bins_remain_cap, 0) # remaining capacity / initial capacity
    fullness_scores = np.nan_to_num(fullness_scores, nan=1.0, posinf = 1.0, neginf = 1.0)
    # Bins that are close to full (smaller relative wasted space) should be prioritized.

    priorities = np.where(viable_bins, 1.0 - fullness_scores, -np.inf) # prioritize viable bins, and discourage (but allow) packing on almost full bins
    
    return priorities

[Heuristics 4th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function incorporates a few heuristics:

    1.  **Feasibility:**  It strongly penalizes bins that are too small to hold the item.
        This avoids wasting time calculating priorities for impossible placements.

    2.  **Capacity Utilization:**  Bins closer to being full (after placing the item)
        are preferred.  This encourages filling bins completely.  We use a scaled
        exponential function to capture this effect - small changes near full
        capacity yield large priority changes.

    3.  **Fragmentation Avoidance:** Bins that have too much remaining capacity
        after adding the item are also penalized to avoid highly fragmented bins.
        The penalty scales with the amount of wasted space.
        We only apply this if a "reasonable" number of feasible bins exist.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Feasibility Check and Initial Penalty
    feasible = bins_remain_cap >= item
    priorities[~feasible] = -np.inf  # Very low priority if not feasible

    feasible_bins_count = np.sum(feasible)

    if feasible_bins_count > 0:  # Only compute if there are feasible bins

        remaining_after_placement = bins_remain_cap[feasible] - item

        # Capacity Utilization - Exponentially Prefer Near-Full Bins
        capacity_utilization = np.exp(-5 * remaining_after_placement / np.max(bins_remain_cap)) # Scale the penalty

        priorities[feasible] = capacity_utilization


        # Fragmentation Avoidance (applied only if enough choices exist to avoid being stuck)
        if feasible_bins_count > 2 :  # Threshold adjusted for different size datasets
            waste_penalty = np.zeros_like(remaining_after_placement)
            large_waste = remaining_after_placement > 0.5 * np.max(bins_remain_cap)
            waste_penalty[large_waste] = -0.1 * remaining_after_placement[large_waste] # Penalize large waste

            priorities[feasible] += waste_penalty

    return priorities

[Heuristics 5th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function incorporates a few heuristics:

    1.  **Feasibility:**  It strongly penalizes bins that are too small to hold the item.
        This avoids wasting time calculating priorities for impossible placements.

    2.  **Capacity Utilization:**  Bins closer to being full (after placing the item)
        are preferred.  This encourages filling bins completely.  We use a scaled
        exponential function to capture this effect - small changes near full
        capacity yield large priority changes.

    3.  **Fragmentation Avoidance:** Bins that have too much remaining capacity
        after adding the item are also penalized to avoid highly fragmented bins.
        The penalty scales with the amount of wasted space.
        We only apply this if a "reasonable" number of feasible bins exist.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Feasibility Check and Initial Penalty
    feasible = bins_remain_cap >= item
    priorities[~feasible] = -np.inf  # Very low priority if not feasible

    feasible_bins_count = np.sum(feasible)

    if feasible_bins_count > 0:  # Only compute if there are feasible bins

        remaining_after_placement = bins_remain_cap[feasible] - item

        # Capacity Utilization - Exponentially Prefer Near-Full Bins
        capacity_utilization = np.exp(-5 * remaining_after_placement / np.max(bins_remain_cap)) # Scale the penalty

        priorities[feasible] = capacity_utilization


        # Fragmentation Avoidance (applied only if enough choices exist to avoid being stuck)
        if feasible_bins_count > 2 :  # Threshold adjusted for different size datasets
            waste_penalty = np.zeros_like(remaining_after_placement)
            large_waste = remaining_after_placement > 0.5 * np.max(bins_remain_cap)
            waste_penalty[large_waste] = -0.1 * remaining_after_placement[large_waste] # Penalize large waste

            priorities[feasible] += waste_penalty

    return priorities

[Heuristics 6th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers:
    1. The wasted space if the item is added to the bin (smaller wasted space is better).
    2. A preference for bins that are already somewhat full. This encourages filling bins more completely.
    3. A large penalty for bins that are too small to hold the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, cap in enumerate(bins_remain_cap):
        if cap < item:
            # Large negative priority if item doesn't fit.  Think of this as an infinite cost to overflowing a bin.
            priorities[i] = -np.inf
        else:
            wasted_space = cap - item
            # Favor bins with less wasted space (negative because lower wasted space means HIGHER priority)
            priorities[i] -= wasted_space

            # Add a bonus for bins that are already relatively full
            #  The fuller, the better, but with diminishing returns, hence the log.
            # Avoid log(0) if item is exactly the bin capacity.
            if wasted_space > 0:
                 priorities[i] += np.log(item / cap) # Use item/cap for more resolution.
            else:
                priorities[i] += 1.0 # Max bonus if perfect fit (cap=item, wasted space is exactly 0).

    return priorities

[Heuristics 7th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Only consider bins that can fit the item.
    valid_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(valid_bins):
        # Calculate remaining capacity after placing the item.
        remaining_capacity = bins_remain_cap[valid_bins] - item

        # Give higher priority to bins with smaller remaining capacity (First Fit Decreasing principle).
        # Also, penalize bins that result in very small remaining capacity to avoid fragmentation.
        priorities[valid_bins] = (1 / (remaining_capacity + 1e-6)) - (10 * (remaining_capacity < 0.1))  # Adding small epsilon to avoid division by zero

        # Give a boost to bins that can perfectly fit the item if there are any
        perfect_fit = np.abs(remaining_capacity) < 1e-6 # Numerical Stability
        if np.any(perfect_fit):
            priorities[valid_bins][perfect_fit] += 100 # Huge Boost!

    return priorities

[Heuristics 8th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Calculate remaining capacity after adding the item
    remaining_capacity = bins_remain_cap - item
    
    # Give very low priority to bins that cannot fit the item
    priorities[remaining_capacity < 0] = -np.inf
    
    # Prioritize bins with smaller wasted space after packing
    priorities[remaining_capacity >= 0] = 1 / (remaining_capacity[remaining_capacity >= 0] + 1e-9)

    # Give higher priority to bins that are almost full after adding the item.
    almost_full_threshold = 0.1  # e.g., bin must be at least 90% full.
    almost_full = (remaining_capacity >= 0) & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
    priorities[almost_full] += 10  # Increase priority significantly

    return priorities

[Heuristics 9th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function incorporates a few heuristics:

    1.  **Feasibility:**  It strongly penalizes bins that are too small to hold the item.
        This avoids wasting time calculating priorities for impossible placements.

    2.  **Capacity Utilization:**  Bins closer to being full (after placing the item)
        are preferred.  This encourages filling bins completely.  We use a scaled
        exponential function to capture this effect - small changes near full
        capacity yield large priority changes.

    3.  **Fragmentation Avoidance:** Bins that have too much remaining capacity
        after adding the item are also penalized to avoid highly fragmented bins.
        The penalty scales with the amount of wasted space.
        We only apply this if a "reasonable" number of feasible bins exist.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Feasibility Check and Initial Penalty
    feasible = bins_remain_cap >= item
    priorities[~feasible] = -np.inf  # Very low priority if not feasible

    feasible_bins_count = np.sum(feasible)

    if feasible_bins_count > 0:  # Only compute if there are feasible bins

        remaining_after_placement = bins_remain_cap[feasible] - item

        # Capacity Utilization - Exponentially Prefer Near-Full Bins
        capacity_utilization = np.exp(-5 * remaining_after_placement / np.max(bins_remain_cap)) # Scale the penalty

        priorities[feasible] = capacity_utilization


        # Fragmentation Avoidance (applied only if enough choices exist to avoid being stuck)
        if feasible_bins_count > 2 :  # Threshold adjusted for different size datasets
            waste_penalty = np.zeros_like(remaining_after_placement)
            large_waste = remaining_after_placement > 0.5 * np.max(bins_remain_cap)
            waste_penalty[large_waste] = -0.1 * remaining_after_placement[large_waste] # Penalize large waste

            priorities[feasible] += waste_penalty

    return priorities

[Heuristics 10th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Only consider bins that can fit the item.
    valid_bins = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(valid_bins):
        # Calculate remaining capacity after placing the item.
        remaining_capacity = bins_remain_cap[valid_bins] - item

        # Give higher priority to bins with smaller remaining capacity (First Fit Decreasing principle).
        # Also, penalize bins that result in very small remaining capacity to avoid fragmentation.
        priorities[valid_bins] = (1 / (remaining_capacity + 1e-6)) - (10 * (remaining_capacity < 0.1))  # Adding small epsilon to avoid division by zero

        # Give a boost to bins that can perfectly fit the item if there are any
        perfect_fit = np.abs(remaining_capacity) < 1e-6 # Numerical Stability
        if np.any(perfect_fit):
            priorities[valid_bins][perfect_fit] += 100 # Huge Boost!

    return priorities

[Heuristics 11th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            priorities[i] = (cap - item) / cap  # Remaining capacity after packing, relative to original capacity. Higher is better.
        else:
            priorities[i] = -1  # Impossible to pack

    return priorities

[Heuristics 12th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            priorities[i] = (cap - item) / cap  # Remaining capacity after packing, relative to original capacity. Higher is better.
        else:
            priorities[i] = -1  # Impossible to pack

    return priorities

[Heuristics 13th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates a few Einstein-inspired heuristics:

    1. **Space-Time Curvature Analogy:** Smaller remaining capacity bins "attract" smaller items more strongly.  This is modeled by a higher priority for bins where the item fits relatively snugly (but still fits).

    2. **Principle of Least Action (Energy Minimization):** We prefer filling bins as completely as possible to minimize wasted space (potential energy). This is implemented by rewarding bins with remaining capacity close to the item size.

    3. **Relativistic Effect (Size Dilation):** As the item size approaches the bin capacity, the relative "difficulty" of packing increases dramatically. We model this by a term that penalizes near-overflows, especially if many near-full bins exist. This also emulates length contraction when an item is placed into bins and a contraction term will be calculated to avoid packing it into those bins.

    4. **Avoid Extreme Packing Densities:** If the bins are nearly full, apply a scaling factor to priorities based on the average fullness ratio. We prioritize dispersing the load across bins.
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # First, handle cases where item doesn't fit.
    fits = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[~fits] = -np.inf  # Very low priority for bins too small.
    if not np.any(fits):
        return priorities

    # Calculate a "snug fit" score: Reward bins where the item fits relatively well.
    snug_fit_score = (bins_remain_cap[fits] - item) / bins_remain_cap[fits]
    snug_fit_score = 1.0 - snug_fit_score  # Higher score for better fit (closer to item size)
    snug_fit_score = np.clip(snug_fit_score, 0.0, 1.0)  # Ensure values are within bounds
    priorities[fits] += snug_fit_score

    # Energy minimization: Prefer bins that get filled up nicely
    remaining_space = bins_remain_cap[fits] - item
    energy_score = np.exp(-np.abs(remaining_space) / (item + 1e-6))
    priorities[fits] += energy_score

    # Relativistic penalty for near-overflows.
    overflow_margin = 0.05 * item  # Define a small margin near overflow

    near_overflow = (bins_remain_cap[fits] - item) < overflow_margin
    if np.any(near_overflow):
        overflow_penalty = np.exp(5 * (bins_remain_cap[fits][near_overflow] - item - overflow_margin) / overflow_margin)
        priorities[fits][near_overflow] -= overflow_penalty

    #Contraction term to avoid packing item to a nearly full bin
    contraction_term = np.exp(5 * (item-bins_remain_cap[fits]))
    priorities[fits] -= contraction_term

    # Avoid Extreme Densities scaling factor
    avg_fullness = np.mean((np.sum(bins_remain_cap) - bins_remain_cap) / np.sum(bins_remain_cap))
    density_scale = 1.0 - np.clip(avg_fullness, 0.0, 0.9)  # Apply the scaling based on the range, can be between 0.1 to 1

    priorities[fits] *= density_scale # Scale priorities

    return priorities

[Heuristics 14th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates a few Einstein-inspired heuristics:

    1. **Space-Time Curvature Analogy:** Smaller remaining capacity bins "attract" smaller items more strongly.  This is modeled by a higher priority for bins where the item fits relatively snugly (but still fits).

    2. **Principle of Least Action (Energy Minimization):** We prefer filling bins as completely as possible to minimize wasted space (potential energy). This is implemented by rewarding bins with remaining capacity close to the item size.

    3. **Relativistic Effect (Size Dilation):** As the item size approaches the bin capacity, the relative "difficulty" of packing increases dramatically. We model this by a term that penalizes near-overflows, especially if many near-full bins exist. This also emulates length contraction when an item is placed into bins and a contraction term will be calculated to avoid packing it into those bins.

    4. **Avoid Extreme Packing Densities:** If the bins are nearly full, apply a scaling factor to priorities based on the average fullness ratio. We prioritize dispersing the load across bins.
    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # First, handle cases where item doesn't fit.
    fits = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[~fits] = -np.inf  # Very low priority for bins too small.
    if not np.any(fits):
        return priorities

    # Calculate a "snug fit" score: Reward bins where the item fits relatively well.
    snug_fit_score = (bins_remain_cap[fits] - item) / bins_remain_cap[fits]
    snug_fit_score = 1.0 - snug_fit_score  # Higher score for better fit (closer to item size)
    snug_fit_score = np.clip(snug_fit_score, 0.0, 1.0)  # Ensure values are within bounds
    priorities[fits] += snug_fit_score

    # Energy minimization: Prefer bins that get filled up nicely
    remaining_space = bins_remain_cap[fits] - item
    energy_score = np.exp(-np.abs(remaining_space) / (item + 1e-6))
    priorities[fits] += energy_score

    # Relativistic penalty for near-overflows.
    overflow_margin = 0.05 * item  # Define a small margin near overflow

    near_overflow = (bins_remain_cap[fits] - item) < overflow_margin
    if np.any(near_overflow):
        overflow_penalty = np.exp(5 * (bins_remain_cap[fits][near_overflow] - item - overflow_margin) / overflow_margin)
        priorities[fits][near_overflow] -= overflow_penalty

    #Contraction term to avoid packing item to a nearly full bin
    contraction_term = np.exp(5 * (item-bins_remain_cap[fits]))
    priorities[fits] -= contraction_term

    # Avoid Extreme Densities scaling factor
    avg_fullness = np.mean((np.sum(bins_remain_cap) - bins_remain_cap) / np.sum(bins_remain_cap))
    density_scale = 1.0 - np.clip(avg_fullness, 0.0, 0.9)  # Apply the scaling based on the range, can be between 0.1 to 1

    priorities[fits] *= density_scale # Scale priorities

    return priorities

[Heuristics 15th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Version 2 incorporates more nuanced considerations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Bin is large enough to accommodate the item.
            # Prioritize bins that are "almost full" after adding the item,
            # but penalize near-perfect fits to avoid creating too many bins
            # that can only hold very small items.
            new_cap = cap - item
            fill_ratio = 1 - (new_cap / cap)

            if new_cap > 0.01:  # Prevents division by zero and near-perfect fit penalty.
                priorities[i] = fill_ratio ** 2 # Square it to emphasize close fits

            else:
                 priorities[i] = -1 # Penalize bins that would have too little remaining space.


        else:
            # Bin is too small to accommodate the item. Set priority to a large negative number.
            priorities[i] = -1e9  # A very low priority to ensure it's not selected.

    return priorities

[Heuristics 16th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Version 2 incorporates more nuanced considerations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Bin is large enough to accommodate the item.
            # Prioritize bins that are "almost full" after adding the item,
            # but penalize near-perfect fits to avoid creating too many bins
            # that can only hold very small items.
            new_cap = cap - item
            fill_ratio = 1 - (new_cap / cap)

            if new_cap > 0.01:  # Prevents division by zero and near-perfect fit penalty.
                priorities[i] = fill_ratio ** 2 # Square it to emphasize close fits

            else:
                 priorities[i] = -1 # Penalize bins that would have too little remaining space.


        else:
            # Bin is too small to accommodate the item. Set priority to a large negative number.
            priorities[i] = -1e9  # A very low priority to ensure it's not selected.

    return priorities

[Heuristics 17th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers:
    1. Waste: The smaller the waste, the higher the priority.
    2. Fill Level: Prefer bins that are already somewhat full.
    3. Avoidance of Near-Full Bins: Avoid bins that will be nearly full after packing (risk of fragmentation).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate waste if the item is placed in each bin.
    waste = bins_remain_cap - item
    waste[waste < 0] = np.inf  # Mark infeasible bins as infinitely bad.

    # Normalize waste (lower waste is better).  Small values of waste should contribute heavily
    normalized_waste = np.exp(-waste)

    # Encourage filling partially filled bins.  The closer to halfway, the better.
    fill_level_priority = np.exp(-np.abs(bins_remain_cap - item - np.mean(bins_remain_cap))/np.std(bins_remain_cap)) if np.std(bins_remain_cap) > 0 else np.ones_like(bins_remain_cap)

    # Penalize bins that become very full after packing (e.g., > 90% full).
    fullness_after = (bins_remain_cap - item) / np.max(bins_remain_cap) # max capacity
    fullness_penalty = np.where(fullness_after < 0.1, -100 * (0.1-fullness_after), 0)

    # Combine the factors. Weighting is important.
    priorities = (normalized_waste * 0.6 +
                 fill_level_priority * 0.3 +
                 fullness_penalty * 0.1)

    return priorities

[Heuristics 18th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that can fit the item snugly but avoids nearly full bins unless absolutely necessary.
    It also includes a small random factor to break ties and encourage exploration of different packing configurations,
    mimicking the probabilistic nature of quantum phenomena near event horizons.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate wasted space if the item is placed in each bin.  If wasted space negative, it means item doesn't fit
    wasted_space = bins_remain_cap - item

    # Give high priority to bins where the item fits and leaves little wasted space.  Squarer the remaining space more is preferred
    fit_indices = wasted_space >= 0
    if np.any(fit_indices):
      priorities[fit_indices] = (bins_remain_cap[fit_indices] - item)**2 #Squarer the smaller space to avoid too small items or almost full bin. This is better near horizon
    else:
      # if no bins fit. Use First Fit Decreasing
      return bins_remain_cap

    # Add a small random factor to break ties and encourage exploration.
    # The magnitude of the random factor should be small compared to the typical differences in wasted space.
    priorities += np.random.rand(len(bins_remain_cap)) * 0.0001

    return priorities

[Heuristics 19th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that can fit the item snugly but avoids nearly full bins unless absolutely necessary.
    It also includes a small random factor to break ties and encourage exploration of different packing configurations,
    mimicking the probabilistic nature of quantum phenomena near event horizons.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate wasted space if the item is placed in each bin.  If wasted space negative, it means item doesn't fit
    wasted_space = bins_remain_cap - item

    # Give high priority to bins where the item fits and leaves little wasted space.  Squarer the remaining space more is preferred
    fit_indices = wasted_space >= 0
    if np.any(fit_indices):
      priorities[fit_indices] = (bins_remain_cap[fit_indices] - item)**2 #Squarer the smaller space to avoid too small items or almost full bin. This is better near horizon
    else:
      # if no bins fit. Use First Fit Decreasing
      return bins_remain_cap

    # Add a small random factor to break ties and encourage exploration.
    # The magnitude of the random factor should be small compared to the typical differences in wasted space.
    priorities += np.random.rand(len(bins_remain_cap)) * 0.0001

    return priorities

[Heuristics 20th]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that can fit the item snugly but avoids nearly full bins unless absolutely necessary.
    It also includes a small random factor to break ties and encourage exploration of different packing configurations,
    mimicking the probabilistic nature of quantum phenomena near event horizons.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate wasted space if the item is placed in each bin.  If wasted space negative, it means item doesn't fit
    wasted_space = bins_remain_cap - item

    # Give high priority to bins where the item fits and leaves little wasted space.  Squarer the remaining space more is preferred
    fit_indices = wasted_space >= 0
    if np.any(fit_indices):
      priorities[fit_indices] = (bins_remain_cap[fit_indices] - item)**2 #Squarer the smaller space to avoid too small items or almost full bin. This is better near horizon
    else:
      # if no bins fit. Use First Fit Decreasing
      return bins_remain_cap

    # Add a small random factor to break ties and encourage exploration.
    # The magnitude of the random factor should be small compared to the typical differences in wasted space.
    priorities += np.random.rand(len(bins_remain_cap)) * 0.0001

    return priorities


### Guide
- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.
- The response in Markdown style and nothing else has the following structure:
"**Analysis:**
**Experience:**"
In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-27 05:30:00,153][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:06,722][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:06,726][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:06,727][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:06,727][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:06,730][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:06,751][root][INFO] - Comprehensive reflection Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.

User Prompt: 
Your task is to redefine 'Current self-reflection' paying attention to avoid all things in 'Ineffective self-reflection' in order to come up with ideas to design better heuristics.

### Current self-reflection
When designing heuristics, consider feasibility, capacity utilization, and fragmentation. Use mathematical functions to model priorities, penalize undesirable outcomes, and add scaling factors to encourage complete filling. Regularly review and eliminate redundant code.
```
None

### Ineffective self-reflection
None

Response (<100 words) should have 4 bullet points: Keywords, Advice, Avoid, Explanation.
I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-27 05:30:06,752][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:09,827][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:09,830][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:09,831][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:09,831][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:09,835][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:09,851][root][INFO] - Crossover Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.


### Better code
def priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.
    This function uses a heuristic inspired by the heliocentric model:
    bins closer in capacity to the item's size are favored, as a more harmonious "fit" is sought,
    akin to the celestial spheres finding their proper place.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the difference between the bin capacity and the item size.
    diffs = np.abs(bins_remain_cap - item)

    # Normalize the differences. A smaller difference yields a higher priority.
    # Add a small epsilon to avoid division by zero and to handle cases where item > bin cap
    epsilon = 1e-9
    priorities = 1 / (diffs + epsilon)

    # Further refine the priority: bins with sufficient capacity should have a significantly increased priority.
    # Bins that cannot contain the item receive zero priority (a 'planetary orbit' that cannot contain the object).
    sufficient_capacity = bins_remain_cap >= item
    priorities = np.where(sufficient_capacity, priorities * (1 + (bins_remain_cap - item) / bins_remain_cap) , 0) # Scale priority by percentage filled if valid

    return priorities

### Worse code
def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Returns priority with which we want to add item to each bin.
    Version 2 incorporates more nuanced considerations.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Bin is large enough to accommodate the item.
            # Prioritize bins that are "almost full" after adding the item,
            # but penalize near-perfect fits to avoid creating too many bins
            # that can only hold very small items.
            new_cap = cap - item
            fill_ratio = 1 - (new_cap / cap)

            if new_cap > 0.01:  # Prevents division by zero and near-perfect fit penalty.
                priorities[i] = fill_ratio ** 2 # Square it to emphasize close fits

            else:
                 priorities[i] = -1 # Penalize bins that would have too little remaining space.


        else:
            # Bin is too small to accommodate the item. Set priority to a large negative number.
            priorities[i] = -1e9  # A very low priority to ensure it's not selected.

    return priorities

### Analyze & experience
- Comparing (1st) vs (20th), we see 1st uses a heliocentric model analogy, prioritizing bins closer in capacity to the item, while 20th prioritizes minimizing wasted space directly and uses a random factor. 1st normalizes differences and scales priority based on percentage filled, while 20th squares the remaining capacity.

Comparing (2nd) vs (19th), 2nd prioritizes bins with the smallest remaining capacity after packing and uses Newton's law of cooling analogy, while 19th prioritizes bins that can fit the item snugly by squaring the remaining space and adds a random factor. 2nd adds a bias to partially filled bins, and sets infeasible bins to negative infinity while 19th returns the bin capacities directly

Comparing (3rd) vs (18th), 3rd calculates fullness scores and prioritizes viable bins, discouraging almost-full bins, while 18th prioritizes bins that fit snugly, squaring the wasted space and adding a random factor. 3rd uses np.where to assign priorities and handles potential division by zero, while 18th returns bin capacities if no bins fit.

Comparing (4th) vs (17th), 4th incorporates feasibility checks, capacity utilization with exponential preference, and fragmentation avoidance, while 17th considers waste, fill level, and avoidance of near-full bins, normalizing waste and using exponentials for fill level priority. 4th penalizes fragmentation only if enough feasible bins exist. 17th uses a combination of normalized waste, fill level priority and fullness penalty, with weighting.

Comparing (5th) vs (16th), 5th duplicates the code from the 4th heuristic, which may be problematic since duplicate functions are redundant. 16th prioritizes bins that are "almost full" after adding item but penalize near-perfect fits and penalize bins that would have too little remaining space.

Comparing (6th) vs (15th), 6th calculates wasted space and adds a bonus for relatively full bins using a logarithm while 15th prioritizes bins large enough to accomodate item, prioritize "almost full" bins and penalize near-perfect fits and bins that would have too little remaining space.

Comparing (7th) vs (14th), 7th and 14th both include relativistic near-overflow penalization, however 7th has a perfect fit huge boost, while 14th has Space-Time Curvature Analogy, Principle of Least Action and Avoid Extreme Packing Densities

Comparing (8th) vs (13th), 8th prioritizes bins with smaller wasted space and gives higher priority to almost full bins after adding item while 13th also includes relativistic near-overflow penalization and Avoid Extreme Packing Densities

Comparing (9th) vs (12th), 9th duplicates the code from the 5th heuristic, which may be problematic since duplicate functions are redundant. 12th has Remaining capacity after packing relative to original capacity

Comparing (10th) vs (11th), 10th includes a perfect fit huge boost, while 11th has Remaining capacity after packing relative to original capacity

Comparing (second worst) vs (worst), we see 11th has Remaining capacity after packing relative to original capacity whereas 12th duplicates the code from the 11th heuristic, which may be problematic since duplicate functions are redundant.

Overall: The better heuristics incorporate feasibility checks, capacity utilization, and fragmentation avoidance, often using mathematical functions like exponentials and logarithms to prioritize near-full bins while penalizing excessive waste or near-overflows. The best approaches also incorporate scaling factors or biases to encourage complete filling and avoid creating bins that can only hold very small items. Poorer performing heuristics have less sophisticated logic that do not account for edge cases and duplicate code.
- 
Okay, let's redefine "Current Self-Reflection" to make it more effective for heuristic design, focusing on avoiding pitfalls and leading to better heuristics.

*   **Keywords:** Adaptive Learning, Outcome Analysis, Solution Diversity, Algorithmic Bias.
*   **Advice:** Analyze heuristic *performance* across diverse problem instances and parameter settings. Quantify solution *quality*, not just feasibility. Explicitly track *algorithmic bias* and design heuristics to mitigate it. Explore diverse solution pathways and avoid premature convergence.
*   **Avoid:** Focusing solely on mathematical models without empirical validation. Ignoring the impact of parameter tuning on heuristic performance. Neglecting the exploration of alternative solution generation strategies.
*   **Explanation:** Shift from static rules to adaptive learning from results. Validate and prevent bias. Aim for more diverse and better solutions.


Your task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
[2025-04-27 05:30:09,888][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:09,889][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:12,073][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:12,076][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:12,078][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:12,078][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:12,081][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:12,082][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:13,032][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:13,034][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:13,036][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:13,036][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:13,038][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:13,040][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:15,687][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:15,691][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:15,692][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:15,692][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:15,694][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:15,696][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:16,486][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:16,489][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:16,490][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:16,491][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:16,493][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:16,495][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:17,936][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:17,939][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:17,941][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:17,941][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:17,943][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:17,945][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:19,710][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:19,713][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:19,715][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:19,715][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:19,718][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:19,720][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:21,856][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:21,859][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:21,860][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:21,860][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:21,862][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:21,864][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:23,644][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:23,647][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:23,649][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:23,649][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:23,651][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:30:23,653][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:25,467][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:25,470][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:25,471][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:25,471][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:25,474][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:26,966][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:30:26,969][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:30:26,970][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:26,970][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:26,973][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:30:27,016][root][INFO] - Iteration 2: Running Code 0
[2025-04-27 05:30:27,188][root][INFO] - Iteration 2: Code Run 0 successful!
[2025-04-27 05:30:27,188][root][INFO] - Iteration 2: Running Code 1
[2025-04-27 05:30:27,340][root][INFO] - Iteration 2: Code Run 1 successful!
[2025-04-27 05:30:27,340][root][INFO] - Iteration 2: Running Code 2
[2025-04-27 05:30:27,505][root][INFO] - Iteration 2: Code Run 2 successful!
[2025-04-27 05:30:27,505][root][INFO] - Iteration 2: Running Code 3
[2025-04-27 05:30:27,653][root][INFO] - Iteration 2: Code Run 3 successful!
[2025-04-27 05:30:27,653][root][INFO] - Iteration 2: Running Code 4
[2025-04-27 05:30:27,821][root][INFO] - Iteration 2: Code Run 4 successful!
[2025-04-27 05:30:27,822][root][INFO] - Iteration 2: Running Code 5
[2025-04-27 05:30:27,990][root][INFO] - Iteration 2: Code Run 5 successful!
[2025-04-27 05:30:27,991][root][INFO] - Iteration 2: Running Code 6
[2025-04-27 05:30:28,182][root][INFO] - Iteration 2: Code Run 6 successful!
[2025-04-27 05:30:28,183][root][INFO] - Iteration 2: Running Code 7
[2025-04-27 05:30:28,540][root][INFO] - Iteration 2: Code Run 7 successful!
[2025-04-27 05:30:28,548][root][INFO] - Iteration 2: Running Code 8
[2025-04-27 05:30:29,085][root][INFO] - Iteration 2: Code Run 8 successful!
[2025-04-27 05:30:29,088][root][INFO] - Iteration 2: Running Code 9
[2025-04-27 05:30:30,121][root][INFO] - Iteration 2: Code Run 9 successful!
[2025-04-27 05:31:20,129][root][INFO] - Error for response_id 0: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.99999719999869 seconds
[2025-04-27 05:31:20,132][root][INFO] - Iteration 2, response_id 1: Objective value: 4.048663741523748
[2025-04-27 05:31:20,134][root][INFO] - Iteration 2, response_id 2: Objective value: 4.048663741523748
[2025-04-27 05:31:20,135][root][INFO] - Iteration 2, response_id 3: Objective value: 4.048663741523748
[2025-04-27 05:31:20,137][root][INFO] - Iteration 2, response_id 4: Objective value: 4.048663741523748
[2025-04-27 05:32:10,146][root][INFO] - Error for response_id 5: Command '['python', '-u', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo/problems/bpp_online/eval.py', '5000', 'C:\\Users\\Nam\\Documents\\GitHub\\HSEvo', 'train']' timed out after 49.999997599999915 seconds
[2025-04-27 05:32:10,148][root][INFO] - Iteration 2, response_id 6: Objective value: 4.048663741523748
[2025-04-27 05:32:10,162][root][INFO] - Iteration 2, response_id 7: Objective value: 3.819305943358592
[2025-04-27 05:32:10,164][root][INFO] - Iteration 2, response_id 8: Objective value: 4.048663741523748
[2025-04-27 05:32:10,166][root][INFO] - Iteration 2, response_id 9: Objective value: 4.048663741523748
[2025-04-27 05:32:10,168][root][INFO] - Iteration 2: Elitist: 3.819305943358592
[2025-04-27 05:32:10,169][root][INFO] - Iteration 2 finished...
[2025-04-27 05:32:10,169][root][INFO] - Best obj: 3.819305943358592, Best Code Path: problem_iter2_code7.py
[2025-04-27 05:32:10,169][root][INFO] - LLM usage: prompt_tokens = 38272, completion_tokens = 14312
[2025-04-27 05:32:10,169][root][INFO] - Function Evals: 41
[2025-04-27 05:32:10,172][root][INFO] - Mutation Prompt: 
System Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.
Your response outputs Python code and nothing else. Format your code as a Python code string: "```python ... ```".

User Prompt: 
You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.
The priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.


Current heuristics:
def priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    """Prioritizes almost full bins; penalizes near-perfect fits and small remainders."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item
    
    # Infeasible bins get lowest priority
    priorities[remaining_capacity < 0] = -np.inf
    
    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
      # Prioritize bins close to full
      almost_full_threshold = 0.1
      almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
      priorities[almost_full] += 10

      #Penalize Near-Perfect Fit.
      near_perfect_fit_threshold = 0.01
      near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
      priorities[near_perfect_fit] -= 5
        
      #Penalize small remainders to avoid fragmentation
      small_remainder_threshold = 0.2
      small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
      priorities[small_remainder] -= 2
      
      # Add a base priority based on how much space is used, but avoid dividing by zero
      utilization = item / bins_remain_cap
      priorities[feasible_bins] += utilization[feasible_bins]
      
    return priorities

Now, think outside the box write a mutated function `priority_v2` better than current version.
You can use some hints below:
- 
Okay, let's redefine "Current Self-Reflection" to make it more effective for heuristic design, focusing on avoiding pitfalls and leading to better heuristics.

*   **Keywords:** Adaptive Learning, Outcome Analysis, Solution Diversity, Algorithmic Bias.
*   **Advice:** Analyze heuristic *performance* across diverse problem instances and parameter settings. Quantify solution *quality*, not just feasibility. Explicitly track *algorithmic bias* and design heuristics to mitigate it. Explore diverse solution pathways and avoid premature convergence.
*   **Avoid:** Focusing solely on mathematical models without empirical validation. Ignoring the impact of parameter tuning on heuristic performance. Neglecting the exploration of alternative solution generation strategies.
*   **Explanation:** Shift from static rules to adaptive learning from results. Validate and prevent bias. Aim for more diverse and better solutions.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
[2025-04-27 05:32:10,174][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:32:10,175][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:32:15,803][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:32:15,807][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:32:15,808][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:15,808][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:15,810][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:32:15,812][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:16,791][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:32:16,795][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:32:16,796][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:16,796][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:16,798][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:32:16,800][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:20,676][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:32:20,681][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:32:20,683][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:20,683][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:20,686][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:32:20,687][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:21,693][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:32:21,696][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:32:21,696][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:21,697][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:21,699][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:24,693][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:32:24,698][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:32:24,699][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:24,700][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:24,702][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:24,716][root][INFO] - Iteration 3: Running Code 0
[2025-04-27 05:32:24,878][root][INFO] - Iteration 3: Code Run 0 successful!
[2025-04-27 05:32:24,878][root][INFO] - Iteration 3: Running Code 1
[2025-04-27 05:32:25,024][root][INFO] - Iteration 3: Code Run 1 successful!
[2025-04-27 05:32:25,024][root][INFO] - Iteration 3: Running Code 2
[2025-04-27 05:32:25,196][root][INFO] - Iteration 3: Code Run 2 successful!
[2025-04-27 05:32:25,196][root][INFO] - Iteration 3: Running Code 3
[2025-04-27 05:32:25,348][root][INFO] - Iteration 3: Code Run 3 successful!
[2025-04-27 05:32:25,348][root][INFO] - Iteration 3: Running Code 4
[2025-04-27 05:32:25,508][root][INFO] - Iteration 3: Code Run 4 successful!
[2025-04-27 05:32:27,983][root][INFO] - Iteration 3, response_id 0: Objective value: 18.60789788591944
[2025-04-27 05:32:28,900][root][INFO] - Iteration 3, response_id 1: Objective value: 3.041483845233347
[2025-04-27 05:32:29,694][root][INFO] - Iteration 3, response_id 2: Objective value: 10.789788591942566
[2025-04-27 05:32:29,703][root][INFO] - Iteration 3, response_id 3: Objective value: 4.696848823294789
[2025-04-27 05:32:29,705][root][INFO] - Iteration 3, response_id 4: Objective value: 4.2181890706023095
[2025-04-27 05:32:29,706][root][INFO] - Iteration 3: Elitist: 3.041483845233347
[2025-04-27 05:32:29,706][root][INFO] - Iteration 3 finished...
[2025-04-27 05:32:29,707][root][INFO] - Best obj: 3.041483845233347, Best Code Path: problem_iter3_code1.py
[2025-04-27 05:32:29,707][root][INFO] - LLM usage: prompt_tokens = 39001, completion_tokens = 14894
[2025-04-27 05:32:29,707][root][INFO] - Function Evals: 46
[2025-04-27 05:32:29,710][root][INFO] - Harmony Search Prompt: 
System Prompt: 
You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.
User Prompt: 
[code]
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on a combination of factors, including remaining capacity,
    item size relative to bin size, and a penalty for creating small fragments.
    It also incorporates a mechanism to encourage exploration of less-utilized bins
    initially and then shift toward filling bins more completely as the packing
    progresses (Adaptive behavior).

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.

    Returns:
        np.ndarray: An array containing the priority score for each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Base Priority: Bin Utilization (Fill Ratio)
        utilization = item / bins_remain_cap
        priorities[feasible_bins] += utilization[feasible_bins]

        # 2. Encourage Exploration (Early Stage): Prioritize less-utilized bins initially.
        #    This helps to distribute items across bins, reducing the chance of early convergence
        #    on suboptimal solutions.  The effect diminishes as bins get filled (adaptive).
        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))
        priorities[feasible_bins] += 0.5 * exploration_factor

        # 3. Fill-Optimization (Later Stage): As packing progresses, prioritize bins that are
        #    closer to being full. This promotes efficient space utilization.
        almost_full_threshold = 0.1  #dynamic: can be made dependent on item size
        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
        priorities[almost_full] += 1.5 #Boost almost full slightly higher

        # 4. Fragmentation Penalty: Discourage creating small remaining fragments to avoid wasting space.
        small_remainder_threshold = 0.2
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= 1

        # 5. Near-Perfect Fit Penalty: While fitting snugly is good, extremely close fits can sometimes
        #    lead to more bins being used overall, so a mild penalty is applied.
        near_perfect_fit_threshold = 0.01
        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
        priorities[near_perfect_fit] -= 0.75

        # 6. Moderate-Fit Bonus: If the item fits reasonably well without creating a tiny fragment or an almost-perfect fit,
        # it gets a small bonus. This encourages balanced filling.
        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit
        moderate_fit_threshold_low = 0.25
        moderate_fit_threshold_high = 0.75
        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)
        priorities[moderate_fit] += 0.25

    return priorities

Now extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.

- Output code only and enclose your code with Python code block: ```python ... ```.
- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```.
[2025-04-27 05:32:29,714][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:32:37,341][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:32:37,344][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:32:37,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:37,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:37,349][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:32:37,353][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                 exploration_weight: float = 0.5,
                 almost_full_boost: float = 1.5,
                 small_remainder_penalty: float = 1.0,
                 near_perfect_fit_penalty: float = 0.75,
                 moderate_fit_bonus: float = 0.25,
                 almost_full_threshold: float = 0.1,
                 small_remainder_threshold: float = 0.2,
                 near_perfect_fit_threshold: float = 0.01,
                 moderate_fit_threshold_low: float = 0.25,
                 moderate_fit_threshold_high: float = 0.75) -> np.ndarray:
    """
    Prioritizes bins based on a combination of factors, including remaining capacity,
    item size relative to bin size, and a penalty for creating small fragments.
    It also incorporates a mechanism to encourage exploration of less-utilized bins
    initially and then shift toward filling bins more completely as the packing
    progresses (Adaptive behavior).

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.
        exploration_weight (float): Weight for exploration factor.
        almost_full_boost (float): Boost for almost full bins.
        small_remainder_penalty (float): Penalty for small remainders.
        near_perfect_fit_penalty (float): Penalty for near perfect fits.
        moderate_fit_bonus (float): Bonus for moderate fits.
        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).
        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).
        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).
        moderate_fit_threshold_low (float): Lower threshold for moderate fit (fraction of bin size).
        moderate_fit_threshold_high (float): Higher threshold for moderate fit (fraction of bin size).

    Returns:
        np.ndarray: An array containing the priority score for each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Base Priority: Bin Utilization (Fill Ratio)
        utilization = item / bins_remain_cap
        priorities[feasible_bins] += utilization[feasible_bins]

        # 2. Encourage Exploration (Early Stage): Prioritize less-utilized bins initially.
        #    This helps to distribute items across bins, reducing the chance of early convergence
        #    on suboptimal solutions.  The effect diminishes as bins get filled (adaptive).
        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))
        priorities[feasible_bins] += exploration_weight * exploration_factor

        # 3. Fill-Optimization (Later Stage): As packing progresses, prioritize bins that are
        #    closer to being full. This promotes efficient space utilization.
        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
        priorities[almost_full] += almost_full_boost #Boost almost full slightly higher

        # 4. Fragmentation Penalty: Discourage creating small remaining fragments to avoid wasting space.
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= small_remainder_penalty

        # 5. Near-Perfect Fit Penalty: While fitting snugly is good, extremely close fits can sometimes
        #    lead to more bins being used overall, so a mild penalty is applied.
        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
        priorities[near_perfect_fit] -= near_perfect_fit_penalty

        # 6. Moderate-Fit Bonus: If the item fits reasonably well without creating a tiny fragment or an almost-perfect fit,
        # it gets a small bonus. This encourages balanced filling.
        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit
        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)
        priorities[moderate_fit] += moderate_fit_bonus

    return priorities
```

```python
parameter_ranges = {
    'exploration_weight': (0.0, 1.0),
    'almost_full_boost': (0.0, 3.0),
    'small_remainder_penalty': (0.0, 2.0),
    'near_perfect_fit_penalty': (0.0, 2.0),
    'moderate_fit_bonus': (0.0, 1.0),
    'almost_full_threshold': (0.0, 0.5),
    'small_remainder_threshold': (0.0, 0.5),
    'near_perfect_fit_threshold': (0.0, 0.1),
    'moderate_fit_threshold_low': (0.0, 0.5),
    'moderate_fit_threshold_high': (0.5, 1.0)
}
```
[2025-04-27 05:32:37,378][root][INFO] - Iteration 4: Running Code 0
[2025-04-27 05:32:39,185][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-27 05:32:39,186][root][INFO] - Iteration 4: Running Code 1
[2025-04-27 05:32:40,961][root][INFO] - Iteration 4: Code Run 1 successful!
[2025-04-27 05:32:40,962][root][INFO] - Iteration 4: Running Code 2
[2025-04-27 05:32:42,816][root][INFO] - Iteration 4: Code Run 2 successful!
[2025-04-27 05:32:42,817][root][INFO] - Iteration 4: Running Code 3
[2025-04-27 05:32:44,697][root][INFO] - Iteration 4: Code Run 3 successful!
[2025-04-27 05:32:44,697][root][INFO] - Iteration 4: Running Code 4
[2025-04-27 05:32:46,597][root][INFO] - Iteration 4: Code Run 4 successful!
[2025-04-27 05:32:46,607][root][INFO] - Iteration 4, response_id 0: Objective value: 4.906262465097731
[2025-04-27 05:32:46,617][root][INFO] - Iteration 4, response_id 1: Objective value: 5.943358595931406
[2025-04-27 05:32:46,716][root][INFO] - Iteration 4, response_id 2: Objective value: 8.665735939369775
[2025-04-27 05:32:48,280][root][INFO] - Iteration 4, response_id 3: Objective value: 7.66852812126048
[2025-04-27 05:32:49,679][root][INFO] - Iteration 4, response_id 4: Objective value: 4.786597526924611
[2025-04-27 05:32:49,684][root][INFO] - Iteration 4: Running Code 0
[2025-04-27 05:32:51,398][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-27 05:32:54,487][root][INFO] - Iteration 4, hs_try 0: Objective value: 1.9046669325887537
[2025-04-27 05:32:54,490][root][INFO] - Iteration 4: Running Code 0
[2025-04-27 05:32:56,255][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-27 05:32:59,300][root][INFO] - Iteration 4, hs_try 1: Objective value: 4.786597526924611
[2025-04-27 05:32:59,303][root][INFO] - Iteration 4: Running Code 0
[2025-04-27 05:33:01,041][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-27 05:33:04,150][root][INFO] - Iteration 4, hs_try 2: Objective value: 4.5073793378540135
[2025-04-27 05:33:04,157][root][INFO] - Iteration 4: Running Code 0
[2025-04-27 05:33:05,884][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-27 05:33:09,030][root][INFO] - Iteration 4, hs_try 3: Objective value: 5.055843637814125
[2025-04-27 05:33:09,033][root][INFO] - Iteration 4: Running Code 0
[2025-04-27 05:33:10,813][root][INFO] - Iteration 4: Code Run 0 successful!
[2025-04-27 05:33:13,816][root][INFO] - Iteration 4, hs_try 4: Objective value: 4.287993617869964
[2025-04-27 05:33:13,817][root][INFO] - Iteration 4: Elitist: 1.9046669325887537
[2025-04-27 05:33:13,818][root][INFO] - Iteration 4 finished...
[2025-04-27 05:33:13,818][root][INFO] - Best obj: 1.9046669325887537, Best Code Path: problem_iter4_code0.py
[2025-04-27 05:33:13,818][root][INFO] - LLM usage: prompt_tokens = 39893, completion_tokens = 16054
[2025-04-27 05:33:13,818][root][INFO] - Function Evals: 56
[2025-04-27 05:33:13,820][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:17,580][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:17,583][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:17,584][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:17,584][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:17,588][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:17,621][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:19,369][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:19,372][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:19,374][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:19,374][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:19,377][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:19,409][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:19,411][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:23,688][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:23,691][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:23,693][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:23,693][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:23,695][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:23,697][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:23,929][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:23,931][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:23,931][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:23,932][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:23,933][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:23,934][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:28,268][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:28,272][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:28,273][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:28,274][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:28,275][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:28,276][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:28,433][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:28,434][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:28,435][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:28,435][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:28,436][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:28,436][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:32,464][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:32,466][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:32,468][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:32,468][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:32,470][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:32,472][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:33,193][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:33,196][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:33,197][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:33,197][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:33,200][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:33,201][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:36,512][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:36,514][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:36,515][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:36,515][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:36,518][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:36,519][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:37,342][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:37,345][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:37,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:37,346][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:37,348][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:37,349][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:40,983][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:40,986][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:40,987][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:40,987][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:40,990][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:42,504][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:33:42,506][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:33:42,507][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:42,507][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:42,510][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:33:42,537][root][INFO] - Iteration 5: Running Code 0
[2025-04-27 05:33:42,701][root][INFO] - Iteration 5: Code Run 0 successful!
[2025-04-27 05:33:42,702][root][INFO] - Iteration 5: Running Code 1
[2025-04-27 05:33:42,863][root][INFO] - Iteration 5: Code Run 1 successful!
[2025-04-27 05:33:42,863][root][INFO] - Iteration 5: Running Code 2
[2025-04-27 05:33:43,012][root][INFO] - Iteration 5: Code Run 2 successful!
[2025-04-27 05:33:43,012][root][INFO] - Iteration 5: Running Code 3
[2025-04-27 05:33:43,166][root][INFO] - Iteration 5: Code Run 3 successful!
[2025-04-27 05:33:43,166][root][INFO] - Iteration 5: Running Code 4
[2025-04-27 05:33:43,332][root][INFO] - Iteration 5: Code Run 4 successful!
[2025-04-27 05:33:43,333][root][INFO] - Iteration 5: Running Code 5
[2025-04-27 05:33:43,512][root][INFO] - Iteration 5: Code Run 5 successful!
[2025-04-27 05:33:43,512][root][INFO] - Iteration 5: Running Code 6
[2025-04-27 05:33:43,704][root][INFO] - Iteration 5: Code Run 6 successful!
[2025-04-27 05:33:43,705][root][INFO] - Iteration 5: Running Code 7
[2025-04-27 05:33:44,380][root][INFO] - Iteration 5: Code Run 7 successful!
[2025-04-27 05:33:44,381][root][INFO] - Iteration 5: Running Code 8
[2025-04-27 05:33:46,535][root][INFO] - Iteration 5: Code Run 8 successful!
[2025-04-27 05:33:46,550][root][INFO] - Iteration 5: Running Code 9
[2025-04-27 05:33:47,584][root][INFO] - Iteration 5: Code Run 9 successful!
[2025-04-27 05:33:49,499][root][INFO] - Iteration 5, response_id 0: Objective value: 4.048663741523748
[2025-04-27 05:33:49,511][root][INFO] - Iteration 5, response_id 1: Objective value: 6.0729956122856095
[2025-04-27 05:33:49,861][root][INFO] - Iteration 5, response_id 2: Objective value: 4.617072197846027
[2025-04-27 05:33:49,868][root][INFO] - Iteration 5, response_id 3: Objective value: 4.248105305145606
[2025-04-27 05:33:49,870][root][INFO] - Iteration 5, response_id 4: Objective value: 4.048663741523748
[2025-04-27 05:33:51,944][root][INFO] - Iteration 5, response_id 5: Objective value: 4.646988432389324
[2025-04-27 05:33:51,946][root][INFO] - Iteration 5, response_id 6: Objective value: 3.8292780215396984
[2025-04-27 05:33:51,948][root][INFO] - Iteration 5, response_id 7: Objective value: 86.58755484643
[2025-04-27 05:33:53,046][root][INFO] - Iteration 5, response_id 8: Objective value: 4.637016354208217
[2025-04-27 05:33:54,126][root][INFO] - Iteration 5, response_id 9: Objective value: 7.060231352213798
[2025-04-27 05:33:54,127][root][INFO] - Iteration 5 finished...
[2025-04-27 05:33:54,128][root][INFO] - Best obj: 1.9046669325887537, Best Code Path: problem_iter4_code0.py
[2025-04-27 05:33:54,128][root][INFO] - LLM usage: prompt_tokens = 65434, completion_tokens = 20474
[2025-04-27 05:33:54,128][root][INFO] - Function Evals: 66
[2025-04-27 05:33:54,133][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:33:54,134][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:34:00,877][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:34:00,881][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:34:00,882][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:00,883][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:00,885][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:34:00,886][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:02,057][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:34:02,061][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:34:02,062][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:02,062][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:02,066][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:34:02,067][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:09,015][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:34:09,019][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:34:09,020][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:09,020][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:09,022][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:34:09,024][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:09,156][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:34:09,157][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:34:09,158][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:09,158][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:09,159][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:16,274][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:34:16,277][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:34:16,278][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:16,278][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:16,281][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:16,309][root][INFO] - Iteration 6: Running Code 0
[2025-04-27 05:34:16,469][root][INFO] - Iteration 6: Code Run 0 successful!
[2025-04-27 05:34:16,470][root][INFO] - Iteration 6: Running Code 1
[2025-04-27 05:34:16,635][root][INFO] - Iteration 6: Code Run 1 successful!
[2025-04-27 05:34:16,635][root][INFO] - Iteration 6: Running Code 2
[2025-04-27 05:34:16,805][root][INFO] - Iteration 6: Code Run 2 successful!
[2025-04-27 05:34:16,805][root][INFO] - Iteration 6: Running Code 3
[2025-04-27 05:34:16,960][root][INFO] - Iteration 6: Code Run 3 successful!
[2025-04-27 05:34:16,960][root][INFO] - Iteration 6: Running Code 4
[2025-04-27 05:34:17,172][root][INFO] - Iteration 6: Code Run 4 successful!
[2025-04-27 05:34:21,833][root][INFO] - Iteration 6, response_id 0: Objective value: 1.9445552453131232
[2025-04-27 05:34:22,608][root][INFO] - Iteration 6, response_id 1: Objective value: 1.9944156362185879
[2025-04-27 05:34:23,909][root][INFO] - Iteration 6, response_id 2: Objective value: 1.9545273234942186
[2025-04-27 05:34:23,917][root][INFO] - Iteration 6, response_id 3: Objective value: 1.7750299162345502
[2025-04-27 05:34:23,925][root][INFO] - Iteration 6, response_id 4: Objective value: 149.1723175109693
[2025-04-27 05:34:23,926][root][INFO] - Iteration 6: Elitist: 1.7750299162345502
[2025-04-27 05:34:23,926][root][INFO] - Iteration 6 finished...
[2025-04-27 05:34:23,926][root][INFO] - Best obj: 1.7750299162345502, Best Code Path: problem_iter6_code3.py
[2025-04-27 05:34:23,926][root][INFO] - LLM usage: prompt_tokens = 66789, completion_tokens = 21753
[2025-04-27 05:34:23,927][root][INFO] - Function Evals: 71
[2025-04-27 05:34:23,932][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:34:31,639][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:34:31,642][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:34:31,643][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:31,644][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:31,647][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:34:31,653][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                 exploration_weight: float = 0.4,
                 almost_full_boost: float = 2.5,
                 small_remainder_penalty: float = 1.2,
                 near_perfect_fit_penalty: float = 1.4,
                 moderate_fit_bonus: float = 1.1,
                 almost_full_threshold: float = 0.08,
                 small_remainder_threshold: float = 0.03,
                 near_perfect_fit_threshold: float = 0.05,
                 moderate_fit_threshold_low: float = 0.35,
                 moderate_fit_threshold_high: float = 0.75,
                 bin_level_threshold: float = 0.5,
                 bin_level_boost: float = 0.5) -> np.ndarray:
    """
    Prioritizes bins based on a combination of factors, adaptively adjusting
    exploration and exploitation based on bin utilization levels. Adds a bin-level
    consideration to further refine bin selection.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.
        exploration_weight (float): Weight for exploration factor.
        almost_full_boost (float): Boost for almost full bins.
        small_remainder_penalty (float): Penalty for small remainders.
        near_perfect_fit_penalty (float): Penalty for near perfect fits.
        moderate_fit_bonus (float): Bonus for moderate fits.
        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).
        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).
        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).
        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).
        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).
        bin_level_threshold (float): Threshold to consider a bin at a certain level.
        bin_level_boost (float): Boost for bins that have passed the bin level.


    Returns:
        np.ndarray: An array containing the priority score for each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Base Priority: Bin Utilization (Fill Ratio)
        utilization = item / bins_remain_cap
        priorities[feasible_bins] += utilization[feasible_bins]

        # 2. Adaptive Exploration: Adjust exploration based on bin fill levels.
        #    Prioritize less-utilized bins when most bins are relatively empty.
        bin_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fill levels
        average_bin_level = np.mean(bin_levels)
        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))

        # Adjust exploration weight dynamically
        adaptive_exploration_weight = exploration_weight * (1 - average_bin_level)
        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor

        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.
        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
        priorities[almost_full] += almost_full_boost

        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= small_remainder_penalty

        # 5. Near-Perfect Fit Penalty: Mild penalty for extremely close fits.
        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
        priorities[near_perfect_fit] -= near_perfect_fit_penalty

        # 6. Moderate-Fit Bonus: Bonus for reasonably well-fitting items.
        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit
        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)
        priorities[moderate_fit] += moderate_fit_bonus

        # 7. Bin Level consideration
        bin_level_reached = feasible_bins & (bin_levels >= bin_level_threshold)
        priorities[bin_level_reached] += bin_level_boost

    return priorities
```

```python
parameter_ranges = {
    'exploration_weight': (0.0, 1.0),
    'almost_full_boost': (0.0, 5.0),
    'small_remainder_penalty': (0.0, 5.0),
    'near_perfect_fit_penalty': (0.0, 5.0),
    'moderate_fit_bonus': (0.0, 5.0),
    'almost_full_threshold': (0.0, 1.0),
    'small_remainder_threshold': (0.0, 1.0),
    'near_perfect_fit_threshold': (0.0, 1.0),
    'moderate_fit_threshold_low': (0.0, 1.0),
    'moderate_fit_threshold_high': (0.0, 1.0),
    'bin_level_threshold': (0.0, 1.0),
    'bin_level_boost': (0.0, 5.0)
}
```
[2025-04-27 05:34:31,678][root][INFO] - Iteration 7: Running Code 0
[2025-04-27 05:34:33,451][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-27 05:34:33,451][root][INFO] - Iteration 7: Running Code 1
[2025-04-27 05:34:35,241][root][INFO] - Iteration 7: Code Run 1 successful!
[2025-04-27 05:34:35,241][root][INFO] - Iteration 7: Running Code 2
[2025-04-27 05:34:37,073][root][INFO] - Iteration 7: Code Run 2 successful!
[2025-04-27 05:34:37,073][root][INFO] - Iteration 7: Running Code 3
[2025-04-27 05:34:38,983][root][INFO] - Iteration 7: Code Run 3 successful!
[2025-04-27 05:34:38,984][root][INFO] - Iteration 7: Running Code 4
[2025-04-27 05:34:40,893][root][INFO] - Iteration 7: Code Run 4 successful!
[2025-04-27 05:34:40,895][root][INFO] - Iteration 7, response_id 0: Objective value: 3.470283207020339
[2025-04-27 05:34:40,896][root][INFO] - Iteration 7, response_id 1: Objective value: 4.98603909054647
[2025-04-27 05:34:41,875][root][INFO] - Iteration 7, response_id 2: Objective value: 3.9888312724371757
[2025-04-27 05:34:43,358][root][INFO] - Iteration 7, response_id 3: Objective value: 4.2580773833266905
[2025-04-27 05:34:44,890][root][INFO] - Iteration 7, response_id 4: Objective value: 2.8320702034304044
[2025-04-27 05:34:44,894][root][INFO] - Iteration 7: Running Code 0
[2025-04-27 05:34:46,613][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-27 05:34:50,522][root][INFO] - Iteration 7, hs_try 0: Objective value: 4.048663741523748
[2025-04-27 05:34:50,526][root][INFO] - Iteration 7: Running Code 0
[2025-04-27 05:34:52,226][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-27 05:34:55,936][root][INFO] - Iteration 7, hs_try 1: Objective value: 4.068607897885915
[2025-04-27 05:34:55,939][root][INFO] - Iteration 7: Running Code 0
[2025-04-27 05:34:57,697][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-27 05:35:01,564][root][INFO] - Iteration 7, hs_try 2: Objective value: 3.6597526924611135
[2025-04-27 05:35:01,567][root][INFO] - Iteration 7: Running Code 0
[2025-04-27 05:35:03,304][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-27 05:35:07,445][root][INFO] - Iteration 7, hs_try 3: Objective value: 69.47546868767452
[2025-04-27 05:35:07,448][root][INFO] - Iteration 7: Running Code 0
[2025-04-27 05:35:09,158][root][INFO] - Iteration 7: Code Run 0 successful!
[2025-04-27 05:35:13,144][root][INFO] - Iteration 7, hs_try 4: Objective value: 4.048663741523748
[2025-04-27 05:35:13,145][root][INFO] - Iteration 7 finished...
[2025-04-27 05:35:13,145][root][INFO] - Best obj: 1.7750299162345502, Best Code Path: problem_iter6_code3.py
[2025-04-27 05:35:13,145][root][INFO] - LLM usage: prompt_tokens = 67936, completion_tokens = 22975
[2025-04-27 05:35:13,146][root][INFO] - Function Evals: 81
[2025-04-27 05:35:13,148][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:19,022][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:19,025][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:19,026][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:19,026][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:19,029][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:19,091][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:20,990][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:20,993][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:20,994][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:20,995][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:20,998][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:21,044][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:21,045][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:25,195][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:25,198][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:25,199][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:25,199][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:25,201][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:25,203][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:26,376][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:26,379][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:26,381][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:26,381][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:26,383][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:26,385][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:29,155][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:29,158][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:29,159][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:29,160][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:29,162][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:29,164][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:30,444][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:30,446][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:30,448][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:30,448][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:30,452][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:30,453][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:33,019][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:33,022][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:33,023][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:33,023][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:33,026][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:33,027][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:36,282][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:36,285][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:36,286][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:36,286][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:36,289][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:36,290][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:38,319][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:38,323][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:38,324][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:38,324][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:38,327][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:38,328][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:39,429][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:39,432][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:39,433][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:39,434][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:39,436][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:39,437][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:41,883][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:41,887][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:41,887][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:41,888][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:41,890][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:44,229][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:35:44,232][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:35:44,233][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:44,234][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:44,236][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:35:44,281][root][INFO] - Iteration 8: Running Code 0
[2025-04-27 05:35:44,446][root][INFO] - Iteration 8: Code Run 0 successful!
[2025-04-27 05:35:44,447][root][INFO] - Iteration 8: Running Code 1
[2025-04-27 05:35:44,611][root][INFO] - Iteration 8: Code Run 1 successful!
[2025-04-27 05:35:44,611][root][INFO] - Iteration 8: Running Code 2
[2025-04-27 05:35:44,768][root][INFO] - Iteration 8: Code Run 2 successful!
[2025-04-27 05:35:44,769][root][INFO] - Iteration 8: Running Code 3
[2025-04-27 05:35:44,927][root][INFO] - Iteration 8: Code Run 3 successful!
[2025-04-27 05:35:44,927][root][INFO] - Iteration 8: Running Code 4
[2025-04-27 05:35:45,100][root][INFO] - Iteration 8: Code Run 4 successful!
[2025-04-27 05:35:45,101][root][INFO] - Iteration 8: Running Code 5
[2025-04-27 05:35:45,280][root][INFO] - Iteration 8: Code Run 5 successful!
[2025-04-27 05:35:45,281][root][INFO] - Iteration 8: Running Code 6
[2025-04-27 05:35:45,468][root][INFO] - Iteration 8: Code Run 6 successful!
[2025-04-27 05:35:45,470][root][INFO] - Iteration 8: Running Code 7
[2025-04-27 05:35:45,849][root][INFO] - Iteration 8: Code Run 7 successful!
[2025-04-27 05:35:45,860][root][INFO] - Iteration 8: Running Code 8
[2025-04-27 05:35:46,584][root][INFO] - Iteration 8: Code Run 8 successful!
[2025-04-27 05:35:46,599][root][INFO] - Iteration 8: Running Code 9
[2025-04-27 05:35:47,364][root][INFO] - Iteration 8: Code Run 9 successful!
[2025-04-27 05:35:53,459][root][INFO] - Iteration 8, response_id 0: Objective value: 1.8747506980454793
[2025-04-27 05:35:53,461][root][INFO] - Iteration 8, response_id 1: Objective value: 4.248105305145606
[2025-04-27 05:35:54,379][root][INFO] - Iteration 8, response_id 2: Objective value: 4.666932588751491
[2025-04-27 05:35:54,389][root][INFO] - Iteration 8, response_id 3: Objective value: 4.188272836059035
[2025-04-27 05:35:54,391][root][INFO] - Iteration 8, response_id 4: Objective value: 4.646988432389324
[2025-04-27 05:35:56,432][root][INFO] - Iteration 8, response_id 5: Objective value: 1.9944156362185879
[2025-04-27 05:35:56,438][root][INFO] - Iteration 8, response_id 6: Objective value: 149.1723175109693
[2025-04-27 05:35:56,440][root][INFO] - Iteration 8, response_id 7: Objective value: 4.038691663342641
[2025-04-27 05:35:56,442][root][INFO] - Iteration 8, response_id 8: Objective value: 4.666932588751491
[2025-04-27 05:35:56,457][root][INFO] - Iteration 8, response_id 9: Objective value: 6.043079377742335
[2025-04-27 05:35:56,460][root][INFO] - Iteration 8 finished...
[2025-04-27 05:35:56,460][root][INFO] - Best obj: 1.7750299162345502, Best Code Path: problem_iter6_code3.py
[2025-04-27 05:35:56,460][root][INFO] - LLM usage: prompt_tokens = 104525, completion_tokens = 28340
[2025-04-27 05:35:56,461][root][INFO] - Function Evals: 91
[2025-04-27 05:35:56,465][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:35:56,466][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:36:05,352][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:36:05,355][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:36:05,356][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:05,356][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:05,359][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:36:05,361][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:05,366][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:36:05,370][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:36:05,371][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:05,371][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:05,373][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:36:05,374][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:13,412][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:36:13,416][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:36:13,417][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:13,417][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:13,420][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:36:13,421][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:13,429][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:36:13,431][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:36:13,432][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:13,433][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:13,435][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:20,056][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:36:20,060][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:36:20,061][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:20,061][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:20,064][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:20,087][root][INFO] - Iteration 9: Running Code 0
[2025-04-27 05:36:20,274][root][INFO] - Iteration 9: Code Run 0 successful!
[2025-04-27 05:36:20,274][root][INFO] - Iteration 9: Running Code 1
[2025-04-27 05:36:20,429][root][INFO] - Iteration 9: Code Run 1 successful!
[2025-04-27 05:36:20,429][root][INFO] - Iteration 9: Running Code 2
[2025-04-27 05:36:20,579][root][INFO] - Iteration 9: Code Run 2 successful!
[2025-04-27 05:36:20,580][root][INFO] - Iteration 9: Running Code 3
[2025-04-27 05:36:20,750][root][INFO] - Iteration 9: Code Run 3 successful!
[2025-04-27 05:36:20,750][root][INFO] - Iteration 9: Running Code 4
[2025-04-27 05:36:20,921][root][INFO] - Iteration 9: Code Run 4 successful!
[2025-04-27 05:36:26,316][root][INFO] - Iteration 9, response_id 0: Objective value: 1.7750299162345502
[2025-04-27 05:36:26,872][root][INFO] - Iteration 9, response_id 1: Objective value: 2.293577981651376
[2025-04-27 05:36:26,880][root][INFO] - Iteration 9, response_id 2: Objective value: 1.7650578380534547
[2025-04-27 05:36:27,303][root][INFO] - Iteration 9, response_id 3: Objective value: 1.7351416035101808
[2025-04-27 05:36:27,305][root][INFO] - Iteration 9, response_id 4: Objective value: 1.9046669325887537
[2025-04-27 05:36:27,307][root][INFO] - Iteration 9: Elitist: 1.7351416035101808
[2025-04-27 05:36:27,307][root][INFO] - Iteration 9 finished...
[2025-04-27 05:36:27,308][root][INFO] - Best obj: 1.7351416035101808, Best Code Path: problem_iter9_code3.py
[2025-04-27 05:36:27,308][root][INFO] - LLM usage: prompt_tokens = 105900, completion_tokens = 29612
[2025-04-27 05:36:27,309][root][INFO] - Function Evals: 96
[2025-04-27 05:36:27,313][LiteLLM][INFO] - 
LiteLLM completion() model= gemini-2.0-flash; provider = gemini
[2025-04-27 05:36:36,304][httpx][INFO] - HTTP Request: POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyDWz_8AG8ir2JnMbK_fzFl4H66epIQkqFs "HTTP/1.1 200 OK"
[2025-04-27 05:36:36,308][LiteLLM][INFO] - Wrapper: Completed Call, calling success_handler
[2025-04-27 05:36:36,309][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:36,309][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:36,311][LiteLLM][INFO] - selected model name for cost calculation: gemini/gemini-2.0-flash
[2025-04-27 05:36:36,319][root][INFO] - LLM Response for HS step: ```python
import numpy as np

def priority_v2(item: float,
                 bins_remain_cap: np.ndarray,
                 exploration_weight: float = 0.4,
                 almost_full_boost: float = 2.5,
                 small_remainder_penalty: float = 1.2,
                 near_perfect_fit_penalty: float = 1.4,
                 moderate_fit_bonus: float = 1.1,
                 almost_full_threshold: float = 0.08,
                 small_remainder_threshold: float = 0.03,
                 near_perfect_fit_threshold: float = 0.05,
                 moderate_fit_threshold_low: float = 0.35,
                 moderate_fit_threshold_high: float = 0.75,
                 bin_level_threshold: float = 0.5,
                 bin_level_boost: float = 0.5,
                 random_factor: float = 0.05,
                 capacity_variance_penalty: float = 0.01) -> np.ndarray:
    """
    Prioritizes bins based on a combination of factors, adaptively adjusting
    exploration and exploitation based on bin utilization levels. Adds a bin-level
    consideration to further refine bin selection and incorporates a degree of randomness.
    Also introduces a penalty based on variance of remaining capacities to promote even fill.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.
        exploration_weight (float): Weight for exploration factor.
        almost_full_boost (float): Boost for almost full bins.
        small_remainder_penalty (float): Penalty for small remainders.
        near_perfect_fit_penalty (float): Penalty for near perfect fits.
        moderate_fit_bonus (float): Bonus for moderate fits.
        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).
        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).
        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).
        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).
        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).
        bin_level_threshold (float): Threshold to consider a bin at a certain level.
        bin_level_boost (float): Boost for bins that have passed the bin level.
        random_factor (float): Scaling factor for random component.
        capacity_variance_penalty (float): Penalty scaling factor for variance in remaining capacity

    Returns:
        np.ndarray: An array containing the priority score for each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Base Priority: Bin Utilization (Fill Ratio)
        utilization = item / bins_remain_cap
        priorities[feasible_bins] += utilization[feasible_bins]

        # 2. Adaptive Exploration: Adjust exploration based on bin fill levels.
        #    Prioritize less-utilized bins when most bins are relatively empty.
        bin_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fill levels
        average_bin_level = np.mean(bin_levels)
        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))

        # Adjust exploration weight dynamically
        adaptive_exploration_weight = exploration_weight * (1 - average_bin_level)
        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor

        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.
        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
        priorities[almost_full] += almost_full_boost

        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= small_remainder_penalty

        # 5. Near-Perfect Fit Penalty: Mild penalty for extremely close fits.
        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
        priorities[near_perfect_fit] -= near_perfect_fit_penalty

        # 6. Moderate-Fit Bonus: Bonus for reasonably well-fitting items.
        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit
        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)
        priorities[moderate_fit] += moderate_fit_bonus

        # 7. Bin Level consideration
        bin_level_reached = feasible_bins & (bin_levels >= bin_level_threshold)
        priorities[bin_level_reached] += bin_level_boost

        # 8. Random Factor for Exploration
        priorities[feasible_bins] += random_factor * np.random.rand(np.sum(feasible_bins))

        # 9. Balance Bin Utilization: Penalize variance in remaining capacity
        capacity_variance = np.var(bins_remain_cap)
        priorities[feasible_bins] -= capacity_variance_penalty * capacity_variance # small penalty to promote balance

    return priorities
```

```python
parameter_ranges = {
    'exploration_weight': (0.0, 1.0),
    'almost_full_boost': (0.0, 5.0),
    'small_remainder_penalty': (0.0, 3.0),
    'near_perfect_fit_penalty': (0.0, 3.0),
    'moderate_fit_bonus': (0.0, 3.0),
    'almost_full_threshold': (0.0, 0.2),
    'small_remainder_threshold': (0.0, 0.1),
    'near_perfect_fit_threshold': (0.0, 0.2),
    'moderate_fit_threshold_low': (0.0, 0.5),
    'moderate_fit_threshold_high': (0.5, 1.0),
    'bin_level_threshold': (0.0, 1.0),
    'bin_level_boost': (0.0, 3.0),
    'random_factor': (0.0, 0.2),
    'capacity_variance_penalty': (0.0, 0.1)
}
```
[2025-04-27 05:36:36,347][root][INFO] - Iteration 10: Running Code 0
[2025-04-27 05:36:38,212][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-27 05:36:38,212][root][INFO] - Iteration 10: Running Code 1
[2025-04-27 05:36:40,012][root][INFO] - Iteration 10: Code Run 1 successful!
[2025-04-27 05:36:40,012][root][INFO] - Iteration 10: Running Code 2
[2025-04-27 05:36:41,912][root][INFO] - Iteration 10: Code Run 2 successful!
[2025-04-27 05:36:41,913][root][INFO] - Iteration 10: Running Code 3
[2025-04-27 05:36:43,893][root][INFO] - Iteration 10: Code Run 3 successful!
[2025-04-27 05:36:43,893][root][INFO] - Iteration 10: Running Code 4
[2025-04-27 05:36:46,092][root][INFO] - Iteration 10: Code Run 4 successful!
[2025-04-27 05:36:46,174][root][INFO] - Iteration 10, response_id 0: Objective value: 5.025927403270851
[2025-04-27 05:36:48,311][root][INFO] - Iteration 10, response_id 1: Objective value: 47.187873952931795
[2025-04-27 05:36:49,961][root][INFO] - Iteration 10, response_id 2: Objective value: 4.706820901475872
[2025-04-27 05:36:51,635][root][INFO] - Iteration 10, response_id 3: Objective value: 12.903869166334273
[2025-04-27 05:36:52,718][root][INFO] - Iteration 10, response_id 4: Objective value: 3.1112883925010015
[2025-04-27 05:36:52,722][root][INFO] - Iteration 10: Running Code 0
[2025-04-27 05:36:54,465][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-27 05:37:00,173][root][INFO] - Iteration 10, hs_try 0: Objective value: 5.44475468687676
[2025-04-27 05:37:00,178][root][INFO] - Iteration 10: Running Code 0
[2025-04-27 05:37:01,953][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-27 05:37:07,521][root][INFO] - Iteration 10, hs_try 1: Objective value: 10.19146390107699
[2025-04-27 05:37:07,524][root][INFO] - Iteration 10: Running Code 0
[2025-04-27 05:37:09,307][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-27 05:37:15,048][root][INFO] - Iteration 10, hs_try 2: Objective value: 15.84563222975669
[2025-04-27 05:37:15,051][root][INFO] - Iteration 10: Running Code 0
[2025-04-27 05:37:16,836][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-27 05:37:22,533][root][INFO] - Iteration 10, hs_try 3: Objective value: 12.933785400877548
[2025-04-27 05:37:22,539][root][INFO] - Iteration 10: Running Code 0
[2025-04-27 05:37:24,304][root][INFO] - Iteration 10: Code Run 0 successful!
[2025-04-27 05:37:30,042][root][INFO] - Iteration 10, hs_try 4: Objective value: 6.980454726765058
[2025-04-27 05:37:30,044][root][INFO] - Iteration 10 finished...
[2025-04-27 05:37:30,044][root][INFO] - Best obj: 1.7351416035101808, Best Code Path: problem_iter9_code3.py
[2025-04-27 05:37:30,044][root][INFO] - LLM usage: prompt_tokens = 107174, completion_tokens = 31019
[2025-04-27 05:37:30,044][root][INFO] - Function Evals: 106
[2025-04-27 05:37:30,045][root][INFO] - Best Code Overall: import numpy as np

def priority_v2(item: float,
                 bins_remain_cap: np.ndarray,
                 exploration_weight: float = 0.4,
                 almost_full_boost: float = 2.5,
                 small_remainder_penalty: float = 1.2,
                 near_perfect_fit_penalty: float = 1.4,
                 moderate_fit_bonus: float = 1.1,
                 almost_full_threshold: float = 0.08,
                 small_remainder_threshold: float = 0.03,
                 near_perfect_fit_threshold: float = 0.05,
                 moderate_fit_threshold_low: float = 0.35,
                 moderate_fit_threshold_high: float = 0.75,
                 bin_level_threshold: float = 0.5,
                 bin_level_boost: float = 0.5,
                 random_factor: float = 0.05) -> np.ndarray:
    """
    Prioritizes bins based on a combination of factors, adaptively adjusting
    exploration and exploitation based on bin utilization levels. Adds a bin-level
    consideration to further refine bin selection and incorporates a degree of randomness.
    Also introduces a penalty based on variance of remaining capacities to promote even fill.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.
        exploration_weight (float): Weight for exploration factor.
        almost_full_boost (float): Boost for almost full bins.
        small_remainder_penalty (float): Penalty for small remainders.
        near_perfect_fit_penalty (float): Penalty for near perfect fits.
        moderate_fit_bonus (float): Bonus for moderate fits.
        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).
        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).
        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).
        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).
        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).
        bin_level_threshold (float): Threshold to consider a bin at a certain level.
        bin_level_boost (float): Boost for bins that have passed the bin level.
        random_factor (float): Scaling factor for random component.

    Returns:
        np.ndarray: An array containing the priority score for each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Base Priority: Bin Utilization (Fill Ratio)
        utilization = item / bins_remain_cap
        priorities[feasible_bins] += utilization[feasible_bins]

        # 2. Adaptive Exploration: Adjust exploration based on bin fill levels.
        #    Prioritize less-utilized bins when most bins are relatively empty.
        bin_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fill levels
        average_bin_level = np.mean(bin_levels)
        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))

        # Adjust exploration weight dynamically
        adaptive_exploration_weight = exploration_weight * (1 - average_bin_level)
        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor

        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.
        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)
        priorities[almost_full] += almost_full_boost

        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= small_remainder_penalty

        # 5. Near-Perfect Fit Penalty: Mild penalty for extremely close fits.
        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)
        priorities[near_perfect_fit] -= near_perfect_fit_penalty

        # 6. Moderate-Fit Bonus: Bonus for reasonably well-fitting items.
        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit
        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)
        priorities[moderate_fit] += moderate_fit_bonus

        # 7. Bin Level consideration
        bin_level_reached = feasible_bins & (bin_levels >= bin_level_threshold)
        priorities[bin_level_reached] += bin_level_boost

        # 8. Random Factor for Exploration
        priorities[feasible_bins] += random_factor * np.random.rand(np.sum(feasible_bins))

        # 9. Balance Bin Utilization: Penalize variance in remaining capacity
        capacity_variance = np.var(bins_remain_cap)
        priorities[feasible_bins] -= 0.01 * capacity_variance # small penalty to promote balance

    return priorities
[2025-04-27 05:37:30,045][root][INFO] - Best Code Path Overall: problem_iter9_code3.py
[2025-04-27 05:37:30,049][root][INFO] - Running validation script...: C:\Users\Nam\Documents\GitHub\HSEvo/problems/bpp_online/eval.py
[2025-04-27 05:37:35,554][root][INFO] - Validation script finished. Results are saved in best_code_overall_val_stdout.txt.
[2025-04-27 05:37:35,566][root][INFO] - [*] Running ...
[2025-04-27 05:37:35,566][root][INFO] - weibull_5k_val.pickle
[2025-04-27 05:37:35,567][root][INFO] - Average number of bins: 2042.6
[2025-04-27 05:37:35,567][root][INFO] - Lower bound on optimum: 2008.8
[2025-04-27 05:37:35,568][root][INFO] - Excess: 1.68%
[2025-04-27 05:37:35,568][root][INFO] - [*] Average:
[2025-04-27 05:37:35,568][root][INFO] - 1.6825965750696912
