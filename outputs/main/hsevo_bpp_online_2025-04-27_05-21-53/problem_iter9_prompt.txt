{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n                 exploration_weight: float = 0.4,\n                 almost_full_boost: float = 2.5,\n                 small_remainder_penalty: float = 1.2,\n                 near_perfect_fit_penalty: float = 1.4,\n                 moderate_fit_bonus: float = 1.1,\n                 almost_full_threshold: float = 0.08,\n                 small_remainder_threshold: float = 0.03,\n                 near_perfect_fit_threshold: float = 0.05,\n                 moderate_fit_threshold_low: float = 0.35,\n                 moderate_fit_threshold_high: float = 0.75,\n                 bin_level_threshold: float = 0.5,\n                 bin_level_boost: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, adaptively adjusting\n    exploration and exploitation based on bin utilization levels. Adds a bin-level\n    consideration to further refine bin selection.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        bin_level_threshold (float): Threshold to consider a bin at a certain level.\n        bin_level_boost (float): Boost for bins that have passed the bin level.\n\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio)\n        utilization = item / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Adaptive Exploration: Adjust exploration based on bin fill levels.\n        #    Prioritize less-utilized bins when most bins are relatively empty.\n        bin_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fill levels\n        average_bin_level = np.mean(bin_levels)\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n\n        # Adjust exploration weight dynamically\n        adaptive_exploration_weight = exploration_weight * (1 - average_bin_level)\n        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: Mild penalty for extremely close fits.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: Bonus for reasonably well-fitting items.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Bin Level consideration\n        bin_level_reached = feasible_bins & (bin_levels >= bin_level_threshold)\n        priorities[bin_level_reached] += bin_level_boost\n\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nOkay, let's redefine \"Current Self-Reflection\" to boost heuristic design:\n\n*   **Keywords:** Adaptive, dynamic, balanced exploration/exploitation, diversity, tunable weights, interpretable, random components.\n\n*   **Advice:** Design heuristics that adapt to problem characteristics (item sizes, bin fill levels). Use tunable weights to balance competing objectives (feasibility, utilization, fragmentation). Incorporate randomness for exploration.\n\n*   **Avoid:** Hardcoded parameters, premature convergence, redundancy.\n\n*   **Explanation:** Focus on adaptability and balanced strategies. Employ tunable parameters for flexibility and interpretability. Prioritize exploration to avoid local optima while ensuring efficient resource utilization.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}