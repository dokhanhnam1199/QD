```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive, combines fullness, near-overflow penalty, and small remainder penalty."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fits = bins_remain_cap >= item

    if not np.any(fits):
        return priorities

    # Fullness score
    remaining_capacities = bins_remain_cap - item
    remaining_capacities[remaining_capacities < 0] = 0
    fullness_scores = np.where(fits, (bins_remain_cap - item) / bins_remain_cap, 1.0) # Avoid inf
    priorities[fits] = 1.0 - fullness_scores[fits]

    # Adaptive near-overflow penalty
    overflow_margin = 0.05 * item
    near_overflow = fits & ((bins_remain_cap - item) < overflow_margin)
    if np.any(near_overflow):
        overflow_penalty = np.exp(5 * ((bins_remain_cap[near_overflow] - item - overflow_margin) / overflow_margin))
        priorities[near_overflow] -= overflow_penalty

    # Adaptive small remainder penalty
    small_remainder_threshold = 0.2 - 0.05 * item
    small_remainder_threshold = max(0.05, small_remainder_threshold)
    small_remainder = fits & (remaining_capacities > 0) & (remaining_capacities <= small_remainder_threshold * bins_remain_cap)
    priorities[small_remainder] -= 3

    # Encourage filling partially filled bins, adaptive to item size
    utilization = item / bins_remain_cap
    current_fill = (bins_remain_cap - remaining_capacities) / bins_remain_cap
    priorities[fits] += utilization[fits] * (1 + current_fill[fits])
    
    # Small random component for exploration
    priorities[fits] += np.random.rand(np.sum(fits)) * 0.1
    
    priorities[bins_remain_cap < item] = -np.inf # Ensure infeasible bins have lowest priority

    return priorities
```
