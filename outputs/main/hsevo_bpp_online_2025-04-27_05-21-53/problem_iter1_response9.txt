```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function implements a best-fit-decreasing heuristic with some added sophistication.
    It prioritizes bins that can accommodate the item with minimal wasted space,
    but also incorporates a term that encourages filling bins completely to avoid fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Iterate over each bin's remaining capacity
    for i, cap in enumerate(bins_remain_cap):
        # If the item fits in the bin
        if item <= cap:
            # Calculate wasted space. Favor smallest waste
            wasted_space = cap - item

            # Base priority is the negative of wasted space (smaller waste -> higher priority)
            priorities[i] = -wasted_space

            # Bonus for filling the bin close to capacity
            # The closer to filling the bin (small wasted_space), the bigger the bonus.
            # Scale bonus with item size; big items are harder to fit later.
            bonus_scale = 1.0
            if item > 0.0:
                bonus = bonus_scale * (item / cap)

                # Bonus is added to a range of [0, bonus_scale]. If bonus_scale is 1,
                # Then the bonus goes from 0 to 1 as wasted_space becomes zero (ideal fit)
                priorities[i] += bonus

        #If item does not fit at all, the bin gets extremely low priority
        else:
             priorities[i] = -np.inf

    return priorities
```
