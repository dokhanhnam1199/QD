```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Heuristic 1: Avoid fragmentation. Give higher priority to bins that can fit the item with minimal wasted space.

    # feasible_bins indicates which bins the item can fit into
    feasible_bins = bins_remain_cap >= item

    priorities = np.zeros_like(bins_remain_cap)

    # Give feasible bins a baseline priority
    priorities[feasible_bins] = 1.0

    # Heuristic 2: Emphasize near-full bins.
    # Calculate wasted space if the item were added to each bin.
    wasted_space = bins_remain_cap - item
    wasted_space[wasted_space < 0] = np.inf # Mark infeasible bins with infinite waste.

    # Assign priorities inversely proportional to wasted space. Smaller waste gives higher priority.
    # Scale wasted space to avoid overly large numbers.
    priorities[feasible_bins] += 1.0 / (1 + wasted_space[feasible_bins])

    # Heuristic 3: Consider current fullness (higher occupancy first)
    # Fullness before adding the item
    fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap)) # scaling by maximum cap to avoid possible division by 0 errors later.

    priorities[feasible_bins] += fullness[feasible_bins] # Add fullness to already feasible bins

    #Heuristic 4: Consider bins that are nearly full (avoid empty bins)
    nearly_full = bins_remain_cap < np.max(bins_remain_cap)/4 # Avoid packing small items in near empty bins, scaled with maximum capacity of all bins
    priorities[nearly_full] *=2

    return priorities
```
