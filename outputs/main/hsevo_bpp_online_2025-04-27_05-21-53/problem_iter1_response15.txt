```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the celestial dance, we favor orbits (bins) where the item (a newly discovered star) fits snugly, but also consider the gravity (remaining space) of the system.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            # A measure of how well the item 'fits' - smaller leftover is better, like a closer orbit
            fit_score = (capacity - item) / capacity

            # Avoidance of filling completely, to leave space for later stars. Small bins are higher penalty.
            empty_space_penalty = np.exp(-capacity)  # exponential decay, smaller bins get higher penalty. Avoidance factor, not used up capacity
            
            # Heavier influence from available space when item size is very small.
            item_size_impact = np.exp(-10 * item)
            
            # Calculate final priority score as the inverse fit to encourage good fills. Add scaled penalty with item size impact
            priorities[i] = 1.0 / (fit_score + 1e-9) + item_size_impact * empty_space_penalty


        else:
            priorities[i] = -np.inf  # Not applicable if the item doesn't fit. A star that cannot find its place is simply excluded.
    return priorities
```
