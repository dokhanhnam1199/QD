```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers:
    1. Waste: The smaller the waste, the higher the priority.
    2. Fill Level: Prefer bins that are already somewhat full.
    3. Avoidance of Near-Full Bins: Avoid bins that will be nearly full after packing (risk of fragmentation).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate waste if the item is placed in each bin.
    waste = bins_remain_cap - item
    waste[waste < 0] = np.inf  # Mark infeasible bins as infinitely bad.

    # Normalize waste (lower waste is better).  Small values of waste should contribute heavily
    normalized_waste = np.exp(-waste)

    # Encourage filling partially filled bins.  The closer to halfway, the better.
    fill_level_priority = np.exp(-np.abs(bins_remain_cap - item - np.mean(bins_remain_cap))/np.std(bins_remain_cap)) if np.std(bins_remain_cap) > 0 else np.ones_like(bins_remain_cap)

    # Penalize bins that become very full after packing (e.g., > 90% full).
    fullness_after = (bins_remain_cap - item) / np.max(bins_remain_cap) # max capacity
    fullness_penalty = np.where(fullness_after < 0.1, -100 * (0.1-fullness_after), 0)

    # Combine the factors. Weighting is important.
    priorities = (normalized_waste * 0.6 +
                 fill_level_priority * 0.3 +
                 fullness_penalty * 0.1)

    return priorities
```
