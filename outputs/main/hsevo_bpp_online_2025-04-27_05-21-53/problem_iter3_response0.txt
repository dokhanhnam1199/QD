```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on a combination of factors:
    - Space utilization: favors bins where the item fills a significant portion of the remaining capacity.
    - Balance: encourages filling bins evenly, avoiding extreme fragmentation.
    - Avoidance of near-perfect fits (can lead to future small item placement issues).
    - Considers both relative and absolute remaining capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item

    # Infeasible bins get the lowest priority
    priorities[remaining_capacity < 0] = -np.inf

    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # 1. Space Utilization Priority: Reward higher utilization
        utilization = item / bins_remain_cap
        priorities[feasible_bins] += 5 * utilization[feasible_bins]  # Boost factor

        # 2. Balance Priority: Encourage even fill levels across bins (minimize variance in remaining capacity)
        #    This is a global consideration, influencing the priority locally.

        # 3. Near-Perfect Fit Penalty (Slightly adjusted threshold and penalty)
        near_perfect_fit_threshold = 0.05  # Increased threshold
        near_perfect_fit = feasible_bins & (remaining_capacity / bins_remain_cap <= near_perfect_fit_threshold)
        priorities[near_perfect_fit] -= 8  # Increased penalty

        # 4. Small Remainder Penalty (Adjusted threshold and penalty)
        small_remainder_threshold = 0.2
        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)
        priorities[small_remainder] -= 3

        # 5. Moderate Remainder Reward: Prefer bins with moderate remaining capacity
        moderate_remainder_lower = 0.3
        moderate_remainder_upper = 0.7
        moderate_remainder = feasible_bins & (remaining_capacity / bins_remain_cap > moderate_remainder_lower) & (remaining_capacity / bins_remain_cap <= moderate_remainder_upper)
        priorities[moderate_remainder] += 2 # small reward

        #6. Absolute remaining capacity reward
        absolute_cap_threshold = 0.2
        absolute_cap = feasible_bins & (remaining_capacity <= absolute_cap_threshold)
        priorities[absolute_cap]+=1 #reward bins with low absolute capacity

        # 7. Adaptive Adjustment (Optional, but potentially powerful - requires more analysis)
        #    This could involve tracking the average remaining capacity and dynamically adjusting
        #    the thresholds or penalties based on observed performance.

    return priorities
```
