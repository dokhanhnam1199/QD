```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines best of v0 and v1: Adaptive penalties, perfect fit bonus, utilization."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    remaining_capacity = bins_remain_cap - item
    feasible_bins = remaining_capacity >= 0

    if np.any(feasible_bins):
        # Perfect fit bonus
        perfect_fit = np.abs(remaining_capacity[feasible_bins]) < 1e-6
        priorities[feasible_bins][perfect_fit] += 100

        # Adaptive penalty for small remainders (fragmentation)
        small_remainder_threshold = 0.2
        small_remainder = (remaining_capacity[feasible_bins] > 0) & (remaining_capacity[feasible_bins] <= small_remainder_threshold * bins_remain_cap[feasible_bins])
        priorities[feasible_bins][small_remainder] -= 20 * (1 - (remaining_capacity[feasible_bins][small_remainder] / (small_remainder_threshold * bins_remain_cap[feasible_bins][small_remainder])))

        # Utilization-based priority
        utilization = item / bins_remain_cap[feasible_bins]
        priorities[feasible_bins] += utilization * 10

        # Encourage filling bins
        almost_full_threshold = 0.1
        almost_full = (remaining_capacity[feasible_bins] > 0) & (remaining_capacity[feasible_bins] <= almost_full_threshold * bins_remain_cap[feasible_bins])
        priorities[feasible_bins][almost_full] += 30

    priorities[remaining_capacity < 0] = -np.inf  # Mark infeasible bins

    return priorities
```
