```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins based on remaining capacity, fit quality, and exploration."""

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    feasible_bins = bins_remain_cap >= item

    if np.any(feasible_bins):
        remaining_capacity = bins_remain_cap[feasible_bins] - item

        # Base priority: inverse of remaining capacity, avoids division by zero
        priorities[feasible_bins] = 1 / (remaining_capacity + 1e-6)

        # Bonus for near-perfect fit
        perfect_fit_threshold = 0.05 * bins_remain_cap[feasible_bins]
        near_perfect_fit = (remaining_capacity >= 0) & (remaining_capacity <= perfect_fit_threshold)
        priorities[feasible_bins][near_perfect_fit] += 50

        # Penalty for small remainders to avoid fragmentation
        small_remainder_threshold = 0.2 * bins_remain_cap[feasible_bins]
        small_remainder = (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold)
        priorities[feasible_bins][small_remainder] -= 25

        # Moderate penalty for almost full bins
        almost_full_threshold = 0.15 * bins_remain_cap[feasible_bins]
        almost_full = (remaining_capacity > 0) & (remaining_capacity <= almost_full_threshold)
        priorities[feasible_bins][almost_full] -= 10

        # Exploration: encourage filling less full bins with a diminishing factor
        exploration_factor = bins_remain_cap[feasible_bins] / np.max(bins_remain_cap)
        priorities[feasible_bins] += 5 * exploration_factor

    else:
        priorities = -np.inf * np.ones_like(bins_remain_cap) # assign lowest priority
    return priorities
```
