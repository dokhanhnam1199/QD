```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function prioritizes bins that can fit the item snugly but avoids nearly full bins unless absolutely necessary.
    It also includes a small random factor to break ties and encourage exploration of different packing configurations,
    mimicking the probabilistic nature of quantum phenomena near event horizons.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate wasted space if the item is placed in each bin.  If wasted space negative, it means item doesn't fit
    wasted_space = bins_remain_cap - item

    # Give high priority to bins where the item fits and leaves little wasted space.  Squarer the remaining space more is preferred
    fit_indices = wasted_space >= 0
    if np.any(fit_indices):
      priorities[fit_indices] = (bins_remain_cap[fit_indices] - item)**2 #Squarer the smaller space to avoid too small items or almost full bin. This is better near horizon
    else:
      # if no bins fit. Use First Fit Decreasing
      return bins_remain_cap

    # Add a small random factor to break ties and encourage exploration.
    # The magnitude of the random factor should be small compared to the typical differences in wasted space.
    priorities += np.random.rand(len(bins_remain_cap)) * 0.0001

    return priorities
```
