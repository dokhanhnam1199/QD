```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version considers both remaining capacity and item size for prioritization.
    Aims for near-fit but penalizes bins that are too close to full (risk of wasted space).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            # Calculate the remaining space if the item is placed in this bin
            remaining_space = cap - item

            # Near-fit bonus: Higher priority for bins where the remaining space is small
            near_fit_bonus = np.exp(-5 * remaining_space / cap)  # Exponential decay

            # Penalize near-full bins to avoid fragmentation. The closer to the bin size this item is, the more we want to use the bin
            # unless it would leave very little space for future small items
            #Penalization will kick in when we are left with less than 10% after placing the item.
            #Penalty will reduce priority of bins in which adding an item would lead to bins with space between 0 to 10% left
            near_full_penalty = 0
            if 0 < remaining_space <= 0.1 * cap:  #was .1 * cap
                near_full_penalty = -np.exp(10 * (0.1 * cap - remaining_space) / cap) # reduce the value exponentially as we move closer to being nearly full
            # Baseline priority: Prefer bins that can fit the item
            priorities[i] = near_fit_bonus + near_full_penalty
        else:
            priorities[i] = -np.inf  # Cannot fit

    return priorities
```
