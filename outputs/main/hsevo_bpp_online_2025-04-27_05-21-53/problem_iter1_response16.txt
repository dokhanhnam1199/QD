```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Heuristic 1: Avoid near-empty bins and prioritize bins that can snugly fit the item.
    # Heuristic 2: Introduce a penalty for bins that would become almost full, increasing the chance of using up all of the capacity

    # Calculate remaining space after adding item (or negative if item doesn't fit)
    remaining_after = bins_remain_cap - item

    # Initialize priority array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give bins where item fits a base priority
    fit_mask = remaining_after >= 0
    priorities[fit_mask] = 1.0

    # Boost priority for bins where the item almost fills it (small remaining space) - avoid fragments
    almost_full_mask = fit_mask & (remaining_after <= 0.1) # Adjust 0.1 as needed
    priorities[almost_full_mask] += 2.0 # Adjust 2.0 as needed

    # Increase the probability of selecting the fullest legal bin if at least one fits.

    # Prioritize bins where the remaining capacity is closest to the item size.
    diffs = np.abs(bins_remain_cap - item)
    priorities[fit_mask] += 1.0 / (diffs[fit_mask] + 0.0001) #Add small value to avoid division by zero

    # Introduce penalty for near-full bins after placement to avoid fragmenting bins
    near_full_penalty_mask = fit_mask & (remaining_after / bins_remain_cap < 0.1) # bin filling over 90%
    priorities[near_full_penalty_mask] -= 0.5 # reduce priority by a certain amount. This value should be fine-tuned by experimenting.

    # Ensure priorities are non-negative
    priorities = np.maximum(priorities, 0)

    return priorities
```
