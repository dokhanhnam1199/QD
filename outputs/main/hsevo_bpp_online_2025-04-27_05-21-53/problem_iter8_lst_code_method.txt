{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                 exploration_weight: float = 0.4,\n                 almost_full_boost: float = 2.5,\n                 small_remainder_penalty: float = 1.2,\n                 near_perfect_fit_penalty: float = 1.4,\n                 moderate_fit_bonus: float = 1.1,\n                 almost_full_threshold: float = 0.08,\n                 small_remainder_threshold: float = 0.03,\n                 near_perfect_fit_threshold: float = 0.05,\n                 moderate_fit_threshold_low: float = 0.35,\n                 moderate_fit_threshold_high: float = 0.75,\n                 bin_level_threshold: float = 0.5,\n                 bin_level_boost: float = 0.5) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, adaptively adjusting\n    exploration and exploitation based on bin utilization levels. Adds a bin-level\n    consideration to further refine bin selection.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        bin_level_threshold (float): Threshold to consider a bin at a certain level.\n        bin_level_boost (float): Boost for bins that have passed the bin level.\n\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio)\n        utilization = item / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Adaptive Exploration: Adjust exploration based on bin fill levels.\n        #    Prioritize less-utilized bins when most bins are relatively empty.\n        bin_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fill levels\n        average_bin_level = np.mean(bin_levels)\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n\n        # Adjust exploration weight dynamically\n        adaptive_exploration_weight = exploration_weight * (1 - average_bin_level)\n        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: Mild penalty for extremely close fits.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: Bonus for reasonably well-fitting items.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Bin Level consideration\n        bin_level_reached = feasible_bins & (bin_levels >= bin_level_threshold)\n        priorities[bin_level_reached] += bin_level_boost\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                 exploration_weight: float = 0.3482592920692952,\n                 almost_full_boost: float = 2.3120758085100395,\n                 small_remainder_penalty: float = 1.048883701071912,\n                 near_perfect_fit_penalty: float = 1.5814163090985471,\n                 moderate_fit_bonus: float = 0.97011540494973,\n                 almost_full_threshold: float = 0.073331980441882,\n                 small_remainder_threshold: float = 0.02524284985386266,\n                 near_perfect_fit_threshold: float = 0.04468113355144796,\n                 moderate_fit_threshold_low: float = 0.33776523602030956,\n                 moderate_fit_threshold_high: float = 0.7785575931513438,\n                 bin_diversity_penalty: float = 0.5,\n                 utilization_exponent: float = 1.5,\n                 random_factor: float = 0.01) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, incorporating bin diversity,\n    a stochastic element, and adaptive exploration.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit.\n        moderate_fit_threshold_high: Higher threshold for moderate fit.\n        bin_diversity_penalty (float): Penalty to encourage the algorithm to use bins with different fill levels.\n        utilization_exponent (float): Exponent to adjust the impact of bin utilization.\n        random_factor (float): A small random number to break ties and encourage exploration.\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio) - Increased importance with exponent\n        utilization = (item / bins_remain_cap) ** utilization_exponent\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Encourage Exploration (Adaptive): Prioritize less-utilized bins initially.\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Bin Diversity Penalty: Discourage packing into bins with similar fill levels.\n        #    This is calculated based on the standard deviation of the utilization of bins\n        #    that are not empty. High standard deviation means more diversity. We *subtract*\n        #    a value that is inversely proportional to the standard deviation.\n\n        filled_bins = bins_remain_cap < 1  # Assuming bin capacity is 1.0.  Adapt as needed.\n        if np.sum(filled_bins) > 1:  # Only apply if there are at least two bins filled\n            filled_bin_utilizations = 1 - bins_remain_cap[filled_bins]  # utilization is 1 - remaining cap\n            utilization_std = np.std(filled_bin_utilizations)\n            priorities[feasible_bins] -= bin_diversity_penalty / (utilization_std + 1e-6)  # Avoid division by zero\n\n        # 8. Stochastic Element: Add a small random number to break ties and explore alternatives.\n        priorities[feasible_bins] += random_factor * np.random.rand(np.sum(feasible_bins))\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                 exploration_weight: float = 0.35,\n                 almost_full_boost: float = 2.3,\n                 small_remainder_penalty: float = 1.05,\n                 near_perfect_fit_penalty: float = 1.6,\n                 moderate_fit_bonus: float = 0.95,\n                 almost_full_threshold: float = 0.07,\n                 small_remainder_threshold: float = 0.025,\n                 near_perfect_fit_threshold: float = 0.045,\n                 moderate_fit_threshold_low: float = 0.34,\n                 moderate_fit_threshold_high: float = 0.78,\n                 capacity_usage_exponent: float = 1.5,\n                 large_item_penalty: float = 0.5,\n                 large_item_threshold: float = 0.8) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, including remaining capacity,\n    item size relative to bin size, and a penalty for creating small fragments.\n    It also incorporates a mechanism to encourage exploration of less-utilized bins\n    initially and then shift toward filling bins more completely as the packing\n    progresses (Adaptive behavior). This version adds a capacity usage exponent to emphasize\n    the filling of bins and a large item penalty to discourage placing very large items.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        capacity_usage_exponent (float): Exponent to emphasize filling of bins.\n        large_item_penalty (float): Penalty for placing large items.\n        large_item_threshold (float): Threshold for considering an item large (fraction of bin size).\n\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio) - Emphasize filling with exponent\n        utilization = (item / bins_remain_cap) ** capacity_usage_exponent\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Encourage Exploration (Early Stage): Prioritize less-utilized bins initially.\n        #    This helps to distribute items across bins, reducing the chance of early convergence\n        #    on suboptimal solutions.  The effect diminishes as bins get filled (adaptive).\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): As packing progresses, prioritize bins that are\n        #    closer to being full. This promotes efficient space utilization.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments to avoid wasting space.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: While fitting snugly is good, extremely close fits can sometimes\n        #    lead to more bins being used overall, so a mild penalty is applied.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: If the item fits reasonably well without creating a tiny fragment or an almost-perfect fit,\n        # it gets a small bonus. This encourages balanced filling.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Large Item Penalty: Discourage placing very large items unless necessary\n        if item > large_item_threshold:\n            priorities[feasible_bins] -= large_item_penalty\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                 exploration_weight: float = 0.35,\n                 almost_full_boost: float = 2.3,\n                 small_remainder_penalty: float = 1.05,\n                 near_perfect_fit_penalty: float = 1.6,\n                 moderate_fit_bonus: float = 0.95,\n                 almost_full_threshold: float = 0.07,\n                 small_remainder_threshold: float = 0.025,\n                 near_perfect_fit_threshold: float = 0.045,\n                 moderate_fit_threshold_low: float = 0.34,\n                 moderate_fit_threshold_high: float = 0.78,\n                 capacity_usage_exponent: float = 1.5,\n                 large_item_penalty: float = 0.5,\n                 large_item_threshold: float = 0.8) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, including remaining capacity,\n    item size relative to bin size, and a penalty for creating small fragments.\n    It also incorporates a mechanism to encourage exploration of less-utilized bins\n    initially and then shift toward filling bins more completely as the packing\n    progresses (Adaptive behavior). This version adds a capacity usage exponent to emphasize\n    the filling of bins and a large item penalty to discourage placing very large items.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        capacity_usage_exponent (float): Exponent to emphasize filling of bins.\n        large_item_penalty (float): Penalty for placing large items.\n        large_item_threshold (float): Threshold for considering an item large (fraction of bin size).\n\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio) - Emphasize filling with exponent\n        utilization = (item / bins_remain_cap) ** capacity_usage_exponent\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Encourage Exploration (Early Stage): Prioritize less-utilized bins initially.\n        #    This helps to distribute items across bins, reducing the chance of early convergence\n        #    on suboptimal solutions.  The effect diminishes as bins get filled (adaptive).\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): As packing progresses, prioritize bins that are\n        #    closer to being full. This promotes efficient space utilization.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments to avoid wasting space.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: While fitting snugly is good, extremely close fits can sometimes\n        #    lead to more bins being used overall, so a mild penalty is applied.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: If the item fits reasonably well without creating a tiny fragment or an almost-perfect fit,\n        # it gets a small bonus. This encourages balanced filling.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Large Item Penalty: Discourage placing very large items unless necessary\n        if item > large_item_threshold:\n            priorities[feasible_bins] -= large_item_penalty\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                 exploration_weight: float = 0.35,\n                 almost_full_boost: float = 2.3,\n                 small_remainder_penalty: float = 1.05,\n                 near_perfect_fit_penalty: float = 1.6,\n                 moderate_fit_bonus: float = 0.95,\n                 almost_full_threshold: float = 0.07,\n                 small_remainder_threshold: float = 0.025,\n                 near_perfect_fit_threshold: float = 0.045,\n                 moderate_fit_threshold_low: float = 0.34,\n                 moderate_fit_threshold_high: float = 0.78,\n                 capacity_usage_exponent: float = 1.5,\n                 large_item_penalty: float = 0.5,\n                 large_item_threshold: float = 0.8) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, including remaining capacity,\n    item size relative to bin size, and a penalty for creating small fragments.\n    It also incorporates a mechanism to encourage exploration of less-utilized bins\n    initially and then shift toward filling bins more completely as the packing\n    progresses (Adaptive behavior). This version adds a capacity usage exponent to emphasize\n    the filling of bins and a large item penalty to discourage placing very large items.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        capacity_usage_exponent (float): Exponent to emphasize filling of bins.\n        large_item_penalty (float): Penalty for placing large items.\n        large_item_threshold (float): Threshold for considering an item large (fraction of bin size).\n\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio) - Emphasize filling with exponent\n        utilization = (item / bins_remain_cap) ** capacity_usage_exponent\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Encourage Exploration (Early Stage): Prioritize less-utilized bins initially.\n        #    This helps to distribute items across bins, reducing the chance of early convergence\n        #    on suboptimal solutions.  The effect diminishes as bins get filled (adaptive).\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): As packing progresses, prioritize bins that are\n        #    closer to being full. This promotes efficient space utilization.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments to avoid wasting space.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: While fitting snugly is good, extremely close fits can sometimes\n        #    lead to more bins being used overall, so a mild penalty is applied.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: If the item fits reasonably well without creating a tiny fragment or an almost-perfect fit,\n        # it gets a small bonus. This encourages balanced filling.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Large Item Penalty: Discourage placing very large items unless necessary\n        if item > large_item_threshold:\n            priorities[feasible_bins] -= large_item_penalty\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                 exploration_weight: float = 0.4547454321191162,\n                 almost_full_boost: float = 4.141162861777289,\n                 small_remainder_penalty: float = 4.0795054878412635,\n                 near_perfect_fit_penalty: float = 1.79837272205777,\n                 moderate_fit_bonus: float = 0.641620136537836,\n                 almost_full_threshold: float = 0.7975366300720903,\n                 small_remainder_threshold: float = 0.6432735229634456,\n                 near_perfect_fit_threshold: float = 0.2217902097194404,\n                 moderate_fit_threshold_low: float = 0.1300795212747079,\n                 moderate_fit_threshold_high: float = 0.3260537680078257,\n                 bin_level_threshold: float = 0.8275929469166272,\n                 bin_level_boost: float = 1.626769834760002) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, adaptively adjusting\n    exploration and exploitation based on bin utilization levels. Adds a bin-level\n    consideration to further refine bin selection.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        bin_level_threshold (float): Threshold to consider a bin at a certain level.\n        bin_level_boost (float): Boost for bins that have passed the bin level.\n\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio)\n        utilization = item / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Adaptive Exploration: Adjust exploration based on bin fill levels.\n        #    Prioritize less-utilized bins when most bins are relatively empty.\n        bin_levels = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalized fill levels\n        average_bin_level = np.mean(bin_levels)\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n\n        # Adjust exploration weight dynamically\n        adaptive_exploration_weight = exploration_weight * (1 - average_bin_level)\n        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization (Later Stage): Prioritize bins that are closer to being full.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: Mild penalty for extremely close fits.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: Bonus for reasonably well-fitting items.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Bin Level consideration\n        bin_level_reached = feasible_bins & (bin_levels >= bin_level_threshold)\n        priorities[bin_level_reached] += bin_level_boost\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines exploration, fill optimization, and fragmentation avoidance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio)\n        utilization = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += utilization\n\n        # 2. Exploration Bonus: Prioritize less-utilized bins.\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += 0.3 * exploration_factor\n\n        # 3. Fill Optimization: Prioritize bins close to full.\n        almost_full_threshold = 0.1\n        almost_full = feasible_bins & (remaining_capacity >= 0) & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 1.2\n\n        # 4. Fragmentation Penalty: Discourage small remainders.\n        small_remainder_threshold = 0.2\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 0.8\n\n        # 5. Perfect Fit Bonus: High bonus\n        perfect_fit = np.abs(remaining_capacity) < 1e-6\n        if np.any(perfect_fit & feasible_bins):\n            priorities[feasible_bins][perfect_fit[feasible_bins]] += 10 #Big bonus\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines exploration, fill optimization, and fragmentation avoidance.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio)\n        utilization = item / bins_remain_cap[feasible_bins]\n        priorities[feasible_bins] += utilization\n\n        # 2. Exploration Bonus: Prioritize less-utilized bins.\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += 0.3 * exploration_factor\n\n        # 3. Fill Optimization: Prioritize bins close to full.\n        almost_full_threshold = 0.1\n        almost_full = feasible_bins & (remaining_capacity >= 0) & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 1.2\n\n        # 4. Fragmentation Penalty: Discourage small remainders.\n        small_remainder_threshold = 0.2\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 0.8\n\n        # 5. Perfect Fit Bonus: High bonus\n        perfect_fit = np.abs(remaining_capacity) < 1e-6\n        if np.any(perfect_fit & feasible_bins):\n            priorities[feasible_bins][perfect_fit[feasible_bins]] += 10 #Big bonus\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive penalties/bonuses based on remaining capacity.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    feasible = bins_remain_cap >= item\n    priorities[~feasible] = -np.inf\n\n    if np.any(feasible):\n        remaining_after = bins_remain_cap[feasible] - item\n        max_cap = np.max(bins_remain_cap)\n\n        # Capacity utilization\n        capacity_utilization = np.exp(-5 * remaining_after / max_cap)\n        priorities[feasible] = capacity_utilization\n\n        # Adaptive near-overflow penalization\n        almost_full_threshold = 0.1 + 0.05 * item\n        almost_full = remaining_after < almost_full_threshold * max_cap\n        priorities[feasible][almost_full] -= 2 * (almost_full_threshold * max_cap - remaining_after[almost_full]) / max_cap\n\n        # Adaptive small remainder penalization\n        small_remainder_threshold = 0.2 - 0.025 * item\n        small_remainder_threshold = max(0.05, small_remainder_threshold)\n        small_remainder = (remaining_after > 0) & (remaining_after <= small_remainder_threshold * max_cap)\n        priorities[feasible][small_remainder] -= 1.5\n\n        # Perfect fit bonus\n        perfect_fit_threshold = 0.01 * max_cap\n        perfect_fit = remaining_after <= perfect_fit_threshold\n        priorities[feasible][perfect_fit] += 1\n\n        # Random tie-breaking\n        priorities[feasible] += np.random.rand(np.sum(feasible)) * 0.05\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness, exploration, and penalties.\n    Combines adaptive exploration with overflow management.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    infeasible = remaining_capacity < 0\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if not np.any(feasible):\n        return priorities\n\n    # Fullness score + prevents divide by zero\n    fullness_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap > 0\n    fullness_scores[valid_bins] = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    fullness_scores[~valid_bins] = 1.0 # assign to 1 when bins_remain_cap <=0\n    priorities[feasible] += (1.0 - fullness_scores[feasible]) #Fillness\n\n    # Exploration bonus, adaptive\n    exploration_factor = bins_remain_cap[feasible] / np.max(bins_remain_cap[feasible])\n    priorities[feasible] += 0.3 * exploration_factor\n\n    # Near-overflow penalty\n    overflow_margin = 0.05 * item\n    near_overflow = feasible & (remaining_capacity < overflow_margin)\n    overflow_penalty = np.exp(5 * (remaining_capacity[near_overflow] - overflow_margin) / overflow_margin)\n    priorities[near_overflow] -= overflow_penalty\n\n    # Perfect fit bonus: Increase the weight slightly.\n    perfect_fit_threshold = 0.001\n    perfect_fit = feasible & (remaining_capacity >= 0) & (remaining_capacity <= perfect_fit_threshold * bins_remain_cap)\n    priorities[perfect_fit] += 0.5\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness, exploration, and penalties.\n    Combines adaptive exploration with overflow management.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    infeasible = remaining_capacity < 0\n    priorities[infeasible] = -np.inf\n\n    feasible = ~infeasible\n    if not np.any(feasible):\n        return priorities\n\n    # Fullness score + prevents divide by zero\n    fullness_scores = np.zeros_like(bins_remain_cap, dtype=float)\n    valid_bins = bins_remain_cap > 0\n    fullness_scores[valid_bins] = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n    fullness_scores[~valid_bins] = 1.0 # assign to 1 when bins_remain_cap <=0\n    priorities[feasible] += (1.0 - fullness_scores[feasible]) #Fillness\n\n    # Exploration bonus, adaptive\n    exploration_factor = bins_remain_cap[feasible] / np.max(bins_remain_cap[feasible])\n    priorities[feasible] += 0.3 * exploration_factor\n\n    # Near-overflow penalty\n    overflow_margin = 0.05 * item\n    near_overflow = feasible & (remaining_capacity < overflow_margin)\n    overflow_penalty = np.exp(5 * (remaining_capacity[near_overflow] - overflow_margin) / overflow_margin)\n    priorities[near_overflow] -= overflow_penalty\n\n    # Perfect fit bonus: Increase the weight slightly.\n    perfect_fit_threshold = 0.001\n    perfect_fit = feasible & (remaining_capacity >= 0) & (remaining_capacity <= perfect_fit_threshold * bins_remain_cap)\n    priorities[perfect_fit] += 0.5\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive, combines fullness, near-overflow penalty, and small remainder penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n\n    if not np.any(fits):\n        return priorities\n\n    # Fullness score\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[remaining_capacities < 0] = 0\n    fullness_scores = np.where(fits, (bins_remain_cap - item) / bins_remain_cap, 1.0) # Avoid inf\n    priorities[fits] = 1.0 - fullness_scores[fits]\n\n    # Adaptive near-overflow penalty\n    overflow_margin = 0.05 * item\n    near_overflow = fits & ((bins_remain_cap - item) < overflow_margin)\n    if np.any(near_overflow):\n        overflow_penalty = np.exp(5 * ((bins_remain_cap[near_overflow] - item - overflow_margin) / overflow_margin))\n        priorities[near_overflow] -= overflow_penalty\n\n    # Adaptive small remainder penalty\n    small_remainder_threshold = 0.2 - 0.05 * item\n    small_remainder_threshold = max(0.05, small_remainder_threshold)\n    small_remainder = fits & (remaining_capacities > 0) & (remaining_capacities <= small_remainder_threshold * bins_remain_cap)\n    priorities[small_remainder] -= 3\n\n    # Encourage filling partially filled bins, adaptive to item size\n    utilization = item / bins_remain_cap\n    current_fill = (bins_remain_cap - remaining_capacities) / bins_remain_cap\n    priorities[fits] += utilization[fits] * (1 + current_fill[fits])\n    \n    # Small random component for exploration\n    priorities[fits] += np.random.rand(np.sum(fits)) * 0.1\n    \n    priorities[bins_remain_cap < item] = -np.inf # Ensure infeasible bins have lowest priority\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive, combines fullness, near-overflow penalty, and small remainder penalty.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n\n    if not np.any(fits):\n        return priorities\n\n    # Fullness score\n    remaining_capacities = bins_remain_cap - item\n    remaining_capacities[remaining_capacities < 0] = 0\n    fullness_scores = np.where(fits, (bins_remain_cap - item) / bins_remain_cap, 1.0) # Avoid inf\n    priorities[fits] = 1.0 - fullness_scores[fits]\n\n    # Adaptive near-overflow penalty\n    overflow_margin = 0.05 * item\n    near_overflow = fits & ((bins_remain_cap - item) < overflow_margin)\n    if np.any(near_overflow):\n        overflow_penalty = np.exp(5 * ((bins_remain_cap[near_overflow] - item - overflow_margin) / overflow_margin))\n        priorities[near_overflow] -= overflow_penalty\n\n    # Adaptive small remainder penalty\n    small_remainder_threshold = 0.2 - 0.05 * item\n    small_remainder_threshold = max(0.05, small_remainder_threshold)\n    small_remainder = fits & (remaining_capacities > 0) & (remaining_capacities <= small_remainder_threshold * bins_remain_cap)\n    priorities[small_remainder] -= 3\n\n    # Encourage filling partially filled bins, adaptive to item size\n    utilization = item / bins_remain_cap\n    current_fill = (bins_remain_cap - remaining_capacities) / bins_remain_cap\n    priorities[fits] += utilization[fits] * (1 + current_fill[fits])\n    \n    # Small random component for exploration\n    priorities[fits] += np.random.rand(np.sum(fits)) * 0.1\n    \n    priorities[bins_remain_cap < item] = -np.inf # Ensure infeasible bins have lowest priority\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fullness, fragmentation, and item size.\n    Adaptive thresholds and bonuses are used to improve performance.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # Adaptive almost full threshold\n        almost_full_threshold = 0.1 + 0.05 * item\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 15\n\n        # Adaptive small remainder penalty\n        small_remainder_threshold = 0.2 - 0.03 * item\n        small_remainder_threshold = max(0.05, small_remainder_threshold)\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 5\n\n        # Adaptive near perfect fit penalty\n        near_perfect_fit_threshold = 0.01 + 0.005 * item\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= 3\n\n        # Utilization priority with current fill consideration\n        utilization = item / bins_remain_cap\n        current_fill = (bins_remain_cap - remaining_capacity) / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins] * (0.75 + current_fill[feasible_bins])\n\n        # Gaussian boost based on capacity difference\n        capacity_difference = np.abs(bins_remain_cap - item)\n        priority_boost = np.exp(-capacity_difference / np.mean(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += priority_boost[feasible_bins] * 1.5\n\n        # Random component for tie-breaking\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fullness, fragmentation, and item size.\n    Adaptive thresholds and bonuses are used to improve performance.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # Adaptive almost full threshold\n        almost_full_threshold = 0.1 + 0.05 * item\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 15\n\n        # Adaptive small remainder penalty\n        small_remainder_threshold = 0.2 - 0.03 * item\n        small_remainder_threshold = max(0.05, small_remainder_threshold)\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 5\n\n        # Adaptive near perfect fit penalty\n        near_perfect_fit_threshold = 0.01 + 0.005 * item\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= 3\n\n        # Utilization priority with current fill consideration\n        utilization = item / bins_remain_cap\n        current_fill = (bins_remain_cap - remaining_capacity) / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins] * (0.75 + current_fill[feasible_bins])\n\n        # Gaussian boost based on capacity difference\n        capacity_difference = np.abs(bins_remain_cap - item)\n        priority_boost = np.exp(-capacity_difference / np.mean(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += priority_boost[feasible_bins] * 1.5\n\n        # Random component for tie-breaking\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fullness, fragmentation, and item size.\n    Adaptive thresholds and bonuses are used to improve performance.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # Adaptive almost full threshold\n        almost_full_threshold = 0.1 + 0.05 * item\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 15\n\n        # Adaptive small remainder penalty\n        small_remainder_threshold = 0.2 - 0.03 * item\n        small_remainder_threshold = max(0.05, small_remainder_threshold)\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 5\n\n        # Adaptive near perfect fit penalty\n        near_perfect_fit_threshold = 0.01 + 0.005 * item\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= 3\n\n        # Utilization priority with current fill consideration\n        utilization = item / bins_remain_cap\n        current_fill = (bins_remain_cap - remaining_capacity) / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins] * (0.75 + current_fill[feasible_bins])\n\n        # Gaussian boost based on capacity difference\n        capacity_difference = np.abs(bins_remain_cap - item)\n        priority_boost = np.exp(-capacity_difference / np.mean(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += priority_boost[feasible_bins] * 1.5\n\n        # Random component for tie-breaking\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fullness, fragmentation, and item size.\n    Adaptive thresholds and bonuses are used to improve performance.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # Adaptive almost full threshold\n        almost_full_threshold = 0.1 + 0.05 * item\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 15\n\n        # Adaptive small remainder penalty\n        small_remainder_threshold = 0.2 - 0.03 * item\n        small_remainder_threshold = max(0.05, small_remainder_threshold)\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 5\n\n        # Adaptive near perfect fit penalty\n        near_perfect_fit_threshold = 0.01 + 0.005 * item\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= 3\n\n        # Utilization priority with current fill consideration\n        utilization = item / bins_remain_cap\n        current_fill = (bins_remain_cap - remaining_capacity) / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins] * (0.75 + current_fill[feasible_bins])\n\n        # Gaussian boost based on capacity difference\n        capacity_difference = np.abs(bins_remain_cap - item)\n        priority_boost = np.exp(-capacity_difference / np.mean(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += priority_boost[feasible_bins] * 1.5\n\n        # Random component for tie-breaking\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.1\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins considering fullness, fragmentation, item size, and randomness.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    priorities[remaining_capacity < 0] = -np.inf\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # Adaptive almost full, big items prefer emptier bins\n        almost_full_threshold = 0.1 + 0.05 * (item)\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += 12\n\n        # Penalize near-perfect fit, inversely proportional to item size\n        near_perfect_fit_threshold = 0.01\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= 1 + 0.5 * item\n\n        # Adaptive small remainder penalty\n        small_remainder_threshold = 0.2 - 0.05 * (item)\n        small_remainder_threshold = max(0.05, small_remainder_threshold)\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 4\n\n        # Utilization scaled by item and current fill, fill empty\n        utilization = item / bins_remain_cap\n        current_fill = (bins_remain_cap - remaining_capacity) / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins] * (0.7 + current_fill[feasible_bins])\n\n        # Encourage bins with remaining capacity close to item size\n        capacity_difference = np.abs(bins_remain_cap[feasible_bins] - item)\n        priority_boost = np.exp(-capacity_difference / np.mean(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += priority_boost * 1.5\n\n        # Small random to break ties and explore, decrease impact\n        priorities[feasible_bins] += np.random.rand(np.sum(feasible_bins)) * 0.08\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines utilization, balanced packing, and adaptive penalties.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n    priorities[remaining_capacity < 0] = -np.inf\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # Utilization priority, scaled by item size\n        utilization = item / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins] * (0.7 + item)\n\n        # Balanced utilization\n        target_utilization = 0.75\n        expected_utilization = (bins_remain_cap[feasible_bins] - remaining_capacity[feasible_bins]) / bins_remain_cap[feasible_bins]\n        balanced_utilization_score = np.exp(-((expected_utilization - target_utilization)**2) / 0.02)\n        priorities[feasible_bins] += 3 * balanced_utilization_score\n\n        # Adaptive near-perfect fit penalty\n        near_perfect_fit_threshold = 0.05\n        near_perfect_fit = feasible_bins & (remaining_capacity <= near_perfect_fit_threshold * bins_remain_cap)\n        priorities[near_perfect_fit] -= 5 # Reduced penalty\n\n        # Adaptive small remainder penalty\n        small_remainder_threshold = 0.15\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= 3\n\n        # Encourage partially filled bins\n        already_filled_threshold_low = 0.2\n        already_filled_threshold_high = 0.9\n        already_filled = feasible_bins & (bins_remain_cap > already_filled_threshold_low * np.max(bins_remain_cap)) & (bins_remain_cap < already_filled_threshold_high * np.max(bins_remain_cap))\n        priorities[already_filled] += 1\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float,\n                  bins_remain_cap: np.ndarray,\n                  exploration_weight: float = 0.4,\n                  almost_full_boost: float = 2.5,\n                  small_remainder_penalty: float = 1.1,\n                  near_perfect_fit_penalty: float = 1.6,\n                  moderate_fit_bonus: float = 1.0,\n                  almost_full_threshold: float = 0.07,\n                  small_remainder_threshold: float = 0.02,\n                  near_perfect_fit_threshold: float = 0.04,\n                  moderate_fit_threshold_low: float = 0.3,\n                  moderate_fit_threshold_high: float = 0.8,\n                  bin_diversity_boost: float = 0.2) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on a combination of factors, including remaining capacity,\n    item size relative to bin size, and a penalty for creating small fragments.\n    It incorporates a mechanism to encourage exploration and exploitation,\n    and dynamically adjusts bin priorities based on remaining capacities,\n    item sizes, and additional bonuses.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n        exploration_weight (float): Weight for exploration factor.\n        almost_full_boost (float): Boost for almost full bins.\n        small_remainder_penalty (float): Penalty for small remainders.\n        near_perfect_fit_penalty (float): Penalty for near perfect fits.\n        moderate_fit_bonus (float): Bonus for moderate fits.\n        almost_full_threshold (float): Threshold for considering a bin almost full (fraction of bin size).\n        small_remainder_threshold (float): Threshold for considering a remainder small (fraction of bin size).\n        near_perfect_fit_threshold (float): Threshold for considering a fit near perfect (fraction of bin size).\n        moderate_fit_threshold_low: Lower threshold for moderate fit (fraction of bin size).\n        moderate_fit_threshold_high: Higher threshold for moderate fit (fraction of bin size).\n        bin_diversity_boost (float): Boost to encourage filling bins with diverse fill levels.\n\n    Returns:\n        np.ndarray: An array containing the priority score for each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    remaining_capacity = bins_remain_cap - item\n\n    # Infeasible bins get the lowest priority\n    priorities[remaining_capacity < 0] = -np.inf\n\n    feasible_bins = remaining_capacity >= 0\n\n    if np.any(feasible_bins):\n        # 1. Base Priority: Bin Utilization (Fill Ratio)\n        utilization = item / bins_remain_cap\n        priorities[feasible_bins] += utilization[feasible_bins]\n\n        # 2. Encourage Exploration (Adaptive): Prioritize less-utilized bins.\n        # Adjust exploration based on how full the bins are on average.\n        average_fill = 1 - np.mean(bins_remain_cap)\n        adaptive_exploration_weight = exploration_weight * (1 - average_fill)  # Reduce exploration as bins fill\n        exploration_factor = (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap[feasible_bins]))\n        priorities[feasible_bins] += adaptive_exploration_weight * exploration_factor\n\n        # 3. Fill-Optimization: Prioritize bins that are closer to being full.\n        almost_full = feasible_bins & (remaining_capacity <= almost_full_threshold * bins_remain_cap)\n        priorities[almost_full] += almost_full_boost\n\n        # 4. Fragmentation Penalty: Discourage creating small remaining fragments.\n        small_remainder = feasible_bins & (remaining_capacity > 0) & (remaining_capacity <= small_remainder_threshold * bins_remain_cap)\n        priorities[small_remainder] -= small_remainder_penalty\n\n        # 5. Near-Perfect Fit Penalty: Slightly discourage near perfect fits.\n        near_perfect_fit = feasible_bins & (remaining_capacity > (1 - near_perfect_fit_threshold) * bins_remain_cap)\n        priorities[near_perfect_fit] -= near_perfect_fit_penalty\n\n        # 6. Moderate-Fit Bonus: Encourage balanced filling.\n        moderate_fit = feasible_bins & ~almost_full & ~small_remainder & ~near_perfect_fit\n        moderate_fit = moderate_fit & (remaining_capacity >= moderate_fit_threshold_low * bins_remain_cap) & (remaining_capacity <= moderate_fit_threshold_high * bins_remain_cap)\n        priorities[moderate_fit] += moderate_fit_bonus\n\n        # 7. Bin Diversity Boost: Encourage filling bins with different fill levels to prevent premature convergence.\n        bin_fill_levels = 1 - (bins_remain_cap[feasible_bins] / np.max(bins_remain_cap))\n        diversity_score = np.std(bin_fill_levels)  # Standard deviation of fill levels\n        priorities[feasible_bins] += bin_diversity_boost * diversity_score\n        \n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}