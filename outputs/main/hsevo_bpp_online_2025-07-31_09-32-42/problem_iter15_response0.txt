```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, implementing a Best Fit
    strategy with a significant, fixed bonus for perfect fits.

    This heuristic is a mutation of priority_v1. It enhances the Best Fit strategy by
    applying a substantial, fixed additive adjustment to the priority of bins that result
    in a perfect fit (zero remaining capacity). This ensures that perfect fits are
    unequivocally prioritized above any non-perfect fit, regardless of how small the
    remaining capacity might be in other bins. For non-perfect fits, it retains the
    original Best Fit preference (minimizing remaining space), but ensures its scores
    are always strictly less than a perfect fit's score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Perfect fits receive a high fixed score. Other fits receive a score based on
        the negative of their remaining space. Bins that cannot fit the item receive -inf.
    """
    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Define a significant fixed bonus for perfect fits.
    # This value is chosen to be strictly greater than the maximum possible score
    # achievable by any non-perfect fit. Assuming normalized bin capacities (e.g., 0 to 1),
    # -potential_remaining_space for non-perfect fits ranges from slightly below 0 down to -1.
    # A value like 1.0 or 100.0 ensures perfect fits are clearly superior.
    PERFECT_FIT_BONUS = 100.0

    # Create masks for different categories of bins
    can_fit_mask = potential_remaining_space >= 0
    perfect_fit_mask = (potential_remaining_space == 0)
    
    # Identify bins where the item can fit but NOT perfectly.
    # This is equivalent to `can_fit_mask` AND `NOT perfect_fit_mask`
    non_perfect_fit_mask = can_fit_mask & (~perfect_fit_mask)

    # Assign priority for bins where the item fits but not perfectly.
    # This part retains the core Best Fit logic from priority_v1:
    # a smaller positive remaining space yields a higher (less negative) priority.
    # These scores will always be <= 0 (e.g., 0.0 for near-perfect, -0.5 for half-empty).
    priorities[non_perfect_fit_mask] = -potential_remaining_space[non_perfect_fit_mask]

    # Apply the fixed, additive adjustment for perfect fits.
    # These bins will receive a substantially higher score than any non-perfect fit,
    # making them the absolute top priority if available.
    priorities[perfect_fit_mask] = PERFECT_FIT_BONUS

    return priorities
```
