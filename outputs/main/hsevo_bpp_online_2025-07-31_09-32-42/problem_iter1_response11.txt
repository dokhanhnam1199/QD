```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin.

    Drawing inspiration from the principles of nature, where systems tend to settle
    into states of minimal energy, this heuristic guides the item towards the bin
    that will result in the smallest amount of 'empty space entropy' after the
    item is placed. We seek to achieve the highest possible 'packing density' within
    each chosen bin, much like how matter clusters efficiently in gravitational fields.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a more desirable bin. Bins that cannot fit the
        item are assigned a very low (negative infinity) priority.
    """
    # Initialize all bin priorities to a very low value.
    # This ensures that bins incapable of holding the item are effectively ignored,
    # and if no bin can hold the item, the system understands a new bin is needed.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient remaining capacity to accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # For those bins that can fit the item, calculate a 'fitness score'.
    # This score is derived from the 'remaining capacity' after placing the item.
    # A smaller remaining capacity implies a 'tighter' or 'better' fit, minimizing
    # wasted space. To make 'smaller remaining capacity' correspond to a 'higher priority',
    # we take the negative of this value.
    #
    # Example:
    # If item=0.3 and bin_capacity=0.5, remaining_space = 0.2. Priority = -0.2.
    # If item=0.3 and bin_capacity=0.3, remaining_space = 0.0 (perfect fit). Priority = 0.0.
    # If item=0.3 and bin_capacity=0.7, remaining_space = 0.4. Priority = -0.4.
    #
    # Maximizing this priority will naturally select the bin with the smallest
    # positive remaining capacity, including a perfect fit (0.0), making it a
    # robust 'Best Fit' heuristic.
    
    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Assign the calculated negative remaining space as the priority.
    priorities[can_fit_mask] = -remaining_space_after_fit

    return priorities
```
