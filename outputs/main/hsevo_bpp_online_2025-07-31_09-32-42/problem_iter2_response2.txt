```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with a non-linear inverse priority for tight fits.

    Prioritizes bins by 1/(remaining_capacity + epsilon), giving strong preference
    to very tight or perfect fits. Unsuitable bins get lowest priority (-inf).
    """
    # Initialize all priority scores to negative infinity. This robustly
    # disqualifies any bin that cannot fit the item, aligning with best practices.
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can potentially fit (remaining capacity >= item size).
    fitting_bins_mask = bins_remain_cap >= item

    # Calculate the remaining capacity if the item were placed in the fitting bins.
    # This is effectively the 'waste' for bins where the item fits.
    potential_remaining_cap = bins_remain_cap[fitting_bins_mask] - item

    # Define a small epsilon for numerical stability. This handles perfect fits (waste = 0)
    # by assigning them a very high, but finite, priority (1/epsilon), and stabilizes
    # the inverse calculation for extremely small positive wastes. This implements the
    # "1.0 / (remaining_waste + epsilon)" strategy praised for its non-linear preference.
    EPSILON = np.finfo(float).eps

    # For bins where the item fits, calculate priority using the inverse of
    # (potential_remaining_cap + EPSILON). A smaller remaining capacity (tighter fit)
    # results in a proportionally larger priority score, strongly favoring tightest fits.
    priority_scores[fitting_bins_mask] = 1.0 / (potential_remaining_cap + EPSILON)

    return priority_scores
```
