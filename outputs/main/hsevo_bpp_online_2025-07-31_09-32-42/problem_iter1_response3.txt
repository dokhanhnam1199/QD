```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    inspired by the principle of efficient packing and minimizing waste.

    As a scientist observing the delicate balance of matter, I believe in
    optimizing the use of space. This heuristic, akin to finding the most
    'stable' configuration for a new particle, aims to select the bin that
    will be most 'tightly' filled by the incoming 'particle' (item).
    It seeks to leave the smallest possible non-negative remainder,
    analogous to achieving the densest and most efficient atomic packing.

    Bins where the item cannot fit are, naturally, given a very low priority,
    as they are not suitable 'vessels' for our particle.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more preferred bin.
    """
    # Initialize priorities. Bins where the item cannot fit will receive -infinity,
    # ensuring they are never chosen. This represents an 'impossible fit'.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins are large enough to accommodate the incoming item.
    # These are our 'candidate containers'.
    can_fit_mask = bins_remain_cap >= item

    # For the candidate bins, we calculate the 'remaining void' if the item were placed.
    # My objective is to minimize this 'void', making the most efficient use of each container.
    # Therefore, we prioritize bins that result in the smallest positive remaining capacity.
    # By negating this remaining capacity, a smaller (closer to zero) positive remainder
    # translates into a larger (closer to zero or positive) priority score.
    # This effectively implements the "Best Fit" strategy, where exact fits (0 remaining)
    # receive the highest score (0), and larger remainders receive more negative scores.
    # Example:
    # item = 0.5
    # bin_capacity_1 = 1.0  => remainder = 0.5  => priority = -0.5
    # bin_capacity_2 = 0.6  => remainder = 0.1  => priority = -0.1 (Best Fit)
    # bin_capacity_3 = 0.5  => remainder = 0.0  => priority = 0.0 (Exact Fit, highest possible)
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    return priorities
```
