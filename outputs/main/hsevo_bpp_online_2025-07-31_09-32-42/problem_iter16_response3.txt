import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                perfect_fit_bonus: float = 59178.206953262765,
                consolidation_bonus: float = 49.29930433034949) -> np.ndarray:
    """
    Combines Best Fit with strong bonuses for perfect fits and consolidating
    items into already partially-filled bins.
    """
    # Initialize priorities to negative infinity. Bins that cannot fit the item
    # will maintain this low priority and thus never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Identify bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0
    
    # Extract relevant values for bins where the item can fit for efficient computation.
    valid_remaining_space = potential_remaining_space[can_fit_mask]
    
    # --- Core Priority: Best Fit Principle ---
    # Assign a base score to eligible bins. Prioritize bins that would have the
    # least remaining space (i.e., closest to a perfect fit but not necessarily 0).
    # A smaller positive remaining space results in a higher (less negative) score.
    priorities[can_fit_mask] = -valid_remaining_space

    # --- Consolidation Bonus (Strategic Fill) ---
    # Apply a fixed bonus to bins that are already partially utilized (not full, not empty).
    # This encourages packing into existing bins before opening new ones (assuming full capacity
    # is the maximum value in bins_remain_cap).
    if bins_remain_cap.size > 0: # Avoid errors on empty bin list
        # Determine what "full capacity" means from the current bin capacities.
        # This assumes the largest capacity in the array represents a "new/empty" bin.
        max_current_cap = np.max(bins_remain_cap)
        
        # Identify bins that are currently partially filled (not completely empty, not full).
        is_partially_filled_pre_placement = (bins_remain_cap < max_current_cap) & (bins_remain_cap > 0)
        
        # Apply consolidation bonus to bins that can fit the item AND are partially filled.
        consolidation_eligible_mask = can_fit_mask & is_partially_filled_pre_placement
        priorities[consolidation_eligible_mask] += consolidation_bonus

    # --- Perfect Fit Bonus (Dominant Override) ---
    # Apply a very large, fixed bonus to guarantee that exact fits (remaining space == 0)
    # are always the highest possible priority. This overrides any other score for perfect fits.
    perfect_fit_mask = (valid_remaining_space == 0)
    # Apply the bonus to the subset of priorities corresponding to fitting bins that are perfect fits.
    priorities[can_fit_mask][perfect_fit_mask] += perfect_fit_bonus

    return priorities
