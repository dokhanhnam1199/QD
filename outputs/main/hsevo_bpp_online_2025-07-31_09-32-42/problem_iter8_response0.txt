```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, BIN_CAPACITY: float) -> np.ndarray:
    """
    Combines robust Best Fit with explicit perfect fit prioritization and
    an adaptive bias for bin consolidation.
    """
    # Initialize all priorities to negative infinity, marking bins that cannot fit the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return the initialized priorities.
    if not np.any(can_fit_mask):
        return priorities

    # --- Constants for Heuristic Scoring ---
    # A small epsilon for numerical stability, preventing division by zero in inverse calculations.
    STABILITY_EPSILON = np.finfo(float).eps

    # Tolerance for identifying near-perfect fits, scaled by the bin capacity for robustness.
    PERFECT_FIT_TOLERANCE = 1e-9 * BIN_CAPACITY 
    # A very high score to ensure perfect fits are chosen over any other option.
    PERFECT_FIT_SCORE = 1e15 

    # Define the weight of the consolidation bias. This is a tunable parameter.
    # It subtly promotes filling already utilized bins.
    CONSOLIDATION_BIAS_WEIGHT = 0.05 

    # --- Calculations for fitting bins ---
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    potential_remaining_space = fitting_bins_remain_cap - item

    # 1. Prioritize Perfect Fits: Identify and assign an overwhelmingly high score to near-perfect fits.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE
    
    # Apply the perfect fit score to the corresponding bins.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    # 2. For Non-Perfect Fits: Apply Best Fit (inverse waste) combined with an adaptive consolidation bias.
    non_perfect_fit_mask_in_fitting = ~perfect_fit_mask_in_fitting
    
    if np.any(non_perfect_fit_mask_in_fitting):
        non_perfect_potential_rem = potential_remaining_space[non_perfect_fit_mask_in_fitting]
        
        # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).
        # This strongly favors bins that result in minimal remaining waste.
        best_fit_scores = 1.0 / (non_perfect_potential_rem + STABILITY_EPSILON)

        # Adaptive Consolidation Bias Component:
        # Encourage packing into existing, more utilized bins to reduce the total bin count.
        # The 'fullness' is determined relative to the most empty bin currently available,
        # making the bias adaptive to the current system state.
        max_rem_cap_overall = np.max(bins_remain_cap)
        
        # Calculate the relative "fullness" of each fitting non-perfect bin.
        # A lower remaining capacity (more full) results in a higher fullness score.
        relative_fullness = (max_rem_cap_overall - fitting_bins_remain_cap[non_perfect_fit_mask_in_fitting]) / \
                            (max_rem_cap_overall + STABILITY_EPSILON)
        
        # Combine the Best Fit score with the adaptive consolidation bias.
        # The bias is added to the Best Fit score, subtly promoting fuller bins.
        combined_scores = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * relative_fullness
        
        # Apply these combined scores to the non-perfect fitting bins.
        priorities[can_fit_mask][non_perfect_fit_mask_in_fitting] = combined_scores

    return priorities
```
