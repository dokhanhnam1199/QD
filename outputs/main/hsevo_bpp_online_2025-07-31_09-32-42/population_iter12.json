[
  {
    "stdout_filepath": "problem_iter11_response0.txt_stdout.txt",
    "code_path": "problem_iter11_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Robust Best Fit heuristic that favors least remaining capacity.\n\n    This function implements a highly effective Best Fit strategy by prioritizing bins\n    that result in the smallest remaining capacity after placing the item. This simple,\n    local rule naturally encourages filling bins and achieves consolidation without\n    complex parameters or conflicting objectives, aligning with emergent behavior principles.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    # A smaller positive value here means a \"better fit\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the negative\n    # of the potential remaining space.\n    # By maximizing this value, we effectively minimize the potential remaining space.\n    # A perfect fit (0 remaining space) naturally results in a priority of 0 (the highest possible),\n    # embodying the \"perfect fit\" priority without explicit, hardcoded scores.\n    # This approach synthesizes the robustness of simple Best Fit from the \"better code\"\n    # and the rejection of complex, sensitive parameters from the \"worse code\" analysis.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response1.txt_stdout.txt",
    "code_path": "problem_iter11_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using Best Fit with a dominant exact fit bonus and a subtle\n    consolidation preference for partially filled bins.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for normalization.\n    BIN_CAPACITY = 1.0\n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to a very high value to ensure exact fits are chosen first.\n    PERFECT_FIT_BONUS = 1e9 \n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing bins.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty, and are not perfect fits.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response2.txt_stdout.txt",
    "code_path": "problem_iter11_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a robust inverse-waste fit, naturally favoring\n    perfect fits, combined with an additive consolidation bias. Avoids explicit\n    epsilon or max scores for numerical stability and clearer logic.\n    \"\"\"\n    BIN_CAPACITY = 1.0\n    CONSOLIDATION_FACTOR = 0.1  # A small factor to encourage consolidation\n\n    # Initialize all priorities to negative infinity. Bins that cannot fit the item\n    # will retain this value, ensuring they are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # A tiny tolerance is still implicitly handled by np.where later, but the core\n    # logic avoids explicit perfect fit checks for score calculation.\n    can_fit_mask = potential_remaining_space >= 0 \n\n    # If no bins can fit, return the initialized (all -inf) priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Extract relevant data for bins where the item can fit.\n    fitting_potential_rem_space = potential_remaining_space[can_fit_mask]\n    fitting_bins_original_cap = bins_remain_cap[can_fit_mask]\n\n    # Calculate the primary score: Inverse of (waste + 1).\n    # Adding 1 to waste ensures no division by zero and results in scores > 0.\n    # Perfect fits (waste=0) naturally get the highest primary score (1.0).\n    fit_score = 1.0 / (fitting_potential_rem_space + 1.0)\n\n    # Calculate current bin fullness: (BIN_CAPACITY - current_remaining_capacity) / BIN_CAPACITY.\n    # This term acts as an additive bias, encouraging consolidation by slightly preferring\n    # bins that are already well-filled, given similar fit scores.\n    current_bin_fullness = (BIN_CAPACITY - fitting_bins_original_cap) / BIN_CAPACITY\n    \n    # Combine the fit score with the consolidation bias.\n    # This forms a continuous priority function without discrete jumps for 'perfect fits'\n    # but still naturally prioritizes them due to the inverse waste component.\n    fitting_priorities = fit_score + CONSOLIDATION_FACTOR * current_bin_fullness\n\n    # Update the main priorities array with the scores for fitting bins.\n    priorities[can_fit_mask] = fitting_priorities\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines robust inverse Best Fit with additive consolidation and explicit perfect fit.\n    Prioritizes minimal waste, encourages using fuller bins, ensuring perfect fits are optimal.\n    \"\"\"\n    # Initialize all priorities to negative infinity. Bins unable to fit are unequivocally marked as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities, indicating no valid choice.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # --- Step 1: Calculate core Best Fit (inverse waste) and Adaptive Consolidation scores ---\n\n    # Calculate the potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Use machine epsilon for numerical stability in inverse calculations, preventing division by zero\n    # when potential_remaining_space is exactly zero (before perfect fit override) or very small.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).\n    # This strongly favors bins that result in the smallest amount of remaining space (tightest fit),\n    # aligning with the principle of waste minimization.\n    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)\n\n    # Adaptive Consolidation Bias Component: Promote packing into already fuller bins.\n    # This encourages overall bin consolidation, aiming to reduce the total number of bins used.\n    # The 'max_rem_cap' provides a dynamic reference for the current \"emptiest\" bin,\n    # making the bias adaptive to the current state of open bins.\n    max_rem_cap = np.max(bins_remain_cap)\n\n    # Calculate the relative \"fullness\" of each fitting bin. A lower bins_remain_cap\n    # indicates a fuller bin, resulting in a higher relative_fullness score (closer to 1).\n    # Handle the edge case where max_rem_cap is zero or near zero to prevent division issues\n    # and ensure consolidation bias doesn't lead to unintended behavior when all bins are full.\n    if max_rem_cap <= EPSILON:\n        relative_fullness = np.zeros_like(potential_remaining_space)\n    else:\n        relative_fullness = (max_rem_cap - bins_remain_cap[can_fit_mask]) / max_rem_cap\n\n    # Tunable weight for the consolidation bias. A small positive value ensures this additive bias\n    # influences decisions without overpowering the primary waste minimization objective.\n    # Analysis indicates additive biases are generally more robust than multiplicative ones.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05\n\n    # Combine the Best Fit score with the adaptive consolidation bias.\n    # This forms the base priority for all bins that can accommodate the item.\n    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * relative_fullness\n\n    # --- Step 2: Explicitly boost perfect fits to ensure their absolute priority ---\n\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    # Using an absolute tolerance for robustness, not scaled by bin_capacity, for simplicity.\n    PERFECT_FIT_TOLERANCE = 1e-9 \n\n    # A very high score to ensure perfect fits are chosen over any other option.\n    # This value must be significantly larger than any possible score derived from Step 1\n    # to guarantee that a perfect fit always receives the highest priority.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the bins that can fit the item.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits.\n    # This overrides any previously calculated score for these specific bins, making\n    # perfect fits the unequivocally best choice, which is a common and effective heuristic.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit with perfect fit bonus, adaptive fragmentation penalty, and subtle fullness bias.\n\n    This heuristic combines the robust Best Fit core from `priority_v0` with an additive\n    consolidation bonus inspired by `priority_v1`, designed to avoid the instability\n    of multiplicative factors. It prioritizes:\n    1. Perfect fits (leaving 0 remaining capacity) with a very high score.\n    2. Non-perfect fits based on Best Fit (minimizing remaining capacity).\n    3. Penalizes bins that would be left with a very small, potentially unusable,\n       positive remaining capacity (fragmentation avoidance, adapted from `priority_v0`).\n    4. Subtly favors bins that are already fuller to encourage consolidation\n       (additive bonus, designed for stability).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive the lowest possible priority (-np.inf).\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for scaling purposes.\n    # In many BPP contexts, item sizes and bin capacities are normalized to 1.0.\n    BIN_CAPACITY = 1.0 \n    \n    # Epsilon for robust float comparisons (to distinguish true zero from very small positive floats)\n    EPSILON = 1e-9\n\n    # Mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can accommodate the current item, return the initialized priorities (-np.inf for all).\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the potential remaining space if the item were placed in fit-able bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n    \n    # Store the original remaining capacities for fit-able bins to calculate the fullness bonus later.\n    original_bins_remain_cap_for_valid = bins_remain_cap[can_fit_mask]\n\n    # Initialize a temporary array to hold priorities for valid bins.\n    priorities_valid = np.zeros_like(potential_remaining_space, dtype=float)\n\n    # --- Scoring Logic ---\n\n    # 1. Highest Priority: Perfect Fit\n    # Identify bins where the remaining space after placing the item would be virtually zero.\n    perfect_fit_mask_in_valid = (np.abs(potential_remaining_space) < EPSILON)\n    # Assign a very high, distinct score to ensure these bins are always chosen first.\n    priorities_valid[perfect_fit_mask_in_valid] = 1000.0 \n\n    # 2. Non-Perfect Fits: Apply Best Fit, Fragmentation Avoidance, and Consolidation Bias.\n    non_perfect_fit_mask_in_valid = ~perfect_fit_mask_in_valid\n    \n    # Get the remaining spaces for bins that are non-perfect fits.\n    r_non_perfect = potential_remaining_space[non_perfect_fit_mask_in_valid]\n    \n    # Get the original remaining capacities for these non-perfect fit bins.\n    original_rem_cap_non_perfect = original_bins_remain_cap_for_valid[non_perfect_fit_mask_in_valid]\n\n    # a. Base Best Fit component: Prioritize smaller remaining space.\n    # A smaller 'r' (closer to 0) results in a higher score. Scales the score to be in a\n    # manageable range (e.g., 0 to 100 if BIN_CAPACITY is 1.0).\n    best_fit_component = (BIN_CAPACITY - r_non_perfect) / BIN_CAPACITY * 100.0\n\n    # b. Strategic Fragmentation Penalty: Penalize leaving very small, positive remaining spaces.\n    # These fragmented spaces are often hard to utilize for future items.\n    # Defines thresholds for \"fragmented\" space: relative to the item size and an absolute minimum.\n    FRAGMENT_THRESHOLD_RELATIVE_TO_ITEM = 0.5  # e.g., < 50% of current item size\n    FRAGMENT_THRESHOLD_ABSOLUTE = 0.1 * BIN_CAPACITY # e.g., < 10% of total bin capacity\n    \n    # Identify if a remaining space is considered \"fragmented\".\n    is_fragmented_space = (r_non_perfect > EPSILON) & \\\n                          (r_non_perfect < np.minimum(item * FRAGMENT_THRESHOLD_RELATIVE_TO_ITEM, FRAGMENT_THRESHOLD_ABSOLUTE))\n\n    # Apply a penalty for fragmented spaces. The penalty's magnitude is scaled by the item's size,\n    # meaning larger items creating small, useless gaps incur a higher penalty.\n    FRAGMENT_PENALTY_SCALAR = 50.0 # Tunable: Adjust magnitude of the penalty.\n    fragmentation_penalty = np.where(is_fragmented_space, item * FRAGMENT_PENALTY_SCALAR, 0.0)\n\n    # c. Consolidation Bonus: A subtle, additive bonus for bins that are already fuller.\n    # This encourages closing bins faster without drastically altering the Best Fit order.\n    # The bonus is higher for bins that have less remaining capacity (i.e., are more full).\n    # It scales linearly from 0 (for an empty bin) up to CONSOLIDATION_FACTOR (for a full bin).\n    CONSOLIDATION_FACTOR = 5.0 # Tunable: A small value to avoid overpowering Best Fit.\n    consolidation_bonus = (BIN_CAPACITY - original_rem_cap_non_perfect) / BIN_CAPACITY * CONSOLIDATION_FACTOR\n    \n    # Combine all components: Base Best Fit score, minus fragmentation penalty, plus consolidation bonus.\n    strategic_priorities_non_perfect = best_fit_component - fragmentation_penalty + consolidation_bonus\n    \n    # Assign these calculated scores back to the 'priorities_valid' array for non-perfect fits.\n    priorities_valid[non_perfect_fit_mask_in_valid] = strategic_priorities_non_perfect\n\n    # Place the calculated valid priorities back into the main 'priorities' array using the mask.\n    priorities[can_fit_mask] = priorities_valid\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response5.txt_stdout.txt",
    "code_path": "problem_iter11_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a robust Best Fit heuristic with a strong bonus for exact fits,\n    prioritizing minimal remaining capacity.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n    \n    # Extract relevant values for bins where the item can fit.\n    valid_remaining_space = potential_remaining_space[can_fit_mask]\n    \n    # --- Core Priority: Best Fit Principle ---\n    # This component prioritizes bins that will have the least remaining space.\n    # A smaller positive remaining space (closer to a perfect fit) leads to a higher\n    # (less negative, closer to 0) base score. A perfect fit (0 remaining space)\n    # gets a base score of 0 here.\n    priorities[can_fit_mask] = -valid_remaining_space\n\n    # --- Strategic Adjustment: Perfect Fit Bonus ---\n    # Apply a large, fixed bonus to guarantee that exact fits are the highest priority.\n    # This is a critical override for optimal bin packing.\n    PERFECT_FIT_BONUS = 1000.0  # A sufficiently large, fixed constant\n    \n    perfect_fit_mask = (valid_remaining_space == 0)\n    priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response6.txt_stdout.txt",
    "code_path": "problem_iter11_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by inverse remaining waste (Best Fit),\n    rewards perfect fits, and severely penalizes small, unusable gaps.\n    \"\"\"\n    PERFECT_FIT_TOLERANCE = 1e-9  # Tolerance for floating point perfect fit check\n    PERFECT_FIT_SCORE = 1e12    # Very high score for perfect fits to ensure selection\n    STABILITY_EPSILON = np.finfo(float).eps # Small epsilon for numerical stability in inverse division\n\n    SMALL_GAP_THRESHOLD = 0.05  # Threshold for what constitutes a \"small gap\"\n    # A large negative penalty to significantly de-prioritize bins leaving small, bad gaps.\n    SMALL_GAP_SEVERE_PENALTY = 1000.0 \n\n    # Initialize all priorities to negative infinity. Bins that cannot fit the item\n    # will retain this lowest priority and thus will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n    \n    # If no bin can fit, return the initialized priorities (all -inf).\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining space in these bins if the item were placed.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Initialize priorities for the subset of currently valid bins.\n    current_bin_priorities = np.zeros_like(potential_remaining_space)\n\n    # 1. Assign Perfect Fit Score: If remaining space is zero (within tolerance), it's a perfect fit.\n    # These should always be the highest priority, guaranteeing immediate selection.\n    perfect_fit_mask = potential_remaining_space <= PERFECT_FIT_TOLERANCE\n    current_bin_priorities[perfect_fit_mask] = PERFECT_FIT_SCORE\n\n    # 2. Assign Inverse Waste Score for Non-Perfect Fits: For bins where the item fits\n    # but some space remains, prioritize inversely to the remaining waste. Smaller waste\n    # yields higher priority, embodying the Best Fit principle. Add epsilon for numerical stability.\n    non_perfect_fit_mask = potential_remaining_space > PERFECT_FIT_TOLERANCE\n    \n    # Only calculate for non-perfect fits where remaining space is positive.\n    if np.any(non_perfect_fit_mask):\n        current_bin_priorities[non_perfect_fit_mask] = \\\n            1.0 / (potential_remaining_space[non_perfect_fit_mask] + STABILITY_EPSILON)\n\n    # 3. Apply Small Gap Penalty: Identify non-perfect fits that result in a \"small gap\".\n    # These are highly undesirable as they fragment bin capacity, making it harder to fit future items.\n    # Apply a severe penalty to make them much less attractive than larger, more usable remaining spaces.\n    small_gap_to_penalize_mask = (potential_remaining_space > PERFECT_FIT_TOLERANCE) & \\\n                                 (potential_remaining_space < SMALL_GAP_THRESHOLD)\n    \n    # Apply penalty only to relevant bins\n    if np.any(small_gap_to_penalize_mask):\n        current_bin_priorities[small_gap_to_penalize_mask] -= SMALL_GAP_SEVERE_PENALTY\n\n    # Assign the calculated priorities back to the main priorities array for bins that can fit.\n    priorities[can_fit_mask] = current_bin_priorities\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response7.txt_stdout.txt",
    "code_path": "problem_iter11_code7.py",
    "code": "import numpy as np\n\n# Assume a global BIN_CAPACITY for context. This is typical in Bin Packing Problem (BPP)\n# where items and bin capacities are often normalized, e.g., to 1.0.\nBIN_CAPACITY = 1.0\n\n# Define heuristic parameters for strategic adjustments.\n# These values are empirical and might require tuning for specific problem distributions.\n\n# EPSILON_CLOSE_TO_ZERO: Tolerance for floating-point comparisons to detect \"exact\" fits.\n# Essential for numerical robustness in comparisons with zero.\nEPSILON_CLOSE_TO_ZERO = 1e-6\n\n# FRAGMENTATION_LOW_THRESHOLD & FRAGMENTATION_HIGH_THRESHOLD:\n# Define a range for \"fragmented\" gaps. These are remaining capacities that are\n# too small to be widely useful for future items, but not small enough to be\n# considered a \"perfect fit\". Placing an item here might lead to wasted space.\nFRAGMENTATION_LOW_THRESHOLD = 0.05 * BIN_CAPACITY # e.g., 5% of bin capacity\nFRAGMENTATION_HIGH_THRESHOLD = 0.20 * BIN_CAPACITY # e.g., 20% of bin capacity\n\n# FRAGMENTATION_PENALTY: The amount by which to reduce the priority for creating\n# a fragmented gap. This is a fixed additive penalty, designed to discourage\n# such outcomes without overriding truly tight fits.\nFRAGMENTATION_PENALTY = 0.3 # A moderate, fixed penalty value.\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a Best Fit core, with an absolute preference for exact fits,\n    and a fixed penalty for creating small, fragmented remaining capacities.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # We allow for very small negative remaining space due to floating point inaccuracies,\n    # treating them as effectively zero.\n    can_fit_mask = potential_remaining_space >= -EPSILON_CLOSE_TO_ZERO\n\n    # Extract the potential remaining space for only the bins where the item can fit.\n    fitting_rem_space = potential_remaining_space[can_fit_mask]\n\n    # --- Step 1: Base Priority (Best Fit logic) ---\n    # The base priority is the negative of the potential remaining space.\n    # This means a smaller remaining space (closer to zero) results in a\n    # higher (less negative or zero) priority score. A perfect fit (0 remaining space)\n    # gets a base score of 0, which is the highest possible \"default\" score.\n    current_priorities_for_fit_bins = -fitting_rem_space\n\n    # --- Step 2: Strategic Additive Adjustments ---\n\n    # 2.1. Overwhelming Priority for Exact/Near-Exact Fits:\n    # Identify bins where the item perfectly or very nearly perfectly fills the bin.\n    # Assign them an extremely high, distinct priority to ensure they are always chosen\n    # if available, as this represents maximal bin utilization.\n    is_exact_or_near_fit = np.abs(fitting_rem_space) < EPSILON_CLOSE_TO_ZERO\n    current_priorities_for_fit_bins[is_exact_or_near_fit] = np.finfo(float).max / 2.0\n\n    # For subsequent adjustments, we only consider bins that are not an exact fit,\n    # as their priority has already been set to the highest possible value.\n    non_exact_mask = ~is_exact_or_near_fit\n\n    # 2.2. Penalty for Fragmented Gaps:\n    # Identify bins that, if chosen, would result in a remaining capacity falling\n    # within the \"fragmentation zone\". Reduce their priority to discourage their selection,\n    # promoting the creation of either very small (perfect fit) or larger, more usable gaps.\n    is_fragmented_zone_gap = (fitting_rem_space > FRAGMENTATION_LOW_THRESHOLD) & \\\n                             (fitting_rem_space < FRAGMENTATION_HIGH_THRESHOLD) & \\\n                             non_exact_mask\n    current_priorities_for_fit_bins[is_fragmented_zone_gap] -= FRAGMENTATION_PENALTY\n\n    # Assign the calculated priorities for fitting bins back into the main priorities array.\n    priorities[can_fit_mask] = current_priorities_for_fit_bins\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response8.txt_stdout.txt",
    "code_path": "problem_iter11_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes tight fits (Best Fit) and perfect fits, with an additive bonus\n    for bins that are already fuller, promoting efficient bin closure.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Small epsilon for numerical stability, especially for near-zero remaining space.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).\n    # This strongly favors bins that result in minimal remaining space (tightest fit).\n    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)\n\n    # Additive Consolidation Bias Component: Promote packing into already fuller bins.\n    # Based on analysis, a bonus directly related to individual bin fullness is preferred.\n    # A smaller bins_remain_cap (fuller bin) results in a higher inverse value,\n    # thereby giving a higher additive bonus.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05\n    consolidation_bonus = 1.0 / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n    # Combine the Best Fit score with the additive consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response9.txt_stdout.txt",
    "code_path": "problem_iter11_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit with strong Exact Fit preference and a subtle, proportional consolidation bonus.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity as per priority_v0's normalization assumption.\n    BIN_CAPACITY = 1.0 \n    \n    # Strong bonus for exact fits, making them top priority.\n    EXACT_FIT_BONUS = 100.0 \n    \n    # Small additive factor for the consolidation bonus, ensuring it only subtly\n    # influences choices without overriding strong Best Fit selections.\n    CONSOLIDATION_STRENGTH = 0.001 \n\n    # Epsilon for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100 \n\n    # Calculate potential remaining space after hypothetical placement.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit.\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # Adjust potential remaining space to be non-negative for scoring.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit logic (negative of remaining space).\n    # A smaller remaining space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Exact Fit Bonus: Prioritize bins that become perfectly full.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 3. Apply Refined Consolidation Bonus:\n    # Promote usage of existing, partially-filled bins by giving a small bonus\n    # proportional to their current fullness, but only if they are not exact fits.\n    \n    # Identify bins that are completely empty.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    \n    # Create a mask for bins that are eligible for this bonus:\n    # They must be able to fit the item, not result in an exact fit, and not be empty.\n    eligible_for_consolidation_bonus_mask = can_fit_mask & ~exact_fit_mask & ~is_empty_bin_mask\n\n    if np.any(eligible_for_consolidation_bonus_mask):\n        # Calculate the current fullness for eligible bins (0 for empty, 1 for full).\n        current_fullness_eligible = (BIN_CAPACITY - bins_remain_cap[eligible_for_consolidation_bonus_mask]) / BIN_CAPACITY\n        \n        # Add a bonus proportional to current fullness.\n        priorities[eligible_for_consolidation_bonus_mask] += CONSOLIDATION_STRENGTH * current_fullness_eligible\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin, aiming to tightly pack items with a focus on relative utilization.\n\n    This heuristic computes a priority score for each bin based on whether the item can fit\n    and how efficiently it utilizes the bin's remaining capacity.\n    - For bins that can fit the item, priority is based on the ratio of the item's size\n      to the bin's remaining capacity (i.e., relative utilization). A higher ratio (closer to 1.0)\n      indicates a tighter fit and thus a higher priority. A perfect fit yields a score of 1.0.\n    - For bins that cannot fit the item, priority is assigned as the negative of the\n      deficit in capacity (`bins_remain_cap - item`). This results in a negative score\n      that is lower (more negative) for bins that are further from being able to accommodate the item.\n\n    This approach ensures that bins able to fit an item always receive a higher priority\n    (positive, in range (0, 1.0]) than bins unable to fit an item (negative, in range [-MAX_ITEM_SIZE, 0)).\n    It adheres to the principles of local rules and emergent behavior, avoiding explicit\n    infinity/epsilon values or predefined \"best fit\" criteria beyond the inherent\n    proportionality.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be > 0.\n        bins_remain_cap: Array of remaining capacities for each bin. Values are >= 0.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities array.\n    priorities = np.empty_like(bins_remain_cap, dtype=float)\n\n    # Calculate the potential remaining space if the item were placed.\n    # This value is positive if the item fits, and negative if it doesn't.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # This inherently handles cases where bins_remain_cap is 0 (since item > 0, 0 - item < 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Assign priorities for bins where the item can fit.\n    # The priority is `item / bins_remain_cap`.\n    # A perfect fit (bins_remain_cap == item) results in a priority of 1.0.\n    # A loose fit results in a priority closer to 0.\n    # Note: bins_remain_cap[can_fit_mask] will never be zero for `item > 0`\n    # because if bins_remain_cap was 0, `0 - item` would be negative,\n    # and it wouldn't be in `can_fit_mask`.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    # Assign priorities for bins where the item cannot fit.\n    # The priority is `potential_remaining_space` (which will be negative).\n    # A bin that is only slightly too small (e.g., potential_remaining_space = -0.01)\n    # will receive a priority score closer to zero than a bin that is much too small\n    # (e.g., potential_remaining_space = -0.9). This means that among non-fitting\n    # bins, those \"closer\" to fitting are still prioritized relatively higher,\n    # but always below any fitting bin.\n    cannot_fit_mask = ~can_fit_mask\n    priorities[cannot_fit_mask] = potential_remaining_space[cannot_fit_mask]\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a\n    relative utilization-based heuristic that encourages emergent packing behavior.\n\n    This heuristic assigns a priority to each bin based on how much of its current\n    remaining capacity the incoming item would consume. The goal is to maximize\n    the 'relative utilization' for the current placement. This local rule aims to\n    drive the system towards effectively filling bins. Bins that cannot accommodate\n    the item receive the lowest possible priority (0.0), ensuring they are not chosen,\n    without relying on specific numerical artifacts like infinity.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         Assumed to contain non-negative float values.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores range from 0.0 (for non-fitting bins or bins with very large remaining\n        capacity relative to the item) up to 1.0 (for a perfect fit).\n    \"\"\"\n    # Initialize all priorities to 0.0. This value implicitly represents the\n    # lowest possible priority for a valid item and will be assigned to bins\n    # that cannot fit the item. This avoids reliance on -np.inf.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # If item is positive, and bins_remain_cap is 0, this mask will correctly\n    # exclude that bin, preventing division by zero.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the priority for bins where the item can fit.\n    # The priority is the ratio of the item's size to the bin's remaining capacity.\n    # A higher ratio indicates that the item consumes a larger proportion of the\n    # available space, leading to a \"tighter\" relative fit.\n    # This promotes the local rule of maximizing current space efficiency.\n    # For a perfect fit (item == bins_remain_cap), the score will be 1.0,\n    # representing the highest possible priority.\n    \n    # We use `np.where` for a vectorized conditional assignment.\n    # For bins where `can_fit_mask` is True, we calculate `item / bins_remain_cap`.\n    # For bins where `can_fit_mask` is False (item does not fit), we assign 0.0.\n    # Note: `item / bins_remain_cap` for elements where `bins_remain_cap` is 0\n    # and `can_fit_mask` is False will not be evaluated, thus preventing ZeroDivisionError.\n    priorities = np.where(can_fit_mask, item / bins_remain_cap, 0.0)\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response3.txt_stdout.txt",
    "code_path": "problem_iter12_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority for placing an item in each bin, implementing a strategy\n    that favors keeping bins with more remaining capacity flexible for future items,\n    akin to a Worst Fit approach, and designed with \"emergent behavior\" in mind.\n\n    This heuristic assigns a higher priority to bins that would have more space remaining\n    after the item is placed, provided the item can fit. This aims to keep bins\n    \"open\" and versatile for subsequent, potentially larger, items, letting a global\n    packing strategy emerge from these local decisions rather than explicit optimization.\n    Bins that cannot accommodate the item receive a low, but finite, priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed to reflect the desirability of a bin, with unfitting\n        bins receiving a score strictly lower than any possible valid placement.\n    \"\"\"\n    # Initialize all priorities to a sufficiently small negative value.\n    # This ensures that any bin where the item cannot fit will always have\n    # a lower priority than any bin where it can fit, without using -np.inf.\n    # Assuming capacities and item sizes are positive, the minimum valid\n    # remaining capacity (for a perfect fit) is 0. Thus, any negative value\n    # effectively excludes non-fitting bins.\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit\n    # (i.e., where potential_remaining_space is non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the\n    # potential remaining space. A larger positive value means more space\n    # would be left, which is preferred in this \"Worst Fit\" type of strategy.\n    # This promotes keeping bins less full, allowing for more flexibility\n    # in subsequent item placements.\n    priorities[can_fit_mask] = potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority for placing an item into each bin, implementing a heuristic\n    that focuses on the proportional fit of the item into the bin's current capacity,\n    while naturally de-prioritizing non-fitting bins without relying on infinity.\n\n    This heuristic encourages placing an item into a bin where it will consume a\n    significant proportion of the bin's *current* available capacity. This approach\n    aims to fill bins efficiently by making more 'used' bins (those with less remaining\n    capacity) more attractive for the current item, provided the item fits.\n    Bins that cannot accommodate the item receive a very low, concrete negative priority score.\n\n    The motivation is to foster an \"emergent behavior\" of bin completion through a\n    simple, local decision rule based on current state (bins_remain_cap) and item size,\n    without explicitly minimizing the *post-placement* remaining space or using infinite values.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores for non-fitting bins are set to a very low finite number to ensure they are not chosen.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low finite number.\n    # This value acts as a strong penalty for bins that cannot fit the item,\n    # ensuring they are never selected, while avoiding the use of -np.inf.\n    priorities = np.full_like(bins_remain_cap, -1e9, dtype=float) # Using -1 billion as a sufficiently low finite value\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based on the ratio of\n    # the item's size to the bin's *current* remaining capacity.\n    # A higher ratio (e.g., item=0.3, bin_cap=0.4 => 0.75) indicates that the item\n    # will utilize a larger proportion of the bin's current available space.\n    # This implicitly favors bins that are already somewhat \"full\" or have just\n    # enough space, encouraging them to be filled further.\n    # This strategy promotes a form of efficient packing by pushing items into\n    # the 'tightest' *current* spaces available.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]