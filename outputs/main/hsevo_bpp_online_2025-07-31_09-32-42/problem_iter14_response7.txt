```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes linear tight fits (Best Fit) and exact fits. Adds a fixed
    bonus to non-perfectly-filling bins to encourage consolidation into existing bins.
    """
    # Initialize all priorities to negative infinity, unequivocally marking bins
    # that cannot accommodate the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return the initialized priorities.
    if not np.any(can_fit_mask):
        return priorities

    # Potential remaining space (waste) if the item were placed in fit-capable bins.
    potential_remaining_space = bins_remain_cap[can_fit_mask] - item

    # Small epsilon for numerical stability for near-zero comparisons.
    EPSILON = np.finfo(float).eps

    # Core Best Fit Component: Assign priority as the negative of potential remaining space.
    # This linearly favors bins that result in minimal remaining space (tightest fit),
    # as smaller (closer to zero or less negative) 'potential_remaining_space' yields a higher score.
    best_fit_scores = -potential_remaining_space

    # Fixed Additive Consolidation Bonus: Encourage filling existing, non-perfectly-fitting bins.
    # This fixed bonus shifts up the score of any bin that can fit the item but won't be a perfect fit.
    # It promotes using partially filled bins before opening new ones (if no perfect fit exists).
    CONSOLIDATION_FIXED_BONUS = 0.1 

    # Identify bins that can fit the item but are not a perfect/near-perfect fit.
    non_perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) >= 1e-9 # Use a small tolerance

    # Apply the fixed consolidation bonus to these bins.
    best_fit_scores[non_perfect_fit_mask_in_fitting] += CONSOLIDATION_FIXED_BONUS
    
    # Assign the calculated scores to the fitting bins in the main priorities array.
    priorities[can_fit_mask] = best_fit_scores

    # Explicitly boost perfect fits to ensure their absolute priority.
    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.
    PERFECT_FIT_TOLERANCE = 1e-9
    # A very high score to ensure perfect fits are chosen over any other option.
    PERFECT_FIT_SCORE = 1e30 

    # Identify perfect or near-perfect fits within the fitting bins.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE

    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    return priorities
```
