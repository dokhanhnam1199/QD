```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for each bin based on the Best Fit principle,
    prioritizing tighter fits non-linearly with robust handling of perfect and non-fitting bins.
    """
    # Initialize priorities to negative infinity, effectively disqualifying bins
    # that cannot fit the item and ensuring they are never chosen by argmax.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining capacity if the item were placed in each bin.
    # A non-negative value means the bin can fit the item.
    potential_remaining_cap = bins_remain_cap - item

    # Create a mask to identify only those bins that have sufficient capacity.
    can_fit_mask = potential_remaining_cap >= 0

    # Define a small epsilon to ensure numerical stability when remaining capacity is zero
    # or very close to zero, and to give perfect fits a very high, finite priority.
    epsilon = 1e-9

    # For bins that can fit, assign a priority. The strategy is to give higher
    # priority to bins that result in less remaining space. An inverse relationship
    # (1 / x) achieves this, making smaller 'x' values result in larger priorities.
    # Adding epsilon to 'x' (potential_remaining_cap) prevents division by zero
    # for perfect fits and ensures a continuous, high priority for very tight fits.
    valid_bin_priorities = 1.0 / (potential_remaining_cap[can_fit_mask] + epsilon)

    # Apply the calculated priorities only to the bins that can actually fit the item.
    priorities[can_fit_mask] = valid_bin_priorities

    return priorities
```
