```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive Best Fit: Prioritizes bins to minimize waste, with distinct high score for perfect fits and robust inverse for others."""

    # Initialize priorities to negative infinity. This explicitly excludes bins
    # that cannot fit the item from consideration, making them the lowest possible priority.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can be placed.
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate the potential remaining capacity (waste) after placing the item
    # for only those bins that can accommodate it.
    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item

    # Separate valid bins into two categories: perfect fits and non-perfect fits (some waste).
    perfect_fit_mask = (potential_remain_after_fit == 0)
    non_perfect_fit_mask = (potential_remain_after_fit > 0)

    # 1. Prioritize perfect fits with a very high, distinct finite score.
    # This guarantees they are chosen over any other fit while maintaining
    # numerical stability (avoiding np.inf).
    PERFECT_FIT_SCORE = 1e12  # A large number ensuring perfect fit dominance
    priorities[can_fit_mask][perfect_fit_mask] = PERFECT_FIT_SCORE

    # 2. For non-perfect fits, prioritize inversely to the remaining waste.
    # A smaller waste yields a higher priority. A small epsilon is added
    # to the denominator to ensure numerical stability, especially for very
    # small positive waste values, preventing potential overflows.
    STABILITY_EPSILON = 1e-9 # Ensures division by zero or near-zero is handled
    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / (potential_remain_after_fit[non_perfect_fit_mask] + STABILITY_EPSILON)

    return priorities
```
