```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which to add an item to each bin, implementing a
    Balanced Best Fit with Fragmentation Aversion heuristic.

    This heuristic extends the standard Best Fit approach (`priority_v1`) by
    introducing a significant penalty for placing an item into a bin if doing
    so results in a small, "awkwardly" sized remaining capacity (a 'fragment').
    The goal is to encourage either:
    1.  A nearly perfect fit, effectively 'closing' the bin.
    2.  Leaving a substantial amount of remaining capacity, keeping the bin
        'open' and useful for larger future items.
    This strategy aims to reduce the creation of unusable fragmented space,
    leading to potentially better overall bin utilization and fewer bins used.

    The heuristic is "problem-aware" by identifying and penalizing a common
    pitfall (fragmentation) in online bin packing. It's "adaptive" in that
    its selection criteria dynamically shift based on the nature of the
    potential remaining space in each bin.

    Args:
        item: Size of the item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.
                         It's assumed that item sizes and bin capacities are
                         normalized such that the maximum bin capacity is 1.0.

    Return:
        Array of same size as bins_remain_cap with priority score for each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Bins that cannot accommodate the item receive the lowest possible priority (-inf).
    """
    # Assuming bin capacity is normalized to 1.0. This allows thresholds to be
    # set as ratios of the full bin capacity. If actual capacities vary,
    # this might need adjustment or a `bin_capacity` parameter.
    BIN_CAPACITY = 1.0

    # A small tolerance for floating-point comparisons to consider a fit "perfect"
    PERFECT_FIT_TOLERANCE = 1e-6

    # Define the range for "fragmented" remaining space.
    # A remaining space is considered a fragment if it's greater than almost zero
    # but less than or equal to this threshold. For example, 0.2 means any remaining
    # space between 0 and 20% of bin capacity is a fragment.
    FRAGMENT_THRESHOLD_RATIO = 0.25 # Can be tuned (e.g., 0.1 to 0.3)
    FRAGMENT_THRESHOLD = BIN_CAPACITY * FRAGMENT_THRESHOLD_RATIO

    # A penalty applied to bins that would result in a 'fragmented' remaining space.
    # This penalty should be significant enough to make fragmented options less
    # desirable than options that leave larger, more useful spaces.
    FRAGMENT_PENALTY = BIN_CAPACITY * 0.7 # Can be tuned (e.g., 0.5 to 1.0)

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    # We use tolerance to account for floating point inaccuracies near zero.
    can_fit_mask = potential_remaining_space >= -PERFECT_FIT_TOLERANCE

    # Step 1: Apply the base Best Fit logic for bins where the item can fit.
    # A smaller positive potential_remaining_space results in a higher (less negative) score.
    # A perfect fit (0) gets a score of 0, which is the highest initial score.
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    # Step 2: Refine priorities based on the Fragmentation Aversion strategy.
    # Get the potential remaining space for only those bins where the item fits.
    fitting_potential_rem_space = potential_remaining_space[can_fit_mask]
    fitting_priorities = priorities[can_fit_mask]

    # Identify remaining spaces that fall into the "fragmentation trap":
    # These are spaces that are small (below FRAGMENT_THRESHOLD) but are not
    # considered a perfect fit (i.e., greater than PERFECT_FIT_TOLERANCE).
    fragment_trap_mask = (fitting_potential_rem_space > PERFECT_FIT_TOLERANCE) & \
                         (fitting_potential_rem_space <= FRAGMENT_THRESHOLD)

    # For bins that would create a fragment, apply a significant penalty to their priority.
    # This makes these options less attractive compared to bins that leave either
    # very little space (perfect fit) or ample space (useful for larger items).
    fitting_priorities[fragment_trap_mask] -= FRAGMENT_PENALTY

    # Update the main priorities array with the refined scores.
    priorities[can_fit_mask] = fitting_priorities

    return priorities
```
