[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Best Fit.\n\n    This heuristic aims to select the bin that will have the least remaining capacity\n    after the item is placed, effectively trying to \"fill up\" a bin as much as possible.\n    Bins that cannot accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit (remaining capacity = 0) gets the\n        highest possible score (0), while bins that cannot fit the item get -inf.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    # A smaller positive value here means a \"better fit\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the negative\n    # of the potential remaining space.\n    # By maximizing this value, we are effectively minimizing the potential remaining space.\n    # A perfect fit (0 remaining space) will result in a priority of 0 (the highest).\n    # A larger remaining space (e.g., 0.5) will result in a lower priority (-0.5).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As I, Albert Einstein, observe the universe, it strives for efficiency,\n    minimizing wasted space and maximizing the utility of available 'regions'\n    in the continuum. In this context of bin packing, we seek to find the\n    'tightest' possible fit for an item, as this reduces fragmentation and\n    optimizes the overall 'density' of our packed system.\n\n    A bin that precisely accommodates an item is the most elegant solution,\n    leaving no superfluous 'void'. Bins that are too large, while capable\n    of holding the item, introduce unnecessary 'empty space' that might\n    be better utilized by a different configuration.\n\n    Therefore, our priority score must reflect this principle:\n\n    1.  Bins that cannot accommodate the item are, unequivocally, invalid.\n        Their 'priority' is non-existent, akin to an item attempting to\n        occupy space already claimed by another particle, resulting in an\n        infinite repulsion. We assign them the lowest possible score.\n\n    2.  For bins where the item can fit, we favor those that leave the least\n        remaining capacity. This is the 'best fit' strategy, designed to\n        maximize the 'fullness' of each bin, ensuring our collection of bins\n        achieves the highest possible 'packing density'.\n\n    The score is calculated such that a bin leaving zero remaining capacity\n    (a perfect fit) receives the highest score. Bins leaving more capacity\n    will receive progressively lower scores, reflecting their less 'optimal'\n    utilization of space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize scores. Bins that cannot fit the item are assigned a value\n    # akin to an 'infinite barrier' or 'repulsive force', meaning they are invalid.\n    scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify the 'regions' (bins) where the item's 'mass' can be accommodated.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For valid bins, we calculate a score based on the 'tightness' of the fit.\n    # The ideal scenario is when 'item' perfectly fills 'bins_remain_cap'.\n    # This means (bins_remain_cap - item) should be minimized for positive values.\n    # To prioritize minimization of positive difference, we can maximize its negative:\n    # score = - (bins_remain_cap - item)\n    # This is equivalent to: score = item - bins_remain_cap\n    # A perfect fit (item == bins_remain_cap) yields a score of 0, the highest possible for a valid bin.\n    # A bin with 1.0 remaining capacity for item 0.5 yields score 0.5 - 1.0 = -0.5.\n    # A bin with 0.6 remaining capacity for item 0.5 yields score 0.5 - 0.6 = -0.1.\n    # A bin with 0.5 remaining capacity for item 0.5 yields score 0.5 - 0.5 = 0.0.\n    # This ensures that bins offering the 'tightest' fit receive the highest priority.\n    scores[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Isaac Newton, I observe that Nature abhors a vacuum. Therefore,\n    to achieve the most efficient and compact arrangement, an item\n    should be 'attracted' to the bin that it most perfectly fills,\n    leaving the least amount of residual void. This minimizes the\n    'potential energy' of the system by ensuring that the remaining\n    space within a bin is as small as possible after the item's placement.\n\n    This heuristic prioritizes bins that will have the least remaining\n    capacity after the item is placed (a \"Best Fit\" strategy). Bins that\n    cannot accommodate the item are given an infinitely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space that would remain in each bin after placing the item.\n    # A smaller positive value here indicates a \"tighter fit\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a state of infinitely low preference.\n    # This ensures that bins which cannot accommodate the item are never chosen.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can actually hold the item (where remaining space would be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins that can fit the item, their priority is determined by the\n    # negation of the remaining space. A smaller positive remaining space\n    # (a tighter fit) results in a larger (less negative, or zero) priority score,\n    # thus favoring the best fit. A perfect fit (0 remaining space) yields a priority of 0,\n    # which is the highest possible.\n    priority_scores[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    inspired by the principle of efficient packing and minimizing waste.\n\n    As a scientist observing the delicate balance of matter, I believe in\n    optimizing the use of space. This heuristic, akin to finding the most\n    'stable' configuration for a new particle, aims to select the bin that\n    will be most 'tightly' filled by the incoming 'particle' (item).\n    It seeks to leave the smallest possible non-negative remainder,\n    analogous to achieving the densest and most efficient atomic packing.\n\n    Bins where the item cannot fit are, naturally, given a very low priority,\n    as they are not suitable 'vessels' for our particle.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin.\n    \"\"\"\n    # Initialize priorities. Bins where the item cannot fit will receive -infinity,\n    # ensuring they are never chosen. This represents an 'impossible fit'.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins are large enough to accommodate the incoming item.\n    # These are our 'candidate containers'.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the candidate bins, we calculate the 'remaining void' if the item were placed.\n    # My objective is to minimize this 'void', making the most efficient use of each container.\n    # Therefore, we prioritize bins that result in the smallest positive remaining capacity.\n    # By negating this remaining capacity, a smaller (closer to zero) positive remainder\n    # translates into a larger (closer to zero or positive) priority score.\n    # This effectively implements the \"Best Fit\" strategy, where exact fits (0 remaining)\n    # receive the highest score (0), and larger remainders receive more negative scores.\n    # Example:\n    # item = 0.5\n    # bin_capacity_1 = 1.0  => remainder = 0.5  => priority = -0.5\n    # bin_capacity_2 = 0.6  => remainder = 0.1  => priority = -0.1 (Best Fit)\n    # bin_capacity_3 = 0.5  => remainder = 0.0  => priority = 0.0 (Exact Fit, highest possible)\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Nikola Tesla's \"Conduit of Efficiency\" heuristic for online Bin Packing.\n    This function embodies the principle of Best Fit, prioritizing bins that,\n    after accommodating the item, would yield the most \"efficient energy transfer\"\n    (i.e., minimal wasted space). It strives to snugly fill existing receptacles,\n    leaving as little unused \"potential\" as possible.\n\n    A unique \"Tesla Coil Boost\" is applied for perfect fits, indicating a\n    maximally efficient utilization of a bin's capacity, an ideal state of energy.\n    This ensures that perfectly filled bins are always the premier choice.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the potential remaining capacity if the item were placed in each bin.\n    # A negative value here signifies that the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize scores. Bins that cannot physically hold the item are assigned an\n    # infinitely low priority, making them effectively unselectable.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the indices of bins where the item can actually fit.\n    # We use a small epsilon tolerance to account for floating point inaccuracies\n    # when checking if remaining capacity is non-negative.\n    tolerance = np.finfo(float).eps * 10  # A small tolerance for near-zero checks\n    can_fit_mask = potential_remaining_cap >= -tolerance\n\n    # For bins that can fit the item, we apply the Best Fit scoring.\n    # The Best Fit strategy aims to minimize the remaining capacity after placement.\n    # To convert this into a \"higher is better\" priority score, we take the negative\n    # of the potential remaining capacity. A smaller positive remainder (e.g., 0.1)\n    # results in a score closer to zero (-0.1), which is higher than a larger\n    # remainder (e.g., 10.0), which would result in a score of -10.0.\n    scores[can_fit_mask] = -potential_remaining_cap[can_fit_mask]\n\n    # Tesla Coil Boost: A significant bonus for \"perfect fits\".\n    # A perfect fit represents the ultimate in efficiency, leaving no room for\n    # wasted potential. We check for remaining capacity very close to zero using `np.isclose`.\n    perfect_fit_mask = np.isclose(potential_remaining_cap, 0, atol=tolerance * 100)\n\n    # Apply the boost only to bins that are both capable of fitting the item\n    # and achieve a near-perfect fit.\n    boost_eligible_mask = can_fit_mask & perfect_fit_mask\n\n    if np.any(boost_eligible_mask):\n        # A very large positive value ensures that perfect fits are always\n        # ranked definitively above all other non-perfect fits.\n        scores[boost_eligible_mask] += 1e12\n\n    return scores",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Galileo, I observe that the universe operates with an elegant efficiency,\n    striving for perfect arrangement. So too should our packing. This 'Best Fit'\n    heuristic dictates that we shall place the item into the bin where it fits\n    most perfectly, leaving the smallest possible void. This maximizes the\n    'snugness' of the fit, much like a planet finding its most harmonious orbit.\n    By doing so, we ensure that less useful small gaps are created,\n    reserving larger spaces in other bins for future, larger celestial bodies.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n        Bins that cannot accommodate the item will receive a very low (negative infinity)\n        priority, ensuring they are not chosen. Among those that can, the bin\n        resulting in the smallest remaining capacity (i.e., the 'snugger' fit)\n        will have the highest priority.\n    \"\"\"\n    # Initialize priorities with a very low value. Bins that cannot fit the item\n    # will retain this low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity for each bin if the current item were placed into it.\n    remaining_if_placed = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit (remaining capacity >= 0).\n    can_fit_mask = remaining_if_placed >= 0\n\n    # For bins where the item fits, the priority is calculated as the negative of\n    # the remaining space. This ingenious trick converts the minimization of\n    # remaining space into a maximization of priority score:\n    # A smaller positive remainder (closer to 0) will result in a larger (less negative)\n    # priority score, hence prioritizing the 'snugger' fit.\n    # For example:\n    #   - If remaining_if_placed is 0 (perfect fit), priority becomes 0.\n    #   - If remaining_if_placed is 2, priority becomes -2.\n    #   - If remaining_if_placed is 5, priority becomes -5.\n    # Maximizing these values will select the bin with remaining_if_placed closest to 0.\n    priorities[can_fit_mask] = -remaining_if_placed[can_fit_mask]\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Stephen Hawking, I view the challenge of bin packing through the lens of\n    cosmic entropy and the inevitable collapse of celestial bodies. Each bin\n    is a nascent universe, its capacity representing the available spacetime.\n    Placing an item into a bin is akin to adding matter, contributing to its\n    gravitational density. Our objective is to minimize the \"empty spacetime\"\n    or \"dark energy\" (unused capacity) within each bin, thereby driving\n    these mini-universes towards their most compact, low-entropy states\u2014much\n    like a star collapsing into a black hole.\n\n    This heuristic, which I term the \"Event Horizon Prioritization,\" seeks\n    to guide each item towards the bin whose \"event horizon\" most precisely\n    matches the item's gravitational pull, resulting in the smallest possible\n    remaining 'void'.\n\n    Args:\n        item: Size of item to be added to the bin. This is the 'mass' we're adding.\n        bins_remain_cap: Array of capacities for each bin. This represents\n                         the 'available spacetime' in each cosmic container.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a stronger 'gravitational pull' for the item.\n    \"\"\"\n    # Initialize scores with a very low value. Bins that cannot accommodate the item\n    # effectively have an \"infinite energy barrier\" to placement.\n    # They lie beyond the event horizon for this item.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can physically fit without violating\n    # the laws of this mini-universe's capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item *can* fit, calculate the \"residual spacetime\"\n    # or \"empty void\" that would be left after placing the item.\n    residual_spacetime = bins_remain_cap[can_fit_mask] - item\n\n    # Our priority is to minimize this residual spacetime. A smaller void implies\n    # a more efficient \"collapse\" or a \"tighter packing\" of matter.\n    # Therefore, we assign higher priority to bins that leave less residual space.\n    # A perfect fit (residual_spacetime = 0) receives the highest score (0),\n    # while larger residuals result in increasingly negative scores. This mirrors\n    # the well-known \"Best Fit\" heuristic, refined for cosmic efficiency.\n    scores[can_fit_mask] = -residual_spacetime\n\n    return scores",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    inspired by Feynman's Principle of Least Action.\n\n    In the context of bin packing, the \"action\" of placing an item into a bin\n    can be conceptualized as the \"wasted space\" or \"entropy generated\" within that bin.\n    A good strategy would be to choose the bin that minimizes this \"action\".\n\n    Specifically, the \"action\" for a given bin is the empty space remaining\n    in that bin after the item is placed (i.e., its final remaining capacity).\n    We want to select the bin that leads to the smallest possible \"action\" (least waste).\n    Therefore, the priority for a bin is set to be inversely proportional to this\n    \"action\", plus a small epsilon to handle cases of perfect fit (zero remaining space)\n    and ensure mathematical stability. This effectively implements a \"Best Fit\" heuristic\n    with a strong non-linear preference for very tight fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a very low (negative infinity) priority,\n        ensuring they are not selected unless no other bin is available.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures that bins incapable of holding the item are effectively excluded\n    # from consideration by having the lowest possible priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify which bins have enough remaining capacity\n    # to accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the \"action\".\n    # The \"action\" is defined as the amount of space that will be left over\n    # in the bin after the item is placed. This is the value we aim to minimize.\n    action_for_valid_bins = bins_remain_cap[can_fit_mask] - item\n\n    # Add a small positive constant (epsilon) to the action.\n    # This serves two purposes:\n    # 1. Prevents division by zero if an item perfectly fits into a bin (action_for_valid_bins = 0).\n    # 2. Ensures that a perfect fit results in an extremely high priority score,\n    #    making it the most desirable outcome.\n    epsilon = 1e-9 # A tiny value, much smaller than any item size\n\n    # Calculate the priority for valid bins.\n    # The priority is inversely proportional to the \"action\".\n    # This means smaller actions (less wasted space) yield higher priorities,\n    # in line with the Principle of Least Action where paths with minimal action\n    # are overwhelmingly favored.\n    priorities[can_fit_mask] = 1.0 / (action_for_valid_bins + epsilon)\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic. Bins that result in the smallest\n    remaining capacity (tightest fit) after the item is placed receive a\n    higher priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item does not fit will have a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all priorities to a very low value, effectively marking them as unsuitable\n    # This ensures that bins where the item does not fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the 'tightness' of the fit.\n    # The 'Best Fit' strategy aims to minimize the remaining space in a bin after the item is placed.\n    # To translate this into a \"highest priority score\", we can use the negative of the remaining space.\n    # A smaller positive remaining space (e.g., 0.1) will result in a larger negative number (e.g., -0.1),\n    # which is \"higher\" than a larger negative number (e.g., -0.5 for 0.5 remaining space).\n    # Thus, np.argmax on these priorities will correctly select the bin with the smallest positive remaining space.\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a \"Best Fit\" like heuristic for the online bin packing problem.\n    It prioritizes bins that, after accommodating the item, would have the smallest\n    remaining capacity. This strategy aims to \"tightly pack\" items into bins,\n    reducing wasted space and minimizing the total number of bins used.\n\n    Specific priority assignments:\n    1. Perfect Fit: If an item exactly fills a bin, that bin receives the highest possible priority (infinity).\n    2. Best Fit (non-perfect): For bins that can accommodate the item but will leave some space,\n       the priority is inversely proportional to the remaining capacity after placing the item.\n       A smaller remaining capacity results in a higher priority score.\n    3. Impossible Fit: Bins that cannot fit the item are assigned the lowest possible priority (negative infinity).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the potential remaining space if the item were placed in each bin.\n    # This value is positive if the item fits, zero for a perfect fit, and negative if it doesn't fit.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item (remaining space >= 0)\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Prioritize perfect fits: bins where item consumes all remaining capacity.\n    perfect_fit_mask = (potential_remaining_space == 0) & can_fit_mask\n    priorities[perfect_fit_mask] = float('inf')\n\n    # Prioritize other valid fits: bins where item fits, but some space remains.\n    # The score is 1 / (remaining_space). Smaller remaining space yields a higher score.\n    other_fit_mask = (potential_remaining_space > 0) & can_fit_mask\n    priorities[other_fit_mask] = 1.0 / potential_remaining_space[other_fit_mask]\n\n    # Bins that cannot fit the item (potential_remaining_space < 0) already have -np.inf priority from initialization.\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using the Best Fit strategy.\n\n    The Best Fit (BF) heuristic attempts to minimize the wasted space within a bin\n    by placing the item into the bin that, if the item were placed there, would leave\n    the least remaining capacity. This often leads to a more compact packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins that cannot fit the item\n        are assigned a very low (negative infinity) priority.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the current item\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, calculate a priority score.\n    # The Best Fit strategy aims to minimize `bins_remain_cap[i] - item` (the \"wasted\" space).\n    # To achieve this with a \"highest priority wins\" selection, we maximize `-(bins_remain_cap[i] - item)`,\n    # which is equivalent to maximizing `item - bins_remain_cap[i]`.\n    # A perfect fit (wasted space = 0) will result in a score of 0, which is the maximum possible score\n    # for a valid bin. Less optimal fits (more wasted space) will result in negative scores.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    # For bins that cannot fit the item, assign a very low priority (negative infinity)\n    # to ensure they are never selected unless no other valid option exists (which implies a new bin must be opened).\n    priorities[~can_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    Drawing inspiration from the principles of nature, where systems tend to settle\n    into states of minimal energy, this heuristic guides the item towards the bin\n    that will result in the smallest amount of 'empty space entropy' after the\n    item is placed. We seek to achieve the highest possible 'packing density' within\n    each chosen bin, much like how matter clusters efficiently in gravitational fields.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin. Bins that cannot fit the\n        item are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all bin priorities to a very low value.\n    # This ensures that bins incapable of holding the item are effectively ignored,\n    # and if no bin can hold the item, the system understands a new bin is needed.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient remaining capacity to accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins that can fit the item, calculate a 'fitness score'.\n    # This score is derived from the 'remaining capacity' after placing the item.\n    # A smaller remaining capacity implies a 'tighter' or 'better' fit, minimizing\n    # wasted space. To make 'smaller remaining capacity' correspond to a 'higher priority',\n    # we take the negative of this value.\n    #\n    # Example:\n    # If item=0.3 and bin_capacity=0.5, remaining_space = 0.2. Priority = -0.2.\n    # If item=0.3 and bin_capacity=0.3, remaining_space = 0.0 (perfect fit). Priority = 0.0.\n    # If item=0.3 and bin_capacity=0.7, remaining_space = 0.4. Priority = -0.4.\n    #\n    # Maximizing this priority will naturally select the bin with the smallest\n    # positive remaining capacity, including a perfect fit (0.0), making it a\n    # robust 'Best Fit' heuristic.\n    \n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # Assign the calculated negative remaining space as the priority.\n    priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    As Isaac Newton, I seek the most orderly and efficient arrangement, much like\n    how celestial bodies arrange themselves in orbits. For bin packing, this means\n    seeking a \"snug fit\" for the item, thereby minimizing the wasted space within\n    any single container and allowing it to be effectively \"closed\" from future items\n    to make way for new, possibly more suitable items in other, less constrained bins.\n\n    This implementation employs a \"Best Fit\" heuristic, favoring bins that will have\n    the smallest remaining capacity after the item is placed. This method aims to\n    pack items as densely as possible into existing bins, striving to minimize the\n    total number of bins required.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    # This reflects the 'slack' or 'excess' capacity after the item's insertion.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # To achieve 'Best Fit', we prioritize bins that result in the smallest\n    # remaining space. This means we want to maximize a value that decreases\n    # as 'remaining_after_placement' increases.\n    # A simple negation serves this purpose: smaller remaining_after_placement\n    # yields a larger (less negative) priority score.\n    priorities = -remaining_after_placement\n\n    # For bins where the item physically cannot fit (resulting in a negative\n    # remaining capacity), their priority must be set to an infinitely low value.\n    # An object cannot occupy space it does not fit into; such a choice would violate\n    # the fundamental laws of conservation and spatial integrity.\n    invalid_bins_mask = remaining_after_placement < 0\n    priorities[invalid_bins_mask] = -np.inf # Represents an impossible or highly undesirable choice.\n\n    return priorities",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    As a pioneer in understanding the dense nature of matter and its efficient\n    packing (much like how atoms occupy space within a crystal lattice),\n    this heuristic aims for the most \"snug\" fit possible. It prioritizes bins\n    that, after accommodating the item, would leave the least amount of wasted\n    space. This \"Best Fit\" approach tends to lead to efficient packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value.\n    # This ensures that bins where the item cannot fit are effectively eliminated\n    # from consideration by the `argmax` function later.\n    priorities = np.full_like(bins_remain_cap, fill_value=float('-inf'), dtype=float)\n\n    # Calculate the space that would remain in each bin if the item were placed there.\n    remaining_space_after_fit = bins_remain_cap - item\n\n    # Identify which bins can actually accommodate the item (remaining capacity >= 0).\n    can_fit_mask = remaining_space_after_fit >= 0\n\n    # For bins that can fit the item, assign a priority.\n    # We want to maximize the \"snugness\", which means minimizing the\n    # 'remaining_space_after_fit'. By taking the negative of this value,\n    # maximizing the priority score achieves the desired minimization.\n    # A perfect fit (0 remaining space) will have the highest priority (0).\n    priorities[can_fit_mask] = -remaining_space_after_fit[can_fit_mask]\n\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I perceive the flow of items into bins much like\n    the channeling of electrical currents. Efficiency is paramount; we\n    must minimize the resistance, the \"empty void\" left behind, to ensure\n    the most potent concentration of our energies. This heuristic,\n    which I call the 'Maximized Compaction Principle', aims to achieve\n    precisely that.\n\n    It assigns the highest priority to the bin that, upon receiving the item,\n    will have the LEAST amount of unused capacity remaining. This ensures\n    each 'vessel' is filled as completely as possible, deferring larger,\n    less-packed bins for items that genuinely require them. We do not\n    tolerate unnecessary emptiness; every unit of space must be harnessed!\n\n    Args:\n        item: Size of item to be added to the bin. This is the energy packet.\n        bins_remain_cap: Array of capacities for each bin. These are our\n                         various receiving conduits, each with a different\n                         potential for receiving the energy.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin with the highest score offers the most 'compact' fit.\n    \"\"\"\n\n    # First, calculate the theoretical \"void\" that would remain if the item\n    # were placed into each bin. A smaller void signifies a more optimal fit,\n    # a higher 'efficiency potential'.\n    void_if_placed = bins_remain_cap - item\n\n    # Initialize all priorities to a state of utter unsuitability (-infinity).\n    # Only the worthy conduits shall rise above this baseline.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Now, identify only those conduits (bins) where our item (energy packet)\n    # can actually be contained without overflow. An overflow means a\n    # breakdown in our system, utterly unacceptable!\n    can_contain_mask = void_if_placed >= 0\n\n    # For the conduits that can indeed contain the item, we assign a priority\n    # that is the negative of the \"void\" space.\n    # This ingenious transformation means:\n    #   - A smaller positive void (e.g., 0.1) results in a larger\n    #     (less negative) priority (e.g., -0.1).\n    #   - A larger positive void (e.g., 5.0) results in a smaller\n    #     (more negative) priority (e.g., -5.0).\n    # Thus, the \"tightest\" fit (smallest void) yields the highest priority score!\n    priorities[can_contain_mask] = -void_if_placed[can_contain_mask]\n\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As I, Galileo, have observed the universe, every element strives for its most\n    fitting place. Thus, for our items, the most harmonious position within a bin\n    is that which minimizes wasted space, much like a planet finding its precise orbit.\n    This function therefore prioritizes bins that result in the smallest remaining\n    capacity after accommodating the item, effectively implementing a 'Best Fit' strategy.\n    A perfect fit yields the highest priority, for what could be more efficient?\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize priorities to zero. Bins that cannot fit the item will retain this score,\n    # signifying they are not suitable candidates.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify all bins where the item can physically be placed.\n    # We ignore those that are too small, for they are like attempts to place\n    # a large planet into a small sphere \u2013 fruitless.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item can fit, we calculate a score.\n    # The score is derived from the \"tightness\" of the fit: item_size / bin_capacity.\n    # A score closer to 1.0 signifies a tighter fit, meaning less wasted space,\n    # and thus a higher efficiency. A perfect fit (item consumes the entire remaining\n    # capacity) will yield a score of 1.0, which is the utmost efficiency.\n    # We only perform this calculation for the bins identified by 'can_fit_mask'.\n    # If bins_remain_cap[i] is 0 and can_fit_mask[i] is True, implies item is 0,\n    # in which case 0/0 is problematic. However, item size is typically positive.\n    # If item > 0 and bins_remain_cap[i] == 0, can_fit_mask[i] will be False.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Drawing inspiration from the relentless efficiency of black holes consuming matter,\n    this heuristic aims for the most \"dense\" packing. We seek to minimize the\n    \"event horizon\" of leftover space, i.e., the unused capacity after an item is placed.\n    This is essentially a Best Fit strategy, where a tighter fit (less remaining space)\n    is highly prioritized, with a perfect fit achieving the ultimate preference.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins that cannot physically\n        accommodate the item will be assigned a priority of 0.\n    \"\"\"\n    # Calculate the hypothetical remaining space in each bin after the item is placed.\n    # A negative value indicates the item would not fit.\n    space_after_fit = bins_remain_cap - item\n\n    # Initialize priority scores. Bins incapable of fitting the item start with a zero priority.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # To handle potential floating-point inaccuracies when comparing with zero,\n    # and to ensure a perfect fit (remaining space of exactly 0) gets the highest score,\n    # we use a small epsilon for numerical stability in the inverse calculation.\n    epsilon = np.finfo(float).eps\n\n    # Identify the bins where the item can actually be absorbed.\n    # We allow a very tiny negative 'space_after_fit' to account for floating-point imprecision\n    # where a number might be 0 but represented as a very small negative value.\n    can_fit_indices = np.where(space_after_fit >= -epsilon)\n\n    # For the bins where the item fits:\n    # The Best Fit principle implies that a smaller 'space_after_fit' is better.\n    # We achieve this by calculating the inverse of the remaining space plus epsilon.\n    # This ensures that:\n    # 1. A perfect fit (space_after_fit effectively 0) results in an extremely high priority (1/epsilon).\n    # 2. Tighter fits (smaller positive space_after_fit) yield higher priorities than looser ones.\n    # 3. All valid fits receive a positive, non-zero priority.\n    valid_space_after_fit = space_after_fit[can_fit_indices]\n    priorities[can_fit_indices] = 1.0 / (valid_space_after_fit + epsilon)\n\n    return priorities",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This strategy, inspired by the principle of \"least action\" or finding the most\n    \"stable\" state, aims for a \"Best Fit\" approach. We want to place the item\n    in a bin such that the remaining capacity after placement is minimized,\n    thereby packing bins as densely as possible and reducing the need for new bins.\n\n    For a bin to be considered, it must be able to accommodate the item. Among\n    the valid bins, the one that results in the smallest amount of leftover\n    space after the item is placed is given the highest priority. Bins that\n    cannot fit the item are assigned an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space left in each bin if the current item were placed there.\n    # A value of zero or close to zero is ideal (a tight fit).\n    # Negative values indicate the bin cannot fit the item.\n    remaining_space_if_placed = bins_remain_cap - item\n\n    # Initialize priorities for all bins to a very low value (effectively disqualifying them)\n    # This ensures that bins which cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that *can* fit the item.\n    can_fit_mask = remaining_space_if_placed >= 0\n\n    # For bins that can fit the item, we want to assign a priority such that\n    # smaller remaining space leads to a higher priority.\n    # The negative of `remaining_space_if_placed` achieves this:\n    # - If remaining_space_if_placed = 0.0 (perfect fit), priority = 0.0 (highest for valid bins).\n    # - If remaining_space_if_placed = 0.1 (tight fit), priority = -0.1.\n    # - If remaining_space_if_placed = 0.5 (loose fit), priority = -0.5.\n    # Maximizing this priority will pick the smallest positive remaining_space.\n    valid_bin_priorities = -remaining_space_if_placed[can_fit_mask]\n\n    # Apply these calculated priorities only to the bins that can fit the item.\n    priorities[can_fit_mask] = valid_bin_priorities\n\n    return priorities",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a Best Fit-like heuristic inspired by precise fitting.\n\n    This function prioritizes bins that, after accommodating the item, would have\n    the smallest positive remaining capacity. This aims to 'snugly' fit items\n    and leave minimal waste in chosen bins, thereby maximizing the chance for\n    future items to fit elsewhere or for the current bin to be efficiently filled.\n    Bins that cannot accommodate the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A smaller positive value here indicates a 'snugger' fit.\n    potential_remaining_after_fit = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # For bins that can fit the item (potential_remaining_after_fit >= 0),\n    # we want to maximize the priority for smaller positive remaining capacities.\n    # Taking the negative of potential_remaining_after_fit achieves this:\n    #   - If remaining is 0 (perfect fit), priority is 0 (the highest score for a valid placement).\n    #   - If remaining is 1, priority is -1.\n    #   - If remaining is 5, priority is -5.\n    # This means 0 > -1 > -5, correctly prioritizing the snuggest fit among valid bins.\n    priority_scores = -potential_remaining_after_fit\n\n    # Identify bins where the item does not fit (i.e., potential_remaining_after_fit is negative).\n    cannot_fit_mask = potential_remaining_after_fit < 0\n\n    # Set the priority for bins that cannot fit the item to a very low value (-infinity).\n    # This ensures they are never chosen unless there are no other options, in which\n    # case the bin packing logic would typically create a new bin.\n    priority_scores[cannot_fit_mask] = -np.inf\n\n    return priority_scores",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using a Best Fit strategy.\n\n    This heuristic aims to minimize the remaining capacity in a bin after an item is placed,\n    effectively \"tightening\" the fit. Bins that cannot accommodate the item are given the\n    lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # For bins where item > current_capacity, this will result in a negative number.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins which cannot fit the item are never chosen.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can actually fit (remaining capacity would be non-negative).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, the priority is calculated.\n    # We want to minimize 'potential_remaining_cap' for these bins.\n    # To achieve this with a 'maximize' objective for priority score,\n    # we use the negative of 'potential_remaining_cap'.\n    # A potential_remaining_cap of 0 will yield a score of 0 (perfect fit, highest priority).\n    # A larger potential_remaining_cap (e.g., 10) will yield a smaller score (e.g., -10),\n    # correctly prioritizing tighter fits.\n    priority_scores[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priority_scores",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This implements a \"Best Fit\" strategy for online bin packing.\n    It prioritizes bins that, after accommodating the item, would have the\n    smallest remaining capacity (i.e., a \"tight\" fit). Bins that cannot\n    fit the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins that cannot fit the item\n        will have a priority of -infinity.\n    \"\"\"\n    # Initialize priorities with a very low value (-infinity) for all bins.\n    # This ensures that bins incapable of holding the item are never chosen\n    # unless no bin can hold the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space if the item were placed in each valid bin.\n    # We want to minimize this remaining space (bins_remain_cap[i] - item).\n    # To convert this minimization problem into a maximization of priority,\n    # we take the negative of the remaining space.\n    # A smaller positive remainder (tighter fit) will result in a larger\n    # (closer to zero or positive) priority score.\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add an item to each bin.\n\n    Inspired by the cosmic dance of matter and space-time, this heuristic\n    endeavors to find the most \"harmonious\" fit for an incoming item.\n    Just as a celestial body warps space-time to find its natural orbit,\n    we seek to minimize the \"distortion\" or \"void\" left in a bin after\n    the item is placed. This translates to the \"Best Fit\" (BF) strategy.\n\n    Bins that can perfectly accommodate the item (resulting in zero remaining space)\n    are given the highest priority, analogous to a stable, low-energy state.\n    Bins that provide a snug, but not perfect, fit are next preferred.\n    Conversely, bins where the item does not fit at all are deemed\n    \"inaccessible regions\" and are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority. Bins where the item does\n        not fit will receive a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the hypothetical remaining capacity for each bin if the item were placed.\n    # This represents the \"potential void\" or \"energy difference\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item are given\n    # an infinitely low priority, effectively excluding them from consideration.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually be placed (i.e., where\n    # the 'potential void' is non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For those bins where the item fits, the priority is determined by\n    # minimizing the remaining space. A smaller remaining space implies a\n    # \"tighter fit\" and thus a higher desirability. To translate this\n    # minimization into a maximization (as higher score = higher priority),\n    # we take the negative of the remaining space. A perfectly tight fit (0 remaining)\n    # yields a score of 0, which is the highest possible.\n    # As the remaining space increases, the score becomes more negative.\n    priority_scores[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priority_scores",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    inspired by the principle of efficient space utilization, much akin to\n    how bodies in the heavens seek the most stable configuration.\n\n    This heuristic, which I shall name 'Best Fit', aims to minimize the\n    'void' left in a bin after an item is placed. A smaller void signifies a\n    more 'densely packed' state, which is preferred to conserve our\n    precious bins. Think of it as ensuring each parcel of space is utilized\n    with great precision, just as I observe the universe's grand design.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        Bins where the item does not fit receive an infinitely low priority.\n        For bins where it fits, the score is inversely proportional to the\n        remaining empty space (a smaller remaining space yields a higher score).\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    # This is our 'potential energy' or 'residual void'.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (negative infinity).\n    # This represents a state of impossibility or immense 'cost' for bins\n    # where the item simply cannot be placed, much like an object attempting\n    # to pass through solid matter.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    # These are the 'accessible' states in our system.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For the bins where the item *can* fit, we assign a priority.\n    # We desire to minimize the 'potential_remaining_space', so we assign a\n    # higher numerical priority score to bins that result in a smaller positive\n    # remaining space. This means we want to maximize the negative of this value.\n    # A bin that leaves 0 space (a perfect fit!) will have the highest score of 0.\n    # A bin that leaves a large positive space will have a large negative score,\n    # thereby having lower priority.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best-Fit' like heuristic.\n\n    Inspired by the natural tendency of radioactive decay to seek a stable\n    (or 'full') state, this heuristic aims to place the item into the bin\n    that, after accommodating the item, leaves the smallest possible\n    remaining capacity. This maximizes the 'compactness' of our bins,\n    analogous to particles seeking their lowest energy state, thereby\n    reducing the total number of 'active' bins required.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a more favorable bin for the item.\n        Bins where the item does not fit are assigned a very low (negative infinity) priority.\n    \"\"\"\n    # Calculate the theoretical remaining capacity if the item were placed in each bin.\n    # This represents the 'potential energy state' after placement.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize priority scores for each bin.\n    # We use a float type to accommodate -np.inf.\n    priorities = np.zeros_like(bins_remain_capacity, dtype=float)\n\n    # Determine which bins can actually accommodate the item.\n    # These are the bins where the 'potential energy state' is non-negative.\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For bins where the item fits, we want to prioritize those that lead to the\n    # smallest positive remaining capacity (i.e., the 'snuggest' fit).\n    # To achieve this, we assign a score that is the negative of the remaining capacity.\n    # A smaller positive remaining capacity (e.g., 0.1) will result in a larger\n    # (less negative) score (-0.1), which is prioritized over a larger remaining\n    # capacity (e.g., 0.5) resulting in a smaller score (-0.5).\n    priorities[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]\n\n    # For bins where the item does not fit, we assign an extremely low priority.\n    # This ensures these bins are never selected.\n    priorities[~can_fit_mask] = -np.inf\n\n    return priorities",
    "response_id": 23,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 29, in priority_v2\n    # For the bins where the item can be channeled, calculate the 'residual capacitance'.\nNameError: name 'bins_remain_capacity' is not defined. Did you mean: 'bins_remain_cap'?\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    As Nikola Tesla, I perceive the flow of material as I would the flow of electricity.\n    My design, `priority_v2`, aims for optimal energy distribution within these containers,\n    harnessing the principle of 'Best Fit'. We guide the item to the bin that\n    will most 'snugly' accommodate it, leaving the least amount of disturbed, unused 'ether'.\n    This minimizes void, ensuring the highest efficiency and the least resistance\n    in our packing endeavors.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins where the item\n        does not fit receive a very low, effectively disqualifying, priority.\n    \"\"\"\n    # Initialize all bins with a profoundly low priority.\n    # Those where the item cannot possibly fit shall remain in the dark.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins can actually receive this burst of energy (item).\n    can_fit_mask = (bins_remain_cap >= item)\n\n    # For the bins where the item can be channeled, calculate the 'residual capacitance'.\n    # This is the space that remains after the item is placed.\n    remaining_capacity_if_placed = bins_remain_cap[can_fit_mask] - item\n\n    # To achieve 'Best Fit', we must minimize this residual capacitance.\n    # Therefore, we assign a priority that is the negative of this remaining capacity.\n    # Maximizing this negative value (e.g., -0.1 is greater than -0.5)\n    # naturally selects the bin with the smallest positive remaining space,\n    # or the perfect 'resonant' fit (where remainder is 0, score is 0).\n    priorities[can_fit_mask] = -remaining_capacity_if_placed\n\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    guided by the principle of Best Fit.\n\n    Just as planets orbit the sun in their most stable path, an item\n    should seek the bin where it fits most snugly, leaving the least\n    remaining space. This maximizes the utilization of our bins,\n    avoiding the creation of new ones unnecessarily.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a very low priority (-infinity).\n        Bins that can fit the item will be prioritized by how little space\n        they leave after the item is placed (smaller remainder means higher priority).\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating inability to fit\n    # or least preference if a better fit cannot be found.\n    # This ensures bins that cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins can actually accommodate the current item.\n    can_fit = bins_remain_cap >= item\n\n    # For those bins that can fit the item, calculate their \"fitness score\".\n    # A smaller remaining capacity after placing the item means a tighter fit,\n    # which is preferred. To achieve this, we want to maximize a value where\n    # `remaining_capacity_after_fit = bin_cap - item`.\n    # Thus, we maximize `item - bin_cap`.\n    # A perfect fit (bin_cap == item) results in a score of 0.\n    # A loose fit (bin_cap >> item) results in a larger negative score.\n    priorities[can_fit] = item - bins_remain_cap[can_fit]\n\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Drawing upon the principle of cosmic compression, where matter seeks the most\n    compact state, this heuristic prioritizes bins that achieve the \"densest\"\n    fit. It mimics a gravitational pull towards the most efficient containment,\n    leaving the least void. Bins that cannot accommodate the item are deemed\n    outside the event horizon and are given an infinitely low priority. For\n    those that can, the priority is inversely proportional to the void space\n    that would remain after the item's insertion. A perfect fit yields the\n    highest possible score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to negative infinity for all bins.\n    # This ensures that bins incapable of fitting the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can physically accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit, calculate the 'void' that would remain.\n    # We want to minimize this void, so we take its negative to maximize the priority.\n    # A smaller positive remainder means a higher (less negative) priority score.\n    # A perfect fit (remainder = 0) yields a score of 0, which is the highest.\n    remaining_space = bins_remain_cap[can_fit_mask] - item\n    snugness_scores = -remaining_space\n\n    # Assign these calculated scores to the eligible bins in the priorities array.\n    priorities[can_fit_mask] = snugness_scores\n\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using a \"Snugness Potential\" heuristic.\n\n    As Feynman might muse, when an item comes along, it's seeking its lowest \"energy state\" or\n    the most \"resonant cavity\" within the existing bins. This means finding a bin where it\n    fits most snugly, leaving the least amount of \"void-energy\" or wasted space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable, \"snugger\" fit. Bins that cannot\n        accommodate the item will receive a priority score of zero.\n    \"\"\"\n    \n    # Calculate the 'potential remaining space' or 'void' that would be left in each bin\n    # if the item were placed there. This is our \"energy landscape\".\n    potential_void = bins_remain_cap - item\n    \n    # Initialize all priorities to a state of \"unsuitability\" (zero).\n    # These are the bins that are either too small, or not yet evaluated for their snugness.\n    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n    \n    # Identify the 'accessible states' \u2013 bins where the item can actually fit (positive or zero void).\n    # These are the only bins where a meaningful \"snugness potential\" can be calculated.\n    can_fit_mask = potential_void >= 0\n    \n    # For the accessible states, the \"snugness potential\" is inversely proportional to the void.\n    # A smaller void implies a tighter, more \"resonant\" fit, leading to a higher priority.\n    # We add a small epsilon to the void to prevent division by zero in the case of a perfect fit,\n    # ensuring that a perfectly snug fit results in an exceptionally high, but finite, priority.\n    \n    epsilon = 1e-9  # A tiny \"quantum fluctuation\" to prevent division by zero.\n    \n    # Compute the \"snugness potential\" for suitable bins.\n    # The smaller the 'potential_void', the larger the `1.0 / (potential_void + epsilon)` term,\n    # thus prioritizing bins that are a \"best fit\".\n    priorities[can_fit_mask] = 1.0 / (potential_void[can_fit_mask] + epsilon)\n    \n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic is inspired by the \"Best Fit\" strategy, aiming to\n    place the item into the bin that will leave the least amount of\n    remaining space, thereby \"snugly\" fitting items and preserving\n    larger gaps for future larger items if possible, or tightly packing\n    bins.\n\n    The priority score is calculated such that a tighter fit (less remaining\n    capacity after placing the item) results in a higher score (closer to zero).\n    Bins where the item does not fit are assigned a very low (negative infinity)\n    priority, ensuring they are never chosen.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value means the item does not fit.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize all priority scores to a very low value (e.g., negative infinity).\n    # This ensures bins where the item does not fit are never selected.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins the item can actually fit into.\n    # A bin is suitable if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For bins where the item can fit, calculate their priority.\n    # We want to minimize the remaining capacity (potential_remaining_capacity).\n    # To achieve this with a maximum selection, we take the negative of the\n    # potential remaining capacity. A smaller positive remaining capacity\n    # (e.g., 0.0 for a perfect fit) will result in a larger priority score\n    # (e.g., 0.0), whereas a larger remaining capacity (e.g., 0.5) will\n    # result in a smaller priority score (-0.5).\n    priority_scores[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]\n\n    return priority_scores",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]