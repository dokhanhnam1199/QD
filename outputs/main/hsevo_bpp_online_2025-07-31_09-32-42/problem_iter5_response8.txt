```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by aggressively minimizing waste, with adaptive scores.

    Explicitly awards perfect fits maximal priority, and for others,
    uses a robust inverse-waste score to favor tight fits, anticipating
    efficient bin closure and minimal fragmentation.
    """
    # Initialize priorities for all bins to a very low value (-infinity).
    # This ensures that any bin that cannot fit the item will have the lowest
    # possible priority and will not be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining space in each bin if the current item were placed there.
    # A non-negative value means the item can fit; a negative value means it cannot.
    potential_remaining_space = bins_remain_cap - item

    # Create a boolean mask to identify only those bins that can actually
    # accommodate the current item (remaining space must be non-negative).
    can_fit_mask = potential_remaining_space >= 0

    # Extract the potential remaining space only for the bins that can fit the item.
    valid_potential_remaining_space = potential_remaining_space[can_fit_mask]

    # Create masks to distinguish between perfect fits (waste = 0) and non-perfect fits (waste > 0).
    perfect_fit_mask = (valid_potential_remaining_space == 0)
    non_perfect_fit_mask = (valid_potential_remaining_space > 0)

    # 1. Explicitly prioritize perfect fits with a very high, distinct score.
    # This guarantees they are chosen over any other fit, promoting immediate bin closure
    # and simplifying future packing decisions for that bin.
    PERFECT_FIT_SCORE = 1e12

    # Apply the perfect fit score to relevant bins through the nested masks.
    priorities[can_fit_mask][perfect_fit_mask] = PERFECT_FIT_SCORE

    # 2. For non-perfect fits, prioritize inversely to the remaining waste.
    # A smaller waste results in a significantly higher priority score.
    # np.finfo(float).eps provides robust numerical stability, giving very high
    # scores for extremely tight fits (waste approaching zero) without division by zero.
    TIGHT_FIT_EPSILON = np.finfo(float).eps

    # Apply the inverse-waste priority score to non-perfect fit bins.
    priorities[can_fit_mask][non_perfect_fit_mask] = \
        1.0 / (valid_potential_remaining_space[non_perfect_fit_mask] + TIGHT_FIT_EPSILON)

    return priorities
```
