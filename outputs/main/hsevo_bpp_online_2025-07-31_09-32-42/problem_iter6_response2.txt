```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for placing an item in each bin, implementing a Best Fit with Gap Avoidance strategy.

    This heuristic extends the Best Fit approach (as in priority_v1) by adding a penalty
    for creating small, non-zero remaining capacities in bins. The goal is to avoid
    fragmentation and leave more "useful" gaps, anticipating future item placements.

    A bin with a perfect fit (remaining capacity = 0) still receives the highest priority.
    For non-perfect fits, bins that would result in a very small, non-zero remaining capacity
    (below a defined epsilon_threshold) are penalized, making them less desirable than bins
    that would result in larger, potentially more useful remaining capacities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin. Assumes bin capacities
                         are normalized, e.g., between 0 and 1.0.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores are designed such that a perfect fit gets the highest possible score,
        while bins that cannot fit the item get -inf.
    """
    # Heuristic Parameters (tunable based on problem characteristics)
    # These values assume normalized bin capacities (e.g., max capacity of 1.0)
    # If bins_remain_cap are not normalized, adjust EPSILON_THRESHOLD and PENALTY_VALUE accordingly.
    
    # Define a threshold for what constitutes a "small" remaining gap.
    # For example, 0.05 means any gap less than 5% of original bin capacity is considered small.
    EPSILON_THRESHOLD = 0.05 
    
    # Penalty applied to bins that result in a small, non-zero remaining gap.
    # This value should be large enough to make penalized bins less attractive than
    # bins leaving larger, useful gaps, but not so large that it overrides perfect fits.
    PENALTY_VALUE = 0.5 

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # Extract potential remaining spaces for bins where the item can fit.
    fit_potential_remaining_space = potential_remaining_space[can_fit_mask]

    # Base priorities: Apply the Best Fit logic (smaller remaining space = higher priority).
    # A perfect fit (0 remaining space) will result in a priority of 0 (the highest in this scale).
    base_priorities = -fit_potential_remaining_space

    # Identify bins that would result in a "small, non-zero" remaining capacity.
    # These are gaps that are too small to be generally useful for future items,
    # but not a perfect zero fit.
    small_undesirable_gap_mask = (fit_potential_remaining_space > 0) & \
                                 (fit_potential_remaining_space < EPSILON_THRESHOLD)

    # Apply a penalty to the base priorities of these "undesirable" gaps.
    # This makes them less attractive compared to bins that leave either perfect fits
    # or larger, more flexible remaining capacities.
    base_priorities[small_undesirable_gap_mask] -= PENALTY_VALUE

    # Assign the calculated priorities back to the full priorities array using the mask.
    priorities[can_fit_mask] = base_priorities

    return priorities
```
