```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin.

    As a pioneer in understanding the dense nature of matter and its efficient
    packing (much like how atoms occupy space within a crystal lattice),
    this heuristic aims for the most "snug" fit possible. It prioritizes bins
    that, after accommodating the item, would leave the least amount of wasted
    space. This "Best Fit" approach tends to lead to efficient packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize all priorities to a very low value.
    # This ensures that bins where the item cannot fit are effectively eliminated
    # from consideration by the `argmax` function later.
    priorities = np.full_like(bins_remain_cap, fill_value=float('-inf'), dtype=float)

    # Calculate the space that would remain in each bin if the item were placed there.
    remaining_space_after_fit = bins_remain_cap - item

    # Identify which bins can actually accommodate the item (remaining capacity >= 0).
    can_fit_mask = remaining_space_after_fit >= 0

    # For bins that can fit the item, assign a priority.
    # We want to maximize the "snugness", which means minimizing the
    # 'remaining_space_after_fit'. By taking the negative of this value,
    # maximizing the priority score achieves the desired minimization.
    # A perfect fit (0 remaining space) will have the highest priority (0).
    priorities[can_fit_mask] = -remaining_space_after_fit[can_fit_mask]

    return priorities
```
