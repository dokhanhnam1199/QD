```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    
    This implementation prioritizes bins using a "Best Fit Decreasing" like heuristic
    for online packing. Bins that result in the smallest non-negative remaining capacity
    after adding the item receive higher priority. Perfect fits are given the highest
    possible priority (infinity). Bins that cannot accommodate the item receive a 
    priority of 0.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with a priority score for each bin.
        A higher score indicates a higher preference for placing the item in that bin.
    """
    # Initialize priorities for all bins to 0. Bins that cannot fit the item
    # or are not prioritized will retain this score.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Create a boolean mask for bins that have enough capacity to hold the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the potential remaining capacity for bins where the item can fit
    # We only operate on the subset of bins identified by can_fit_mask
    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item

    # Identify bins that would be perfectly filled by the item
    perfect_fit_mask = (potential_remain_after_fit == 0)

    # Assign infinite priority to perfect fits. This ensures they are always chosen
    # over any other non-perfect fit, as they utilize space most efficiently.
    priorities[can_fit_mask][perfect_fit_mask] = np.inf

    # For bins that can fit the item but are not perfectly filled:
    # Prioritize them inversely to their remaining capacity.
    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.
    # This encourages packing items into bins that are nearly full,
    # leaving larger bins for potentially larger future items.
    non_perfect_fit_mask = (potential_remain_after_fit > 0)
    
    # Calculate inverse for positive remaining capacities.
    # Add a small epsilon if needed to prevent division by zero for values
    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`
    # should ideally handle this.
    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]

    return priorities
```
