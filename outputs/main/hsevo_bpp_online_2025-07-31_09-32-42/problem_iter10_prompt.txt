{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining aggressive inverse-waste minimization,\n    a distinct high score for perfect fits, and a strategic penalty\n    for leaving very small, \"unusable\" remaining capacities (bad gaps).\n    This heuristic minimizes fragmentation while favoring tight fits.\n    \"\"\"\n    BIN_CAPACITY_UNIT = 1.0  # Assumed normalized bin capacity\n\n    # Heuristic Parameters\n    # Tolerance for identifying a perfect fit (remaining capacity approximately 0)\n    PERFECT_FIT_TOLERANCE = 1e-9 \n    # A very high, distinct score assigned to perfect fits to ensure top priority\n    MAX_PERFECT_FIT_SCORE = 1000.0 \n    # Threshold below which a remaining gap is considered \"bad\" (difficult to fill)\n    SMALL_GAP_THRESHOLD = 0.15 * BIN_CAPACITY_UNIT \n    # A large negative offset applied to \"bad gap\" scores. This ensures they are\n    # heavily penalized and ranked lower than any \"good gap\", despite their\n    # raw inverse-waste score potentially being high.\n    BAD_GAP_PENALTY_OFFSET = -2000.0 # Adjusted to be sufficiently negative to push\n                                     # bad gaps (which can have high 1/waste scores)\n                                     # below good gaps (e.g., if 1/waste for bad gap is 1000,\n                                     # and min 1/waste for good gap is 6.67, then 1000 - 2000 = -1000, which is < 6.67)\n\n    # Small epsilon for numerical stability in inverse calculations (prevents division by zero)\n    TIGHT_FIT_EPSILON = np.finfo(float).eps \n\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. Bins that cannot fit the item\n    # will retain this value and thus never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # We use -PERFECT_FIT_TOLERANCE to account for floating-point inaccuracies\n    # when `item` might slightly exceed `bins_remain_cap` due to precision issues.\n    can_fit_mask = potential_remaining_space >= -PERFECT_FIT_TOLERANCE\n\n    # Filter potential remaining spaces for only those bins where the item can fit.\n    valid_potential_remaining_space = potential_remaining_space[can_fit_mask]\n    \n    # Initialize a temporary array for priorities of valid bins.\n    valid_priorities = np.zeros_like(valid_potential_remaining_space, dtype=float)\n\n    # --- Scoring Logic based on Categories ---\n\n    # 1. Perfect Fit: Remaining space is approximately zero.\n    # These receive the highest possible score, making them the top choice.\n    perfect_fit_mask = np.isclose(valid_potential_remaining_space, 0.0, atol=PERFECT_FIT_TOLERANCE)\n    valid_priorities[perfect_fit_mask] = MAX_PERFECT_FIT_SCORE \n\n    # 2. Bad Gap: Remaining space is small but non-zero (i.e., (0, SMALL_GAP_THRESHOLD)).\n    # These are scored using inverse waste, but then heavily penalized by a large negative offset.\n    # This ensures they are chosen only if no 'Good Gap' or 'Perfect Fit' options are available.\n    small_gap_mask = (valid_potential_remaining_space > PERFECT_FIT_TOLERANCE) & \\\n                     (valid_potential_remaining_space < SMALL_GAP_THRESHOLD)\n    \n    # Calculate base inverse waste score for bad gaps\n    bad_gap_base_scores = 1.0 / (valid_potential_remaining_space[small_gap_mask] + TIGHT_FIT_EPSILON)\n    # Apply the heavy penalty\n    valid_priorities[small_gap_mask] = bad_gap_base_scores + BAD_GAP_PENALTY_OFFSET\n\n    # 3. Good Gap: Remaining space is greater than or equal to the threshold ([SMALL_GAP_THRESHOLD, BIN_CAPACITY_UNIT]).\n    # These are scored in a \"Best Fit\" manner using inverse waste: 1.0 / (remaining_space + epsilon).\n    # A smaller remaining space (tighter fit) results in a higher positive score.\n    other_gap_mask = valid_potential_remaining_space >= SMALL_GAP_THRESHOLD\n    valid_priorities[other_gap_mask] = 1.0 / (valid_potential_remaining_space[other_gap_mask] + TIGHT_FIT_EPSILON)\n\n    # Assign the calculated priorities back to the full 'priorities' array\n    # using the original mask for all bins that could fit the item.\n    priorities[can_fit_mask] = valid_priorities\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}