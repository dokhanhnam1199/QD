import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                epsilon_stability: float = 4.6041975107835264e-11).eps,
                base_priority_scale: float = 6.387491073357772,
                max_bin_capacity_for_normalization: float = 65.11640871830005,
                fullness_bonus_weight: float = 0.0003358945682809765) -> np.ndarray:
    """Prioritizes inverse waste for tight fits, with a subtle bonus for
    bins already fuller. Uses a customizable epsilon for stability and
    tunable weights for the different priority components.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity (waste) if the item is placed.
    remaining_waste = bins_remain_cap[can_fit_mask] - item

    # Core Best Fit (BF) priority: Inverse of (remaining_waste + epsilon).
    # This provides a strong non-linear preference for perfect or very tight fits,
    # consistent with the top-performing 'priority_v0' heuristic.
    base_priority = base_priority_scale / (remaining_waste + epsilon_stability)

    # Adaptive / Global Utility Element:
    # Introduce a subtle bonus for bins that are already more full (have less remaining capacity).
    # This element aligns with "Adaptive Logic" and "Global Utility" advice by encouraging
    # the closing of already utilized bins. It acts as a weighted tie-breaker or minor nudge
    # when the primary Best Fit scores are very close.
    # We assume `max_bin_capacity_for_normalization` represents the full capacity,
    # where `max_bin_capacity_for_normalization - bins_remain_cap` represents
    # the portion of the bin that is already filled.
    current_fullness = max_bin_capacity_for_normalization - bins_remain_cap[can_fit_mask]
    
    fullness_bonus = fullness_bonus_weight * current_fullness
    
    # Combine the dominant Best Fit priority with the subtle fullness bonus.
    priorities[can_fit_mask] = base_priority + fullness_bonus

    return priorities
