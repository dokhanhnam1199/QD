{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Implements a robust Best Fit heuristic with a strong bonus for exact fits,\n    prioritizing minimal remaining capacity.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n    \n    # Extract relevant values for bins where the item can fit.\n    valid_remaining_space = potential_remaining_space[can_fit_mask]\n    \n    # --- Core Priority: Best Fit Principle ---\n    # This component prioritizes bins that will have the least remaining space.\n    # A smaller positive remaining space (closer to a perfect fit) leads to a higher\n    # (less negative, closer to 0) base score. A perfect fit (0 remaining space)\n    # gets a base score of 0 here.\n    priorities[can_fit_mask] = -valid_remaining_space\n\n    # --- Strategic Adjustment: Perfect Fit Bonus ---\n    # Apply a large, fixed bonus to guarantee that exact fits are the highest priority.\n    # This is a critical override for optimal bin packing.\n    PERFECT_FIT_BONUS = 1000.0  # A sufficiently large, fixed constant\n    \n    perfect_fit_mask = (valid_remaining_space == 0)\n    priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit with strong Exact Fit preference and a subtle, proportional consolidation bonus.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity as per priority_v0's normalization assumption.\n    BIN_CAPACITY = 1.0 \n    \n    # Strong bonus for exact fits, making them top priority.\n    EXACT_FIT_BONUS = 100.0 \n    \n    # Small additive factor for the consolidation bonus, ensuring it only subtly\n    # influences choices without overriding strong Best Fit selections.\n    CONSOLIDATION_STRENGTH = 0.001 \n\n    # Epsilon for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100 \n\n    # Calculate potential remaining space after hypothetical placement.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit.\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # Adjust potential remaining space to be non-negative for scoring.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit logic (negative of remaining space).\n    # A smaller remaining space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Exact Fit Bonus: Prioritize bins that become perfectly full.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 3. Apply Refined Consolidation Bonus:\n    # Promote usage of existing, partially-filled bins by giving a small bonus\n    # proportional to their current fullness, but only if they are not exact fits.\n    \n    # Identify bins that are completely empty.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    \n    # Create a mask for bins that are eligible for this bonus:\n    # They must be able to fit the item, not result in an exact fit, and not be empty.\n    eligible_for_consolidation_bonus_mask = can_fit_mask & ~exact_fit_mask & ~is_empty_bin_mask\n\n    if np.any(eligible_for_consolidation_bonus_mask):\n        # Calculate the current fullness for eligible bins (0 for empty, 1 for full).\n        current_fullness_eligible = (BIN_CAPACITY - bins_remain_cap[eligible_for_consolidation_bonus_mask]) / BIN_CAPACITY\n        \n        # Add a bonus proportional to current fullness.\n        priorities[eligible_for_consolidation_bonus_mask] += CONSOLIDATION_STRENGTH * current_fullness_eligible\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes tight fits (Best Fit) and perfect fits, with an additive bonus\n    for bins that are already fuller, promoting efficient bin closure.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Small epsilon for numerical stability, especially for near-zero remaining space.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).\n    # This strongly favors bins that result in minimal remaining space (tightest fit).\n    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)\n\n    # Additive Consolidation Bias Component: Promote packing into already fuller bins.\n    # Based on analysis, a bonus directly related to individual bin fullness is preferred.\n    # A smaller bins_remain_cap (fuller bin) results in a higher inverse value,\n    # thereby giving a higher additive bonus.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05\n    consolidation_bonus = 1.0 / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n    # Combine the Best Fit score with the additive consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using Best Fit with a dominant exact fit bonus and a subtle\n    consolidation preference for partially filled bins.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for normalization.\n    BIN_CAPACITY = 1.0\n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to a very high value to ensure exact fits are chosen first.\n    PERFECT_FIT_BONUS = 1e9 \n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing bins.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty, and are not perfect fits.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\n# Assume a global BIN_CAPACITY for context. This is typical in Bin Packing Problem (BPP)\n# where items and bin capacities are often normalized, e.g., to 1.0.\nBIN_CAPACITY = 1.0\n\n# Define heuristic parameters for strategic adjustments.\n# These values are empirical and might require tuning for specific problem distributions.\n\n# EPSILON_CLOSE_TO_ZERO: Tolerance for floating-point comparisons to detect \"exact\" fits.\n# Essential for numerical robustness in comparisons with zero.\nEPSILON_CLOSE_TO_ZERO = 1e-6\n\n# FRAGMENTATION_LOW_THRESHOLD & FRAGMENTATION_HIGH_THRESHOLD:\n# Define a range for \"fragmented\" gaps. These are remaining capacities that are\n# too small to be widely useful for future items, but not small enough to be\n# considered a \"perfect fit\". Placing an item here might lead to wasted space.\nFRAGMENTATION_LOW_THRESHOLD = 0.05 * BIN_CAPACITY # e.g., 5% of bin capacity\nFRAGMENTATION_HIGH_THRESHOLD = 0.20 * BIN_CAPACITY # e.g., 20% of bin capacity\n\n# FRAGMENTATION_PENALTY: The amount by which to reduce the priority for creating\n# a fragmented gap. This is a fixed additive penalty, designed to discourage\n# such outcomes without overriding truly tight fits.\nFRAGMENTATION_PENALTY = 0.3 # A moderate, fixed penalty value.\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a Best Fit core, with an absolute preference for exact fits,\n    and a fixed penalty for creating small, fragmented remaining capacities.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # We allow for very small negative remaining space due to floating point inaccuracies,\n    # treating them as effectively zero.\n    can_fit_mask = potential_remaining_space >= -EPSILON_CLOSE_TO_ZERO\n\n    # Extract the potential remaining space for only the bins where the item can fit.\n    fitting_rem_space = potential_remaining_space[can_fit_mask]\n\n    # --- Step 1: Base Priority (Best Fit logic) ---\n    # The base priority is the negative of the potential remaining space.\n    # This means a smaller remaining space (closer to zero) results in a\n    # higher (less negative or zero) priority score. A perfect fit (0 remaining space)\n    # gets a base score of 0, which is the highest possible \"default\" score.\n    current_priorities_for_fit_bins = -fitting_rem_space\n\n    # --- Step 2: Strategic Additive Adjustments ---\n\n    # 2.1. Overwhelming Priority for Exact/Near-Exact Fits:\n    # Identify bins where the item perfectly or very nearly perfectly fills the bin.\n    # Assign them an extremely high, distinct priority to ensure they are always chosen\n    # if available, as this represents maximal bin utilization.\n    is_exact_or_near_fit = np.abs(fitting_rem_space) < EPSILON_CLOSE_TO_ZERO\n    current_priorities_for_fit_bins[is_exact_or_near_fit] = np.finfo(float).max / 2.0\n\n    # For subsequent adjustments, we only consider bins that are not an exact fit,\n    # as their priority has already been set to the highest possible value.\n    non_exact_mask = ~is_exact_or_near_fit\n\n    # 2.2. Penalty for Fragmented Gaps:\n    # Identify bins that, if chosen, would result in a remaining capacity falling\n    # within the \"fragmentation zone\". Reduce their priority to discourage their selection,\n    # promoting the creation of either very small (perfect fit) or larger, more usable gaps.\n    is_fragmented_zone_gap = (fitting_rem_space > FRAGMENTATION_LOW_THRESHOLD) & \\\n                             (fitting_rem_space < FRAGMENTATION_HIGH_THRESHOLD) & \\\n                             non_exact_mask\n    current_priorities_for_fit_bins[is_fragmented_zone_gap] -= FRAGMENTATION_PENALTY\n\n    # Assign the calculated priorities for fitting bins back into the main priorities array.\n    priorities[can_fit_mask] = current_priorities_for_fit_bins\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes tight fits (Best Fit) and perfect fits, with an additive bonus\n    for bins that are already fuller, promoting efficient bin closure.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Small epsilon for numerical stability, especially for near-zero remaining space.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).\n    # This strongly favors bins that result in minimal remaining space (tightest fit).\n    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)\n\n    # Additive Consolidation Bias Component: Promote packing into already fuller bins.\n    # Based on analysis, a bonus directly related to individual bin fullness is preferred.\n    # A smaller bins_remain_cap (fuller bin) results in a higher inverse value,\n    # thereby giving a higher additive bonus.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05\n    consolidation_bonus = 1.0 / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n    # Combine the Best Fit score with the additive consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using Best Fit with a dominant exact fit bonus and a subtle\n    consolidation preference for partially filled bins.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for normalization.\n    BIN_CAPACITY = 1.0\n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to a very high value to ensure exact fits are chosen first.\n    PERFECT_FIT_BONUS = 1e9 \n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing bins.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty, and are not perfect fits.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes tight fits (Best Fit) and perfect fits, with an additive bonus\n    for bins that are already fuller, promoting efficient bin closure.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Small epsilon for numerical stability, especially for near-zero remaining space.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).\n    # This strongly favors bins that result in minimal remaining space (tightest fit).\n    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)\n\n    # Additive Consolidation Bias Component: Promote packing into already fuller bins.\n    # Based on analysis, a bonus directly related to individual bin fullness is preferred.\n    # A smaller bins_remain_cap (fuller bin) results in a higher inverse value,\n    # thereby giving a higher additive bonus.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05\n    consolidation_bonus = 1.0 / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n    # Combine the Best Fit score with the additive consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a\n    relative utilization-based heuristic that encourages emergent packing behavior.\n\n    This heuristic assigns a priority to each bin based on how much of its current\n    remaining capacity the incoming item would consume. The goal is to maximize\n    the 'relative utilization' for the current placement. This local rule aims to\n    drive the system towards effectively filling bins. Bins that cannot accommodate\n    the item receive the lowest possible priority (0.0), ensuring they are not chosen,\n    without relying on specific numerical artifacts like infinity.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         Assumed to contain non-negative float values.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores range from 0.0 (for non-fitting bins or bins with very large remaining\n        capacity relative to the item) up to 1.0 (for a perfect fit).\n    \"\"\"\n    # Initialize all priorities to 0.0. This value implicitly represents the\n    # lowest possible priority for a valid item and will be assigned to bins\n    # that cannot fit the item. This avoids reliance on -np.inf.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # If item is positive, and bins_remain_cap is 0, this mask will correctly\n    # exclude that bin, preventing division by zero.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the priority for bins where the item can fit.\n    # The priority is the ratio of the item's size to the bin's remaining capacity.\n    # A higher ratio indicates that the item consumes a larger proportion of the\n    # available space, leading to a \"tighter\" relative fit.\n    # This promotes the local rule of maximizing current space efficiency.\n    # For a perfect fit (item == bins_remain_cap), the score will be 1.0,\n    # representing the highest possible priority.\n    \n    # We use `np.where` for a vectorized conditional assignment.\n    # For bins where `can_fit_mask` is True, we calculate `item / bins_remain_cap`.\n    # For bins where `can_fit_mask` is False (item does not fit), we assign 0.0.\n    # Note: `item / bins_remain_cap` for elements where `bins_remain_cap` is 0\n    # and `can_fit_mask` is False will not be evaluated, thus preventing ZeroDivisionError.\n    priorities = np.where(can_fit_mask, item / bins_remain_cap, 0.0)\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Best Fit.\n\n    This heuristic aims to select the bin that will have the least remaining capacity\n    after the item is placed, effectively trying to \"fill up\" a bin as much as possible.\n    Bins that cannot accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit (remaining capacity = 0) gets the\n        highest possible score (0), while bins that cannot fit the item get -inf.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    # A smaller positive value here means a \"better fit\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the negative\n    # of the potential remaining space.\n    # By maximizing this value, we are effectively minimizing the potential remaining space.\n    # A perfect fit (0 remaining space) will result in a priority of 0 (the highest).\n    # A larger remaining space (e.g., 0.5) will result in a lower priority (-0.5).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority for placing an item in each bin, implementing a strategy\n    that favors keeping bins with more remaining capacity flexible for future items,\n    akin to a Worst Fit approach, and designed with \"emergent behavior\" in mind.\n\n    This heuristic assigns a higher priority to bins that would have more space remaining\n    after the item is placed, provided the item can fit. This aims to keep bins\n    \"open\" and versatile for subsequent, potentially larger, items, letting a global\n    packing strategy emerge from these local decisions rather than explicit optimization.\n    Bins that cannot accommodate the item receive a low, but finite, priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed to reflect the desirability of a bin, with unfitting\n        bins receiving a score strictly lower than any possible valid placement.\n    \"\"\"\n    # Initialize all priorities to a sufficiently small negative value.\n    # This ensures that any bin where the item cannot fit will always have\n    # a lower priority than any bin where it can fit, without using -np.inf.\n    # Assuming capacities and item sizes are positive, the minimum valid\n    # remaining capacity (for a perfect fit) is 0. Thus, any negative value\n    # effectively excludes non-fitting bins.\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit\n    # (i.e., where potential_remaining_space is non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the\n    # potential remaining space. A larger positive value means more space\n    # would be left, which is preferred in this \"Worst Fit\" type of strategy.\n    # This promotes keeping bins less full, allowing for more flexibility\n    # in subsequent item placements.\n    priorities[can_fit_mask] = potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority for placing an item in each bin, implementing a strategy\n    that favors keeping bins with more remaining capacity flexible for future items,\n    akin to a Worst Fit approach, and designed with \"emergent behavior\" in mind.\n\n    This heuristic assigns a higher priority to bins that would have more space remaining\n    after the item is placed, provided the item can fit. This aims to keep bins\n    \"open\" and versatile for subsequent, potentially larger, items, letting a global\n    packing strategy emerge from these local decisions rather than explicit optimization.\n    Bins that cannot accommodate the item receive a low, but finite, priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed to reflect the desirability of a bin, with unfitting\n        bins receiving a score strictly lower than any possible valid placement.\n    \"\"\"\n    # Initialize all priorities to a sufficiently small negative value.\n    # This ensures that any bin where the item cannot fit will always have\n    # a lower priority than any bin where it can fit, without using -np.inf.\n    # Assuming capacities and item sizes are positive, the minimum valid\n    # remaining capacity (for a perfect fit) is 0. Thus, any negative value\n    # effectively excludes non-fitting bins.\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit\n    # (i.e., where potential_remaining_space is non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the\n    # potential remaining space. A larger positive value means more space\n    # would be left, which is preferred in this \"Worst Fit\" type of strategy.\n    # This promotes keeping bins less full, allowing for more flexibility\n    # in subsequent item placements.\n    priorities[can_fit_mask] = potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority for placing an item in each bin, implementing a strategy\n    that favors keeping bins with more remaining capacity flexible for future items,\n    akin to a Worst Fit approach, and designed with \"emergent behavior\" in mind.\n\n    This heuristic assigns a higher priority to bins that would have more space remaining\n    after the item is placed, provided the item can fit. This aims to keep bins\n    \"open\" and versatile for subsequent, potentially larger, items, letting a global\n    packing strategy emerge from these local decisions rather than explicit optimization.\n    Bins that cannot accommodate the item receive a low, but finite, priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed to reflect the desirability of a bin, with unfitting\n        bins receiving a score strictly lower than any possible valid placement.\n    \"\"\"\n    # Initialize all priorities to a sufficiently small negative value.\n    # This ensures that any bin where the item cannot fit will always have\n    # a lower priority than any bin where it can fit, without using -np.inf.\n    # Assuming capacities and item sizes are positive, the minimum valid\n    # remaining capacity (for a perfect fit) is 0. Thus, any negative value\n    # effectively excludes non-fitting bins.\n    priorities = np.full_like(bins_remain_cap, -1.0, dtype=float)\n\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit\n    # (i.e., where potential_remaining_space is non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the\n    # potential remaining space. A larger positive value means more space\n    # would be left, which is preferred in this \"Worst Fit\" type of strategy.\n    # This promotes keeping bins less full, allowing for more flexibility\n    # in subsequent item placements.\n    priorities[can_fit_mask] = potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.\n\n    This heuristic aims to select the bin that has the most remaining capacity before the item is\n    placed (since item size is constant for comparison), effectively trying to keep bins\n    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute\n    items widely, promoting an emergent behavior of balanced bin usage across the available\n    containers, rather than aggressively filling and closing bins. This approach attempts to\n    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.\n\n    This design adheres to the principle of \"minimal, local decision rules where desired global\n    outcomes emerge from their aggregate application,\" avoiding explicit global objectives or\n    reliance on numerical infinities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Bins that cannot accommodate the item receive a low, fixed finite priority score.\n    \"\"\"\n    # Initialize all priorities to a sufficiently low, but finite, number.\n    # This ensures that any bin that cannot fit the item will have a lower priority\n    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.\n    LOW_PRIORITY = -1000.0\n    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item can fit, assign a priority based directly on their\n    # current remaining capacity. By maximizing this value, we are effectively choosing\n    # the bin with the most remaining space (Worst Fit). This is a simple, local rule\n    # that encourages spreading out items across bins, allowing the overall distribution\n    # of items to emerge from these repeated local decisions.\n    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}