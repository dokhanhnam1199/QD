```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines linear Best Fit with a linear consolidation bias and dominant perfect fit.
    Prioritizes tightest fits while encouraging use of fuller bins.
    """
    # Initialize all priorities to negative infinity, unequivocally marking bins
    # that cannot accommodate the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return the initialized priorities.
    if not np.any(can_fit_mask):
        return priorities

    # Extract relevant data for bins that can fit the item.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Potential remaining space if the item were placed in fit-capable bins.
    potential_remaining_space = fitting_bins_remain_cap - item

    # Core Best Fit Component: Assign priority linearly as the negative of potential remaining space.
    # This ensures that smaller remaining space (tighter fit) results in a higher score.
    # A perfect fit (0 remaining) gets a score of 0.
    best_fit_scores = -potential_remaining_space

    # Linear Consolidation Bias Component: Promote packing into already fuller bins.
    # A smaller bins_remain_cap (fuller bin) leads to a larger (less negative) bonus score,
    # thereby giving a higher additive bonus.
    CONSOLIDATION_BIAS_WEIGHT = 0.05 
    consolidation_bonus = -fitting_bins_remain_cap * CONSOLIDATION_BIAS_WEIGHT

    # Combine the linear Best Fit score with the linear consolidation bias.
    priorities[can_fit_mask] = best_fit_scores + consolidation_bonus

    # Explicitly boost perfect fits to ensure their absolute priority.
    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.
    PERFECT_FIT_TOLERANCE = 1e-9
    # A very high score to ensure perfect fits are chosen over any other option.
    PERFECT_FIT_SCORE = 1e30 

    # Identify perfect or near-perfect fits within the fitting bins.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE

    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    return priorities
```
