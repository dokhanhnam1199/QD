```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Hybrid Best Fit with explicit perfect fit priority and bin consolidation bonus.
    Prioritizes perfect fits. For others, balances tight fit (inverse waste) with
    a subtle bonus for fuller bins to encourage closure.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, all priorities remain -inf.
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    potential_remaining_space = fitting_bins_remain_cap - item

    # Constants for numerical stability and scoring.
    STABILITY_EPSILON = np.finfo(float).eps  # Smallest representable float
    PERFECT_FIT_TOLERANCE = 1e-6             # Absolute tolerance for near-perfect fits
    PERFECT_FIT_SCORE = 1e12                 # High score for perfect fits to guarantee selection
    ALPHA_FULLNESS_BONUS = 0.01              # Weight for the bin fullness component (0.01-0.05 is often a good start)

    # 1. Explicitly identify and prioritize perfect or near-perfect fits.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE
    
    # Apply the highest score to perfect fit bins.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    # 2. For non-perfect fits, calculate a combined score.
    non_perfect_fit_mask_in_fitting = ~perfect_fit_mask_in_fitting
    
    # Only proceed if there are bins that are not perfect fits but can still fit the item.
    if np.any(non_perfect_fit_mask_in_fitting):
        non_perfect_potential_rem = potential_remaining_space[non_perfect_fit_mask_in_fitting]
        non_perfect_bins_remain_cap = fitting_bins_remain_cap[non_perfect_fit_mask_in_fitting]

        # Primary component: Inverse of remaining waste (Best Fit).
        # This gives disproportionately higher scores to tighter fits.
        best_fit_score = 1.0 / (non_perfect_potential_rem + STABILITY_EPSILON)

        # Secondary component: Inverse of remaining capacity (Fullness Bonus).
        # Gives higher scores to bins that are already more full (smaller remaining capacity),
        # acting as a subtle bias towards closing bins.
        bin_fullness_score = 1.0 / (non_perfect_bins_remain_cap + STABILITY_EPSILON)

        # Combine: Multiply the best-fit score by a factor that increases with bin fullness.
        # The '1.0 + alpha * ...' ensures the primary best_fit_score is amplified, not replaced,
        # by the fullness component, balancing immediate fit quality with bin consolidation.
        combined_score = best_fit_score * (1.0 + ALPHA_FULLNESS_BONUS * bin_fullness_score)
        
        # Assign these combined scores to the non-perfect fitting bins.
        priorities[can_fit_mask][non_perfect_fit_mask_in_fitting] = combined_score

    return priorities
```
