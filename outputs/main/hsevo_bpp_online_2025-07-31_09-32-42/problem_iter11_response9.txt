```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Best Fit with strong Exact Fit preference and a subtle, proportional consolidation bonus.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.full(num_bins, -np.inf, dtype=float)

    # Assume a standard bin capacity as per priority_v0's normalization assumption.
    BIN_CAPACITY = 1.0 
    
    # Strong bonus for exact fits, making them top priority.
    EXACT_FIT_BONUS = 100.0 
    
    # Small additive factor for the consolidation bonus, ensuring it only subtly
    # influences choices without overriding strong Best Fit selections.
    CONSOLIDATION_STRENGTH = 0.001 

    # Epsilon for robust floating-point comparisons.
    EPSILON = np.finfo(float).eps * 100 

    # Calculate potential remaining space after hypothetical placement.
    potential_remaining_space = bins_remain_cap - item

    # Identify bins where the item can fit.
    can_fit_mask = potential_remaining_space >= -EPSILON

    # Adjust potential remaining space to be non-negative for scoring.
    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)

    # 1. Base Score: Apply Best Fit logic (negative of remaining space).
    # A smaller remaining space results in a higher (less negative) score.
    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]

    # 2. Apply Exact Fit Bonus: Prioritize bins that become perfectly full.
    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)
    priorities[exact_fit_mask] += EXACT_FIT_BONUS

    # 3. Apply Refined Consolidation Bonus:
    # Promote usage of existing, partially-filled bins by giving a small bonus
    # proportional to their current fullness, but only if they are not exact fits.
    
    # Identify bins that are completely empty.
    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)
    
    # Create a mask for bins that are eligible for this bonus:
    # They must be able to fit the item, not result in an exact fit, and not be empty.
    eligible_for_consolidation_bonus_mask = can_fit_mask & ~exact_fit_mask & ~is_empty_bin_mask

    if np.any(eligible_for_consolidation_bonus_mask):
        # Calculate the current fullness for eligible bins (0 for empty, 1 for full).
        current_fullness_eligible = (BIN_CAPACITY - bins_remain_cap[eligible_for_consolidation_bonus_mask]) / BIN_CAPACITY
        
        # Add a bonus proportional to current fullness.
        priorities[eligible_for_consolidation_bonus_mask] += CONSOLIDATION_STRENGTH * current_fullness_eligible

    return priorities
```
