```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    guided by the principle of Best Fit.

    Just as planets orbit the sun in their most stable path, an item
    should seek the bin where it fits most snugly, leaving the least
    remaining space. This maximizes the utilization of our bins,
    avoiding the creation of new ones unnecessarily.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a very low priority (-infinity).
        Bins that can fit the item will be prioritized by how little space
        they leave after the item is placed (smaller remainder means higher priority).
    """
    # Initialize all priorities to a very low value, indicating inability to fit
    # or least preference if a better fit cannot be found.
    # This ensures bins that cannot fit the item are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins can actually accommodate the current item.
    can_fit = bins_remain_cap >= item

    # For those bins that can fit the item, calculate their "fitness score".
    # A smaller remaining capacity after placing the item means a tighter fit,
    # which is preferred. To achieve this, we want to maximize a value where
    # `remaining_capacity_after_fit = bin_cap - item`.
    # Thus, we maximize `item - bin_cap`.
    # A perfect fit (bin_cap == item) results in a score of 0.
    # A loose fit (bin_cap >> item) results in a larger negative score.
    priorities[can_fit] = item - bins_remain_cap[can_fit]

    return priorities
```
