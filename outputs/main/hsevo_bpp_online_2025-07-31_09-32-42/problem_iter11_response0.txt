```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Robust Best Fit heuristic that favors least remaining capacity.

    This function implements a highly effective Best Fit strategy by prioritizing bins
    that result in the smallest remaining capacity after placing the item. This simple,
    local rule naturally encourages filling bins and achieves consolidation without
    complex parameters or conflicting objectives, aligning with emergent behavior principles.
    """
    # Calculate the remaining space in each bin if the item were placed.
    # A smaller positive value here means a "better fit".
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # For bins where the item can fit, assign a priority based on the negative
    # of the potential remaining space.
    # By maximizing this value, we effectively minimize the potential remaining space.
    # A perfect fit (0 remaining space) naturally results in a priority of 0 (the highest possible),
    # embodying the "perfect fit" priority without explicit, hardcoded scores.
    # This approach synthesizes the robustness of simple Best Fit from the "better code"
    # and the rejection of complex, sensitive parameters from the "worse code" analysis.
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    return priorities
```
