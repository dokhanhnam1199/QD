```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using a non-linear 'Best Fit' approach, emphasizing very
    tight fits while robustly disqualifying bins that cannot fit the item.
    """
    # Initialize priorities to negative infinity, ensuring bins unable to fit
    # the item are unequivocally disqualified. This is a robust signal.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins have sufficient remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining space (waste) in suitable bins after placing the item.
    # A smaller waste indicates a more efficient, tighter fit.
    remaining_waste = bins_remain_cap[can_fit_mask] - item

    # A small positive constant to ensure numerical stability and to assign a
    # very high, finite priority to perfect fits (waste = 0). This creates
    # a strong non-linear preference for bins that are nearly or perfectly full.
    EPSILON = 1e-9

    # Calculate priority as the inverse of (waste + epsilon).
    # This non-linear function disproportionately rewards very small waste values,
    # making perfect or near-perfect fits highly desirable.
    priorities[can_fit_mask] = 1.0 / (remaining_waste + EPSILON)

    return priorities
```
