```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines robust Best Fit (prioritizing minimal waste) with an adaptive, linear bias
    towards selecting already fuller bins. This hybrid approach aims for both immediate
    waste minimization and long-term bin consolidation for improved global utility.
    """
    # Initialize all priorities to negative infinity, unequivocally marking bins
    # that cannot accommodate the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return the initialized priorities.
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the potential remaining space (waste) if the item were placed in fit-capable bins.
    potential_remaining_space = bins_remain_cap[can_fit_mask] - item

    # Use a small epsilon for numerical stability, especially for perfect fits (waste = 0).
    # This ensures perfect fits receive a very high, but finite, priority score.
    epsilon = np.finfo(float).eps

    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).
    # This strongly favors bins that result in minimal remaining space.
    best_fit_scores = 1.0 / (potential_remaining_space + epsilon)

    # Adaptive Consolidation Bias Component:
    # Introduce a positive bias for bins that are already relatively full.
    # This encourages packing into existing, more utilized bins, contributing to
    # overall bin consolidation and reducing the number of bins used.
    # We use the maximum remaining capacity among *all* bins as a dynamic reference
    # for what an "empty" bin looks like in the current system state.
    max_rem_cap = np.max(bins_remain_cap)

    # Calculate the relative "fullness" of each fitting bin. A lower bins_remain_cap
    # indicates a fuller bin, resulting in a higher fullness score (closer to 1).
    # Add epsilon to denominator to prevent division by zero if max_rem_cap is 0 (e.g., all bins are full).
    # In such a case, can_fit_mask would likely be all false unless item is 0.
    relative_fullness = (max_rem_cap - bins_remain_cap[can_fit_mask]) / (max_rem_cap + epsilon)

    # Define the weight of the consolidation bias. This is a tunable parameter.
    # A small positive value ensures this bias influences decisions, especially
    # when Best Fit scores are very close, without overpowering the primary
    # waste minimization objective.
    consolidation_bias_weight = 0.05

    # Combine the Best Fit score with the adaptive consolidation bias.
    # The bias is added to the Best Fit score, subtly promoting fuller bins.
    priorities[can_fit_mask] = best_fit_scores + consolidation_bias_weight * relative_fullness

    return priorities
```
