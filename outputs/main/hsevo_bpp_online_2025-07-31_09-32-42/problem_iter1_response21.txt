```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add an item to each bin.

    Inspired by the cosmic dance of matter and space-time, this heuristic
    endeavors to find the most "harmonious" fit for an incoming item.
    Just as a celestial body warps space-time to find its natural orbit,
    we seek to minimize the "distortion" or "void" left in a bin after
    the item is placed. This translates to the "Best Fit" (BF) strategy.

    Bins that can perfectly accommodate the item (resulting in zero remaining space)
    are given the highest priority, analogous to a stable, low-energy state.
    Bins that provide a snug, but not perfect, fit are next preferred.
    Conversely, bins where the item does not fit at all are deemed
    "inaccessible regions" and are assigned the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority. Bins where the item does
        not fit will receive a very low (negative infinity) priority.
    """
    # Calculate the hypothetical remaining capacity for each bin if the item were placed.
    # This represents the "potential void" or "energy difference".
    potential_remaining_space = bins_remain_cap - item

    # Initialize priority scores. Bins that cannot fit the item are given
    # an infinitely low priority, effectively excluding them from consideration.
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify the bins where the item can actually be placed (i.e., where
    # the 'potential void' is non-negative).
    can_fit_mask = potential_remaining_space >= 0

    # For those bins where the item fits, the priority is determined by
    # minimizing the remaining space. A smaller remaining space implies a
    # "tighter fit" and thus a higher desirability. To translate this
    # minimization into a maximization (as higher score = higher priority),
    # we take the negative of the remaining space. A perfectly tight fit (0 remaining)
    # yields a score of 0, which is the highest possible.
    # As the remaining space increases, the score becomes more negative.
    priority_scores[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    return priority_scores
```
