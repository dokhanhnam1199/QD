```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority for placing an item into each bin, implementing a heuristic
    that focuses on the proportional fit of the item into the bin's current capacity,
    while naturally de-prioritizing non-fitting bins without relying on infinity.

    This heuristic encourages placing an item into a bin where it will consume a
    significant proportion of the bin's *current* available capacity. This approach
    aims to fill bins efficiently by making more 'used' bins (those with less remaining
    capacity) more attractive for the current item, provided the item fits.
    Bins that cannot accommodate the item receive a very low, concrete negative priority score.

    The motivation is to foster an "emergent behavior" of bin completion through a
    simple, local decision rule based on current state (bins_remain_cap) and item size,
    without explicitly minimizing the *post-placement* remaining space or using infinite values.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores for non-fitting bins are set to a very low finite number to ensure they are not chosen.
    """
    # Initialize all priorities to a sufficiently low finite number.
    # This value acts as a strong penalty for bins that cannot fit the item,
    # ensuring they are never selected, while avoiding the use of -np.inf.
    priorities = np.full_like(bins_remain_cap, -1e9, dtype=float) # Using -1 billion as a sufficiently low finite value

    # Create a boolean mask for bins where the item can actually fit.
    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item can fit, assign a priority based on the ratio of
    # the item's size to the bin's *current* remaining capacity.
    # A higher ratio (e.g., item=0.3, bin_cap=0.4 => 0.75) indicates that the item
    # will utilize a larger proportion of the bin's current available space.
    # This implicitly favors bins that are already somewhat "full" or have just
    # enough space, encouraging them to be filled further.
    # This strategy promotes a form of efficient packing by pushing items into
    # the 'tightest' *current* spaces available.
    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]

    return priorities
```
