```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:
    """Hybrid Best Fit with explicit perfect fit priority and fullness bonus.
    Prioritizes perfect fits, then combines inverse waste minimization with a
    multiplicative bonus for bin fullness to encourage consolidation.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # 1. Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Extract relevant data for bins that can fit, to avoid re-indexing.
    relevant_bins_remain_cap = bins_remain_cap[can_fit_mask]
    potential_remain_after_fit = relevant_bins_remain_cap - item

    # Epsilon for numerical stability, using a small standard machine epsilon.
    epsilon = np.finfo(float).eps

    # 2. Prioritize Perfect Fits: Assign a very high, distinct score.
    # Use a tolerance for floating point comparisons, scaled by bin_capacity for robustness
    # across different problem scales.
    PERFECT_FIT_TOLERANCE = epsilon * bin_capacity 
    
    # Mask for perfect fits *within the set of bins that can fit*.
    perfect_fit_sub_mask = (np.abs(potential_remain_after_fit) < PERFECT_FIT_TOLERANCE)
    
    # A large, bin_capacity-scaled score ensures perfect fits are unequivocally dominant.
    PERFECT_FIT_SCORE = 1e6 * bin_capacity 
    
    # Assign perfect fit scores to the identified bins.
    priorities[can_fit_mask][perfect_fit_sub_mask] = PERFECT_FIT_SCORE

    # 3. Process Non-Perfect Fits: Apply the hybrid Best Fit + Fullness logic.
    # Mask for non-perfect fits *within the set of bins that can fit*.
    non_perfect_fit_sub_mask = ~perfect_fit_sub_mask

    # Get the remaining waste and bin remaining capacities specifically for non-perfect fits.
    remaining_waste_non_perfect = potential_remain_after_fit[non_perfect_fit_sub_mask]
    bins_remain_cap_non_perfect = relevant_bins_remain_cap[non_perfect_fit_sub_mask]

    # Primary Best Fit component: Inverse of (remaining_waste + epsilon).
    # This gives disproportionately high scores to tighter (but not perfect) fits.
    best_fit_score = 1.0 / (remaining_waste_non_perfect + epsilon)

    # Bin Fullness component: Inverse of (bins_remain_cap + epsilon).
    # This term gives higher scores to bins that are already more full (smaller bins_remain_cap),
    # acting as a bias towards closing bins.
    bin_fullness_score = 1.0 / (bins_remain_cap_non_perfect + epsilon)

    # Weighting factor for the bin fullness bonus.
    # A small alpha ensures that the primary Best Fit (waste minimization) remains dominant,
    # but the fullness component provides a subtle, adaptive influence, encouraging bin closure.
    alpha = 0.01  # Tunable parameter: Adjust based on desired balance.

    # Combine: Multiply the best-fit score by a factor that increases with bin fullness.
    # The '1.0 + alpha * ...' ensures the base best_fit_score is always present
    # and is only amplified by the fullness, not replaced.
    combined_score = best_fit_score * (1.0 + alpha * bin_fullness_score)

    # Assign these combined scores to the corresponding non-perfect fit bins.
    priorities[can_fit_mask][non_perfect_fit_sub_mask] = combined_score

    return priorities
```
