```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with Strong Perfect Fit Preference, Inverse Waste Scoring,
    and an Adaptive Consolidation Bias to encourage filling existing bins faster.
    """
    BIN_CAPACITY = 1.0
    PERFECT_FIT_TOLERANCE = 1e-6
    EPSILON = np.finfo(float).eps
    MAX_PRIORITY_SCORE = 1e12
    # A factor to weigh the consolidation bias. A small positive value ensures it
    # influences choices among bins with similar inverse waste scores without dominating.
    CONSOLIDATION_FACTOR = 0.1

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. Bins that cannot fit the item
    # will retain this value, ensuring they are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    # We allow a tiny negative remaining space due to floating-point precision.
    can_fit_mask = potential_remaining_space >= -PERFECT_FIT_TOLERANCE

    # Extract the potential remaining spaces only for bins where the item can fit.
    fitting_potential_rem_space = potential_remaining_space[can_fit_mask]
    
    # Get the original remaining capacities for these fitting bins.
    # This is needed to calculate the current "fullness" before placing the item.
    fitting_bins_original_cap = bins_remain_cap[can_fit_mask]

    # Initialize priorities for fitting bins.
    fitting_priorities = np.zeros_like(fitting_potential_rem_space)

    # Identify perfect or near-perfect fits based on the defined tolerance.
    perfect_fit_mask = np.abs(fitting_potential_rem_space) <= PERFECT_FIT_TOLERANCE

    # Assign the maximal priority score for perfect fits. This strongly encourages closing bins.
    fitting_priorities[perfect_fit_mask] = MAX_PRIORITY_SCORE

    # For bins that are not a perfect fit, apply an inverse waste scoring
    # and add a consolidation bias.
    non_perfect_fit_mask = ~perfect_fit_mask
    
    # Calculate waste for inverse scoring. Since perfect_fit_mask handles near-zero,
    # fitting_potential_rem_space[non_perfect_fit_mask] will be positive.
    waste_for_inverse = fitting_potential_rem_space[non_perfect_fit_mask]

    # Calculate current bin fullness: (BIN_CAPACITY - current_remaining_capacity) / BIN_CAPACITY.
    # A bin that is already 'fuller' (i.e., has less remaining capacity) gets a higher fullness score.
    # This term acts as an adaptive, linear bias, encouraging consolidation by slightly preferring
    # bins that are already well-filled, given similar waste.
    current_bin_fullness = (BIN_CAPACITY - fitting_bins_original_cap[non_perfect_fit_mask]) / BIN_CAPACITY
    
    # Apply the inverse waste function. Adding EPSILON prevents division by zero.
    # Then add the consolidation bias.
    fitting_priorities[non_perfect_fit_mask] = (
        1 / (waste_for_inverse + EPSILON) + CONSOLIDATION_FACTOR * current_bin_fullness
    )

    # Update the main priorities array with the scores for fitting bins.
    priorities[can_fit_mask] = fitting_priorities

    return priorities
```
