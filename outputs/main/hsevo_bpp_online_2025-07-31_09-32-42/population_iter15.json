[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with strong bonuses for perfect fits and consolidating\n    items into already partially-filled bins.\n    \"\"\"\n    # Constants for priority bonuses, chosen to ensure desired hierarchy\n    PERFECT_FIT_BONUS = 10000.0  # Very large, fixed bonus for exact fits (dominant)\n    CONSOLIDATION_BONUS = 5.0    # Fixed bonus for filling existing, partially used bins\n\n    # Initialize priorities to negative infinity. Bins that cannot fit the item\n    # will maintain this low priority and thus never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n    \n    # Extract relevant values for bins where the item can fit for efficient computation.\n    valid_remaining_space = potential_remaining_space[can_fit_mask]\n    \n    # --- Core Priority: Best Fit Principle ---\n    # Assign a base score to eligible bins. Prioritize bins that would have the\n    # least remaining space (i.e., closest to a perfect fit but not necessarily 0).\n    # A smaller positive remaining space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -valid_remaining_space\n\n    # --- Consolidation Bonus (Strategic Fill) ---\n    # Apply a fixed bonus to bins that are already partially utilized (not full, not empty).\n    # This encourages packing into existing bins before opening new ones (assuming full capacity\n    # is the maximum value in bins_remain_cap).\n    if bins_remain_cap.size > 0: # Avoid errors on empty bin list\n        # Determine what \"full capacity\" means from the current bin capacities.\n        # This assumes the largest capacity in the array represents a \"new/empty\" bin.\n        max_current_cap = np.max(bins_remain_cap)\n        \n        # Identify bins that are currently partially filled (not completely empty, not full).\n        is_partially_filled_pre_placement = (bins_remain_cap < max_current_cap) & (bins_remain_cap > 0)\n        \n        # Apply consolidation bonus to bins that can fit the item AND are partially filled.\n        consolidation_eligible_mask = can_fit_mask & is_partially_filled_pre_placement\n        priorities[consolidation_eligible_mask] += CONSOLIDATION_BONUS\n\n    # --- Perfect Fit Bonus (Dominant Override) ---\n    # Apply a very large, fixed bonus to guarantee that exact fits (remaining space == 0)\n    # are always the highest possible priority. This overrides any other score for perfect fits.\n    perfect_fit_mask = (valid_remaining_space == 0)\n    # Apply the bonus to the subset of priorities corresponding to fitting bins that are perfect fits.\n    priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit with overwhelming exact fit preference and a subtle consolidation bonus.\n    Prioritizes filling bins completely, then minimizing waste, then consolidating.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for calculating fullness.\n    BIN_CAPACITY = 1.0 \n    \n    # Overwhelming bonus for exact fits, making them top priority regardless of other factors.\n    # This value is significantly high to ensure dominance as per \"Analyze & experience\".\n    EXACT_FIT_BONUS = 1e6 \n    \n    # Small additive factor for the consolidation bonus, ensuring it subtly promotes\n    # using existing, partially-filled bins without overriding Best Fit or Exact Fit.\n    CONSOLIDATION_STRENGTH = 0.001 \n\n    # Epsilon for robust floating-point comparisons, to handle near-zero or near-full conditions.\n    EPSILON = np.finfo(float).eps * 100 \n\n    # Calculate potential remaining space in each bin after hypothetically placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (remaining space must be non-negative or very close to zero).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # Adjust potential remaining space to be exactly non-negative for consistent scoring.\n    # This handles tiny negative values due to floating-point precision errors.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score (Best Fit): Prioritize bins that will have the least remaining space.\n    # A smaller remaining space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Overwhelming Exact Fit Bonus: Add a large bonus to bins that become perfectly full.\n    # This bonus ensures that exact fits are chosen above all other considerations.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 3. Apply Subtle Consolidation Bonus:\n    # Promote usage of existing, partially-filled bins by giving a small bonus\n    # proportional to their current fullness. This applies only to:\n    # - Bins that can fit the item.\n    # - Bins that are NOT exact fits (exact fits are handled by the dominant bonus).\n    # - Bins that are NOT completely empty (encouraging filling existing bins rather than new ones).\n    \n    # Identify bins that are completely empty.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    \n    # Create a mask for bins eligible for this consolidation bonus.\n    eligible_for_consolidation_bonus_mask = can_fit_mask & ~exact_fit_mask & ~is_empty_bin_mask\n\n    if np.any(eligible_for_consolidation_bonus_mask):\n        # Calculate the current fullness for eligible bins (0 for empty, 1 for full).\n        current_fullness_eligible = (BIN_CAPACITY - bins_remain_cap[eligible_for_consolidation_bonus_mask]) / BIN_CAPACITY\n        \n        # Add a subtle bonus proportional to current fullness, encouraging consolidation.\n        priorities[eligible_for_consolidation_bonus_mask] += CONSOLIDATION_STRENGTH * current_fullness_eligible\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines linear Best Fit with a minor additive bonus for fuller bins, and a dominant score for perfect fits,\n    prioritizing immediate waste minimization and bin closure.\n    \"\"\"\n    # Initialize all priorities to negative infinity, marking unavailable bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate potential remaining space for fitting bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Numerical stability epsilon.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Linear scoring for minimal remaining space.\n    # A smaller (closer to zero) potential_remaining_space results in a higher (less negative) score,\n    # prioritizing the tightest fits.\n    best_fit_scores = -potential_remaining_space\n\n    # Additive Consolidation Bias Component: Small bonus for already fuller bins.\n    # By using the inverse of remaining capacity, fuller bins (smaller remaining capacity)\n    # receive a higher bonus. The weight ensures this is a minor adjustment.\n    CONSOLIDATION_BIAS_WEIGHT = 0.005  # Reduced weight compared to v0 for subtle influence\n    consolidation_bonus = CONSOLIDATION_BIAS_WEIGHT / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n    # Combine the linear Best Fit score with the additive consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    PERFECT_FIT_SCORE = 1e30  # A very high score to ensure perfect fits are chosen.\n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to perfect fit bins, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using Best Fit with a dominant exact fit bonus and a subtle\n    consolidation preference. Employs robust fixed scoring and finite low priority for unfit bins.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n\n    # Initialize all priorities to a very low, but finite, number.\n    # This ensures bins that cannot fit the item receive a clearly lower priority\n    # than any fitting bin, aligning with robust numerical practices.\n    LOW_PRIORITY_FOR_UNFIT = -1e18 # Sufficiently low to be less than any possible valid Best Fit score.\n    priorities = np.full(num_bins, LOW_PRIORITY_FOR_UNFIT, dtype=float)\n\n    # Assume a standard bin capacity for common normalization in BPP.\n    BIN_CAPACITY = 1.0\n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to a very high value to ensure exact fits are chosen first,\n    # as this is critical for minimizing bin count.\n    PERFECT_FIT_BONUS = 1e9\n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing,\n    # partially filled bins, promoting consolidation without overcomplicating.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons, handling minor inaccuracies.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item in each bin.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    # This prevents negative scores from floating-point errors for near-perfect fits.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    # Scores are only applied to bins that can fit the item.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is considered a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty (new),\n    # and are not perfect fits (already handled by a much higher bonus).\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\n# Assume a global BIN_CAPACITY for context. This is typical in Bin Packing Problem (BPP)\n# where items and bin capacities are often normalized, e.g., to 1.0.\nBIN_CAPACITY = 1.0\n\n# Define heuristic parameters for strategic adjustments.\n# These values are empirical and might require tuning for specific problem distributions.\n\n# EPSILON_CLOSE_TO_ZERO: Tolerance for floating-point comparisons to detect \"exact\" fits.\n# Essential for numerical robustness in comparisons with zero.\nEPSILON_CLOSE_TO_ZERO = 1e-6\n\n# CONSOLIDATION_BONUS: A fixed additive bonus for placing an item into a bin\n# that is already partially filled. This encourages consolidating items into\n# existing bins rather than opening new ones, promoting better bin utilization.\n# This value should be positive but significantly smaller than the exact fit bonus.\nCONSOLIDATION_BONUS = 0.1 # A moderate, fixed bonus value.\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with an overwhelming exact fit preference and a consolidation bonus.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # We allow for very small negative remaining space due to floating point inaccuracies,\n    # treating them as effectively zero.\n    can_fit_mask = potential_remaining_space >= -EPSILON_CLOSE_TO_ZERO\n\n    # If no bin can fit the item, return the priorities as they are (all -inf).\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Extract the potential remaining space for only the bins where the item can fit.\n    fitting_rem_space = potential_remaining_space[can_fit_mask]\n    # Also get the original remaining capacity for these bins to identify partially filled ones.\n    fitting_bins_remain_cap_orig = bins_remain_cap[can_fit_mask]\n\n    # --- Step 1: Base Priority (Best Fit logic) ---\n    # The base priority is the negative of the potential remaining space.\n    # This means a smaller remaining space (closer to zero) results in a\n    # higher (less negative or zero) priority score. A perfect fit (0 remaining space)\n    # gets a base score of 0, which is the highest possible \"default\" score for non-bonused bins.\n    current_priorities_for_fit_bins = -fitting_rem_space\n\n    # --- Step 2: Strategic Additive Adjustments ---\n\n    # 2.1. Overwhelming Priority for Exact/Near-Exact Fits:\n    # Identify bins where the item perfectly or very nearly perfectly fills the bin.\n    # Assign them an extremely high, distinct priority to ensure they are always chosen\n    # if available, as this represents maximal bin utilization and closes a bin efficiently.\n    is_exact_or_near_fit = np.abs(fitting_rem_space) < EPSILON_CLOSE_TO_ZERO\n    current_priorities_for_fit_bins[is_exact_or_near_fit] = np.finfo(float).max / 2.0\n\n    # 2.2. Consolidation Bonus:\n    # For bins that are NOT exact fits, apply a bonus if they are already partially\n    # filled (i.e., not completely empty at the start). This encourages placing items\n    # into bins that are already in use, rather than opening new ones, thereby\n    # consolidating items and reducing the total number of bins used.\n    # We apply this bonus only to bins that are not already exact fits, as exact fits\n    # already have the highest priority.\n    non_exact_mask = ~is_exact_or_near_fit\n    \n    # A bin is considered 'partially filled' if its original remaining capacity\n    # is less than the full BIN_CAPACITY (allowing for epsilon to account for\n    # small floating point differences from initial fill). This identifies bins\n    # that are not 'freshly opened' or completely empty.\n    is_partially_filled_before_placement = fitting_bins_remain_cap_orig < (BIN_CAPACITY - EPSILON_CLOSE_TO_ZERO)\n\n    # Apply the consolidation bonus to fitting, non-exact-fit, and already partially-filled bins.\n    apply_consolidation_bonus_mask = non_exact_mask & is_partially_filled_before_placement\n    current_priorities_for_fit_bins[apply_consolidation_bonus_mask] += CONSOLIDATION_BONUS\n\n    # Assign the calculated priorities for fitting bins back into the main priorities array.\n    priorities[can_fit_mask] = current_priorities_for_fit_bins\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines linear Best Fit with a linear consolidation bias and dominant perfect fit.\n    Prioritizes tightest fits while encouraging use of fuller bins.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Extract relevant data for bins that can fit the item.\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Potential remaining space if the item were placed in fit-capable bins.\n    potential_remaining_space = fitting_bins_remain_cap - item\n\n    # Core Best Fit Component: Assign priority linearly as the negative of potential remaining space.\n    # This ensures that smaller remaining space (tighter fit) results in a higher score.\n    # A perfect fit (0 remaining) gets a score of 0.\n    best_fit_scores = -potential_remaining_space\n\n    # Linear Consolidation Bias Component: Promote packing into already fuller bins.\n    # A smaller bins_remain_cap (fuller bin) leads to a larger (less negative) bonus score,\n    # thereby giving a higher additive bonus.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05 \n    consolidation_bonus = -fitting_bins_remain_cap * CONSOLIDATION_BIAS_WEIGHT\n\n    # Combine the linear Best Fit score with the linear consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using enhanced Best Fit, strongly favoring exact fits and\n    consolidating into partially-filled bins for high utilization.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for normalization.\n    BIN_CAPACITY = 1.0 \n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to an extremely high value to ensure exact fits are chosen first,\n    # as indicated by analysis as the most critical performance factor.\n    PERFECT_FIT_BONUS = 1e15 \n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing,\n    # partially-filled bins, promoting consolidation.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    # This directly minimizes wasted space within a bin.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty, and are not perfect fits.\n    # This adheres to the analysis's preference for simple, fixed additive consolidation bonuses.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes linear tight fits (Best Fit) and exact fits. Adds a fixed\n    bonus to non-perfectly-filling bins to encourage consolidation into existing bins.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Small epsilon for numerical stability for near-zero comparisons.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the negative of potential remaining space.\n    # This linearly favors bins that result in minimal remaining space (tightest fit),\n    # as smaller (closer to zero or less negative) 'potential_remaining_space' yields a higher score.\n    best_fit_scores = -potential_remaining_space\n\n    # Fixed Additive Consolidation Bonus: Encourage filling existing, non-perfectly-fitting bins.\n    # This fixed bonus shifts up the score of any bin that can fit the item but won't be a perfect fit.\n    # It promotes using partially filled bins before opening new ones (if no perfect fit exists).\n    CONSOLIDATION_FIXED_BONUS = 0.1 \n\n    # Identify bins that can fit the item but are not a perfect/near-perfect fit.\n    non_perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) >= 1e-9 # Use a small tolerance\n\n    # Apply the fixed consolidation bonus to these bins.\n    best_fit_scores[non_perfect_fit_mask_in_fitting] += CONSOLIDATION_FIXED_BONUS\n    \n    # Assign the calculated scores to the fitting bins in the main priorities array.\n    priorities[can_fit_mask] = best_fit_scores\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit heuristic with a strong bonus for exact fits, minimizing wasted space.\n    Prioritizes bins that will have minimal remaining capacity after placement,\n    with an overwhelming preference for bins that become perfectly full.\n    \"\"\"\n    # Initialize all priorities to a very low value. Bins that cannot fit the item\n    # will retain this lowest priority, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining space in bins where the item can fit.\n    # This is the core of the Best Fit strategy: find the bin that leaves the least space.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # The base priority for fitting bins is the negative of the potential remaining space.\n    # A smaller remaining space (closer to zero) results in a higher (less negative) priority.\n    priorities[can_fit_mask] = -potential_remaining_space\n\n    # Define constants for bonuses, based on the analysis emphasizing their importance.\n    # EPSILON for robust floating-point comparison of exact fits.\n    EPSILON = 1e-9\n    # PERFECT_FIT_BONUS is a very large additive bonus to ensure exact fits\n    # (or near-exact fits) are always chosen above any other option.\n    PERFECT_FIT_BONUS = 1e9\n\n    # Identify bins that would result in a perfect or near-perfect fit.\n    # This checks if the potential remaining space is negligibly close to zero.\n    exact_fit_mask = can_fit_mask & (np.abs(potential_remaining_space) < EPSILON)\n\n    # Apply the overwhelming bonus to exact fit bins.\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by Best Fit, with a strong bonus for exact fits and a minor bonus for consolidating partially-filled bins.\"\"\"\n\n    # Constants derived from analysis: very high bonus for exact fits, small bonus for consolidation.\n    # Assumes a standard bin capacity of 1.0 for identifying \"partially-filled\" bins.\n    BIN_CAPACITY = 1.0\n    PERFECT_FIT_BONUS = 1000.0\n    CONSOLIDATION_BONUS = 1.0\n\n    # Calculate remaining space if item were placed (Best Fit core).\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities. Bins that cannot fit the item get the lowest possible score.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Base priority: negative of potential remaining space (Best Fit).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    # Add a substantial bonus for exact fits.\n    exact_fit_mask = np.isclose(potential_remaining_space, 0.0) & can_fit_mask\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # Add a small, fixed bonus for placing items into already partially-filled bins.\n    # This encourages consolidation without being overly complex or dominant.\n    # A bin is considered partially-filled if its current remaining capacity is less than BIN_CAPACITY\n    # (meaning it's not a brand new empty bin) but greater than zero.\n    partially_filled_mask = (bins_remain_cap < BIN_CAPACITY) & (bins_remain_cap > 0) & can_fit_mask\n    priorities[partially_filled_mask] += CONSOLIDATION_BONUS\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a Best Fit\n    strategy with a significant, fixed bonus for perfect fits.\n\n    This heuristic is a mutation of priority_v1. It enhances the Best Fit strategy by\n    applying a substantial, fixed additive adjustment to the priority of bins that result\n    in a perfect fit (zero remaining capacity). This ensures that perfect fits are\n    unequivocally prioritized above any non-perfect fit, regardless of how small the\n    remaining capacity might be in other bins. For non-perfect fits, it retains the\n    original Best Fit preference (minimizing remaining space), but ensures its scores\n    are always strictly less than a perfect fit's score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Perfect fits receive a high fixed score. Other fits receive a score based on\n        the negative of their remaining space. Bins that cannot fit the item receive -inf.\n    \"\"\"\n    # Calculate the potential remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Define a significant fixed bonus for perfect fits.\n    # This value is chosen to be strictly greater than the maximum possible score\n    # achievable by any non-perfect fit. Assuming normalized bin capacities (e.g., 0 to 1),\n    # -potential_remaining_space for non-perfect fits ranges from slightly below 0 down to -1.\n    # A value like 1.0 or 100.0 ensures perfect fits are clearly superior.\n    PERFECT_FIT_BONUS = 100.0\n\n    # Create masks for different categories of bins\n    can_fit_mask = potential_remaining_space >= 0\n    perfect_fit_mask = (potential_remaining_space == 0)\n    \n    # Identify bins where the item can fit but NOT perfectly.\n    # This is equivalent to `can_fit_mask` AND `NOT perfect_fit_mask`\n    non_perfect_fit_mask = can_fit_mask & (~perfect_fit_mask)\n\n    # Assign priority for bins where the item fits but not perfectly.\n    # This part retains the core Best Fit logic from priority_v1:\n    # a smaller positive remaining space yields a higher (less negative) priority.\n    # These scores will always be <= 0 (e.g., 0.0 for near-perfect, -0.5 for half-empty).\n    priorities[non_perfect_fit_mask] = -potential_remaining_space[non_perfect_fit_mask]\n\n    # Apply the fixed, additive adjustment for perfect fits.\n    # These bins will receive a substantially higher score than any non-perfect fit,\n    # making them the absolute top priority if available.\n    priorities[perfect_fit_mask] = PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response1.txt_stdout.txt",
    "code_path": "problem_iter15_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a Best Fit\n    strategy with a strong, fixed preference for perfect fits.\n\n    This heuristic aims to select the bin that will have the least remaining capacity\n    after the item is placed (Best Fit principle, minimizing immediate waste).\n    Crucially, it applies a significant, fixed additive bonus to bins where the item\n    perfectly fills the bin, ensuring these are always chosen over any non-perfect fit,\n    regardless of how close the non-perfect fit might be.\n    Bins that cannot accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit receives a large positive bonus,\n        while bins that cannot fit the item get -inf.\n    \"\"\"\n    # Define a fixed, additive bonus for a perfect fit.\n    # This value must be sufficiently large to ensure that a perfect fit\n    # always outranks any non-perfect fit. If item sizes and bin capacities\n    # are typically normalized to 1.0, a bonus of 2.0 (or anything > 1.0)\n    # guarantees this, as the Best Fit score (negative remaining space)\n    # is typically between -1.0 and 0.0.\n    BONUS_PERFECT_FIT = 2.0\n\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the negative\n    # of the potential remaining space. This implements the Best Fit strategy:\n    # maximizing this value means minimizing the remaining space.\n    # A smaller positive potential_remaining_space results in a higher (less negative) priority.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    # Identify bins where a perfect fit occurs. Use np.isclose for robust floating-point comparison.\n    # The `atol` (absolute tolerance) ensures that small floating point inaccuracies don't prevent\n    # a near-perfect fit from being recognized as a perfect one.\n    perfect_fit_mask = np.isclose(potential_remaining_space, 0.0, atol=1e-9)\n\n    # Apply the fixed bonus to bins that are both a perfect fit AND capable of fitting the item.\n    # The 'and can_fit_mask' part is crucial to avoid applying a bonus if, due to floating point\n    # precision, a negative remaining capacity (meaning item does not fit) is very close to zero.\n    priorities[perfect_fit_mask & can_fit_mask] += BONUS_PERFECT_FIT\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response2.txt_stdout.txt",
    "code_path": "problem_iter15_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    mutating priority_v1 to strongly favor perfect fits with a fixed bonus.\n\n    This heuristic aims to select the bin that will have the least remaining capacity\n    after the item is placed (Best Fit), but gives a significant, fixed additive bonus\n    to bins that achieve a perfect fit (remaining capacity = 0).\n    Bins that cannot accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit gets the highest possible score,\n        while bins that cannot fit the item get -inf.\n    \"\"\"\n    # A small epsilon for floating point comparisons to identify 'perfect fits'\n    EPSILON = 1e-9 \n\n    # A fixed bonus for a perfect fit. This value must be significantly larger\n    # than any possible negative score from non-perfect fits (which range from -1 to 0).\n    PERFECT_FIT_BONUS = 1.0 \n\n    potential_remaining_space = bins_remain_cap - item\n\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit. We use -EPSILON to account for\n    # minor floating point inaccuracies that might make a valid fit appear slightly negative.\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # Assign base priority using the Best Fit logic: maximize -potential_remaining_space,\n    # effectively minimizing the remaining space.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    # Identify true perfect fit bins using a precise epsilon comparison.\n    # Only bins where the remaining space is very close to zero get this bonus.\n    perfect_fit_mask = np.isclose(potential_remaining_space, 0, atol=EPSILON)\n\n    # Apply the fixed bonus to perfect fit bins. This ensures that any perfect fit\n    # is prioritized above all non-perfect fits, as its score will be positive.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response3.txt_stdout.txt",
    "code_path": "problem_iter15_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing Best Fit with a strong Perfect Fit bias.\n\n    This heuristic prioritizes bins that achieve a perfect fit for the item. If no perfect\n    fit is available, it defaults to a Best Fit strategy, selecting the bin that will\n    have the least remaining capacity after the item is placed. Bins that cannot\n    accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit gets a significantly higher\n        fixed bonus, ensuring it's always preferred over any non-perfect fit.\n        Bins that cannot fit the item get -inf.\n    \"\"\"\n    # Define a fixed, large bonus for perfect fits. This value should be chosen\n    # to be greater than the absolute maximum possible score obtained from a non-perfect fit.\n    # In the Best Fit strategy, non-perfect fit scores range from -(MaxBinCapacity - Item) to just below 0.\n    # For common bin capacities (e.g., 1.0), this range is typically [-1.0, 0).\n    # A bonus of 1.0 (or higher) ensures that a perfect fit (score 0 + bonus) will always\n    # outscore any non-perfect fit (score < 0).\n    PERFECT_FIT_SCORE_BOOST = 1.0\n\n    # Calculate the remaining space in each bin if the item were placed.\n    # A smaller positive value here means a \"better fit\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the negative\n    # of the potential remaining space. This implements the core Best Fit strategy.\n    # By maximizing this value, we are effectively minimizing the potential remaining space.\n    # A larger remaining space (e.g., 0.5) will result in a lower priority (-0.5),\n    # while a very tight fit (e.g., 0.01 remaining) gets a priority closer to 0 (-0.01).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    # Identify bins that result in a perfect fit (remaining space is exactly 0).\n    # This comparison assumes floating point equality to zero is sufficient for perfect fit.\n    perfect_fit_mask = potential_remaining_space == 0\n\n    # Apply a fixed, additive bonus to the priority of bins that achieve a perfect fit.\n    # This ensures that any bin offering a perfect fit will always have a higher\n    # priority than any bin offering a non-perfect fit, regardless of how small\n    # the remaining space is in the non-perfect fit bin.\n    priorities[perfect_fit_mask] += PERFECT_FIT_SCORE_BOOST\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response4.txt_stdout.txt",
    "code_path": "problem_iter15_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, enhancing Best Fit with a strong perfect-fit bonus.\n\n    This heuristic prioritizes selecting the bin that results in the least remaining capacity\n    after the item is placed (Best Fit principle), which directly aligns with waste minimization.\n    Crucially, it applies a significant, fixed additive bonus to bins that achieve a perfect fit\n    (where the remaining capacity becomes exactly zero), making them the absolute highest priority\n    choice. Bins that cannot accommodate the item receive the lowest possible priority.\n\n    This design emphasizes direct, greedy choices and simplicity, focusing on immediate optimal\n    outcomes (filling a bin as much as possible, or perfectly).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit gets a large positive bonus,\n        other valid fits get scores based on negative remaining space, and\n        bins that cannot fit the item get -inf.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a base priority based on the negative\n    # of the potential remaining space. This implements the Best Fit principle:\n    # minimizing remaining space (making -potential_remaining_space as high as possible).\n    # A smaller positive remaining space (e.g., 0.1) results in a priority of -0.1.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    # --- Apply a fixed, additive bonus for perfect fits ---\n    # Identify bins where the item fits perfectly, leaving exactly 0 remaining capacity.\n    # This is a direct, simple outcome.\n    perfect_fit_mask = potential_remaining_space == 0.0\n\n    # Define a large, fixed constant bonus for perfect fits. This makes a perfect fit\n    # overwhelmingly more desirable than any other fit, including very tight ones.\n    # The value should be large enough to ensure it's always higher than any non-perfect fit score.\n    # (Assuming bin capacities are within a reasonable range, e.g., max 1.0, 1000.0 is sufficiently large)\n    PERFECT_FIT_BONUS = 1000.0\n\n    # Add the bonus to the priorities of perfect fit bins.\n    # Since their base priority from -potential_remaining_space was 0.0, this sets their\n    # final priority to PERFECT_FIT_BONUS.\n    priorities[perfect_fit_mask] = PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]