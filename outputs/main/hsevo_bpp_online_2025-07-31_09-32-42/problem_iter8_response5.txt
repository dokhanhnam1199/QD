```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:
    """
    Adaptive Hybrid Heuristic: Combines robust best-fit, explicit perfect-fit,
    and consolidation bias, scaled for problem awareness.
    """
    # Initialize all priorities to negative infinity. Bins unable to fit are disqualified.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can be placed.
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit, return the initialized (all -inf) priorities.
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the potential remaining space (waste) in suitable bins after placing the item.
    potential_waste = bins_remain_cap[can_fit_mask] - item

    # --- Problem-aware constants for numerical stability and scaling ---
    # EPSILON: A small value for numerical stability in inverse calculations, scaled by bin_capacity
    # to maintain relative precision across different bin sizes.
    EPSILON = np.finfo(float).eps * bin_capacity 
    if EPSILON == 0.0: # Safeguard for very small bin_capacity values
        EPSILON = np.finfo(float).eps

    # PERFECT_FIT_TOLERANCE: Tolerance for identifying "perfect fits" to account for
    # floating-point inaccuracies, scaled by bin_capacity.
    PERFECT_FIT_TOLERANCE = 1e-9 * bin_capacity 

    # PERFECT_FIT_SCORE: A very high score for perfect fits, scaled by bin_capacity
    # to ensure they are overwhelmingly prioritized regardless of problem scale.
    PERFECT_FIT_SCORE = 1e6 * bin_capacity 

    # CONSOLIDATION_FACTOR: Weight for the consolidation bonus. This additive factor
    # encourages selecting already fuller bins, promoting their closure.
    CONSOLIDATION_FACTOR = 0.1 

    # --- Assign priorities based on fit characteristics ---

    # 1. Prioritize perfect fits (waste is zero or very close to zero).
    perfect_fit_mask = np.isclose(potential_waste, 0, atol=PERFECT_FIT_TOLERANCE)
    priorities[can_fit_mask][perfect_fit_mask] = PERFECT_FIT_SCORE

    # 2. For non-perfect fits (some waste remains), use a combined score.
    non_perfect_fit_mask = ~perfect_fit_mask 

    if np.any(non_perfect_fit_mask):
        # Extract waste for only the non-perfect fitting bins.
        current_potential_waste = potential_waste[non_perfect_fit_mask]

        # Primary score: Inverse of waste. This strongly rewards tighter fits
        # by making smaller wastes result in disproportionately higher scores.
        best_fit_score = 1.0 / (current_potential_waste + EPSILON)

        # Secondary score: Bonus based on the bin's current fullness (before placing item).
        # This is normalized (0 to 1) and encourages selecting bins closer to full.
        current_fullness = (bin_capacity - bins_remain_cap[can_fit_mask][non_perfect_fit_mask]) / bin_capacity

        # Additive consolidation bonus.
        consolidation_bonus = CONSOLIDATION_FACTOR * current_fullness

        # Combine the scores. Best Fit is dominant, but fuller bins get a slight edge.
        priorities[can_fit_mask][non_perfect_fit_mask] = best_fit_score + consolidation_bonus

    return priorities
```
