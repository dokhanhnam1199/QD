```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes inverse waste for tight fits, with a subtle bonus for
    bins already fuller. Uses machine epsilon for stability.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity (waste) if the item is placed.
    remaining_waste = bins_remain_cap[can_fit_mask] - item

    # Use machine epsilon for robust numerical stability, as recommended by analysis.
    epsilon = np.finfo(float).eps

    # Core Best Fit (BF) priority: Inverse of (remaining_waste + epsilon).
    # This provides a strong non-linear preference for perfect or very tight fits,
    # consistent with the top-performing 'priority_v0' heuristic.
    base_priority = 1.0 / (remaining_waste + epsilon)

    # Adaptive / Global Utility Element:
    # Introduce a subtle bonus for bins that are already more full (have less remaining capacity).
    # This element aligns with "Adaptive Logic" and "Global Utility" advice by encouraging
    # the closing of already utilized bins. It acts as a weighted tie-breaker or minor nudge
    # when the primary Best Fit scores are very close.
    # We assume a normalized bin capacity of 1.0, where `1.0 - bins_remain_cap` represents
    # the portion of the bin that is already filled.
    WEIGHT_FULLNESS_BONUS = 1e-7 # A small, tunable weight chosen to ensure this bonus
                                 # is secondary and does not override the primary
                                 # waste minimization unless scores are extremely close.

    current_fullness = 1.0 - bins_remain_cap[can_fit_mask]
    
    fullness_bonus = WEIGHT_FULLNESS_BONUS * current_fullness
    
    # Combine the dominant Best Fit priority with the subtle fullness bonus.
    priorities[can_fit_mask] = base_priority + fullness_bonus

    return priorities
```
