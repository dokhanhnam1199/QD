```python
import numpy as np

# Assume a global BIN_CAPACITY for context. This is typical in Bin Packing Problem (BPP)
# where items and bin capacities are often normalized, e.g., to 1.0.
# The thresholds below are defined relative to this capacity.
BIN_CAPACITY = 1.0

# Define heuristic parameters for strategic adjustments.
# These values are empirical and might require tuning for specific problem distributions.

# EPSILON_CLOSE_TO_ZERO: Tolerance for floating-point comparisons to detect "exact" fits.
EPSILON_CLOSE_TO_ZERO = 1e-6

# FRAGMENTATION_LOW_THRESHOLD & FRAGMENTATION_HIGH_THRESHOLD:
# Define a range for "fragmented" gaps. These are remaining capacities that are
# too small to be widely useful for future items, but not small enough to be
# considered a "perfect fit". Placing an item here might lead to wasted space.
FRAGMENTATION_LOW_THRESHOLD = 0.05 * BIN_CAPACITY  # e.g., 5% of bin capacity
FRAGMENTATION_HIGH_THRESHOLD = 0.20 * BIN_CAPACITY # e.g., 20% of bin capacity

# FRAGMENTATION_PENALTY: The amount by which to reduce the priority for creating
# a fragmented gap. A higher value makes fragmented gaps significantly less desirable.
# This value is relative to the base Best Fit score (which is typically small negative numbers).
FRAGMENTATION_PENALTY = 0.5

# LARGE_GAP_THRESHOLD: Defines a threshold for what's considered a "large" remaining gap.
# If no tight fit is available, leaving a large gap might be strategically beneficial
# to accommodate larger future items, thus keeping the bin "open".
LARGE_GAP_THRESHOLD = 0.50 * BIN_CAPACITY # e.g., 50% of bin capacity

# LARGE_GAP_BONUS: The amount by which to increase the priority for leaving a large gap.
# This bonus should be small enough not to override truly tight fits, but
# sufficient to make large gaps slightly more attractive than medium-sized,
# potentially fragmented ones, when no tight fit is an option.
LARGE_GAP_BONUS = 0.1

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns a priority score for placing an item in each bin, enhancing the
    Best Fit (BF) heuristic with strategic considerations for bin consolidation,
    fragmentation avoidance, and maintaining bin utility.

    This heuristic aims to:
    1.  **Strongly Prioritize Exact Fits:** Always choose a bin that can be
        perfectly (or near-perfectly) filled by the item, ensuring maximum bin utilization.
    2.  **Discourage Fragmentation:** Penalize bins that would result in a
        small, potentially unusable "fragmented" remaining capacity after placement.
        This encourages filling bins more completely or leaving larger, more useful gaps.
    3.  **Encourage Large Usable Gaps (Strategic Worst Fit):** If no tight fit is
        available, slightly prefer bins that leave a substantial remaining capacity.
        This keeps bins strategically "open" to accommodate larger future items,
        reducing the chance of using many bins with small, varied, and hard-to-fill gaps.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: A NumPy array containing the remaining capacity of each bin.

    Return:
        A NumPy array of the same size as `bins_remain_cap`, with a priority score
        for each bin. A higher score indicates a higher priority for placing the
        item in that bin. Bins that cannot accommodate the item receive -infinity.
    """
    # Calculate the remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    # We allow for very small negative remaining space due to floating point inaccuracies,
    # treating them as effectively zero.
    can_fit_mask = potential_remaining_space >= -EPSILON_CLOSE_TO_ZERO

    # Extract the potential remaining space for only the bins where the item can fit.
    fitting_rem_space = potential_remaining_space[can_fit_mask]

    # --- Step 1: Base Priority (Best Fit logic) ---
    # The base priority is the negative of the potential remaining space.
    # This means a smaller remaining space (closer to zero) results in a
    # higher (less negative or zero) priority score.
    # A perfect fit (0 remaining space) gets a base score of 0.
    current_priorities_for_fit_bins = -fitting_rem_space

    # --- Step 2: Strategic Adjustments ---

    # 2.1. Very High Priority for Exact/Near-Exact Fits:
    # Identify bins where the item perfectly or very nearly perfectly fills the bin.
    # Assign them an extremely high, distinct priority to ensure they are always chosen if available.
    is_exact_or_near_fit = np.abs(fitting_rem_space) < EPSILON_CLOSE_TO_ZERO
    current_priorities_for_fit_bins[is_exact_or_near_fit] = np.finfo(float).max / 2.0 # Use a very large float value

    # For subsequent adjustments, we only consider bins that are not an exact fit,
    # as their priority has already been set to the highest possible value.
    non_exact_mask = ~is_exact_or_near_fit

    # 2.2. Penalty for Fragmented Gaps:
    # Identify bins that, if chosen, would result in a remaining capacity falling
    # within the "fragmentation zone" (e.g., too small to be useful for many items,
    # but not a perfect fit). Reduce their priority to discourage their selection.
    is_fragmented_zone_gap = (fitting_rem_space > FRAGMENTATION_LOW_THRESHOLD) & \
                             (fitting_rem_space < FRAGMENTATION_HIGH_THRESHOLD) & \
                             non_exact_mask
    current_priorities_for_fit_bins[is_fragmented_zone_gap] -= FRAGMENTATION_PENALTY

    # 2.3. Bonus for Large Usable Gaps:
    # Identify bins that, if chosen, would leave a large remaining capacity.
    # If no exact or very tight fit is available, it might be strategically better
    # to leave a large, reusable space rather than a fragmented one. This applies
    # a small bonus to make these bins slightly more attractive among non-tight options.
    is_large_usable_gap = (fitting_rem_space >= LARGE_GAP_THRESHOLD) & \
                          non_exact_mask
    current_priorities_for_fit_bins[is_large_usable_gap] += LARGE_GAP_BONUS

    # Assign the calculated priorities for fitting bins back into the main priorities array.
    priorities[can_fit_mask] = current_priorities_for_fit_bins

    return priorities
```
