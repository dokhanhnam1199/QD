```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid Best Fit with explicit Perfect Fit priority and adaptive bin consolidation.
    Combines inverse waste minimization with a multiplicative bonus for bin fullness,
    while ensuring perfect fits are chosen first.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Mask for bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return priorities as is (-inf for all).
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the remaining capacity (waste) if the item is placed.
    # Only for bins that can fit the item.
    current_bins_remain_cap = bins_remain_cap[can_fit_mask]
    potential_remaining_waste = current_bins_remain_cap - item

    # Constants for heuristic scoring
    # A very high score to ensure perfect fits are chosen over any other option.
    PERFECT_FIT_SCORE = 1e12
    # A small tolerance for robust floating-point comparison to identify perfect fits.
    # Using an absolute tolerance suitable for general floating-point comparisons.
    PERFECT_FIT_TOLERANCE = 1e-9
    # Epsilon for numerical stability, preventing division by zero, especially for small waste or remaining capacity.
    STABILITY_EPSILON = np.finfo(float).eps
    # Weighting factor for the bin fullness bonus.
    # A small alpha ensures that the primary Best Fit (waste minimization) remains dominant,
    # but the fullness component provides a subtle, adaptive influence towards bin closure.
    ALPHA_FULLNESS_BONUS = 0.01

    # 1. Apply Perfect Fit Bonus: Identify and highly prioritize near-perfect fits.
    # These are cases where potential_remaining_waste is very close to zero.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_waste) < PERFECT_FIT_TOLERANCE
    
    # Assign the high perfect fit score to the corresponding bins.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    # 2. For non-perfect fits, apply a hybrid Best Fit strategy with a fullness bonus.
    non_perfect_fit_mask_in_fitting = ~perfect_fit_mask_in_fitting
    
    # Select the relevant subsets for non-perfect fits.
    non_perfect_waste = potential_remaining_waste[non_perfect_fit_mask_in_fitting]
    non_perfect_bins_remain_cap = current_bins_remain_cap[non_perfect_fit_mask_in_fitting]

    # Calculate the primary Best Fit component: Inverse of (waste + epsilon).
    # This gives disproportionately high scores to tighter fits.
    best_fit_score = 1.0 / (non_perfect_waste + STABILITY_EPSILON)

    # Calculate the Bin Fullness component: Inverse of (bins_remain_cap + epsilon).
    # This term gives higher scores to bins that are already more full (smaller bins_remain_cap).
    # It acts as a bias towards closing bins.
    bin_fullness_score = 1.0 / (non_perfect_bins_remain_cap + STABILITY_EPSILON)

    # Combine: Multiply the best-fit score by a factor that increases with bin fullness.
    # The '1.0 + ALPHA_FULLNESS_BONUS * ...' ensures the base best_fit_score is always present
    # and is only amplified by the fullness, not replaced. This hybrid approach
    # aims for immediate efficiency (Best Fit) while adaptively guiding towards bin closure.
    combined_score = best_fit_score * (1.0 + ALPHA_FULLNESS_BONUS * bin_fullness_score)

    # Assign the combined scores to the non-perfect fitting bins.
    priorities[can_fit_mask][non_perfect_fit_mask_in_fitting] = combined_score

    return priorities
```
