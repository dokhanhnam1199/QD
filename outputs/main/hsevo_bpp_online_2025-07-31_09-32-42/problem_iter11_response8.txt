```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes tight fits (Best Fit) and perfect fits, with an additive bonus
    for bins that are already fuller, promoting efficient bin closure.
    """
    # Initialize all priorities to negative infinity, unequivocally marking bins
    # that cannot accommodate the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return the initialized priorities.
    if not np.any(can_fit_mask):
        return priorities

    # Potential remaining space (waste) if the item were placed in fit-capable bins.
    potential_remaining_space = bins_remain_cap[can_fit_mask] - item

    # Small epsilon for numerical stability, especially for near-zero remaining space.
    EPSILON = np.finfo(float).eps

    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).
    # This strongly favors bins that result in minimal remaining space (tightest fit).
    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)

    # Additive Consolidation Bias Component: Promote packing into already fuller bins.
    # Based on analysis, a bonus directly related to individual bin fullness is preferred.
    # A smaller bins_remain_cap (fuller bin) results in a higher inverse value,
    # thereby giving a higher additive bonus.
    CONSOLIDATION_BIAS_WEIGHT = 0.05
    consolidation_bonus = 1.0 / (bins_remain_cap[can_fit_mask] + EPSILON)

    # Combine the Best Fit score with the additive consolidation bias.
    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * consolidation_bonus

    # Explicitly boost perfect fits to ensure their absolute priority.
    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.
    PERFECT_FIT_TOLERANCE = 1e-9
    # A very high score to ensure perfect fits are chosen over any other option.
    PERFECT_FIT_SCORE = 1e30 

    # Identify perfect or near-perfect fits within the fitting bins.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE

    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    return priorities
```
