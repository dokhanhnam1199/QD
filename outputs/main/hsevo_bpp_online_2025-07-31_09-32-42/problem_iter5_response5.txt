```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Consolidation-Aware Best Fit: Prioritizes minimal waste (Best Fit) while subtly
    favoring bins that are already fuller. This encourages faster bin closure
    and more efficient bin consolidation, integrating adaptive logic.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): Remaining capacity in each bin. Assumes capacities
                                      are normalized (e.g., max capacity of 1.0).

    Returns:
        np.ndarray: Priority scores for each bin. Bins unable to fit the item get -np.inf.
    """
    # Initialize priorities to negative infinity, ensuring bins unable to fit
    # the item are unequivocally disqualified.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins have sufficient remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining space (waste) in suitable bins after placing the item.
    # A smaller waste indicates a more efficient, tighter fit.
    remaining_waste = bins_remain_cap[can_fit_mask] - item

    # Calculate the current fullness of bins that can fit the item.
    # This assumes a maximum bin capacity of 1.0 for normalized problems.
    # Higher fullness implies the bin is closer to being 'closed'.
    current_fullness = 1.0 - bins_remain_cap[can_fit_mask]

    # A small positive constant for numerical stability and to ensure a finite,
    # very high priority for perfect fits (waste = 0).
    epsilon = np.finfo(float).eps

    # Define a consolidation factor. This value is chosen to be small enough
    # to ensure the primary Best Fit term (inverse waste) remains dominant,
    # but large enough to provide a subtle preference among bins with
    # very similar waste values. It acts as an adaptive consolidation incentive.
    CONSOLIDATION_FACTOR = 0.1

    # Primary score: Inverse of waste. This strongly rewards tight fits.
    best_fit_score = 1.0 / (remaining_waste + epsilon)

    # Secondary score: Bonus for current fullness. This nudges the selection
    # towards bins that are already more filled, encouraging their closure.
    consolidation_bonus = CONSOLIDATION_FACTOR * current_fullness

    # Combine the scores. The Best Fit dominates, but bins closer to full
    # receive a slight advantage, reflecting a more global optimization strategy.
    priorities[can_fit_mask] = best_fit_score + consolidation_bonus

    return priorities
```
