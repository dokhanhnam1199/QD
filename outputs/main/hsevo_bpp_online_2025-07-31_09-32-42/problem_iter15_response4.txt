```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, enhancing Best Fit with a strong perfect-fit bonus.

    This heuristic prioritizes selecting the bin that results in the least remaining capacity
    after the item is placed (Best Fit principle), which directly aligns with waste minimization.
    Crucially, it applies a significant, fixed additive bonus to bins that achieve a perfect fit
    (where the remaining capacity becomes exactly zero), making them the absolute highest priority
    choice. Bins that cannot accommodate the item receive the lowest possible priority.

    This design emphasizes direct, greedy choices and simplicity, focusing on immediate optimal
    outcomes (filling a bin as much as possible, or perfectly).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores are designed such that a perfect fit gets a large positive bonus,
        other valid fits get scores based on negative remaining space, and
        bins that cannot fit the item get -inf.
    """
    # Calculate the remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # For bins where the item can fit, assign a base priority based on the negative
    # of the potential remaining space. This implements the Best Fit principle:
    # minimizing remaining space (making -potential_remaining_space as high as possible).
    # A smaller positive remaining space (e.g., 0.1) results in a priority of -0.1.
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    # --- Apply a fixed, additive bonus for perfect fits ---
    # Identify bins where the item fits perfectly, leaving exactly 0 remaining capacity.
    # This is a direct, simple outcome.
    perfect_fit_mask = potential_remaining_space == 0.0

    # Define a large, fixed constant bonus for perfect fits. This makes a perfect fit
    # overwhelmingly more desirable than any other fit, including very tight ones.
    # The value should be large enough to ensure it's always higher than any non-perfect fit score.
    # (Assuming bin capacities are within a reasonable range, e.g., max 1.0, 1000.0 is sufficiently large)
    PERFECT_FIT_BONUS = 1000.0

    # Add the bonus to the priorities of perfect fit bins.
    # Since their base priority from -potential_remaining_space was 0.0, this sets their
    # final priority to PERFECT_FIT_BONUS.
    priorities[perfect_fit_mask] = PERFECT_FIT_BONUS

    return priorities
```
