```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, implementing a
    relative utilization-based heuristic that encourages emergent packing behavior.

    This heuristic assigns a priority to each bin based on how much of its current
    remaining capacity the incoming item would consume. The goal is to maximize
    the 'relative utilization' for the current placement. This local rule aims to
    drive the system towards effectively filling bins. Bins that cannot accommodate
    the item receive the lowest possible priority (0.0), ensuring they are not chosen,
    without relying on specific numerical artifacts like infinity.

    Args:
        item: Size of item to be added to the bin. Assumed to be a positive float.
        bins_remain_cap: Array of current remaining capacities for each bin.
                         Assumed to contain non-negative float values.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores range from 0.0 (for non-fitting bins or bins with very large remaining
        capacity relative to the item) up to 1.0 (for a perfect fit).
    """
    # Initialize all priorities to 0.0. This value implicitly represents the
    # lowest possible priority for a valid item and will be assigned to bins
    # that cannot fit the item. This avoids reliance on -np.inf.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    # If item is positive, and bins_remain_cap is 0, this mask will correctly
    # exclude that bin, preventing division by zero.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the priority for bins where the item can fit.
    # The priority is the ratio of the item's size to the bin's remaining capacity.
    # A higher ratio indicates that the item consumes a larger proportion of the
    # available space, leading to a "tighter" relative fit.
    # This promotes the local rule of maximizing current space efficiency.
    # For a perfect fit (item == bins_remain_cap), the score will be 1.0,
    # representing the highest possible priority.
    
    # We use `np.where` for a vectorized conditional assignment.
    # For bins where `can_fit_mask` is True, we calculate `item / bins_remain_cap`.
    # For bins where `can_fit_mask` is False (item does not fit), we assign 0.0.
    # Note: `item / bins_remain_cap` for elements where `bins_remain_cap` is 0
    # and `can_fit_mask` is False will not be evaluated, thus preventing ZeroDivisionError.
    priorities = np.where(can_fit_mask, item / bins_remain_cap, 0.0)

    return priorities
```
