```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    As I, Galileo, have observed the universe, every element strives for its most
    fitting place. Thus, for our items, the most harmonious position within a bin
    is that which minimizes wasted space, much like a planet finding its precise orbit.
    This function therefore prioritizes bins that result in the smallest remaining
    capacity after accommodating the item, effectively implementing a 'Best Fit' strategy.
    A perfect fit yields the highest priority, for what could be more efficient?

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher score indicates a more desirable bin.
    """
    # Initialize priorities to zero. Bins that cannot fit the item will retain this score,
    # signifying they are not suitable candidates.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify all bins where the item can physically be placed.
    # We ignore those that are too small, for they are like attempts to place
    # a large planet into a small sphere â€“ fruitless.
    can_fit_mask = bins_remain_cap >= item

    # For those bins where the item can fit, we calculate a score.
    # The score is derived from the "tightness" of the fit: item_size / bin_capacity.
    # A score closer to 1.0 signifies a tighter fit, meaning less wasted space,
    # and thus a higher efficiency. A perfect fit (item consumes the entire remaining
    # capacity) will yield a score of 1.0, which is the utmost efficiency.
    # We only perform this calculation for the bins identified by 'can_fit_mask'.
    # If bins_remain_cap[i] is 0 and can_fit_mask[i] is True, implies item is 0,
    # in which case 0/0 is problematic. However, item size is typically positive.
    # If item > 0 and bins_remain_cap[i] == 0, can_fit_mask[i] will be False.
    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]

    return priorities
```
