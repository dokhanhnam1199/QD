```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a robust Best Fit heuristic with a strong bonus for exact fits,
    prioritizing minimal remaining capacity.
    """
    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0
    
    # Extract relevant values for bins where the item can fit.
    valid_remaining_space = potential_remaining_space[can_fit_mask]
    
    # --- Core Priority: Best Fit Principle ---
    # This component prioritizes bins that will have the least remaining space.
    # A smaller positive remaining space (closer to a perfect fit) leads to a higher
    # (less negative, closer to 0) base score. A perfect fit (0 remaining space)
    # gets a base score of 0 here.
    priorities[can_fit_mask] = -valid_remaining_space

    # --- Strategic Adjustment: Perfect Fit Bonus ---
    # Apply a large, fixed bonus to guarantee that exact fits are the highest priority.
    # This is a critical override for optimal bin packing.
    PERFECT_FIT_BONUS = 1000.0  # A sufficiently large, fixed constant
    
    perfect_fit_mask = (valid_remaining_space == 0)
    priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS

    return priorities
```
