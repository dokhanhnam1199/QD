```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by Best Fit, with a strong bonus for exact fits and a minor bonus for consolidating partially-filled bins."""

    # Constants derived from analysis: very high bonus for exact fits, small bonus for consolidation.
    # Assumes a standard bin capacity of 1.0 for identifying "partially-filled" bins.
    BIN_CAPACITY = 1.0
    PERFECT_FIT_BONUS = 1000.0
    CONSOLIDATION_BONUS = 1.0

    # Calculate remaining space if item were placed (Best Fit core).
    potential_remaining_space = bins_remain_cap - item

    # Initialize priorities. Bins that cannot fit the item get the lowest possible score.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Mask for bins where the item can fit.
    can_fit_mask = potential_remaining_space >= 0

    # Base priority: negative of potential remaining space (Best Fit).
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    # Add a substantial bonus for exact fits.
    exact_fit_mask = np.isclose(potential_remaining_space, 0.0) & can_fit_mask
    priorities[exact_fit_mask] += PERFECT_FIT_BONUS

    # Add a small, fixed bonus for placing items into already partially-filled bins.
    # This encourages consolidation without being overly complex or dominant.
    # A bin is considered partially-filled if its current remaining capacity is less than BIN_CAPACITY
    # (meaning it's not a brand new empty bin) but greater than zero.
    partially_filled_mask = (bins_remain_cap < BIN_CAPACITY) & (bins_remain_cap > 0) & can_fit_mask
    priorities[partially_filled_mask] += CONSOLIDATION_BONUS

    return priorities
```
