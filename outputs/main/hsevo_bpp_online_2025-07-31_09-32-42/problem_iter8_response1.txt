```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by combining aggressive inverse-waste minimization,
    a distinct high score for perfect fits, and a strategic penalty
    for leaving very small, "unusable" remaining capacities (bad gaps).
    This heuristic minimizes fragmentation while favoring tight fits.
    """
    BIN_CAPACITY_UNIT = 1.0  # Assumed normalized bin capacity

    # Heuristic Parameters
    # Tolerance for identifying a perfect fit (remaining capacity approximately 0)
    PERFECT_FIT_TOLERANCE = 1e-9 
    # A very high, distinct score assigned to perfect fits to ensure top priority
    MAX_PERFECT_FIT_SCORE = 1000.0 
    # Threshold below which a remaining gap is considered "bad" (difficult to fill)
    SMALL_GAP_THRESHOLD = 0.15 * BIN_CAPACITY_UNIT 
    # A large negative offset applied to "bad gap" scores. This ensures they are
    # heavily penalized and ranked lower than any "good gap", despite their
    # raw inverse-waste score potentially being high.
    BAD_GAP_PENALTY_OFFSET = -2000.0 # Adjusted to be sufficiently negative to push
                                     # bad gaps (which can have high 1/waste scores)
                                     # below good gaps (e.g., if 1/waste for bad gap is 1000,
                                     # and min 1/waste for good gap is 6.67, then 1000 - 2000 = -1000, which is < 6.67)

    # Small epsilon for numerical stability in inverse calculations (prevents division by zero)
    TIGHT_FIT_EPSILON = np.finfo(float).eps 

    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. Bins that cannot fit the item
    # will retain this value and thus never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    # We use -PERFECT_FIT_TOLERANCE to account for floating-point inaccuracies
    # when `item` might slightly exceed `bins_remain_cap` due to precision issues.
    can_fit_mask = potential_remaining_space >= -PERFECT_FIT_TOLERANCE

    # Filter potential remaining spaces for only those bins where the item can fit.
    valid_potential_remaining_space = potential_remaining_space[can_fit_mask]
    
    # Initialize a temporary array for priorities of valid bins.
    valid_priorities = np.zeros_like(valid_potential_remaining_space, dtype=float)

    # --- Scoring Logic based on Categories ---

    # 1. Perfect Fit: Remaining space is approximately zero.
    # These receive the highest possible score, making them the top choice.
    perfect_fit_mask = np.isclose(valid_potential_remaining_space, 0.0, atol=PERFECT_FIT_TOLERANCE)
    valid_priorities[perfect_fit_mask] = MAX_PERFECT_FIT_SCORE 

    # 2. Bad Gap: Remaining space is small but non-zero (i.e., (0, SMALL_GAP_THRESHOLD)).
    # These are scored using inverse waste, but then heavily penalized by a large negative offset.
    # This ensures they are chosen only if no 'Good Gap' or 'Perfect Fit' options are available.
    small_gap_mask = (valid_potential_remaining_space > PERFECT_FIT_TOLERANCE) & \
                     (valid_potential_remaining_space < SMALL_GAP_THRESHOLD)
    
    # Calculate base inverse waste score for bad gaps
    bad_gap_base_scores = 1.0 / (valid_potential_remaining_space[small_gap_mask] + TIGHT_FIT_EPSILON)
    # Apply the heavy penalty
    valid_priorities[small_gap_mask] = bad_gap_base_scores + BAD_GAP_PENALTY_OFFSET

    # 3. Good Gap: Remaining space is greater than or equal to the threshold ([SMALL_GAP_THRESHOLD, BIN_CAPACITY_UNIT]).
    # These are scored in a "Best Fit" manner using inverse waste: 1.0 / (remaining_space + epsilon).
    # A smaller remaining space (tighter fit) results in a higher positive score.
    other_gap_mask = valid_potential_remaining_space >= SMALL_GAP_THRESHOLD
    valid_priorities[other_gap_mask] = 1.0 / (valid_potential_remaining_space[other_gap_mask] + TIGHT_FIT_EPSILON)

    # Assign the calculated priorities back to the full 'priorities' array
    # using the original mask for all bins that could fit the item.
    priorities[can_fit_mask] = valid_priorities

    return priorities
```
