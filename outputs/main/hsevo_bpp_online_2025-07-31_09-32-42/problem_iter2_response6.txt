```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by aggressively seeking the tightest fit, mimicking a strong
    gravitational pull towards minimal void. Perfect fits yield the highest score,
    while non-fitting bins are given an infinitely low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to negative infinity for all bins.
    # This ensures that bins incapable of fitting the item are never chosen,
    # providing robust handling of invalid options.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins can physically accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # For the bins that can fit, calculate the 'void' that would remain.
    # We add a small epsilon to ensure numerical stability, especially for perfect fits (void=0),
    # preventing division by zero and allowing for a very high, but finite, priority score.
    remaining_void = bins_remain_cap[can_fit_mask] - item
    
    # Define a small epsilon for numerical stability.
    # This ensures that a perfect fit (remaining_void = 0) results in a very large,
    # finite priority (1/epsilon), while also providing robust inverse scaling for
    # extremely small positive remaining voids.
    epsilon = 1e-9 

    # Calculate priority: inversely proportional to the void space.
    # This creates a strong non-linear preference for tighter fits, where
    # smaller void leads to disproportionately higher priority, achieving
    # the "densest" fit.
    snugness_scores = 1.0 / (remaining_void + epsilon)

    # Assign these calculated scores to the eligible bins in the priorities array.
    priorities[can_fit_mask] = snugness_scores

    return priorities
```
