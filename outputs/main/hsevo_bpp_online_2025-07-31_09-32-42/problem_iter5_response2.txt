```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using an "Accelerated Best Fit" heuristic. It strongly favors
    tight fits by minimizing waste, and applies an additional non-linear penalty to larger
    waste values, thereby accelerating the preference for bin completion and reducing fragmentation.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): A NumPy array representing the remaining capacity
                                      in each bin.

    Returns:
        np.ndarray: A NumPy array of priorities for each bin. Bins unable to fit
                    the item will have a priority of -np.inf.
    """
    # Use machine epsilon for numerical stability, ensuring perfect fits (waste = 0)
    # receive an extremely high, finite priority score.
    epsilon = np.finfo(float).eps

    # Initialize priorities to negative infinity, unequivocally disqualifying bins
    # that cannot accommodate the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins with sufficient remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining space (waste) in suitable bins after placing the item.
    # A smaller waste indicates a more efficient fit.
    remaining_waste = bins_remain_cap[can_fit_mask] - item

    # Define a coefficient for the squared waste penalty. This constant can be tuned,
    # but a value of 1.0 provides a significant, disproportionate penalty for larger wastes.
    # This term makes the heuristic more aggressive in pursuing very tight fits.
    # It indirectly promotes closing bins faster and discourages leaving moderately large gaps.
    waste_squared_penalty_coeff = 1.0

    # Calculate priority as the inverse of a "penalized waste" term.
    # The term `(remaining_waste + epsilon)` handles the standard Best Fit.
    # The additional term `waste_squared_penalty_coeff * remaining_waste**2` introduces
    # a stronger, non-linear penalty for larger waste values. This effectively
    # "accelerates" the preference for minimal waste.
    penalized_waste = remaining_waste + epsilon + waste_squared_penalty_coeff * (remaining_waste**2)

    priorities[can_fit_mask] = 1.0 / penalized_waste

    return priorities
```
