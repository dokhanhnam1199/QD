```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Drawing upon the principle of cosmic compression, where matter seeks the most
    compact state, this heuristic prioritizes bins that achieve the "densest"
    fit. It mimics a gravitational pull towards the most efficient containment,
    leaving the least void. Bins that cannot accommodate the item are deemed
    outside the event horizon and are given an infinitely low priority. For
    those that can, the priority is inversely proportional to the void space
    that would remain after the item's insertion. A perfect fit yields the
    highest possible score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to negative infinity for all bins.
    # This ensures that bins incapable of fitting the item are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins can physically accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # For the bins that can fit, calculate the 'void' that would remain.
    # We want to minimize this void, so we take its negative to maximize the priority.
    # A smaller positive remainder means a higher (less negative) priority score.
    # A perfect fit (remainder = 0) yields a score of 0, which is the highest.
    remaining_space = bins_remain_cap[can_fit_mask] - item
    snugness_scores = -remaining_space

    # Assign these calculated scores to the eligible bins in the priorities array.
    priorities[can_fit_mask] = snugness_scores

    return priorities
```
