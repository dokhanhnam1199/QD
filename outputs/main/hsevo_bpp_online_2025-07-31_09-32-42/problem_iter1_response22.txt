```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    inspired by the principle of efficient space utilization, much akin to
    how bodies in the heavens seek the most stable configuration.

    This heuristic, which I shall name 'Best Fit', aims to minimize the
    'void' left in a bin after an item is placed. A smaller void signifies a
    more 'densely packed' state, which is preferred to conserve our
    precious bins. Think of it as ensuring each parcel of space is utilized
    with great precision, just as I observe the universe's grand design.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with a priority score for each bin.
        Bins where the item does not fit receive an infinitely low priority.
        For bins where it fits, the score is inversely proportional to the
        remaining empty space (a smaller remaining space yields a higher score).
    """
    # Calculate the space that would remain in each bin if the item were placed there.
    # This is our 'potential energy' or 'residual void'.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to a very low value (negative infinity).
    # This represents a state of impossibility or immense 'cost' for bins
    # where the item simply cannot be placed, much like an object attempting
    # to pass through solid matter.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    # These are the 'accessible' states in our system.
    can_fit_mask = potential_remaining_space >= 0

    # For the bins where the item *can* fit, we assign a priority.
    # We desire to minimize the 'potential_remaining_space', so we assign a
    # higher numerical priority score to bins that result in a smaller positive
    # remaining space. This means we want to maximize the negative of this value.
    # A bin that leaves 0 space (a perfect fit!) will have the highest score of 0.
    # A bin that leaves a large positive space will have a large negative score,
    # thereby having lower priority.
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    return priorities
```
