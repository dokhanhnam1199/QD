```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:
    """Returns priority with which to add an item to each bin, implementing a Best Fit
    variant with a dynamic 'dead space' penalty for problem-aware robustness and
    informed exploration.

    This heuristic extends the standard Best Fit approach by actively discouraging
    the creation of small, potentially unusable gaps (referred to as "dead space")
    within bins. While Best Fit prioritizes minimizing remaining capacity, this
    `priority_v2` introduces an adaptive penalty. If placing an item results in a
    remaining capacity that falls into a predefined 'dead space' range (too small
    to be generally useful, but not perfectly zero), the priority for that bin
    is significantly reduced. This aims to prevent bin fragmentation, improve
    overall bin utilization, and encourage more robust packing solutions, especially
    when dealing with items that could leave awkward small residuals.

    The penalty ensures that creating such "dead space" is often considered worse
    than placing the item into a much emptier bin, thereby nudging the heuristic
    away from locally optimal but globally inefficient choices.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.
        bin_capacity: The total capacity of a single bin. This is crucial for
                      scaling the 'dead space' threshold and penalty value. Default is 1.0.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores are designed such that:
        - A perfect fit (remaining capacity = 0) receives the highest possible score (0).
        - Bins that create "dead space" after placement receive a heavily penalized score.
        - Bins that cannot accommodate the item receive the lowest possible priority (-inf).
    """
    # Define thresholds and penalty for 'dead space'. These are dynamically
    # scaled relative to the bin_capacity for problem-aware robustness.
    # A remaining space is considered 'dead space' if it's greater than 0
    # but less than a certain fraction (e.g., 10%) of the bin's total capacity.
    DEAD_SPACE_THRESHOLD = 0.1 * bin_capacity

    # The penalty value is set to the full bin capacity. This makes creating
    # a dead space gap significantly less desirable than placing the item
    # into a brand new, empty bin (which would result in a score of -bin_capacity).
    PENALTY_VALUE = bin_capacity

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # Apply the base Best Fit priority: negative of the potential remaining space.
    # A smaller remaining space results in a higher (less negative) priority.
    # A perfect fit (0 remaining space) will result in a priority of 0 (the highest possible base score).
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    # Identify bins that, if chosen, would result in 'dead space'.
    # This applies to bins where:
    # 1. The item *can* fit (already covered by can_fit_mask).
    # 2. The resulting `potential_remaining_space` is greater than 0 (not a perfect fit).
    # 3. The resulting `potential_remaining_space` is less than the `DEAD_SPACE_THRESHOLD`.
    dead_space_creation_mask = (potential_remaining_space > 0) & (potential_remaining_space < DEAD_SPACE_THRESHOLD)

    # Combine the masks: apply penalty only to bins that can fit the item AND create dead space.
    apply_penalty_mask = can_fit_mask & dead_space_creation_mask

    # Apply the significant penalty to the priorities of identified 'dead space' bins.
    # This actively discourages choices that lead to awkward, unusable gaps,
    # thereby introducing 'problem-aware robustness' into the heuristic.
    priorities[apply_penalty_mask] -= PENALTY_VALUE

    return priorities
```
