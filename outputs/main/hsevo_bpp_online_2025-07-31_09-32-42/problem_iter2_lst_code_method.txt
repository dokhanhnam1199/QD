{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    inspired by Feynman's Principle of Least Action.\n\n    In the context of bin packing, the \"action\" of placing an item into a bin\n    can be conceptualized as the \"wasted space\" or \"entropy generated\" within that bin.\n    A good strategy would be to choose the bin that minimizes this \"action\".\n\n    Specifically, the \"action\" for a given bin is the empty space remaining\n    in that bin after the item is placed (i.e., its final remaining capacity).\n    We want to select the bin that leads to the smallest possible \"action\" (least waste).\n    Therefore, the priority for a bin is set to be inversely proportional to this\n    \"action\", plus a small epsilon to handle cases of perfect fit (zero remaining space)\n    and ensure mathematical stability. This effectively implements a \"Best Fit\" heuristic\n    with a strong non-linear preference for very tight fits.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a very low (negative infinity) priority,\n        ensuring they are not selected unless no other bin is available.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value.\n    # This ensures that bins incapable of holding the item are effectively excluded\n    # from consideration by having the lowest possible priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify which bins have enough remaining capacity\n    # to accommodate the current item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit the item, calculate the \"action\".\n    # The \"action\" is defined as the amount of space that will be left over\n    # in the bin after the item is placed. This is the value we aim to minimize.\n    action_for_valid_bins = bins_remain_cap[can_fit_mask] - item\n\n    # Add a small positive constant (epsilon) to the action.\n    # This serves two purposes:\n    # 1. Prevents division by zero if an item perfectly fits into a bin (action_for_valid_bins = 0).\n    # 2. Ensures that a perfect fit results in an extremely high priority score,\n    #    making it the most desirable outcome.\n    epsilon = 1e-9 # A tiny value, much smaller than any item size\n\n    # Calculate the priority for valid bins.\n    # The priority is inversely proportional to the \"action\".\n    # This means smaller actions (less wasted space) yield higher priorities,\n    # in line with the Principle of Least Action where paths with minimal action\n    # are overwhelmingly favored.\n    priorities[can_fit_mask] = 1.0 / (action_for_valid_bins + epsilon)\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    guided by the principle of Best Fit.\n\n    Just as planets orbit the sun in their most stable path, an item\n    should seek the bin where it fits most snugly, leaving the least\n    remaining space. This maximizes the utilization of our bins,\n    avoiding the creation of new ones unnecessarily.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a very low priority (-infinity).\n        Bins that can fit the item will be prioritized by how little space\n        they leave after the item is placed (smaller remainder means higher priority).\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating inability to fit\n    # or least preference if a better fit cannot be found.\n    # This ensures bins that cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins can actually accommodate the current item.\n    can_fit = bins_remain_cap >= item\n\n    # For those bins that can fit the item, calculate their \"fitness score\".\n    # A smaller remaining capacity after placing the item means a tighter fit,\n    # which is preferred. To achieve this, we want to maximize a value where\n    # `remaining_capacity_after_fit = bin_cap - item`.\n    # Thus, we maximize `item - bin_cap`.\n    # A perfect fit (bin_cap == item) results in a score of 0.\n    # A loose fit (bin_cap >> item) results in a larger negative score.\n    priorities[can_fit] = item - bins_remain_cap[can_fit]\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using a Best Fit strategy.\n\n    This heuristic aims to minimize the remaining capacity in a bin after an item is placed,\n    effectively \"tightening\" the fit. Bins that cannot accommodate the item are given the\n    lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # For bins where item > current_capacity, this will result in a negative number.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins to a very low value (-infinity).\n    # This ensures that bins which cannot fit the item are never chosen.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can actually fit (remaining capacity would be non-negative).\n    fitting_bins_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, the priority is calculated.\n    # We want to minimize 'potential_remaining_cap' for these bins.\n    # To achieve this with a 'maximize' objective for priority score,\n    # we use the negative of 'potential_remaining_cap'.\n    # A potential_remaining_cap of 0 will yield a score of 0 (perfect fit, highest priority).\n    # A larger potential_remaining_cap (e.g., 10) will yield a smaller score (e.g., -10),\n    # correctly prioritizing tighter fits.\n    priority_scores[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]\n\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This strategy, inspired by the principle of \"least action\" or finding the most\n    \"stable\" state, aims for a \"Best Fit\" approach. We want to place the item\n    in a bin such that the remaining capacity after placement is minimized,\n    thereby packing bins as densely as possible and reducing the need for new bins.\n\n    For a bin to be considered, it must be able to accommodate the item. Among\n    the valid bins, the one that results in the smallest amount of leftover\n    space after the item is placed is given the highest priority. Bins that\n    cannot fit the item are assigned an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space left in each bin if the current item were placed there.\n    # A value of zero or close to zero is ideal (a tight fit).\n    # Negative values indicate the bin cannot fit the item.\n    remaining_space_if_placed = bins_remain_cap - item\n\n    # Initialize priorities for all bins to a very low value (effectively disqualifying them)\n    # This ensures that bins which cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that *can* fit the item.\n    can_fit_mask = remaining_space_if_placed >= 0\n\n    # For bins that can fit the item, we want to assign a priority such that\n    # smaller remaining space leads to a higher priority.\n    # The negative of `remaining_space_if_placed` achieves this:\n    # - If remaining_space_if_placed = 0.0 (perfect fit), priority = 0.0 (highest for valid bins).\n    # - If remaining_space_if_placed = 0.1 (tight fit), priority = -0.1.\n    # - If remaining_space_if_placed = 0.5 (loose fit), priority = -0.5.\n    # Maximizing this priority will pick the smallest positive remaining_space.\n    valid_bin_priorities = -remaining_space_if_placed[can_fit_mask]\n\n    # Apply these calculated priorities only to the bins that can fit the item.\n    priorities[can_fit_mask] = valid_bin_priorities\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    inspired by the principle of efficient space utilization, much akin to\n    how bodies in the heavens seek the most stable configuration.\n\n    This heuristic, which I shall name 'Best Fit', aims to minimize the\n    'void' left in a bin after an item is placed. A smaller void signifies a\n    more 'densely packed' state, which is preferred to conserve our\n    precious bins. Think of it as ensuring each parcel of space is utilized\n    with great precision, just as I observe the universe's grand design.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        Bins where the item does not fit receive an infinitely low priority.\n        For bins where it fits, the score is inversely proportional to the\n        remaining empty space (a smaller remaining space yields a higher score).\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    # This is our 'potential energy' or 'residual void'.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (negative infinity).\n    # This represents a state of impossibility or immense 'cost' for bins\n    # where the item simply cannot be placed, much like an object attempting\n    # to pass through solid matter.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    # These are the 'accessible' states in our system.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For the bins where the item *can* fit, we assign a priority.\n    # We desire to minimize the 'potential_remaining_space', so we assign a\n    # higher numerical priority score to bins that result in a smaller positive\n    # remaining space. This means we want to maximize the negative of this value.\n    # A bin that leaves 0 space (a perfect fit!) will have the highest score of 0.\n    # A bin that leaves a large positive space will have a large negative score,\n    # thereby having lower priority.\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic. Bins that result in the smallest\n    remaining capacity (tightest fit) after the item is placed receive a\n    higher priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item does not fit will have a very low (negative infinity) priority.\n    \"\"\"\n    # Initialize all priorities to a very low value, effectively marking them as unsuitable\n    # This ensures that bins where the item does not fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the 'tightness' of the fit.\n    # The 'Best Fit' strategy aims to minimize the remaining space in a bin after the item is placed.\n    # To translate this into a \"highest priority score\", we can use the negative of the remaining space.\n    # A smaller positive remaining space (e.g., 0.1) will result in a larger negative number (e.g., -0.1),\n    # which is \"higher\" than a larger negative number (e.g., -0.5 for 0.5 remaining space).\n    # Thus, np.argmax on these priorities will correctly select the bin with the smallest positive remaining space.\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Drawing upon the principle of cosmic compression, where matter seeks the most\n    compact state, this heuristic prioritizes bins that achieve the \"densest\"\n    fit. It mimics a gravitational pull towards the most efficient containment,\n    leaving the least void. Bins that cannot accommodate the item are deemed\n    outside the event horizon and are given an infinitely low priority. For\n    those that can, the priority is inversely proportional to the void space\n    that would remain after the item's insertion. A perfect fit yields the\n    highest possible score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to negative infinity for all bins.\n    # This ensures that bins incapable of fitting the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can physically accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit, calculate the 'void' that would remain.\n    # We want to minimize this void, so we take its negative to maximize the priority.\n    # A smaller positive remainder means a higher (less negative) priority score.\n    # A perfect fit (remainder = 0) yields a score of 0, which is the highest.\n    remaining_space = bins_remain_cap[can_fit_mask] - item\n    snugness_scores = -remaining_space\n\n    # Assign these calculated scores to the eligible bins in the priorities array.\n    priorities[can_fit_mask] = snugness_scores\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic is inspired by the \"Best Fit\" strategy, aiming to\n    place the item into the bin that will leave the least amount of\n    remaining space, thereby \"snugly\" fitting items and preserving\n    larger gaps for future larger items if possible, or tightly packing\n    bins.\n\n    The priority score is calculated such that a tighter fit (less remaining\n    capacity after placing the item) results in a higher score (closer to zero).\n    Bins where the item does not fit are assigned a very low (negative infinity)\n    priority, ensuring they are never chosen.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value means the item does not fit.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Initialize all priority scores to a very low value (e.g., negative infinity).\n    # This ensures bins where the item does not fit are never selected.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins the item can actually fit into.\n    # A bin is suitable if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For bins where the item can fit, calculate their priority.\n    # We want to minimize the remaining capacity (potential_remaining_capacity).\n    # To achieve this with a maximum selection, we take the negative of the\n    # potential remaining capacity. A smaller positive remaining capacity\n    # (e.g., 0.0 for a perfect fit) will result in a larger priority score\n    # (e.g., 0.0), whereas a larger remaining capacity (e.g., 0.5) will\n    # result in a smaller priority score (-0.5).\n    priority_scores[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]\n\n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, implementing a variation of Best Fit.\n\n    This heuristic aims to select the bin that will have the least remaining capacity\n    after the item is placed, effectively trying to \"fill up\" a bin as much as possible.\n    Bins that cannot accommodate the item receive the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a higher priority for placing the item in that bin.\n        Scores are designed such that a perfect fit (remaining capacity = 0) gets the\n        highest possible score (0), while bins that cannot fit the item get -inf.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    # A smaller positive value here means a \"better fit\".\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins where the item can fit, assign a priority based on the negative\n    # of the potential remaining space.\n    # By maximizing this value, we are effectively minimizing the potential remaining space.\n    # A perfect fit (0 remaining space) will result in a priority of 0 (the highest).\n    # A larger remaining space (e.g., 0.5) will result in a lower priority (-0.5).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This strategy, inspired by the principle of \"least action\" or finding the most\n    \"stable\" state, aims for a \"Best Fit\" approach. We want to place the item\n    in a bin such that the remaining capacity after placement is minimized,\n    thereby packing bins as densely as possible and reducing the need for new bins.\n\n    For a bin to be considered, it must be able to accommodate the item. Among\n    the valid bins, the one that results in the smallest amount of leftover\n    space after the item is placed is given the highest priority. Bins that\n    cannot fit the item are assigned an extremely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space left in each bin if the current item were placed there.\n    # A value of zero or close to zero is ideal (a tight fit).\n    # Negative values indicate the bin cannot fit the item.\n    remaining_space_if_placed = bins_remain_cap - item\n\n    # Initialize priorities for all bins to a very low value (effectively disqualifying them)\n    # This ensures that bins which cannot fit the item are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that *can* fit the item.\n    can_fit_mask = remaining_space_if_placed >= 0\n\n    # For bins that can fit the item, we want to assign a priority such that\n    # smaller remaining space leads to a higher priority.\n    # The negative of `remaining_space_if_placed` achieves this:\n    # - If remaining_space_if_placed = 0.0 (perfect fit), priority = 0.0 (highest for valid bins).\n    # - If remaining_space_if_placed = 0.1 (tight fit), priority = -0.1.\n    # - If remaining_space_if_placed = 0.5 (loose fit), priority = -0.5.\n    # Maximizing this priority will pick the smallest positive remaining_space.\n    valid_bin_priorities = -remaining_space_if_placed[can_fit_mask]\n\n    # Apply these calculated priorities only to the bins that can fit the item.\n    priorities[can_fit_mask] = valid_bin_priorities\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    This implementation prioritizes bins using a \"Best Fit Decreasing\" like heuristic\n    for online packing. Bins that result in the smallest non-negative remaining capacity\n    after adding the item receive higher priority. Perfect fits are given the highest\n    possible priority (infinity). Bins that cannot accommodate the item receive a \n    priority of 0.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a higher preference for placing the item in that bin.\n    \"\"\"\n    # Initialize priorities for all bins to 0. Bins that cannot fit the item\n    # or are not prioritized will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Create a boolean mask for bins that have enough capacity to hold the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining capacity for bins where the item can fit\n    # We only operate on the subset of bins identified by can_fit_mask\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Identify bins that would be perfectly filled by the item\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n\n    # Assign infinite priority to perfect fits. This ensures they are always chosen\n    # over any other non-perfect fit, as they utilize space most efficiently.\n    priorities[can_fit_mask][perfect_fit_mask] = np.inf\n\n    # For bins that can fit the item but are not perfectly filled:\n    # Prioritize them inversely to their remaining capacity.\n    # A smaller remaining capacity means a 'tighter' or 'better' fit, thus higher priority.\n    # This encourages packing items into bins that are nearly full,\n    # leaving larger bins for potentially larger future items.\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n    \n    # Calculate inverse for positive remaining capacities.\n    # Add a small epsilon if needed to prevent division by zero for values\n    # extremely close to zero but not exactly zero, though `potential_remain_after_fit > 0`\n    # should ideally handle this.\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / potential_remain_after_fit[non_perfect_fit_mask]\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}