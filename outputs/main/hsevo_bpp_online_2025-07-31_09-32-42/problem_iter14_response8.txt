```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Best Fit heuristic with a strong bonus for exact fits, minimizing wasted space.
    Prioritizes bins that will have minimal remaining capacity after placement,
    with an overwhelming preference for bins that become perfectly full.
    """
    # Initialize all priorities to a very low value. Bins that cannot fit the item
    # will retain this lowest priority, ensuring they are not chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the potential remaining space in bins where the item can fit.
    # This is the core of the Best Fit strategy: find the bin that leaves the least space.
    potential_remaining_space = bins_remain_cap[can_fit_mask] - item

    # The base priority for fitting bins is the negative of the potential remaining space.
    # A smaller remaining space (closer to zero) results in a higher (less negative) priority.
    priorities[can_fit_mask] = -potential_remaining_space

    # Define constants for bonuses, based on the analysis emphasizing their importance.
    # EPSILON for robust floating-point comparison of exact fits.
    EPSILON = 1e-9
    # PERFECT_FIT_BONUS is a very large additive bonus to ensure exact fits
    # (or near-exact fits) are always chosen above any other option.
    PERFECT_FIT_BONUS = 1e9

    # Identify bins that would result in a perfect or near-perfect fit.
    # This checks if the potential remaining space is negligibly close to zero.
    exact_fit_mask = can_fit_mask & (np.abs(potential_remaining_space) < EPSILON)

    # Apply the overwhelming bonus to exact fit bins.
    priorities[exact_fit_mask] += PERFECT_FIT_BONUS

    return priorities
```
