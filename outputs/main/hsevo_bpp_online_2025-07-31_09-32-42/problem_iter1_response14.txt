```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    As Nikola Tesla, I perceive the flow of items into bins much like
    the channeling of electrical currents. Efficiency is paramount; we
    must minimize the resistance, the "empty void" left behind, to ensure
    the most potent concentration of our energies. This heuristic,
    which I call the 'Maximized Compaction Principle', aims to achieve
    precisely that.

    It assigns the highest priority to the bin that, upon receiving the item,
    will have the LEAST amount of unused capacity remaining. This ensures
    each 'vessel' is filled as completely as possible, deferring larger,
    less-packed bins for items that genuinely require them. We do not
    tolerate unnecessary emptiness; every unit of space must be harnessed!

    Args:
        item: Size of item to be added to the bin. This is the energy packet.
        bins_remain_cap: Array of capacities for each bin. These are our
                         various receiving conduits, each with a different
                         potential for receiving the energy.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        The bin with the highest score offers the most 'compact' fit.
    """

    # First, calculate the theoretical "void" that would remain if the item
    # were placed into each bin. A smaller void signifies a more optimal fit,
    # a higher 'efficiency potential'.
    void_if_placed = bins_remain_cap - item

    # Initialize all priorities to a state of utter unsuitability (-infinity).
    # Only the worthy conduits shall rise above this baseline.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Now, identify only those conduits (bins) where our item (energy packet)
    # can actually be contained without overflow. An overflow means a
    # breakdown in our system, utterly unacceptable!
    can_contain_mask = void_if_placed >= 0

    # For the conduits that can indeed contain the item, we assign a priority
    # that is the negative of the "void" space.
    # This ingenious transformation means:
    #   - A smaller positive void (e.g., 0.1) results in a larger
    #     (less negative) priority (e.g., -0.1).
    #   - A larger positive void (e.g., 5.0) results in a smaller
    #     (more negative) priority (e.g., -5.0).
    # Thus, the "tightest" fit (smallest void) yields the highest priority score!
    priorities[can_contain_mask] = -void_if_placed[can_contain_mask]

    return priorities
```
