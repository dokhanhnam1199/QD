```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, implementing a Best Fit
    strategy with a strong, fixed preference for perfect fits.

    This heuristic aims to select the bin that will have the least remaining capacity
    after the item is placed (Best Fit principle, minimizing immediate waste).
    Crucially, it applies a significant, fixed additive bonus to bins where the item
    perfectly fills the bin, ensuring these are always chosen over any non-perfect fit,
    regardless of how close the non-perfect fit might be.
    Bins that cannot accommodate the item receive the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores are designed such that a perfect fit receives a large positive bonus,
        while bins that cannot fit the item get -inf.
    """
    # Define a fixed, additive bonus for a perfect fit.
    # This value must be sufficiently large to ensure that a perfect fit
    # always outranks any non-perfect fit. If item sizes and bin capacities
    # are typically normalized to 1.0, a bonus of 2.0 (or anything > 1.0)
    # guarantees this, as the Best Fit score (negative remaining space)
    # is typically between -1.0 and 0.0.
    BONUS_PERFECT_FIT = 2.0

    # Calculate the remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # For bins where the item can fit, assign a priority based on the negative
    # of the potential remaining space. This implements the Best Fit strategy:
    # maximizing this value means minimizing the remaining space.
    # A smaller positive potential_remaining_space results in a higher (less negative) priority.
    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]

    # Identify bins where a perfect fit occurs. Use np.isclose for robust floating-point comparison.
    # The `atol` (absolute tolerance) ensures that small floating point inaccuracies don't prevent
    # a near-perfect fit from being recognized as a perfect one.
    perfect_fit_mask = np.isclose(potential_remaining_space, 0.0, atol=1e-9)

    # Apply the fixed bonus to bins that are both a perfect fit AND capable of fitting the item.
    # The 'and can_fit_mask' part is crucial to avoid applying a bonus if, due to floating point
    # precision, a negative remaining capacity (meaning item does not fit) is very close to zero.
    priorities[perfect_fit_mask & can_fit_mask] += BONUS_PERFECT_FIT

    return priorities
```
