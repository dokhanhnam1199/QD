```python
import numpy as np

# Assuming BIN_CAPACITY can be inferred or passed. For this function, as `bins_remain_cap`
# is an array of float values (e.g., [1.0, 0.5, 0.2]), we can infer that the maximum
# value in this array (or a conceptual "full" bin capacity) is 1.0 (normalized).
BIN_CAPACITY_UNIT = 1.0 

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which to add an item to each bin, implementing a Best Fit
    variation that strategically avoids creating very small, "unusable" remaining gaps,
    while still highly prioritizing perfect fits.

    This heuristic applies an "adaptive logic" by categorizing potential bin states
    after an item is placed, aiming to improve "global utility" by anticipating
    future bin configurations and managing dynamic bin states:

    1.  **Perfect Fit**: If placing the item fills the bin exactly (remaining capacity becomes 0).
        This receives the highest possible priority score. This is a highly desirable outcome
        as it "closes" a bin efficiently.

    2.  **Good Gap**: If placing the item leaves a remaining capacity that is large enough
        to be potentially useful for future items (i.e., above a defined 'small gap threshold').
        These bins are scored similarly to standard Best Fit (preferring smaller remaining space
        amongst themselves), but are always considered more desirable than 'Bad Gaps'. This
        promotes filling bins without creating highly fragmented space.

    3.  **Bad Gap**: If placing the item leaves a very small, non-zero remaining capacity
        (below the 'small gap threshold'). Such capacities are often difficult to fill with
        subsequent items, leading to wasted space and an increased number of bins used overall.
        These bins are heavily penalized to ensure they are chosen only if no 'Good Gap'
        or 'Perfect Fit' options are available.

    This approach moves beyond simply "over-emphasizing immediate greedy fits" by adding
    a foresight mechanism that penalizes outcomes likely to lead to future fragmentation.

    Args:
        item: Size of item to be added to the bin (float, typically between 0 and BIN_CAPACITY_UNIT).
        bins_remain_cap: Array of current remaining capacities for each bin (float, typically
                         between 0 and BIN_CAPACITY_UNIT).

    Return:
        Array of same size as bins_remain_cap with priority score for each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Bins that cannot accommodate the item receive the lowest possible priority (-np.inf).
    """
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    # Using a small epsilon (1e-9) to account for floating-point inaccuracies
    # when an item perfectly fills a bin (e.g., 0.5 - 0.5 = 0.0, but float math might yield 1e-17).
    can_fit_mask = potential_remaining_space >= -1e-9

    # Filter potential remaining spaces for only those bins where the item can fit.
    valid_potential_remaining_space = potential_remaining_space[can_fit_mask]
    
    # Initialize a temporary array for priorities of valid bins.
    valid_priorities = np.zeros_like(valid_potential_remaining_space, dtype=float)

    # --- Heuristic Parameters ---
    # This threshold defines the upper bound for what is considered a "small" and
    # potentially "unusable" remaining gap. A value of 0.15 means any remaining
    # space less than 15% of the bin capacity (and greater than zero) is considered a "bad gap".
    # This parameter is crucial and may require tuning based on the problem's item size distribution.
    SMALL_GAP_THRESHOLD = 0.15 * BIN_CAPACITY_UNIT 

    # This is a large negative offset applied to "bad gaps". It ensures that
    # any 'Good Gap' (even a very large one, which would typically get a low negative score)
    # will always have a higher priority than any 'Bad Gap'.
    # The range of scores for 'Good Gaps' typically falls within [-(BIN_CAPACITY_UNIT - min_item_size), 0].
    # An offset like -100.0 is sufficiently large to push 'Bad Gap' scores well below this range.
    BAD_GAP_SCORE_OFFSET = -100.0 

    # --- Scoring Logic based on Categories ---

    # 1. Perfect Fit: Remaining space is approximately zero.
    # These receive the highest possible score (0.0), making them the top choice.
    perfect_fit_mask = np.isclose(valid_potential_remaining_space, 0.0, atol=1e-9)
    valid_priorities[perfect_fit_mask] = 0.0 

    # 2. Bad Gap: Remaining space is small but non-zero (i.e., (0, SMALL_GAP_THRESHOLD)).
    # These are heavily penalized. Their score is calculated as -(remaining_space)
    # plus the large negative offset. This ensures they are ranked lower than all 'Good Gaps'.
    small_gap_mask = (valid_potential_remaining_space > 1e-9) & \
                     (valid_potential_remaining_space < SMALL_GAP_THRESHOLD)
    valid_priorities[small_gap_mask] = -valid_potential_remaining_space[small_gap_mask] + BAD_GAP_SCORE_OFFSET

    # 3. Good Gap: Remaining space is greater than or equal to the threshold ([SMALL_GAP_THRESHOLD, BIN_CAPACITY_UNIT]).
    # These are scored in a "Best Fit" manner: -(remaining_space). Among these, smaller
    # remaining spaces (closer to the threshold) will have higher scores (closer to 0.0).
    # Due to BAD_GAP_SCORE_OFFSET, these scores will always be higher than those of 'Bad Gaps'.
    other_gap_mask = valid_potential_remaining_space >= SMALL_GAP_THRESHOLD
    valid_priorities[other_gap_mask] = -valid_potential_remaining_space[other_gap_mask]

    # Assign the calculated priorities back to the full 'priorities' array
    # using the original mask for all bins that could fit the item.
    priorities[can_fit_mask] = valid_priorities

    return priorities
```
