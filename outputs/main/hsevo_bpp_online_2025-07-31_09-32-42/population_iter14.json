[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with strong bonuses for perfect fits and consolidating\n    items into already partially-filled bins.\n    \"\"\"\n    # Constants for priority bonuses, chosen to ensure desired hierarchy\n    PERFECT_FIT_BONUS = 10000.0  # Very large, fixed bonus for exact fits (dominant)\n    CONSOLIDATION_BONUS = 5.0    # Fixed bonus for filling existing, partially used bins\n\n    # Initialize priorities to negative infinity. Bins that cannot fit the item\n    # will maintain this low priority and thus never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n    \n    # Extract relevant values for bins where the item can fit for efficient computation.\n    valid_remaining_space = potential_remaining_space[can_fit_mask]\n    \n    # --- Core Priority: Best Fit Principle ---\n    # Assign a base score to eligible bins. Prioritize bins that would have the\n    # least remaining space (i.e., closest to a perfect fit but not necessarily 0).\n    # A smaller positive remaining space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -valid_remaining_space\n\n    # --- Consolidation Bonus (Strategic Fill) ---\n    # Apply a fixed bonus to bins that are already partially utilized (not full, not empty).\n    # This encourages packing into existing bins before opening new ones (assuming full capacity\n    # is the maximum value in bins_remain_cap).\n    if bins_remain_cap.size > 0: # Avoid errors on empty bin list\n        # Determine what \"full capacity\" means from the current bin capacities.\n        # This assumes the largest capacity in the array represents a \"new/empty\" bin.\n        max_current_cap = np.max(bins_remain_cap)\n        \n        # Identify bins that are currently partially filled (not completely empty, not full).\n        is_partially_filled_pre_placement = (bins_remain_cap < max_current_cap) & (bins_remain_cap > 0)\n        \n        # Apply consolidation bonus to bins that can fit the item AND are partially filled.\n        consolidation_eligible_mask = can_fit_mask & is_partially_filled_pre_placement\n        priorities[consolidation_eligible_mask] += CONSOLIDATION_BONUS\n\n    # --- Perfect Fit Bonus (Dominant Override) ---\n    # Apply a very large, fixed bonus to guarantee that exact fits (remaining space == 0)\n    # are always the highest possible priority. This overrides any other score for perfect fits.\n    perfect_fit_mask = (valid_remaining_space == 0)\n    # Apply the bonus to the subset of priorities corresponding to fitting bins that are perfect fits.\n    priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit with overwhelming exact fit preference and a subtle consolidation bonus.\n    Prioritizes filling bins completely, then minimizing waste, then consolidating.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for calculating fullness.\n    BIN_CAPACITY = 1.0 \n    \n    # Overwhelming bonus for exact fits, making them top priority regardless of other factors.\n    # This value is significantly high to ensure dominance as per \"Analyze & experience\".\n    EXACT_FIT_BONUS = 1e6 \n    \n    # Small additive factor for the consolidation bonus, ensuring it subtly promotes\n    # using existing, partially-filled bins without overriding Best Fit or Exact Fit.\n    CONSOLIDATION_STRENGTH = 0.001 \n\n    # Epsilon for robust floating-point comparisons, to handle near-zero or near-full conditions.\n    EPSILON = np.finfo(float).eps * 100 \n\n    # Calculate potential remaining space in each bin after hypothetically placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (remaining space must be non-negative or very close to zero).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # Adjust potential remaining space to be exactly non-negative for consistent scoring.\n    # This handles tiny negative values due to floating-point precision errors.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score (Best Fit): Prioritize bins that will have the least remaining space.\n    # A smaller remaining space results in a higher (less negative) score.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Overwhelming Exact Fit Bonus: Add a large bonus to bins that become perfectly full.\n    # This bonus ensures that exact fits are chosen above all other considerations.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += EXACT_FIT_BONUS\n\n    # 3. Apply Subtle Consolidation Bonus:\n    # Promote usage of existing, partially-filled bins by giving a small bonus\n    # proportional to their current fullness. This applies only to:\n    # - Bins that can fit the item.\n    # - Bins that are NOT exact fits (exact fits are handled by the dominant bonus).\n    # - Bins that are NOT completely empty (encouraging filling existing bins rather than new ones).\n    \n    # Identify bins that are completely empty.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    \n    # Create a mask for bins eligible for this consolidation bonus.\n    eligible_for_consolidation_bonus_mask = can_fit_mask & ~exact_fit_mask & ~is_empty_bin_mask\n\n    if np.any(eligible_for_consolidation_bonus_mask):\n        # Calculate the current fullness for eligible bins (0 for empty, 1 for full).\n        current_fullness_eligible = (BIN_CAPACITY - bins_remain_cap[eligible_for_consolidation_bonus_mask]) / BIN_CAPACITY\n        \n        # Add a subtle bonus proportional to current fullness, encouraging consolidation.\n        priorities[eligible_for_consolidation_bonus_mask] += CONSOLIDATION_STRENGTH * current_fullness_eligible\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines linear Best Fit with a minor additive bonus for fuller bins, and a dominant score for perfect fits,\n    prioritizing immediate waste minimization and bin closure.\n    \"\"\"\n    # Initialize all priorities to negative infinity, marking unavailable bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate potential remaining space for fitting bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Numerical stability epsilon.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Linear scoring for minimal remaining space.\n    # A smaller (closer to zero) potential_remaining_space results in a higher (less negative) score,\n    # prioritizing the tightest fits.\n    best_fit_scores = -potential_remaining_space\n\n    # Additive Consolidation Bias Component: Small bonus for already fuller bins.\n    # By using the inverse of remaining capacity, fuller bins (smaller remaining capacity)\n    # receive a higher bonus. The weight ensures this is a minor adjustment.\n    CONSOLIDATION_BIAS_WEIGHT = 0.005  # Reduced weight compared to v0 for subtle influence\n    consolidation_bonus = CONSOLIDATION_BIAS_WEIGHT / (bins_remain_cap[can_fit_mask] + EPSILON)\n\n    # Combine the linear Best Fit score with the additive consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    PERFECT_FIT_SCORE = 1e30  # A very high score to ensure perfect fits are chosen.\n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to perfect fit bins, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using Best Fit with a dominant exact fit bonus and a subtle\n    consolidation preference. Employs robust fixed scoring and finite low priority for unfit bins.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n\n    # Initialize all priorities to a very low, but finite, number.\n    # This ensures bins that cannot fit the item receive a clearly lower priority\n    # than any fitting bin, aligning with robust numerical practices.\n    LOW_PRIORITY_FOR_UNFIT = -1e18 # Sufficiently low to be less than any possible valid Best Fit score.\n    priorities = np.full(num_bins, LOW_PRIORITY_FOR_UNFIT, dtype=float)\n\n    # Assume a standard bin capacity for common normalization in BPP.\n    BIN_CAPACITY = 1.0\n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to a very high value to ensure exact fits are chosen first,\n    # as this is critical for minimizing bin count.\n    PERFECT_FIT_BONUS = 1e9\n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing,\n    # partially filled bins, promoting consolidation without overcomplicating.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons, handling minor inaccuracies.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item in each bin.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    # This prevents negative scores from floating-point errors for near-perfect fits.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    # Scores are only applied to bins that can fit the item.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is considered a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty (new),\n    # and are not perfect fits (already handled by a much higher bonus).\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\n# Assume a global BIN_CAPACITY for context. This is typical in Bin Packing Problem (BPP)\n# where items and bin capacities are often normalized, e.g., to 1.0.\nBIN_CAPACITY = 1.0\n\n# Define heuristic parameters for strategic adjustments.\n# These values are empirical and might require tuning for specific problem distributions.\n\n# EPSILON_CLOSE_TO_ZERO: Tolerance for floating-point comparisons to detect \"exact\" fits.\n# Essential for numerical robustness in comparisons with zero.\nEPSILON_CLOSE_TO_ZERO = 1e-6\n\n# CONSOLIDATION_BONUS: A fixed additive bonus for placing an item into a bin\n# that is already partially filled. This encourages consolidating items into\n# existing bins rather than opening new ones, promoting better bin utilization.\n# This value should be positive but significantly smaller than the exact fit bonus.\nCONSOLIDATION_BONUS = 0.1 # A moderate, fixed bonus value.\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with an overwhelming exact fit preference and a consolidation bonus.\n    \"\"\"\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that\n    # any bin that cannot fit the item will never be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # We allow for very small negative remaining space due to floating point inaccuracies,\n    # treating them as effectively zero.\n    can_fit_mask = potential_remaining_space >= -EPSILON_CLOSE_TO_ZERO\n\n    # If no bin can fit the item, return the priorities as they are (all -inf).\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Extract the potential remaining space for only the bins where the item can fit.\n    fitting_rem_space = potential_remaining_space[can_fit_mask]\n    # Also get the original remaining capacity for these bins to identify partially filled ones.\n    fitting_bins_remain_cap_orig = bins_remain_cap[can_fit_mask]\n\n    # --- Step 1: Base Priority (Best Fit logic) ---\n    # The base priority is the negative of the potential remaining space.\n    # This means a smaller remaining space (closer to zero) results in a\n    # higher (less negative or zero) priority score. A perfect fit (0 remaining space)\n    # gets a base score of 0, which is the highest possible \"default\" score for non-bonused bins.\n    current_priorities_for_fit_bins = -fitting_rem_space\n\n    # --- Step 2: Strategic Additive Adjustments ---\n\n    # 2.1. Overwhelming Priority for Exact/Near-Exact Fits:\n    # Identify bins where the item perfectly or very nearly perfectly fills the bin.\n    # Assign them an extremely high, distinct priority to ensure they are always chosen\n    # if available, as this represents maximal bin utilization and closes a bin efficiently.\n    is_exact_or_near_fit = np.abs(fitting_rem_space) < EPSILON_CLOSE_TO_ZERO\n    current_priorities_for_fit_bins[is_exact_or_near_fit] = np.finfo(float).max / 2.0\n\n    # 2.2. Consolidation Bonus:\n    # For bins that are NOT exact fits, apply a bonus if they are already partially\n    # filled (i.e., not completely empty at the start). This encourages placing items\n    # into bins that are already in use, rather than opening new ones, thereby\n    # consolidating items and reducing the total number of bins used.\n    # We apply this bonus only to bins that are not already exact fits, as exact fits\n    # already have the highest priority.\n    non_exact_mask = ~is_exact_or_near_fit\n    \n    # A bin is considered 'partially filled' if its original remaining capacity\n    # is less than the full BIN_CAPACITY (allowing for epsilon to account for\n    # small floating point differences from initial fill). This identifies bins\n    # that are not 'freshly opened' or completely empty.\n    is_partially_filled_before_placement = fitting_bins_remain_cap_orig < (BIN_CAPACITY - EPSILON_CLOSE_TO_ZERO)\n\n    # Apply the consolidation bonus to fitting, non-exact-fit, and already partially-filled bins.\n    apply_consolidation_bonus_mask = non_exact_mask & is_partially_filled_before_placement\n    current_priorities_for_fit_bins[apply_consolidation_bonus_mask] += CONSOLIDATION_BONUS\n\n    # Assign the calculated priorities for fitting bins back into the main priorities array.\n    priorities[can_fit_mask] = current_priorities_for_fit_bins\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines linear Best Fit with a linear consolidation bias and dominant perfect fit.\n    Prioritizes tightest fits while encouraging use of fuller bins.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Extract relevant data for bins that can fit the item.\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Potential remaining space if the item were placed in fit-capable bins.\n    potential_remaining_space = fitting_bins_remain_cap - item\n\n    # Core Best Fit Component: Assign priority linearly as the negative of potential remaining space.\n    # This ensures that smaller remaining space (tighter fit) results in a higher score.\n    # A perfect fit (0 remaining) gets a score of 0.\n    best_fit_scores = -potential_remaining_space\n\n    # Linear Consolidation Bias Component: Promote packing into already fuller bins.\n    # A smaller bins_remain_cap (fuller bin) leads to a larger (less negative) bonus score,\n    # thereby giving a higher additive bonus.\n    CONSOLIDATION_BIAS_WEIGHT = 0.05 \n    consolidation_bonus = -fitting_bins_remain_cap * CONSOLIDATION_BIAS_WEIGHT\n\n    # Combine the linear Best Fit score with the linear consolidation bias.\n    priorities[can_fit_mask] = best_fit_scores + consolidation_bonus\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using enhanced Best Fit, strongly favoring exact fits and\n    consolidating into partially-filled bins for high utilization.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.full(num_bins, -np.inf, dtype=float)\n\n    # Assume a standard bin capacity for normalization.\n    BIN_CAPACITY = 1.0 \n\n    # Define constants for bonus scores and floating-point comparisons.\n    # PERFECT_FIT_BONUS is set to an extremely high value to ensure exact fits are chosen first,\n    # as indicated by analysis as the most critical performance factor.\n    PERFECT_FIT_BONUS = 1e15 \n\n    # PARTIALLY_FILLED_BIN_BONUS is a small additive bonus to favor existing,\n    # partially-filled bins, promoting consolidation.\n    PARTIALLY_FILLED_BIN_BONUS = 0.005\n\n    # EPSILON for robust floating-point comparisons.\n    EPSILON = np.finfo(float).eps * 100\n\n    # Calculate potential remaining space after placing the item.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify bins where the item can fit (allowing for minor float inaccuracies).\n    can_fit_mask = potential_remaining_space >= -EPSILON\n\n    # For scoring, ensure remaining space is non-negative if within fit tolerance.\n    potential_remaining_space_for_scoring = np.where(potential_remaining_space < 0, 0, potential_remaining_space)\n\n    # 1. Base Score: Apply Best Fit principle (minimize remaining capacity).\n    # A smaller potential_remaining_space results in a higher (less negative) score.\n    # This directly minimizes wasted space within a bin.\n    priorities[can_fit_mask] = -potential_remaining_space_for_scoring[can_fit_mask]\n\n    # 2. Apply Perfect Fit Bonus: Overwhelmingly prioritize bins that become perfectly full.\n    # A bin is a perfect fit if its remaining space after placement is nearly zero.\n    exact_fit_mask = can_fit_mask & (potential_remaining_space_for_scoring < EPSILON)\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # 3. Apply Partially Filled Bin Bonus: Consolidate items into bins that are already in use.\n    # This bonus applies to bins that can fit the item, are not completely empty, and are not perfect fits.\n    # This adheres to the analysis's preference for simple, fixed additive consolidation bonuses.\n    is_empty_bin_mask = np.isclose(bins_remain_cap, BIN_CAPACITY, atol=EPSILON)\n    is_partially_filled_bin_mask = can_fit_mask & ~is_empty_bin_mask & ~exact_fit_mask\n\n    priorities[is_partially_filled_bin_mask] += PARTIALLY_FILLED_BIN_BONUS\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes linear tight fits (Best Fit) and exact fits. Adds a fixed\n    bonus to non-perfectly-filling bins to encourage consolidation into existing bins.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return the initialized priorities.\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Small epsilon for numerical stability for near-zero comparisons.\n    EPSILON = np.finfo(float).eps\n\n    # Core Best Fit Component: Assign priority as the negative of potential remaining space.\n    # This linearly favors bins that result in minimal remaining space (tightest fit),\n    # as smaller (closer to zero or less negative) 'potential_remaining_space' yields a higher score.\n    best_fit_scores = -potential_remaining_space\n\n    # Fixed Additive Consolidation Bonus: Encourage filling existing, non-perfectly-fitting bins.\n    # This fixed bonus shifts up the score of any bin that can fit the item but won't be a perfect fit.\n    # It promotes using partially filled bins before opening new ones (if no perfect fit exists).\n    CONSOLIDATION_FIXED_BONUS = 0.1 \n\n    # Identify bins that can fit the item but are not a perfect/near-perfect fit.\n    non_perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) >= 1e-9 # Use a small tolerance\n\n    # Apply the fixed consolidation bonus to these bins.\n    best_fit_scores[non_perfect_fit_mask_in_fitting] += CONSOLIDATION_FIXED_BONUS\n    \n    # Assign the calculated scores to the fitting bins in the main priorities array.\n    priorities[can_fit_mask] = best_fit_scores\n\n    # Explicitly boost perfect fits to ensure their absolute priority.\n    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.\n    PERFECT_FIT_TOLERANCE = 1e-9\n    # A very high score to ensure perfect fits are chosen over any other option.\n    PERFECT_FIT_SCORE = 1e30 \n\n    # Identify perfect or near-perfect fits within the fitting bins.\n    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE\n\n    # Apply the super-high score to bins that are perfect fits, overriding previous calculations.\n    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best Fit heuristic with a strong bonus for exact fits, minimizing wasted space.\n    Prioritizes bins that will have minimal remaining capacity after placement,\n    with an overwhelming preference for bins that become perfectly full.\n    \"\"\"\n    # Initialize all priorities to a very low value. Bins that cannot fit the item\n    # will retain this lowest priority, ensuring they are not chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining space in bins where the item can fit.\n    # This is the core of the Best Fit strategy: find the bin that leaves the least space.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # The base priority for fitting bins is the negative of the potential remaining space.\n    # A smaller remaining space (closer to zero) results in a higher (less negative) priority.\n    priorities[can_fit_mask] = -potential_remaining_space\n\n    # Define constants for bonuses, based on the analysis emphasizing their importance.\n    # EPSILON for robust floating-point comparison of exact fits.\n    EPSILON = 1e-9\n    # PERFECT_FIT_BONUS is a very large additive bonus to ensure exact fits\n    # (or near-exact fits) are always chosen above any other option.\n    PERFECT_FIT_BONUS = 1e9\n\n    # Identify bins that would result in a perfect or near-perfect fit.\n    # This checks if the potential remaining space is negligibly close to zero.\n    exact_fit_mask = can_fit_mask & (np.abs(potential_remaining_space) < EPSILON)\n\n    # Apply the overwhelming bonus to exact fit bins.\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by Best Fit, with a strong bonus for exact fits and a minor bonus for consolidating partially-filled bins.\"\"\"\n\n    # Constants derived from analysis: very high bonus for exact fits, small bonus for consolidation.\n    # Assumes a standard bin capacity of 1.0 for identifying \"partially-filled\" bins.\n    BIN_CAPACITY = 1.0\n    PERFECT_FIT_BONUS = 1000.0\n    CONSOLIDATION_BONUS = 1.0\n\n    # Calculate remaining space if item were placed (Best Fit core).\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities. Bins that cannot fit the item get the lowest possible score.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Base priority: negative of potential remaining space (Best Fit).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    # Add a substantial bonus for exact fits.\n    exact_fit_mask = np.isclose(potential_remaining_space, 0.0) & can_fit_mask\n    priorities[exact_fit_mask] += PERFECT_FIT_BONUS\n\n    # Add a small, fixed bonus for placing items into already partially-filled bins.\n    # This encourages consolidation without being overly complex or dominant.\n    # A bin is considered partially-filled if its current remaining capacity is less than BIN_CAPACITY\n    # (meaning it's not a brand new empty bin) but greater than zero.\n    partially_filled_mask = (bins_remain_cap < BIN_CAPACITY) & (bins_remain_cap > 0) & can_fit_mask\n    priorities[partially_filled_mask] += CONSOLIDATION_BONUS\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]