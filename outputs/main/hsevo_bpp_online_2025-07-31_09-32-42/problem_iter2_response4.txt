```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for each bin, leveraging a robust Best Fit strategy.
    Prioritizes bins that minimize remaining space, using an inverse function for strong preference,
    and ensures numerical stability with epsilon. Non-fitting bins receive lowest priority.
    """
    # Initialize all priorities to negative infinity, unequivocally marking bins
    # that cannot accommodate the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the potential remaining space (waste) if the item were placed in fit-capable bins.
    potential_remaining_space = bins_remain_cap[can_fit_mask] - item

    # Add a small epsilon to the remaining space to ensure numerical stability when
    # dividing by very small numbers or zero (for perfect fits). This also provides
    # a consistently high, but finite, priority for perfect fits.
    epsilon = np.finfo(float).eps  # Smallest positive float for stability

    # Assign priority as the inverse of (potential remaining space + epsilon).
    # This non-linear relationship strongly favors bins that leave minimal space,
    # ensuring that perfect or near-perfect fits receive significantly higher scores.
    priorities[can_fit_mask] = 1.0 / (potential_remaining_space + epsilon)

    return priorities
```
