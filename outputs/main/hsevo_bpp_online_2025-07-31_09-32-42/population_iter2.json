[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive Best Fit: Prioritizes bins to minimize waste, with distinct high score for perfect fits and robust inverse for others.\"\"\"\n\n    # Initialize priorities to negative infinity. This explicitly excludes bins\n    # that cannot fit the item from consideration, making them the lowest possible priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can be placed.\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Calculate the potential remaining capacity (waste) after placing the item\n    # for only those bins that can accommodate it.\n    potential_remain_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Separate valid bins into two categories: perfect fits and non-perfect fits (some waste).\n    perfect_fit_mask = (potential_remain_after_fit == 0)\n    non_perfect_fit_mask = (potential_remain_after_fit > 0)\n\n    # 1. Prioritize perfect fits with a very high, distinct finite score.\n    # This guarantees they are chosen over any other fit while maintaining\n    # numerical stability (avoiding np.inf).\n    PERFECT_FIT_SCORE = 1e12  # A large number ensuring perfect fit dominance\n    priorities[can_fit_mask][perfect_fit_mask] = PERFECT_FIT_SCORE\n\n    # 2. For non-perfect fits, prioritize inversely to the remaining waste.\n    # A smaller waste yields a higher priority. A small epsilon is added\n    # to the denominator to ensure numerical stability, especially for very\n    # small positive waste values, preventing potential overflows.\n    STABILITY_EPSILON = 1e-9 # Ensures division by zero or near-zero is handled\n    priorities[can_fit_mask][non_perfect_fit_mask] = 1.0 / (potential_remain_after_fit[non_perfect_fit_mask] + STABILITY_EPSILON)\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a non-linear 'Best Fit' approach, emphasizing very\n    tight fits while robustly disqualifying bins that cannot fit the item.\n    \"\"\"\n    # Initialize priorities to negative infinity, ensuring bins unable to fit\n    # the item are unequivocally disqualified. This is a robust signal.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining space (waste) in suitable bins after placing the item.\n    # A smaller waste indicates a more efficient, tighter fit.\n    remaining_waste = bins_remain_cap[can_fit_mask] - item\n\n    # A small positive constant to ensure numerical stability and to assign a\n    # very high, finite priority to perfect fits (waste = 0). This creates\n    # a strong non-linear preference for bins that are nearly or perfectly full.\n    EPSILON = 1e-9\n\n    # Calculate priority as the inverse of (waste + epsilon).\n    # This non-linear function disproportionately rewards very small waste values,\n    # making perfect or near-perfect fits highly desirable.\n    priorities[can_fit_mask] = 1.0 / (remaining_waste + EPSILON)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best Fit with a non-linear inverse priority for tight fits.\n\n    Prioritizes bins by 1/(remaining_capacity + epsilon), giving strong preference\n    to very tight or perfect fits. Unsuitable bins get lowest priority (-inf).\n    \"\"\"\n    # Initialize all priority scores to negative infinity. This robustly\n    # disqualifies any bin that cannot fit the item, aligning with best practices.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can potentially fit (remaining capacity >= item size).\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity if the item were placed in the fitting bins.\n    # This is effectively the 'waste' for bins where the item fits.\n    potential_remaining_cap = bins_remain_cap[fitting_bins_mask] - item\n\n    # Define a small epsilon for numerical stability. This handles perfect fits (waste = 0)\n    # by assigning them a very high, but finite, priority (1/epsilon), and stabilizes\n    # the inverse calculation for extremely small positive wastes. This implements the\n    # \"1.0 / (remaining_waste + epsilon)\" strategy praised for its non-linear preference.\n    EPSILON = np.finfo(float).eps\n\n    # For bins where the item fits, calculate priority using the inverse of\n    # (potential_remaining_cap + EPSILON). A smaller remaining capacity (tighter fit)\n    # results in a proportionally larger priority score, strongly favoring tightest fits.\n    priority_scores[fitting_bins_mask] = 1.0 / (potential_remaining_cap + EPSILON)\n\n    return priority_scores",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin based on the Best Fit principle,\n    prioritizing tighter fits non-linearly with robust handling of perfect and non-fitting bins.\n    \"\"\"\n    # Initialize priorities to negative infinity, effectively disqualifying bins\n    # that cannot fit the item and ensuring they are never chosen by argmax.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # A non-negative value means the bin can fit the item.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Create a mask to identify only those bins that have sufficient capacity.\n    can_fit_mask = potential_remaining_cap >= 0\n\n    # Define a small epsilon to ensure numerical stability when remaining capacity is zero\n    # or very close to zero, and to give perfect fits a very high, finite priority.\n    epsilon = 1e-9\n\n    # For bins that can fit, assign a priority. The strategy is to give higher\n    # priority to bins that result in less remaining space. An inverse relationship\n    # (1 / x) achieves this, making smaller 'x' values result in larger priorities.\n    # Adding epsilon to 'x' (potential_remaining_cap) prevents division by zero\n    # for perfect fits and ensures a continuous, high priority for very tight fits.\n    valid_bin_priorities = 1.0 / (potential_remaining_cap[can_fit_mask] + epsilon)\n\n    # Apply the calculated priorities only to the bins that can actually fit the item.\n    priorities[can_fit_mask] = valid_bin_priorities\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin, leveraging a robust Best Fit strategy.\n    Prioritizes bins that minimize remaining space, using an inverse function for strong preference,\n    and ensures numerical stability with epsilon. Non-fitting bins receive lowest priority.\n    \"\"\"\n    # Initialize all priorities to negative infinity, unequivocally marking bins\n    # that cannot accommodate the item as unavailable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins have sufficient capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the potential remaining space (waste) if the item were placed in fit-capable bins.\n    potential_remaining_space = bins_remain_cap[can_fit_mask] - item\n\n    # Add a small epsilon to the remaining space to ensure numerical stability when\n    # dividing by very small numbers or zero (for perfect fits). This also provides\n    # a consistently high, but finite, priority for perfect fits.\n    epsilon = np.finfo(float).eps  # Smallest positive float for stability\n\n    # Assign priority as the inverse of (potential remaining space + epsilon).\n    # This non-linear relationship strongly favors bins that leave minimal space,\n    # ensuring that perfect or near-perfect fits receive significantly higher scores.\n    priorities[can_fit_mask] = 1.0 / (potential_remaining_space + epsilon)\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best Fit with strong preference for tight/perfect fits.\n    Uses inverse of remaining waste + epsilon for numerical stability,\n    and clear disqualification for unfit bins with -inf.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the remaining capacity (waste) if the item is placed.\n    # This value will be non-negative for bins where the item fits.\n    remaining_waste = bins_remain_cap[can_fit_mask] - item\n\n    # Add a small epsilon to the denominator for numerical stability.\n    # This prevents division by zero for perfect fits (waste = 0) and\n    # ensures very large, but finite, priority for them.\n    # It also handles very small positive waste values gracefully.\n    epsilon = np.finfo(float).eps\n\n    # The priority is the inverse of (remaining_waste + epsilon).\n    # This creates a strong non-linear preference: smaller waste yields\n    # disproportionately higher priority. Perfect fits receive the highest score (1/epsilon).\n    priorities[can_fit_mask] = 1.0 / (remaining_waste + epsilon)\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by aggressively seeking the tightest fit, mimicking a strong\n    gravitational pull towards minimal void. Perfect fits yield the highest score,\n    while non-fitting bins are given an infinitely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to negative infinity for all bins.\n    # This ensures that bins incapable of fitting the item are never chosen,\n    # providing robust handling of invalid options.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can physically accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins that can fit, calculate the 'void' that would remain.\n    # We add a small epsilon to ensure numerical stability, especially for perfect fits (void=0),\n    # preventing division by zero and allowing for a very high, but finite, priority score.\n    remaining_void = bins_remain_cap[can_fit_mask] - item\n    \n    # Define a small epsilon for numerical stability.\n    # This ensures that a perfect fit (remaining_void = 0) results in a very large,\n    # finite priority (1/epsilon), while also providing robust inverse scaling for\n    # extremely small positive remaining voids.\n    epsilon = 1e-9 \n\n    # Calculate priority: inversely proportional to the void space.\n    # This creates a strong non-linear preference for tighter fits, where\n    # smaller void leads to disproportionately higher priority, achieving\n    # the \"densest\" fit.\n    snugness_scores = 1.0 / (remaining_void + epsilon)\n\n    # Assign these calculated scores to the eligible bins in the priorities array.\n    priorities[can_fit_mask] = snugness_scores\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for online bin packing, strongly favoring tight fits with robust invalid bin handling.\n\n    This heuristic uses a non-linear reciprocal function for valid fits to prioritize\n    tighter placements, and sets an unequivocally low priority for bins where\n    the item cannot fit, ensuring robust selection.\n    \"\"\"\n    # Initialize all priority scores to a very low value (negative infinity).\n    # This ensures bins where the item does not fit are never selected,\n    # making the choice clear for numpy.argmax.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity for each bin if the item were placed in it.\n    # A negative value here means the item does not fit.\n    potential_remaining_capacity = bins_remain_cap - item\n\n    # Create a boolean mask to identify bins where the item can actually fit.\n    can_fit_mask = potential_remaining_capacity >= 0\n\n    # For bins where the item can fit, calculate their priority.\n    # We want to minimize the remaining capacity (potential_remaining_capacity).\n    # The reciprocal (1.0 / x) function provides a strong non-linear preference\n    # for smaller x (less remaining capacity).\n    # Add a small epsilon to the denominator for numerical stability and to ensure\n    # perfect fits (where potential_remaining_capacity is 0) receive a very high,\n    # but finite, priority score (1.0 / epsilon).\n    epsilon = np.finfo(float).eps  # A very small positive floating-point number\n\n    # Apply the reciprocal scoring to only the bins where the item fits.\n    # A perfect fit (0 remaining) will result in a score of 1.0 / epsilon, which is very high.\n    # Bins with slightly more remaining capacity will get progressively lower scores,\n    # but still higher than non-fitting bins.\n    priorities_for_fitting_bins = 1.0 / (potential_remaining_capacity[can_fit_mask] + epsilon)\n    priority_scores[can_fit_mask] = priorities_for_fitting_bins\n\n    return priority_scores",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for online bin packing, balancing tight fit preference and robustness.\n\n    Prioritizes bins using an inverse of remaining capacity, strongly favoring\n    tight fits (including perfect fits via an epsilon), and robustly disqualifies\n    bins that cannot accommodate the item using negative infinity.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This unequivocally disqualifies\n    # any bin that cannot fit the item, ensuring it's never chosen by np.argmax.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining space in each bin if the item were placed.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Define a small epsilon to ensure numerical stability when dividing by remaining space.\n    # For perfect fits (remaining space = 0), this ensures a very high, but finite, priority.\n    epsilon = 1e-9\n\n    # For bins where the item can fit:\n    # Assign a priority based on 1.0 / (remaining_space + epsilon).\n    # This non-linear function heavily favors bins that result in very little\n    # remaining space, pushing towards \"best fit\" with a strong preference for tight packing.\n    # A perfect fit (0 remaining space) will receive priority 1/epsilon (very high),\n    # while larger remaining spaces will yield lower priorities.\n    priorities[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a robust Best Fit strategy.\n    \n    Assigns high priority to bins that result in minimal remaining capacity,\n    using a 1/(waste + epsilon) non-linear score for strong preference\n    towards tight fits, and -inf for bins that cannot fit the item.\n    \"\"\"\n    # Initialize priorities for all bins to a very low value (-infinity).\n    # This ensures that any bin that cannot fit the item will have the lowest\n    # possible priority and will not be chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining space in each bin if the current item were placed there.\n    # A non-negative value means the item can fit; a negative value means it cannot.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Create a boolean mask to identify only those bins that can actually\n    # accommodate the current item (remaining space must be non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Define a small positive constant to ensure numerical stability.\n    # This epsilon is crucial to prevent division by zero when an item\n    # perfectly fills a bin (potential_remaining_space = 0). It ensures\n    # perfect fits get a very high, but finite, priority score.\n    epsilon = np.finfo(float).eps \n\n    # For the bins that can fit the item, calculate their priority.\n    # The heuristic uses an inverse relationship: smaller remaining space\n    # (after placing the item) results in a larger priority score.\n    # The `+ epsilon` makes `1.0 / (0 + epsilon)` a very large number,\n    # effectively giving perfect fits the highest possible priority among valid bins.\n    priorities[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]