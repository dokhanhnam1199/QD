```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Nikola Tesla's "Conduit of Efficiency" heuristic for online Bin Packing.
    This function embodies the principle of Best Fit, prioritizing bins that,
    after accommodating the item, would yield the most "efficient energy transfer"
    (i.e., minimal wasted space). It strives to snugly fill existing receptacles,
    leaving as little unused "potential" as possible.

    A unique "Tesla Coil Boost" is applied for perfect fits, indicating a
    maximally efficient utilization of a bin's capacity, an ideal state of energy.
    This ensures that perfectly filled bins are always the premier choice.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the potential remaining capacity if the item were placed in each bin.
    # A negative value here signifies that the item does not fit.
    potential_remaining_cap = bins_remain_cap - item

    # Initialize scores. Bins that cannot physically hold the item are assigned an
    # infinitely low priority, making them effectively unselectable.
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify the indices of bins where the item can actually fit.
    # We use a small epsilon tolerance to account for floating point inaccuracies
    # when checking if remaining capacity is non-negative.
    tolerance = np.finfo(float).eps * 10  # A small tolerance for near-zero checks
    can_fit_mask = potential_remaining_cap >= -tolerance

    # For bins that can fit the item, we apply the Best Fit scoring.
    # The Best Fit strategy aims to minimize the remaining capacity after placement.
    # To convert this into a "higher is better" priority score, we take the negative
    # of the potential remaining capacity. A smaller positive remainder (e.g., 0.1)
    # results in a score closer to zero (-0.1), which is higher than a larger
    # remainder (e.g., 10.0), which would result in a score of -10.0.
    scores[can_fit_mask] = -potential_remaining_cap[can_fit_mask]

    # Tesla Coil Boost: A significant bonus for "perfect fits".
    # A perfect fit represents the ultimate in efficiency, leaving no room for
    # wasted potential. We check for remaining capacity very close to zero using `np.isclose`.
    perfect_fit_mask = np.isclose(potential_remaining_cap, 0, atol=tolerance * 100)

    # Apply the boost only to bins that are both capable of fitting the item
    # and achieve a near-perfect fit.
    boost_eligible_mask = can_fit_mask & perfect_fit_mask

    if np.any(boost_eligible_mask):
        # A very large positive value ensures that perfect fits are always
        # ranked definitively above all other non-perfect fits.
        scores[boost_eligible_mask] += 1e12

    return scores
```
