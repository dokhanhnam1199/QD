```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic is inspired by the "Best Fit" strategy, aiming to
    place the item into the bin that will leave the least amount of
    remaining space, thereby "snugly" fitting items and preserving
    larger gaps for future larger items if possible, or tightly packing
    bins.

    The priority score is calculated such that a tighter fit (less remaining
    capacity after placing the item) results in a higher score (closer to zero).
    Bins where the item does not fit are assigned a very low (negative infinity)
    priority, ensuring they are never chosen.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher score indicates higher priority.
    """
    # Calculate the remaining capacity for each bin if the item were placed in it.
    # A negative value means the item does not fit.
    potential_remaining_capacity = bins_remain_cap - item

    # Initialize all priority scores to a very low value (e.g., negative infinity).
    # This ensures bins where the item does not fit are never selected.
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins the item can actually fit into.
    # A bin is suitable if its remaining capacity is greater than or equal to the item size.
    can_fit_mask = potential_remaining_capacity >= 0

    # For bins where the item can fit, calculate their priority.
    # We want to minimize the remaining capacity (potential_remaining_capacity).
    # To achieve this with a maximum selection, we take the negative of the
    # potential remaining capacity. A smaller positive remaining capacity
    # (e.g., 0.0 for a perfect fit) will result in a larger priority score
    # (e.g., 0.0), whereas a larger remaining capacity (e.g., 0.5) will
    # result in a smaller priority score (-0.5).
    priority_scores[can_fit_mask] = -potential_remaining_capacity[can_fit_mask]

    return priority_scores
```
