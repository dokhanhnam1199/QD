```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, using a Best Fit strategy.

    This heuristic aims to minimize the remaining capacity in a bin after an item is placed,
    effectively "tightening" the fit. Bins that cannot accommodate the item are given the
    lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more preferred bin.
    """
    # Calculate the remaining capacity if the item were placed in each bin.
    # For bins where item > current_capacity, this will result in a negative number.
    potential_remaining_cap = bins_remain_cap - item

    # Initialize priority scores for all bins to a very low value (-infinity).
    # This ensures that bins which cannot fit the item are never chosen.
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can actually fit (remaining capacity would be non-negative).
    fitting_bins_mask = potential_remaining_cap >= 0

    # For bins where the item fits, the priority is calculated.
    # We want to minimize 'potential_remaining_cap' for these bins.
    # To achieve this with a 'maximize' objective for priority score,
    # we use the negative of 'potential_remaining_cap'.
    # A potential_remaining_cap of 0 will yield a score of 0 (perfect fit, highest priority).
    # A larger potential_remaining_cap (e.g., 10) will yield a smaller score (e.g., -10),
    # correctly prioritizing tighter fits.
    priority_scores[fitting_bins_mask] = -potential_remaining_cap[fitting_bins_mask]

    return priority_scores
```
