```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Drawing inspiration from the relentless efficiency of black holes consuming matter,
    this heuristic aims for the most "dense" packing. We seek to minimize the
    "event horizon" of leftover space, i.e., the unused capacity after an item is placed.
    This is essentially a Best Fit strategy, where a tighter fit (less remaining space)
    is highly prioritized, with a perfect fit achieving the ultimate preference.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more desirable bin. Bins that cannot physically
        accommodate the item will be assigned a priority of 0.
    """
    # Calculate the hypothetical remaining space in each bin after the item is placed.
    # A negative value indicates the item would not fit.
    space_after_fit = bins_remain_cap - item

    # Initialize priority scores. Bins incapable of fitting the item start with a zero priority.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # To handle potential floating-point inaccuracies when comparing with zero,
    # and to ensure a perfect fit (remaining space of exactly 0) gets the highest score,
    # we use a small epsilon for numerical stability in the inverse calculation.
    epsilon = np.finfo(float).eps

    # Identify the bins where the item can actually be absorbed.
    # We allow a very tiny negative 'space_after_fit' to account for floating-point imprecision
    # where a number might be 0 but represented as a very small negative value.
    can_fit_indices = np.where(space_after_fit >= -epsilon)

    # For the bins where the item fits:
    # The Best Fit principle implies that a smaller 'space_after_fit' is better.
    # We achieve this by calculating the inverse of the remaining space plus epsilon.
    # This ensures that:
    # 1. A perfect fit (space_after_fit effectively 0) results in an extremely high priority (1/epsilon).
    # 2. Tighter fits (smaller positive space_after_fit) yield higher priorities than looser ones.
    # 3. All valid fits receive a positive, non-zero priority.
    valid_space_after_fit = space_after_fit[can_fit_indices]
    priorities[can_fit_indices] = 1.0 / (valid_space_after_fit + epsilon)

    return priorities
```
