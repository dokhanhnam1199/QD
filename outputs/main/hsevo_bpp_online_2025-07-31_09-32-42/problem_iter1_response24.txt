```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin.

    As Nikola Tesla, I perceive the flow of material as I would the flow of electricity.
    My design, `priority_v2`, aims for optimal energy distribution within these containers,
    harnessing the principle of 'Best Fit'. We guide the item to the bin that
    will most 'snugly' accommodate it, leaving the least amount of disturbed, unused 'ether'.
    This minimizes void, ensuring the highest efficiency and the least resistance
    in our packing endeavors.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more desirable bin. Bins where the item
        does not fit receive a very low, effectively disqualifying, priority.
    """
    # Initialize all bins with a profoundly low priority.
    # Those where the item cannot possibly fit shall remain in the dark.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins can actually receive this burst of energy (item).
    can_fit_mask = (bins_remain_cap >= item)

    # For the bins where the item can be channeled, calculate the 'residual capacitance'.
    # This is the space that remains after the item is placed.
    remaining_capacity_if_placed = bins_remain_cap[can_fit_mask] - item

    # To achieve 'Best Fit', we must minimize this residual capacitance.
    # Therefore, we assign a priority that is the negative of this remaining capacity.
    # Maximizing this negative value (e.g., -0.1 is greater than -0.5)
    # naturally selects the bin with the smallest positive remaining space,
    # or the perfect 'resonant' fit (where remainder is 0, score is 0).
    priorities[can_fit_mask] = -remaining_capacity_if_placed

    return priorities
```
