import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                *, # Enforce keyword-only arguments for new parameters
                initial_unfit_priority: float = -935812787.1319085,
                fit_threshold: float = 0.007897139321895308,
                remaining_space_priority_factor: float = 1.4385484626020624) -> np.ndarray:
    """Robust Best Fit heuristic that favors least remaining capacity.

    This function implements a highly effective Best Fit strategy by prioritizing bins
    that result in the smallest remaining capacity after placing the item. This simple,
    local rule naturally encourages filling bins and achieves consolidation without
    complex parameters or conflicting objectives, aligning with emergent behavior principles.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): An array of the remaining capacities of the bins.
        initial_unfit_priority (float, optional): The priority assigned to bins where the item
            cannot fit. Defaults to -np.inf to ensure these bins are never selected.
        fit_threshold (float, optional): The minimum allowed remaining capacity for an item
            to be considered 'fitting'. If potential_remaining_space is less than this,
            the item is considered not to fit. Defaults to 0.0.
        remaining_space_priority_factor (float, optional): A factor by which the potential
            remaining space is multiplied to determine the priority. A negative value
            (e.g., -1.0 for Best Fit) prioritizes smaller remaining space, while a
            positive value (e.g., 1.0 for Worst Fit) prioritizes larger remaining space.
            Defaults to -1.0.

    Returns:
        np.ndarray: An array of priority scores for each bin. Higher scores indicate
                    higher preference.
    """
    # Calculate the remaining space in each bin if the item were placed.
    # A smaller positive value here means a "better fit".
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to a specified value for bins that cannot fit.
    # This ensures that any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, initial_unfit_priority, dtype=float)

    # Create a boolean mask for bins where the item can actually fit
    # (remaining space is greater than or equal to the fit_threshold).
    can_fit_mask = potential_remaining_space >= fit_threshold

    # For bins where the item can fit, assign a priority based on the potential
    # remaining space, weighted by the specified factor.
    # By maximizing this value (when factor is negative), we effectively minimize
    # the potential remaining space. A perfect fit (0 remaining space) naturally
    # results in a priority of 0 (the highest possible when factor is -1),
    # embodying the "perfect fit" priority without explicit, hardcoded scores.
    priorities[can_fit_mask] = remaining_space_priority_factor * potential_remaining_space[can_fit_mask]

    return priorities
