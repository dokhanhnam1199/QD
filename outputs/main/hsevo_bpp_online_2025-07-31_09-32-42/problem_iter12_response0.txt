```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, implementing a variation of Worst Fit.

    This heuristic aims to select the bin that has the most remaining capacity before the item is
    placed (since item size is constant for comparison), effectively trying to keep bins
    as 'open' or 'empty' as possible for as long as possible. The primary goal is to distribute
    items widely, promoting an emergent behavior of balanced bin usage across the available
    containers, rather than aggressively filling and closing bins. This approach attempts to
    preserve larger contiguous spaces in bins, potentially beneficial for future larger items.

    This design adheres to the principle of "minimal, local decision rules where desired global
    outcomes emerge from their aggregate application," avoiding explicit global objectives or
    reliance on numerical infinities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Bins that cannot accommodate the item receive a low, fixed finite priority score.
    """
    # Initialize all priorities to a sufficiently low, but finite, number.
    # This ensures that any bin that cannot fit the item will have a lower priority
    # than any bin that can fit it, without relying on -infinity or other numerical mechanisms.
    LOW_PRIORITY = -1000.0
    priorities = np.full_like(bins_remain_cap, LOW_PRIORITY, dtype=float)

    # Create a boolean mask for bins where the item can actually fit.
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item can fit, assign a priority based directly on their
    # current remaining capacity. By maximizing this value, we are effectively choosing
    # the bin with the most remaining space (Worst Fit). This is a simple, local rule
    # that encourages spreading out items across bins, allowing the overall distribution
    # of items to emerge from these repeated local decisions.
    priorities[can_fit_mask] = bins_remain_cap[can_fit_mask]

    return priorities
```
