```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    inspired by Feynman's Principle of Least Action.

    In the context of bin packing, the "action" of placing an item into a bin
    can be conceptualized as the "wasted space" or "entropy generated" within that bin.
    A good strategy would be to choose the bin that minimizes this "action".

    Specifically, the "action" for a given bin is the empty space remaining
    in that bin after the item is placed (i.e., its final remaining capacity).
    We want to select the bin that leads to the smallest possible "action" (least waste).
    Therefore, the priority for a bin is set to be inversely proportional to this
    "action", plus a small epsilon to handle cases of perfect fit (zero remaining space)
    and ensure mathematical stability. This effectively implements a "Best Fit" heuristic
    with a strong non-linear preference for very tight fits.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a very low (negative infinity) priority,
        ensuring they are not selected unless no other bin is available.
    """
    # Initialize priorities for all bins to a very low value.
    # This ensures that bins incapable of holding the item are effectively excluded
    # from consideration by having the lowest possible priority.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask to identify which bins have enough remaining capacity
    # to accommodate the current item.
    can_fit_mask = bins_remain_cap >= item

    # For the bins that can fit the item, calculate the "action".
    # The "action" is defined as the amount of space that will be left over
    # in the bin after the item is placed. This is the value we aim to minimize.
    action_for_valid_bins = bins_remain_cap[can_fit_mask] - item

    # Add a small positive constant (epsilon) to the action.
    # This serves two purposes:
    # 1. Prevents division by zero if an item perfectly fits into a bin (action_for_valid_bins = 0).
    # 2. Ensures that a perfect fit results in an extremely high priority score,
    #    making it the most desirable outcome.
    epsilon = 1e-9 # A tiny value, much smaller than any item size

    # Calculate the priority for valid bins.
    # The priority is inversely proportional to the "action".
    # This means smaller actions (less wasted space) yield higher priorities,
    # in line with the Principle of Least Action where paths with minimal action
    # are overwhelmingly favored.
    priorities[can_fit_mask] = 1.0 / (action_for_valid_bins + epsilon)

    return priorities
```
