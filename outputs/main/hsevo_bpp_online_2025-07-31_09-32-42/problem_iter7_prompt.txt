{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes inverse waste for tight fits, with a subtle bonus for\n    bins already fuller. Uses machine epsilon for stability.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    can_fit_mask = bins_remain_cap >= item\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate the remaining capacity (waste) if the item is placed.\n    remaining_waste = bins_remain_cap[can_fit_mask] - item\n\n    # Use machine epsilon for robust numerical stability, as recommended by analysis.\n    epsilon = np.finfo(float).eps\n\n    # Core Best Fit (BF) priority: Inverse of (remaining_waste + epsilon).\n    # This provides a strong non-linear preference for perfect or very tight fits,\n    # consistent with the top-performing 'priority_v0' heuristic.\n    base_priority = 1.0 / (remaining_waste + epsilon)\n\n    # Adaptive / Global Utility Element:\n    # Introduce a subtle bonus for bins that are already more full (have less remaining capacity).\n    # This element aligns with \"Adaptive Logic\" and \"Global Utility\" advice by encouraging\n    # the closing of already utilized bins. It acts as a weighted tie-breaker or minor nudge\n    # when the primary Best Fit scores are very close.\n    # We assume a normalized bin capacity of 1.0, where `1.0 - bins_remain_cap` represents\n    # the portion of the bin that is already filled.\n    WEIGHT_FULLNESS_BONUS = 1e-7 # A small, tunable weight chosen to ensure this bonus\n                                 # is secondary and does not override the primary\n                                 # waste minimization unless scores are extremely close.\n\n    current_fullness = 1.0 - bins_remain_cap[can_fit_mask]\n    \n    fullness_bonus = WEIGHT_FULLNESS_BONUS * current_fullness\n    \n    # Combine the dominant Best Fit priority with the subtle fullness bonus.\n    priorities[can_fit_mask] = base_priority + fullness_bonus\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}