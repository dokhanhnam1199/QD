```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This function implements a "Best Fit" like heuristic for the online bin packing problem.
    It prioritizes bins that, after accommodating the item, would have the smallest
    remaining capacity. This strategy aims to "tightly pack" items into bins,
    reducing wasted space and minimizing the total number of bins used.

    Specific priority assignments:
    1. Perfect Fit: If an item exactly fills a bin, that bin receives the highest possible priority (infinity).
    2. Best Fit (non-perfect): For bins that can accommodate the item but will leave some space,
       the priority is inversely proportional to the remaining capacity after placing the item.
       A smaller remaining capacity results in a higher priority score.
    3. Impossible Fit: Bins that cannot fit the item are assigned the lowest possible priority (negative infinity).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the potential remaining space if the item were placed in each bin.
    # This value is positive if the item fits, zero for a perfect fit, and negative if it doesn't fit.
    potential_remaining_space = bins_remain_cap - item

    # Identify bins that can accommodate the item (remaining space >= 0)
    can_fit_mask = potential_remaining_space >= 0

    # Prioritize perfect fits: bins where item consumes all remaining capacity.
    perfect_fit_mask = (potential_remaining_space == 0) & can_fit_mask
    priorities[perfect_fit_mask] = float('inf')

    # Prioritize other valid fits: bins where item fits, but some space remains.
    # The score is 1 / (remaining_space). Smaller remaining space yields a higher score.
    other_fit_mask = (potential_remaining_space > 0) & can_fit_mask
    priorities[other_fit_mask] = 1.0 / potential_remaining_space[other_fit_mask]

    # Bins that cannot fit the item (potential_remaining_space < 0) already have -np.inf priority from initialization.

    return priorities
```
