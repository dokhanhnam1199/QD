```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines robust Best Fit with adaptive bin consolidation and explicit perfect fit prioritization.
    Prioritizes minimal waste, encourages using fuller bins, and ensures perfect fits are optimal.
    """
    # Initialize all priorities to negative infinity, unequivocally marking bins
    # that cannot accommodate the item as unavailable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins have sufficient capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return the initialized priorities.
    if not np.any(can_fit_mask):
        return priorities

    # --- Step 1: Calculate core Best Fit and Adaptive Consolidation scores ---

    # Potential remaining space (waste) if the item were placed in fit-capable bins.
    potential_remaining_space = bins_remain_cap[can_fit_mask] - item

    # Small epsilon for numerical stability, especially for near-zero remaining space.
    # This prevents division by zero and ensures very small waste values don't cause issues.
    EPSILON = np.finfo(float).eps

    # Core Best Fit Component: Assign priority as the inverse of (potential remaining space + epsilon).
    # This strongly favors bins that result in minimal remaining space (tightest fit).
    best_fit_scores = 1.0 / (potential_remaining_space + EPSILON)

    # Adaptive Consolidation Bias Component: Promote packing into already fuller bins.
    # This encourages overall bin consolidation, aiming to reduce the total number of bins used.
    # We use the maximum remaining capacity among *all* bins as a dynamic reference
    # for what an "empty" bin looks like in the current system state.
    max_rem_cap = np.max(bins_remain_cap)

    # Calculate the relative "fullness" of each fitting bin. A lower bins_remain_cap
    # indicates a fuller bin, resulting in a higher fullness score (closer to 1).
    # Add epsilon to denominator to prevent division by zero if max_rem_cap is 0.
    relative_fullness = (max_rem_cap - bins_remain_cap[can_fit_mask]) / (max_rem_cap + EPSILON)

    # Tunable weight for the consolidation bias. A small positive value ensures this
    # bias influences decisions without overpowering the primary waste minimization.
    CONSOLIDATION_BIAS_WEIGHT = 0.05

    # Combine the Best Fit score with the adaptive consolidation bias.
    # This forms the base priority for all fit-capable bins.
    priorities[can_fit_mask] = best_fit_scores + CONSOLIDATION_BIAS_WEIGHT * relative_fullness

    # --- Step 2: Explicitly boost perfect fits to ensure their absolute priority ---

    # Tolerance for identifying near-perfect fits to handle floating-point inaccuracies.
    # A small absolute value is used for robustness across different bin capacities/item sizes.
    PERFECT_FIT_TOLERANCE = 1e-9

    # A very high score to ensure perfect fits are chosen over any other option.
    # This value must be significantly larger than any possible score derived from Step 1
    # to guarantee that a perfect fit always receives the highest priority.
    PERFECT_FIT_SCORE = 1e30 

    # Identify perfect or near-perfect fits within the fitting bins.
    perfect_fit_mask_in_fitting = np.abs(potential_remaining_space) < PERFECT_FIT_TOLERANCE

    # Apply the super-high score to bins that are perfect fits.
    # This overrides any score calculated in Step 1 for these specific bins,
    # making perfect fits the unequivocally best choice.
    priorities[can_fit_mask][perfect_fit_mask_in_fitting] = PERFECT_FIT_SCORE

    return priorities
```
