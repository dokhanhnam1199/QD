```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a robust inverse-waste fit, naturally favoring
    perfect fits, combined with an additive consolidation bias. Avoids explicit
    epsilon or max scores for numerical stability and clearer logic.
    """
    BIN_CAPACITY = 1.0
    CONSOLIDATION_FACTOR = 0.1  # A small factor to encourage consolidation

    # Initialize all priorities to negative infinity. Bins that cannot fit the item
    # will retain this value, ensuring they are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Create a boolean mask for bins where the item can actually fit.
    # A tiny tolerance is still implicitly handled by np.where later, but the core
    # logic avoids explicit perfect fit checks for score calculation.
    can_fit_mask = potential_remaining_space >= 0 

    # If no bins can fit, return the initialized (all -inf) priorities.
    if not np.any(can_fit_mask):
        return priorities

    # Extract relevant data for bins where the item can fit.
    fitting_potential_rem_space = potential_remaining_space[can_fit_mask]
    fitting_bins_original_cap = bins_remain_cap[can_fit_mask]

    # Calculate the primary score: Inverse of (waste + 1).
    # Adding 1 to waste ensures no division by zero and results in scores > 0.
    # Perfect fits (waste=0) naturally get the highest primary score (1.0).
    fit_score = 1.0 / (fitting_potential_rem_space + 1.0)

    # Calculate current bin fullness: (BIN_CAPACITY - current_remaining_capacity) / BIN_CAPACITY.
    # This term acts as an additive bias, encouraging consolidation by slightly preferring
    # bins that are already well-filled, given similar fit scores.
    current_bin_fullness = (BIN_CAPACITY - fitting_bins_original_cap) / BIN_CAPACITY
    
    # Combine the fit score with the consolidation bias.
    # This forms a continuous priority function without discrete jumps for 'perfect fits'
    # but still naturally prioritizes them due to the inverse waste component.
    fitting_priorities = fit_score + CONSOLIDATION_FACTOR * current_bin_fullness

    # Update the main priorities array with the scores for fitting bins.
    priorities[can_fit_mask] = fitting_priorities

    return priorities
```
