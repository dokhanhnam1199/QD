```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for online bin packing, balancing tight fit preference and robustness.

    Prioritizes bins using an inverse of remaining capacity, strongly favoring
    tight fits (including perfect fits via an epsilon), and robustly disqualifies
    bins that cannot accommodate the item using negative infinity.
    """
    # Initialize all priorities to negative infinity. This unequivocally disqualifies
    # any bin that cannot fit the item, ensuring it's never chosen by np.argmax.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # Define a small epsilon to ensure numerical stability when dividing by remaining space.
    # For perfect fits (remaining space = 0), this ensures a very high, but finite, priority.
    epsilon = 1e-9

    # For bins where the item can fit:
    # Assign a priority based on 1.0 / (remaining_space + epsilon).
    # This non-linear function heavily favors bins that result in very little
    # remaining space, pushing towards "best fit" with a strong preference for tight packing.
    # A perfect fit (0 remaining space) will receive priority 1/epsilon (very high),
    # while larger remaining spaces will yield lower priorities.
    priorities[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)

    return priorities
```
