```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    implementing a Best-Fit-Preferential strategy with fragmentation avoidance.

    This heuristic extends Best Fit by heavily penalizing bins that would be left
    with a very small, potentially unusable amount of remaining capacity after
    the item is placed. It aims to prevent bin fragmentation and leave more
    "useful" space in bins that are not perfectly filled. This introduces an
    adaptive element, prioritizing not just the tightest fit, but also
    considering the quality of the remaining space for future items.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.
        bin_capacity: The total capacity of a single bin. This is crucial
                      for defining the threshold for "small, fragmented"
                      remaining space. Defaults to 1.0 if not specified.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores are designed such that:
        1. A perfect fit (remaining capacity = 0) receives the highest possible score.
        2. Bins that would be left with a small, 'fragmented' capacity (i.e.,
           a remainder too small to be generally useful but not zero) receive
           a significant penalty, making them less desirable than bins leaving
           larger, more usable space.
        3. Among other bins (those not leading to fragmentation or perfect fit),
           the Best Fit principle applies (prioritizing smaller remaining space).
        4. Bins that cannot accommodate the item receive the lowest possible priority (-inf).
    """

    # Calculate the remaining space in each bin if the item were placed.
    # A smaller positive value here means a "tighter fit".
    potential_remaining_space = bins_remain_cap - item

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # Get the potential remaining space only for bins where the item can fit.
    fitting_remaining_space = potential_remaining_space[can_fit_mask]

    # --- Scoring Logic ---

    # 1. Base Score: Apply the Best Fit principle (negative of remaining space).
    #    A perfect fit (0 remaining space) will result in a priority of 0 (highest base score).
    base_scores = -fitting_remaining_space

    # 2. Fragmentation Penalty: Identify and penalize "fragmented" remaining spaces.
    #    These are small, positive remaining capacities that are often hard to fill
    #    with subsequent items, leading to wasted space and potentially more bins.

    # Define a threshold for what constitutes a "small, fragmented" gap.
    # This is a fraction of the total bin capacity. For example, 10% of bin capacity.
    FRAGMENTATION_EPSILON_RATIO = 0.10  
    fragmentation_threshold = bin_capacity * FRAGMENTATION_EPSILON_RATIO

    # Define the magnitude of the penalty. This value should be large enough
    # to make a fragmented fit less desirable than most non-fragmented fits.
    # A value significantly greater than `bin_capacity` (the maximum possible base score magnitude)
    # ensures that a penalized score is worse than any non-penalized score.
    FRAGMENTATION_PENALTY_MAGNITUDE = bin_capacity * 2.0 

    # Apply penalty only if the remaining space is positive (i.e., not a perfect fit)
    # AND falls within the defined fragmentation threshold.
    is_fragmented_gap = (fitting_remaining_space > 0) & \
                        (fitting_remaining_space <= fragmentation_threshold)

    penalties = np.zeros_like(base_scores)
    penalties[is_fragmented_gap] = FRAGMENTATION_PENALTY_MAGNITUDE

    # Combine base scores with penalties.
    # Penalized scores will become significantly more negative, effectively
    # pushing them down the priority list.
    priorities[can_fit_mask] = base_scores - penalties

    return priorities
```
