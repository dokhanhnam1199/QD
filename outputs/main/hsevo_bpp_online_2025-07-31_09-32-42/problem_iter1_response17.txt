```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This strategy, inspired by the principle of "least action" or finding the most
    "stable" state, aims for a "Best Fit" approach. We want to place the item
    in a bin such that the remaining capacity after placement is minimized,
    thereby packing bins as densely as possible and reducing the need for new bins.

    For a bin to be considered, it must be able to accommodate the item. Among
    the valid bins, the one that results in the smallest amount of leftover
    space after the item is placed is given the highest priority. Bins that
    cannot fit the item are assigned an extremely low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the space left in each bin if the current item were placed there.
    # A value of zero or close to zero is ideal (a tight fit).
    # Negative values indicate the bin cannot fit the item.
    remaining_space_if_placed = bins_remain_cap - item

    # Initialize priorities for all bins to a very low value (effectively disqualifying them)
    # This ensures that bins which cannot fit the item are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that *can* fit the item.
    can_fit_mask = remaining_space_if_placed >= 0

    # For bins that can fit the item, we want to assign a priority such that
    # smaller remaining space leads to a higher priority.
    # The negative of `remaining_space_if_placed` achieves this:
    # - If remaining_space_if_placed = 0.0 (perfect fit), priority = 0.0 (highest for valid bins).
    # - If remaining_space_if_placed = 0.1 (tight fit), priority = -0.1.
    # - If remaining_space_if_placed = 0.5 (loose fit), priority = -0.5.
    # Maximizing this priority will pick the smallest positive remaining_space.
    valid_bin_priorities = -remaining_space_if_placed[can_fit_mask]

    # Apply these calculated priorities only to the bins that can fit the item.
    priorities[can_fit_mask] = valid_bin_priorities

    return priorities
```
