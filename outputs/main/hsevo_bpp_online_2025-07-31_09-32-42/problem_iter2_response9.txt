```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using a robust Best Fit strategy.
    
    Assigns high priority to bins that result in minimal remaining capacity,
    using a 1/(waste + epsilon) non-linear score for strong preference
    towards tight fits, and -inf for bins that cannot fit the item.
    """
    # Initialize priorities for all bins to a very low value (-infinity).
    # This ensures that any bin that cannot fit the item will have the lowest
    # possible priority and will not be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining space in each bin if the current item were placed there.
    # A non-negative value means the item can fit; a negative value means it cannot.
    potential_remaining_space = bins_remain_cap - item

    # Create a boolean mask to identify only those bins that can actually
    # accommodate the current item (remaining space must be non-negative).
    can_fit_mask = potential_remaining_space >= 0

    # Define a small positive constant to ensure numerical stability.
    # This epsilon is crucial to prevent division by zero when an item
    # perfectly fills a bin (potential_remaining_space = 0). It ensures
    # perfect fits get a very high, but finite, priority score.
    epsilon = np.finfo(float).eps 

    # For the bins that can fit the item, calculate their priority.
    # The heuristic uses an inverse relationship: smaller remaining space
    # (after placing the item) results in a larger priority score.
    # The `+ epsilon` makes `1.0 / (0 + epsilon)` a very large number,
    # effectively giving perfect fits the highest possible priority among valid bins.
    priorities[can_fit_mask] = 1.0 / (potential_remaining_space[can_fit_mask] + epsilon)

    return priorities
```
