import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 6.677292258915086e-06) -> np.ndarray:
    """Prioritizes bins using a non-linear 'Best Fit' approach, emphasizing very
    tight fits while robustly disqualifying bins that cannot fit the item.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): A NumPy array representing the remaining capacity
                                      in each bin.
        epsilon (float): A small positive constant to ensure numerical stability and to
                         assign a very high, finite priority to perfect fits (waste = 0).
                         This creates a strong non-linear preference for bins that are
                         nearly or perfectly full.

    Returns:
        np.ndarray: A NumPy array of priorities for each bin. Bins unable to fit
                    the item will have a priority of -np.inf.
    """
    # Initialize priorities to negative infinity, ensuring bins unable to fit
    # the item are unequivocally disqualified. This is a robust signal.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins have sufficient remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining space (waste) in suitable bins after placing the item.
    # A smaller waste indicates a more efficient, tighter fit.
    remaining_waste = bins_remain_cap[can_fit_mask] - item

    # Calculate priority as the inverse of (waste + epsilon).
    # This non-linear function disproportionately rewards very small waste values,
    # making perfect or near-perfect fits highly desirable.
    priorities[can_fit_mask] = 1.0 / (remaining_waste + epsilon)

    return priorities
