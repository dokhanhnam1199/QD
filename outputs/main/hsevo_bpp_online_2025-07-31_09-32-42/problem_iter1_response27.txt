```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, using a "Snugness Potential" heuristic.

    As Feynman might muse, when an item comes along, it's seeking its lowest "energy state" or
    the most "resonant cavity" within the existing bins. This means finding a bin where it
    fits most snugly, leaving the least amount of "void-energy" or wasted space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a more desirable, "snugger" fit. Bins that cannot
        accommodate the item will receive a priority score of zero.
    """
    
    # Calculate the 'potential remaining space' or 'void' that would be left in each bin
    # if the item were placed there. This is our "energy landscape".
    potential_void = bins_remain_cap - item
    
    # Initialize all priorities to a state of "unsuitability" (zero).
    # These are the bins that are either too small, or not yet evaluated for their snugness.
    priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)
    
    # Identify the 'accessible states' â€“ bins where the item can actually fit (positive or zero void).
    # These are the only bins where a meaningful "snugness potential" can be calculated.
    can_fit_mask = potential_void >= 0
    
    # For the accessible states, the "snugness potential" is inversely proportional to the void.
    # A smaller void implies a tighter, more "resonant" fit, leading to a higher priority.
    # We add a small epsilon to the void to prevent division by zero in the case of a perfect fit,
    # ensuring that a perfectly snug fit results in an exceptionally high, but finite, priority.
    
    epsilon = 1e-9  # A tiny "quantum fluctuation" to prevent division by zero.
    
    # Compute the "snugness potential" for suitable bins.
    # The smaller the 'potential_void', the larger the `1.0 / (potential_void + epsilon)` term,
    # thus prioritizing bins that are a "best fit".
    priorities[can_fit_mask] = 1.0 / (potential_void[can_fit_mask] + epsilon)
    
    return priorities
```
