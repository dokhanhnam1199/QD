```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which to add an item to each bin, implementing a multi-objective
    heuristic that prioritizes perfect fits, penalizes small "fragment" gaps,
    and otherwise behaves like Best Fit.

    This heuristic aims to:
    1. Strongly prioritize bins that result in a perfect fit (0 remaining capacity).
    2. Penalize bins that would be left with a very small, potentially unusable
       "fragment" capacity after placing the item. This discourages creating
       hard-to-fill gaps.
    3. For all other valid bins, revert to a Best Fit strategy, preferring bins
       that leave less remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score for each bin.
        A higher score indicates a higher priority for placing the item in that bin.
        Scores are designed such that:
        - Perfect fits receive the highest possible score.
        - Bins leaving a "small fragment" receive a lower score than standard Best Fit would,
          potentially making them less attractive than bins leaving larger but more useful gaps.
        - Bins that cannot accommodate the item receive the lowest possible priority (-inf).
    """
    # Define constants for heuristic tuning
    # These values can be adjusted based on problem characteristics or desired behavior.
    PERFECT_FIT_BONUS = 1000.0  # A very high bonus to ensure perfect fits are always chosen first.
    SMALL_GAP_THRESHOLD = 0.05  # Defines what constitutes a "small fragment" (e.g., 5% of a typical bin capacity).
                                # Assumes items and capacities are normalized, e.g., bin capacity is 1.0.
    SMALL_GAP_PENALTY_FACTOR = 5.0 # Multiplier for penalizing small gaps. Higher value means
                                  # more aggressive de-prioritization of fragments.

    # Initialize all priorities to negative infinity. This ensures that
    # any bin that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the potential remaining space in each bin if the item were placed.
    potential_remaining_space = bins_remain_cap - item

    # Create a boolean mask for bins where the item can actually fit (remaining space >= 0).
    can_fit_mask = potential_remaining_space >= 0

    # Extract the potential remaining space for only the bins where the item can fit.
    fitting_prs = potential_remaining_space[can_fit_mask]

    # Create a temporary array to store priorities for fitting bins.
    fitting_priorities = np.empty_like(fitting_prs)

    # 1. Prioritize Exact Fits (Highest Priority Tier)
    # Use np.isclose for robust floating-point comparison to zero.
    perfect_fit_mask_local = np.isclose(fitting_prs, 0.0)
    fitting_priorities[perfect_fit_mask_local] = PERFECT_FIT_BONUS

    # 2. Penalize Small, Non-Zero Fragments (Anti-Fragmentation Tier)
    # Identify bins where 0 < potential_remaining_space <= SMALL_GAP_THRESHOLD.
    # Exclude perfect fits, as they are handled by the highest priority rule.
    small_gap_mask_local = (fitting_prs > 0) & (fitting_prs <= SMALL_GAP_THRESHOLD)
    # For these small gaps, apply a stronger penalty than the standard Best Fit.
    # A negative score multiplied by a penalty factor makes it more negative, hence lower priority.
    fitting_priorities[small_gap_mask_local] = -fitting_prs[small_gap_mask_local] * SMALL_GAP_PENALTY_FACTOR

    # 3. Regular Fit (Standard Best Fit Tier)
    # These are bins where potential_remaining_space is larger than SMALL_GAP_THRESHOLD.
    regular_fit_mask_local = fitting_prs > SMALL_GAP_THRESHOLD
    # For these, apply the standard Best Fit logic: smaller remaining space is better (less negative score).
    fitting_priorities[regular_fit_mask_local] = -fitting_prs[regular_fit_mask_local]

    # Assign the calculated priorities back to the main priorities array for the fitting bins.
    priorities[can_fit_mask] = fitting_priorities

    return priorities
```
