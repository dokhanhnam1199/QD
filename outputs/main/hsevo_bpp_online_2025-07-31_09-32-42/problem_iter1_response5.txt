```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    As Galileo, I observe that the universe operates with an elegant efficiency,
    striving for perfect arrangement. So too should our packing. This 'Best Fit'
    heuristic dictates that we shall place the item into the bin where it fits
    most perfectly, leaving the smallest possible void. This maximizes the
    'snugness' of the fit, much like a planet finding its most harmonious orbit.
    By doing so, we ensure that less useful small gaps are created,
    reserving larger spaces in other bins for future, larger celestial bodies.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more desirable bin.
        Bins that cannot accommodate the item will receive a very low (negative infinity)
        priority, ensuring they are not chosen. Among those that can, the bin
        resulting in the smallest remaining capacity (i.e., the 'snugger' fit)
        will have the highest priority.
    """
    # Initialize priorities with a very low value. Bins that cannot fit the item
    # will retain this low priority.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining capacity for each bin if the current item were placed into it.
    remaining_if_placed = bins_remain_cap - item

    # Create a boolean mask for bins where the item can actually fit (remaining capacity >= 0).
    can_fit_mask = remaining_if_placed >= 0

    # For bins where the item fits, the priority is calculated as the negative of
    # the remaining space. This ingenious trick converts the minimization of
    # remaining space into a maximization of priority score:
    # A smaller positive remainder (closer to 0) will result in a larger (less negative)
    # priority score, hence prioritizing the 'snugger' fit.
    # For example:
    #   - If remaining_if_placed is 0 (perfect fit), priority becomes 0.
    #   - If remaining_if_placed is 2, priority becomes -2.
    #   - If remaining_if_placed is 5, priority becomes -5.
    # Maximizing these values will select the bin with remaining_if_placed closest to 0.
    priorities[can_fit_mask] = -remaining_if_placed[can_fit_mask]

    return priorities
```
