[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n    \"\"\"\n    # Initialize priority scores to negative infinity for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit.\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate priorities for fitting bins by combining two effective strategies:\n    # 1. Proportional Best Fit: `item / bins_remain_cap` (maximizes relative fill).\n    # 2. Smallest Fit: `-bins_remain_cap` (prioritizes bins with less remaining space to close them).\n    # The sum balances maximizing the item's proportional use of space with minimizing the bin's overall remaining space.\n    priorities[fitting_bins_mask] = \\\n        (item / bins_remain_cap[fitting_bins_mask]) + \\\n        (-bins_remain_cap[fitting_bins_mask])\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive Best Fit: Prioritizes bins maximizing relative fill, promoting efficient bin usage.\n    This heuristic favors bins where the item constitutes a larger proportion of the remaining capacity,\n    a strategy robustly outperforming Worst Fit by minimizing wasted space dynamically.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid in typical BPP.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the \"proportional utilization\" for the fitting bins.\n        # This score represents how much of the bin's *remaining* capacity the item will fill.\n        # A higher ratio (closer to 1.0) indicates a tighter, more efficient fit.\n        # This strategy is a powerful form of Best Fit, effectively balancing item size\n        # against available bin space. Perfect fits (item fills bin exactly) result in a score of 1.0.\n        priorities[fitting_mask] = item / bins_remain_cap[fitting_mask]\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using proportional fit, favoring those where the item\n    fills a larger percentage of remaining capacity. Ensures robustness for invalid items.\n    \"\"\"\n    # Robustness check: If the item size is non-positive, it's considered invalid.\n    # No bin should be chosen for such an item, returning negative infinity.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize all priorities to negative infinity. This ensures that bins\n    # where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item.\n    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item fits, assign a priority based on proportional utilization.\n    # This means item_size / bin_remaining_capacity. A higher ratio (closer to 1.0) indicates\n    # a 'snugger' proportional fit, aiming to maximize the relative fill of a bin.\n    # This directly implements the Best Fit strategy focusing on proportional utilization\n    # identified as highly effective. Division by zero is avoided because bins where item > 0\n    # and capacity is 0 will not be in the `can_fit_mask`.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive Best Fit (ABF) with remnant preference. Prioritizes perfect fits, then standard\n    best fit, while penalizing very small non-zero remnants to encourage more usable leftover space.\n    \"\"\"\n    if item <= 0:\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Core Best Fit: Prioritize bins by minimizing remaining space\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Adaptive Component: Penalize very small, non-zero remnants\n    # This constant (e.g., 5% of a typical bin capacity) needs tuning based on problem scale.\n    SMALL_REMNANT_THRESHOLD = 0.05 \n    # Penalty value to make small remnants less attractive than better fits.\n    PENALTY_VALUE = 0.1 \n\n    small_remnant_mask = (remaining_after_placement > 0) & \\\n                         (remaining_after_placement < SMALL_REMNANT_THRESHOLD) & \\\n                         fits_mask\n    priorities[small_remnant_mask] -= PENALTY_VALUE\n\n    # Absolute Highest Priority: Ensure perfect fits are always chosen first\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using a Best Fit (BF) strategy, prioritizing bins that result in the smallest remaining capacity after placement.\n    Handles invalid items by assigning the lowest priority.\n    \"\"\"\n    # Initialize priority scores with negative infinity for bins where the item cannot fit\n    # or if the item itself is invalid.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: items must have a positive size to be packable.\n    # If not, all bins remain at the lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Create a mask for bins where the item *can* fit (remaining capacity >= item size).\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the remaining capacity if the item were placed.\n    # A Best Fit strategy aims to minimize this remaining capacity (i.e., find the tightest fit).\n    # To assign higher priority to smaller remaining capacities, we take the negative of this value.\n    # Example: If remaining_capacity = 5, priority = -5. If remaining_capacity = 50, priority = -50.\n    # A value of -5 is higher (less negative) than -50, correctly prioritizing tighter fits.\n    potential_remainders = bins_remain_cap[fits_mask] - item\n    priorities[fits_mask] = -potential_remainders\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best-Fit with robust input handling and intuitive linear scoring,\n    prioritizing perfect fits to minimize wasted space.\n    \"\"\"\n    # Robustness check: Handle invalid item sizes (non-positive items).\n    # Such items cannot be packed, so all bins receive the lowest priority.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value. This ensures bins where the item\n    # cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the 'wasted space' (remaining capacity after placement)\n    # if the item were placed in each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Create a mask to identify only those bins where the item can fit (wasted_space >= 0).\n    can_fit_mask = wasted_space >= 0\n\n    # For bins that can accommodate the item, assign a priority score.\n    # The Best-Fit principle aims to minimize 'wasted_space'.\n    # We use a linear transformation: 1.0 - wasted_space.\n    # This design ensures:\n    # - A perfect fit (wasted_space = 0) receives the highest score of 1.0.\n    # - As wasted_space increases, the priority linearly decreases from 1.0.\n    # This scaling provides an intuitive interpretation while maintaining Best-Fit's\n    # relative preference for tighter fits.\n    priorities[can_fit_mask] = 1.0 - wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item using a robust Proportional Best Fit strategy.\n\n    Prioritizes bins by maximizing the proportion of their capacity filled by the item.\n    Handles invalid inputs (non-positive items) gracefully.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness (from priority_v0): non-positive items cannot be packed, assign lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit (similar to priority_v0 and implicitly in priority_v1's logic).\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply Proportional Best Fit strategy (refining a concept hinted in priority_v0's docstring):\n    # Prioritize bins that would be most \"filled up\" by the item relative to their current capacity.\n    # This promotes efficient use of space by maximizing `item / current_bin_capacity` for valid bins.\n    # Bins where the item fits will have `bins_remain_cap` >= `item` > 0, preventing division by zero.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using a 'Normalized Best Fit' strategy.\n\n    Combines Best Fit with normalized scoring. Prioritizes perfect fits (1.0).\n    Non-perfect fits are scored by `1 - (remainder / BinCapacity)`, ensuring\n    smaller remainders yield higher, interpretable scores (0, 1.0). Robustly\n    handles non-positive items.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle non-positive items; they cannot be packed.\n    if item <= 0:\n        return priorities\n\n    # Calculate potential remaining capacity for all bins after placing the item.\n    potential_remainders = bins_remain_cap - item\n\n    # Mask for bins where the item actually fits (remainder >= 0).\n    fits_mask = (potential_remainders >= 0)\n\n    # Separate masks for perfect fits and non-perfect fits.\n    perfect_fit_mask = fits_mask & (potential_remainders == 0)\n    non_perfect_fits_mask = fits_mask & (potential_remainders > 0)\n\n    # Assign the highest priority (1.0) to perfect fits.\n    priorities[perfect_fit_mask] = 1.0\n\n    # For bins where the item fits but not perfectly, calculate a score\n    # based on the remaining capacity, normalized to be between 0 and 1.0.\n    if np.any(non_perfect_fits_mask):\n        # Assume a standard maximum bin capacity of 1.0 for normalization,\n        # common in normalized Bin Packing Problem setups.\n        # This allows the score to represent \"utilization\" within the bin.\n        normalization_factor = 1.0 \n\n        # Score is 1.0 minus the remainder, normalized by the bin's total capacity.\n        # Smaller remainders result in scores closer to 1.0.\n        priorities[non_perfect_fits_mask] = (\n            1.0 - (potential_remainders[non_perfect_fits_mask] / normalization_factor)\n        )\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a robust Best Fit (BF) strategy.\n\n    Selects bins that minimize wasted space after placement, assigning higher\n    scores to tighter fits. Handles invalid items and non-fitting bins robustly.\n    \"\"\"\n    # Initialize all priorities to negative infinity, assuming no fit by default.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: If the item size is non-positive, it cannot be packed.\n    # All bins will effectively have infinite negative priority for such an item.\n    if item <= 0:\n        return priorities\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # This also helps identify which bins can actually fit the item (positive or zero remainder).\n    potential_remainders = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item fits (remainder is non-negative).\n    fits_mask = potential_remainders >= 0\n\n    # For bins where the item fits, apply the Best Fit logic:\n    # Prioritize bins that result in the smallest remaining capacity after placement.\n    # By taking the negative of the potential_remainders, a smaller positive remainder\n    # (e.g., 5) results in a higher (less negative) priority score (-5) compared to\n    # a larger remainder (e.g., 20) which results in a lower (more negative) score (-20).\n    priorities[fits_mask] = -potential_remainders[fits_mask]\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item to each bin using a Proportional Best Fit strategy.\n\n    Maximizes the item's proportion of a bin's remaining capacity, prioritizing bins where the item\n    fits most 'tightly' relative to the bin's current size. Includes robust input handling.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness: non-positive items cannot be packed, assign lowest priority.\n    # This element is directly adopted from the 'priority_v0' heuristic for safety.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit. This clear masking approach is similar to 'priority_v0'.\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply a \"Proportional Best Fit\" strategy, which the analysis indicated as highly effective\n    # (similar to \"Heuristic 1st\"). This aims to maximize the ratio of the item's size to the\n    # bin's remaining capacity, leading to efficient space utilization.\n    # bins_remain_cap[valid_bins_mask] will always be > 0 because item > 0 and fits.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for placing an item using a \"Best Fit with Gap Management\" strategy.\n\n    This heuristic extends the traditional Best Fit (BF) by incorporating\n    multi-criteria decision-making and simple feature engineering of the\n    resulting bin state. It aims to improve upon basic BF by:\n\n    1.  **Core Best Fit Principle:** Still prioritizes bins that leave less\n        remaining capacity (minimizing immediate waste).\n    2.  **Bin Closure Incentive:** Provides a significant bonus for bins that\n        become \"almost full\" or \"perfectly full\" after placing the item. This\n        encourages the efficient closure of bins, reducing the total number of\n        active bins and minimizing \"dead\" space across many bins.\n    3.  **Awkward Gap Deterrent:** Applies a moderate penalty for bins that are\n        left with an \"awkwardly small\" remaining capacity. These are gaps\n        that are too small for many subsequent items but too large to be\n        considered efficiently \"closed,\" potentially leading to fragmentation\n        and unused space.\n\n    Assumptions:\n    - Item sizes and bin capacities are normalized, such that the full bin capacity is 1.0.\n      (This allows for generic thresholds like 0.02 or 0.15 for gap analysis).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a more preferred bin. Bins where the item does\n        not fit are assigned -np.inf.\n    \"\"\"\n    # Assuming normalized item sizes and bin capacities, e.g., 0 to 1.\n    BIN_CAPACITY = 1.0\n\n    # Calculate the remaining capacity of each bin *after* placing the current item.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit principle:\n    # A smaller 'remaining_after_placement' is better, so we negate it to make it a higher priority.\n    # A perfect fit (remaining_after_placement = 0) gets a base priority of 0.\n    priorities = -remaining_after_placement\n\n    # --- Feature Engineering & Multi-criteria Adjustments ---\n    # These thresholds and values are empirical and can be fine-tuned for specific problem instances.\n\n    # Define thresholds for identifying different types of remaining gaps:\n    # EPSILON_CLOSE: If remaining capacity is below this, the bin is considered \"nearly full\" or \"closed\".\n    EPSILON_CLOSE = 0.02 * BIN_CAPACITY # e.g., 2% of bin capacity\n\n    # PENALTY_AWKWARD_START/END: If remaining capacity falls within this range, it's considered an \"awkward gap\".\n    PENALTY_AWKWARD_START = 0.05 * BIN_CAPACITY # e.g., 5% of bin capacity\n    PENALTY_AWKWARD_END = 0.15 * BIN_CAPACITY   # e.g., 15% of bin capacity\n\n    # Define the magnitude of bonuses/penalties:\n    # BONUS_CLOSE: A significant bonus to strongly favor closing a bin.\n    BONUS_CLOSE = 0.5 * BIN_CAPACITY # Large bonus to make closing a bin highly attractive.\n\n    # PENALTY_AWKWARD: A moderate penalty to discourage creating awkward, hard-to-fill gaps.\n    PENALTY_AWKWARD = 0.2 * BIN_CAPACITY # Sufficient to make awkward gaps less desirable than larger ones.\n\n    # 1. Apply bonus for 'closing' bins (remaining capacity is very small or zero)\n    # This promotes a strategy of consolidating items into fewer bins, making them\n    # \"closed\" for future large items and reducing overall fragmentation.\n    bonus_mask = (remaining_after_placement >= 0) & (remaining_after_placement <= EPSILON_CLOSE)\n    priorities[bonus_mask] += BONUS_CLOSE\n\n    # 2. Apply penalty for 'awkward' small gaps\n    # This discourages creating bins with remaining capacities that are too small\n    # to be easily used by subsequent items, yet not small enough to be efficiently filled.\n    # Such bins can become \"dead space\" if not managed.\n    penalty_mask = (remaining_after_placement > PENALTY_AWKWARD_START) & \\\n                   (remaining_after_placement < PENALTY_AWKWARD_END)\n    priorities[penalty_mask] -= PENALTY_AWKWARD\n\n    # Finally, set the priority to negative infinity for bins where the item does not fit.\n    # This ensures that these bins are never selected as valid options.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mutated priority function for online Bin Packing, incorporating a Best Fit strategy\n    with enhancements for bin completion and fragmentation avoidance.\n\n    This heuristic combines multiple criteria:\n    1.  **Best Fit Preference:** Prioritizes bins that result in the smallest remaining capacity\n        after placing the item. This is the primary driver for efficient space utilization.\n    2.  **Bin Completion Bonus:** Applies a significant bonus to bins that would become\n        completely full (or virtually full) after placing the item. This encourages \"closing\"\n        bins, reducing the number of active bins and potentially simplifying future decisions.\n    3.  **Small Gap Penalty:** Applies a penalty for bins where placing the item would leave\n        a very small, non-zero remaining capacity. Such tiny gaps can be difficult to fill\n        with subsequent items, leading to wasted space and fragmentation. This aims to\n        deter creating \"unusable\" leftover space.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         Assumed to be non-negative floats.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins where the item does not fit\n        are assigned -np.inf.\n    \"\"\"\n    # Define constants for heuristic parameters. These values might need tuning\n    # depending on the specific distribution of item sizes and bin capacities.\n    # Assumes a typical bin capacity is implicitly scaled, e.g., to 1.0.\n    EPSILON = 1e-9  # Tolerance for floating point comparisons (e.g., for \"perfect fit\")\n    PERFECT_FIT_BONUS = 1000.0 # Large bonus for a perfect fit to make it highly preferred\n    SMALL_GAP_THRESHOLD = 0.1 # Threshold for defining a \"small\" remaining capacity\n                              # (e.g., 0.1 means 10% of a common normalized bin capacity)\n    SMALL_GAP_PENALTY = -0.5  # Penalty applied if placing the item leaves a small, unusable gap\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit principle:\n    # A smaller remaining_after_placement (closer to 0) is better, so we take the negative.\n    # This means 0 remaining capacity gets a 0 score, 0.1 gets -0.1, etc.\n    priorities = -remaining_after_placement\n\n    # --- Apply Bin Completion Bonus ---\n    # Identify bins where the item fits perfectly or almost perfectly.\n    # This condition uses EPSILON to account for floating-point inaccuracies.\n    perfect_fit_mask = remaining_after_placement <= EPSILON\n\n    # Add a significant bonus to these bins. This ensures that perfect fits are\n    # prioritized above all other considerations (e.g., even above the small gap penalty\n    # if it were to accidentally apply to a near-perfect fit, though logically it shouldn't).\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Apply Small Gap Penalty ---\n    # Identify bins where the item fits, but leaves a small, non-zero remaining capacity.\n    # Such small gaps can lead to fragmentation.\n    small_unusable_gap_mask = (remaining_after_placement > EPSILON) & \\\n                              (remaining_after_placement < SMALL_GAP_THRESHOLD)\n\n    # Apply a penalty to these bins. This makes them less attractive than bins that\n    # either perfectly fit the item or leave a larger, potentially more usable space.\n    # The penalty value is critical: it should be strong enough to deter but not so strong\n    # that it prevents all small fits when no better option exists.\n    priorities[small_unusable_gap_mask] += SMALL_GAP_PENALTY\n\n    # --- Final Filtering for Non-Fitting Bins ---\n    # Set priority to negative infinity for bins where the item does not fit (i.e.,\n    # remaining_after_placement is negative). This ensures these bins are never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using an adaptive Best Fit strategy with a dynamic\n    preference for consolidating smaller items into already fuller bins.\n\n    This heuristic attempts to balance the Best Fit principle (minimizing wasted space per item)\n    with a strategy to reduce fragmentation, especially for smaller items. For small items,\n    it slightly prioritizes bins that are already more full (have less remaining capacity),\n    aiming to 'finish' those bins or prevent creation of many small gaps across new bins.\n    For larger items, it reverts closer to a pure Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assumption for Bin Capacity:\n    # In many online Bin Packing problems, bin capacities are normalized, often to 1.0.\n    # If the problem context implies a different fixed bin capacity, this value should be adjusted.\n    BIN_CAPACITY = 1.0\n\n    # Hyperparameter K:\n    # This constant controls the strength of the adaptive preference for fuller bins.\n    # A value of K=0 makes this function equivalent to the original Best Fit (priority_v1).\n    # Increasing K (e.g., from 0.1 to 1.0) intensifies the preference for fuller bins\n    # for smaller items. This value might need tuning for specific problem instances.\n    K = 0.5 \n\n    # Calculate remaining capacity after placing the item in each bin.\n    # This is crucial for identifying bins where the item fits.\n    remaining_after_placement = bins_remain_cap - item\n\n    # --- Core Priority Calculation ---\n    # The base of the priority score is (item - bins_remain_cap), which is equivalent to\n    # the negative of the remaining space after placement. This component drives the\n    # Best Fit behavior: higher score for less remaining space (closer to perfect fit).\n\n    # Adaptive Factor:\n    # This factor dynamically adjusts the influence of the bin's current fullness based on the item's size.\n    # - For smaller items (item << BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 1.0.\n    #   This means the adaptive_factor is larger, giving more weight to the 'bins_remain_cap' term.\n    #   The effect: a stronger preference for putting small items into bins that are already more full.\n    # - For larger items (item approaches BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 0.0.\n    #   This means the adaptive_factor is smaller, reducing the weight of the 'bins_remain_cap' term.\n    #   The effect: the priority calculation becomes very similar to pure Best Fit.\n    \n    # Ensure BIN_CAPACITY is not zero to prevent division by zero, though in BPP it's always positive.\n    adaptive_factor = K * (1.0 - item / BIN_CAPACITY) if BIN_CAPACITY > 0 else 0.0\n    \n    # The combined priority score:\n    # The first part (item - bins_remain_cap) is the standard Best Fit component.\n    # The second part (- adaptive_factor * bins_remain_cap) applies a penalty that is:\n    #   1. Larger (more negative) for bins with more remaining capacity (i.e., less full bins).\n    #   2. Scaled by 'adaptive_factor', meaning this penalty is more significant for smaller items.\n    # This synergistically pushes smaller items into already fuller bins while maintaining Best Fit\n    # for larger items.\n    priorities = (item - bins_remain_cap) - adaptive_factor * bins_remain_cap\n\n    # --- Handling Invalid Placements ---\n    # Crucially, any bin where the item cannot fit (resulting in negative remaining_after_placement)\n    # must be assigned the lowest possible priority (-np.inf) to ensure it is never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 149.21220582369367,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response3.txt_stdout.txt",
    "code_path": "problem_iter6_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns a priority score for each bin, combining Best Fit with a \"Bin Completion\" bias.\n\n    This heuristic aims to select a bin that:\n    1.  Fits the item (essential, bins where the item does not fit are assigned the lowest possible priority).\n    2.  Among valid fits, prioritizes Best Fit (leaving the least remaining capacity).\n    3.  Additionally, applies a \"Bin Completion\" bias. It gives a bonus to bins that are\n        already significantly full (i.e., have little remaining capacity before the item is placed).\n        This encourages \"finishing off\" bins that are closer to being full, leading to fewer\n        partially filled bins overall and potentially consolidating items more efficiently.\n        This represents an adaptive strategy, prioritizing a global state objective (bin consolidation)\n        alongside the immediate fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0, assuming\n                      items and bin capacities are normalized.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Base Best Fit priority:\n    # A perfect fit (remaining_after_placement = 0) gets the highest BF score (0).\n    # Less remaining capacity results in a higher score (closer to 0).\n    bf_priorities = -remaining_after_placement\n\n    # Calculate current occupancy ratio for each bin (before placing the item)\n    # This ratio ranges from 0 (empty bin) to 1 (full bin).\n    # We clip it to ensure values are within [0, 1] for robustness against potential\n    # floating point inaccuracies or unusual initial states (though usually not expected).\n    current_occupancy_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    current_occupancy_ratio = np.clip(current_occupancy_ratio, 0, 1)\n\n    # Bin Completion Bias:\n    # A bonus is applied based on how full the bin currently is.\n    # The fuller the bin (higher current_occupancy_ratio), the higher the bonus.\n    # This encourages packing items into bins that are already close to being completely filled.\n    # The weight 'beta' controls the influence of this bias. A higher beta means this bias\n    # has a stronger effect on the final priority, potentially shifting choices away from\n    # pure Best Fit if a less tight fit in an already full bin is available.\n    beta = 0.5  # Tunable parameter. A value of 0 effectively reverts to Best Fit.\n\n    completion_bonus = beta * current_occupancy_ratio\n\n    # Combine Best Fit priority with the completion bonus.\n    # The primary BF priority ensures valid fits are preferred and tighter fits are generally\n    # chosen. The completion bonus then adds a strategic layer to favor consolidating items\n    # into bins that are already well-utilized, aiming to reduce the total number of open bins.\n    priorities = bf_priorities + completion_bonus\n\n    # Finally, set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected, overriding any potential positive bonuses\n    # that might have been calculated for them (e.g., if a bin was already very full\n    # but the item still didn't fit).\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response4.txt_stdout.txt",
    "code_path": "problem_iter6_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Returns priority for each bin using an enhanced Best Fit strategy with an adaptive bias.\n\n    This heuristic extends the Best Fit (BF) strategy by incorporating two main adaptive biases:\n    1.  **Consolidation Bias (Near-Perfect Fit Bonus):** Strongly prioritizes bins where the item fits\n        almost perfectly, encouraging the \"finishing off\" of bins to consolidate items into fewer containers.\n    2.  **Anti-Fragmentation Bias (Small Item/Sliver Penalty):** For relatively small items, it subtly\n        penalizes placing them in bins if doing so would leave a very small, potentially unusable\n        \"sliver\" of remaining capacity. This aims to prevent the creation of many fragmented bins.\n\n    This approach combines the efficiency of BF with strategic considerations for the long-term\n    state of the bins, promoting better overall bin utilization and reducing wasted space.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a non-negative float.\n        bins_remain_cap: Array of remaining capacities for each bin. Assumed to be non-negative floats.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0, suitable for normalized problems.\n                      This parameter is crucial for defining relative thresholds.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins where the item does not fit are assigned -np.inf.\n    \"\"\"\n    if not isinstance(bins_remain_cap, np.ndarray):\n        bins_remain_cap = np.array(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity after hypothetically placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on Best Fit (minimize remaining space).\n    # A smaller positive 'remaining_after_placement' leads to a higher (less negative) score.\n    # A perfect fit (0 remaining) gets a score of 0.\n    priorities = -remaining_after_placement\n\n    # --- Adaptive Bias Parameters (Tunable) ---\n    # These parameters define what \"perfect fit\", \"small item\", and \"fragmenting sliver\" mean\n    # relative to the bin_capacity. Adjusting these values can fine-tune the heuristic's behavior.\n\n    # Tolerance for considering a fit \"near-perfect\" (e.g., remaining capacity is within 1% of bin_capacity)\n    perfect_fit_tolerance = 0.01 * bin_capacity\n\n    # Item is considered \"small\" if its size is less than this ratio of bin_capacity\n    small_item_threshold_ratio = 0.25\n\n    # A remaining space smaller than this ratio * bin_capacity is considered a \"fragmenting sliver\"\n    # that we might want to avoid creating with small items.\n    fragmentation_sliver_ratio = 0.05\n\n    # Bonuses and Penalties (scaled relative to bin_capacity for consistency)\n    # These values determine the strength of the adaptive biases.\n    # They should be significant enough to influence decisions for close BF scores\n    # but not so large as to consistently override a clearly better BF.\n    PERFECT_FIT_BONUS = 0.5 * bin_capacity  # Strong bonus for finishing a bin\n    FRAGMENTATION_PENALTY = 0.2 * bin_capacity # Penalty for creating small unusable spaces\n\n    # --- Apply Adaptive Biases ---\n\n    # 1. Consolidation Bias: Boost for Near-Perfect Fits\n    # If placing the item leaves very little capacity (including exactly zero), give a significant bonus.\n    # This encourages finishing off bins.\n    is_near_perfect_fit = (remaining_after_placement >= 0) & \\\n                          (remaining_after_placement <= perfect_fit_tolerance)\n    priorities[is_near_perfect_fit] += PERFECT_FIT_BONUS\n\n    # 2. Anti-Fragmentation Bias: Penalty for Small Items creating Slivers\n    # This applies if:\n    #   a) The item itself is relatively small.\n    #   b) Placing the item would leave a small, non-zero \"fragment\" in the bin\n    #      (i.e., remaining space is positive but below 'fragmentation_sliver_ratio').\n    # This discourages creating many bins with tiny, difficult-to-use residual capacities.\n    is_small_item = item < small_item_threshold_ratio * bin_capacity\n    is_fragmenting_sliver = (remaining_after_placement > perfect_fit_tolerance) & \\\n                            (remaining_after_placement < fragmentation_sliver_ratio * bin_capacity)\n\n    # Apply the penalty only when both conditions are met.\n    priorities[is_small_item & is_fragmenting_sliver] -= FRAGMENTATION_PENALTY\n\n    # --- Final Filter: Infeasible Bins ---\n    # Set priority to negative infinity for bins where the item does not fit (remaining capacity would be negative).\n    # This ensures these bins are never selected by the max priority mechanism.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]