```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    implementing a 'Best Fit' heuristic, aiming for maximum packing efficiency.
    Inspired by the meticulous work on DNA structure, this function prioritizes
    bins where the item fits most tightly, leaving the smallest remaining capacity.

    A higher priority score is given to a bin that, if the item were placed in it,
    would result in the least amount of wasted space (i.e., the smallest
    remaining capacity after accommodating the item). Bins that cannot fit
    the item are given the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        The bin that yields the highest (least negative) priority score is
        the one that offers the 'best fit'.
    """
    # Initialize all priorities to a very low value (effectively negative infinity)
    # This ensures that bins where the item cannot fit are never selected.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins where the item can actually fit
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item fits, calculate the remaining capacity after placement.
    # We want to minimize this remaining capacity (bins_remain_cap - item).
    # To convert this minimization problem into a maximization of priority,
    # we take the negative of the remaining capacity.
    # A smaller positive remaining capacity results in a larger (less negative) priority.
    # A perfect fit (0 remaining capacity) will yield the highest priority of 0.
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    return priorities
```
