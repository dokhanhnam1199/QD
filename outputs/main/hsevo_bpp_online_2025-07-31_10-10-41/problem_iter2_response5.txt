```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for adding an item to each bin, combining Best Fit's linearity
    with a normalized score.

    This heuristic prioritizes bins that result in the smallest remaining capacity
    (Best Fit principle). A perfect fit yields the highest score (1.0), and the
    priority linearly decreases as the "wasted space" (remaining capacity after
    placement) increases. Bins where the item does not fit receive -np.inf.
    This maintains the robustness of Best Fit while mapping scores to a more
    intuitive range where 1.0 is ideal.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.

    Return:
        Array of priority scores for each bin. Higher score is better.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the 'wasted space' (remaining capacity after placing the item)
    # for only those bins where the item fits.
    wasted_space_for_fits = bins_remain_cap[can_fit_mask] - item

    # Assign priorities based on wasted space.
    # A perfect fit (wasted_space = 0) results in a priority of 1.0.
    # As wasted_space increases, the priority linearly decreases from 1.0.
    # This effectively shifts and scales the original Best Fit score
    # (where a perfect fit was 0, and scores were non-positive)
    # to a range where 1.0 is the peak.
    priorities[can_fit_mask] = 1.0 - wasted_space_for_fits

    return priorities
```
