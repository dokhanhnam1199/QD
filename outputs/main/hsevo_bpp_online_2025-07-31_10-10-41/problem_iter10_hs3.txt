import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, 
                 no_fit_priority: float = -522322293269.44226, 
                 perfect_fit_epsilon: float = 1.9168952840261964e-07, 
                 perfect_fit_priority: float = 382668055389.5929, 
                 remaining_capacity_weight: float = -9.612783779357317) -> np.ndarray:
    """Prioritizes Best Fit, strongly favoring bins that achieve perfect item-bin fits.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): An array of remaining capacities for each bin.
        no_fit_priority (float): The priority score assigned to bins where the item does not fit.
                                 Default is negative infinity to ensure they are never chosen.
        perfect_fit_epsilon (float): Tolerance for floating-point comparison to identify perfect fits.
                                     A smaller value means stricter perfect fit.
        perfect_fit_priority (float): The priority score assigned to bins that achieve a perfect fit.
                                      Default is positive infinity to give them absolute highest priority.
        remaining_capacity_weight (float): The weight applied to the remaining capacity. A negative
                                           value transforms remaining capacity (which we want to minimize)
                                           into a priority score (which we want to maximize). Default is -1.0.

    Returns:
        np.ndarray: An array of priority scores for each bin. Higher scores indicate better fit.
    """

    # Calculate the remaining capacity after placing the item in each bin.
    # A smaller positive value indicates a better fit (less wasted space).
    remaining_after_placement = bins_remain_cap - item

    # Initialize priority scores. Best Fit strategy aims to minimize remaining capacity,
    # so we negate it (or multiply by a negative weight) to transform into a maximization problem.
    priorities = remaining_capacity_weight * remaining_after_placement

    # For bins where the item does not fit (remaining_after_placement would be negative),
    # assign the lowest possible priority (`no_fit_priority`) to ensure they are never chosen.
    priorities[remaining_after_placement < 0] = no_fit_priority

    # Apply a strong bonus for perfect fits: if an item perfectly fills a bin (remaining capacity is zero
    # or very close to zero due to floating-point precision), give it the absolute highest priority.
    # This aligns with the strategy of completing bins whenever possible.
    perfect_fit_mask = np.abs(remaining_after_placement) < perfect_fit_epsilon
    priorities[perfect_fit_mask] = perfect_fit_priority

    return priorities
