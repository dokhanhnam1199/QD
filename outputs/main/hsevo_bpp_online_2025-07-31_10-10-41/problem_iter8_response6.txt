```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by minimizing remaining capacity (Best Fit). Awards infinite
    priority to perfect fits, ensuring optimal bin utilization for exact matches.
    """
    # Initialize all priorities to a very low value. Bins are undesirable or unusable by default.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Robustness check: Items with non-positive sizes are invalid and cannot be placed.
    if item <= 0:
        return priorities

    # Identify all bins where the current item can physically fit.
    fitting_mask = bins_remain_cap >= item

    # Proceed only if there's at least one bin where the item can fit.
    if np.any(fitting_mask):
        # Calculate the remaining capacity if the item were placed in each fitting bin.
        # This is the core of the Best Fit strategy: find the bin that minimizes this remainder.
        remaining_after_fit = bins_remain_cap[fitting_mask] - item

        # Assign a priority score such that smaller remaining capacities get higher scores.
        # By negating the remainder, we transform minimizing a positive value into maximizing a negative value (closer to zero).
        priorities[fitting_mask] = -remaining_after_fit

        # Strongly prioritize perfect fits by assigning them an infinite score.
        # This encourages completing bins whenever an item perfectly fills one,
        # aligning with the goal of maximizing bin utilization and preventing tiny remnants.
        perfect_fit_mask = (remaining_after_fit == 0)
        if np.any(perfect_fit_mask):
             priorities[fitting_mask][perfect_fit_mask] = np.inf

    return priorities
```
