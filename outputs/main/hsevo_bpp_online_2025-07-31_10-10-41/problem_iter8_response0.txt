```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes Best Fit, strongly favoring bins that achieve perfect item-bin fits."""

    # Calculate the remaining capacity after placing the item in each bin.
    # A smaller positive value indicates a better fit (less wasted space).
    remaining_after_placement = bins_remain_cap - item

    # Initialize priority scores. Best Fit strategy aims to minimize remaining capacity,
    # so we negate it to transform into a maximization problem (higher score = better).
    priorities = -remaining_after_placement

    # For bins where the item does not fit (remaining_after_placement would be negative),
    # assign the lowest possible priority (-infinity) to ensure they are never chosen.
    priorities[remaining_after_placement < 0] = -np.inf

    # Apply a strong bonus for perfect fits: if an item perfectly fills a bin (remaining capacity is zero
    # or very close to zero due to floating-point precision), give it the absolute highest priority.
    # This aligns with the strategy of completing bins whenever possible.
    epsilon = 1e-9  # Tolerance for floating-point comparison
    perfect_fit_mask = np.abs(remaining_after_placement) < epsilon
    priorities[perfect_fit_mask] = np.inf

    return priorities
```
