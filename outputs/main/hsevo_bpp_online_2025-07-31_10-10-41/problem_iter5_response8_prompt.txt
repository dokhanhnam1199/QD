{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Smallest Fit (SF) strategy.\n\n    Bins with the smallest current remaining capacity (among those where the item fits) get the highest priority.\n    This aims to \"fill up\" bins that are already partially used, prioritizing them over larger, emptier bins,\n    while still ensuring the item fits. Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores with negative infinity for bins where the item cannot fit\n    # and a temporary value for bins where it can fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find bins where the item fits\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, assign a priority based on their *current* remaining capacity.\n    # We want to prioritize bins with smaller remaining capacity (i.e., those that are more full).\n    # To do this, we take the negative of the bins_remain_cap.\n    # A smaller bins_remain_cap (e.g., 20) results in a larger (less negative) priority score (-20)\n    # compared to a larger bins_remain_cap (e.g., 100) which results in a smaller (more negative) score (-100).\n    priorities[fits_mask] = -bins_remain_cap[fits_mask]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    item: float,\n    bins_remain_cap: np.ndarray,\n    item_min_threshold: float = 0.05592199795804799,\n    priority_if_invalid: float = -53305.26486232452,\n    priority_score_max: float = 4.066753785007031,\n    priority_score_min: float = -0.7758139363388836) -> np.ndarray:\n    \"\"\"Returns priority, favoring tightest fits (Best Fit) with a normalized scale.\n\n    This heuristic prioritizes bins that minimize wasted space, assigning higher scores\n    to tighter linear fits (priority_score_min to priority_score_max, with priority_score_max being a perfect fit).\n    Bins incapable of holding the item receive the lowest possible priority, ensuring robustness.\n    \"\"\"\n    # Robustness check: Items less than or equal to 'item_min_threshold' are typically not valid in BPP.\n    if item <= item_min_threshold:\n        return np.full_like(bins_remain_cap, priority_if_invalid)\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we observe a fundamental difference in strategy. Heuristic 1st implements a Best Fit (BF) strategy focusing on *proportional utilization* (`item / bins_remain_cap`), aiming to maximize the relative fill of a bin. Its docstring clarifies its mathematical equivalence in rank order to standard BF, suggesting it's a strong performer for tight packing. In contrast, Heuristic 20th employs a Worst Fit (WF) strategy (`remaining_after_placement`), aiming to keep bins as \"open\" as possible by maximizing leftover space. The ranking clearly indicates BF (proportional) is vastly superior to WF for typical bin packing objectives.\n\nComparing (2nd) vs (19th), Heuristic 2nd presents a robust Best Fit (BF) strategy (minimizing absolute remaining capacity via `-remaining_after_fit`). A key improvement here is the explicit robustness check for `item <= 0`, ensuring invalid inputs are handled gracefully. Heuristic 19th is another instance of the Worst Fit strategy, identical to 20th. This comparison reinforces the strong performance of BF over WF, and highlights the value of input validation for robustness.\n\nComparing (3rd) vs (4th), both implement Best Fit (minimizing absolute remaining capacity). Heuristic 3rd includes the `if item <= 0` robustness check and uses a distinct `potential_remainders` variable, making the logic flow very clear. Heuristic 4th achieves the same core calculation (`-remaining_after_placement`) but lacks the explicit `item <= 0` check and reassigns non-fitting priorities after an initial calculation. The higher ranking of 3rd suggests that explicit robustness checks and perhaps a slightly cleaner code structure (masking first, then calculating) are preferred.\n\nComparing (5th) vs (16th), Heuristic 5th employs a Smallest Fit (SF) strategy, prioritizing bins with the smallest *current* remaining capacity (`-bins_remain_cap`). This aims to \"fill up\" bins quickly. Heuristic 16th is a Worst Fit strategy. The ranking shows SF is considerably better than WF, indicating that focusing on filling existing bins (even if not perfectly) is more effective than leaving large gaps.\n\nComparing (11th) vs (12th), we find that these heuristics are identical and incomplete, merely performing an `item_min_threshold` check and returning a fixed invalid priority. They lack any actual packing logic. Their low ranking (11th-15th) signifies that a partially implemented or non-functional heuristic is severely penalized, ranking below even the traditionally poorer-performing Worst Fit strategies. This block of identical, incomplete functions highlights that basic functionality and completeness are paramount.\n\nOverall, the ranking strongly suggests that Best Fit variants (both proportional and absolute) are the most effective strategies for this Bin Packing context, likely due to their goal of minimizing wasted space. Robustness checks for invalid inputs contribute positively to a heuristic's perceived quality. Smallest Fit is a viable but less performant alternative to Best Fit. Worst Fit is consistently the least effective full strategy, and incomplete/broken code is the worst possible outcome. Simplicity in scaling and calculation often correlates with higher performance over overly complex, numerically fine-tuned approaches.\n- \nHere's the redefined 'Current self-reflection' for designing better bin packing heuristics:\n\n*   **Keywords:** Adaptive Strategies, Global State Inference, Feature Engineering, Multi-criteria Optimization.\n*   **Advice:** Focus on heuristics that dynamically adapt their logic based on current problem characteristics. Explore synergistic combinations of diverse packing rules. Prioritize leveraging comprehensive information about the system's global state and future implications, not just immediate fits.\n*   **Avoid:** Relying on fixed, static rules (e.g., Best Fit). Preconceived notions about the superiority of simple linear or non-linear functions for priority. Making performance claims based on limited empirical observations or specific algorithm names.\n*   **Explanation:** This approach encourages exploring a broader design space, developing more robust and intelligent heuristics by considering the evolving problem context and integrating richer information, leading to genuinely novel solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}