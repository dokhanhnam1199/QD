```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    using a Best Fit strategy with strong additive incentives for perfect fits (bin completion).

    Bins where the item fits perfectly get a very high positive priority, effectively
    prioritizing bin completion. Among bins where the item fits but not perfectly,
    those leaving less remaining capacity are preferred (Best Fit). Bins where the item
    does not fit are assigned the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Parameter for tuning: The magnitude of the bonus for a perfect fit.
    # This value should be significantly larger than any negative score achievable
    # from the Best Fit component, to ensure perfect fits are always prioritized.
    # For example, if bin capacities are typically normalized to 1.0, the base scores
    # will range from 0 (perfect fit) down to -1.0. A bonus of 100 ensures it's always the highest.
    PERFECT_FIT_BONUS = 100.0

    # Calculate the remaining capacity after placing the item in each bin
    remaining_after_placement = bins_remain_cap - item

    # Initialize priorities to a very low value (-np.inf) for bins where the item cannot fit.
    # This ensures they are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins where the item fits (remaining capacity is non-negative).
    # This ensures we only consider valid placements.
    fits_mask = remaining_after_placement >= 0

    # Apply the Best Fit logic for bins where the item fits:
    # Prioritize bins that leave less remaining capacity.
    # A smaller remaining_after_placement value means a better fit (closer to zero).
    # To maximize this as a priority score, we take the negative of remaining_after_placement.
    # So, a perfect fit (remaining_after_placement = 0) gets a base priority of 0.
    # A near-perfect fit (e.g., remaining_after_placement = 0.1) gets -0.1.
    priorities[fits_mask] = -remaining_after_placement[fits_mask]

    # Additive Incentive: Apply a significant bonus for perfect fits (bin completion).
    # Use np.isclose for robust floating-point comparison with zero, as direct == 0 can be problematic.
    perfect_fit_mask = np.isclose(remaining_after_placement, 0, atol=1e-9)

    # The bonus is added to the base score (which would be 0 for a perfect fit).
    # This ensures that any bin where the item perfectly fills the remaining capacity
    # receives a score much higher than any other non-perfect fit.
    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS

    return priorities
```
