[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes Best Fit, strongly favoring bins that achieve perfect item-bin fits.\"\"\"\n\n    # Calculate the remaining capacity after placing the item in each bin.\n    # A smaller positive value indicates a better fit (less wasted space).\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores. Best Fit strategy aims to minimize remaining capacity,\n    # so we negate it to transform into a maximization problem (higher score = better).\n    priorities = -remaining_after_placement\n\n    # For bins where the item does not fit (remaining_after_placement would be negative),\n    # assign the lowest possible priority (-infinity) to ensure they are never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    # Apply a strong bonus for perfect fits: if an item perfectly fills a bin (remaining capacity is zero\n    # or very close to zero due to floating-point precision), give it the absolute highest priority.\n    # This aligns with the strategy of completing bins whenever possible.\n    epsilon = 1e-9  # Tolerance for floating-point comparison\n    perfect_fit_mask = np.abs(remaining_after_placement) < epsilon\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using Best Fit with bonuses for perfect fits and near-full bins.\n\n    This heuristic combines the effectiveness of Best Fit with specific incentives for\n    bin consolidation, avoiding complex adaptive factors.\n    \"\"\"\n    BIN_CAPACITY = 1.0  # Assumed normalized bin capacity, adjust if problem implies otherwise\n\n    # Robustness check: If the item size is non-positive, it's invalid.\n    # No bin should be chosen, so return negative infinity for all.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Initialize all priorities to negative infinity. This ensures that bins\n    # where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify all bins capable of containing the incoming item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate base priority for fitting bins using a Best Fit approach.\n    # The goal is to maximize `-(remaining_capacity_after_placement)`.\n    # This means smaller remaining space (better fit) yields a higher score (closer to 0 or positive).\n    # A perfect fit (0 remaining) gets a base score of 0.\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    # --- Apply Bonuses to Enhance Bin Consolidation ---\n\n    # 1. Perfect Fit Bonus: Substantially prioritize bins where the item\n    #    perfectly fills the remaining capacity. This is a strong, but finite, bonus.\n    PERFECT_FIT_BONUS = 100.0  # Tunable constant\n    perfect_fit_mask = (remaining_after_placement == 0)\n    if np.any(perfect_fit_mask):\n        priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # 2. Bin Near-Completion Bonus (pre-placement): Encourage using bins that are\n    #    already significantly full *before* the item is placed. This helps\n    #    consolidate items into existing bins and potentially close them off.\n    #    The bonus is proportional to the bin's current fullness (0 to 1).\n    FULLNESS_BONUS_FACTOR = 0.5  # Tunable constant, controls strength of this incentive\n    if BIN_CAPACITY > 0: # Ensure valid division\n        current_fullness = (BIN_CAPACITY - bins_remain_cap[can_fit_mask]) / BIN_CAPACITY\n        priorities[can_fit_mask] += FULLNESS_BONUS_FACTOR * current_fullness\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Prioritizes Best Fit, adds a bonus for bin consolidation, and gives highest priority to perfect fits.\n    \"\"\"\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Base Best Fit priority: A smaller positive remaining capacity yields a higher score.\n    bf_priorities = -remaining_after_placement\n\n    # Bin Completion Bonus: Encourage filling up existing bins by giving a bonus\n    # based on current occupancy (before placing the item).\n    current_occupancy_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    current_occupancy_ratio = np.clip(current_occupancy_ratio, 0, 1)\n\n    beta = 0.5  # Tunable parameter for the influence of the completion bias.\n    completion_bonus = beta * current_occupancy_ratio\n\n    # Combine Best Fit priority with the completion bonus\n    priorities = bf_priorities + completion_bonus\n\n    # Perfect Fit Bonus: Strongly prioritize bins that result in a perfect fit.\n    # Use a small tolerance for floating-point comparisons.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0, atol=1e-9)\n    priorities[perfect_fit_mask] = np.inf\n\n    # Finally, set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected, overriding any other calculated bonuses.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit prioritizing minimal remaining space, with an absolute bonus for perfect fits.\n    \"\"\"\n    if item <= 0:\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Core Best Fit: Prioritize bins by minimizing remaining space\n    # This means maximizing -remaining_after_placement for valid fits.\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Absolute Highest Priority: Ensure perfect fits are always chosen first.\n    # This strongly encourages bin completion.\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with strong prioritization for perfect fits and a bonus for near-perfect fits.\n    \"\"\"\n    # Initialize all priorities to negative infinity, indicating bins where item cannot fit initially.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: items must have a positive size to be packable.\n    if item <= 0:\n        return priorities\n\n    # Calculate the remaining capacity for each bin if the item were placed.\n    potential_remainders = bins_remain_cap - item\n\n    # Create a mask for bins where the item *can* physically fit.\n    fits_mask = potential_remainders >= 0\n\n    # 1. Core Best Fit (BF) Strategy:\n    # For bins where the item fits, calculate the priority as the negative of the remaining space.\n    # This means smaller remaining space (tighter fit) results in a higher (less negative) priority.\n    priorities[fits_mask] = -potential_remainders[fits_mask]\n\n    # 2. Strong Prioritization for Perfect Fits:\n    # If an item perfectly fills a bin (remainder is exactly zero), assign the highest possible priority.\n    # This leverages the insight that perfect fits are highly desirable.\n    perfect_fit_mask = (potential_remainders == 0) & fits_mask\n    priorities[perfect_fit_mask] = np.inf\n\n    # 3. Additive Bonus for Near-Perfect Fits (Bin Completion Incentive):\n    # Apply a significant, but not infinite, bonus for bins that are left with\n    # a very small amount of remaining capacity after placement. This encourages\n    # 'completing' bins by leaving minimal waste.\n    # EPSILON defines what \"very small\" means for remaining capacity.\n    EPSILON = 1e-6 \n    BONUS_FOR_NEAR_PERFECT = 1000.0 # A substantial bonus to elevate these fits\n\n    near_perfect_fit_mask = (potential_remainders > 0) & (potential_remainders <= EPSILON) & fits_mask\n    priorities[near_perfect_fit_mask] += BONUS_FOR_NEAR_PERFECT\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with explicit incentives: significant bonus for perfect fits to\n    complete bins, and a penalty for creating small, unusable gaps, prioritizing efficient\n    space utilization and bin consolidation.\n    \"\"\"\n    # Define constants for heuristic parameters. These values might need tuning\n    # depending on the specific distribution of item sizes and bin capacities.\n    # Assumes a typical bin capacity is implicitly scaled, e.g., to 1.0.\n    EPSILON = 1e-9  # Tolerance for floating point comparisons (e.g., for \"perfect fit\")\n    PERFECT_FIT_BONUS = 1000.0 # Large bonus for a perfect fit to make it highly preferred\n    SMALL_GAP_THRESHOLD = 0.1 # Threshold for defining a \"small\" remaining capacity\n                              # (e.g., 0.1 means 10% of a common normalized bin capacity)\n    SMALL_GAP_PENALTY = -0.5  # Penalty applied if placing the item leaves a small, unusable gap\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit principle:\n    # A smaller remaining_after_placement (closer to 0) is better, so we take the negative.\n    # This means 0 remaining capacity gets a 0 score, 0.1 gets -0.1, etc.\n    priorities = -remaining_after_placement\n\n    # --- Apply Bin Completion Bonus ---\n    # Identify bins where the item fits perfectly or almost perfectly.\n    # This condition uses EPSILON to account for floating-point inaccuracies.\n    perfect_fit_mask = remaining_after_placement <= EPSILON\n\n    # Add a significant bonus to these bins. This ensures that perfect fits are\n    # prioritized above all other considerations.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Apply Small Gap Penalty ---\n    # Identify bins where the item fits, but leaves a small, non-zero remaining capacity.\n    # Such small gaps can lead to fragmentation.\n    small_unusable_gap_mask = (remaining_after_placement > EPSILON) & \\\n                              (remaining_after_placement < SMALL_GAP_THRESHOLD)\n\n    # Apply a penalty to these bins. This makes them less attractive than bins that\n    # either perfectly fit the item or leave a larger, potentially more usable space.\n    priorities[small_unusable_gap_mask] += SMALL_GAP_PENALTY\n\n    # --- Final Filtering for Non-Fitting Bins ---\n    # Set priority to negative infinity for bins where the item does not fit (i.e.,\n    # remaining_after_placement is negative). This ensures these bins are never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by minimizing remaining capacity (Best Fit). Awards infinite\n    priority to perfect fits, ensuring optimal bin utilization for exact matches.\n    \"\"\"\n    # Initialize all priorities to a very low value. Bins are undesirable or unusable by default.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid and cannot be placed.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the remaining capacity if the item were placed in each fitting bin.\n        # This is the core of the Best Fit strategy: find the bin that minimizes this remainder.\n        remaining_after_fit = bins_remain_cap[fitting_mask] - item\n\n        # Assign a priority score such that smaller remaining capacities get higher scores.\n        # By negating the remainder, we transform minimizing a positive value into maximizing a negative value (closer to zero).\n        priorities[fitting_mask] = -remaining_after_fit\n\n        # Strongly prioritize perfect fits by assigning them an infinite score.\n        # This encourages completing bins whenever an item perfectly fills one,\n        # aligning with the goal of maximizing bin utilization and preventing tiny remnants.\n        perfect_fit_mask = (remaining_after_fit == 0)\n        if np.any(perfect_fit_mask):\n             priorities[fitting_mask][perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Proportional Best Fit with a strong bonus for perfect fits.\n\n    Prioritizes bins where the item fills a larger proportion of remaining capacity,\n    with a significant boost for bins where the item fits exactly.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid in typical BPP.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Base priority: Proportional Best Fit (from priority_v0).\n        # This maximizes the ratio of item size to remaining bin capacity,\n        # promoting efficient utilization and minimizing wasted space within a bin.\n        current_priorities = item / bins_remain_cap[fitting_mask]\n\n        # Identify bins where the item fits perfectly (remaining capacity equals item size).\n        perfect_fit_mask = (bins_remain_cap[fitting_mask] == item)\n\n        # Apply a significant, non-infinite bonus to perfect fits.\n        # This strongly prioritizes closing bins exactly, as suggested by the analysis\n        # (\"Strongly prioritize perfect item-bin fits\"), while avoiding the potential\n        # rigidity of an infinite score if other factors might rarely matter.\n        # A large constant ensures these scores are strictly higher than any\n        # non-perfect proportional fit (which are always <= 1.0).\n        current_priorities[perfect_fit_mask] += 100.0\n\n        # Assign the calculated priorities to the fitting bins.\n        priorities[fitting_mask] = current_priorities\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, BIN_CAPACITY: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Enhanced Best Fit: Combines core Best Fit with perfect fit prioritization,\n    a penalty for very small remnants, and a bonus for nearly full bins to encourage consolidation.\n    \"\"\"\n    if item <= 0:\n        # Invalid item size should result in lowest possible priority for all bins.\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap) # Initialize with lowest priority\n\n    # 1. Core Best Fit Logic:\n    # For bins where the item fits, set priority based on minimizing remaining space.\n    # A smaller remaining_after_placement (closer to 0) results in a higher priority.\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Define hyperparameters for the adaptive components.\n    # These values might need tuning based on problem characteristics and scale.\n    SMALL_REMNANT_THRESHOLD = 0.05 * BIN_CAPACITY # e.g., 5% of bin capacity\n    PENALTY_VALUE = 0.1 # Arbitrary penalty value, relative to typical priority scores\n\n    NEARLY_FULL_THRESHOLD = 0.1 * BIN_CAPACITY # e.g., bins with <= 10% capacity remaining are \"nearly full\"\n    BIN_COMPLETION_BONUS = 0.05 # Arbitrary bonus value\n\n    # 2. Penalize very small, non-zero remnants:\n    # Discourages leaving tiny, potentially unusable gaps in bins (from priority_v0).\n    small_remnant_mask = (remaining_after_placement > 0) & \\\n                         (remaining_after_placement < SMALL_REMNANT_THRESHOLD) & \\\n                         fits_mask\n    priorities[small_remnant_mask] -= PENALTY_VALUE\n\n    # 3. Bonus for nearly full bins (before placing the item):\n    # Encourages consolidating items into bins that are already well-filled,\n    # aiming to \"finish\" or close off bins sooner (inspired by Bin Completion Bonus concept).\n    nearly_full_bin_mask = (bins_remain_cap <= NEARLY_FULL_THRESHOLD) & \\\n                           (bins_remain_cap > 0) & \\\n                           fits_mask # Ensure item still fits\n    priorities[nearly_full_bin_mask] += BIN_COMPLETION_BONUS\n\n    # 4. Absolute Highest Priority for perfect fits:\n    # A perfect fit (0 remaining space) is almost always the optimal immediate choice\n    # and should override any other considerations (from priority_v0).\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using Proportional Best Fit, with a strong bonus for perfect item-bin fits.\n\n    Promotes efficient space utilization and fast bin closure.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle non-positive items: they cannot be packed, assign lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit.\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply Proportional Best Fit for valid bins: maximize `item / current_bin_capacity`.\n    # This naturally favors smaller valid remaining capacities (Best Fit) and higher utilization.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    # Aggressively prioritize perfect fits with an infinite score to ensure immediate closure.\n    perfect_fit_mask = bins_remain_cap == item\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]