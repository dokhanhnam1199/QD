import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray,
                default_priority: float = -269.86928832654354,
                weight_proportional_fit: float = 6.272249880865167,
                weight_smallest_fit: float = 7.231192539169563) -> np.ndarray:
    """Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).
    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.

    Args:
        item (float): The size of the item to be placed.
        bins_remain_cap (np.ndarray): A NumPy array of remaining capacities for each bin.
        default_priority (float, optional): The priority assigned to bins where the item cannot fit
                                            or for invalid item sizes. Defaults to -np.inf.
        weight_proportional_fit (float, optional): The weight given to the proportional fit component
                                                  (item / bin_capacity). Defaults to 1.0.
        weight_smallest_fit (float, optional): The weight given to the smallest fit component
                                               (-bin_capacity). Defaults to 1.0.

    Returns:
        np.ndarray: An array of priority scores for each bin. Higher scores indicate higher priority.
    """
    # Initialize priority scores to default_priority for non-fitting or invalid cases.
    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)

    # Handle invalid item size: If item is non-positive, it cannot be packed.
    if item <= 0:
        return priorities

    # Identify bins where the item can fit.
    fitting_bins_mask = bins_remain_cap >= item

    # Calculate priorities for fitting bins by combining two effective strategies:
    # 1. Proportional Best Fit: `item / bins_remain_cap` (maximizes relative fill).
    # 2. Smallest Fit: `-bins_remain_cap` (prioritizes bins with less remaining space to close them).
    # The weighted sum balances maximizing the item's proportional use of space with minimizing the bin's overall remaining space.
    priorities[fitting_bins_mask] = \
        (weight_proportional_fit * (item / bins_remain_cap[fitting_bins_mask])) + \
        (weight_smallest_fit * (-bins_remain_cap[fitting_bins_mask]))

    return priorities
