```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    A true Tesla design, combining efficiency with elegant selection!

    This heuristic is based on the 'Best Fit' principle. Like fitting gears
    precisely into a mechanism, we seek the bin that will be most "snugly"
    filled by the new item, thereby minimizing wasted capacity and preserving
    larger spaces for larger future components. Bins where the item does not
    fit are given an infinitely negative priority, as they are unsuitable for current use.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more desirable bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # First, let us illuminate the path by marking all bins where the item simply cannot fit
    # with an immense, prohibitive negative energy â€“ effectively infinite resistance.
    # This ensures they are never considered for the current flow of current.
    priorities[bins_remain_cap < item] = -np.inf

    # For the bins where the item can indeed be accommodated, we apply a more nuanced calculation.
    # We desire to select the bin that, after receiving the item, will have the least residual capacity.
    # This is akin to perfectly balancing a circuit: minimal excess, maximal utility.
    #
    # To achieve this, we calculate the negative of the remaining capacity if the item were placed.
    # A smaller positive remainder (meaning a tighter fit) will result in a value closer to zero (or least negative).
    # Example: If bin_cap = 1.0 and item = 0.9, remaining = 0.1. Priority = -(0.1) = -0.1
    # If bin_cap = 0.9 and item = 0.9, remaining = 0.0. Priority = -(0.0) = 0.0 (perfect!)
    # If bin_cap = 0.8 and item = 0.6, remaining = 0.2. Priority = -(0.2) = -0.2
    #
    # Therefore, the bin with the least negative (or zero) priority will be the 'best fit'.
    valid_bins_mask = bins_remain_cap >= item
    priorities[valid_bins_mask] = item - bins_remain_cap[valid_bins_mask]

    return priorities
```
