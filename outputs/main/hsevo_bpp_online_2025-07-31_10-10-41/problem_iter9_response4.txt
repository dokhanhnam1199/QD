```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which to add an item to each bin, enhancing Best Fit with a strong perfect-fit bonus.

    This function calculates a priority score for each bin based on the Best Fit (BF) strategy,
    which prefers bins that minimize the remaining capacity after placing the item. To implement
    additive incentives, a significant bonus is applied to bins where the item perfectly fills
    the remaining capacity, ensuring these bins are selected with the highest priority. Bins
    where the item cannot fit are assigned the lowest possible priority (-np.inf).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity after hypothetically placing the item in each bin.
    # This forms the basis for the Best Fit strategy.
    remaining_after_placement = bins_remain_cap - item

    # Initialize priority scores based on Best Fit:
    # We want to minimize remaining_after_placement (make it as close to 0 as possible, but not negative).
    # To convert this to a maximization problem (higher priority is better), we take the negative.
    # So, a smaller positive remaining_after_placement results in a higher (less negative) priority score.
    # A value of 0 (perfect fit) gets a base priority of 0.
    priorities = -remaining_after_placement

    # --- Additive Incentive: Strong Perfect Fit Bonus ---
    # Define a large, tunable bonus for perfect fits. This parameter
    # ensures that a bin where the item perfectly fills the remaining space
    # (i.e., remaining_after_placement is effectively zero) is given
    # an overwhelmingly higher priority than any non-perfect fit.
    # The value should be sufficiently large to exceed the absolute range
    # of negative scores from non-perfect fits (e.g., if max bin capacity is 1.0,
    # priorities for non-perfect fits are in (-1.0, 0]). A bonus > 1.0 guarantees dominance.
    PERFECT_FIT_BONUS = 1000.0  # This parameter can be tuned for specific problem scales.

    # Apply the bonus where the item perfectly fits.
    # Using np.isclose for floating-point comparison robustness.
    priorities[np.isclose(remaining_after_placement, 0.0)] += PERFECT_FIT_BONUS

    # --- Logic Validation: Handle Non-Fitting Bins ---
    # Any bin where remaining_after_placement is negative means the item does not fit.
    # These bins must be excluded from selection by assigning them the lowest possible priority.
    priorities[remaining_after_placement < 0] = -np.inf

    return priorities
```
