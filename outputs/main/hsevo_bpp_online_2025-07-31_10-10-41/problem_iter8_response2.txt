```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:
    """Prioritizes Best Fit, adds a bonus for bin consolidation, and gives highest priority to perfect fits.
    """
    # Handle invalid item size: If item is non-positive, it cannot be packed.
    if item <= 0:
        return np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the remaining capacity after placing the item in each bin
    remaining_after_placement = bins_remain_cap - item

    # Base Best Fit priority: A smaller positive remaining capacity yields a higher score.
    bf_priorities = -remaining_after_placement

    # Bin Completion Bonus: Encourage filling up existing bins by giving a bonus
    # based on current occupancy (before placing the item).
    current_occupancy_ratio = (bin_capacity - bins_remain_cap) / bin_capacity
    current_occupancy_ratio = np.clip(current_occupancy_ratio, 0, 1)

    beta = 0.5  # Tunable parameter for the influence of the completion bias.
    completion_bonus = beta * current_occupancy_ratio

    # Combine Best Fit priority with the completion bonus
    priorities = bf_priorities + completion_bonus

    # Perfect Fit Bonus: Strongly prioritize bins that result in a perfect fit.
    # Use a small tolerance for floating-point comparisons.
    perfect_fit_mask = np.isclose(remaining_after_placement, 0, atol=1e-9)
    priorities[perfect_fit_mask] = np.inf

    # Finally, set priority to negative infinity for bins where the item does not fit.
    # This ensures these bins are never selected, overriding any other calculated bonuses.
    priorities[remaining_after_placement < 0] = -np.inf

    return priorities
```
