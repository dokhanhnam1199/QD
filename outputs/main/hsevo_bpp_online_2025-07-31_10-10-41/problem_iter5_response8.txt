```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using a robust Best Fit (BF) strategy.

    Selects bins that minimize wasted space after placement, assigning higher
    scores to tighter fits. Handles invalid items and non-fitting bins robustly.
    """
    # Initialize all priorities to negative infinity, assuming no fit by default.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Robustness check: If the item size is non-positive, it cannot be packed.
    # All bins will effectively have infinite negative priority for such an item.
    if item <= 0:
        return priorities

    # Calculate the remaining capacity if the item were placed in each bin.
    # This also helps identify which bins can actually fit the item (positive or zero remainder).
    potential_remainders = bins_remain_cap - item

    # Create a boolean mask for bins where the item fits (remainder is non-negative).
    fits_mask = potential_remainders >= 0

    # For bins where the item fits, apply the Best Fit logic:
    # Prioritize bins that result in the smallest remaining capacity after placement.
    # By taking the negative of the potential_remainders, a smaller positive remainder
    # (e.g., 5) results in a higher (less negative) priority score (-5) compared to
    # a larger remainder (e.g., 20) which results in a lower (more negative) score (-20).
    priorities[fits_mask] = -potential_remainders[fits_mask]

    return priorities
```
