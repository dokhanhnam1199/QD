```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using proportional fit, favoring those where the item
    fills a larger percentage of remaining capacity. Ensures robustness for invalid items.
    """
    # Robustness check: If the item size is non-positive, it's considered invalid.
    # No bin should be chosen for such an item, returning negative infinity.
    if item <= 0:
        return np.full_like(bins_remain_cap, -np.inf)

    # Initialize all priorities to negative infinity. This ensures that bins
    # where the item cannot fit are never selected.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify all bins capable of containing the incoming item.
    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.
    can_fit_mask = bins_remain_cap >= item

    # For those bins where the item fits, assign a priority based on proportional utilization.
    # This means item_size / bin_remaining_capacity. A higher ratio (closer to 1.0) indicates
    # a 'snugger' proportional fit, aiming to maximize the relative fill of a bin.
    # This directly implements the Best Fit strategy focusing on proportional utilization
    # identified as highly effective. Division by zero is avoided because bins where item > 0
    # and capacity is 0 will not be in the `can_fit_mask`.
    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]

    return priorities
```
