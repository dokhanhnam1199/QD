```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for adding item to each bin.

    This heuristic combines Best Fit's linear efficiency with a bonus for perfect fits.
    It prioritizes bins that perfectly contain the item, then ranks others by minimizing
    remaining capacity.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # 1. Identify bins that can accommodate the item.
    valid_bins_mask = bins_remain_cap >= item

    # 2. Calculate the 'wasted space' if the item were placed in each valid bin.
    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item

    # 3. Apply the core Best Fit strategy: lower leftover space means higher priority.
    # This assigns priorities as the negative of the leftover space (0 for perfect fit,
    # then increasingly negative for looser fits).
    priorities[valid_bins_mask] = -leftover_space_if_placed

    # 4. Enhance perfect fits with a significant bonus (element from v1's intent).
    # This implements the idea of strongly preferring perfect fits (like v1's exp(0)=1.0),
    # but uses a linear constant bonus instead of exponential decay to maintain performance.
    # The bonus must be greater than any negative priority from non-perfect fits.
    BONUS_PERFECT_FIT = 100.0 
    
    # Identify bins where the item fits perfectly (leftover space is zero or very close to zero).
    perfect_fit_mask = valid_bins_mask & np.isclose(leftover_space_if_placed, 0.0, atol=1e-9)
    
    # Apply the bonus only to perfect fits.
    priorities[perfect_fit_mask] = BONUS_PERFECT_FIT

    return priorities
```
