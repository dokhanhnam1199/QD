```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    As Albert Einstein, I propose a heuristic based on the principle of
    "Least Resistance" or "Maximal Local Utilization". Just as matter warps
    spacetime, we want the item to "warp" the bin's remaining capacity
    as completely as possible. This means fitting the item into a bin
    such that the *remaining void* is minimized.

    This strategy aligns with the 'Best Fit' heuristic in bin packing,
    which aims to leave the smallest possible capacity after the item is
    placed. This effectively makes the most efficient use of the current bin,
    leaving larger capacities in other bins for potentially larger future items,
    thus minimizing the total number of bins required over time.

    A higher priority score indicates a more desirable bin.
    - If an item fits, the score is based on `item - bin_remaining_capacity`.
      A perfect fit (item == bin_remaining_capacity) yields a score of 0.
      A looser fit (item << bin_remaining_capacity) yields a more negative score.
      The goal is to maximize this value (make it closest to 0 or least negative).
    - If an item does not fit, the priority is set to a very low (negative infinity) value.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize all priorities to a very low value, indicating an undesirable bin.
    # This handles cases where an item does not fit.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins where the item can actually fit.
    # This corresponds to "valid space-time coordinates" where the item can exist.
    can_fit = bins_remain_cap >= item

    # For bins where the item fits, calculate the priority score.
    # We want to maximize `item - bins_remain_cap`, which means minimizing
    # `bins_remain_cap - item` (the remaining void) for positive remaining capacities.
    # A perfect fit (bins_remain_cap[i] == item) results in a score of 0, which is
    # the maximum possible non-negative score, hence highest priority for valid fits.
    # If bins_remain_cap[i] > item, the score will be negative, and the closer
    # bins_remain_cap[i] is to item, the closer to 0 (and thus higher) the score will be.
    priorities[can_fit] = item - bins_remain_cap[can_fit]

    return priorities
```
