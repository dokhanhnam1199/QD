{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit (BF) strategy.\n\n    Bins where the item fits perfectly get the highest priority. Among bins where the item fits,\n    those leaving less remaining capacity are preferred. Bins where the item does not fit\n    are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores\n    # We use -np.inf for bins where the item cannot fit, ensuring they are never chosen.\n    # For bins where it fits, we prioritize by minimizing the remaining space.\n    # A smaller remaining_after_placement value means a better fit (closer to zero).\n    # To maximize this as a priority score, we take the negative of remaining_after_placement.\n    # So, a perfect fit (remaining_after_placement = 0) gets a priority of 0,\n    # a near-perfect fit (e.g., remaining_after_placement = 0.1) gets -0.1,\n    # and a loose fit (e.g., remaining_after_placement = 10) gets -10.\n    # The higher the value (closer to 0 for negatives, or 0 itself), the better.\n    priorities = -remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item does not fit\n    # (i.e., remaining_after_placement is negative)\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Returns a priority score for each bin, combining Best Fit with a \"Bin Completion\" bias.\n\n    This heuristic aims to select a bin that:\n    1.  Fits the item (essential, bins where the item does not fit are assigned the lowest possible priority).\n    2.  Among valid fits, prioritizes Best Fit (leaving the least remaining capacity).\n    3.  Additionally, applies a \"Bin Completion\" bias. It gives a bonus to bins that are\n        already significantly full (i.e., have little remaining capacity before the item is placed).\n        This encourages \"finishing off\" bins that are closer to being full, leading to fewer\n        partially filled bins overall and potentially consolidating items more efficiently.\n        This represents an adaptive strategy, prioritizing a global state objective (bin consolidation)\n        alongside the immediate fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        bin_capacity: The maximum capacity of a single bin. Default to 1.0, assuming\n                      items and bin capacities are normalized.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Base Best Fit priority:\n    # A perfect fit (remaining_after_placement = 0) gets the highest BF score (0).\n    # Less remaining capacity results in a higher score (closer to 0).\n    bf_priorities = -remaining_after_placement\n\n    # Calculate current occupancy ratio for each bin (before placing the item)\n    # This ratio ranges from 0 (empty bin) to 1 (full bin).\n    # We clip it to ensure values are within [0, 1] for robustness against potential\n    # floating point inaccuracies or unusual initial states (though usually not expected).\n    current_occupancy_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    current_occupancy_ratio = np.clip(current_occupancy_ratio, 0, 1)\n\n    # Bin Completion Bias:\n    # A bonus is applied based on how full the bin currently is.\n    # The fuller the bin (higher current_occupancy_ratio), the higher the bonus.\n    # This encourages packing items into bins that are already close to being completely filled.\n    # The weight 'beta' controls the influence of this bias. A higher beta means this bias\n    # has a stronger effect on the final priority, potentially shifting choices away from\n    # pure Best Fit if a less tight fit in an already full bin is available.\n    beta = 0.5  # Tunable parameter. A value of 0 effectively reverts to Best Fit.\n\n    completion_bonus = beta * current_occupancy_ratio\n\n    # Combine Best Fit priority with the completion bonus.\n    # The primary BF priority ensures valid fits are preferred and tighter fits are generally\n    # chosen. The completion bonus then adds a strategic layer to favor consolidating items\n    # into bins that are already well-utilized, aiming to reduce the total number of open bins.\n    priorities = bf_priorities + completion_bonus\n\n    # Finally, set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected, overriding any potential positive bonuses\n    # that might have been calculated for them (e.g., if a bin was already very full\n    # but the item still didn't fit).\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive Best Fit (ABF) with remnant preference. Prioritizes perfect fits, then standard\n    best fit, while penalizing very small non-zero remnants to encourage more usable leftover space.\n    \"\"\"\n    if item <= 0:\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Core Best Fit: Prioritize bins by minimizing remaining space\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Adaptive Component: Penalize very small, non-zero remnants\n    # This constant (e.g., 5% of a typical bin capacity) needs tuning based on problem scale.\n    SMALL_REMNANT_THRESHOLD = 0.05 \n    # Penalty value to make small remnants less attractive than better fits.\n    PENALTY_VALUE = 0.1 \n\n    small_remnant_mask = (remaining_after_placement > 0) & \\\n                         (remaining_after_placement < SMALL_REMNANT_THRESHOLD) & \\\n                         fits_mask\n    priorities[small_remnant_mask] -= PENALTY_VALUE\n\n    # Absolute Highest Priority: Ensure perfect fits are always chosen first\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using a Best Fit (BF) strategy, prioritizing bins that result in the smallest remaining capacity after placement.\n    Handles invalid items by assigning the lowest priority.\n    \"\"\"\n    # Initialize priority scores with negative infinity for bins where the item cannot fit\n    # or if the item itself is invalid.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: items must have a positive size to be packable.\n    # If not, all bins remain at the lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Create a mask for bins where the item *can* fit (remaining capacity >= item size).\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the remaining capacity if the item were placed.\n    # A Best Fit strategy aims to minimize this remaining capacity (i.e., find the tightest fit).\n    # To assign higher priority to smaller remaining capacities, we take the negative of this value.\n    # Example: If remaining_capacity = 5, priority = -5. If remaining_capacity = 50, priority = -50.\n    # A value of -5 is higher (less negative) than -50, correctly prioritizing tighter fits.\n    potential_remainders = bins_remain_cap[fits_mask] - item\n    priorities[fits_mask] = -potential_remainders\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Mutated priority function for online Bin Packing, incorporating a Best Fit strategy\n    with enhancements for bin completion and fragmentation avoidance.\n\n    This heuristic combines multiple criteria:\n    1.  **Best Fit Preference:** Prioritizes bins that result in the smallest remaining capacity\n        after placing the item. This is the primary driver for efficient space utilization.\n    2.  **Bin Completion Bonus:** Applies a significant bonus to bins that would become\n        completely full (or virtually full) after placing the item. This encourages \"closing\"\n        bins, reducing the number of active bins and potentially simplifying future decisions.\n    3.  **Small Gap Penalty:** Applies a penalty for bins where placing the item would leave\n        a very small, non-zero remaining capacity. Such tiny gaps can be difficult to fill\n        with subsequent items, leading to wasted space and fragmentation. This aims to\n        deter creating \"unusable\" leftover space.\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         Assumed to be non-negative floats.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins where the item does not fit\n        are assigned -np.inf.\n    \"\"\"\n    # Define constants for heuristic parameters. These values might need tuning\n    # depending on the specific distribution of item sizes and bin capacities.\n    # Assumes a typical bin capacity is implicitly scaled, e.g., to 1.0.\n    EPSILON = 1e-9  # Tolerance for floating point comparisons (e.g., for \"perfect fit\")\n    PERFECT_FIT_BONUS = 1000.0 # Large bonus for a perfect fit to make it highly preferred\n    SMALL_GAP_THRESHOLD = 0.1 # Threshold for defining a \"small\" remaining capacity\n                              # (e.g., 0.1 means 10% of a common normalized bin capacity)\n    SMALL_GAP_PENALTY = -0.5  # Penalty applied if placing the item leaves a small, unusable gap\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit principle:\n    # A smaller remaining_after_placement (closer to 0) is better, so we take the negative.\n    # This means 0 remaining capacity gets a 0 score, 0.1 gets -0.1, etc.\n    priorities = -remaining_after_placement\n\n    # --- Apply Bin Completion Bonus ---\n    # Identify bins where the item fits perfectly or almost perfectly.\n    # This condition uses EPSILON to account for floating-point inaccuracies.\n    perfect_fit_mask = remaining_after_placement <= EPSILON\n\n    # Add a significant bonus to these bins. This ensures that perfect fits are\n    # prioritized above all other considerations (e.g., even above the small gap penalty\n    # if it were to accidentally apply to a near-perfect fit, though logically it shouldn't).\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Apply Small Gap Penalty ---\n    # Identify bins where the item fits, but leaves a small, non-zero remaining capacity.\n    # Such small gaps can lead to fragmentation.\n    small_unusable_gap_mask = (remaining_after_placement > EPSILON) & \\\n                              (remaining_after_placement < SMALL_GAP_THRESHOLD)\n\n    # Apply a penalty to these bins. This makes them less attractive than bins that\n    # either perfectly fit the item or leave a larger, potentially more usable space.\n    # The penalty value is critical: it should be strong enough to deter but not so strong\n    # that it prevents all small fits when no better option exists.\n    priorities[small_unusable_gap_mask] += SMALL_GAP_PENALTY\n\n    # --- Final Filtering for Non-Fitting Bins ---\n    # Set priority to negative infinity for bins where the item does not fit (i.e.,\n    # remaining_after_placement is negative). This ensures these bins are never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive Best Fit: Prioritizes bins maximizing relative fill, promoting efficient bin usage.\n    This heuristic favors bins where the item constitutes a larger proportion of the remaining capacity,\n    a strategy robustly outperforming Worst Fit by minimizing wasted space dynamically.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid in typical BPP.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the \"proportional utilization\" for the fitting bins.\n        # This score represents how much of the bin's *remaining* capacity the item will fill.\n        # A higher ratio (closer to 1.0) indicates a tighter, more efficient fit.\n        # This strategy is a powerful form of Best Fit, effectively balancing item size\n        # against available bin space. Perfect fits (item fills bin exactly) result in a score of 1.0.\n        priorities[fitting_mask] = item / bins_remain_cap[fitting_mask]\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive Best Fit: Prioritizes bins maximizing relative fill, promoting efficient bin usage.\n    This heuristic favors bins where the item constitutes a larger proportion of the remaining capacity,\n    a strategy robustly outperforming Worst Fit by minimizing wasted space dynamically.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid in typical BPP.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the \"proportional utilization\" for the fitting bins.\n        # This score represents how much of the bin's *remaining* capacity the item will fill.\n        # A higher ratio (closer to 1.0) indicates a tighter, more efficient fit.\n        # This strategy is a powerful form of Best Fit, effectively balancing item size\n        # against available bin space. Perfect fits (item fills bin exactly) result in a score of 1.0.\n        priorities[fitting_mask] = item / bins_remain_cap[fitting_mask]\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive Best Fit (ABF) with remnant preference. Prioritizes perfect fits, then standard\n    best fit, while penalizing very small non-zero remnants to encourage more usable leftover space.\n    \"\"\"\n    if item <= 0:\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Core Best Fit: Prioritize bins by minimizing remaining space\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Adaptive Component: Penalize very small, non-zero remnants\n    # This constant (e.g., 5% of a typical bin capacity) needs tuning based on problem scale.\n    SMALL_REMNANT_THRESHOLD = 0.05 \n    # Penalty value to make small remnants less attractive than better fits.\n    PENALTY_VALUE = 0.1 \n\n    small_remnant_mask = (remaining_after_placement > 0) & \\\n                         (remaining_after_placement < SMALL_REMNANT_THRESHOLD) & \\\n                         fits_mask\n    priorities[small_remnant_mask] -= PENALTY_VALUE\n\n    # Absolute Highest Priority: Ensure perfect fits are always chosen first\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item using a robust Proportional Best Fit strategy.\n\n    Prioritizes bins by maximizing the proportion of their capacity filled by the item.\n    Handles invalid inputs (non-positive items) gracefully.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness (from priority_v0): non-positive items cannot be packed, assign lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit (similar to priority_v0 and implicitly in priority_v1's logic).\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply Proportional Best Fit strategy (refining a concept hinted in priority_v0's docstring):\n    # Prioritize bins that would be most \"filled up\" by the item relative to their current capacity.\n    # This promotes efficient use of space by maximizing `item / current_bin_capacity` for valid bins.\n    # Bins where the item fits will have `bins_remain_cap` >= `item` > 0, preventing division by zero.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using proportional fit, favoring those where the item\n    fills a larger percentage of remaining capacity. Ensures robustness for invalid items.\n    \"\"\"\n    # Robustness check: If the item size is non-positive, it's considered invalid.\n    # No bin should be chosen for such an item, returning negative infinity.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize all priorities to negative infinity. This ensures that bins\n    # where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item.\n    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item fits, assign a priority based on proportional utilization.\n    # This means item_size / bin_remaining_capacity. A higher ratio (closer to 1.0) indicates\n    # a 'snugger' proportional fit, aiming to maximize the relative fill of a bin.\n    # This directly implements the Best Fit strategy focusing on proportional utilization\n    # identified as highly effective. Division by zero is avoided because bins where item > 0\n    # and capacity is 0 will not be in the `can_fit_mask`.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using proportional fit, favoring those where the item\n    fills a larger percentage of remaining capacity. Ensures robustness for invalid items.\n    \"\"\"\n    # Robustness check: If the item size is non-positive, it's considered invalid.\n    # No bin should be chosen for such an item, returning negative infinity.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize all priorities to negative infinity. This ensures that bins\n    # where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item.\n    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item fits, assign a priority based on proportional utilization.\n    # This means item_size / bin_remaining_capacity. A higher ratio (closer to 1.0) indicates\n    # a 'snugger' proportional fit, aiming to maximize the relative fill of a bin.\n    # This directly implements the Best Fit strategy focusing on proportional utilization\n    # identified as highly effective. Division by zero is avoided because bins where item > 0\n    # and capacity is 0 will not be in the `can_fit_mask`.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_priority: float = -137.50755434220446,\n                weight_proportional_fit: float = 6.429049372442565,\n                weight_smallest_fit: float = 4.499361878629241) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n\n    Args:\n        item (float): The size of the item to be placed.\n        bins_remain_cap (np.ndarray): A NumPy array of remaining capacities for each bin.\n        default_priority (float, optional): The priority assigned to bins where the item cannot fit\n                                            or for invalid item sizes. Defaults to -np.inf.\n        weight_proportional_fit (float, optional): The weight given to the proportional fit component\n                                                  (item / bin_capacity). Defaults to 1.0.\n        weight_smallest_fit (float, optional): The weight given to the smallest fit component\n                                               (-bin_capacity). Defaults to 1.0.\n\n    Returns:\n        np.ndarray: An array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priority scores to default_priority for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_priority: float = -137.50755434220446,\n                weight_proportional_fit: float = 6.429049372442565,\n                weight_smallest_fit: float = 4.499361878629241) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n\n    Args:\n        item (float): The size of the item to be placed.\n        bins_remain_cap (np.ndarray): A NumPy array of remaining capacities for each bin.\n        default_priority (float, optional): The priority assigned to bins where the item cannot fit\n                                            or for invalid item sizes. Defaults to -np.inf.\n        weight_proportional_fit (float, optional): The weight given to the proportional fit component\n                                                  (item / bin_capacity). Defaults to 1.0.\n        weight_smallest_fit (float, optional): The weight given to the smallest fit component\n                                               (-bin_capacity). Defaults to 1.0.\n\n    Returns:\n        np.ndarray: An array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priority scores to default_priority for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_priority: float = -137.50755434220446,\n                weight_proportional_fit: float = 6.429049372442565,\n                weight_smallest_fit: float = 4.499361878629241) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n\n    Args:\n        item (float): The size of the item to be placed.\n        bins_remain_cap (np.ndarray): A NumPy array of remaining capacities for each bin.\n        default_priority (float, optional): The priority assigned to bins where the item cannot fit\n                                            or for invalid item sizes. Defaults to -np.inf.\n        weight_proportional_fit (float, optional): The weight given to the proportional fit component\n                                                  (item / bin_capacity). Defaults to 1.0.\n        weight_smallest_fit (float, optional): The weight given to the smallest fit component\n                                               (-bin_capacity). Defaults to 1.0.\n\n    Returns:\n        np.ndarray: An array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priority scores to default_priority for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_priority: float = -137.50755434220446,\n                weight_proportional_fit: float = 6.429049372442565,\n                weight_smallest_fit: float = 4.499361878629241) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n\n    Args:\n        item (float): The size of the item to be placed.\n        bins_remain_cap (np.ndarray): A NumPy array of remaining capacities for each bin.\n        default_priority (float, optional): The priority assigned to bins where the item cannot fit\n                                            or for invalid item sizes. Defaults to -np.inf.\n        weight_proportional_fit (float, optional): The weight given to the proportional fit component\n                                                  (item / bin_capacity). Defaults to 1.0.\n        weight_smallest_fit (float, optional): The weight given to the smallest fit component\n                                               (-bin_capacity). Defaults to 1.0.\n\n    Returns:\n        np.ndarray: An array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priority scores to default_priority for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray,\n                default_priority: float = -137.50755434220446,\n                weight_proportional_fit: float = 6.429049372442565,\n                weight_smallest_fit: float = 4.499361878629241) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n\n    Args:\n        item (float): The size of the item to be placed.\n        bins_remain_cap (np.ndarray): A NumPy array of remaining capacities for each bin.\n        default_priority (float, optional): The priority assigned to bins where the item cannot fit\n                                            or for invalid item sizes. Defaults to -np.inf.\n        weight_proportional_fit (float, optional): The weight given to the proportional fit component\n                                                  (item / bin_capacity). Defaults to 1.0.\n        weight_smallest_fit (float, optional): The weight given to the smallest fit component\n                                               (-bin_capacity). Defaults to 1.0.\n\n    Returns:\n        np.ndarray: An array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    # Initialize priority scores to default_priority for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, default_priority, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using an adaptive Best Fit strategy with a dynamic\n    preference for consolidating smaller items into already fuller bins.\n\n    This heuristic attempts to balance the Best Fit principle (minimizing wasted space per item)\n    with a strategy to reduce fragmentation, especially for smaller items. For small items,\n    it slightly prioritizes bins that are already more full (have less remaining capacity),\n    aiming to 'finish' those bins or prevent creation of many small gaps across new bins.\n    For larger items, it reverts closer to a pure Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assumption for Bin Capacity:\n    # In many online Bin Packing problems, bin capacities are normalized, often to 1.0.\n    # If the problem context implies a different fixed bin capacity, this value should be adjusted.\n    BIN_CAPACITY = 1.0\n\n    # Hyperparameter K:\n    # This constant controls the strength of the adaptive preference for fuller bins.\n    # A value of K=0 makes this function equivalent to the original Best Fit (priority_v1).\n    # Increasing K (e.g., from 0.1 to 1.0) intensifies the preference for fuller bins\n    # for smaller items. This value might need tuning for specific problem instances.\n    K = 0.5 \n\n    # Calculate remaining capacity after placing the item in each bin.\n    # This is crucial for identifying bins where the item fits.\n    remaining_after_placement = bins_remain_cap - item\n\n    # --- Core Priority Calculation ---\n    # The base of the priority score is (item - bins_remain_cap), which is equivalent to\n    # the negative of the remaining space after placement. This component drives the\n    # Best Fit behavior: higher score for less remaining space (closer to perfect fit).\n\n    # Adaptive Factor:\n    # This factor dynamically adjusts the influence of the bin's current fullness based on the item's size.\n    # - For smaller items (item << BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 1.0.\n    #   This means the adaptive_factor is larger, giving more weight to the 'bins_remain_cap' term.\n    #   The effect: a stronger preference for putting small items into bins that are already more full.\n    # - For larger items (item approaches BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 0.0.\n    #   This means the adaptive_factor is smaller, reducing the weight of the 'bins_remain_cap' term.\n    #   The effect: the priority calculation becomes very similar to pure Best Fit.\n    \n    # Ensure BIN_CAPACITY is not zero to prevent division by zero, though in BPP it's always positive.\n    adaptive_factor = K * (1.0 - item / BIN_CAPACITY) if BIN_CAPACITY > 0 else 0.0\n    \n    # The combined priority score:\n    # The first part (item - bins_remain_cap) is the standard Best Fit component.\n    # The second part (- adaptive_factor * bins_remain_cap) applies a penalty that is:\n    #   1. Larger (more negative) for bins with more remaining capacity (i.e., less full bins).\n    #   2. Scaled by 'adaptive_factor', meaning this penalty is more significant for smaller items.\n    # This synergistically pushes smaller items into already fuller bins while maintaining Best Fit\n    # for larger items.\n    priorities = (item - bins_remain_cap) - adaptive_factor * bins_remain_cap\n\n    # --- Handling Invalid Placements ---\n    # Crucially, any bin where the item cannot fit (resulting in negative remaining_after_placement)\n    # must be assigned the lowest possible priority (-np.inf) to ensure it is never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using an adaptive Best Fit strategy with a dynamic\n    preference for consolidating smaller items into already fuller bins.\n\n    This heuristic attempts to balance the Best Fit principle (minimizing wasted space per item)\n    with a strategy to reduce fragmentation, especially for smaller items. For small items,\n    it slightly prioritizes bins that are already more full (have less remaining capacity),\n    aiming to 'finish' those bins or prevent creation of many small gaps across new bins.\n    For larger items, it reverts closer to a pure Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assumption for Bin Capacity:\n    # In many online Bin Packing problems, bin capacities are normalized, often to 1.0.\n    # If the problem context implies a different fixed bin capacity, this value should be adjusted.\n    BIN_CAPACITY = 1.0\n\n    # Hyperparameter K:\n    # This constant controls the strength of the adaptive preference for fuller bins.\n    # A value of K=0 makes this function equivalent to the original Best Fit (priority_v1).\n    # Increasing K (e.g., from 0.1 to 1.0) intensifies the preference for fuller bins\n    # for smaller items. This value might need tuning for specific problem instances.\n    K = 0.5 \n\n    # Calculate remaining capacity after placing the item in each bin.\n    # This is crucial for identifying bins where the item fits.\n    remaining_after_placement = bins_remain_cap - item\n\n    # --- Core Priority Calculation ---\n    # The base of the priority score is (item - bins_remain_cap), which is equivalent to\n    # the negative of the remaining space after placement. This component drives the\n    # Best Fit behavior: higher score for less remaining space (closer to perfect fit).\n\n    # Adaptive Factor:\n    # This factor dynamically adjusts the influence of the bin's current fullness based on the item's size.\n    # - For smaller items (item << BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 1.0.\n    #   This means the adaptive_factor is larger, giving more weight to the 'bins_remain_cap' term.\n    #   The effect: a stronger preference for putting small items into bins that are already more full.\n    # - For larger items (item approaches BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 0.0.\n    #   This means the adaptive_factor is smaller, reducing the weight of the 'bins_remain_cap' term.\n    #   The effect: the priority calculation becomes very similar to pure Best Fit.\n    \n    # Ensure BIN_CAPACITY is not zero to prevent division by zero, though in BPP it's always positive.\n    adaptive_factor = K * (1.0 - item / BIN_CAPACITY) if BIN_CAPACITY > 0 else 0.0\n    \n    # The combined priority score:\n    # The first part (item - bins_remain_cap) is the standard Best Fit component.\n    # The second part (- adaptive_factor * bins_remain_cap) applies a penalty that is:\n    #   1. Larger (more negative) for bins with more remaining capacity (i.e., less full bins).\n    #   2. Scaled by 'adaptive_factor', meaning this penalty is more significant for smaller items.\n    # This synergistically pushes smaller items into already fuller bins while maintaining Best Fit\n    # for larger items.\n    priorities = (item - bins_remain_cap) - adaptive_factor * bins_remain_cap\n\n    # --- Handling Invalid Placements ---\n    # Crucially, any bin where the item cannot fit (resulting in negative remaining_after_placement)\n    # must be assigned the lowest possible priority (-np.inf) to ensure it is never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using an adaptive Best Fit strategy with a dynamic\n    preference for consolidating smaller items into already fuller bins.\n\n    This heuristic attempts to balance the Best Fit principle (minimizing wasted space per item)\n    with a strategy to reduce fragmentation, especially for smaller items. For small items,\n    it slightly prioritizes bins that are already more full (have less remaining capacity),\n    aiming to 'finish' those bins or prevent creation of many small gaps across new bins.\n    For larger items, it reverts closer to a pure Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assumption for Bin Capacity:\n    # In many online Bin Packing problems, bin capacities are normalized, often to 1.0.\n    # If the problem context implies a different fixed bin capacity, this value should be adjusted.\n    BIN_CAPACITY = 1.0\n\n    # Hyperparameter K:\n    # This constant controls the strength of the adaptive preference for fuller bins.\n    # A value of K=0 makes this function equivalent to the original Best Fit (priority_v1).\n    # Increasing K (e.g., from 0.1 to 1.0) intensifies the preference for fuller bins\n    # for smaller items. This value might need tuning for specific problem instances.\n    K = 0.5 \n\n    # Calculate remaining capacity after placing the item in each bin.\n    # This is crucial for identifying bins where the item fits.\n    remaining_after_placement = bins_remain_cap - item\n\n    # --- Core Priority Calculation ---\n    # The base of the priority score is (item - bins_remain_cap), which is equivalent to\n    # the negative of the remaining space after placement. This component drives the\n    # Best Fit behavior: higher score for less remaining space (closer to perfect fit).\n\n    # Adaptive Factor:\n    # This factor dynamically adjusts the influence of the bin's current fullness based on the item's size.\n    # - For smaller items (item << BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 1.0.\n    #   This means the adaptive_factor is larger, giving more weight to the 'bins_remain_cap' term.\n    #   The effect: a stronger preference for putting small items into bins that are already more full.\n    # - For larger items (item approaches BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 0.0.\n    #   This means the adaptive_factor is smaller, reducing the weight of the 'bins_remain_cap' term.\n    #   The effect: the priority calculation becomes very similar to pure Best Fit.\n    \n    # Ensure BIN_CAPACITY is not zero to prevent division by zero, though in BPP it's always positive.\n    adaptive_factor = K * (1.0 - item / BIN_CAPACITY) if BIN_CAPACITY > 0 else 0.0\n    \n    # The combined priority score:\n    # The first part (item - bins_remain_cap) is the standard Best Fit component.\n    # The second part (- adaptive_factor * bins_remain_cap) applies a penalty that is:\n    #   1. Larger (more negative) for bins with more remaining capacity (i.e., less full bins).\n    #   2. Scaled by 'adaptive_factor', meaning this penalty is more significant for smaller items.\n    # This synergistically pushes smaller items into already fuller bins while maintaining Best Fit\n    # for larger items.\n    priorities = (item - bins_remain_cap) - adaptive_factor * bins_remain_cap\n\n    # --- Handling Invalid Placements ---\n    # Crucially, any bin where the item cannot fit (resulting in negative remaining_after_placement)\n    # must be assigned the lowest possible priority (-np.inf) to ensure it is never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using an adaptive Best Fit strategy with a dynamic\n    preference for consolidating smaller items into already fuller bins.\n\n    This heuristic attempts to balance the Best Fit principle (minimizing wasted space per item)\n    with a strategy to reduce fragmentation, especially for smaller items. For small items,\n    it slightly prioritizes bins that are already more full (have less remaining capacity),\n    aiming to 'finish' those bins or prevent creation of many small gaps across new bins.\n    For larger items, it reverts closer to a pure Best Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Assumption for Bin Capacity:\n    # In many online Bin Packing problems, bin capacities are normalized, often to 1.0.\n    # If the problem context implies a different fixed bin capacity, this value should be adjusted.\n    BIN_CAPACITY = 1.0\n\n    # Hyperparameter K:\n    # This constant controls the strength of the adaptive preference for fuller bins.\n    # A value of K=0 makes this function equivalent to the original Best Fit (priority_v1).\n    # Increasing K (e.g., from 0.1 to 1.0) intensifies the preference for fuller bins\n    # for smaller items. This value might need tuning for specific problem instances.\n    K = 0.5 \n\n    # Calculate remaining capacity after placing the item in each bin.\n    # This is crucial for identifying bins where the item fits.\n    remaining_after_placement = bins_remain_cap - item\n\n    # --- Core Priority Calculation ---\n    # The base of the priority score is (item - bins_remain_cap), which is equivalent to\n    # the negative of the remaining space after placement. This component drives the\n    # Best Fit behavior: higher score for less remaining space (closer to perfect fit).\n\n    # Adaptive Factor:\n    # This factor dynamically adjusts the influence of the bin's current fullness based on the item's size.\n    # - For smaller items (item << BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 1.0.\n    #   This means the adaptive_factor is larger, giving more weight to the 'bins_remain_cap' term.\n    #   The effect: a stronger preference for putting small items into bins that are already more full.\n    # - For larger items (item approaches BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 0.0.\n    #   This means the adaptive_factor is smaller, reducing the weight of the 'bins_remain_cap' term.\n    #   The effect: the priority calculation becomes very similar to pure Best Fit.\n    \n    # Ensure BIN_CAPACITY is not zero to prevent division by zero, though in BPP it's always positive.\n    adaptive_factor = K * (1.0 - item / BIN_CAPACITY) if BIN_CAPACITY > 0 else 0.0\n    \n    # The combined priority score:\n    # The first part (item - bins_remain_cap) is the standard Best Fit component.\n    # The second part (- adaptive_factor * bins_remain_cap) applies a penalty that is:\n    #   1. Larger (more negative) for bins with more remaining capacity (i.e., less full bins).\n    #   2. Scaled by 'adaptive_factor', meaning this penalty is more significant for smaller items.\n    # This synergistically pushes smaller items into already fuller bins while maintaining Best Fit\n    # for larger items.\n    priorities = (item - bins_remain_cap) - adaptive_factor * bins_remain_cap\n\n    # --- Handling Invalid Placements ---\n    # Crucially, any bin where the item cannot fit (resulting in negative remaining_after_placement)\n    # must be assigned the lowest possible priority (-np.inf) to ensure it is never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}