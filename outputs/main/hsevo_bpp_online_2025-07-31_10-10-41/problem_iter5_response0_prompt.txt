{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    using a Best Fit (BF) strategy based on the *proportion* of the remaining\n    capacity that the item would fill.\n\n    This heuristic prioritizes bins where the item consumes a larger fraction\n    of the *currently available* space. Bins where the item perfectly fills\n    the remaining capacity receive the highest possible priority (1.0).\n    Among bins where the item fits, those where it fills a greater proportion\n    of the remaining capacity are preferred. Bins where the item does not fit\n    are assigned the lowest possible priority (-np.inf).\n\n    This approach is a \"mutation\" of the standard Best Fit. While standard BF\n    focuses on minimizing the *absolute* remaining space, this version focuses\n    on maximizing the *relative* (proportional) utilization of the current bin space.\n    For a given item, minimizing absolute remaining space is mathematically equivalent\n    to maximizing the item's proportion of the remaining space, meaning both\n    methods yield the same optimal bin selection in terms of rank order.\n    However, the scaling of the priority scores differs, potentially offering\n    different numerical properties or a more intuitive interpretation as a \"fill ratio\".\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be > 0.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Scores range from (0.0, 1.0] for fitting bins, and -np.inf for non-fitting bins.\n    \"\"\"\n    # Initialize priority scores to negative infinity. These will be for bins\n    # where the item does not fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    # We must ensure bins_remain_cap is positive to avoid division by zero or negative capacity.\n    # If bins_remain_cap is zero, it implies the bin is already full, and if item > 0, it won't fit.\n    # The condition `bins_remain_cap >= item` implicitly handles `bins_remain_cap > 0` for `item > 0`.\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate priorities only for bins where the item fits.\n    # The priority is the ratio of the item size to the bin's remaining capacity.\n    # A higher ratio indicates a \"tighter\" fit relative to the available space.\n    # Example: if item=0.3, and bin_remain_cap=0.3, ratio = 1.0 (perfect fit).\n    # If item=0.3, and bin_remain_cap=0.6, ratio = 0.5.\n    # The division by `bins_remain_cap[fitting_bins_mask]` is safe because `fitting_bins_mask`\n    # ensures `bins_remain_cap` is at least `item`, and `item` is assumed to be > 0.\n    priorities[fitting_bins_mask] = item / bins_remain_cap[fitting_bins_mask]\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Worst Fit (WF) strategy.\n\n    Worst Fit aims to keep bins as \"open\" as possible by placing the item into the bin that will\n    have the most remaining capacity. This strategy can be beneficial for keeping large contiguous\n    spaces available for future, potentially larger, items. Bins where the item does not fit\n    are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # For Worst Fit, we want to maximize the remaining_after_placement.\n    # A larger positive value means more space left, which is preferred.\n    priorities = remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we observe a fundamental difference in strategy. Heuristic 1st implements a Best Fit (BF) strategy focusing on *proportional utilization* (`item / bins_remain_cap`), aiming to maximize the relative fill of a bin. Its docstring clarifies its mathematical equivalence in rank order to standard BF, suggesting it's a strong performer for tight packing. In contrast, Heuristic 20th employs a Worst Fit (WF) strategy (`remaining_after_placement`), aiming to keep bins as \"open\" as possible by maximizing leftover space. The ranking clearly indicates BF (proportional) is vastly superior to WF for typical bin packing objectives.\n\nComparing (2nd) vs (19th), Heuristic 2nd presents a robust Best Fit (BF) strategy (minimizing absolute remaining capacity via `-remaining_after_fit`). A key improvement here is the explicit robustness check for `item <= 0`, ensuring invalid inputs are handled gracefully. Heuristic 19th is another instance of the Worst Fit strategy, identical to 20th. This comparison reinforces the strong performance of BF over WF, and highlights the value of input validation for robustness.\n\nComparing (3rd) vs (4th), both implement Best Fit (minimizing absolute remaining capacity). Heuristic 3rd includes the `if item <= 0` robustness check and uses a distinct `potential_remainders` variable, making the logic flow very clear. Heuristic 4th achieves the same core calculation (`-remaining_after_placement`) but lacks the explicit `item <= 0` check and reassigns non-fitting priorities after an initial calculation. The higher ranking of 3rd suggests that explicit robustness checks and perhaps a slightly cleaner code structure (masking first, then calculating) are preferred.\n\nComparing (5th) vs (16th), Heuristic 5th employs a Smallest Fit (SF) strategy, prioritizing bins with the smallest *current* remaining capacity (`-bins_remain_cap`). This aims to \"fill up\" bins quickly. Heuristic 16th is a Worst Fit strategy. The ranking shows SF is considerably better than WF, indicating that focusing on filling existing bins (even if not perfectly) is more effective than leaving large gaps.\n\nComparing (11th) vs (12th), we find that these heuristics are identical and incomplete, merely performing an `item_min_threshold` check and returning a fixed invalid priority. They lack any actual packing logic. Their low ranking (11th-15th) signifies that a partially implemented or non-functional heuristic is severely penalized, ranking below even the traditionally poorer-performing Worst Fit strategies. This block of identical, incomplete functions highlights that basic functionality and completeness are paramount.\n\nOverall, the ranking strongly suggests that Best Fit variants (both proportional and absolute) are the most effective strategies for this Bin Packing context, likely due to their goal of minimizing wasted space. Robustness checks for invalid inputs contribute positively to a heuristic's perceived quality. Smallest Fit is a viable but less performant alternative to Best Fit. Worst Fit is consistently the least effective full strategy, and incomplete/broken code is the worst possible outcome. Simplicity in scaling and calculation often correlates with higher performance over overly complex, numerically fine-tuned approaches.\n- \nHere's the redefined 'Current self-reflection' for designing better bin packing heuristics:\n\n*   **Keywords:** Adaptive Strategies, Global State Inference, Feature Engineering, Multi-criteria Optimization.\n*   **Advice:** Focus on heuristics that dynamically adapt their logic based on current problem characteristics. Explore synergistic combinations of diverse packing rules. Prioritize leveraging comprehensive information about the system's global state and future implications, not just immediate fits.\n*   **Avoid:** Relying on fixed, static rules (e.g., Best Fit). Preconceived notions about the superiority of simple linear or non-linear functions for priority. Making performance claims based on limited empirical observations or specific algorithm names.\n*   **Explanation:** This approach encourages exploring a broader design space, developing more robust and intelligent heuristics by considering the evolving problem context and integrating richer information, leading to genuinely novel solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}