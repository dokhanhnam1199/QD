{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority for each bin using a \"Normalized Proportional Fit\" strategy.\n\n    This heuristic is a mutation of the Best Fit strategy, designed to be more\n    interpretable and numerically robust in its scoring. It prioritizes bins based\n    on the proportion of their current available capacity that the item would fill.\n\n    1.  **Perfect Fits:** Bins where the item fits perfectly (`bins_remain_cap == item`)\n        are given the highest possible priority (a score of `1.0`). This ensures\n        they are unequivocally chosen when available.\n    2.  **Proportional Fit (Non-Perfect):** For bins where the item fits but not\n        perfectly, the priority is calculated as `item / bins_remain_cap`. This ratio\n        represents how much of the bin's current available space the item will occupy.\n        A higher ratio indicates a tighter fit (closer to filling the remaining space).\n        This naturally prioritizes bins that leave less remaining capacity,\n        aligning with the core principle of Best Fit. A small epsilon is added to\n        the denominator to ensure numerical stability and to ensure these scores\n        are always strictly less than 1.0.\n    3.  **No Fit:** Bins where the item does not fit (`bins_remain_cap < item`)\n        are assigned the lowest possible priority (`-np.inf`), ensuring they are\n        never selected.\n\n    This approach provides scores that are always positive (for valid fits) and\n    reside within a clear range (e.g., (0, 1.0] for non-infinite scores), making\n    them more interpretable as a \"fit quality\" percentage.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item actually fits\n    fits_mask = (bins_remain_cap >= item)\n\n    # Separate masks for perfect fits and non-perfect fits\n    perfect_fit_mask = (bins_remain_cap == item)\n    non_perfect_fits_mask = fits_mask & (~perfect_fit_mask)\n\n    # Assign highest explicit priority to perfect fits\n    priorities[perfect_fit_mask] = 1.0  # Score of 1.0 for perfect fit\n\n    # For bins where the item fits but not perfectly, calculate the proportional fit score.\n    # This score will be between 0 and (1.0 - epsilon)\n    if np.any(non_perfect_fits_mask):\n        # Add a tiny machine epsilon to the denominator to prevent division by zero\n        # in theoretical edge cases (though bins_remain_cap[non_perfect_fits_mask]\n        # should always be > item, and thus > 0 if item > 0)\n        # and to ensure the score for non-perfect fits is strictly less than 1.0.\n        epsilon = np.finfo(float).eps\n        priorities[non_perfect_fits_mask] = item / (bins_remain_cap[non_perfect_fits_mask] + epsilon)\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Worst Fit (WF) strategy.\n\n    Worst Fit aims to keep bins as \"open\" as possible by placing the item into the bin that will\n    have the most remaining capacity. This strategy can be beneficial for keeping large contiguous\n    spaces available for future, potentially larger, items. Bins where the item does not fit\n    are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # For Worst Fit, we want to maximize the remaining_after_placement.\n    # A larger positive value means more space left, which is preferred.\n    priorities = remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we observe a fundamental difference in strategy. Heuristic 1st implements a Best Fit (BF) strategy focusing on *proportional utilization* (`item / bins_remain_cap`), aiming to maximize the relative fill of a bin. Its docstring clarifies its mathematical equivalence in rank order to standard BF, suggesting it's a strong performer for tight packing. In contrast, Heuristic 20th employs a Worst Fit (WF) strategy (`remaining_after_placement`), aiming to keep bins as \"open\" as possible by maximizing leftover space. The ranking clearly indicates BF (proportional) is vastly superior to WF for typical bin packing objectives.\n\nComparing (2nd) vs (19th), Heuristic 2nd presents a robust Best Fit (BF) strategy (minimizing absolute remaining capacity via `-remaining_after_fit`). A key improvement here is the explicit robustness check for `item <= 0`, ensuring invalid inputs are handled gracefully. Heuristic 19th is another instance of the Worst Fit strategy, identical to 20th. This comparison reinforces the strong performance of BF over WF, and highlights the value of input validation for robustness.\n\nComparing (3rd) vs (4th), both implement Best Fit (minimizing absolute remaining capacity). Heuristic 3rd includes the `if item <= 0` robustness check and uses a distinct `potential_remainders` variable, making the logic flow very clear. Heuristic 4th achieves the same core calculation (`-remaining_after_placement`) but lacks the explicit `item <= 0` check and reassigns non-fitting priorities after an initial calculation. The higher ranking of 3rd suggests that explicit robustness checks and perhaps a slightly cleaner code structure (masking first, then calculating) are preferred.\n\nComparing (5th) vs (16th), Heuristic 5th employs a Smallest Fit (SF) strategy, prioritizing bins with the smallest *current* remaining capacity (`-bins_remain_cap`). This aims to \"fill up\" bins quickly. Heuristic 16th is a Worst Fit strategy. The ranking shows SF is considerably better than WF, indicating that focusing on filling existing bins (even if not perfectly) is more effective than leaving large gaps.\n\nComparing (11th) vs (12th), we find that these heuristics are identical and incomplete, merely performing an `item_min_threshold` check and returning a fixed invalid priority. They lack any actual packing logic. Their low ranking (11th-15th) signifies that a partially implemented or non-functional heuristic is severely penalized, ranking below even the traditionally poorer-performing Worst Fit strategies. This block of identical, incomplete functions highlights that basic functionality and completeness are paramount.\n\nOverall, the ranking strongly suggests that Best Fit variants (both proportional and absolute) are the most effective strategies for this Bin Packing context, likely due to their goal of minimizing wasted space. Robustness checks for invalid inputs contribute positively to a heuristic's perceived quality. Smallest Fit is a viable but less performant alternative to Best Fit. Worst Fit is consistently the least effective full strategy, and incomplete/broken code is the worst possible outcome. Simplicity in scaling and calculation often correlates with higher performance over overly complex, numerically fine-tuned approaches.\n- \nHere's the redefined 'Current self-reflection' for designing better bin packing heuristics:\n\n*   **Keywords:** Adaptive Strategies, Global State Inference, Feature Engineering, Multi-criteria Optimization.\n*   **Advice:** Focus on heuristics that dynamically adapt their logic based on current problem characteristics. Explore synergistic combinations of diverse packing rules. Prioritize leveraging comprehensive information about the system's global state and future implications, not just immediate fits.\n*   **Avoid:** Relying on fixed, static rules (e.g., Best Fit). Preconceived notions about the superiority of simple linear or non-linear functions for priority. Making performance claims based on limited empirical observations or specific algorithm names.\n*   **Explanation:** This approach encourages exploring a broader design space, developing more robust and intelligent heuristics by considering the evolving problem context and integrating richer information, leading to genuinely novel solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}