```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This implementation employs a 'Best-Fit' heuristic, prioritizing bins that,
    after accommodating the item, will have the least remaining capacity (i.e., the
    tightest fit). Bins where the item cannot fit are assigned a significantly
    lower priority score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the space that would remain in each bin if the item were placed there.
    remaining_after_placement = bins_remain_cap - item

    # Initialize priorities with a very low value (negative infinity).
    # This ensures that bins incapable of holding the item are never chosen
    # when the selection mechanism picks the bin with the maximum priority.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins can accommodate the item.
    can_fit_mask = remaining_after_placement >= 0

    # For bins where the item fits, assign a priority based on the Best-Fit strategy.
    # The Best-Fit strategy aims to minimize the remaining capacity after placement.
    # To translate this into a "maximize priority" system, we use the negative of
    # the remaining capacity. A smaller positive remaining capacity (tighter fit)
    # results in a larger (closer to zero, less negative) priority score.
    # Example: If remaining_after_placement is 0.1, priority is -0.1.
    # If remaining_after_placement is 0.5, priority is -0.5.
    # -0.1 is greater than -0.5, correctly favoring the tighter fit.
    priorities[can_fit_mask] = -remaining_after_placement[can_fit_mask]

    return priorities
```
