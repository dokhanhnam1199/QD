```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.
    Inspired by the gravitational mechanics of black holes, this heuristic
    prioritizes bins that allow the item to achieve maximum density,
    leaving the smallest possible 'void' (remaining capacity).

    The gravitational pull towards a bin intensifies dramatically as the
    remaining capacity approaches zero, indicating a near-perfect 'collapse'
    of the item into the available space, much like matter nearing an event horizon.
    Bins that cannot accommodate the item are treated as impenetrable event horizons,
    receiving zero priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # A small constant, akin to a quantum fluctuation, to prevent infinite
    # priority for a perfectly zero remaining space, while still giving it
    # an overwhelmingly high score.
    epsilon = 1e-9

    # Calculate the hypothetical remaining capacity after the item is placed.
    # This represents the 'void' left in the bin.
    remaining_after_fit = bins_remain_cap - item

    # Initialize priorities. Bins incapable of holding the item start with zero priority,
    # signifying an insurmountable event horizon.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can actually fit.
    # These are the regions of spacetime where the item's 'mass' can reside.
    can_fit_mask = remaining_after_fit >= 0

    # For bins where the item fits, the priority is inversely proportional to the
    # 'void' left. The smaller the void, the stronger the 'gravitational pull'.
    # A perfect fit (void=0) results in an extremely high priority, simulating
    # the immense gravitational force at the brink of a singularity.
    priorities[can_fit_mask] = 1.0 / (remaining_after_fit[can_fit_mask] + epsilon)
    
    return priorities
```
