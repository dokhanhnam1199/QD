```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority using a Best Fit (BF) strategy, prioritizing bins that result in the smallest remaining capacity after placement.
    Handles invalid items by assigning the lowest priority.
    """
    # Initialize priority scores with negative infinity for bins where the item cannot fit
    # or if the item itself is invalid.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Robustness check: items must have a positive size to be packable.
    # If not, all bins remain at the lowest priority.
    if item <= 0:
        return priorities

    # Create a mask for bins where the item *can* fit (remaining capacity >= item size).
    fits_mask = bins_remain_cap >= item

    # For bins where the item fits, calculate the remaining capacity if the item were placed.
    # A Best Fit strategy aims to minimize this remaining capacity (i.e., find the tightest fit).
    # To assign higher priority to smaller remaining capacities, we take the negative of this value.
    # Example: If remaining_capacity = 5, priority = -5. If remaining_capacity = 50, priority = -50.
    # A value of -5 is higher (less negative) than -50, correctly prioritizing tighter fits.
    potential_remainders = bins_remain_cap[fits_mask] - item
    priorities[fits_mask] = -potential_remainders

    return priorities
```
