```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Galileo's "Best Fit" Priority: Seeks to find the most fitting
    receptacle, leaving no more space than is necessary. A tighter fit
    is akin to celestial bodies occupying their orbits with precision.
    Bins that cannot accommodate the item are cast out of consideration
    into an endless void.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities. Bins that cannot fit the item are given an
    # infinitely low priority, as if they reside in the realm beyond the
    # celestial sphere â€“ utterly unreachable.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify the 'habitable' bins, those whose remaining capacity
    # is greater than or equal to the item's size.
    can_fit_mask = bins_remain_cap >= item

    # For these suitable bins, we calculate the remaining void after the item
    # is placed. Our objective is to minimize this void, striving for the
    # most compact and precise arrangement, much like the perfect orbits.
    # Thus, a smaller remaining space yields a higher priority.
    # By negating the remaining space, the 'best fit' (smallest positive
    # remaining space, or zero for a perfect fit) will result in the
    # largest (least negative, or zero) priority score.
    fitting_bins_remaining_space = bins_remain_cap[can_fit_mask] - item
    priorities[can_fit_mask] = -fitting_bins_remaining_space

    return priorities
```
