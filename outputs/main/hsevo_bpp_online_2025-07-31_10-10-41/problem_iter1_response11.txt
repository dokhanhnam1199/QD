```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    guided by the principle of Best Fit.

    Inspired by the universe's tendency to find the most efficient
    configuration, this heuristic prioritizes bins that offer the
    tightest fit for the incoming item. By minimizing the leftover space
    within a chosen bin, we aim to conserve capacity in other bins
    for potentially larger future items, thus optimizing the overall
    packing density. A smaller remaining gap signifies a "better" fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity if the item were placed in each bin.
    # This also helps identify bins where the item does not fit (resulting in negative values).
    potential_new_remaining_capacities = bins_remain_cap - item

    # Initialize priorities. Bins where the item does not fit should have
    # a very low priority (effectively, they are not options).
    # We use -np.inf to ensure they are never chosen unless no other option exists.
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify valid bins where the item actually fits.
    # These are bins where the potential new remaining capacity is non-negative.
    valid_bins_mask = potential_new_remaining_capacities >= 0

    # For valid bins, the priority is the negative of the remaining capacity.
    # This way, the smallest positive remaining capacity (tightest fit)
    # yields the highest (least negative) priority score.
    priority_scores[valid_bins_mask] = -potential_new_remaining_capacities[valid_bins_mask]

    return priority_scores
```
