```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:
    """Returns a priority score for each bin, combining Best Fit with a "Bin Completion" bias.

    This heuristic aims to select a bin that:
    1.  Fits the item (essential, bins where the item does not fit are assigned the lowest possible priority).
    2.  Among valid fits, prioritizes Best Fit (leaving the least remaining capacity).
    3.  Additionally, applies a "Bin Completion" bias. It gives a bonus to bins that are
        already significantly full (i.e., have little remaining capacity before the item is placed).
        This encourages "finishing off" bins that are closer to being full, leading to fewer
        partially filled bins overall and potentially consolidating items more efficiently.
        This represents an adaptive strategy, prioritizing a global state objective (bin consolidation)
        alongside the immediate fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.
        bin_capacity: The maximum capacity of a single bin. Default to 1.0, assuming
                      items and bin capacities are normalized.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity after placing the item in each bin
    remaining_after_placement = bins_remain_cap - item

    # Base Best Fit priority:
    # A perfect fit (remaining_after_placement = 0) gets the highest BF score (0).
    # Less remaining capacity results in a higher score (closer to 0).
    bf_priorities = -remaining_after_placement

    # Calculate current occupancy ratio for each bin (before placing the item)
    # This ratio ranges from 0 (empty bin) to 1 (full bin).
    # We clip it to ensure values are within [0, 1] for robustness against potential
    # floating point inaccuracies or unusual initial states (though usually not expected).
    current_occupancy_ratio = (bin_capacity - bins_remain_cap) / bin_capacity
    current_occupancy_ratio = np.clip(current_occupancy_ratio, 0, 1)

    # Bin Completion Bias:
    # A bonus is applied based on how full the bin currently is.
    # The fuller the bin (higher current_occupancy_ratio), the higher the bonus.
    # This encourages packing items into bins that are already close to being completely filled.
    # The weight 'beta' controls the influence of this bias. A higher beta means this bias
    # has a stronger effect on the final priority, potentially shifting choices away from
    # pure Best Fit if a less tight fit in an already full bin is available.
    beta = 0.5  # Tunable parameter. A value of 0 effectively reverts to Best Fit.

    completion_bonus = beta * current_occupancy_ratio

    # Combine Best Fit priority with the completion bonus.
    # The primary BF priority ensures valid fits are preferred and tighter fits are generally
    # chosen. The completion bonus then adds a strategic layer to favor consolidating items
    # into bins that are already well-utilized, aiming to reduce the total number of open bins.
    priorities = bf_priorities + completion_bonus

    # Finally, set priority to negative infinity for bins where the item does not fit.
    # This ensures these bins are never selected, overriding any potential positive bonuses
    # that might have been calculated for them (e.g., if a bin was already very full
    # but the item still didn't fit).
    priorities[remaining_after_placement < 0] = -np.inf

    return priorities
```
