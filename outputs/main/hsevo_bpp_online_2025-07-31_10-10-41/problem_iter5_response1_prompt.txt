{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Refined Best Fit heuristic: prioritizes bins leaving minimal remaining capacity.\n    This enhances robustness and clarity while maintaining optimal linear priority scaling.\n    \"\"\"\n    # Initialize all priorities to a very low value (-inf) for bins where the item cannot fit or are undesirable.\n    # This uses a clear initialization method seen in priority_v1.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case of non-positive item sizes, which are outside typical BPP scope.\n    # This adds robustness, inspired by priority_v1's explicit handling of such scenarios.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    # Using boolean masking for concise and efficient array filtering, similar to priority_v1.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the remaining capacity in these fitting bins after placing the item.\n        # This is the core calculation for the \"Best Fit\" strategy, derived from priority_v0,\n        # which was identified as empirically superior due to its linear proportionality.\n        remaining_after_fit = bins_remain_cap[fitting_mask] - item\n\n        # Assign priority scores. The Best Fit heuristic prioritizes smaller remaining capacity\n        # by taking its negative. A perfect fit (0 remaining) gets 0 priority, a snug fit gets\n        # a slightly negative, and looser fits get more negative, ensuring optimal bin selection.\n        priorities[fitting_mask] = -remaining_after_fit\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    item: float,\n    bins_remain_cap: np.ndarray,\n    item_min_threshold: float = 0.05592199795804799,\n    priority_if_invalid: float = -53305.26486232452,\n    priority_score_max: float = 4.066753785007031,\n    priority_score_min: float = -0.7758139363388836) -> np.ndarray:\n    \"\"\"Returns priority, favoring tightest fits (Best Fit) with a normalized scale.\n\n    This heuristic prioritizes bins that minimize wasted space, assigning higher scores\n    to tighter linear fits (priority_score_min to priority_score_max, with priority_score_max being a perfect fit).\n    Bins incapable of holding the item receive the lowest possible priority, ensuring robustness.\n    \"\"\"\n    # Robustness check: Items less than or equal to 'item_min_threshold' are typically not valid in BPP.\n    if item <= item_min_threshold:\n        return np.full_like(bins_remain_cap, priority_if_invalid)\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we observe a fundamental difference in strategy. Heuristic 1st implements a Best Fit (BF) strategy focusing on *proportional utilization* (`item / bins_remain_cap`), aiming to maximize the relative fill of a bin. Its docstring clarifies its mathematical equivalence in rank order to standard BF, suggesting it's a strong performer for tight packing. In contrast, Heuristic 20th employs a Worst Fit (WF) strategy (`remaining_after_placement`), aiming to keep bins as \"open\" as possible by maximizing leftover space. The ranking clearly indicates BF (proportional) is vastly superior to WF for typical bin packing objectives.\n\nComparing (2nd) vs (19th), Heuristic 2nd presents a robust Best Fit (BF) strategy (minimizing absolute remaining capacity via `-remaining_after_fit`). A key improvement here is the explicit robustness check for `item <= 0`, ensuring invalid inputs are handled gracefully. Heuristic 19th is another instance of the Worst Fit strategy, identical to 20th. This comparison reinforces the strong performance of BF over WF, and highlights the value of input validation for robustness.\n\nComparing (3rd) vs (4th), both implement Best Fit (minimizing absolute remaining capacity). Heuristic 3rd includes the `if item <= 0` robustness check and uses a distinct `potential_remainders` variable, making the logic flow very clear. Heuristic 4th achieves the same core calculation (`-remaining_after_placement`) but lacks the explicit `item <= 0` check and reassigns non-fitting priorities after an initial calculation. The higher ranking of 3rd suggests that explicit robustness checks and perhaps a slightly cleaner code structure (masking first, then calculating) are preferred.\n\nComparing (5th) vs (16th), Heuristic 5th employs a Smallest Fit (SF) strategy, prioritizing bins with the smallest *current* remaining capacity (`-bins_remain_cap`). This aims to \"fill up\" bins quickly. Heuristic 16th is a Worst Fit strategy. The ranking shows SF is considerably better than WF, indicating that focusing on filling existing bins (even if not perfectly) is more effective than leaving large gaps.\n\nComparing (11th) vs (12th), we find that these heuristics are identical and incomplete, merely performing an `item_min_threshold` check and returning a fixed invalid priority. They lack any actual packing logic. Their low ranking (11th-15th) signifies that a partially implemented or non-functional heuristic is severely penalized, ranking below even the traditionally poorer-performing Worst Fit strategies. This block of identical, incomplete functions highlights that basic functionality and completeness are paramount.\n\nOverall, the ranking strongly suggests that Best Fit variants (both proportional and absolute) are the most effective strategies for this Bin Packing context, likely due to their goal of minimizing wasted space. Robustness checks for invalid inputs contribute positively to a heuristic's perceived quality. Smallest Fit is a viable but less performant alternative to Best Fit. Worst Fit is consistently the least effective full strategy, and incomplete/broken code is the worst possible outcome. Simplicity in scaling and calculation often correlates with higher performance over overly complex, numerically fine-tuned approaches.\n- \nHere's the redefined 'Current self-reflection' for designing better bin packing heuristics:\n\n*   **Keywords:** Adaptive Strategies, Global State Inference, Feature Engineering, Multi-criteria Optimization.\n*   **Advice:** Focus on heuristics that dynamically adapt their logic based on current problem characteristics. Explore synergistic combinations of diverse packing rules. Prioritize leveraging comprehensive information about the system's global state and future implications, not just immediate fits.\n*   **Avoid:** Relying on fixed, static rules (e.g., Best Fit). Preconceived notions about the superiority of simple linear or non-linear functions for priority. Making performance claims based on limited empirical observations or specific algorithm names.\n*   **Explanation:** This approach encourages exploring a broader design space, developing more robust and intelligent heuristics by considering the evolving problem context and integrating richer information, leading to genuinely novel solutions.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}