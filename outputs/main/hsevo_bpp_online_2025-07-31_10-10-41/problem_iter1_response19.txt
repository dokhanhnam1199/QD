```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a Best Fit heuristic.

    This heuristic prioritizes placing the item into the bin that will leave the smallest
    amount of remaining space after the item is placed, effectively attempting to "fill"
    bins as much as possible. Bins that cannot accommodate the item are given the lowest
    possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the space remaining in each bin *after* placing the item.
    # A smaller positive value indicates a "tighter" fit, which is preferred by Best Fit.
    space_after_placement = bins_remain_cap - item

    # Initialize a priority array. By default, set priorities to negative infinity.
    # This ensures that bins that cannot fit the item (or are implicitly not good choices)
    # will have a very low score and will not be selected unless no other option exists.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins can actually fit the item (i.e., space_after_placement is non-negative).
    can_fit_mask = space_after_placement >= 0

    # For the bins where the item can fit, calculate their priority.
    # To implement Best Fit (where we want to minimize 'space_after_placement'),
    # we take the negative of 'space_after_placement'.
    # This way, a smaller positive 'space_after_placement' (e.g., 0 for a perfect fit)
    # will result in a larger (less negative, or zero) priority score.
    # Example:
    # - If 'space_after_placement' is 0, priority is 0 (highest possible for a fit).
    # - If 'space_after_placement' is 2, priority is -2.
    # - If 'space_after_placement' is 10, priority is -10.
    # The bin with the largest priority score will be the one that offers the "best fit".
    priorities[can_fit_mask] = -space_after_placement[can_fit_mask]

    return priorities
```
