```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This priority function implements a "Best Fit" strategy, aiming to place the
    item into the bin that minimizes the remaining empty space. It rewards
    perfect fits most highly, and penalizes bins where the item does not fit.

    Rosalind Franklin's work emphasized precise and efficient structural arrangement.
    In bin packing, this translates to maximizing the utilization of each container,
    leaving as little wasted space as possible.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        - Higher score indicates higher priority.
        - Bins where the item does not fit will have a score of -np.inf.
        - Bins where the item fits perfectly will have the highest score (0).
        - Other fitting bins will have negative scores, where a score closer
          to zero indicates a "tighter" fit (less remaining space).
    """
    # Initialize all priorities to a very low value, indicating "cannot fit" or "least desirable".
    # Using -np.inf ensures these bins will not be chosen unless no other option exists.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the space that would remain if the item were placed in each bin.
    # This value will be positive if the item fits, zero for a perfect fit, and negative if it doesn't fit.
    remaining_space_after_placement = bins_remain_cap - item

    # Create a boolean mask to identify bins where the item can actually fit (remaining_space >= 0).
    can_fit_mask = remaining_space_after_placement >= 0

    # For bins where the item fits, assign a priority score.
    # The Best Fit heuristic aims to *minimize* the remaining space.
    # To convert this minimization problem into a maximization problem (for priority),
    # we negate the remaining space.
    #   - If remaining_space is 0 (perfect fit), priority is 0 (highest possible).
    #   - If remaining_space is small positive (e.g., 0.1), priority is -0.1.
    #   - If remaining_space is large positive (e.g., 0.5), priority is -0.5.
    # This naturally prioritizes smaller remaining space over larger remaining space.
    priorities[can_fit_mask] = -remaining_space_after_placement[can_fit_mask]

    return priorities
```
