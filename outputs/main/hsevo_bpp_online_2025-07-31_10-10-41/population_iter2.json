[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority, favoring tightest fits (Best Fit) with a normalized scale.\n\n    This heuristic prioritizes bins that minimize wasted space, assigning higher scores\n    to tighter linear fits (0 to 1, with 1 being a perfect fit). Bins incapable\n    of holding the item receive the lowest possible priority, ensuring robustness.\n    \"\"\"\n    # Robustness check from v1: Non-positive items are typically not valid in BPP.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate potential remaining space (wasted space) if the item were placed.\n    # This is the core \"Best Fit\" principle, shared conceptually by v0 and v1.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value, ensuring non-fitting bins are never chosen.\n    # This element is common to both v0 and v1.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually fit.\n    fitting_bins_mask = potential_remaining_space >= 0\n\n    # Extract the 'wasted space' for only the bins where the item fits.\n    wasted_space_for_fits = potential_remaining_space[fitting_bins_mask]\n\n    # Dynamically normalize priorities within the range of fitting bins.\n    # This combines the 'quantifying desirability' aspect of v1 with v0's linearity.\n    # We find the maximum 'wasted space' among currently viable bins to scale priorities.\n    if wasted_space_for_fits.size > 0:\n        max_wasted_space_among_fits = np.max(wasted_space_for_fits)\n        \n        # If all fitting bins are perfect fits (max_wasted_space is 0), assign max priority.\n        if max_wasted_space_among_fits == 0:\n            priorities[fitting_bins_mask] = 1.0\n        else:\n            # Linearly scale the priority: smallest wasted space (0) gets 1.0,\n            # largest wasted space gets 0.0. This is a linear transformation\n            # of v0's priority, ensuring a positive, normalized scale.\n            priorities[fitting_bins_mask] = 1.0 - (wasted_space_for_fits / max_wasted_space_among_fits)\n    \n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a linear Best Fit strategy: highest priority for the 'snug' fit, minimizing wasted space.\n    This simple, direct, and proportional approach has proven robust and effective compared to non-linear alternatives.\n    Bins unable to fit the item receive the lowest priority.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item are given an infinitely low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can physically fit. This is a direct and robust check.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual capacity' or 'wasted space' that would remain\n    # in each fitting bin after the item is placed. Our objective is to minimize this waste.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority as the negative of the remaining space. This linear transformation\n    # converts the goal of 'minimizing waste' into 'maximizing priority'. A smaller\n    # positive residual capacity results in a priority score closer to zero (less negative),\n    # thus becoming a higher priority choice. This direct and proportional relationship\n    # has consistently shown superior performance and interpretability.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for online Bin Packing, combining Best Fit's efficiency with robustness.\n\n    This heuristic prioritizes bins that offer the 'snuggest' fit, minimizing\n    wasted space, consistent with the Best Fit strategy. A perfect fit yields\n    the highest priority. This ensures optimal utilization and compact packing.\n    Invalid item sizes are handled robustly.\n    \"\"\"\n\n    # Robustness check: If the item size is non-positive, it's considered invalid for packing.\n    # No bin should ever be chosen for such an item. This prevents erroneous behavior\n    # for items that technically 'fit everywhere' but represent no actual packing.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # This 'potential remainder' is crucial for determining the 'snugness' of the fit.\n    potential_remainders = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that bins where\n    # the item cannot fit, or which are otherwise undesirable, are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item. Only these bins\n    # are relevant for further priority calculation.\n    can_fit_mask = potential_remainders >= 0\n\n    # For those bins where the item fits, assign a priority based on the Best Fit principle.\n    # The priority is derived from the negative of the remaining space. This means:\n    # - A remainder of 0 (a perfect fit) yields the highest priority (0).\n    # - A larger positive remainder (more wasted space) yields a lower (more negative) priority.\n    # When selecting the maximum priority, this naturally selects the smallest non-negative remainder,\n    # optimizing for the tightest possible fit and efficient space utilization.\n    priorities[can_fit_mask] = -potential_remainders[can_fit_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"A linear Best Fit heuristic. Prioritizes bins by minimizing remaining space.\n    Snug fits receive higher scores (closer to zero); non-fitting bins get lowest priority.\n    \"\"\"\n    \n    # Initialize priorities. Bins that cannot fit the item are assigned negative infinity,\n    # ensuring they are never chosen as valid candidates.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the 'wasted space' (remaining capacity after item placement) for each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Create a mask for bins where the item can actually fit (wasted_space >= 0).\n    can_fit_mask = (wasted_space >= 0)\n\n    # For bins where the item fits, assign a priority as the negative of the wasted space.\n    # This linear transformation means:\n    # - A perfect fit (wasted_space = 0) gets the highest score (0).\n    # - Smaller positive wasted space yields higher (less negative) scores.\n    # - Larger positive wasted space yields lower (more negative) scores.\n    # This directly implements the \"Best Fit\" strategy, which was identified as superior.\n    priorities[can_fit_mask] = -wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority, prioritizing bins that, after accommodating the item,\n    minimize 'wasted' space. This linear Best Fit strategy combines clarity\n    with proven efficiency for online bin packing.\n    \"\"\"\n    # Initialize all priorities to a very low value for non-viable bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a mask for bins that can physically accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate the 'wasted space' (remaining capacity - item size).\n    # This explicit intermediate variable enhances clarity, similar to v1's approach.\n    wasted_space = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority by maximizing the negative of the wasted space.\n    # This maintains the core linear relationship of Best Fit (as in v0),\n    # where a perfect fit (wasted_space = 0) yields the highest score (0).\n    priorities[can_fit_mask] = -wasted_space\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item to each bin, combining Best Fit's linearity\n    with a normalized score.\n\n    This heuristic prioritizes bins that result in the smallest remaining capacity\n    (Best Fit principle). A perfect fit yields the highest score (1.0), and the\n    priority linearly decreases as the \"wasted space\" (remaining capacity after\n    placement) increases. Bins where the item does not fit receive -np.inf.\n    This maintains the robustness of Best Fit while mapping scores to a more\n    intuitive range where 1.0 is ideal.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of priority scores for each bin. Higher score is better.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' (remaining capacity after placing the item)\n    # for only those bins where the item fits.\n    wasted_space_for_fits = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities based on wasted space.\n    # A perfect fit (wasted_space = 0) results in a priority of 1.0.\n    # As wasted_space increases, the priority linearly decreases from 1.0.\n    # This effectively shifts and scales the original Best Fit score\n    # (where a perfect fit was 0, and scores were non-positive)\n    # to a range where 1.0 is the peak.\n    priorities[can_fit_mask] = 1.0 - wasted_space_for_fits\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Refined Best Fit heuristic: prioritizes bins leaving minimal remaining capacity.\n    This enhances robustness and clarity while maintaining optimal linear priority scaling.\n    \"\"\"\n    # Initialize all priorities to a very low value (-inf) for bins where the item cannot fit or are undesirable.\n    # This uses a clear initialization method seen in priority_v1.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case of non-positive item sizes, which are outside typical BPP scope.\n    # This adds robustness, inspired by priority_v1's explicit handling of such scenarios.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    # Using boolean masking for concise and efficient array filtering, similar to priority_v1.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the remaining capacity in these fitting bins after placing the item.\n        # This is the core calculation for the \"Best Fit\" strategy, derived from priority_v0,\n        # which was identified as empirically superior due to its linear proportionality.\n        remaining_after_fit = bins_remain_cap[fitting_mask] - item\n\n        # Assign priority scores. The Best Fit heuristic prioritizes smaller remaining capacity\n        # by taking its negative. A perfect fit (0 remaining) gets 0 priority, a snug fit gets\n        # a slightly negative, and looser fits get more negative, ensuring optimal bin selection.\n        priorities[fitting_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item to each bin using a robust Best Fit strategy.\n\n    Prioritizes bins minimizing leftover space after placement, maximizing bin fullness.\n    Handles non-positive items gracefully, combining proven linear best fit with input robustness.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness: non-positive items cannot be packed, assign lowest priority.\n    # This element is adapted from the \"worse\" heuristic for improved input handling.\n    if item <= 0:\n        return priorities\n\n    # Apply the empirically superior Best Fit logic: linear negative relationship to remaining space.\n    # This maximizes the priority for bins that leave the least amount of space.\n    valid_bins_mask = bins_remain_cap >= item\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for placing an item into bins, based on a \"Best-Fit\" strategy\n    with an intuitive score scaling.\n\n    This heuristic combines the robustness of Best-Fit (prioritizing tightest fits)\n    from `priority_v0` with the clear scoring goal of `priority_v1` (perfect fit = highest score).\n    It assigns a perfect fit a priority of 1.0, with scores decreasing linearly\n    as 'wasted space' increases. Bins incapable of holding the item receive a\n    significantly low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value. This ensures bins where the item\n    # cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the 'wasted space' (or remaining capacity after placement)\n    # for each bin if the item were placed there.\n    # A negative 'wasted_space' indicates the item does not fit.\n    wasted_space = bins_remain_cap - item\n\n    # Create a mask to identify only those bins where the item can fit.\n    can_fit_mask = wasted_space >= 0\n\n    # For bins that can accommodate the item, assign a priority score.\n    # The 'Best-Fit' principle aims to minimize 'wasted_space'.\n    # To align with the goal of 'highest priority for perfect fit' (like exp(0)=1 in v1),\n    # we use a linear transformation: 1.0 - wasted_space.\n    # This means:\n    # - If wasted_space is 0 (perfect fit), priority is 1.0 (highest).\n    # - As wasted_space increases, priority linearly decreases from 1.0.\n    # This preserves the relative ordering of bins as in 'priority_v0' (Best-Fit)\n    # but scales the scores for more intuitive interpretation.\n    priorities[can_fit_mask] = 1.0 - wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding item to each bin.\n\n    This heuristic combines Best Fit's linear efficiency with a bonus for perfect fits.\n    It prioritizes bins that perfectly contain the item, then ranks others by minimizing\n    remaining capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins that can accommodate the item.\n    valid_bins_mask = bins_remain_cap >= item\n\n    # 2. Calculate the 'wasted space' if the item were placed in each valid bin.\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n\n    # 3. Apply the core Best Fit strategy: lower leftover space means higher priority.\n    # This assigns priorities as the negative of the leftover space (0 for perfect fit,\n    # then increasingly negative for looser fits).\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    # 4. Enhance perfect fits with a significant bonus (element from v1's intent).\n    # This implements the idea of strongly preferring perfect fits (like v1's exp(0)=1.0),\n    # but uses a linear constant bonus instead of exponential decay to maintain performance.\n    # The bonus must be greater than any negative priority from non-perfect fits.\n    BONUS_PERFECT_FIT = 100.0 \n    \n    # Identify bins where the item fits perfectly (leftover space is zero or very close to zero).\n    perfect_fit_mask = valid_bins_mask & np.isclose(leftover_space_if_placed, 0.0, atol=1e-9)\n    \n    # Apply the bonus only to perfect fits.\n    priorities[perfect_fit_mask] = BONUS_PERFECT_FIT\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]