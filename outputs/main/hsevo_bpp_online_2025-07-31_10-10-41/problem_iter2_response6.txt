```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Refined Best Fit heuristic: prioritizes bins leaving minimal remaining capacity.
    This enhances robustness and clarity while maintaining optimal linear priority scaling.
    """
    # Initialize all priorities to a very low value (-inf) for bins where the item cannot fit or are undesirable.
    # This uses a clear initialization method seen in priority_v1.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Handle the edge case of non-positive item sizes, which are outside typical BPP scope.
    # This adds robustness, inspired by priority_v1's explicit handling of such scenarios.
    if item <= 0:
        return priorities

    # Identify all bins where the current item can physically fit.
    # Using boolean masking for concise and efficient array filtering, similar to priority_v1.
    fitting_mask = bins_remain_cap >= item

    # Proceed only if there's at least one bin where the item can fit.
    if np.any(fitting_mask):
        # Calculate the remaining capacity in these fitting bins after placing the item.
        # This is the core calculation for the "Best Fit" strategy, derived from priority_v0,
        # which was identified as empirically superior due to its linear proportionality.
        remaining_after_fit = bins_remain_cap[fitting_mask] - item

        # Assign priority scores. The Best Fit heuristic prioritizes smaller remaining capacity
        # by taking its negative. A perfect fit (0 remaining) gets 0 priority, a snug fit gets
        # a slightly negative, and looser fits get more negative, ensuring optimal bin selection.
        priorities[fitting_mask] = -remaining_after_fit

    return priorities
```
