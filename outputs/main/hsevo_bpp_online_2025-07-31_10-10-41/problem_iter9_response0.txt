```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, enhancing Best Fit with a perfect fit bonus.

    This function builds upon the Best Fit (BF) strategy (prioritizing bins that leave less remaining capacity)
    and incorporates a significant additive bonus for bins where the item perfectly fills the bin,
    thereby encouraging bin completion.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the remaining capacity after placing the item in each bin
    remaining_after_placement = bins_remain_cap - item

    # Initialize priority scores based on the Best Fit (BF) strategy.
    # A smaller positive `remaining_after_placement` value indicates a better fit.
    # To convert this into a maximization problem (higher priority is better),
    # we take the negative of `remaining_after_placement`.
    # For example:
    #   - If remaining=0 (perfect fit), initial priority is 0.
    #   - If remaining=0.1 (tight fit), initial priority is -0.1.
    #   - If remaining=0.5 (loose fit), initial priority is -0.5.
    priorities = -remaining_after_placement

    # --- Additive Incentive: Perfect Fit / Bin Completion Bonus ---
    # Define a substantial bonus for bins where the item fits perfectly,
    # leading to the bin being completely filled. This encourages closing bins.
    # The bonus value should be significantly larger than the range of
    # Best Fit scores for non-perfect fits (which are typically between -BIN_CAPACITY and 0).
    # Assuming common bin capacities (e.g., 1.0 if normalized), Best Fit scores
    # will be in [-1.0, 0). A bonus of 10.0 ensures perfect fits are highly preferred.
    PERFECT_FIT_BONUS = 10.0

    # Use a small epsilon for robust floating-point comparison to identify perfect fits.
    # A bin is considered "perfectly fit" if its remaining capacity after placement
    # is numerically very close to zero.
    EPSILON = 1e-9

    # Apply the perfect fit bonus to the relevant bins.
    # This check identifies bins that will have approximately zero remaining capacity
    # after the item is placed.
    perfect_fit_mask = np.abs(remaining_after_placement) < EPSILON
    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS

    # --- Core Placement Logic Validation: Handle Non-Fitting Items ---
    # For bins where the item does not fit (i.e., `remaining_after_placement` is negative),
    # assign the lowest possible priority (`-np.inf`) to ensure they are never selected.
    # This step correctly overrides any temporary positive values that might arise if
    # `remaining_after_placement` was negative before the `-` operation (e.g., `-(-0.5)` yields `0.5`),
    # ensuring only bins where the item physically fits can be chosen.
    priorities[remaining_after_placement < 0] = -np.inf

    return priorities
```
