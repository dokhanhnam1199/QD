```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin,
    inspired by a Best-Fit decreasing-gap strategy for optimal packing.

    As a scientist, I sought to organize and utilize every resource with utmost efficiency.
    This heuristic embodies that principle by prioritizing the bins that, after accommodating
    the current item, will have the least remaining "empty" space. This minimizes the
    "radioactive waste" of unused capacity in bins, leading to a tighter overall packing
    and fewer bins utilized, much like carefully isolating a new element into the smallest
    effective container. Bins unable to contain the item are, of course, discarded from
    consideration.

    Args:
        item: Size of item to be added to the bin. This is the "activity" of our element.
        bins_remain_cap: Array of capacities for each bin. These are our "containers".

    Return:
        Array of same size as bins_remain_cap with priority score for each bin.
        A higher score indicates a more desirable bin.
    """
    # Initialize all priorities to a very low value (effectively ruling out non-viable bins).
    # Just as an empty flask cannot contain a sample.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a mask for bins that can physically accommodate the item.
    # We must only consider containers that are large enough.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, calculate their score.
    # The goal is to minimize the remaining capacity (bins_remain_cap - item) after placement.
    # To achieve this with a "highest score wins" selection, we maximize the negative of
    # the remaining capacity: -(bins_remain_cap - item), which simplifies to (item - bins_remain_cap).
    # A perfect fit (bins_remain_cap == item) results in a score of 0.0, which is the highest
    # possible score, signifying the most efficient use of space. All other valid fits
    # will result in negative scores, with smaller absolute values indicating tighter fits.
    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]

    return priorities
```
