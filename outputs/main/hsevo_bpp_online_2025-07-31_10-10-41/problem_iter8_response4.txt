```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with strong prioritization for perfect fits and a bonus for near-perfect fits.
    """
    # Initialize all priorities to negative infinity, indicating bins where item cannot fit initially.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Robustness check: items must have a positive size to be packable.
    if item <= 0:
        return priorities

    # Calculate the remaining capacity for each bin if the item were placed.
    potential_remainders = bins_remain_cap - item

    # Create a mask for bins where the item *can* physically fit.
    fits_mask = potential_remainders >= 0

    # 1. Core Best Fit (BF) Strategy:
    # For bins where the item fits, calculate the priority as the negative of the remaining space.
    # This means smaller remaining space (tighter fit) results in a higher (less negative) priority.
    priorities[fits_mask] = -potential_remainders[fits_mask]

    # 2. Strong Prioritization for Perfect Fits:
    # If an item perfectly fills a bin (remainder is exactly zero), assign the highest possible priority.
    # This leverages the insight that perfect fits are highly desirable.
    perfect_fit_mask = (potential_remainders == 0) & fits_mask
    priorities[perfect_fit_mask] = np.inf

    # 3. Additive Bonus for Near-Perfect Fits (Bin Completion Incentive):
    # Apply a significant, but not infinite, bonus for bins that are left with
    # a very small amount of remaining capacity after placement. This encourages
    # 'completing' bins by leaving minimal waste.
    # EPSILON defines what "very small" means for remaining capacity.
    EPSILON = 1e-6 
    BONUS_FOR_NEAR_PERFECT = 1000.0 # A substantial bonus to elevate these fits

    near_perfect_fit_mask = (potential_remainders > 0) & (potential_remainders <= EPSILON) & fits_mask
    priorities[near_perfect_fit_mask] += BONUS_FOR_NEAR_PERFECT

    return priorities
```
