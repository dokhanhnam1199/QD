```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for adding an item using a robust Proportional Best Fit strategy.

    Prioritizes bins by maximizing the proportion of their capacity filled by the item.
    Handles invalid inputs (non-positive items) gracefully.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Incorporate robustness (from priority_v0): non-positive items cannot be packed, assign lowest priority.
    if item <= 0:
        return priorities

    # Identify bins where the item can fit (similar to priority_v0 and implicitly in priority_v1's logic).
    valid_bins_mask = bins_remain_cap >= item

    # Apply Proportional Best Fit strategy (refining a concept hinted in priority_v0's docstring):
    # Prioritize bins that would be most "filled up" by the item relative to their current capacity.
    # This promotes efficient use of space by maximizing `item / current_bin_capacity` for valid bins.
    # Bins where the item fits will have `bins_remain_cap` >= `item` > 0, preventing division by zero.
    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]

    return priorities
```
