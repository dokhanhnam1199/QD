```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    As Isaac Newton, I view the Universe, and indeed problems such as Bin Packing,
    as systems that strive towards an optimal state of arrangement and efficiency.
    My heuristic for prioritizing bins is inspired by the principle of 'Best Fit',
    which in my physical understanding, aligns with minimizing potential energy
    or waste within a system.

    Imagine each bin as a potential well, and the item as a body seeking to fall
    into the shallowest suitable well. The most 'attractive' bin is not merely
    one that can contain the item, but one that snugly contains it, leaving the
    least 'void' or 'unused potential'. This tight packing minimizes the
    'gravitational pull' for future items to gravitate towards newly opened bins,
    thus conserving the total number of containers required.

    The priority for a suitable bin is calculated as the negative of the
    remaining capacity after the item is placed. This converts the pursuit of
    the *minimum* wasted space into a *maximization* problem, where the bin with
    the highest priority (i.e., the least negative remaining space) is chosen.
    Bins that are too small to accommodate the item are given an infinitely
    low priority, rendering them impenetrable barriers.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities for all bins. Bins that cannot fit the item
    # are assigned a negative infinity priority, making them effectively
    # impossible choices, akin to insurmountable obstacles.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify the bins where the item can physically fit.
    # These are the 'accessible' regions in our potential landscape.
    can_fit_mask = bins_remain_cap >= item

    # Calculate the 'residual capacity' or 'potential void' that would remain
    # in each fitting bin after the item is placed. Our aim is to minimize this value.
    remaining_after_fit = bins_remain_cap[can_fit_mask] - item

    # To convert the goal of 'minimizing residual capacity' into a 'maximization
    # of priority', we take the negative of the residual capacity.
    # A smaller positive residual capacity results in a priority score closer to zero
    # (i.e., less negative), thus becoming a higher priority choice.
    priorities[can_fit_mask] = -remaining_after_fit

    return priorities
```
