```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Proportional Best Fit with a strong bonus for perfect fits.

    Prioritizes bins where the item fills a larger proportion of remaining capacity,
    with a significant boost for bins where the item fits exactly.
    """
    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Robustness check: Items with non-positive sizes are invalid in typical BPP.
    if item <= 0:
        return priorities

    # Identify all bins where the current item can physically fit.
    fitting_mask = bins_remain_cap >= item

    # Proceed only if there's at least one bin where the item can fit.
    if np.any(fitting_mask):
        # Base priority: Proportional Best Fit (from priority_v0).
        # This maximizes the ratio of item size to remaining bin capacity,
        # promoting efficient utilization and minimizing wasted space within a bin.
        current_priorities = item / bins_remain_cap[fitting_mask]

        # Identify bins where the item fits perfectly (remaining capacity equals item size).
        perfect_fit_mask = (bins_remain_cap[fitting_mask] == item)

        # Apply a significant, non-infinite bonus to perfect fits.
        # This strongly prioritizes closing bins exactly, as suggested by the analysis
        # ("Strongly prioritize perfect item-bin fits"), while avoiding the potential
        # rigidity of an infinite score if other factors might rarely matter.
        # A large constant ensures these scores are strictly higher than any
        # non-perfect proportional fit (which are always <= 1.0).
        current_priorities[perfect_fit_mask] += 100.0

        # Assign the calculated priorities to the fitting bins.
        priorities[fitting_mask] = current_priorities

    return priorities
```
