[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority, favoring tightest fits (Best Fit) with a normalized scale.\n\n    This heuristic prioritizes bins that minimize wasted space, assigning higher scores\n    to tighter linear fits (0 to 1, with 1 being a perfect fit). Bins incapable\n    of holding the item receive the lowest possible priority, ensuring robustness.\n    \"\"\"\n    # Robustness check from v1: Non-positive items are typically not valid in BPP.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate potential remaining space (wasted space) if the item were placed.\n    # This is the core \"Best Fit\" principle, shared conceptually by v0 and v1.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value, ensuring non-fitting bins are never chosen.\n    # This element is common to both v0 and v1.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually fit.\n    fitting_bins_mask = potential_remaining_space >= 0\n\n    # Extract the 'wasted space' for only the bins where the item fits.\n    wasted_space_for_fits = potential_remaining_space[fitting_bins_mask]\n\n    # Dynamically normalize priorities within the range of fitting bins.\n    # This combines the 'quantifying desirability' aspect of v1 with v0's linearity.\n    # We find the maximum 'wasted space' among currently viable bins to scale priorities.\n    if wasted_space_for_fits.size > 0:\n        max_wasted_space_among_fits = np.max(wasted_space_for_fits)\n        \n        # If all fitting bins are perfect fits (max_wasted_space is 0), assign max priority.\n        if max_wasted_space_among_fits == 0:\n            priorities[fitting_bins_mask] = 1.0\n        else:\n            # Linearly scale the priority: smallest wasted space (0) gets 1.0,\n            # largest wasted space gets 0.0. This is a linear transformation\n            # of v0's priority, ensuring a positive, normalized scale.\n            priorities[fitting_bins_mask] = 1.0 - (wasted_space_for_fits / max_wasted_space_among_fits)\n    \n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a linear Best Fit strategy: highest priority for the 'snug' fit, minimizing wasted space.\n    This simple, direct, and proportional approach has proven robust and effective compared to non-linear alternatives.\n    Bins unable to fit the item receive the lowest priority.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item are given an infinitely low priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can physically fit. This is a direct and robust check.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual capacity' or 'wasted space' that would remain\n    # in each fitting bin after the item is placed. Our objective is to minimize this waste.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority as the negative of the remaining space. This linear transformation\n    # converts the goal of 'minimizing waste' into 'maximizing priority'. A smaller\n    # positive residual capacity results in a priority score closer to zero (less negative),\n    # thus becoming a higher priority choice. This direct and proportional relationship\n    # has consistently shown superior performance and interpretability.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for online Bin Packing, combining Best Fit's efficiency with robustness.\n\n    This heuristic prioritizes bins that offer the 'snuggest' fit, minimizing\n    wasted space, consistent with the Best Fit strategy. A perfect fit yields\n    the highest priority. This ensures optimal utilization and compact packing.\n    Invalid item sizes are handled robustly.\n    \"\"\"\n\n    # Robustness check: If the item size is non-positive, it's considered invalid for packing.\n    # No bin should ever be chosen for such an item. This prevents erroneous behavior\n    # for items that technically 'fit everywhere' but represent no actual packing.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # This 'potential remainder' is crucial for determining the 'snugness' of the fit.\n    potential_remainders = bins_remain_cap - item\n\n    # Initialize all priorities to negative infinity. This ensures that bins where\n    # the item cannot fit, or which are otherwise undesirable, are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item. Only these bins\n    # are relevant for further priority calculation.\n    can_fit_mask = potential_remainders >= 0\n\n    # For those bins where the item fits, assign a priority based on the Best Fit principle.\n    # The priority is derived from the negative of the remaining space. This means:\n    # - A remainder of 0 (a perfect fit) yields the highest priority (0).\n    # - A larger positive remainder (more wasted space) yields a lower (more negative) priority.\n    # When selecting the maximum priority, this naturally selects the smallest non-negative remainder,\n    # optimizing for the tightest possible fit and efficient space utilization.\n    priorities[can_fit_mask] = -potential_remainders[can_fit_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"A linear Best Fit heuristic. Prioritizes bins by minimizing remaining space.\n    Snug fits receive higher scores (closer to zero); non-fitting bins get lowest priority.\n    \"\"\"\n    \n    # Initialize priorities. Bins that cannot fit the item are assigned negative infinity,\n    # ensuring they are never chosen as valid candidates.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the 'wasted space' (remaining capacity after item placement) for each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Create a mask for bins where the item can actually fit (wasted_space >= 0).\n    can_fit_mask = (wasted_space >= 0)\n\n    # For bins where the item fits, assign a priority as the negative of the wasted space.\n    # This linear transformation means:\n    # - A perfect fit (wasted_space = 0) gets the highest score (0).\n    # - Smaller positive wasted space yields higher (less negative) scores.\n    # - Larger positive wasted space yields lower (more negative) scores.\n    # This directly implements the \"Best Fit\" strategy, which was identified as superior.\n    priorities[can_fit_mask] = -wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority, prioritizing bins that, after accommodating the item,\n    minimize 'wasted' space. This linear Best Fit strategy combines clarity\n    with proven efficiency for online bin packing.\n    \"\"\"\n    # Initialize all priorities to a very low value for non-viable bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a mask for bins that can physically accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate the 'wasted space' (remaining capacity - item size).\n    # This explicit intermediate variable enhances clarity, similar to v1's approach.\n    wasted_space = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priority by maximizing the negative of the wasted space.\n    # This maintains the core linear relationship of Best Fit (as in v0),\n    # where a perfect fit (wasted_space = 0) yields the highest score (0).\n    priorities[can_fit_mask] = -wasted_space\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item to each bin, combining Best Fit's linearity\n    with a normalized score.\n\n    This heuristic prioritizes bins that result in the smallest remaining capacity\n    (Best Fit principle). A perfect fit yields the highest score (1.0), and the\n    priority linearly decreases as the \"wasted space\" (remaining capacity after\n    placement) increases. Bins where the item does not fit receive -np.inf.\n    This maintains the robustness of Best Fit while mapping scores to a more\n    intuitive range where 1.0 is ideal.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of priority scores for each bin. Higher score is better.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' (remaining capacity after placing the item)\n    # for only those bins where the item fits.\n    wasted_space_for_fits = bins_remain_cap[can_fit_mask] - item\n\n    # Assign priorities based on wasted space.\n    # A perfect fit (wasted_space = 0) results in a priority of 1.0.\n    # As wasted_space increases, the priority linearly decreases from 1.0.\n    # This effectively shifts and scales the original Best Fit score\n    # (where a perfect fit was 0, and scores were non-positive)\n    # to a range where 1.0 is the peak.\n    priorities[can_fit_mask] = 1.0 - wasted_space_for_fits\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Refined Best Fit heuristic: prioritizes bins leaving minimal remaining capacity.\n    This enhances robustness and clarity while maintaining optimal linear priority scaling.\n    \"\"\"\n    # Initialize all priorities to a very low value (-inf) for bins where the item cannot fit or are undesirable.\n    # This uses a clear initialization method seen in priority_v1.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle the edge case of non-positive item sizes, which are outside typical BPP scope.\n    # This adds robustness, inspired by priority_v1's explicit handling of such scenarios.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    # Using boolean masking for concise and efficient array filtering, similar to priority_v1.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the remaining capacity in these fitting bins after placing the item.\n        # This is the core calculation for the \"Best Fit\" strategy, derived from priority_v0,\n        # which was identified as empirically superior due to its linear proportionality.\n        remaining_after_fit = bins_remain_cap[fitting_mask] - item\n\n        # Assign priority scores. The Best Fit heuristic prioritizes smaller remaining capacity\n        # by taking its negative. A perfect fit (0 remaining) gets 0 priority, a snug fit gets\n        # a slightly negative, and looser fits get more negative, ensuring optimal bin selection.\n        priorities[fitting_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item to each bin using a robust Best Fit strategy.\n\n    Prioritizes bins minimizing leftover space after placement, maximizing bin fullness.\n    Handles non-positive items gracefully, combining proven linear best fit with input robustness.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness: non-positive items cannot be packed, assign lowest priority.\n    # This element is adapted from the \"worse\" heuristic for improved input handling.\n    if item <= 0:\n        return priorities\n\n    # Apply the empirically superior Best Fit logic: linear negative relationship to remaining space.\n    # This maximizes the priority for bins that leave the least amount of space.\n    valid_bins_mask = bins_remain_cap >= item\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for placing an item into bins, based on a \"Best-Fit\" strategy\n    with an intuitive score scaling.\n\n    This heuristic combines the robustness of Best-Fit (prioritizing tightest fits)\n    from `priority_v0` with the clear scoring goal of `priority_v1` (perfect fit = highest score).\n    It assigns a perfect fit a priority of 1.0, with scores decreasing linearly\n    as 'wasted space' increases. Bins incapable of holding the item receive a\n    significantly low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities to a very low value. This ensures bins where the item\n    # cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the 'wasted space' (or remaining capacity after placement)\n    # for each bin if the item were placed there.\n    # A negative 'wasted_space' indicates the item does not fit.\n    wasted_space = bins_remain_cap - item\n\n    # Create a mask to identify only those bins where the item can fit.\n    can_fit_mask = wasted_space >= 0\n\n    # For bins that can accommodate the item, assign a priority score.\n    # The 'Best-Fit' principle aims to minimize 'wasted_space'.\n    # To align with the goal of 'highest priority for perfect fit' (like exp(0)=1 in v1),\n    # we use a linear transformation: 1.0 - wasted_space.\n    # This means:\n    # - If wasted_space is 0 (perfect fit), priority is 1.0 (highest).\n    # - As wasted_space increases, priority linearly decreases from 1.0.\n    # This preserves the relative ordering of bins as in 'priority_v0' (Best-Fit)\n    # but scales the scores for more intuitive interpretation.\n    priorities[can_fit_mask] = 1.0 - wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding item to each bin.\n\n    This heuristic combines Best Fit's linear efficiency with a bonus for perfect fits.\n    It prioritizes bins that perfectly contain the item, then ranks others by minimizing\n    remaining capacity.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # 1. Identify bins that can accommodate the item.\n    valid_bins_mask = bins_remain_cap >= item\n\n    # 2. Calculate the 'wasted space' if the item were placed in each valid bin.\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n\n    # 3. Apply the core Best Fit strategy: lower leftover space means higher priority.\n    # This assigns priorities as the negative of the leftover space (0 for perfect fit,\n    # then increasingly negative for looser fits).\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    # 4. Enhance perfect fits with a significant bonus (element from v1's intent).\n    # This implements the idea of strongly preferring perfect fits (like v1's exp(0)=1.0),\n    # but uses a linear constant bonus instead of exponential decay to maintain performance.\n    # The bonus must be greater than any negative priority from non-perfect fits.\n    BONUS_PERFECT_FIT = 100.0 \n    \n    # Identify bins where the item fits perfectly (leftover space is zero or very close to zero).\n    perfect_fit_mask = valid_bins_mask & np.isclose(leftover_space_if_placed, 0.0, atol=1e-9)\n    \n    # Apply the bonus only to perfect fits.\n    priorities[perfect_fit_mask] = BONUS_PERFECT_FIT\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using a Best Fit strategy based on the\n    proportion of available bin space consumed by the item.\n\n    This heuristic prioritizes bins where the item consumes a larger fraction\n    of the bin's remaining capacity. This is a direct measure of \"tightness of fit\"\n    expressed proportionally, aligning with the principles of simplicity, directness,\n    and interpretability. A perfect fit will yield a score of 1.0.\n\n    Args:\n        item: Size of item to be added to the bin. Must be non-negative.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Bins where the item does not fit are assigned the lowest possible priority (-np.inf).\n    \"\"\"\n    # Initialize priority scores to negative infinity.\n    # This ensures that bins where the item cannot fit are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # A mask for bins where the item can physically fit (remaining capacity is greater than or equal to item size).\n    # We also ensure bins_remain_cap is positive to avoid division by zero.\n    # Note: If item is 0, it fits into any bin with >0 capacity and yields a ratio of 0.\n    # If a bin has 0 remaining capacity, it's not a valid fit for any item > 0.\n    # If item is 0 and bin_remain_cap is 0, it's technically a \"fit\", but 0/0 is undefined.\n    # The `bins_remain_cap > 0` condition handles this gracefully.\n    can_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap > 0)\n\n    # Calculate the priority score for valid bins.\n    # The score is the ratio of the item's size to the bin's remaining capacity.\n    # A higher ratio (closer to 1.0) indicates a better, tighter fit, as the item\n    # fills a larger proportion of the available space.\n    # Example:\n    #   item = 5\n    #   Bin A (cap=10): score = 5/10 = 0.5\n    #   Bin B (cap=6):  score = 5/6  = 0.833...\n    #   Bin C (cap=5):  score = 5/5  = 1.0 (perfect fit)\n    # This prioritizes Bin C > Bin B > Bin A, which is consistent with Best Fit.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using a \"Normalized Proportional Fit\" strategy.\n\n    This heuristic is a mutation of the Best Fit strategy, designed to be more\n    interpretable and numerically robust in its scoring. It prioritizes bins based\n    on the proportion of their current available capacity that the item would fill.\n\n    1.  **Perfect Fits:** Bins where the item fits perfectly (`bins_remain_cap == item`)\n        are given the highest possible priority (a score of `1.0`). This ensures\n        they are unequivocally chosen when available.\n    2.  **Proportional Fit (Non-Perfect):** For bins where the item fits but not\n        perfectly, the priority is calculated as `item / bins_remain_cap`. This ratio\n        represents how much of the bin's current available space the item will occupy.\n        A higher ratio indicates a tighter fit (closer to filling the remaining space).\n        This naturally prioritizes bins that leave less remaining capacity,\n        aligning with the core principle of Best Fit. A small epsilon is added to\n        the denominator to ensure numerical stability and to ensure these scores\n        are always strictly less than 1.0.\n    3.  **No Fit:** Bins where the item does not fit (`bins_remain_cap < item`)\n        are assigned the lowest possible priority (`-np.inf`), ensuring they are\n        never selected.\n\n    This approach provides scores that are always positive (for valid fits) and\n    reside within a clear range (e.g., (0, 1.0] for non-infinite scores), making\n    them more interpretable as a \"fit quality\" percentage.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item actually fits\n    fits_mask = (bins_remain_cap >= item)\n\n    # Separate masks for perfect fits and non-perfect fits\n    perfect_fit_mask = (bins_remain_cap == item)\n    non_perfect_fits_mask = fits_mask & (~perfect_fit_mask)\n\n    # Assign highest explicit priority to perfect fits\n    priorities[perfect_fit_mask] = 1.0  # Score of 1.0 for perfect fit\n\n    # For bins where the item fits but not perfectly, calculate the proportional fit score.\n    # This score will be between 0 and (1.0 - epsilon)\n    if np.any(non_perfect_fits_mask):\n        # Add a tiny machine epsilon to the denominator to prevent division by zero\n        # in theoretical edge cases (though bins_remain_cap[non_perfect_fits_mask]\n        # should always be > item, and thus > 0 if item > 0)\n        # and to ensure the score for non-perfect fits is strictly less than 1.0.\n        epsilon = np.finfo(float).eps\n        priorities[non_perfect_fits_mask] = item / (bins_remain_cap[non_perfect_fits_mask] + epsilon)\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    using a Best Fit (BF) strategy based on the *proportion* of the remaining\n    capacity that the item would fill.\n\n    This heuristic prioritizes bins where the item consumes a larger fraction\n    of the *currently available* space. Bins where the item perfectly fills\n    the remaining capacity receive the highest possible priority (1.0).\n    Among bins where the item fits, those where it fills a greater proportion\n    of the remaining capacity are preferred. Bins where the item does not fit\n    are assigned the lowest possible priority (-np.inf).\n\n    This approach is a \"mutation\" of the standard Best Fit. While standard BF\n    focuses on minimizing the *absolute* remaining space, this version focuses\n    on maximizing the *relative* (proportional) utilization of the current bin space.\n    For a given item, minimizing absolute remaining space is mathematically equivalent\n    to maximizing the item's proportion of the remaining space, meaning both\n    methods yield the same optimal bin selection in terms of rank order.\n    However, the scaling of the priority scores differs, potentially offering\n    different numerical properties or a more intuitive interpretation as a \"fill ratio\".\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be > 0.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Scores range from (0.0, 1.0] for fitting bins, and -np.inf for non-fitting bins.\n    \"\"\"\n    # Initialize priority scores to negative infinity. These will be for bins\n    # where the item does not fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    # We must ensure bins_remain_cap is positive to avoid division by zero or negative capacity.\n    # If bins_remain_cap is zero, it implies the bin is already full, and if item > 0, it won't fit.\n    # The condition `bins_remain_cap >= item` implicitly handles `bins_remain_cap > 0` for `item > 0`.\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate priorities only for bins where the item fits.\n    # The priority is the ratio of the item size to the bin's remaining capacity.\n    # A higher ratio indicates a \"tighter\" fit relative to the available space.\n    # Example: if item=0.3, and bin_remain_cap=0.3, ratio = 1.0 (perfect fit).\n    # If item=0.3, and bin_remain_cap=0.6, ratio = 0.5.\n    # The division by `bins_remain_cap[fitting_bins_mask]` is safe because `fitting_bins_mask`\n    # ensures `bins_remain_cap` is at least `item`, and `item` is assumed to be > 0.\n    priorities[fitting_bins_mask] = item / bins_remain_cap[fitting_bins_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Worst Fit (WF) strategy.\n\n    Worst Fit aims to keep bins as \"open\" as possible by placing the item into the bin that will\n    have the most remaining capacity. This strategy can be beneficial for keeping large contiguous\n    spaces available for future, potentially larger, items. Bins where the item does not fit\n    are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores.\n    # For Worst Fit, we want to maximize the remaining_after_placement.\n    # A larger positive value means more space left, which is preferred.\n    priorities = remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Smallest Fit (SF) strategy.\n\n    Bins with the smallest current remaining capacity (among those where the item fits) get the highest priority.\n    This aims to \"fill up\" bins that are already partially used, prioritizing them over larger, emptier bins,\n    while still ensuring the item fits. Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priority scores with negative infinity for bins where the item cannot fit\n    # and a temporary value for bins where it can fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Find bins where the item fits\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, assign a priority based on their *current* remaining capacity.\n    # We want to prioritize bins with smaller remaining capacity (i.e., those that are more full).\n    # To do this, we take the negative of the bins_remain_cap.\n    # A smaller bins_remain_cap (e.g., 20) results in a larger (less negative) priority score (-20)\n    # compared to a larger bins_remain_cap (e.g., 100) which results in a smaller (more negative) score (-100).\n    priorities[fits_mask] = -bins_remain_cap[fits_mask]\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response0.txt_stdout.txt",
    "code_path": "problem_iter4_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    item_min_threshold: float = 0.05592199795804799,\n    priority_if_invalid: float = -53305.26486232452,\n    priority_score_max: float = 4.066753785007031,\n    priority_score_min: float = -0.7758139363388836) -> np.ndarray:\n    \"\"\"Returns priority, favoring tightest fits (Best Fit) with a normalized scale.\n\n    This heuristic prioritizes bins that minimize wasted space, assigning higher scores\n    to tighter linear fits (priority_score_min to priority_score_max, with priority_score_max being a perfect fit).\n    Bins incapable of holding the item receive the lowest possible priority, ensuring robustness.\n    \"\"\"\n    # Robustness check: Items less than or equal to 'item_min_threshold' are typically not valid in BPP.\n    if item <= item_min_threshold:\n        return np.full_like(bins_remain_cap, priority_if_invalid)",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]