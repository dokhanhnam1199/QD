[
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).\n    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.\n    \"\"\"\n    # Initialize priority scores to negative infinity for non-fitting or invalid cases.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit.\n    fitting_bins_mask = bins_remain_cap >= item\n\n    # Calculate priorities for fitting bins by combining two effective strategies:\n    # 1. Proportional Best Fit: `item / bins_remain_cap` (maximizes relative fill).\n    # 2. Smallest Fit: `-bins_remain_cap` (prioritizes bins with less remaining space to close them).\n    # The sum balances maximizing the item's proportional use of space with minimizing the bin's overall remaining space.\n    priorities[fitting_bins_mask] = \\\n        (item / bins_remain_cap[fitting_bins_mask]) + \\\n        (-bins_remain_cap[fitting_bins_mask])\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Adaptive Best Fit: Prioritizes bins maximizing relative fill, promoting efficient bin usage.\n    This heuristic favors bins where the item constitutes a larger proportion of the remaining capacity,\n    a strategy robustly outperforming Worst Fit by minimizing wasted space dynamically.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid in typical BPP.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the \"proportional utilization\" for the fitting bins.\n        # This score represents how much of the bin's *remaining* capacity the item will fill.\n        # A higher ratio (closer to 1.0) indicates a tighter, more efficient fit.\n        # This strategy is a powerful form of Best Fit, effectively balancing item size\n        # against available bin space. Perfect fits (item fills bin exactly) result in a score of 1.0.\n        priorities[fitting_mask] = item / bins_remain_cap[fitting_mask]\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response2.txt_stdout.txt",
    "code_path": "problem_iter5_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using proportional fit, favoring those where the item\n    fills a larger percentage of remaining capacity. Ensures robustness for invalid items.\n    \"\"\"\n    # Robustness check: If the item size is non-positive, it's considered invalid.\n    # No bin should be chosen for such an item, returning negative infinity.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize all priorities to negative infinity. This ensures that bins\n    # where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item.\n    # A bin can fit the item if its remaining capacity is greater than or equal to the item size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins where the item fits, assign a priority based on proportional utilization.\n    # This means item_size / bin_remaining_capacity. A higher ratio (closer to 1.0) indicates\n    # a 'snugger' proportional fit, aiming to maximize the relative fill of a bin.\n    # This directly implements the Best Fit strategy focusing on proportional utilization\n    # identified as highly effective. Division by zero is avoided because bins where item > 0\n    # and capacity is 0 will not be in the `can_fit_mask`.\n    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response3.txt_stdout.txt",
    "code_path": "problem_iter5_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive Best Fit (ABF) with remnant preference. Prioritizes perfect fits, then standard\n    best fit, while penalizing very small non-zero remnants to encourage more usable leftover space.\n    \"\"\"\n    if item <= 0:\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Core Best Fit: Prioritize bins by minimizing remaining space\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Adaptive Component: Penalize very small, non-zero remnants\n    # This constant (e.g., 5% of a typical bin capacity) needs tuning based on problem scale.\n    SMALL_REMNANT_THRESHOLD = 0.05 \n    # Penalty value to make small remnants less attractive than better fits.\n    PENALTY_VALUE = 0.1 \n\n    small_remnant_mask = (remaining_after_placement > 0) & \\\n                         (remaining_after_placement < SMALL_REMNANT_THRESHOLD) & \\\n                         fits_mask\n    priorities[small_remnant_mask] -= PENALTY_VALUE\n\n    # Absolute Highest Priority: Ensure perfect fits are always chosen first\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response4.txt_stdout.txt",
    "code_path": "problem_iter5_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using a Best Fit (BF) strategy, prioritizing bins that result in the smallest remaining capacity after placement.\n    Handles invalid items by assigning the lowest priority.\n    \"\"\"\n    # Initialize priority scores with negative infinity for bins where the item cannot fit\n    # or if the item itself is invalid.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: items must have a positive size to be packable.\n    # If not, all bins remain at the lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Create a mask for bins where the item *can* fit (remaining capacity >= item size).\n    fits_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the remaining capacity if the item were placed.\n    # A Best Fit strategy aims to minimize this remaining capacity (i.e., find the tightest fit).\n    # To assign higher priority to smaller remaining capacities, we take the negative of this value.\n    # Example: If remaining_capacity = 5, priority = -5. If remaining_capacity = 50, priority = -50.\n    # A value of -5 is higher (less negative) than -50, correctly prioritizing tighter fits.\n    potential_remainders = bins_remain_cap[fits_mask] - item\n    priorities[fits_mask] = -potential_remainders\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response5.txt_stdout.txt",
    "code_path": "problem_iter5_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Best-Fit with robust input handling and intuitive linear scoring,\n    prioritizing perfect fits to minimize wasted space.\n    \"\"\"\n    # Robustness check: Handle invalid item sizes (non-positive items).\n    # Such items cannot be packed, so all bins receive the lowest priority.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value. This ensures bins where the item\n    # cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the 'wasted space' (remaining capacity after placement)\n    # if the item were placed in each bin.\n    wasted_space = bins_remain_cap - item\n\n    # Create a mask to identify only those bins where the item can fit (wasted_space >= 0).\n    can_fit_mask = wasted_space >= 0\n\n    # For bins that can accommodate the item, assign a priority score.\n    # The Best-Fit principle aims to minimize 'wasted_space'.\n    # We use a linear transformation: 1.0 - wasted_space.\n    # This design ensures:\n    # - A perfect fit (wasted_space = 0) receives the highest score of 1.0.\n    # - As wasted_space increases, the priority linearly decreases from 1.0.\n    # This scaling provides an intuitive interpretation while maintaining Best-Fit's\n    # relative preference for tighter fits.\n    priorities[can_fit_mask] = 1.0 - wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response6.txt_stdout.txt",
    "code_path": "problem_iter5_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item using a robust Proportional Best Fit strategy.\n\n    Prioritizes bins by maximizing the proportion of their capacity filled by the item.\n    Handles invalid inputs (non-positive items) gracefully.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness (from priority_v0): non-positive items cannot be packed, assign lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit (similar to priority_v0 and implicitly in priority_v1's logic).\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply Proportional Best Fit strategy (refining a concept hinted in priority_v0's docstring):\n    # Prioritize bins that would be most \"filled up\" by the item relative to their current capacity.\n    # This promotes efficient use of space by maximizing `item / current_bin_capacity` for valid bins.\n    # Bins where the item fits will have `bins_remain_cap` >= `item` > 0, preventing division by zero.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response7.txt_stdout.txt",
    "code_path": "problem_iter5_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for each bin using a 'Normalized Best Fit' strategy.\n\n    Combines Best Fit with normalized scoring. Prioritizes perfect fits (1.0).\n    Non-perfect fits are scored by `1 - (remainder / BinCapacity)`, ensuring\n    smaller remainders yield higher, interpretable scores (0, 1.0). Robustly\n    handles non-positive items.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle non-positive items; they cannot be packed.\n    if item <= 0:\n        return priorities\n\n    # Calculate potential remaining capacity for all bins after placing the item.\n    potential_remainders = bins_remain_cap - item\n\n    # Mask for bins where the item actually fits (remainder >= 0).\n    fits_mask = (potential_remainders >= 0)\n\n    # Separate masks for perfect fits and non-perfect fits.\n    perfect_fit_mask = fits_mask & (potential_remainders == 0)\n    non_perfect_fits_mask = fits_mask & (potential_remainders > 0)\n\n    # Assign the highest priority (1.0) to perfect fits.\n    priorities[perfect_fit_mask] = 1.0\n\n    # For bins where the item fits but not perfectly, calculate a score\n    # based on the remaining capacity, normalized to be between 0 and 1.0.\n    if np.any(non_perfect_fits_mask):\n        # Assume a standard maximum bin capacity of 1.0 for normalization,\n        # common in normalized Bin Packing Problem setups.\n        # This allows the score to represent \"utilization\" within the bin.\n        normalization_factor = 1.0 \n\n        # Score is 1.0 minus the remainder, normalized by the bin's total capacity.\n        # Smaller remainders result in scores closer to 1.0.\n        priorities[non_perfect_fits_mask] = (\n            1.0 - (potential_remainders[non_perfect_fits_mask] / normalization_factor)\n        )\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response8.txt_stdout.txt",
    "code_path": "problem_iter5_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using a robust Best Fit (BF) strategy.\n\n    Selects bins that minimize wasted space after placement, assigning higher\n    scores to tighter fits. Handles invalid items and non-fitting bins robustly.\n    \"\"\"\n    # Initialize all priorities to negative infinity, assuming no fit by default.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: If the item size is non-positive, it cannot be packed.\n    # All bins will effectively have infinite negative priority for such an item.\n    if item <= 0:\n        return priorities\n\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # This also helps identify which bins can actually fit the item (positive or zero remainder).\n    potential_remainders = bins_remain_cap - item\n\n    # Create a boolean mask for bins where the item fits (remainder is non-negative).\n    fits_mask = potential_remainders >= 0\n\n    # For bins where the item fits, apply the Best Fit logic:\n    # Prioritize bins that result in the smallest remaining capacity after placement.\n    # By taking the negative of the potential_remainders, a smaller positive remainder\n    # (e.g., 5) results in a higher (less negative) priority score (-5) compared to\n    # a larger remainder (e.g., 20) which results in a lower (more negative) score (-20).\n    priorities[fits_mask] = -potential_remainders[fits_mask]\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response9.txt_stdout.txt",
    "code_path": "problem_iter5_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority for adding an item to each bin using a Proportional Best Fit strategy.\n\n    Maximizes the item's proportion of a bin's remaining capacity, prioritizing bins where the item\n    fits most 'tightly' relative to the bin's current size. Includes robust input handling.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Incorporate robustness: non-positive items cannot be packed, assign lowest priority.\n    # This element is directly adopted from the 'priority_v0' heuristic for safety.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit. This clear masking approach is similar to 'priority_v0'.\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply a \"Proportional Best Fit\" strategy, which the analysis indicated as highly effective\n    # (similar to \"Heuristic 1st\"). This aims to maximize the ratio of the item's size to the\n    # bin's remaining capacity, leading to efficient space utilization.\n    # bins_remain_cap[valid_bins_mask] will always be > 0 because item > 0 and fits.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]