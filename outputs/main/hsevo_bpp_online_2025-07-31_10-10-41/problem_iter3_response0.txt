```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for each bin using a Best Fit strategy based on the
    proportion of available bin space consumed by the item.

    This heuristic prioritizes bins where the item consumes a larger fraction
    of the bin's remaining capacity. This is a direct measure of "tightness of fit"
    expressed proportionally, aligning with the principles of simplicity, directness,
    and interpretability. A perfect fit will yield a score of 1.0.

    Args:
        item: Size of item to be added to the bin. Must be non-negative.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score for each bin.
        Bins where the item does not fit are assigned the lowest possible priority (-np.inf).
    """
    # Initialize priority scores to negative infinity.
    # This ensures that bins where the item cannot fit are never chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # A mask for bins where the item can physically fit (remaining capacity is greater than or equal to item size).
    # We also ensure bins_remain_cap is positive to avoid division by zero.
    # Note: If item is 0, it fits into any bin with >0 capacity and yields a ratio of 0.
    # If a bin has 0 remaining capacity, it's not a valid fit for any item > 0.
    # If item is 0 and bin_remain_cap is 0, it's technically a "fit", but 0/0 is undefined.
    # The `bins_remain_cap > 0` condition handles this gracefully.
    can_fit_mask = (bins_remain_cap >= item) & (bins_remain_cap > 0)

    # Calculate the priority score for valid bins.
    # The score is the ratio of the item's size to the bin's remaining capacity.
    # A higher ratio (closer to 1.0) indicates a better, tighter fit, as the item
    # fills a larger proportion of the available space.
    # Example:
    #   item = 5
    #   Bin A (cap=10): score = 5/10 = 0.5
    #   Bin B (cap=6):  score = 5/6  = 0.833...
    #   Bin C (cap=5):  score = 5/5  = 1.0 (perfect fit)
    # This prioritizes Bin C > Bin B > Bin A, which is consistent with Best Fit.
    priorities[can_fit_mask] = item / bins_remain_cap[can_fit_mask]

    return priorities
```
