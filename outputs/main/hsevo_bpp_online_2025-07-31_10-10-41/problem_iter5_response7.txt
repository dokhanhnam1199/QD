```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for each bin using a 'Normalized Best Fit' strategy.

    Combines Best Fit with normalized scoring. Prioritizes perfect fits (1.0).
    Non-perfect fits are scored by `1 - (remainder / BinCapacity)`, ensuring
    smaller remainders yield higher, interpretable scores (0, 1.0). Robustly
    handles non-positive items.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Handle non-positive items; they cannot be packed.
    if item <= 0:
        return priorities

    # Calculate potential remaining capacity for all bins after placing the item.
    potential_remainders = bins_remain_cap - item

    # Mask for bins where the item actually fits (remainder >= 0).
    fits_mask = (potential_remainders >= 0)

    # Separate masks for perfect fits and non-perfect fits.
    perfect_fit_mask = fits_mask & (potential_remainders == 0)
    non_perfect_fits_mask = fits_mask & (potential_remainders > 0)

    # Assign the highest priority (1.0) to perfect fits.
    priorities[perfect_fit_mask] = 1.0

    # For bins where the item fits but not perfectly, calculate a score
    # based on the remaining capacity, normalized to be between 0 and 1.0.
    if np.any(non_perfect_fits_mask):
        # Assume a standard maximum bin capacity of 1.0 for normalization,
        # common in normalized Bin Packing Problem setups.
        # This allows the score to represent "utilization" within the bin.
        normalization_factor = 1.0 

        # Score is 1.0 minus the remainder, normalized by the bin's total capacity.
        # Smaller remainders result in scores closer to 1.0.
        priorities[non_perfect_fits_mask] = (
            1.0 - (potential_remainders[non_perfect_fits_mask] / normalization_factor)
        )

    return priorities
```
