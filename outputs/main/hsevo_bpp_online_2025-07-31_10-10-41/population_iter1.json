[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit (BF) strategy.\n\n    Bins where the item fits perfectly get the highest priority. Among bins where the item fits,\n    those leaving less remaining capacity are preferred. Bins where the item does not fit\n    are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores\n    # We use -np.inf for bins where the item cannot fit, ensuring they are never chosen.\n    # For bins where it fits, we prioritize by minimizing the remaining space.\n    # A smaller remaining_after_placement value means a better fit (closer to zero).\n    # To maximize this as a priority score, we take the negative of remaining_after_placement.\n    # So, a perfect fit (remaining_after_placement = 0) gets a priority of 0,\n    # a near-perfect fit (e.g., remaining_after_placement = 0.1) gets -0.1,\n    # and a loose fit (e.g., remaining_after_placement = 10) gets -10.\n    # The higher the value (closer to 0 for negatives, or 0 itself), the better.\n    priorities = -remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item does not fit\n    # (i.e., remaining_after_placement is negative)\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Einstein, I propose a \"Principle of Minimal Cosmic Expansion.\"\n    Just as the universe expands, so too do our demands on resources. In the realm\n    of bin packing, we must strive to minimize the \"expansion\" of our bin count.\n    This implies a strategy of densification: to fill existing space as efficiently\n    as possible before creating new space (new bins).\n\n    Therefore, the optimal heuristic is to prioritize placing an item into a bin\n    such that the *remaining void* within that bin is minimized. This \"Best Fit\"\n    approach leaves the least amount of fragmented space, making it harder for\n    future items to fit poorly and necessitating fewer new bins.\n\n    A higher priority score indicates a greater preference for the bin.\n    \"\"\"\n    # Initialize all scores to a very low value. Bins that cannot fit the item\n    # must have an effectively infinite disincentive.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit.\n    # This prevents considering bins that are too small.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can accommodate the item, calculate their \"fit tightness\".\n    # The 'item - bins_remain_cap' term serves as an inverse measure of remaining void.\n    # - If item = bins_remain_cap (perfect fit), the score is 0.0 (highest possible for a fit).\n    # - If item is much smaller than bins_remain_cap, the score will be a larger negative value.\n    # Maximizing this value corresponds to minimizing the remaining capacity after placement.\n    scores[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Isaac Newton, I view the Universe, and indeed problems such as Bin Packing,\n    as systems that strive towards an optimal state of arrangement and efficiency.\n    My heuristic for prioritizing bins is inspired by the principle of 'Best Fit',\n    which in my physical understanding, aligns with minimizing potential energy\n    or waste within a system.\n\n    Imagine each bin as a potential well, and the item as a body seeking to fall\n    into the shallowest suitable well. The most 'attractive' bin is not merely\n    one that can contain the item, but one that snugly contains it, leaving the\n    least 'void' or 'unused potential'. This tight packing minimizes the\n    'gravitational pull' for future items to gravitate towards newly opened bins,\n    thus conserving the total number of containers required.\n\n    The priority for a suitable bin is calculated as the negative of the\n    remaining capacity after the item is placed. This converts the pursuit of\n    the *minimum* wasted space into a *maximization* problem, where the bin with\n    the highest priority (i.e., the least negative remaining space) is chosen.\n    Bins that are too small to accommodate the item are given an infinitely\n    low priority, rendering them impenetrable barriers.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities for all bins. Bins that cannot fit the item\n    # are assigned a negative infinity priority, making them effectively\n    # impossible choices, akin to insurmountable obstacles.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can physically fit.\n    # These are the 'accessible' regions in our potential landscape.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual capacity' or 'potential void' that would remain\n    # in each fitting bin after the item is placed. Our aim is to minimize this value.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To convert the goal of 'minimizing residual capacity' into a 'maximization\n    # of priority', we take the negative of the residual capacity.\n    # A smaller positive residual capacity results in a priority score closer to zero\n    # (i.e., less negative), thus becoming a higher priority choice.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function embodies the principle of \"optimal packing\" by favoring bins\n    that, after accommodating the incoming item, will be left with the smallest\n    possible remaining capacity. Think of it as striving for atomic stability:\n    we seek to minimize the \"energy\" (wasted space) within each bin.\n\n    Bins that cannot accommodate the item are effectively 'forbidden' as they\n    would lead to an unstable configuration (overflow) and are assigned the\n    lowest possible priority, akin to highly unstable radioactive isotopes.\n    Among the bins where the item fits, the higher priority is given to the one\n    that achieves the tightest fit, thus optimizing the bin's fill level and\n    conserving overall space, much like a dense, well-organized crystalline structure.\n\n    Args:\n        item: Size of item to be added to the bin. This is the 'particle' we wish to place.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         These are our 'containers'.\n\n    Return:\n        Array of the same size as bins_remain_cap, where each value is the\n        priority score for placing the item into the corresponding bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining space in each bin if the 'item' were placed.\n    # This is our 'post-reaction' state, revealing the 'residual energy'.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (-infinity).\n    # This ensures that bins where the item cannot fit are never chosen.\n    # It represents an impossible or highly undesirable 'reaction path'.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item *can* actually fit.\n    # These are the 'viable reaction vessels'.\n    fitting_bins_mask = potential_remaining_space >= 0\n\n    # For the bins where the item fits, we want to assign a higher priority\n    # to those that result in the smallest positive remaining space.\n    # A smaller 'potential_remaining_space' means a 'tighter' fit.\n    # To achieve this with a maximum priority score, we take the negative\n    # of the potential remaining space. This way, a smaller positive value\n    # (e.g., 0.1 remaining) yields a larger (less negative) priority (-0.1)\n    # compared to a larger positive value (e.g., 0.5 remaining) yielding (-0.5).\n    # This pushes the system towards the most 'stable' and 'packed' configuration.\n    priorities[fitting_bins_mask] = -potential_remaining_space[fitting_bins_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Nikola Tesla's principle of 'Electromagnetic Optimization':\n    In the realm of energy and efficiency, one must strive for the most\n    harmonious coupling between source and receiver. This heuristic embodies\n    that quest, seeking the container where the incoming 'energy packet' (item)\n    will complete the 'circuit' most precisely, leaving the barest minimum of\n    residual 'potential' (space). We prioritize the bins that achieve the\n    'snuggest' fit, minimizing inefficiency and accelerating the full utilization\n    of each vessel. A perfect fit is given the highest possible consideration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin. Bins that cannot\n        accommodate the item receive a score of 0, effectively removing them\n        from contention unless no suitable bin exists (in which case a new\n        bin would typically be opened by the higher-level logic).\n    \"\"\"\n    # Initialize all bin priorities to 0.0. Bins that cannot fit will retain this score.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the remaining capacity in each bin if the item were placed.\n    # A smaller 'remaining_space' after placement indicates a 'snugger' fit.\n    remaining_space = bins_remain_cap - item\n\n    # Identify which bins can actually accommodate the item.\n    # This ensures we only consider valid placements.\n    can_fit_mask = remaining_space >= 0\n\n    # For bins that can fit, we assign a priority.\n    # The Best Fit heuristic seeks to minimize 'remaining_space'.\n    # To convert this into a 'highest priority wins' score, we use the negative\n    # of the remaining_space.\n    # - A perfect fit (remaining_space = 0) gets a priority of 0.\n    # - A snug fit (small positive remaining_space) gets a small negative priority\n    #   (e.g., -0.1 for remaining_space of 0.1).\n    # - A loose fit (large positive remaining_space) gets a large negative priority\n    #   (e.g., -0.5 for remaining_space of 0.5).\n    # This ensures that smaller positive `remaining_space` values yield priorities\n    # that are numerically larger (closer to zero).\n    priorities[can_fit_mask] = -remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic.\n\n    As Galileo, I believe in discerning the most orderly and efficient\n    arrangements within creation. In the grand cosmos of capacities,\n    we must place this new 'celestial body' (item) into the 'orb' (bin)\n    that accommodates it with the least superfluous void. This approach,\n    akin to fitting a planet into its most harmonious orbit, ensures that\n    we leave the larger, more capacious bins for truly vast entities yet\n    to emerge, or that we fill our current vessels with maximum precision.\n\n    The priority for each bin is determined by the negative of the space\n    that would remain if the item were placed within it. Thus, a smaller\n    remaining void (a tighter, more 'best' fit) yields a higher (less negative)\n    priority score. Bins that cannot possibly contain the item are deemed\n    unsuitable and receive the lowest possible priority, indicating they are\n    not viable candidates in this celestial arrangement.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    if bins_remain_cap.size == 0:\n        return np.array([], dtype=float)\n\n    # Initialize priorities to a profoundly low value for all bins.\n    # This reflects their initial state of unsuitability or disfavor.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins are truly capacious enough to contain this item.\n    # These are the bins that can potentially offer a 'fit'.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For those bins deemed capable, calculate the remaining capacity after\n    # the item is placed. This 'remaining_space' is what we seek to minimize\n    # in the spirit of a 'Best Fit'.\n    remaining_space = bins_remain_cap[can_fit_mask] - item\n    \n    # Assign the priority: the negative of the remaining space.\n    # A smaller remaining space (closer to zero) results in a larger\n    # (less negative, thus higher) priority, guiding us to the optimal snug fit.\n    priorities[can_fit_mask] = -remaining_space\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    Inspired by the gravitational mechanics of black holes, this heuristic\n    prioritizes bins that allow the item to achieve maximum density,\n    leaving the smallest possible 'void' (remaining capacity).\n\n    The gravitational pull towards a bin intensifies dramatically as the\n    remaining capacity approaches zero, indicating a near-perfect 'collapse'\n    of the item into the available space, much like matter nearing an event horizon.\n    Bins that cannot accommodate the item are treated as impenetrable event horizons,\n    receiving zero priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # A small constant, akin to a quantum fluctuation, to prevent infinite\n    # priority for a perfectly zero remaining space, while still giving it\n    # an overwhelmingly high score.\n    epsilon = 1e-9\n\n    # Calculate the hypothetical remaining capacity after the item is placed.\n    # This represents the 'void' left in the bin.\n    remaining_after_fit = bins_remain_cap - item\n\n    # Initialize priorities. Bins incapable of holding the item start with zero priority,\n    # signifying an insurmountable event horizon.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item can actually fit.\n    # These are the regions of spacetime where the item's 'mass' can reside.\n    can_fit_mask = remaining_after_fit >= 0\n\n    # For bins where the item fits, the priority is inversely proportional to the\n    # 'void' left. The smaller the void, the stronger the 'gravitational pull'.\n    # A perfect fit (void=0) results in an extremely high priority, simulating\n    # the immense gravitational force at the brink of a singularity.\n    priorities[can_fit_mask] = 1.0 / (remaining_after_fit[can_fit_mask] + epsilon)\n    \n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    inspired by a quantum-mechanical principle of seeking the 'lowest energy state'.\n\n    Just as a quantum system tends towards a state of minimum energy,\n    our item will seek a bin configuration that minimizes the 'energy'\n    of wasted space. This heuristic, akin to a 'Best Fit' strategy,\n    prioritizes bins that, upon receiving the item, will have the least\n    remaining capacity. A perfect fit is the absolute ground state,\n    yielding zero potential energy. Bins incapable of holding the item\n    represent impenetrable potential barriers \u2013 an infinitely high energy state.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable (lower 'energy') bin.\n    \"\"\"\n    # Calculate the 'potential energy' of the remaining empty space in each bin\n    # if the item were to be placed there.\n    potential_wasted_space = bins_remain_cap - item\n\n    # Initialize priorities for all bins to an extremely low value.\n    # This represents an 'infinite energy' state for bins that cannot fit the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify which bins can actually accommodate the item. These are our\n    # 'accessible energy levels'.\n    can_fit_mask = potential_wasted_space >= 0\n\n    # For bins where the item can fit:\n    # The 'energy' (wasted space) should be minimized. To turn this into a priority\n    # (where higher is better), we take the negative of the wasted space.\n    # A smaller `potential_wasted_space` (e.g., 0 for a perfect fit, or a small positive number)\n    # will result in a larger (less negative, closer to zero) priority score.\n    # A perfect fit (wasted_space = 0) gets the highest priority of 0.\n    priorities[can_fit_mask] = -potential_wasted_space[can_fit_mask]\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic, aiming for maximum packing efficiency.\n    Inspired by the meticulous work on DNA structure, this function prioritizes\n    bins where the item fits most tightly, leaving the smallest remaining capacity.\n\n    A higher priority score is given to a bin that, if the item were placed in it,\n    would result in the least amount of wasted space (i.e., the smallest\n    remaining capacity after accommodating the item). Bins that cannot fit\n    the item are given the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        The bin that yields the highest (least negative) priority score is\n        the one that offers the 'best fit'.\n    \"\"\"\n    # Initialize all priorities to a very low value (effectively negative infinity)\n    # This ensures that bins where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the remaining capacity after placement.\n    # We want to minimize this remaining capacity (bins_remain_cap - item).\n    # To convert this minimization problem into a maximization of priority,\n    # we take the negative of the remaining capacity.\n    # A smaller positive remaining capacity results in a larger (less negative) priority.\n    # A perfect fit (0 remaining capacity) will yield the highest priority of 0.\n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation employs a 'Best-Fit' heuristic, prioritizing bins that,\n    after accommodating the item, will have the least remaining capacity (i.e., the\n    tightest fit). Bins where the item cannot fit are assigned a significantly\n    lower priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priorities with a very low value (negative infinity).\n    # This ensures that bins incapable of holding the item are never chosen\n    # when the selection mechanism picks the bin with the maximum priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the item.\n    can_fit_mask = remaining_after_placement >= 0\n\n    # For bins where the item fits, assign a priority based on the Best-Fit strategy.\n    # The Best-Fit strategy aims to minimize the remaining capacity after placement.\n    # To translate this into a \"maximize priority\" system, we use the negative of\n    # the remaining capacity. A smaller positive remaining capacity (tighter fit)\n    # results in a larger (closer to zero, less negative) priority score.\n    # Example: If remaining_after_placement is 0.1, priority is -0.1.\n    # If remaining_after_placement is 0.5, priority is -0.5.\n    # -0.1 is greater than -0.5, correctly favoring the tighter fit.\n    priorities[can_fit_mask] = -remaining_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a Best Fit-like strategy. It aims to place\n    the item in a bin such that the remaining capacity of that bin is minimized\n    after the item is placed (i.e., making the bin as 'full' as possible).\n\n    Bins that cannot accommodate the item are given a very low priority\n    (negative infinity). Among valid bins, the priority is set to the negative\n    of the space that would be left in the bin after placing the item. This way,\n    a smaller leftover space results in a higher (less negative) priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n\n    # For valid bins, calculate the remaining space if the item were placed.\n    # We want to minimize this remaining space, which means maximizing its negative value.\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n    \n    # Assign the negative of the leftover space as the priority.\n    # Example: If leftover is 0.1, priority is -0.1. If leftover is 0.5, priority is -0.5.\n    # -0.1 is greater than -0.5, so the bin with less leftover space gets higher priority.\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    return priorities",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    guided by the principle of Best Fit.\n\n    Inspired by the universe's tendency to find the most efficient\n    configuration, this heuristic prioritizes bins that offer the\n    tightest fit for the incoming item. By minimizing the leftover space\n    within a chosen bin, we aim to conserve capacity in other bins\n    for potentially larger future items, thus optimizing the overall\n    packing density. A smaller remaining gap signifies a \"better\" fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # This also helps identify bins where the item does not fit (resulting in negative values).\n    potential_new_remaining_capacities = bins_remain_cap - item\n\n    # Initialize priorities. Bins where the item does not fit should have\n    # a very low priority (effectively, they are not options).\n    # We use -np.inf to ensure they are never chosen unless no other option exists.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify valid bins where the item actually fits.\n    # These are bins where the potential new remaining capacity is non-negative.\n    valid_bins_mask = potential_new_remaining_capacities >= 0\n\n    # For valid bins, the priority is the negative of the remaining capacity.\n    # This way, the smallest positive remaining capacity (tightest fit)\n    # yields the highest (least negative) priority score.\n    priority_scores[valid_bins_mask] = -potential_new_remaining_capacities[valid_bins_mask]\n\n    return priority_scores",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, guided by the principle of Best Fit.\n\n    Verily, just as objects in motion seek the lowest potential energy, so too shall an item of\n    given magnitude seek the receptacle that can most perfectly contain it, leaving but a\n    negligible void. This 'Best Fit' strategy, inspired by the desire for maximal efficiency\n    and minimal wasted space, ensures we compact our goods with a precision worthy of the\n    celestial mechanics.\n\n    The priority for each bin is determined as follows:\n    1. For bins where the item does not fit, the priority is set to a value so infinitesimally\n       small that these bins are rendered unsuitable.\n    2. For bins where the item fits, the priority is calculated such that a tighter fit\n       (i.e., less remaining capacity after the item is placed) yields a higher score.\n       Specifically, it is the negative of the potential leftover capacity, transforming\n       the minimization of waste into a maximization problem for the selection mechanism.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    # A positive value indicates the item fits, a negative value indicates it does not.\n    potential_leftover = bins_remain_cap - item\n\n    # Identify which bins can actually accommodate the item.\n    fits_mask = potential_leftover >= 0\n\n    # Initialize all priority scores to a very low value (negative infinity).\n    # This ensures that bins where the item does not fit are never chosen\n    # unless there are absolutely no fitting bins.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For those bins where the item fits, assign a priority based on the Best Fit principle.\n    # We want to minimize the 'potential_leftover' (i.e., the wasted space).\n    # To achieve this with a maximization-based selection (highest priority wins),\n    # we take the negative of the 'potential_leftover'. Thus, a smaller positive\n    # 'potential_leftover' (closer to zero) results in a larger (less negative) priority score.\n    priority_scores[fits_mask] = -potential_leftover[fits_mask]\n\n    return priority_scores",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    inspired by a Best-Fit decreasing-gap strategy for optimal packing.\n\n    As a scientist, I sought to organize and utilize every resource with utmost efficiency.\n    This heuristic embodies that principle by prioritizing the bins that, after accommodating\n    the current item, will have the least remaining \"empty\" space. This minimizes the\n    \"radioactive waste\" of unused capacity in bins, leading to a tighter overall packing\n    and fewer bins utilized, much like carefully isolating a new element into the smallest\n    effective container. Bins unable to contain the item are, of course, discarded from\n    consideration.\n\n    Args:\n        item: Size of item to be added to the bin. This is the \"activity\" of our element.\n        bins_remain_cap: Array of capacities for each bin. These are our \"containers\".\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low value (effectively ruling out non-viable bins).\n    # Just as an empty flask cannot contain a sample.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a mask for bins that can physically accommodate the item.\n    # We must only consider containers that are large enough.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate their score.\n    # The goal is to minimize the remaining capacity (bins_remain_cap - item) after placement.\n    # To achieve this with a \"highest score wins\" selection, we maximize the negative of\n    # the remaining capacity: -(bins_remain_cap - item), which simplifies to (item - bins_remain_cap).\n    # A perfect fit (bins_remain_cap == item) results in a score of 0.0, which is the highest\n    # possible score, signifying the most efficient use of space. All other valid fits\n    # will result in negative scores, with smaller absolute values indicating tighter fits.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Nikola Tesla's ingenious design for efficient resource allocation!\n    This heuristic embodies the principle of 'Best Fit' (BF), striving for\n    the most precise and snug placement of items within our electrical\n    storage units (bins). By minimizing the remaining free capacity in a\n    chosen bin, we ensure optimal utilization, akin to minimizing energy\n    loss and maximizing power density.\n\n    The priority is determined by the 'tightness' of the fit: a smaller\n    residual space after accommodating the item indicates a higher\n    priority, favoring a 'perfect' fit, where the item precisely\n    occupies the remaining capacity. Bins where the item does not fit\n    receive the lowest possible priority, ensuring they are never chosen.\n    This precise calculation prevents wasted 'energy' (space) and ensures\n    our packing efficiency approaches the theoretical limits!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # A smaller positive remainder signifies a 'best fit'.\n    potential_remainders = bins_remain_cap - item\n\n    # Initialize priorities. Bins where the item cannot physically fit will be given\n    # an infinitely low priority, rendering them ineligible. Tesla tolerates no\n    # impossibility in his designs!\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item.\n    # These are the only bins worthy of consideration.\n    can_fit_mask = potential_remainders >= 0\n\n    # For those bins where the item fits, assign a priority.\n    # The priority is derived from the negative of the remaining space.\n    # This means a remainder of 0 (a perfect fit) yields a priority of 0,\n    # a remainder of 0.1 yields -0.1, and so on. When selecting the maximum\n    # priority, this naturally selects the smallest non-negative remainder.\n    # This is the essence of 'Best Fit' \u2013 maximizing snugness!\n    priorities[can_fit_mask] = -potential_remainders[can_fit_mask]\n\n    return priorities",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the pursuit of the most harmonious fit, seeking to leave\n    the least void within a celestial sphere, I decree that the optimal\n    placement is that which most snugly embraces the item, thus minimizing\n    the remaining, unproductive space. A perfect fit earns the highest acclaim.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize priorities to zero. Bins where the item does not fit will inherently\n    # retain this zero priority.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Define a small epsilon to prevent division by zero and to differentiate\n    # between varying small positive remaining spaces. This acts as a 'fineness' of measurement.\n    epsilon = 1e-9 \n\n    # Identify the bins where the item can physically fit (remaining space is non-negative).\n    can_fit_mask = potential_remaining_space >= 0\n\n    # Apply the priority logic only to bins where the item can fit.\n    \n    # Case 1: The item fits perfectly (remaining space is exactly zero).\n    # This is the most desired outcome, akin to a perfectly elliptical orbit.\n    # Assign a distinctly very high priority to ensure it is always chosen over a non-perfect fit.\n    perfect_fit_mask = (potential_remaining_space == 0) & can_fit_mask\n    if np.any(perfect_fit_mask):\n        priorities[perfect_fit_mask] = 1.0 / epsilon # A very large number\n\n    # Case 2: The item fits, but some space remains (remaining space is positive).\n    # Following the principle of 'Best Fit', we aim to minimize this leftover void.\n    # A smaller positive remaining space signifies a better, more harmonious fit,\n    # and thus should receive a higher priority. We achieve this with an inverse relationship.\n    non_perfect_fit_mask = (potential_remaining_space > 0) & can_fit_mask\n    if np.any(non_perfect_fit_mask):\n        priorities[non_perfect_fit_mask] = 1.0 / (potential_remaining_space[non_perfect_fit_mask] + epsilon)\n\n    return priorities",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    Drawing inspiration from the relentless pull of gravity towards a singularity,\n    this heuristic, which I shall call the 'Event Horizon Collapse Prioritization',\n    guides the incoming item towards a bin that, upon its absorption, approaches\n    a state of maximal density \u2013 that is, a bin that becomes as full as possible,\n    leaving minimal 'event horizon' (remaining space). A perfect fit, like\n    a complete gravitational collapse, is highly favored. Bins that cannot\n    accommodate the item are given a virtually infinite negative priority,\n    as they are beyond the event horizon for this item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a stronger 'gravitational pull' for the item.\n    \"\"\"\n    # Initialize all scores to an abyssal low, effectively ruling out\n    # bins that cannot even contain the item. This is our 'negative infinity'\n    # for impossible fits.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'habitable' bins \u2013 those where the item can physically fit.\n    can_fit = bins_remain_cap >= item\n\n    if np.any(can_fit):\n        # For the habitable bins, calculate the 'residual energy' \u2013\n        # the amount of space remaining after the item is placed.\n        residual_energy = bins_remain_cap[can_fit] - item\n\n        # To prevent division by zero in the case of a perfect fit\n        # (where residual_energy is exactly 0), we add a minuscule\n        # 'quantum perturbation' (epsilon). This ensures that a perfect\n        # fit yields the highest possible finite score.\n        epsilon = 1e-9\n\n        # The 'Event Horizon Collapse Prioritization' assigns a score\n        # inversely proportional to the residual energy. A smaller\n        # residual energy (i.e., a tighter fit) results in a much higher score,\n        # encouraging the 'collapse' of the bin towards a fully packed state.\n        valid_scores = 1.0 / (residual_energy + epsilon)\n\n        # Apply these calculated potentials to the relevant bins.\n        scores[can_fit] = valid_scores\n    # If no bins can accommodate the item, all scores remain -np.inf,\n    # signaling a crisis where new space (a new bin) is required.\n\n    return scores",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Feynman's Quantum Bin Packing Principle:\n    # An item, like a quantum particle, seeks the \"lowest energy state\" in a bin,\n    # minimizing the \"residual vacuum\" after its placement.\n\n    # Calculate the 'potential energy' or 'gap' that would be left in each bin after placement.\n    # This 'gap' is the 'excitation energy' we want to minimize.\n    # A negative gap means the bin cannot accommodate the item; it's an 'infinite potential wall'.\n    delta = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item get zero priority.\n    # This ensures they are not chosen.\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify valid bins (where the item can actually fit, i.e., delta >= 0).\n    can_fit_mask = (delta >= 0)\n\n    # For these valid bins, calculate the score.\n    # The 'attraction' or 'priority' to a bin is inversely proportional to the 'gap' left.\n    # A smaller gap means a higher priority, as it leads to a more 'compact' or 'filled' bin state.\n    # We add a tiny epsilon (1e-9) to the denominator. This serves a dual purpose:\n    # 1. Prevents division by zero if delta is exactly 0 (a perfect fit).\n    # 2. Gives perfect fits an extremely high, finite score (1 / 1e-9 = 1 Billion).\n    # This naturally makes perfect fits the highest priority, then near-perfect, and so on,\n    # embodying the principle of minimizing 'wasted' space.\n    scores[can_fit_mask] = 1.0 / (delta[can_fit_mask] + 1e-9)\n\n    # Bins where `delta < 0` (cannot fit) retain their `0.0` score from initialization,\n    # ensuring they are implicitly deprioritized.\n\n    return scores",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This priority function implements a \"Best Fit\" strategy, aiming to place the\n    item into the bin that minimizes the remaining empty space. It rewards\n    perfect fits most highly, and penalizes bins where the item does not fit.\n\n    Rosalind Franklin's work emphasized precise and efficient structural arrangement.\n    In bin packing, this translates to maximizing the utilization of each container,\n    leaving as little wasted space as possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        - Higher score indicates higher priority.\n        - Bins where the item does not fit will have a score of -np.inf.\n        - Bins where the item fits perfectly will have the highest score (0).\n        - Other fitting bins will have negative scores, where a score closer\n          to zero indicates a \"tighter\" fit (less remaining space).\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating \"cannot fit\" or \"least desirable\".\n    # Using -np.inf ensures these bins will not be chosen unless no other option exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the space that would remain if the item were placed in each bin.\n    # This value will be positive if the item fits, zero for a perfect fit, and negative if it doesn't fit.\n    remaining_space_after_placement = bins_remain_cap - item\n\n    # Create a boolean mask to identify bins where the item can actually fit (remaining_space >= 0).\n    can_fit_mask = remaining_space_after_placement >= 0\n\n    # For bins where the item fits, assign a priority score.\n    # The Best Fit heuristic aims to *minimize* the remaining space.\n    # To convert this minimization problem into a maximization problem (for priority),\n    # we negate the remaining space.\n    #   - If remaining_space is 0 (perfect fit), priority is 0 (highest possible).\n    #   - If remaining_space is small positive (e.g., 0.1), priority is -0.1.\n    #   - If remaining_space is large positive (e.g., 0.5), priority is -0.5.\n    # This naturally prioritizes smaller remaining space over larger remaining space.\n    priorities[can_fit_mask] = -remaining_space_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a Best Fit heuristic.\n\n    This heuristic prioritizes placing the item into the bin that will leave the smallest\n    amount of remaining space after the item is placed, effectively attempting to \"fill\"\n    bins as much as possible. Bins that cannot accommodate the item are given the lowest\n    possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space remaining in each bin *after* placing the item.\n    # A smaller positive value indicates a \"tighter\" fit, which is preferred by Best Fit.\n    space_after_placement = bins_remain_cap - item\n\n    # Initialize a priority array. By default, set priorities to negative infinity.\n    # This ensures that bins that cannot fit the item (or are implicitly not good choices)\n    # will have a very low score and will not be selected unless no other option exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can actually fit the item (i.e., space_after_placement is non-negative).\n    can_fit_mask = space_after_placement >= 0\n\n    # For the bins where the item can fit, calculate their priority.\n    # To implement Best Fit (where we want to minimize 'space_after_placement'),\n    # we take the negative of 'space_after_placement'.\n    # This way, a smaller positive 'space_after_placement' (e.g., 0 for a perfect fit)\n    # will result in a larger (less negative, or zero) priority score.\n    # Example:\n    # - If 'space_after_placement' is 0, priority is 0 (highest possible for a fit).\n    # - If 'space_after_placement' is 2, priority is -2.\n    # - If 'space_after_placement' is 10, priority is -10.\n    # The bin with the largest priority score will be the one that offers the \"best fit\".\n    priorities[can_fit_mask] = -space_after_placement[can_fit_mask]\n\n    return priorities",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n    This version implements a 'Best Fit' heuristic with a slight modification\n    to handle perfect fits robustly. It prioritizes bins that will have the\n    smallest remaining capacity after the item is placed, thus aiming to\n    leave as little 'waste' as possible in the selected bin. Perfect fits\n    (where item exactly fills the bin) receive the highest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher score indicates higher priority for selecting the bin.\n    \"\"\"\n    # Calculate the remaining capacity of each bin if the current item were placed into it.\n    post_placement_remain_cap = bins_remain_cap - item\n\n    # Initialize priorities for all bins.\n    # Bins where the item does not fit must have a very low priority (e.g., -infinity)\n    # so they are never chosen if any valid bin exists.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # A small positive constant (epsilon) is added to the denominator to:\n    # 1. Prevent division by zero if an item perfectly fills a bin (post_placement_remain_cap is 0).\n    # 2. Ensure that perfect fits result in the highest possible finite priority score,\n    #    as 1/epsilon will be a very large number.\n    epsilon = 1e-9 \n\n    # Identify which bins can accommodate the current item.\n    # These are bins where the remaining capacity after placing the item is non-negative.\n    fit_mask = post_placement_remain_cap >= 0\n\n    # For the bins where the item fits, calculate their priority.\n    # The 'Best Fit' strategy seeks to minimize the remaining capacity after placement.\n    # Therefore, the priority is inversely proportional to this remaining capacity.\n    # A smaller remaining capacity (closer to a perfect fit) leads to a higher priority score.\n    priorities[fit_mask] = 1.0 / (post_placement_remain_cap[fit_mask] + epsilon)\n\n    return priorities",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Albert Einstein, I propose a heuristic based on the principle of\n    \"Least Resistance\" or \"Maximal Local Utilization\". Just as matter warps\n    spacetime, we want the item to \"warp\" the bin's remaining capacity\n    as completely as possible. This means fitting the item into a bin\n    such that the *remaining void* is minimized.\n\n    This strategy aligns with the 'Best Fit' heuristic in bin packing,\n    which aims to leave the smallest possible capacity after the item is\n    placed. This effectively makes the most efficient use of the current bin,\n    leaving larger capacities in other bins for potentially larger future items,\n    thus minimizing the total number of bins required over time.\n\n    A higher priority score indicates a more desirable bin.\n    - If an item fits, the score is based on `item - bin_remaining_capacity`.\n      A perfect fit (item == bin_remaining_capacity) yields a score of 0.\n      A looser fit (item << bin_remaining_capacity) yields a more negative score.\n      The goal is to maximize this value (make it closest to 0 or least negative).\n    - If an item does not fit, the priority is set to a very low (negative infinity) value.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating an undesirable bin.\n    # This handles cases where an item does not fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item can actually fit.\n    # This corresponds to \"valid space-time coordinates\" where the item can exist.\n    can_fit = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the priority score.\n    # We want to maximize `item - bins_remain_cap`, which means minimizing\n    # `bins_remain_cap - item` (the remaining void) for positive remaining capacities.\n    # A perfect fit (bins_remain_cap[i] == item) results in a score of 0, which is\n    # the maximum possible non-negative score, hence highest priority for valid fits.\n    # If bins_remain_cap[i] > item, the score will be negative, and the closer\n    # bins_remain_cap[i] is to item, the closer to 0 (and thus higher) the score will be.\n    priorities[can_fit] = item - bins_remain_cap[can_fit]\n\n    return priorities",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This heuristic is inspired by the principle of efficient packing and\n    minimizing waste, akin to how physical systems seek the most stable and\n    compact arrangements. It prioritizes bins that will result in the least\n    remaining capacity after accommodating the item, thus yielding the \"tightest\" fit.\n    This method aims to consolidate items effectively, much like how celestial bodies\n    draw together to form dense structures, thereby minimizing the total space required.\n    Bins that cannot fit the item are, naturally, given a vanishingly low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # This quantity is akin to the 'potential energy' of a bin after receiving the item;\n    # we seek to minimize this potential for wasted space, leading to a more stable configuration.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priorities. Bins that cannot accommodate the item must be excluded\n    # from consideration, as they violate the fundamental laws of fit.\n    # Assigning them a negative infinity value ensures they are never chosen\n    # when valid options exist.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item can fit (remaining capacity is non-negative).\n    # This signifies a physically possible placement.\n    can_fit_mask = remaining_after_placement >= 0\n\n    # For those bins that can accommodate the item, we desire to select the one that\n    # leaves the smallest possible non-negative remaining capacity. This is the\n    # essence of the \"Best Fit\" strategy, designed for optimal consolidation of matter.\n    #\n    # To translate this into a priority score where 'higher' means 'better':\n    #   - A remaining capacity of 0 (a perfect, harmonious fit) is ideal, yielding the highest priority.\n    #   - Small positive remaining capacities are next preferred, as they are nearly ideal.\n    #   - Larger positive remaining capacities are less preferred, indicating greater disarray.\n    #\n    # Thus, the priority score is the negative of the remaining capacity.\n    # A smaller positive remainder (e.g., 0.1) results in a larger priority (-0.1)\n    # compared to a larger remainder (e.g., 10), which results in a smaller priority (-10).\n    # A perfect fit (0 remainder) results in the highest possible priority (0).\n    priority_scores[can_fit_mask] = -remaining_after_placement[can_fit_mask]\n\n    return priority_scores",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    inspired by the principles of optimal resource utilization and efficiency.\n    This heuristic prioritizes the \"Best Fit\" strategy, seeking to leave the\n    smallest possible remainder in a bin after placement, akin to precisely\n    filling a flask with an experimental sample. Bins that cannot accommodate\n    the item are heavily penalized.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Calculate the remaining capacity if the item were placed in each bin.\n    # This represents the \"unfilled\" portion or \"waste\" after placement.\n    hypothetical_leftover = bins_remain_cap - item\n\n    # Initialize a priority score array.\n    # We use float to accommodate negative infinity.\n    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins where the item can fit (i.e., leftover capacity would be non-negative).\n    can_fit_mask = hypothetical_leftover >= 0\n\n    # For bins that can fit, we want to maximize the 'snugness' of the fit.\n    # Snugness means minimizing the `hypothetical_leftover`.\n    # Therefore, we assign priority as the negative of the leftover capacity.\n    # A smaller positive leftover (more snug fit) results in a larger (less negative)\n    # priority score, making it more desirable.\n    priority_scores[can_fit_mask] = -hypothetical_leftover[can_fit_mask]\n\n    # For bins that cannot accommodate the item, assign an extremely low priority.\n    # This ensures they are never chosen unless no other option exists (which\n    # should ideally not happen if a new bin can always be opened).\n    priority_scores[~can_fit_mask] = -np.inf\n\n    return priority_scores",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    A true Tesla design, combining efficiency with elegant selection!\n\n    This heuristic is based on the 'Best Fit' principle. Like fitting gears\n    precisely into a mechanism, we seek the bin that will be most \"snugly\"\n    filled by the new item, thereby minimizing wasted capacity and preserving\n    larger spaces for larger future components. Bins where the item does not\n    fit are given an infinitely negative priority, as they are unsuitable for current use.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # First, let us illuminate the path by marking all bins where the item simply cannot fit\n    # with an immense, prohibitive negative energy \u2013 effectively infinite resistance.\n    # This ensures they are never considered for the current flow of current.\n    priorities[bins_remain_cap < item] = -np.inf\n\n    # For the bins where the item can indeed be accommodated, we apply a more nuanced calculation.\n    # We desire to select the bin that, after receiving the item, will have the least residual capacity.\n    # This is akin to perfectly balancing a circuit: minimal excess, maximal utility.\n    #\n    # To achieve this, we calculate the negative of the remaining capacity if the item were placed.\n    # A smaller positive remainder (meaning a tighter fit) will result in a value closer to zero (or least negative).\n    # Example: If bin_cap = 1.0 and item = 0.9, remaining = 0.1. Priority = -(0.1) = -0.1\n    # If bin_cap = 0.9 and item = 0.9, remaining = 0.0. Priority = -(0.0) = 0.0 (perfect!)\n    # If bin_cap = 0.8 and item = 0.6, remaining = 0.2. Priority = -(0.2) = -0.2\n    #\n    # Therefore, the bin with the least negative (or zero) priority will be the 'best fit'.\n    valid_bins_mask = bins_remain_cap >= item\n    priorities[valid_bins_mask] = item - bins_remain_cap[valid_bins_mask]\n\n    return priorities",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Galileo's \"Best Fit\" Priority: Seeks to find the most fitting\n    receptacle, leaving no more space than is necessary. A tighter fit\n    is akin to celestial bodies occupying their orbits with precision.\n    Bins that cannot accommodate the item are cast out of consideration\n    into an endless void.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities. Bins that cannot fit the item are given an\n    # infinitely low priority, as if they reside in the realm beyond the\n    # celestial sphere \u2013 utterly unreachable.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify the 'habitable' bins, those whose remaining capacity\n    # is greater than or equal to the item's size.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For these suitable bins, we calculate the remaining void after the item\n    # is placed. Our objective is to minimize this void, striving for the\n    # most compact and precise arrangement, much like the perfect orbits.\n    # Thus, a smaller remaining space yields a higher priority.\n    # By negating the remaining space, the 'best fit' (smallest positive\n    # remaining space, or zero for a perfect fit) will result in the\n    # largest (least negative, or zero) priority score.\n    fitting_bins_remaining_space = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -fitting_bins_remaining_space\n\n    return priorities",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    Inspired by the 'Event Horizon Proximity Principle'. We aim to place\n    the incoming 'quantum of mass' (item) into the 'gravitational well' (bin)\n    that brings its remaining capacity closest to its 'event horizon' (full capacity),\n    without exceeding it. This strategy maximizes the 'density' within each bin,\n    thereby minimizing the overall 'curvature of spacetime' (the total number of bins).\n\n    A bin that results in a smaller remaining capacity after packing is considered\n    a more attractive 'gravitational singularity', indicating higher efficiency.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the hypothetical remaining capacity for each bin if the item were placed.\n    # This represents the 'distance' from the bin's event horizon after interaction.\n    hypothetical_remain_cap = bins_remain_cap - item\n\n    # Initialize all priorities to a state of effective 'negative infinity'.\n    # Bins that cannot accommodate the item are effectively 'beyond their event horizon'\n    # and are not viable candidates.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify the 'observable universe' of bins where the item can actually fit.\n    # These are bins where hypothetical_remain_cap is non-negative.\n    can_fit_mask = hypothetical_remain_cap >= 0\n\n    # For viable bins, the priority is higher when the remaining capacity\n    # is smaller. A smaller remaining capacity signifies closer proximity\n    # to the 'event horizon' (optimal utilization).\n    # We achieve this by negating the remaining capacity: a smaller positive value\n    # becomes a larger (less negative) priority score. A perfect fit (0 remaining)\n    # yields the highest score (0).\n    priorities[can_fit_mask] = -hypothetical_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the Best Fit (BF) heuristic.\n\n    The Best Fit heuristic aims to minimize the remaining capacity in a bin after placing an item.\n    This strategy tries to \"fill up\" bins as much as possible, potentially allowing them to be\n    closed off sooner and thus reducing the total number of bins used.\n\n    For each bin:\n    - If the item fits, the priority is calculated as the negative of the remaining capacity\n      after placing the item. This means a smaller remaining capacity (tighter fit) results\n      in a higher (less negative) priority score. An exact fit (remaining capacity = 0)\n      will yield the highest possible score (0) among valid fits.\n    - If the item does not fit, the priority is set to negative infinity, ensuring these bins\n      are never chosen unless no other bins are available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of the same size as bins_remain_cap with priority scores for each bin.\n        A higher score indicates a more desirable bin. Bins where the item cannot fit\n        will have a priority of -np.inf.\n    \"\"\"\n    # Initialize priorities with a very low value for all bins.\n    # We use float type to accommodate -np.inf.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins can currently accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the remaining capacity if the item is placed.\n    # We are interested in minimizing this remaining capacity.\n    # To convert minimization to maximization (for a priority function where higher is better),\n    # we take the negative of the remaining capacity.\n    # For example:\n    #   - If item=3, bin_cap=5 -> remaining=2 -> priority=-2\n    #   - If item=3, bin_cap=3 -> remaining=0 -> priority=0 (best fit, highest priority)\n    #   - If item=3, bin_cap=10 -> remaining=7 -> priority=-7\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign the calculated priorities to the bins that can fit the item.\n    priorities[can_fit_mask] = -remaining_capacity_after_fit\n\n    return priorities",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This function implements a \"Best Fit\" heuristic for the online bin packing problem.\n    It prioritizes bins that, upon receiving the item, would leave the smallest\n    amount of remaining capacity (i.e., achieving the \"snuggest\" fit).\n    Bins where the item cannot fit are assigned an extremely low priority.\n\n    The logic is as follows:\n    1. For each bin, determine if the item can fit within its remaining capacity.\n    2. If the item fits, calculate the remaining capacity after placing the item\n       (current_bin_capacity - item_size).\n    3. The priority score for a fitting bin is the negative of this remaining capacity.\n       This ensures that a smaller positive remaining capacity (a snugger fit, or\n       even a perfect fit resulting in 0 remaining capacity) yields a higher\n       (less negative or zero) priority score.\n    4. If the item does not fit, the bin receives a priority of negative infinity,\n       ensuring it is never chosen.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value (negative infinity).\n    # This ensures that bins where the item does not fit are never selected,\n    # as their priority will be lower than any valid fitting bin.\n    priorities = -np.ones_like(bins_remain_cap, dtype=float) * np.inf\n\n    # Find the indices of all bins where the current item can physically fit.\n    fitting_bin_indices = np.where(item <= bins_remain_cap)[0]\n\n    if fitting_bin_indices.size > 0:\n        # Calculate the remaining capacity in these fitting bins if the item were placed.\n        remaining_after_fit = bins_remain_cap[fitting_bin_indices] - item\n\n        # Assign priority scores to the fitting bins.\n        # By taking the negative of the remaining capacity, a smaller positive\n        # remaining capacity (closer to a perfect fit) results in a larger\n        # (less negative, or zero for a perfect fit) priority score.\n        priorities[fitting_bin_indices] = -remaining_after_fit\n\n    return priorities",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  }
]