```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin,
    using a Best Fit (BF) strategy based on the *proportion* of the remaining
    capacity that the item would fill.

    This heuristic prioritizes bins where the item consumes a larger fraction
    of the *currently available* space. Bins where the item perfectly fills
    the remaining capacity receive the highest possible priority (1.0).
    Among bins where the item fits, those where it fills a greater proportion
    of the remaining capacity are preferred. Bins where the item does not fit
    are assigned the lowest possible priority (-np.inf).

    This approach is a "mutation" of the standard Best Fit. While standard BF
    focuses on minimizing the *absolute* remaining space, this version focuses
    on maximizing the *relative* (proportional) utilization of the current bin space.
    For a given item, minimizing absolute remaining space is mathematically equivalent
    to maximizing the item's proportion of the remaining space, meaning both
    methods yield the same optimal bin selection in terms of rank order.
    However, the scaling of the priority scores differs, potentially offering
    different numerical properties or a more intuitive interpretation as a "fill ratio".

    Args:
        item: Size of item to be added to the bin. Assumed to be > 0.
        bins_remain_cap: Array of current remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score for each bin.
        Scores range from (0.0, 1.0] for fitting bins, and -np.inf for non-fitting bins.
    """
    # Initialize priority scores to negative infinity. These will be for bins
    # where the item does not fit.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can fit.
    # We must ensure bins_remain_cap is positive to avoid division by zero or negative capacity.
    # If bins_remain_cap is zero, it implies the bin is already full, and if item > 0, it won't fit.
    # The condition `bins_remain_cap >= item` implicitly handles `bins_remain_cap > 0` for `item > 0`.
    fitting_bins_mask = bins_remain_cap >= item

    # Calculate priorities only for bins where the item fits.
    # The priority is the ratio of the item size to the bin's remaining capacity.
    # A higher ratio indicates a "tighter" fit relative to the available space.
    # Example: if item=0.3, and bin_remain_cap=0.3, ratio = 1.0 (perfect fit).
    # If item=0.3, and bin_remain_cap=0.6, ratio = 0.5.
    # The division by `bins_remain_cap[fitting_bins_mask]` is safe because `fitting_bins_mask`
    # ensures `bins_remain_cap` is at least `item`, and `item` is assumed to be > 0.
    priorities[fitting_bins_mask] = item / bins_remain_cap[fitting_bins_mask]

    return priorities
```
