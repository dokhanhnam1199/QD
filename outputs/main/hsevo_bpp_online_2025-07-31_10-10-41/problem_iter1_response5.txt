```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin,
    implementing a 'Best Fit' heuristic.

    As Galileo, I believe in discerning the most orderly and efficient
    arrangements within creation. In the grand cosmos of capacities,
    we must place this new 'celestial body' (item) into the 'orb' (bin)
    that accommodates it with the least superfluous void. This approach,
    akin to fitting a planet into its most harmonious orbit, ensures that
    we leave the larger, more capacious bins for truly vast entities yet
    to emerge, or that we fill our current vessels with maximum precision.

    The priority for each bin is determined by the negative of the space
    that would remain if the item were placed within it. Thus, a smaller
    remaining void (a tighter, more 'best' fit) yields a higher (less negative)
    priority score. Bins that cannot possibly contain the item are deemed
    unsuitable and receive the lowest possible priority, indicating they are
    not viable candidates in this celestial arrangement.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    if bins_remain_cap.size == 0:
        return np.array([], dtype=float)

    # Initialize priorities to a profoundly low value for all bins.
    # This reflects their initial state of unsuitability or disfavor.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify which bins are truly capacious enough to contain this item.
    # These are the bins that can potentially offer a 'fit'.
    can_fit_mask = bins_remain_cap >= item

    # For those bins deemed capable, calculate the remaining capacity after
    # the item is placed. This 'remaining_space' is what we seek to minimize
    # in the spirit of a 'Best Fit'.
    remaining_space = bins_remain_cap[can_fit_mask] - item
    
    # Assign the priority: the negative of the remaining space.
    # A smaller remaining space (closer to zero) results in a larger
    # (less negative, thus higher) priority, guiding us to the optimal snug fit.
    priorities[can_fit_mask] = -remaining_space

    return priorities
```
