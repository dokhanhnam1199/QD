```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function implements a Best Fit-like strategy. It aims to place
    the item in a bin such that the remaining capacity of that bin is minimized
    after the item is placed (i.e., making the bin as 'full' as possible).

    Bins that cannot accommodate the item are given a very low priority
    (negative infinity). Among valid bins, the priority is set to the negative
    of the space that would be left in the bin after placing the item. This way,
    a smaller leftover space results in a higher (less negative) priority score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Create a boolean mask for bins that can accommodate the item
    valid_bins_mask = bins_remain_cap >= item

    # For valid bins, calculate the remaining space if the item were placed.
    # We want to minimize this remaining space, which means maximizing its negative value.
    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item
    
    # Assign the negative of the leftover space as the priority.
    # Example: If leftover is 0.1, priority is -0.1. If leftover is 0.5, priority is -0.5.
    # -0.1 is greater than -0.5, so the bin with less leftover space gets higher priority.
    priorities[valid_bins_mask] = -leftover_space_if_placed

    return priorities
```
