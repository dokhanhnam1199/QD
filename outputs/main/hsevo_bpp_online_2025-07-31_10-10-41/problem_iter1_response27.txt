```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    
    Inspired by quantum phenomena, this heuristic views the packing problem 
    as an optimization of "potential energy." Bins that offer a "snug fit" 
    for the item, leaving minimal wasted space, are highly preferred. 
    A perfect fit represents the lowest potential energy state and thus 
    the highest probability (priority) for the item to settle there.

    Specifically, the priority is calculated using an exponential decay function:
    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.
    This means:
    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).
    - As the "wasted space" (remaining_capacity - item_size) increases, the priority 
      decreases exponentially towards zero.
    - Bins where the item does not fit receive a priority of negative infinity.

    This "fuzzy Best Fit" approach smoothly quantifies the desirability of each bin, 
    preferring efficiency while still distinguishing between different levels of "goodness."

    Args:
        item: Size of item to be added to the bin. Assumed to be a positive float.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    
    # Items in Bin Packing are typically positive. If a non-positive item were given,
    # it defies the problem context. Assign lowest priority to all bins.
    if item <= 0:
        return np.full_like(bins_remain_cap, -np.inf)

    # Initialize priorities to a very low value, representing "cannot fit" or "undesirable".
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins where the item *can* fit
    fits_mask = bins_remain_cap >= item

    # Calculate the 'wasted space' if the item were placed in each fitting bin.
    # This is the difference: (bin_remaining_capacity - item_size).
    # We want to minimize this difference for higher priority.
    wasted_space_for_fits = bins_remain_cap[fits_mask] - item

    # Apply the exponential priority function.
    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).
    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).
    priorities[fits_mask] = np.exp(-wasted_space_for_fits)

    return priorities
```
