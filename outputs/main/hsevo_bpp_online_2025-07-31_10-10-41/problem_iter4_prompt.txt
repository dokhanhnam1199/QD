{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority, favoring tightest fits (Best Fit) with a normalized scale.\n\n    This heuristic prioritizes bins that minimize wasted space, assigning higher scores\n    to tighter linear fits (0 to 1, with 1 being a perfect fit). Bins incapable\n    of holding the item receive the lowest possible priority, ensuring robustness.\n    \"\"\"\n    # Robustness check from v1: Non-positive items are typically not valid in BPP.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Calculate potential remaining space (wasted space) if the item were placed.\n    # This is the core \"Best Fit\" principle, shared conceptually by v0 and v1.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value, ensuring non-fitting bins are never chosen.\n    # This element is common to both v0 and v1.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can actually fit.\n    fitting_bins_mask = potential_remaining_space >= 0\n\n    # Extract the 'wasted space' for only the bins where the item fits.\n    wasted_space_for_fits = potential_remaining_space[fitting_bins_mask]\n\n    # Dynamically normalize priorities within the range of fitting bins.\n    # This combines the 'quantifying desirability' aspect of v1 with v0's linearity.\n    # We find the maximum 'wasted space' among currently viable bins to scale priorities.\n    if wasted_space_for_fits.size > 0:\n        max_wasted_space_among_fits = np.max(wasted_space_for_fits)\n        \n        # If all fitting bins are perfect fits (max_wasted_space is 0), assign max priority.\n        if max_wasted_space_among_fits == 0:\n            priorities[fitting_bins_mask] = 1.0\n        else:\n            # Linearly scale the priority: smallest wasted space (0) gets 1.0,\n            # largest wasted space gets 0.0. This is a linear transformation\n            # of v0's priority, ensuring a positive, normalized scale.\n            priorities[fitting_bins_mask] = 1.0 - (wasted_space_for_fits / max_wasted_space_among_fits)\n    \n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}