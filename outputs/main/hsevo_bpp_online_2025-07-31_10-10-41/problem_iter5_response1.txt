```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Adaptive Best Fit: Prioritizes bins maximizing relative fill, promoting efficient bin usage.
    This heuristic favors bins where the item constitutes a larger proportion of the remaining capacity,
    a strategy robustly outperforming Worst Fit by minimizing wasted space dynamically.
    """
    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Robustness check: Items with non-positive sizes are invalid in typical BPP.
    if item <= 0:
        return priorities

    # Identify all bins where the current item can physically fit.
    fitting_mask = bins_remain_cap >= item

    # Proceed only if there's at least one bin where the item can fit.
    if np.any(fitting_mask):
        # Calculate the "proportional utilization" for the fitting bins.
        # This score represents how much of the bin's *remaining* capacity the item will fill.
        # A higher ratio (closer to 1.0) indicates a tighter, more efficient fit.
        # This strategy is a powerful form of Best Fit, effectively balancing item size
        # against available bin space. Perfect fits (item fills bin exactly) result in a score of 1.0.
        priorities[fitting_mask] = item / bins_remain_cap[fitting_mask]

    return priorities
```
