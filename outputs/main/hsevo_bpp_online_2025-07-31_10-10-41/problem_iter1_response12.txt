```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, guided by the principle of Best Fit.

    Verily, just as objects in motion seek the lowest potential energy, so too shall an item of
    given magnitude seek the receptacle that can most perfectly contain it, leaving but a
    negligible void. This 'Best Fit' strategy, inspired by the desire for maximal efficiency
    and minimal wasted space, ensures we compact our goods with a precision worthy of the
    celestial mechanics.

    The priority for each bin is determined as follows:
    1. For bins where the item does not fit, the priority is set to a value so infinitesimally
       small that these bins are rendered unsuitable.
    2. For bins where the item fits, the priority is calculated such that a tighter fit
       (i.e., less remaining capacity after the item is placed) yields a higher score.
       Specifically, it is the negative of the potential leftover capacity, transforming
       the minimization of waste into a maximization problem for the selection mechanism.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the space that would remain in each bin if the item were placed there.
    # A positive value indicates the item fits, a negative value indicates it does not.
    potential_leftover = bins_remain_cap - item

    # Identify which bins can actually accommodate the item.
    fits_mask = potential_leftover >= 0

    # Initialize all priority scores to a very low value (negative infinity).
    # This ensures that bins where the item does not fit are never chosen
    # unless there are absolutely no fitting bins.
    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # For those bins where the item fits, assign a priority based on the Best Fit principle.
    # We want to minimize the 'potential_leftover' (i.e., the wasted space).
    # To achieve this with a maximization-based selection (highest priority wins),
    # we take the negative of the 'potential_leftover'. Thus, a smaller positive
    # 'potential_leftover' (closer to zero) results in a larger (less negative) priority score.
    priority_scores[fits_mask] = -potential_leftover[fits_mask]

    return priority_scores
```
