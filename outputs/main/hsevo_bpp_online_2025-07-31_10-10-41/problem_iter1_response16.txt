```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin.

    Drawing inspiration from the relentless pull of gravity towards a singularity,
    this heuristic, which I shall call the 'Event Horizon Collapse Prioritization',
    guides the incoming item towards a bin that, upon its absorption, approaches
    a state of maximal density – that is, a bin that becomes as full as possible,
    leaving minimal 'event horizon' (remaining space). A perfect fit, like
    a complete gravitational collapse, is highly favored. Bins that cannot
    accommodate the item are given a virtually infinite negative priority,
    as they are beyond the event horizon for this item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score for each bin.
        Higher scores indicate a stronger 'gravitational pull' for the item.
    """
    # Initialize all scores to an abyssal low, effectively ruling out
    # bins that cannot even contain the item. This is our 'negative infinity'
    # for impossible fits.
    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify the 'habitable' bins – those where the item can physically fit.
    can_fit = bins_remain_cap >= item

    if np.any(can_fit):
        # For the habitable bins, calculate the 'residual energy' –
        # the amount of space remaining after the item is placed.
        residual_energy = bins_remain_cap[can_fit] - item

        # To prevent division by zero in the case of a perfect fit
        # (where residual_energy is exactly 0), we add a minuscule
        # 'quantum perturbation' (epsilon). This ensures that a perfect
        # fit yields the highest possible finite score.
        epsilon = 1e-9

        # The 'Event Horizon Collapse Prioritization' assigns a score
        # inversely proportional to the residual energy. A smaller
        # residual energy (i.e., a tighter fit) results in a much higher score,
        # encouraging the 'collapse' of the bin towards a fully packed state.
        valid_scores = 1.0 / (residual_energy + epsilon)

        # Apply these calculated potentials to the relevant bins.
        scores[can_fit] = valid_scores
    # If no bins can accommodate the item, all scores remain -np.inf,
    # signaling a crisis where new space (a new bin) is required.

    return scores
```
