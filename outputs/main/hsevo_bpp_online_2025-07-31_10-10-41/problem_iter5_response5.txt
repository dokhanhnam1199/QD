```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best-Fit with robust input handling and intuitive linear scoring,
    prioritizing perfect fits to minimize wasted space.
    """
    # Robustness check: Handle invalid item sizes (non-positive items).
    # Such items cannot be packed, so all bins receive the lowest priority.
    if item <= 0:
        return np.full_like(bins_remain_cap, -np.inf)

    # Initialize priorities to a very low value. This ensures bins where the item
    # cannot fit are never selected.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the 'wasted space' (remaining capacity after placement)
    # if the item were placed in each bin.
    wasted_space = bins_remain_cap - item

    # Create a mask to identify only those bins where the item can fit (wasted_space >= 0).
    can_fit_mask = wasted_space >= 0

    # For bins that can accommodate the item, assign a priority score.
    # The Best-Fit principle aims to minimize 'wasted_space'.
    # We use a linear transformation: 1.0 - wasted_space.
    # This design ensures:
    # - A perfect fit (wasted_space = 0) receives the highest score of 1.0.
    # - As wasted_space increases, the priority linearly decreases from 1.0.
    # This scaling provides an intuitive interpretation while maintaining Best-Fit's
    # relative preference for tighter fits.
    priorities[can_fit_mask] = 1.0 - wasted_space[can_fit_mask]

    return priorities
```
