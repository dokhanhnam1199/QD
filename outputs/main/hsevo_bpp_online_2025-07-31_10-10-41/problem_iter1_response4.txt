```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Nikola Tesla's principle of 'Electromagnetic Optimization':
    In the realm of energy and efficiency, one must strive for the most
    harmonious coupling between source and receiver. This heuristic embodies
    that quest, seeking the container where the incoming 'energy packet' (item)
    will complete the 'circuit' most precisely, leaving the barest minimum of
    residual 'potential' (space). We prioritize the bins that achieve the
    'snuggest' fit, minimizing inefficiency and accelerating the full utilization
    of each vessel. A perfect fit is given the highest possible consideration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        A higher score indicates a more desirable bin. Bins that cannot
        accommodate the item receive a score of 0, effectively removing them
        from contention unless no suitable bin exists (in which case a new
        bin would typically be opened by the higher-level logic).
    """
    # Initialize all bin priorities to 0.0. Bins that cannot fit will retain this score.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the remaining capacity in each bin if the item were placed.
    # A smaller 'remaining_space' after placement indicates a 'snugger' fit.
    remaining_space = bins_remain_cap - item

    # Identify which bins can actually accommodate the item.
    # This ensures we only consider valid placements.
    can_fit_mask = remaining_space >= 0

    # For bins that can fit, we assign a priority.
    # The Best Fit heuristic seeks to minimize 'remaining_space'.
    # To convert this into a 'highest priority wins' score, we use the negative
    # of the remaining_space.
    # - A perfect fit (remaining_space = 0) gets a priority of 0.
    # - A snug fit (small positive remaining_space) gets a small negative priority
    #   (e.g., -0.1 for remaining_space of 0.1).
    # - A loose fit (large positive remaining_space) gets a large negative priority
    #   (e.g., -0.5 for remaining_space of 0.5).
    # This ensures that smaller positive `remaining_space` values yield priorities
    # that are numerically larger (closer to zero).
    priorities[can_fit_mask] = -remaining_space[can_fit_mask]

    return priorities
```
