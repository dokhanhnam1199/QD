```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit (proportional utilization) with Smallest Fit (current bin capacity).
    Prioritizes bins yielding a high fill ratio while also preferring bins with smaller current remaining capacities to close them faster.
    """
    # Initialize priority scores to negative infinity for non-fitting or invalid cases.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Handle invalid item size: If item is non-positive, it cannot be packed.
    if item <= 0:
        return priorities

    # Identify bins where the item can fit.
    fitting_bins_mask = bins_remain_cap >= item

    # Calculate priorities for fitting bins by combining two effective strategies:
    # 1. Proportional Best Fit: `item / bins_remain_cap` (maximizes relative fill).
    # 2. Smallest Fit: `-bins_remain_cap` (prioritizes bins with less remaining space to close them).
    # The sum balances maximizing the item's proportional use of space with minimizing the bin's overall remaining space.
    priorities[fitting_bins_mask] = \
        (item / bins_remain_cap[fitting_bins_mask]) + \
        (-bins_remain_cap[fitting_bins_mask])

    return priorities
```
