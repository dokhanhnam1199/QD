[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes Best Fit, strongly favoring bins that achieve perfect item-bin fits.\"\"\"\n\n    # Calculate the remaining capacity after placing the item in each bin.\n    # A smaller positive value indicates a better fit (less wasted space).\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores. Best Fit strategy aims to minimize remaining capacity,\n    # so we negate it to transform into a maximization problem (higher score = better).\n    priorities = -remaining_after_placement\n\n    # For bins where the item does not fit (remaining_after_placement would be negative),\n    # assign the lowest possible priority (-infinity) to ensure they are never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    # Apply a strong bonus for perfect fits: if an item perfectly fills a bin (remaining capacity is zero\n    # or very close to zero due to floating-point precision), give it the absolute highest priority.\n    # This aligns with the strategy of completing bins whenever possible.\n    epsilon = 1e-9  # Tolerance for floating-point comparison\n    perfect_fit_mask = np.abs(remaining_after_placement) < epsilon\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using Best Fit with bonuses for perfect fits and near-full bins.\n\n    This heuristic combines the effectiveness of Best Fit with specific incentives for\n    bin consolidation, avoiding complex adaptive factors.\n    \"\"\"\n    BIN_CAPACITY = 1.0  # Assumed normalized bin capacity, adjust if problem implies otherwise\n\n    # Robustness check: If the item size is non-positive, it's invalid.\n    # No bin should be chosen, so return negative infinity for all.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Initialize all priorities to negative infinity. This ensures that bins\n    # where the item cannot fit are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify all bins capable of containing the incoming item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate base priority for fitting bins using a Best Fit approach.\n    # The goal is to maximize `-(remaining_capacity_after_placement)`.\n    # This means smaller remaining space (better fit) yields a higher score (closer to 0 or positive).\n    # A perfect fit (0 remaining) gets a base score of 0.\n    remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n    priorities[can_fit_mask] = -remaining_after_placement\n\n    # --- Apply Bonuses to Enhance Bin Consolidation ---\n\n    # 1. Perfect Fit Bonus: Substantially prioritize bins where the item\n    #    perfectly fills the remaining capacity. This is a strong, but finite, bonus.\n    PERFECT_FIT_BONUS = 100.0  # Tunable constant\n    perfect_fit_mask = (remaining_after_placement == 0)\n    if np.any(perfect_fit_mask):\n        priorities[can_fit_mask][perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # 2. Bin Near-Completion Bonus (pre-placement): Encourage using bins that are\n    #    already significantly full *before* the item is placed. This helps\n    #    consolidate items into existing bins and potentially close them off.\n    #    The bonus is proportional to the bin's current fullness (0 to 1).\n    FULLNESS_BONUS_FACTOR = 0.5  # Tunable constant, controls strength of this incentive\n    if BIN_CAPACITY > 0: # Ensure valid division\n        current_fullness = (BIN_CAPACITY - bins_remain_cap[can_fit_mask]) / BIN_CAPACITY\n        priorities[can_fit_mask] += FULLNESS_BONUS_FACTOR * current_fullness\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = 1.0) -> np.ndarray:\n    \"\"\"Prioritizes Best Fit, adds a bonus for bin consolidation, and gives highest priority to perfect fits.\n    \"\"\"\n    # Handle invalid item size: If item is non-positive, it cannot be packed.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Base Best Fit priority: A smaller positive remaining capacity yields a higher score.\n    bf_priorities = -remaining_after_placement\n\n    # Bin Completion Bonus: Encourage filling up existing bins by giving a bonus\n    # based on current occupancy (before placing the item).\n    current_occupancy_ratio = (bin_capacity - bins_remain_cap) / bin_capacity\n    current_occupancy_ratio = np.clip(current_occupancy_ratio, 0, 1)\n\n    beta = 0.5  # Tunable parameter for the influence of the completion bias.\n    completion_bonus = beta * current_occupancy_ratio\n\n    # Combine Best Fit priority with the completion bonus\n    priorities = bf_priorities + completion_bonus\n\n    # Perfect Fit Bonus: Strongly prioritize bins that result in a perfect fit.\n    # Use a small tolerance for floating-point comparisons.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0, atol=1e-9)\n    priorities[perfect_fit_mask] = np.inf\n\n    # Finally, set priority to negative infinity for bins where the item does not fit.\n    # This ensures these bins are never selected, overriding any other calculated bonuses.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best Fit prioritizing minimal remaining space, with an absolute bonus for perfect fits.\n    \"\"\"\n    if item <= 0:\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap)\n\n    # Core Best Fit: Prioritize bins by minimizing remaining space\n    # This means maximizing -remaining_after_placement for valid fits.\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Absolute Highest Priority: Ensure perfect fits are always chosen first.\n    # This strongly encourages bin completion.\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with strong prioritization for perfect fits and a bonus for near-perfect fits.\n    \"\"\"\n    # Initialize all priorities to negative infinity, indicating bins where item cannot fit initially.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: items must have a positive size to be packable.\n    if item <= 0:\n        return priorities\n\n    # Calculate the remaining capacity for each bin if the item were placed.\n    potential_remainders = bins_remain_cap - item\n\n    # Create a mask for bins where the item *can* physically fit.\n    fits_mask = potential_remainders >= 0\n\n    # 1. Core Best Fit (BF) Strategy:\n    # For bins where the item fits, calculate the priority as the negative of the remaining space.\n    # This means smaller remaining space (tighter fit) results in a higher (less negative) priority.\n    priorities[fits_mask] = -potential_remainders[fits_mask]\n\n    # 2. Strong Prioritization for Perfect Fits:\n    # If an item perfectly fills a bin (remainder is exactly zero), assign the highest possible priority.\n    # This leverages the insight that perfect fits are highly desirable.\n    perfect_fit_mask = (potential_remainders == 0) & fits_mask\n    priorities[perfect_fit_mask] = np.inf\n\n    # 3. Additive Bonus for Near-Perfect Fits (Bin Completion Incentive):\n    # Apply a significant, but not infinite, bonus for bins that are left with\n    # a very small amount of remaining capacity after placement. This encourages\n    # 'completing' bins by leaving minimal waste.\n    # EPSILON defines what \"very small\" means for remaining capacity.\n    EPSILON = 1e-6 \n    BONUS_FOR_NEAR_PERFECT = 1000.0 # A substantial bonus to elevate these fits\n\n    near_perfect_fit_mask = (potential_remainders > 0) & (potential_remainders <= EPSILON) & fits_mask\n    priorities[near_perfect_fit_mask] += BONUS_FOR_NEAR_PERFECT\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with explicit incentives: significant bonus for perfect fits to\n    complete bins, and a penalty for creating small, unusable gaps, prioritizing efficient\n    space utilization and bin consolidation.\n    \"\"\"\n    # Define constants for heuristic parameters. These values might need tuning\n    # depending on the specific distribution of item sizes and bin capacities.\n    # Assumes a typical bin capacity is implicitly scaled, e.g., to 1.0.\n    EPSILON = 1e-9  # Tolerance for floating point comparisons (e.g., for \"perfect fit\")\n    PERFECT_FIT_BONUS = 1000.0 # Large bonus for a perfect fit to make it highly preferred\n    SMALL_GAP_THRESHOLD = 0.1 # Threshold for defining a \"small\" remaining capacity\n                              # (e.g., 0.1 means 10% of a common normalized bin capacity)\n    SMALL_GAP_PENALTY = -0.5  # Penalty applied if placing the item leaves a small, unusable gap\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit principle:\n    # A smaller remaining_after_placement (closer to 0) is better, so we take the negative.\n    # This means 0 remaining capacity gets a 0 score, 0.1 gets -0.1, etc.\n    priorities = -remaining_after_placement\n\n    # --- Apply Bin Completion Bonus ---\n    # Identify bins where the item fits perfectly or almost perfectly.\n    # This condition uses EPSILON to account for floating-point inaccuracies.\n    perfect_fit_mask = remaining_after_placement <= EPSILON\n\n    # Add a significant bonus to these bins. This ensures that perfect fits are\n    # prioritized above all other considerations.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Apply Small Gap Penalty ---\n    # Identify bins where the item fits, but leaves a small, non-zero remaining capacity.\n    # Such small gaps can lead to fragmentation.\n    small_unusable_gap_mask = (remaining_after_placement > EPSILON) & \\\n                              (remaining_after_placement < SMALL_GAP_THRESHOLD)\n\n    # Apply a penalty to these bins. This makes them less attractive than bins that\n    # either perfectly fit the item or leave a larger, potentially more usable space.\n    priorities[small_unusable_gap_mask] += SMALL_GAP_PENALTY\n\n    # --- Final Filtering for Non-Fitting Bins ---\n    # Set priority to negative infinity for bins where the item does not fit (i.e.,\n    # remaining_after_placement is negative). This ensures these bins are never chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by minimizing remaining capacity (Best Fit). Awards infinite\n    priority to perfect fits, ensuring optimal bin utilization for exact matches.\n    \"\"\"\n    # Initialize all priorities to a very low value. Bins are undesirable or unusable by default.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid and cannot be placed.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Calculate the remaining capacity if the item were placed in each fitting bin.\n        # This is the core of the Best Fit strategy: find the bin that minimizes this remainder.\n        remaining_after_fit = bins_remain_cap[fitting_mask] - item\n\n        # Assign a priority score such that smaller remaining capacities get higher scores.\n        # By negating the remainder, we transform minimizing a positive value into maximizing a negative value (closer to zero).\n        priorities[fitting_mask] = -remaining_after_fit\n\n        # Strongly prioritize perfect fits by assigning them an infinite score.\n        # This encourages completing bins whenever an item perfectly fills one,\n        # aligning with the goal of maximizing bin utilization and preventing tiny remnants.\n        perfect_fit_mask = (remaining_after_fit == 0)\n        if np.any(perfect_fit_mask):\n             priorities[fitting_mask][perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines Proportional Best Fit with a strong bonus for perfect fits.\n\n    Prioritizes bins where the item fills a larger proportion of remaining capacity,\n    with a significant boost for bins where the item fits exactly.\n    \"\"\"\n    # Initialize all priorities to a very low value, indicating bins are initially undesirable or unusable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Robustness check: Items with non-positive sizes are invalid in typical BPP.\n    if item <= 0:\n        return priorities\n\n    # Identify all bins where the current item can physically fit.\n    fitting_mask = bins_remain_cap >= item\n\n    # Proceed only if there's at least one bin where the item can fit.\n    if np.any(fitting_mask):\n        # Base priority: Proportional Best Fit (from priority_v0).\n        # This maximizes the ratio of item size to remaining bin capacity,\n        # promoting efficient utilization and minimizing wasted space within a bin.\n        current_priorities = item / bins_remain_cap[fitting_mask]\n\n        # Identify bins where the item fits perfectly (remaining capacity equals item size).\n        perfect_fit_mask = (bins_remain_cap[fitting_mask] == item)\n\n        # Apply a significant, non-infinite bonus to perfect fits.\n        # This strongly prioritizes closing bins exactly, as suggested by the analysis\n        # (\"Strongly prioritize perfect item-bin fits\"), while avoiding the potential\n        # rigidity of an infinite score if other factors might rarely matter.\n        # A large constant ensures these scores are strictly higher than any\n        # non-perfect proportional fit (which are always <= 1.0).\n        current_priorities[perfect_fit_mask] += 100.0\n\n        # Assign the calculated priorities to the fitting bins.\n        priorities[fitting_mask] = current_priorities\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, BIN_CAPACITY: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Enhanced Best Fit: Combines core Best Fit with perfect fit prioritization,\n    a penalty for very small remnants, and a bonus for nearly full bins to encourage consolidation.\n    \"\"\"\n    if item <= 0:\n        # Invalid item size should result in lowest possible priority for all bins.\n        return -np.inf * np.ones_like(bins_remain_cap)\n\n    remaining_after_placement = bins_remain_cap - item\n    priorities = -np.inf * np.ones_like(bins_remain_cap) # Initialize with lowest priority\n\n    # 1. Core Best Fit Logic:\n    # For bins where the item fits, set priority based on minimizing remaining space.\n    # A smaller remaining_after_placement (closer to 0) results in a higher priority.\n    fits_mask = remaining_after_placement >= 0\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Define hyperparameters for the adaptive components.\n    # These values might need tuning based on problem characteristics and scale.\n    SMALL_REMNANT_THRESHOLD = 0.05 * BIN_CAPACITY # e.g., 5% of bin capacity\n    PENALTY_VALUE = 0.1 # Arbitrary penalty value, relative to typical priority scores\n\n    NEARLY_FULL_THRESHOLD = 0.1 * BIN_CAPACITY # e.g., bins with <= 10% capacity remaining are \"nearly full\"\n    BIN_COMPLETION_BONUS = 0.05 # Arbitrary bonus value\n\n    # 2. Penalize very small, non-zero remnants:\n    # Discourages leaving tiny, potentially unusable gaps in bins (from priority_v0).\n    small_remnant_mask = (remaining_after_placement > 0) & \\\n                         (remaining_after_placement < SMALL_REMNANT_THRESHOLD) & \\\n                         fits_mask\n    priorities[small_remnant_mask] -= PENALTY_VALUE\n\n    # 3. Bonus for nearly full bins (before placing the item):\n    # Encourages consolidating items into bins that are already well-filled,\n    # aiming to \"finish\" or close off bins sooner (inspired by Bin Completion Bonus concept).\n    nearly_full_bin_mask = (bins_remain_cap <= NEARLY_FULL_THRESHOLD) & \\\n                           (bins_remain_cap > 0) & \\\n                           fits_mask # Ensure item still fits\n    priorities[nearly_full_bin_mask] += BIN_COMPLETION_BONUS\n\n    # 4. Absolute Highest Priority for perfect fits:\n    # A perfect fit (0 remaining space) is almost always the optimal immediate choice\n    # and should override any other considerations (from priority_v0).\n    perfect_fit_mask = (remaining_after_placement == 0)\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using Proportional Best Fit, with a strong bonus for perfect item-bin fits.\n\n    Promotes efficient space utilization and fast bin closure.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle non-positive items: they cannot be packed, assign lowest priority.\n    if item <= 0:\n        return priorities\n\n    # Identify bins where the item can fit.\n    valid_bins_mask = bins_remain_cap >= item\n\n    # Apply Proportional Best Fit for valid bins: maximize `item / current_bin_capacity`.\n    # This naturally favors smaller valid remaining capacities (Best Fit) and higher utilization.\n    priorities[valid_bins_mask] = item / bins_remain_cap[valid_bins_mask]\n\n    # Aggressively prioritize perfect fits with an infinite score to ensure immediate closure.\n    perfect_fit_mask = bins_remain_cap == item\n    priorities[perfect_fit_mask] = np.inf\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, enhancing Best Fit with a perfect fit bonus.\n\n    This function builds upon the Best Fit (BF) strategy (prioritizing bins that leave less remaining capacity)\n    and incorporates a significant additive bonus for bins where the item perfectly fills the bin,\n    thereby encouraging bin completion.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit (BF) strategy.\n    # A smaller positive `remaining_after_placement` value indicates a better fit.\n    # To convert this into a maximization problem (higher priority is better),\n    # we take the negative of `remaining_after_placement`.\n    # For example:\n    #   - If remaining=0 (perfect fit), initial priority is 0.\n    #   - If remaining=0.1 (tight fit), initial priority is -0.1.\n    #   - If remaining=0.5 (loose fit), initial priority is -0.5.\n    priorities = -remaining_after_placement\n\n    # --- Additive Incentive: Perfect Fit / Bin Completion Bonus ---\n    # Define a substantial bonus for bins where the item fits perfectly,\n    # leading to the bin being completely filled. This encourages closing bins.\n    # The bonus value should be significantly larger than the range of\n    # Best Fit scores for non-perfect fits (which are typically between -BIN_CAPACITY and 0).\n    # Assuming common bin capacities (e.g., 1.0 if normalized), Best Fit scores\n    # will be in [-1.0, 0). A bonus of 10.0 ensures perfect fits are highly preferred.\n    PERFECT_FIT_BONUS = 10.0\n\n    # Use a small epsilon for robust floating-point comparison to identify perfect fits.\n    # A bin is considered \"perfectly fit\" if its remaining capacity after placement\n    # is numerically very close to zero.\n    EPSILON = 1e-9\n\n    # Apply the perfect fit bonus to the relevant bins.\n    # This check identifies bins that will have approximately zero remaining capacity\n    # after the item is placed.\n    perfect_fit_mask = np.abs(remaining_after_placement) < EPSILON\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    # --- Core Placement Logic Validation: Handle Non-Fitting Items ---\n    # For bins where the item does not fit (i.e., `remaining_after_placement` is negative),\n    # assign the lowest possible priority (`-np.inf`) to ensure they are never selected.\n    # This step correctly overrides any temporary positive values that might arise if\n    # `remaining_after_placement` was negative before the `-` operation (e.g., `-(-0.5)` yields `0.5`),\n    # ensuring only bins where the item physically fits can be chosen.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns a priority score for each bin, incorporating Best Fit,\n    a strong bonus for perfect fits, and an additive incentive for near-completion.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on Best Fit (BF) strategy:\n    # Prefer bins leaving less remaining capacity. A smaller positive\n    # remaining_after_placement means a better fit. We take the negative\n    # to convert this into a maximization problem for priority scores.\n    # Example: 0.1 remaining -> -0.1 priority; 10 remaining -> -10 priority.\n    priorities = -remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item does not fit.\n    # This ensures they are never chosen unless no other option exists (implying a new bin).\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    # --- Additive Incentives ---\n\n    # Determine a robust magnitude for bonus values based on the scale of bin capacities.\n    # This helps in tuning parameters like thresholds and bonus magnitudes so they\n    # are relevant regardless of the actual numerical scale of bin sizes.\n    positive_caps = bins_remain_cap[bins_remain_cap > 0]\n    # Use the maximum remaining capacity as a reference scale. If no positive capacities\n    # exist (e.g., all bins are full or array is empty), default to 1.0 to prevent errors\n    # and provide a baseline for bonus calculation.\n    max_relevant_capacity = np.max(positive_caps) if positive_caps.size > 0 else 1.0\n\n    # 1. Strong Bonus for Perfect Fits:\n    # This bonus ensures that a perfect fit (remaining capacity becomes 0)\n    # gets a score strictly higher than any non-perfect fit.\n    # We use a small epsilon for floating-point comparisons to define \"perfect fit\".\n    EPSILON_PERFECT_FIT = 1e-9\n    is_perfect_fit = np.isclose(remaining_after_placement, 0.0, atol=EPSILON_PERFECT_FIT)\n\n    # The bonus magnitude must be large enough to make a perfect fit dominate.\n    # A safe approach is to set it higher than the maximum possible negative priority\n    # a non-perfect fit could receive (which is roughly -max_relevant_capacity).\n    # Setting it to `2 * max_relevant_capacity + 1.0` ensures this dominance.\n    PERFECT_FIT_BONUS_MAGNITUDE = max_relevant_capacity * 2 + 1.0\n    priorities[is_perfect_fit] += PERFECT_FIT_BONUS_MAGNITUDE\n\n    # 2. Additive Incentive for \"Near Completion\" / \"Tight Fits\":\n    # This bonus encourages placing items into bins that are almost full after placement,\n    # but not perfectly full. This promotes \"closing\" bins efficiently.\n    # It applies only if the item fits and it's not a perfect fit.\n    \n    # Define \"near completion\" as leaving a remaining capacity below a certain threshold.\n    # This threshold is set as a fraction (e.g., 10%) of the `max_relevant_capacity`.\n    # This makes the threshold adaptive to the scale of bin sizes.\n    NEAR_COMPLETION_THRESHOLD = max_relevant_capacity * 0.1\n\n    # Identify bins that are \"near completion\" after the item is placed.\n    # They must have positive remaining capacity (not perfect fit) and be below the threshold.\n    is_near_completion = (remaining_after_placement > EPSILON_PERFECT_FIT) & \\\n                         (remaining_after_placement <= NEAR_COMPLETION_THRESHOLD)\n\n    # The bonus magnitude for near completion should be significant but less than\n    # the perfect fit bonus, ensuring the hierarchy (Perfect > Near > Normal).\n    # Setting it to `max_relevant_capacity` places these fits above any normal fit\n    # (which are at most 0 and typically negative), but below perfect fits.\n    NEAR_COMPLETION_BONUS_MAGNITUDE = max_relevant_capacity * 1.0\n    priorities[is_near_completion] += NEAR_COMPLETION_BONUS_MAGNITUDE\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    using a Best Fit strategy with strong additive incentives for perfect fits (bin completion).\n\n    Bins where the item fits perfectly get a very high positive priority, effectively\n    prioritizing bin completion. Among bins where the item fits but not perfectly,\n    those leaving less remaining capacity are preferred (Best Fit). Bins where the item\n    does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Parameter for tuning: The magnitude of the bonus for a perfect fit.\n    # This value should be significantly larger than any negative score achievable\n    # from the Best Fit component, to ensure perfect fits are always prioritized.\n    # For example, if bin capacities are typically normalized to 1.0, the base scores\n    # will range from 0 (perfect fit) down to -1.0. A bonus of 100 ensures it's always the highest.\n    PERFECT_FIT_BONUS = 100.0\n\n    # Calculate the remaining capacity after placing the item in each bin\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priorities to a very low value (-np.inf) for bins where the item cannot fit.\n    # This ensures they are never chosen.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item fits (remaining capacity is non-negative).\n    # This ensures we only consider valid placements.\n    fits_mask = remaining_after_placement >= 0\n\n    # Apply the Best Fit logic for bins where the item fits:\n    # Prioritize bins that leave less remaining capacity.\n    # A smaller remaining_after_placement value means a better fit (closer to zero).\n    # To maximize this as a priority score, we take the negative of remaining_after_placement.\n    # So, a perfect fit (remaining_after_placement = 0) gets a base priority of 0.\n    # A near-perfect fit (e.g., remaining_after_placement = 0.1) gets -0.1.\n    priorities[fits_mask] = -remaining_after_placement[fits_mask]\n\n    # Additive Incentive: Apply a significant bonus for perfect fits (bin completion).\n    # Use np.isclose for robust floating-point comparison with zero, as direct == 0 can be problematic.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0, atol=1e-9)\n\n    # The bonus is added to the base score (which would be 0 for a perfect fit).\n    # This ensures that any bin where the item perfectly fills the remaining capacity\n    # receives a score much higher than any other non-perfect fit.\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 52, in priority_v2\nnumpy._core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'\n7\n1\n"
  },
  {
    "stdout_filepath": "problem_iter9_response3.txt_stdout.txt",
    "code_path": "problem_iter9_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, extending Best Fit with a perfect-fit bonus.\n\n    This heuristic builds upon the Best Fit (BF) strategy by:\n    1. Prioritizing bins that leave less remaining capacity, following the BF principle.\n    2. Applying a substantial additive bonus to bins where the item perfectly fills the bin,\n       strongly encouraging bin completion and efficient bin utilization.\n    Bins where the item does not fit are assigned the lowest possible priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Define a significant bonus for perfect fits (when a bin is exactly filled).\n    # This value should be large enough to make a perfect fit unequivocally the best\n    # option, even compared to a very tight non-perfect fit.\n    # For typical bin packing problem scales, 1000.0 is a reasonable value.\n    # If item sizes and bin capacities can be very large, this bonus might need to be higher.\n    PERFECT_FIT_BONUS = 1000.0\n\n    # Calculate the remaining capacity after hypothetically placing the item in each bin.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on the Best Fit (BF) principle:\n    # A smaller positive `remaining_after_placement` indicates a tighter, more desirable fit.\n    # By taking the negative of this value, we transform it into a score where\n    # a smaller remaining space yields a higher (less negative, or zero) priority value.\n    priorities = -remaining_after_placement\n\n    # Set priority to negative infinity for bins where the item cannot fit\n    # (i.e., `remaining_after_placement` would be negative).\n    # This ensures these bins are never selected.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    # Apply a substantial additive bonus for bins that are perfectly filled by the item.\n    # Using `np.isclose` for float comparison to account for potential floating-point\n    # precision issues, which is generally safer than direct `== 0.0` for floats.\n    perfect_fit_mask = np.isclose(remaining_after_placement, 0.0, atol=1e-9)\n    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response4.txt_stdout.txt",
    "code_path": "problem_iter9_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which to add an item to each bin, enhancing Best Fit with a strong perfect-fit bonus.\n\n    This function calculates a priority score for each bin based on the Best Fit (BF) strategy,\n    which prefers bins that minimize the remaining capacity after placing the item. To implement\n    additive incentives, a significant bonus is applied to bins where the item perfectly fills\n    the remaining capacity, ensuring these bins are selected with the highest priority. Bins\n    where the item cannot fit are assigned the lowest possible priority (-np.inf).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after hypothetically placing the item in each bin.\n    # This forms the basis for the Best Fit strategy.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priority scores based on Best Fit:\n    # We want to minimize remaining_after_placement (make it as close to 0 as possible, but not negative).\n    # To convert this to a maximization problem (higher priority is better), we take the negative.\n    # So, a smaller positive remaining_after_placement results in a higher (less negative) priority score.\n    # A value of 0 (perfect fit) gets a base priority of 0.\n    priorities = -remaining_after_placement\n\n    # --- Additive Incentive: Strong Perfect Fit Bonus ---\n    # Define a large, tunable bonus for perfect fits. This parameter\n    # ensures that a bin where the item perfectly fills the remaining space\n    # (i.e., remaining_after_placement is effectively zero) is given\n    # an overwhelmingly higher priority than any non-perfect fit.\n    # The value should be sufficiently large to exceed the absolute range\n    # of negative scores from non-perfect fits (e.g., if max bin capacity is 1.0,\n    # priorities for non-perfect fits are in (-1.0, 0]). A bonus > 1.0 guarantees dominance.\n    PERFECT_FIT_BONUS = 1000.0  # This parameter can be tuned for specific problem scales.\n\n    # Apply the bonus where the item perfectly fits.\n    # Using np.isclose for floating-point comparison robustness.\n    priorities[np.isclose(remaining_after_placement, 0.0)] += PERFECT_FIT_BONUS\n\n    # --- Logic Validation: Handle Non-Fitting Bins ---\n    # Any bin where remaining_after_placement is negative means the item does not fit.\n    # These bins must be excluded from selection by assigning them the lowest possible priority.\n    priorities[remaining_after_placement < 0] = -np.inf\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]