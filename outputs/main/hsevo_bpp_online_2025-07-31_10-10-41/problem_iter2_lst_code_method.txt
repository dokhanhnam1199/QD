{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function embodies the principle of \"optimal packing\" by favoring bins\n    that, after accommodating the incoming item, will be left with the smallest\n    possible remaining capacity. Think of it as striving for atomic stability:\n    we seek to minimize the \"energy\" (wasted space) within each bin.\n\n    Bins that cannot accommodate the item are effectively 'forbidden' as they\n    would lead to an unstable configuration (overflow) and are assigned the\n    lowest possible priority, akin to highly unstable radioactive isotopes.\n    Among the bins where the item fits, the higher priority is given to the one\n    that achieves the tightest fit, thus optimizing the bin's fill level and\n    conserving overall space, much like a dense, well-organized crystalline structure.\n\n    Args:\n        item: Size of item to be added to the bin. This is the 'particle' we wish to place.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n                         These are our 'containers'.\n\n    Return:\n        Array of the same size as bins_remain_cap, where each value is the\n        priority score for placing the item into the corresponding bin.\n        The bin with the highest score will be selected.\n    \"\"\"\n    # Calculate the remaining space in each bin if the 'item' were placed.\n    # This is our 'post-reaction' state, revealing the 'residual energy'.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (-infinity).\n    # This ensures that bins where the item cannot fit are never chosen.\n    # It represents an impossible or highly undesirable 'reaction path'.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item *can* actually fit.\n    # These are the 'viable reaction vessels'.\n    fitting_bins_mask = potential_remaining_space >= 0\n\n    # For the bins where the item fits, we want to assign a higher priority\n    # to those that result in the smallest positive remaining space.\n    # A smaller 'potential_remaining_space' means a 'tighter' fit.\n    # To achieve this with a maximum priority score, we take the negative\n    # of the potential remaining space. This way, a smaller positive value\n    # (e.g., 0.1 remaining) yields a larger (less negative) priority (-0.1)\n    # compared to a larger positive value (e.g., 0.5 remaining) yielding (-0.5).\n    # This pushes the system towards the most 'stable' and 'packed' configuration.\n    priorities[fitting_bins_mask] = -potential_remaining_space[fitting_bins_mask]\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Isaac Newton, I view the Universe, and indeed problems such as Bin Packing,\n    as systems that strive towards an optimal state of arrangement and efficiency.\n    My heuristic for prioritizing bins is inspired by the principle of 'Best Fit',\n    which in my physical understanding, aligns with minimizing potential energy\n    or waste within a system.\n\n    Imagine each bin as a potential well, and the item as a body seeking to fall\n    into the shallowest suitable well. The most 'attractive' bin is not merely\n    one that can contain the item, but one that snugly contains it, leaving the\n    least 'void' or 'unused potential'. This tight packing minimizes the\n    'gravitational pull' for future items to gravitate towards newly opened bins,\n    thus conserving the total number of containers required.\n\n    The priority for a suitable bin is calculated as the negative of the\n    remaining capacity after the item is placed. This converts the pursuit of\n    the *minimum* wasted space into a *maximization* problem, where the bin with\n    the highest priority (i.e., the least negative remaining space) is chosen.\n    Bins that are too small to accommodate the item are given an infinitely\n    low priority, rendering them impenetrable barriers.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities for all bins. Bins that cannot fit the item\n    # are assigned a negative infinity priority, making them effectively\n    # impossible choices, akin to insurmountable obstacles.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the bins where the item can physically fit.\n    # These are the 'accessible' regions in our potential landscape.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the 'residual capacity' or 'potential void' that would remain\n    # in each fitting bin after the item is placed. Our aim is to minimize this value.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To convert the goal of 'minimizing residual capacity' into a 'maximization\n    # of priority', we take the negative of the residual capacity.\n    # A smaller positive residual capacity results in a priority score closer to zero\n    # (i.e., less negative), thus becoming a higher priority choice.\n    priorities[can_fit_mask] = -remaining_after_fit\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Nikola Tesla's ingenious design for efficient resource allocation!\n    This heuristic embodies the principle of 'Best Fit' (BF), striving for\n    the most precise and snug placement of items within our electrical\n    storage units (bins). By minimizing the remaining free capacity in a\n    chosen bin, we ensure optimal utilization, akin to minimizing energy\n    loss and maximizing power density.\n\n    The priority is determined by the 'tightness' of the fit: a smaller\n    residual space after accommodating the item indicates a higher\n    priority, favoring a 'perfect' fit, where the item precisely\n    occupies the remaining capacity. Bins where the item does not fit\n    receive the lowest possible priority, ensuring they are never chosen.\n    This precise calculation prevents wasted 'energy' (space) and ensures\n    our packing efficiency approaches the theoretical limits!\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the hypothetical remaining space if the item were placed in each bin.\n    # A smaller positive remainder signifies a 'best fit'.\n    potential_remainders = bins_remain_cap - item\n\n    # Initialize priorities. Bins where the item cannot physically fit will be given\n    # an infinitely low priority, rendering them ineligible. Tesla tolerates no\n    # impossibility in his designs!\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify all bins capable of containing the incoming item.\n    # These are the only bins worthy of consideration.\n    can_fit_mask = potential_remainders >= 0\n\n    # For those bins where the item fits, assign a priority.\n    # The priority is derived from the negative of the remaining space.\n    # This means a remainder of 0 (a perfect fit) yields a priority of 0,\n    # a remainder of 0.1 yields -0.1, and so on. When selecting the maximum\n    # priority, this naturally selects the smallest non-negative remainder.\n    # This is the essence of 'Best Fit' \u2013 maximizing snugness!\n    priorities[can_fit_mask] = -potential_remainders[can_fit_mask]\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Feynman's Quantum Bin Packing Principle:\n    # An item, like a quantum particle, seeks the \"lowest energy state\" in a bin,\n    # minimizing the \"residual vacuum\" after its placement.\n\n    # Calculate the 'potential energy' or 'gap' that would be left in each bin after placement.\n    # This 'gap' is the 'excitation energy' we want to minimize.\n    # A negative gap means the bin cannot accommodate the item; it's an 'infinite potential wall'.\n    delta = bins_remain_cap - item\n\n    # Initialize priority scores. Bins that cannot fit the item get zero priority.\n    # This ensures they are not chosen.\n    scores = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify valid bins (where the item can actually fit, i.e., delta >= 0).\n    can_fit_mask = (delta >= 0)\n\n    # For these valid bins, calculate the score.\n    # The 'attraction' or 'priority' to a bin is inversely proportional to the 'gap' left.\n    # A smaller gap means a higher priority, as it leads to a more 'compact' or 'filled' bin state.\n    # We add a tiny epsilon (1e-9) to the denominator. This serves a dual purpose:\n    # 1. Prevents division by zero if delta is exactly 0 (a perfect fit).\n    # 2. Gives perfect fits an extremely high, finite score (1 / 1e-9 = 1 Billion).\n    # This naturally makes perfect fits the highest priority, then near-perfect, and so on,\n    # embodying the principle of minimizing 'wasted' space.\n    scores[can_fit_mask] = 1.0 / (delta[can_fit_mask] + 1e-9)\n\n    # Bins where `delta < 0` (cannot fit) retain their `0.0` score from initialization,\n    # ensuring they are implicitly deprioritized.\n\n    return scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin,\n    inspired by a Best-Fit decreasing-gap strategy for optimal packing.\n\n    As a scientist, I sought to organize and utilize every resource with utmost efficiency.\n    This heuristic embodies that principle by prioritizing the bins that, after accommodating\n    the current item, will have the least remaining \"empty\" space. This minimizes the\n    \"radioactive waste\" of unused capacity in bins, leading to a tighter overall packing\n    and fewer bins utilized, much like carefully isolating a new element into the smallest\n    effective container. Bins unable to contain the item are, of course, discarded from\n    consideration.\n\n    Args:\n        item: Size of item to be added to the bin. This is the \"activity\" of our element.\n        bins_remain_cap: Array of capacities for each bin. These are our \"containers\".\n\n    Return:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        A higher score indicates a more desirable bin.\n    \"\"\"\n    # Initialize all priorities to a very low value (effectively ruling out non-viable bins).\n    # Just as an empty flask cannot contain a sample.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a mask for bins that can physically accommodate the item.\n    # We must only consider containers that are large enough.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit, calculate their score.\n    # The goal is to minimize the remaining capacity (bins_remain_cap - item) after placement.\n    # To achieve this with a \"highest score wins\" selection, we maximize the negative of\n    # the remaining capacity: -(bins_remain_cap - item), which simplifies to (item - bins_remain_cap).\n    # A perfect fit (bins_remain_cap == item) results in a score of 0.0, which is the highest\n    # possible score, signifying the most efficient use of space. All other valid fits\n    # will result in negative scores, with smaller absolute values indicating tighter fits.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin based on the Best Fit (BF) heuristic.\n\n    The Best Fit heuristic aims to minimize the remaining capacity in a bin after placing an item.\n    This strategy tries to \"fill up\" bins as much as possible, potentially allowing them to be\n    closed off sooner and thus reducing the total number of bins used.\n\n    For each bin:\n    - If the item fits, the priority is calculated as the negative of the remaining capacity\n      after placing the item. This means a smaller remaining capacity (tighter fit) results\n      in a higher (less negative) priority score. An exact fit (remaining capacity = 0)\n      will yield the highest possible score (0) among valid fits.\n    - If the item does not fit, the priority is set to negative infinity, ensuring these bins\n      are never chosen unless no other bins are available.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of the same size as bins_remain_cap with priority scores for each bin.\n        A higher score indicates a more desirable bin. Bins where the item cannot fit\n        will have a priority of -np.inf.\n    \"\"\"\n    # Initialize priorities with a very low value for all bins.\n    # We use float type to accommodate -np.inf.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins can currently accommodate the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, calculate the remaining capacity if the item is placed.\n    # We are interested in minimizing this remaining capacity.\n    # To convert minimization to maximization (for a priority function where higher is better),\n    # we take the negative of the remaining capacity.\n    # For example:\n    #   - If item=3, bin_cap=5 -> remaining=2 -> priority=-2\n    #   - If item=3, bin_cap=3 -> remaining=0 -> priority=0 (best fit, highest priority)\n    #   - If item=3, bin_cap=10 -> remaining=7 -> priority=-7\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Assign the calculated priorities to the bins that can fit the item.\n    priorities[can_fit_mask] = -remaining_capacity_after_fit\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This function implements a \"Best Fit\" heuristic for the online bin packing problem.\n    It prioritizes bins that, upon receiving the item, would leave the smallest\n    amount of remaining capacity (i.e., achieving the \"snuggest\" fit).\n    Bins where the item cannot fit are assigned an extremely low priority.\n\n    The logic is as follows:\n    1. For each bin, determine if the item can fit within its remaining capacity.\n    2. If the item fits, calculate the remaining capacity after placing the item\n       (current_bin_capacity - item_size).\n    3. The priority score for a fitting bin is the negative of this remaining capacity.\n       This ensures that a smaller positive remaining capacity (a snugger fit, or\n       even a perfect fit resulting in 0 remaining capacity) yields a higher\n       (less negative or zero) priority score.\n    4. If the item does not fit, the bin receives a priority of negative infinity,\n       ensuring it is never chosen.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities to a very low value (negative infinity).\n    # This ensures that bins where the item does not fit are never selected,\n    # as their priority will be lower than any valid fitting bin.\n    priorities = -np.ones_like(bins_remain_cap, dtype=float) * np.inf\n\n    # Find the indices of all bins where the current item can physically fit.\n    fitting_bin_indices = np.where(item <= bins_remain_cap)[0]\n\n    if fitting_bin_indices.size > 0:\n        # Calculate the remaining capacity in these fitting bins if the item were placed.\n        remaining_after_fit = bins_remain_cap[fitting_bin_indices] - item\n\n        # Assign priority scores to the fitting bins.\n        # By taking the negative of the remaining capacity, a smaller positive\n        # remaining capacity (closer to a perfect fit) results in a larger\n        # (less negative, or zero for a perfect fit) priority score.\n        priorities[fitting_bin_indices] = -remaining_after_fit\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a Best Fit-like strategy. It aims to place\n    the item in a bin such that the remaining capacity of that bin is minimized\n    after the item is placed (i.e., making the bin as 'full' as possible).\n\n    Bins that cannot accommodate the item are given a very low priority\n    (negative infinity). Among valid bins, the priority is set to the negative\n    of the space that would be left in the bin after placing the item. This way,\n    a smaller leftover space results in a higher (less negative) priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n\n    # For valid bins, calculate the remaining space if the item were placed.\n    # We want to minimize this remaining space, which means maximizing its negative value.\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n    \n    # Assign the negative of the leftover space as the priority.\n    # Example: If leftover is 0.1, priority is -0.1. If leftover is 0.5, priority is -0.5.\n    # -0.1 is greater than -0.5, so the bin with less leftover space gets higher priority.\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This implementation employs a 'Best-Fit' heuristic, prioritizing bins that,\n    after accommodating the item, will have the least remaining capacity (i.e., the\n    tightest fit). Bins where the item cannot fit are assigned a significantly\n    lower priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the space that would remain in each bin if the item were placed there.\n    remaining_after_placement = bins_remain_cap - item\n\n    # Initialize priorities with a very low value (negative infinity).\n    # This ensures that bins incapable of holding the item are never chosen\n    # when the selection mechanism picks the bin with the maximum priority.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify which bins can accommodate the item.\n    can_fit_mask = remaining_after_placement >= 0\n\n    # For bins where the item fits, assign a priority based on the Best-Fit strategy.\n    # The Best-Fit strategy aims to minimize the remaining capacity after placement.\n    # To translate this into a \"maximize priority\" system, we use the negative of\n    # the remaining capacity. A smaller positive remaining capacity (tighter fit)\n    # results in a larger (closer to zero, less negative) priority score.\n    # Example: If remaining_after_placement is 0.1, priority is -0.1.\n    # If remaining_after_placement is 0.5, priority is -0.5.\n    # -0.1 is greater than -0.5, correctly favoring the tighter fit.\n    priorities[can_fit_mask] = -remaining_after_placement[can_fit_mask]\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a Best Fit-like strategy. It aims to place\n    the item in a bin such that the remaining capacity of that bin is minimized\n    after the item is placed (i.e., making the bin as 'full' as possible).\n\n    Bins that cannot accommodate the item are given a very low priority\n    (negative infinity). Among valid bins, the priority is set to the negative\n    of the space that would be left in the bin after placing the item. This way,\n    a smaller leftover space results in a higher (less negative) priority score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins that can accommodate the item\n    valid_bins_mask = bins_remain_cap >= item\n\n    # For valid bins, calculate the remaining space if the item were placed.\n    # We want to minimize this remaining space, which means maximizing its negative value.\n    leftover_space_if_placed = bins_remain_cap[valid_bins_mask] - item\n    \n    # Assign the negative of the leftover space as the priority.\n    # Example: If leftover is 0.1, priority is -0.1. If leftover is 0.5, priority is -0.5.\n    # -0.1 is greater than -0.5, so the bin with less leftover space gets higher priority.\n    priorities[valid_bins_mask] = -leftover_space_if_placed\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    \n    Inspired by quantum phenomena, this heuristic views the packing problem \n    as an optimization of \"potential energy.\" Bins that offer a \"snug fit\" \n    for the item, leaving minimal wasted space, are highly preferred. \n    A perfect fit represents the lowest potential energy state and thus \n    the highest probability (priority) for the item to settle there.\n\n    Specifically, the priority is calculated using an exponential decay function:\n    Priority = exp(-(remaining_capacity - item_size)) for bins where the item fits.\n    This means:\n    - A perfect fit (remaining_capacity - item_size = 0) results in a priority of 1.0 (e^0).\n    - As the \"wasted space\" (remaining_capacity - item_size) increases, the priority \n      decreases exponentially towards zero.\n    - Bins where the item does not fit receive a priority of negative infinity.\n\n    This \"fuzzy Best Fit\" approach smoothly quantifies the desirability of each bin, \n    preferring efficiency while still distinguishing between different levels of \"goodness.\"\n\n    Args:\n        item: Size of item to be added to the bin. Assumed to be a positive float.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Items in Bin Packing are typically positive. If a non-positive item were given,\n    # it defies the problem context. Assign lowest priority to all bins.\n    if item <= 0:\n        return np.full_like(bins_remain_cap, -np.inf)\n\n    # Initialize priorities to a very low value, representing \"cannot fit\" or \"undesirable\".\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item *can* fit\n    fits_mask = bins_remain_cap >= item\n\n    # Calculate the 'wasted space' if the item were placed in each fitting bin.\n    # This is the difference: (bin_remaining_capacity - item_size).\n    # We want to minimize this difference for higher priority.\n    wasted_space_for_fits = bins_remain_cap[fits_mask] - item\n\n    # Apply the exponential priority function.\n    # We use -wasted_space to ensure smaller wasted space leads to higher exp value (closer to 1.0).\n    # exp(0) = 1.0 (perfect fit), exp(-small_positive) < 1.0 (snug fit), exp(-large_positive) ~ 0 (loose fit).\n    priorities[fits_mask] = np.exp(-wasted_space_for_fits)\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}