```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin based on the Best Fit (BF) heuristic.

    The Best Fit heuristic aims to minimize the remaining capacity in a bin after placing an item.
    This strategy tries to "fill up" bins as much as possible, potentially allowing them to be
    closed off sooner and thus reducing the total number of bins used.

    For each bin:
    - If the item fits, the priority is calculated as the negative of the remaining capacity
      after placing the item. This means a smaller remaining capacity (tighter fit) results
      in a higher (less negative) priority score. An exact fit (remaining capacity = 0)
      will yield the highest possible score (0) among valid fits.
    - If the item does not fit, the priority is set to negative infinity, ensuring these bins
      are never chosen unless no other bins are available.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of current remaining capacities for each bin.

    Return:
        Array of the same size as bins_remain_cap with priority scores for each bin.
        A higher score indicates a more desirable bin. Bins where the item cannot fit
        will have a priority of -np.inf.
    """
    # Initialize priorities with a very low value for all bins.
    # We use float type to accommodate -np.inf.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Determine which bins can currently accommodate the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins where the item fits, calculate the remaining capacity if the item is placed.
    # We are interested in minimizing this remaining capacity.
    # To convert minimization to maximization (for a priority function where higher is better),
    # we take the negative of the remaining capacity.
    # For example:
    #   - If item=3, bin_cap=5 -> remaining=2 -> priority=-2
    #   - If item=3, bin_cap=3 -> remaining=0 -> priority=0 (best fit, highest priority)
    #   - If item=3, bin_cap=10 -> remaining=7 -> priority=-7
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item

    # Assign the calculated priorities to the bins that can fit the item.
    priorities[can_fit_mask] = -remaining_capacity_after_fit

    return priorities
```
