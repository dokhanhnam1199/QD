```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for each bin using an adaptive Best Fit strategy with a dynamic
    preference for consolidating smaller items into already fuller bins.

    This heuristic attempts to balance the Best Fit principle (minimizing wasted space per item)
    with a strategy to reduce fragmentation, especially for smaller items. For small items,
    it slightly prioritizes bins that are already more full (have less remaining capacity),
    aiming to 'finish' those bins or prevent creation of many small gaps across new bins.
    For larger items, it reverts closer to a pure Best Fit strategy.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Assumption for Bin Capacity:
    # In many online Bin Packing problems, bin capacities are normalized, often to 1.0.
    # If the problem context implies a different fixed bin capacity, this value should be adjusted.
    BIN_CAPACITY = 1.0

    # Hyperparameter K:
    # This constant controls the strength of the adaptive preference for fuller bins.
    # A value of K=0 makes this function equivalent to the original Best Fit (priority_v1).
    # Increasing K (e.g., from 0.1 to 1.0) intensifies the preference for fuller bins
    # for smaller items. This value might need tuning for specific problem instances.
    K = 0.5 

    # Calculate remaining capacity after placing the item in each bin.
    # This is crucial for identifying bins where the item fits.
    remaining_after_placement = bins_remain_cap - item

    # --- Core Priority Calculation ---
    # The base of the priority score is (item - bins_remain_cap), which is equivalent to
    # the negative of the remaining space after placement. This component drives the
    # Best Fit behavior: higher score for less remaining space (closer to perfect fit).

    # Adaptive Factor:
    # This factor dynamically adjusts the influence of the bin's current fullness based on the item's size.
    # - For smaller items (item << BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 1.0.
    #   This means the adaptive_factor is larger, giving more weight to the 'bins_remain_cap' term.
    #   The effect: a stronger preference for putting small items into bins that are already more full.
    # - For larger items (item approaches BIN_CAPACITY), (1.0 - item / BIN_CAPACITY) is close to 0.0.
    #   This means the adaptive_factor is smaller, reducing the weight of the 'bins_remain_cap' term.
    #   The effect: the priority calculation becomes very similar to pure Best Fit.
    
    # Ensure BIN_CAPACITY is not zero to prevent division by zero, though in BPP it's always positive.
    adaptive_factor = K * (1.0 - item / BIN_CAPACITY) if BIN_CAPACITY > 0 else 0.0
    
    # The combined priority score:
    # The first part (item - bins_remain_cap) is the standard Best Fit component.
    # The second part (- adaptive_factor * bins_remain_cap) applies a penalty that is:
    #   1. Larger (more negative) for bins with more remaining capacity (i.e., less full bins).
    #   2. Scaled by 'adaptive_factor', meaning this penalty is more significant for smaller items.
    # This synergistically pushes smaller items into already fuller bins while maintaining Best Fit
    # for larger items.
    priorities = (item - bins_remain_cap) - adaptive_factor * bins_remain_cap

    # --- Handling Invalid Placements ---
    # Crucially, any bin where the item cannot fit (resulting in negative remaining_after_placement)
    # must be assigned the lowest possible priority (-np.inf) to ensure it is never chosen.
    priorities[remaining_after_placement < 0] = -np.inf

    return priorities
```
