```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority for placing an item into bins, based on a "Best-Fit" strategy
    with an intuitive score scaling.

    This heuristic combines the robustness of Best-Fit (prioritizing tightest fits)
    from `priority_v0` with the clear scoring goal of `priority_v1` (perfect fit = highest score).
    It assigns a perfect fit a priority of 1.0, with scores decreasing linearly
    as 'wasted space' increases. Bins incapable of holding the item receive a
    significantly low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value. This ensures bins where the item
    # cannot fit are never selected.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate the 'wasted space' (or remaining capacity after placement)
    # for each bin if the item were placed there.
    # A negative 'wasted_space' indicates the item does not fit.
    wasted_space = bins_remain_cap - item

    # Create a mask to identify only those bins where the item can fit.
    can_fit_mask = wasted_space >= 0

    # For bins that can accommodate the item, assign a priority score.
    # The 'Best-Fit' principle aims to minimize 'wasted_space'.
    # To align with the goal of 'highest priority for perfect fit' (like exp(0)=1 in v1),
    # we use a linear transformation: 1.0 - wasted_space.
    # This means:
    # - If wasted_space is 0 (perfect fit), priority is 1.0 (highest).
    # - As wasted_space increases, priority linearly decreases from 1.0.
    # This preserves the relative ordering of bins as in 'priority_v0' (Best-Fit)
    # but scales the scores for more intuitive interpretation.
    priorities[can_fit_mask] = 1.0 - wasted_space[can_fit_mask]

    return priorities
```
