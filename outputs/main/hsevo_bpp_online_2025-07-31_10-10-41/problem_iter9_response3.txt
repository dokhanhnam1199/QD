```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, extending Best Fit with a perfect-fit bonus.

    This heuristic builds upon the Best Fit (BF) strategy by:
    1. Prioritizing bins that leave less remaining capacity, following the BF principle.
    2. Applying a substantial additive bonus to bins where the item perfectly fills the bin,
       strongly encouraging bin completion and efficient bin utilization.
    Bins where the item does not fit are assigned the lowest possible priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Define a significant bonus for perfect fits (when a bin is exactly filled).
    # This value should be large enough to make a perfect fit unequivocally the best
    # option, even compared to a very tight non-perfect fit.
    # For typical bin packing problem scales, 1000.0 is a reasonable value.
    # If item sizes and bin capacities can be very large, this bonus might need to be higher.
    PERFECT_FIT_BONUS = 1000.0

    # Calculate the remaining capacity after hypothetically placing the item in each bin.
    remaining_after_placement = bins_remain_cap - item

    # Initialize priority scores based on the Best Fit (BF) principle:
    # A smaller positive `remaining_after_placement` indicates a tighter, more desirable fit.
    # By taking the negative of this value, we transform it into a score where
    # a smaller remaining space yields a higher (less negative, or zero) priority value.
    priorities = -remaining_after_placement

    # Set priority to negative infinity for bins where the item cannot fit
    # (i.e., `remaining_after_placement` would be negative).
    # This ensures these bins are never selected.
    priorities[remaining_after_placement < 0] = -np.inf

    # Apply a substantial additive bonus for bins that are perfectly filled by the item.
    # Using `np.isclose` for float comparison to account for potential floating-point
    # precision issues, which is generally safer than direct `== 0.0` for floats.
    perfect_fit_mask = np.isclose(remaining_after_placement, 0.0, atol=1e-9)
    priorities[perfect_fit_mask] += PERFECT_FIT_BONUS

    return priorities
```
