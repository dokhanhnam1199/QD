```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add an item to each bin,
    inspired by the principles of optimal resource utilization and efficiency.
    This heuristic prioritizes the "Best Fit" strategy, seeking to leave the
    smallest possible remainder in a bin after placement, akin to precisely
    filling a flask with an experimental sample. Bins that cannot accommodate
    the item are heavily penalized.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score for each bin.
        Higher scores indicate a more desirable bin.
    """
    # Calculate the remaining capacity if the item were placed in each bin.
    # This represents the "unfilled" portion or "waste" after placement.
    hypothetical_leftover = bins_remain_cap - item

    # Initialize a priority score array.
    # We use float to accommodate negative infinity.
    priority_scores = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item can fit (i.e., leftover capacity would be non-negative).
    can_fit_mask = hypothetical_leftover >= 0

    # For bins that can fit, we want to maximize the 'snugness' of the fit.
    # Snugness means minimizing the `hypothetical_leftover`.
    # Therefore, we assign priority as the negative of the leftover capacity.
    # A smaller positive leftover (more snug fit) results in a larger (less negative)
    # priority score, making it more desirable.
    priority_scores[can_fit_mask] = -hypothetical_leftover[can_fit_mask]

    # For bins that cannot accommodate the item, assign an extremely low priority.
    # This ensures they are never chosen unless no other option exists (which
    # should ideally not happen if a new bin can always be opened).
    priority_scores[~can_fit_mask] = -np.inf

    return priority_scores
```
