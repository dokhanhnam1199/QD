```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's preference for tight fits with a normalized Fill Ratio bonus.
    Prioritizes bins that fit the item snugly and are already substantially full,
    with adaptive weighting for robustness.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    eligible_bins_caps = bins_remain_cap[fittable_bins_mask]

    # Component 1: Best Fit (tightness) - Inverse of remaining capacity after packing
    # Higher score for smaller leftover space.
    best_fit_score = 1.0 / (eligible_bins_caps - item + 1e-9)

    # Component 2: Fill Ratio (bin fullness) - Normalized inverse of remaining capacity
    # This component is derived from Heuristic 9's approach to normalize based on
    # maximum initial capacity if it were known. Here, we use a general
    # penalty for large remaining capacities by inverting the capacity.
    # Adding a small constant to avoid zero and ensure all bins have some base priority.
    fill_ratio_score = 1.0 / (eligible_bins_caps + 1.0) # Penalize large remaining space more

    # Adaptive Weighting: Use item size to adjust the importance of fill ratio.
    # Larger items might benefit more from prioritizing bins that are already fuller,
    # while smaller items might be more sensitive to the tightness of the fit.
    # This is a simple heuristic: a higher weight for fill ratio for larger items.
    # Let's assume a normalized item size for this scaling (e.g., item / max_possible_item_size).
    # For simplicity, we'll use a direct relationship with item size, capped.
    fill_ratio_weight = min(item * 2.0, 1.5) # Weight for fill ratio, capped at 1.5

    # Combine scores: Weighted sum for better control and interpretability.
    # This offers more granular control than pure multiplicative combinations.
    combined_scores = best_fit_score + fill_ratio_weight * fill_ratio_score

    # Assign combined scores to the priorities array for eligible bins.
    priorities[fittable_bins_mask] = combined_scores

    # Normalize priorities to the range [0, 1] for consistent comparison.
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = priorities / max_priority

    return priorities
```
