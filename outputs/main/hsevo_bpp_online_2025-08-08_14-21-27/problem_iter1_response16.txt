```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using sigmoid fit score.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bin_capacities = bins_remain_cap - item
    valid_bins_mask = bin_capacities >= 0

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    remaining_capacities_valid = bins_remain_cap[valid_bins_mask]
    max_capacity = np.max(bins_remain_cap) # Consider the maximum possible capacity to normalize

    if max_capacity == 0: # Avoid division by zero if all bins were full and no items could fit
        return priorities

    # Sigmoid function to map remaining capacity to a priority score.
    # We want bins that are nearly full (low remaining capacity) to have higher priority.
    # A larger negative slope will make the transition sharper.
    slope = -5.0 # Adjust slope for desired sharpness of the sigmoid
    # Shift the sigmoid so that remaining capacity of 0 (bin is exactly full) gets a high score
    # and large remaining capacity gets a low score.
    # shifted_remaining_capacity = (remaining_capacities_valid / max_capacity) - 1.0
    shifted_remaining_capacity = remaining_capacities_valid / max_capacity

    priorities[valid_bins_mask] = 1 / (1 + np.exp(slope * shifted_remaining_capacity))

    return priorities
```
