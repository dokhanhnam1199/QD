```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by favoring those with least remaining capacity after packing,
    while also considering the likelihood of future fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Calculate the remaining capacity if the item is placed in each bin
    potential_remaining_cap = bins_remain_cap - item
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # For bins that can fit the item, assign priority based on remaining capacity
    # Higher priority for bins with less remaining capacity (tightest fit)
    # Add a small epsilon to avoid division by zero
    priorities[can_fit_mask] = 1.0 / (potential_remaining_cap[can_fit_mask] + 1e-9)
    
    # Further adjust priorities: bins that leave more remaining capacity
    # after packing might be preferred if they are large enough to fit
    # future, potentially larger items. This is a simple form of adaptive
    # prioritization, favoring slightly less tight fits that retain more 'room'.
    # We multiply by the potential remaining capacity itself.
    # This is a heuristic that balances tight fits with future flexibility.
    priorities[can_fit_mask] *= potential_remaining_cap[can_fit_mask]

    # Normalize priorities to avoid extremely large values and ensure a better distribution
    # This makes the heuristic less sensitive to extreme differences in remaining capacity.
    if np.any(priorities):
        priorities /= np.max(priorities)
        
    return priorities
```
