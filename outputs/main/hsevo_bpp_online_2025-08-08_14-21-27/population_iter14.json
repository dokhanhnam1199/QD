[
  {
    "stdout_filepath": "problem_iter14_response0.txt_stdout.txt",
    "code_path": "problem_iter14_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a Fill Ratio that penalizes large remaining capacities.\n    Prioritizes bins that snugly fit the item and are already substantially full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    eligible_bins_caps = bins_remain_cap[fittable_bins_mask]\n\n    # Score 1: Best Fit (inverse of remaining capacity after packing)\n    # Higher score for smaller remaining capacity. Adding epsilon for numerical stability.\n    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)\n\n    # Score 2: Fill Ratio (inversely proportional to remaining capacity)\n    # Prioritizes bins that are more full. This is a refinement to penalize bins\n    # with a lot of leftover space more strongly than a simple ratio.\n    fill_ratio_scores = 1.0 / (eligible_bins_caps + 1e-9)\n\n    # Combine scores multiplicatively. This emphasizes bins that are good in both aspects.\n    # The addition of 1.0 in the fill_ratio_scores is removed to directly use the inverse\n    # of remaining capacity for a stronger penalty on larger remaining spaces.\n    combined_scores = best_fit_scores * fill_ratio_scores\n\n    # Assign combined scores to the priorities array for eligible bins.\n    priorities[fittable_bins_mask] = combined_scores\n\n    # Normalize priorities to the range [0, 1] for consistent comparison.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and Fullness Ratio with an adaptive bonus,\n    prioritizing bins that offer a tight fit and are already well-utilized.\n    This aims for efficient packing by balancing immediate fit with future bin usage.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n    \n    # Best Fit Score: Inverted remaining capacity after fit. Tighter fits get higher scores.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n    \n    # Fullness Score: (Bin Capacity - Remaining Capacity) / Bin Capacity. Higher for fuller bins.\n    # Assuming a bin capacity of 1.0 for normalization.\n    bin_capacity = 1.0\n    current_fill_ratio = (bin_capacity - fittable_bins_remain_cap) / bin_capacity\n    fill_ratio_score = current_fill_ratio\n\n    # Adaptive Bonus: Penalizes bins with large remaining capacity more heavily.\n    # This encourages using bins that would leave smaller unusable gaps.\n    # A lower remaining capacity (higher fill ratio) leads to a smaller (less negative) adaptive bonus.\n    adaptive_bonus = -np.log(fittable_bins_remain_cap + 1e-9) * 0.5\n\n    # Combine scores: Multiplicatively combine Best Fit and Fill Ratio,\n    # then add the adaptive bonus. This prioritizes tight fits and full bins,\n    # with an adjustment for leftover space.\n    combined_scores = best_fit_scores * (1 + fill_ratio_score) + adaptive_bonus\n    \n    # Ensure that even if combined_scores are very low or negative, a small positive priority exists\n    # for fittable bins, mainly driven by the best_fit_scores component.\n    # This prevents entirely eliminating bins that are only a decent fit.\n    priorities[fittable_bins_mask] = np.maximum(combined_scores, best_fit_scores * 0.1)\n\n    # Normalize priorities to a [0, 1] range for consistent behavior.\n    max_priority = np.max(priorities)\n    if max_priority > 1e-9:\n        priorities[fittable_bins_mask] /= max_priority\n    else:\n        # Fallback for cases where all calculated priorities are near zero.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response2.txt_stdout.txt",
    "code_path": "problem_iter14_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a modified Fill Ratio (item/bin_capacity).\n    Prioritizes bins that fit the item snugly and are already substantially full.\n    This aims for denser packing by favoring bins that are both a good fit and well-utilized.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the current item.\n    eligible_bins_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return all zeros.\n    if not np.any(eligible_bins_mask):\n        return priorities\n\n    # Get the remaining capacities of only the eligible bins.\n    eligible_bins_caps = bins_remain_cap[eligible_bins_mask]\n\n    # --- Best Fit Component ---\n    # This component prioritizes bins where the item leaves the least remaining capacity.\n    # A smaller remaining capacity after packing (eligible_bins_caps - item) results in a higher score.\n    # Adding a small epsilon (1e-9) prevents division by zero for bins that will be exactly full.\n    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)\n\n    # --- Fill Ratio Component ---\n    # This component prioritizes bins that are already more full, relative to the item's size.\n    # A higher item size relative to the bin's remaining capacity indicates a better \"fill\".\n    # This encourages using bins that have already been utilized to a greater extent.\n    fill_ratio_scores = item / (eligible_bins_caps + 1e-9)\n\n    # --- Combined Score ---\n    # Multiply the Best Fit and Fill Ratio scores. This multiplicative approach\n    # ensures that bins excelling in BOTH criteria receive disproportionately higher scores.\n    # Bins that are a tight fit AND are already quite full are strongly preferred.\n    combined_scores = best_fit_scores * fill_ratio_scores\n\n    # Assign the calculated combined scores back to the priorities array for the eligible bins.\n    priorities[eligible_bins_mask] = combined_scores\n\n    # Normalize priorities to the range [0, 1]. This makes scores comparable\n    # across different item/bin configurations and helps in selecting the top bin.\n    # Avoid division by zero if all priorities are zero (which shouldn't happen here\n    # if eligible_bins_mask is true, but good practice).\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response3.txt_stdout.txt",
    "code_path": "problem_iter14_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's preference for tight fits with a multiplicative\n    fullness bonus, prioritizing bins that are nearly full and can\n    accommodate the item with minimal remaining space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit component: Prioritize bins with smallest remaining capacity after fitting\n    # Adding a small epsilon to avoid division by zero if remaining capacity is exactly item size\n    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Fullness component: Prioritize bins that are already more full.\n    # Assuming a normalized bin capacity of 1.0. If capacity varies, this needs adjustment.\n    # Higher fullness means smaller remaining capacity, so we want to penalize larger remaining capacities.\n    # A simple way is to use the inverse of remaining capacity, but to avoid zero for empty bins\n    # and to make it more comparable to best_fit, let's use a score derived from 1 - (remaining_cap / capacity)\n    # where capacity is assumed to be 1.0.\n    fullness_score = 1.0 - fittable_bins_remain_cap # Higher score for smaller remaining capacity\n\n    # Combine scores multiplicatively: Boosts bins that are both tight fits and more full.\n    # A small constant is added to fullness_score to prevent it from being zero,\n    # ensuring that even less full bins contribute to the multiplicative factor.\n    combined_scores = best_fit_score * (fullness_score + 0.5) # Adding a small boost to less full bins\n\n    priorities[fittable_bins_mask] = combined_scores\n\n    # Normalize priorities for fittable bins to a [0, 1] range.\n    max_priority = np.max(priorities[fittable_bins_mask])\n    if max_priority > 0:\n        priorities[fittable_bins_mask] /= max_priority\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response4.txt_stdout.txt",
    "code_path": "problem_iter14_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness and a logarithmic fullness bonus multiplicatively.\n    This prioritizes bins that are already quite full and can snugly fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins with minimal remaining capacity after fitting.\n    # Adding epsilon for numerical stability.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Bonus: A bonus reflecting how full the bin is *before* fitting the item.\n    # Uses a logarithmic scale to give diminishing returns for very full bins,\n    # but still rewards moderately full bins. Add 1 to avoid log(0).\n    # We use the *inverse* of remaining capacity to represent fullness.\n    fullness_bonus = np.log1p(1.0 / (fittable_bins_remain_cap + 1e-6))\n\n    # Combined Score: Multiplicatively combine Best Fit and Fullness Bonus.\n    # This prioritizes bins that are both a good fit (low residual space)\n    # and are already quite full.\n    combined_scores = best_fit_scores * (1.0 + fullness_bonus * 0.5) # Adjust weight for fullness bonus\n\n    # Normalize priorities to a [0, 1] range.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response5.txt_stdout.txt",
    "code_path": "problem_iter14_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a multiplicative Fill Ratio bonus,\n    prioritizing bins that are both a good fit and already relatively full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Inverse of the remaining capacity after packing. Higher is better.\n    # Adding epsilon to avoid division by zero.\n    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Fill Ratio Score: Represents how full the bin *was* before this item.\n    # A higher fill ratio (lower remaining capacity) is generally better for consolidation.\n    # We use the inverse of the remaining capacity (plus epsilon) as a proxy.\n    fill_ratio_score = 1.0 / (fittable_bins_remain_cap + 1e-9)\n\n    # Combine multiplicatively: Prioritize bins that are both a tight fit (high best_fit_score)\n    # and were already quite full (high fill_ratio_score).\n    combined_scores = best_fit_score * fill_ratio_score\n\n    # Normalize scores to the range [0, 1] for consistent priority assignment.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response6.txt_stdout.txt",
    "code_path": "problem_iter14_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's preference for tight fits with a refined 'fill ratio' bonus,\n    prioritizing bins that are both a good fit and already significantly utilized.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins that leave less remaining capacity.\n    # Add epsilon to avoid division by zero and prioritize tighter fits.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Refined Fill Ratio Bonus: Prioritizes bins that are more full.\n    # This is calculated as 1 - (remaining_capacity / max_possible_capacity),\n    # which directly indicates how much space is already occupied.\n    # We consider the initial maximum remaining capacity to establish a baseline for \"fullness\".\n    max_initial_remain_cap = np.max(bins_remain_cap)\n    fill_ratio_bonus = 1.0 - (fittable_bins_remain_cap / (max_initial_remain_cap + 1e-9))\n\n    # Combine: Use a multiplicative approach for Best Fit and Fill Ratio.\n    # This aims to reward bins that are *both* a tight fit and already full.\n    # A small constant is added to the fill ratio bonus to avoid zeroing out\n    # the score if a bin is completely empty but a tight fit.\n    combined_scores = best_fit_scores * (fill_ratio_bonus + 0.1)\n\n    # Normalize priorities to a [0, 1] range.\n    if np.max(combined_scores) > 1e-9:\n        priorities[fittable_bins_mask] = np.clip(combined_scores / np.max(combined_scores), 0, 1)\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response7.txt_stdout.txt",
    "code_path": "problem_iter14_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and a normalized \"fullness\" score multiplicatively,\n    prioritizing bins that are both a tight fit and already quite full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Inverse of remaining capacity after fitting. Smaller remaining capacity is better.\n    # Adding a small epsilon to prevent division by zero.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Fullness Score: Ratio of capacity already used. Higher is better.\n    # Normalized by the maximum remaining capacity among fittable bins to gauge how \"full\" a bin is relative to others.\n    # A bin with less initial remaining capacity is considered fuller.\n    max_initial_remain_cap = np.max(fittable_bins_remain_cap)\n    # Handle the case where max_initial_remain_cap is very small or zero to avoid division by zero.\n    if max_initial_remain_cap < 1e-9:\n        fullness_scores = np.ones_like(fittable_bins_remain_cap) # All bins are equally \"full\" if none have significant remaining capacity\n    else:\n        fullness_scores = 1.0 - (fittable_bins_remain_cap / max_initial_remain_cap)\n\n    # Combine scores multiplicatively. This rewards bins that are both a good fit and already full.\n    # Add a small constant to fullness scores to prevent the combined score from becoming zero easily\n    # if Best Fit score is high but Fullness is low (or vice-versa).\n    combined_scores = best_fit_scores * (fullness_scores + 0.1)\n\n    # Normalize the combined scores to be between 0 and 1 for consistent priority representation.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n    else:\n        # If all combined scores are near zero (e.g., all bins are large and empty),\n        # assign a uniform small priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 19.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response8.txt_stdout.txt",
    "code_path": "problem_iter14_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with an adaptive penalty for leftover space,\n    prioritizing tight fits while discouraging large wasted capacities.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit: Higher score for bins with less remaining capacity after fitting.\n    # Add a small epsilon to avoid division by zero and to ensure non-zero scores for perfect fits.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Adaptive Penalty: Penalize leaving large gaps using a logarithmic function.\n    # Logarithm of (1 + remaining capacity after fit) smooths the penalty,\n    # giving diminishing returns to larger remaining spaces.\n    # We invert this to reward smaller leftover spaces.\n    adaptive_penalty = np.log1p(fittable_bins_remain_cap - item + 1)\n\n    # Combine: A weighted sum. Best Fit is the primary driver,\n    # with the adaptive penalty acting as a penalty for suboptimal fits (large remaining capacity).\n    # The weight for adaptive_penalty is negative to penalize.\n    combined_scores = (best_fit_scores * 1.0) - (adaptive_penalty * 0.3)\n\n    # Normalize scores to the [0, 1] range.\n    # If all scores are very close to zero or negative, assign a small positive value\n    # to ensure fittable bins have some priority.\n    max_score = np.max(combined_scores)\n    min_score = np.min(combined_scores)\n\n    if max_score - min_score > 1e-9:\n        priorities[fittable_bins_mask] = np.clip((combined_scores - min_score) / (max_score - min_score), 0, 1)\n    else:\n        # If all calculated scores are effectively the same (e.g., all perfect fits or all similarly poor fits)\n        # assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.5\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response9.txt_stdout.txt",
    "code_path": "problem_iter14_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and a logarithmic fill ratio bonus multiplicatively.\n    Prioritizes bins that are a tight fit and already quite full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins with minimal remaining capacity after fitting.\n    # Add epsilon for numerical stability and to avoid division by zero.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Fullness Bonus: Logarithmic scale of how full the bin is *before* fitting.\n    # Use log1p to handle remaining capacity of 0 gracefully.\n    # This term is inversely related to remaining capacity.\n    fullness_bonus = np.log1p(1.0 / (fittable_bins_remain_cap + 1e-9))\n\n    # Combine scores multiplicatively: Emphasizes bins that are both a good fit and already full.\n    combined_scores = best_fit_scores * (1.0 + fullness_bonus * 0.5) # Adjust multiplier for balance\n\n    # Normalize priorities to a [0, 1] range for consistent comparison.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n    else:\n        # Fallback: if all combined scores are near zero, assign uniform small priority.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]