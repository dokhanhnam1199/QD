```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a multiplicative bonus for bin fullness, 
    aiming for a more aggressive filling strategy.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]

    # Best Fit Score: Prefer bins that leave minimal remaining capacity after fitting the item.
    # We use 1 / (remaining_capacity - item + epsilon) so smaller remaining capacity yields higher score.
    # Adding 1 to the denominator to avoid division by zero and to give a base score.
    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1.0)

    # Fullness Ratio: Measure how full a bin is *after* the item is placed.
    # A higher ratio means the bin is more full, which is desirable.
    # We calculate this based on the remaining capacity *before* placing the item,
    # assuming a standard bin capacity, let's say 1.0 for normalization.
    # If bin capacity is variable, it should be passed as an argument.
    # For now, assuming a nominal capacity of 1.0 for calculating fill ratio's component.
    # A more accurate fullness would consider the total capacity of the bin.
    # Let's assume a fixed bin capacity of 1.0 for simplicity in this example,
    # or a normalized capacity.
    # A better approach might be to use the *initial* remaining capacity if available,
    # or the capacity that was left *before* the item was placed.
    # Here, we use the remaining capacity *after* placing the item to represent how full it *becomes*.
    # A higher value of (1.0 - (fittable_bins_remain_cap - item)) / 1.0 represents a fuller bin.
    # To avoid issues with different bin capacities, let's use the "space left before fitting"
    # divided by a reference capacity (e.g., total capacity of the largest bin encountered so far,
    # or a fixed value like 1.0 if capacities are normalized).
    # For simplicity, we'll consider the "space available" as a proxy for fullness if we don't
    # have total capacity. The more space *was* available, the less "full" the bin was initially.
    # So, a smaller `fittable_bins_remain_cap` means the bin was fuller *before* fitting.
    # Let's aim for a metric that rewards bins that are *already* fuller.
    # A simple proxy for fullness (higher is better) is the inverse of remaining capacity.
    # However, we already have best_fit which uses this.
    # Let's redefine fullness as the ratio of *space used* to *total capacity*.
    # If we assume total capacity is 1.0 for all bins for simplicity:
    # Fullness = (1.0 - fittable_bins_remain_cap) / 1.0
    # But this would penalize bins with large initial capacity even if they are mostly full.
    # A better approach: The percentage of capacity *already taken*.
    # Let's use the complement of the remaining capacity *before* fitting,
    # normalized by the maximum possible remaining capacity (which is the maximum capacity if we knew it).
    # Without knowing total capacity, we can use a surrogate:
    # How "close" is the bin to being full?
    # Higher score if `fittable_bins_remain_cap` is small (relative to other fittable bins).
    # This is similar to Best Fit, so let's ensure it's distinct.

    # Let's try a multiplicative approach. We want to maximize both "best fit" and "fullness".
    # Fullness metric: percentage of capacity *already filled*.
    # If we don't know total capacity, we can use the available capacity as a base.
    # Consider bins that are already "mostly full".
    # A bin that has `C` capacity and `r` remaining capacity, has `C-r` filled.
    # Fill ratio = (C-r) / C = 1 - r/C.
    # To make it usable without C, we can normalize `r` by the maximum possible `r` among fittable bins.
    # `fullness_score` = 1 - (fittable_bins_remain_cap / max(fittable_bins_remain_cap))
    # This rewards bins that had less remaining capacity *before* fitting.
    max_initial_remain_cap = np.max(fittable_bins_remain_cap)
    fullness_scores = 1.0 - (fittable_bins_remain_cap / (max_initial_remain_cap + 1e-6))

    # Combine: Multiplicative interaction between Best Fit and Fullness.
    # This encourages bins that are both a good fit and already relatively full.
    # Add a small epsilon to prevent multiplication by zero.
    combined_scores = best_fit_scores * (fullness_scores + 0.1) # Adding 0.1 to ensure scores are positive and not zeroed out easily

    # Normalize priorities to a [0, 1] range.
    max_score = np.max(combined_scores)
    if max_score > 1e-9:
        priorities[fittable_bins_mask] = combined_scores / max_score
    else:
        # If all scores are near zero, assign a small uniform priority to fittable bins.
        priorities[fittable_bins_mask] = 0.1

    return priorities
```
