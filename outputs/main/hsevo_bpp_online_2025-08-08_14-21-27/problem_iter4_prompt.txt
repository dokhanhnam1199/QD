{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive Priority: Combines 'Best Fit' with an 'Almost Full' bias.\n    Prioritizes bins that leave minimal space, favoring near-perfect fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Calculate remaining capacity for bins that can fit the item\n    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # Heuristic: Prioritize bins that result in less remaining capacity.\n    # This is a \"Best Fit\" like strategy.\n    # Using 1 / (1 + residual_capacity) to give higher scores to smaller residuals.\n    # A residual capacity of 0 gets a score of 1. A large residual gets a score close to 0.\n    priorities[can_fit_mask] = 1.0 / (1.0 + remaining_capacity_after_fit)\n    \n    # Additional bias: Slightly boost priority for bins that become nearly full (e.g., residual < 0.1 * bin_capacity)\n    # This \"almost full\" bias encourages tighter packing and potentially better overall utilization.\n    # We'll apply a small multiplier to these bins.\n    original_bin_capacities = bins_remain_cap[can_fit_mask] # Assuming we know original capacities or can infer\n    # For this example, let's assume a fixed bin capacity, say 1.0, for demonstration\n    # In a real scenario, bin capacity would be a parameter or known context.\n    # If bin_capacity is not fixed, this bias needs adjustment or a different approach.\n    # For simplicity here, let's assume a standard bin capacity is known or implied.\n    # Let's use a placeholder if bin capacity is not explicitly available.\n    # If bin_capacity is available, it would be:\n    # almost_full_mask = remaining_capacity_after_fit < (bin_capacity * 0.1) \n    \n    # Without explicit bin capacity, we'll use a small absolute residual as a proxy for 'almost full'\n    # For example, if the remaining capacity is very small (e.g., less than 0.05)\n    small_residual_bias_mask = remaining_capacity_after_fit < 0.05\n    priorities[can_fit_mask][small_residual_bias_mask] *= 1.1 # Apply a small boost\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}