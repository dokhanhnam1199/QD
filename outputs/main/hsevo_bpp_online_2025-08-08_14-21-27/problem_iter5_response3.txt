```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive Best-Fit: Combines 'Best Fit' proximity with a bonus for bins that
    leave a small but not zero remainder, promoting tighter packing and future flexibility.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate remaining capacity after fitting the item
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Base priority: Inverse of remaining capacity (Best Fit)
    # Higher score for smaller remaining capacity
    # Add a small epsilon to prevent division by zero for perfect fits
    base_priority = 1.0 / (remaining_capacity_after_fit + 1e-9)
    
    # Adaptive bonus: Reward bins that leave a small, positive remainder.
    # This encourages tighter packing while leaving a tiny bit of space,
    # which can be beneficial for subsequent items.
    # We use a scaled inverse of the remaining capacity for this bonus.
    # A small positive residual gets a higher bonus.
    # This is inspired by heuristics that balance tight fit with future utility.
    # A simple approach is to multiply by the remaining capacity itself,
    # effectively favoring residuals that are small but non-zero.
    # This is similar to some elements in 'priority_v1' but without normalization.
    adaptive_bonus = remaining_capacity_after_fit * 0.5 # A tunable factor for the bonus

    # Combine base priority with adaptive bonus
    # Higher values indicate better suitability
    priorities[can_fit_mask] = base_priority + adaptive_bonus
    
    # Ensure priorities are non-negative, though logic should prevent this
    priorities = np.maximum(0, priorities)
    
    return priorities
```
