{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a bonus for already full bins, using a logarithmic bonus\n    to balance tight fits with encouraging fuller bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins that leave less remaining capacity.\n    # Adding a small epsilon to avoid division by zero.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Bonus: A bonus for bins that are already more full.\n    # Using the inverse of remaining capacity on fittable bins.\n    # Normalize by the maximum remaining capacity among fittable bins to get a relative measure.\n    max_remaining_cap_fittable = np.max(fittable_bins_remain_cap)\n    fullness_bonus = (max_remaining_cap_fittable - fittable_bins_remain_cap) / (max_remaining_cap_fittable + 1e-6)\n\n    # Adaptive Bonus using logarithm of remaining capacity after fit.\n    # This penalizes leaving excessively large gaps but gives smaller penalties for smaller gaps.\n    # Adding 1 to prevent log(0) and ensure positive values.\n    adaptive_bonus = np.log1p(fittable_bins_remain_cap - item)\n\n    # Combine: Weighted sum of Best Fit and Fullness Bonus, with Adaptive Bonus as a modifier.\n    # Weights are heuristic and can be tuned. Here, Best Fit is primary, Fullness adds context,\n    # and the Adaptive Bonus influences the penalty for leftover space.\n    # We invert the adaptive bonus as smaller leftover space (lower log) should be better.\n    combined_scores = (best_fit_scores * 1.0) + (fullness_bonus * 0.5) - (adaptive_bonus * 0.2)\n\n    # Normalize priorities to a [0, 1] range for better comparability and to avoid extreme values.\n    if np.max(combined_scores) > 1e-9:\n        priorities[fittable_bins_mask] = np.clip(combined_scores / np.max(combined_scores), 0, 1)\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a bonus for already full bins, using a logarithmic bonus\n    to balance tight fits with encouraging fuller bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins that leave less remaining capacity.\n    # Adding a small epsilon to avoid division by zero.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Bonus: A bonus for bins that are already more full.\n    # Using the inverse of remaining capacity on fittable bins.\n    # Normalize by the maximum remaining capacity among fittable bins to get a relative measure.\n    max_remaining_cap_fittable = np.max(fittable_bins_remain_cap)\n    fullness_bonus = (max_remaining_cap_fittable - fittable_bins_remain_cap) / (max_remaining_cap_fittable + 1e-6)\n\n    # Adaptive Bonus using logarithm of remaining capacity after fit.\n    # This penalizes leaving excessively large gaps but gives smaller penalties for smaller gaps.\n    # Adding 1 to prevent log(0) and ensure positive values.\n    adaptive_bonus = np.log1p(fittable_bins_remain_cap - item)\n\n    # Combine: Weighted sum of Best Fit and Fullness Bonus, with Adaptive Bonus as a modifier.\n    # Weights are heuristic and can be tuned. Here, Best Fit is primary, Fullness adds context,\n    # and the Adaptive Bonus influences the penalty for leftover space.\n    # We invert the adaptive bonus as smaller leftover space (lower log) should be better.\n    combined_scores = (best_fit_scores * 1.0) + (fullness_bonus * 0.5) - (adaptive_bonus * 0.2)\n\n    # Normalize priorities to a [0, 1] range for better comparability and to avoid extreme values.\n    if np.max(combined_scores) > 1e-9:\n        priorities[fittable_bins_mask] = np.clip(combined_scores / np.max(combined_scores), 0, 1)\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a modified Fill Ratio for denser packing.\n    Prioritizes bins that fit the item snugly and are already substantially full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(eligible_bins_mask):\n        return priorities\n\n    eligible_bins_caps = bins_remain_cap[eligible_bins_mask]\n\n    # Score 1: Best Fit - inverse of remaining capacity after packing.\n    # Higher score for smaller remaining capacity.\n    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)\n\n    # Score 2: Fill Ratio - remaining capacity relative to the item size.\n    # Prioritizes bins where the item occupies a larger fraction of the remaining space,\n    # promoting tighter packing. Avoids penalizing bins with very large remaining capacity.\n    fill_ratio_scores = item / (eligible_bins_caps + 1e-9)\n\n    # Combine scores multiplicatively: accentuates bins that excel in both criteria.\n    combined_scores = best_fit_scores * fill_ratio_scores\n\n    # Assign combined scores to the priorities array for eligible bins.\n    priorities[eligible_bins_mask] = combined_scores\n\n    # Normalize priorities to the range [0, 1] for consistent comparison.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a multiplicative bonus for bins that are already fuller,\n    aiming for efficient packing and reduced bin count.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher score for bins with less remaining capacity after fit.\n    # This strongly favors tight fits. Add epsilon for stability.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Score: Higher score for bins that are already more full.\n    # This encourages consolidating items into fewer bins.\n    # Normalize by the maximum remaining capacity among fittable bins for relative comparison.\n    max_rem_cap_fittable = np.max(fittable_bins_remain_cap)\n    fullness_scores = (max_rem_cap_fittable - fittable_bins_remain_cap) / (max_rem_cap_fittable + 1e-6)\n\n    # Combine scores multiplicatively.\n    # The multiplication ensures that a good fit (high best_fit_scores) is prioritized,\n    # and this priority is boosted if the bin is also already fuller (high fullness_scores).\n    # This heuristic balances the desire for a tight fit with the objective of using fewer bins.\n    combined_scores = best_fit_scores * (1 + 0.5 * fullness_scores)\n\n    # Normalize priorities to a [0, 1] range.\n    max_combined_score = np.max(combined_scores)\n    if max_combined_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_combined_score\n    else:\n        # Fallback: if all combined scores are near zero, assign a small uniform priority.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a modified Fill Ratio for denser packing.\n    Prioritizes bins that fit the item snugly and are already substantially full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(eligible_bins_mask):\n        return priorities\n\n    eligible_bins_caps = bins_remain_cap[eligible_bins_mask]\n\n    # Score 1: Best Fit - inverse of remaining capacity after packing.\n    # Higher score for smaller remaining capacity.\n    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)\n\n    # Score 2: Fill Ratio - remaining capacity relative to the item size.\n    # Prioritizes bins where the item occupies a larger fraction of the remaining space,\n    # promoting tighter packing. Avoids penalizing bins with very large remaining capacity.\n    fill_ratio_scores = item / (eligible_bins_caps + 1e-9)\n\n    # Combine scores multiplicatively: accentuates bins that excel in both criteria.\n    combined_scores = best_fit_scores * fill_ratio_scores\n\n    # Assign combined scores to the priorities array for eligible bins.\n    priorities[eligible_bins_mask] = combined_scores\n\n    # Normalize priorities to the range [0, 1] for consistent comparison.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a multiplicative bonus for fuller bins,\n    using a logarithmic scale to favor bins that are mostly full but can still fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins with minimal remaining capacity after fitting.\n    # Adding epsilon for numerical stability.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Bonus: A bonus reflecting how full the bin is *before* fitting the item.\n    # We use a logarithmic scale for the remaining capacity to give diminishing returns\n    # as bins get very full, but still reward those that are significantly filled.\n    # The idea is to slightly favor bins that are already quite full (smaller remaining capacity)\n    # to encourage consolidation. Adding 1 to avoid log(0).\n    fullness_bonus = np.log1p(bins_remain_cap[fittable_bins_mask])\n\n    # Combine scores multiplicatively: Prioritize bins that are both a good fit (low residual)\n    # and are already quite full. The fullness bonus acts as a multiplier on the best-fit score.\n    combined_scores = best_fit_scores * (1.0 + fullness_bonus * 0.2) # Add 1 to ensure positive multiplier\n\n    # Normalize priorities to a [0, 1] range.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a Fill Ratio bonus, using a multiplicative approach.\n    This prioritizes bins that fit tightly and are already relatively full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Inverse of remaining capacity after packing. Higher is better.\n    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Fill Ratio Score: Inverse of the bin's total capacity (assuming total capacity is 1 for simplicity or can be passed).\n    # Here we use the inverse of the *original* remaining capacity before fitting the item,\n    # to represent how full the bin *was*. A higher fill ratio (lower remaining capacity) is better.\n    # Add 1 to avoid division by zero if a bin was already full (though fittable_bins_mask should prevent this).\n    fill_ratio_score = 1.0 / (fittable_bins_remain_cap + 1e-9)\n\n    # Combine multiplicatively: Prioritize bins that are both a tight fit and were already full.\n    # This balances immediate packing efficiency with the goal of consolidating items.\n    combined_scores = best_fit_score * fill_ratio_score\n\n    # Normalize to [0, 1]\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a multiplicative bonus for bin fullness, \n    aiming for a more aggressive filling strategy.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Prefer bins that leave minimal remaining capacity after fitting the item.\n    # We use 1 / (remaining_capacity - item + epsilon) so smaller remaining capacity yields higher score.\n    # Adding 1 to the denominator to avoid division by zero and to give a base score.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1.0)\n\n    # Fullness Ratio: Measure how full a bin is *after* the item is placed.\n    # A higher ratio means the bin is more full, which is desirable.\n    # We calculate this based on the remaining capacity *before* placing the item,\n    # assuming a standard bin capacity, let's say 1.0 for normalization.\n    # If bin capacity is variable, it should be passed as an argument.\n    # For now, assuming a nominal capacity of 1.0 for calculating fill ratio's component.\n    # A more accurate fullness would consider the total capacity of the bin.\n    # Let's assume a fixed bin capacity of 1.0 for simplicity in this example,\n    # or a normalized capacity.\n    # A better approach might be to use the *initial* remaining capacity if available,\n    # or the capacity that was left *before* the item was placed.\n    # Here, we use the remaining capacity *after* placing the item to represent how full it *becomes*.\n    # A higher value of (1.0 - (fittable_bins_remain_cap - item)) / 1.0 represents a fuller bin.\n    # To avoid issues with different bin capacities, let's use the \"space left before fitting\"\n    # divided by a reference capacity (e.g., total capacity of the largest bin encountered so far,\n    # or a fixed value like 1.0 if capacities are normalized).\n    # For simplicity, we'll consider the \"space available\" as a proxy for fullness if we don't\n    # have total capacity. The more space *was* available, the less \"full\" the bin was initially.\n    # So, a smaller `fittable_bins_remain_cap` means the bin was fuller *before* fitting.\n    # Let's aim for a metric that rewards bins that are *already* fuller.\n    # A simple proxy for fullness (higher is better) is the inverse of remaining capacity.\n    # However, we already have best_fit which uses this.\n    # Let's redefine fullness as the ratio of *space used* to *total capacity*.\n    # If we assume total capacity is 1.0 for all bins for simplicity:\n    # Fullness = (1.0 - fittable_bins_remain_cap) / 1.0\n    # But this would penalize bins with large initial capacity even if they are mostly full.\n    # A better approach: The percentage of capacity *already taken*.\n    # Let's use the complement of the remaining capacity *before* fitting,\n    # normalized by the maximum possible remaining capacity (which is the maximum capacity if we knew it).\n    # Without knowing total capacity, we can use a surrogate:\n    # How \"close\" is the bin to being full?\n    # Higher score if `fittable_bins_remain_cap` is small (relative to other fittable bins).\n    # This is similar to Best Fit, so let's ensure it's distinct.\n\n    # Let's try a multiplicative approach. We want to maximize both \"best fit\" and \"fullness\".\n    # Fullness metric: percentage of capacity *already filled*.\n    # If we don't know total capacity, we can use the available capacity as a base.\n    # Consider bins that are already \"mostly full\".\n    # A bin that has `C` capacity and `r` remaining capacity, has `C-r` filled.\n    # Fill ratio = (C-r) / C = 1 - r/C.\n    # To make it usable without C, we can normalize `r` by the maximum possible `r` among fittable bins.\n    # `fullness_score` = 1 - (fittable_bins_remain_cap / max(fittable_bins_remain_cap))\n    # This rewards bins that had less remaining capacity *before* fitting.\n    max_initial_remain_cap = np.max(fittable_bins_remain_cap)\n    fullness_scores = 1.0 - (fittable_bins_remain_cap / (max_initial_remain_cap + 1e-6))\n\n    # Combine: Multiplicative interaction between Best Fit and Fullness.\n    # This encourages bins that are both a good fit and already relatively full.\n    # Add a small epsilon to prevent multiplication by zero.\n    combined_scores = best_fit_scores * (fullness_scores + 0.1) # Adding 0.1 to ensure scores are positive and not zeroed out easily\n\n    # Normalize priorities to a [0, 1] range.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit's tightness with a multiplicative bonus for fuller bins,\n    using a logarithmic scale to favor bins that are mostly full but can still fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins with minimal remaining capacity after fitting.\n    # Adding epsilon for numerical stability.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Bonus: A bonus reflecting how full the bin is *before* fitting the item.\n    # We use a logarithmic scale for the remaining capacity to give diminishing returns\n    # as bins get very full, but still reward those that are significantly filled.\n    # The idea is to slightly favor bins that are already quite full (smaller remaining capacity)\n    # to encourage consolidation. Adding 1 to avoid log(0).\n    fullness_bonus = np.log1p(bins_remain_cap[fittable_bins_mask])\n\n    # Combine scores multiplicatively: Prioritize bins that are both a good fit (low residual)\n    # and are already quite full. The fullness bonus acts as a multiplier on the best-fit score.\n    combined_scores = best_fit_scores * (1.0 + fullness_bonus * 0.2) # Add 1 to ensure positive multiplier\n\n    # Normalize priorities to a [0, 1] range.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and First Fit Decreasing ideas with a focus on filling\n    bins as much as possible, prioritizing bins that are nearly full or\n    can accommodate the item with minimal remaining space.\n    This version uses a multiplicative approach to balance fitting tightly\n    and maintaining a good fill ratio.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and a Fill Ratio bonus multiplicatively,\n    prioritizing bins that are both a tight fit and already well-utilized.\n    This aims for efficient packing by favoring dense bins that can snugly fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # --- Best Fit Component ---\n    # Higher score for smaller remaining capacity after fitting.\n    remaining_capacity_after_fit = fitting_bins_remain_cap - item\n    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)\n    \n    # --- Fill Ratio Component ---\n    # Using 1.0 as the assumed bin capacity. Higher fill ratio (less remaining capacity) is better.\n    # This encourages using bins that are already somewhat full.\n    bin_capacity = 1.0 \n    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity\n    fill_ratio_score = current_fill_ratio\n    \n    # --- Combined Score ---\n    # Multiplicatively combine Best Fit and Fill Ratio.\n    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).\n    # A bin that is nearly full and can snugly fit the item will get a high score.\n    combined_score = proximity_score * fill_ratio_score\n    \n    # --- Refinement: Ensure proximity is considered for empty bins ---\n    # If a bin was empty (fill_ratio=0), combined_score would be 0.\n    # We want to ensure that even in this case, the proximity score is still considered,\n    # as an empty bin might be the only option or a good first fit.\n    # We take the maximum of the combined score and a modified proximity score\n    # where the fill_ratio_score component is only applied if fill_ratio > 0.\n    # This ensures that even empty bins get a score based on their proximity.\n    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))\n    \n    # Add a small constant to all valid priorities to ensure that even if\n    # all scores are very low, they are distinct and positive, aiding tie-breaking.\n    priorities[can_fit_mask] += 1e-6\n    \n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and a Fill Ratio bonus multiplicatively,\n    prioritizing bins that are both a tight fit and already well-utilized.\n    This aims for efficient packing by favoring dense bins that can snugly fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # --- Best Fit Component ---\n    # Higher score for smaller remaining capacity after fitting.\n    remaining_capacity_after_fit = fitting_bins_remain_cap - item\n    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)\n    \n    # --- Fill Ratio Component ---\n    # Using 1.0 as the assumed bin capacity. Higher fill ratio (less remaining capacity) is better.\n    # This encourages using bins that are already somewhat full.\n    bin_capacity = 1.0 \n    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity\n    fill_ratio_score = current_fill_ratio\n    \n    # --- Combined Score ---\n    # Multiplicatively combine Best Fit and Fill Ratio.\n    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).\n    # A bin that is nearly full and can snugly fit the item will get a high score.\n    combined_score = proximity_score * fill_ratio_score\n    \n    # --- Refinement: Ensure proximity is considered for empty bins ---\n    # If a bin was empty (fill_ratio=0), combined_score would be 0.\n    # We want to ensure that even in this case, the proximity score is still considered,\n    # as an empty bin might be the only option or a good first fit.\n    # We take the maximum of the combined score and a modified proximity score\n    # where the fill_ratio_score component is only applied if fill_ratio > 0.\n    # This ensures that even empty bins get a score based on their proximity.\n    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))\n    \n    # Add a small constant to all valid priorities to ensure that even if\n    # all scores are very low, they are distinct and positive, aiding tie-breaking.\n    priorities[can_fit_mask] += 1e-6\n    \n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and First Fit Decreasing ideas with a focus on filling\n    bins as much as possible, prioritizing bins that are nearly full or\n    can accommodate the item with minimal remaining space.\n    This version uses a multiplicative approach to balance fitting tightly\n    and maintaining a good fill ratio.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and a Fill Ratio bonus multiplicatively,\n    prioritizing bins that are both a tight fit and already well-utilized.\n    This aims for efficient packing by favoring dense bins that can snugly fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # --- Best Fit Component ---\n    # Higher score for smaller remaining capacity after fitting.\n    remaining_capacity_after_fit = fitting_bins_remain_cap - item\n    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)\n    \n    # --- Fill Ratio Component ---\n    # Using 1.0 as the assumed bin capacity. Higher fill ratio (less remaining capacity) is better.\n    # This encourages using bins that are already somewhat full.\n    bin_capacity = 1.0 \n    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity\n    fill_ratio_score = current_fill_ratio\n    \n    # --- Combined Score ---\n    # Multiplicatively combine Best Fit and Fill Ratio.\n    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).\n    # A bin that is nearly full and can snugly fit the item will get a high score.\n    combined_score = proximity_score * fill_ratio_score\n    \n    # --- Refinement: Ensure proximity is considered for empty bins ---\n    # If a bin was empty (fill_ratio=0), combined_score would be 0.\n    # We want to ensure that even in this case, the proximity score is still considered,\n    # as an empty bin might be the only option or a good first fit.\n    # We take the maximum of the combined score and a modified proximity score\n    # where the fill_ratio_score component is only applied if fill_ratio > 0.\n    # This ensures that even empty bins get a score based on their proximity.\n    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))\n    \n    # Add a small constant to all valid priorities to ensure that even if\n    # all scores are very low, they are distinct and positive, aiding tie-breaking.\n    priorities[can_fit_mask] += 1e-6\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and First Fit Decreasing ideas with a focus on filling\n    bins as much as possible, prioritizing bins that are nearly full or\n    can accommodate the item with minimal remaining space.\n    This version uses a multiplicative approach to balance fitting tightly\n    and maintaining a good fill ratio.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.2305129093783861) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a 'fill ratio' bonus, prioritizing bins that are both a tight fit\n    and already well-utilized, aiming for efficient packing.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): A numpy array representing the remaining capacity of each bin.\n        epsilon (float, optional): A small constant to prevent division by zero. Defaults to 1e-9.\n\n    Returns:\n        np.ndarray: A numpy array of priorities for each bin, normalized to [0, 1].\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(eligible_bins_mask):\n        return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and First Fit Decreasing ideas with a focus on filling\n    bins as much as possible, prioritizing bins that are nearly full or\n    can accommodate the item with minimal remaining space.\n    This version uses a multiplicative approach to balance fitting tightly\n    and maintaining a good fill ratio.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.2305129093783861) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a 'fill ratio' bonus, prioritizing bins that are both a tight fit\n    and already well-utilized, aiming for efficient packing.\n\n    Args:\n        item (float): The size of the item to be packed.\n        bins_remain_cap (np.ndarray): A numpy array representing the remaining capacity of each bin.\n        epsilon (float, optional): A small constant to prevent division by zero. Defaults to 1e-9.\n\n    Returns:\n        np.ndarray: A numpy array of priorities for each bin, normalized to [0, 1].\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(eligible_bins_mask):\n        return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a fill ratio bonus using a multiplicative approach,\n    prioritizing bins that offer a tight fit and are already well-utilized.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    fitting_bins_indices = np.where(can_fit_mask)[0]\n    \n    if fitting_bins_indices.size > 0:\n        fitting_bins_cap = bins_remain_cap[fitting_bins_indices]\n        \n        # Best Fit component: Smaller difference is better (higher score)\n        differences = fitting_bins_cap - item\n        best_fit_score = 1.0 / (differences + 1e-9)\n        \n        # Fill Ratio component: Higher fill ratio is better (higher score)\n        # Assuming bin capacity is constant (e.g., 1.0 for normalized problems or a known max_capacity)\n        # Here, we use the total capacity before packing as the reference for fill ratio.\n        # A simpler proxy for fullness is (bin_capacity - remaining_capacity).\n        # Let's assume a hypothetical bin capacity of 1.0 for this calculation if not provided.\n        # If bin_capacity is known, replace 1.0 with it.\n        bin_capacity = 1.0 \n        fullness = (bin_capacity - fitting_bins_cap) / bin_capacity\n        fill_ratio_score = fullness \n        \n        # Combine scores multiplicatively: Boosts bins that are both tight fits and fuller.\n        # Adding a small constant to fill_ratio_score to avoid multiplying by zero if a bin is empty.\n        combined_scores = best_fit_score * (fill_ratio_score + 0.1) # Add small bonus to slightly full bins\n        \n        priorities[fitting_bins_indices] = combined_scores\n        \n        # Normalize priorities to be between 0 and 1 for the fitting bins\n        max_priority = np.max(priorities[fitting_bins_indices])\n        if max_priority > 0:\n            priorities[fitting_bins_indices] /= max_priority\n            \n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}