```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit preference with a bonus for bins that are already significantly filled,
    aiming for efficient space utilization and minimizing the number of bins used.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_cap.size > 0:
        differences = fitting_bins_cap - item
        
        # Best Fit component: Higher score for smaller remaining capacity
        best_fit_score = 1.0 / (differences + 1e-9)
        
        # Fullness bonus: Reward bins that are already more utilized (closer to full)
        # This is a simplified version of the fullness bonus from v0,
        # focusing on the absolute remaining capacity as a proxy for fullness.
        # Bins with less remaining capacity are considered "more full".
        fullness_bonus = (np.max(bins_remain_cap) - fitting_bins_cap) / (np.max(bins_remain_cap) + 1e-9)
        
        # Combine scores: Additive combination. Prioritize tight fits (Best Fit)
        # and give a boost to bins that are already quite full.
        combined_scores = best_fit_score + fullness_bonus * 0.5 # Tunable weight for bonus
        
        priorities[can_fit_mask] = combined_scores
        
        # Normalize priorities for bins that can fit the item
        max_priority = np.max(priorities[can_fit_mask])
        if max_priority > 0:
            priorities[can_fit_mask] /= max_priority
            
    return priorities
```
