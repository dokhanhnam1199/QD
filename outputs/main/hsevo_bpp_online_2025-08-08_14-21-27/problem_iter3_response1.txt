```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for bins using an adaptive strategy that considers both proximity and bin fullness.
    Bins that can fit the item are prioritized. Among fitting bins, those with remaining capacity closer to the item size
    (but not too small) are preferred. Additionally, a penalty is introduced for using bins that are already very full
    to encourage spreading items, and a bonus for using bins that are less full to make use of existing capacity.

    The priority is calculated as:
    priority = (proximity_score * proximity_weight) + (fullness_bonus * fullness_weight)

    proximity_score: Higher for bins where remaining capacity is close to item size.
                     A small offset is added to avoid division by zero.
    fullness_bonus: A bonus for bins that have more remaining capacity.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array of the remaining capacities of all bins.

    Returns:
        np.ndarray: An array of priority scores for each bin. Bins that cannot fit the item have a score of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    if fitting_bins_cap.size > 0:
        # Proximity Score: Inverse of (difference + epsilon) to favor closer fits.
        # Add a small buffer (e.g., 0.1 * item) to avoid extremely small differences
        # that might lead to disproportionately high priorities.
        differences = fitting_bins_cap - item
        proximity_score = 1.0 / (differences + 0.1 * item + 1e-9)

        # Fullness Bonus: Reward bins with more remaining capacity.
        # Normalize remaining capacity to a [0, 1] range based on the maximum possible remaining capacity
        # which can be considered the bin capacity (assuming bins start empty).
        # For simplicity, let's consider the maximum remaining capacity among fitting bins as a reference.
        max_fitting_cap = np.max(fitting_bins_cap)
        fullness_bonus = fitting_bins_cap / (max_fitting_cap + 1e-9)

        # Weights for balancing proximity and fullness
        proximity_weight = 0.7
        fullness_weight = 0.3

        # Combine scores
        combined_priorities = (proximity_score * proximity_weight) + (fullness_bonus * fullness_weight)

        # Normalize to [0, 1] based on the maximum combined priority
        max_combined_priority = np.max(combined_priorities)
        if max_combined_priority > 0:
            priorities[can_fit_mask] = combined_priorities / max_combined_priority

    return priorities
```
