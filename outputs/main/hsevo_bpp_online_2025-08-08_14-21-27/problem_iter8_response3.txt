```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best-Fit proximity with a fill ratio bonus, prioritizing tight fits
    and the utilization of already fuller bins for better overall packing.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    differences = fitting_bins_cap - item

    # Best-Fit component: Higher score for smaller remaining capacity after fitting
    # Add a small epsilon to prevent division by zero for perfect fits.
    best_fit_score = 1.0 / (differences + 1e-9)

    # Fill Ratio component: Bonus for bins that are already more utilized.
    # Use the inverse of remaining capacity as a proxy for fullness relative to bin size.
    # Normalize by the maximum remaining capacity to get a relative fullness score.
    max_total_capacity = np.max(bins_remain_cap) # Assuming all bins have same max capacity
    fill_ratio_bonus = fitting_bins_cap / (max_total_capacity + 1e-9)

    # Combine scores multiplicatively, giving weight to both tight fit and fullness.
    # The addition of 1 to fill_ratio_bonus ensures that even less full bins
    # contribute positively to the score, preventing zeroing out the best_fit_score.
    combined_scores = best_fit_score * (1 + fill_ratio_bonus * 0.7) # Tunable weight for bonus

    priorities[can_fit_mask] = combined_scores

    # Normalize priorities to ensure the highest score is 1.0 for consistent selection.
    max_priority = np.max(priorities[can_fit_mask])
    if max_priority > 0:
        priorities[can_fit_mask] /= max_priority

    return priorities
```
