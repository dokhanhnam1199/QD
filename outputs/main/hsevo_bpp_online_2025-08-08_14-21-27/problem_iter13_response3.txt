import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.8621771941) -> np.ndarray:
    """
    Combines Best Fit with a 'fill ratio' bonus, prioritizing bins that are both a tight fit
    and already well-utilized, aiming for efficient packing.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): A numpy array representing the remaining capacity of each bin.
        epsilon (float, optional): A small constant to prevent division by zero. Defaults to 1e-9.

    Returns:
        np.ndarray: A numpy array of priorities for each bin, normalized to [0, 1].
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    eligible_bins_mask = bins_remain_cap >= item

    if not np.any(eligible_bins_mask):
        return priorities

    eligible_bins_caps = bins_remain_cap[eligible_bins_mask]

    # Best Fit Score: Inversely proportional to the remaining capacity after fitting the item.
    # Adding a small epsilon to avoid division by zero.
    best_fit_scores = 1.0 / (eligible_bins_caps - item + epsilon)

    # Fill Ratio Score: Proportional to how full the bin is *relative to its capacity after packing*.
    # This emphasizes bins that will have less remaining space after the item is placed.
    fill_ratio_scores = (bins_remain_cap[eligible_bins_mask] - item) / (eligible_bins_caps + epsilon)


    # Combined Score: Multiplicative combination.
    # Prioritizes bins that are a good fit (high best_fit_scores) AND are already quite full (high fill_ratio_scores).
    combined_scores = best_fit_scores * fill_ratio_scores

    priorities[eligible_bins_mask] = combined_scores

    # Normalize priorities to the range [0, 1] for consistent comparison across different item sizes and bin states.
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = priorities / max_priority

    return priorities
