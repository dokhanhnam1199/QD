```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a fill-ratio bonus, favoring bins that are both a good fit and already utilized.
    This heuristic prioritizes bins that are nearly full and leave minimal residual capacity.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Filter bins that can fit the item
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Calculate the remaining capacity after fitting the item
    remaining_capacity_after_fit = fitting_bins_remain_cap - item
    
    # --- Best Fit Component ---
    # Score is inversely proportional to the residual capacity after fitting.
    # Adding a small epsilon to avoid division by zero.
    # A score of 1.0 means the bin is perfectly filled after adding the item.
    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)
    
    # --- Fill Ratio Component ---
    # Assumes a default bin capacity of 1.0.
    # Fill ratio is the proportion of capacity already used. Higher is better.
    bin_capacity = 1.0 
    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity
    fill_ratio_score = current_fill_ratio
    
    # --- Combined Score ---
    # Multiply proximity score by fill ratio score.
    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).
    # The idea is to prefer bins that are already "almost full" and can still accommodate the item snugly.
    combined_score = proximity_score * fill_ratio_score
    
    # --- Refinement: Ensure proximity is considered for empty bins ---
    # If a bin was empty (fill_ratio=0), combined_score would be 0.
    # We want to ensure that even in this case, the proximity score is still considered,
    # as an empty bin might be the only option or a good first fit.
    # We take the maximum of the combined score and the proximity score itself,
    # effectively giving proximity score at least its due when fill ratio is zero.
    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))
    
    # Add a small epsilon to all valid priorities to ensure that even if
    # all scores are very low, they are distinct and positive, aiding tie-breaking.
    priorities[can_fit_mask] += 1e-6
    
    return priorities
```
