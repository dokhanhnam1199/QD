```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive fullness bonus. Prioritizes bins that are
    nearly full and can accommodate the item with minimal remaining space,
    using a normalized fullness score for better adaptability.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]

    # Best Fit component: Prioritize bins with smallest remaining capacity after fitting.
    # Adding a small epsilon to avoid division by zero.
    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)

    # Adaptive Fullness component: Prioritize bins that are already more full,
    # using a normalized measure relative to the maximum initial remaining capacity
    # among fittable bins to ensure better cross-bin comparison.
    # This score is higher for bins that are already fuller.
    # Add a small epsilon to the denominator to avoid division by zero if all fittable bins are empty.
    max_initial_remain_cap = np.max(fittable_bins_remain_cap)
    fullness_score = 1.0 - (fittable_bins_remain_cap / (max_initial_remain_cap + 1e-9))

    # Combine scores multiplicatively: Boosts bins that are both tight fits and more full.
    # Add a small constant to fullness_score to ensure it always contributes positively
    # and doesn't zero out the overall score if a bin is very empty.
    combined_scores = best_fit_score * (fullness_score + 0.5)

    priorities[fittable_bins_mask] = combined_scores

    # Normalize priorities for fittable bins to a [0, 1] range.
    max_priority = np.max(priorities[fittable_bins_mask])
    if max_priority > 0:
        priorities[fittable_bins_mask] /= max_priority

    return priorities
```
