```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for bins using an adaptive strategy.
    It prioritizes bins that offer a good fit (similar to Inverse Distance)
    but also considers bins that are less full to maintain flexibility for future larger items.
    The priority is a combination of proximity to the item size and a penalty for being too full.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if fitting_bins_cap.size > 0:
        differences = fitting_bins_cap - item
        # Proximity score: higher for smaller differences
        proximity_scores = 1.0 / (differences + 1e-9)

        # Fill penalty: penalize bins that are already very full (low remaining capacity)
        # This encourages using bins with more space for potentially larger future items.
        # We invert the remaining capacity and normalize it. Bins with less remaining capacity
        # will have a higher penalty score.
        max_cap = np.max(bins_remain_cap)
        min_remaining = fitting_bins_cap
        fill_penalties = (max_cap - min_remaining) / (max_cap + 1e-9)

        # Combine scores. We want high proximity and low fill penalty.
        # A simple way is to add proximity and subtract the penalty.
        # The weights can be adjusted to tune the balance.
        combined_scores = proximity_scores + fill_penalties * 0.5 # Adjust weight for fill penalty

        # Normalize combined scores for the fitting bins
        max_combined_score = np.max(combined_scores)
        if max_combined_score > 0:
            priorities[fitting_bins_indices] = combined_scores / max_combined_score

    return priorities
```
