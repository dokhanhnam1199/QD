{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit with a multiplicative bonus for bins that are already fuller,\n    aiming for efficient packing and reduced bin count.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher score for bins with less remaining capacity after fit.\n    # This strongly favors tight fits. Add epsilon for stability.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Score: Higher score for bins that are already more full.\n    # This encourages consolidating items into fewer bins.\n    # Normalize by the maximum remaining capacity among fittable bins for relative comparison.\n    max_rem_cap_fittable = np.max(fittable_bins_remain_cap)\n    fullness_scores = (max_rem_cap_fittable - fittable_bins_remain_cap) / (max_rem_cap_fittable + 1e-6)\n\n    # Combine scores multiplicatively.\n    # The multiplication ensures that a good fit (high best_fit_scores) is prioritized,\n    # and this priority is boosted if the bin is also already fuller (high fullness_scores).\n    # This heuristic balances the desire for a tight fit with the objective of using fewer bins.\n    combined_scores = best_fit_scores * (1 + 0.5 * fullness_scores)\n\n    # Normalize priorities to a [0, 1] range.\n    max_combined_score = np.max(combined_scores)\n    if max_combined_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_combined_score\n    else:\n        # Fallback: if all combined scores are near zero, assign a small uniform priority.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit and a Fill Ratio bonus multiplicatively,\n    prioritizing bins that are both a tight fit and already well-utilized.\n    This aims for efficient packing by favoring dense bins that can snugly fit the item.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # --- Best Fit Component ---\n    # Higher score for smaller remaining capacity after fitting.\n    remaining_capacity_after_fit = fitting_bins_remain_cap - item\n    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)\n    \n    # --- Fill Ratio Component ---\n    # Using 1.0 as the assumed bin capacity. Higher fill ratio (less remaining capacity) is better.\n    # This encourages using bins that are already somewhat full.\n    bin_capacity = 1.0 \n    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity\n    fill_ratio_score = current_fill_ratio\n    \n    # --- Combined Score ---\n    # Multiplicatively combine Best Fit and Fill Ratio.\n    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).\n    # A bin that is nearly full and can snugly fit the item will get a high score.\n    combined_score = proximity_score * fill_ratio_score\n    \n    # --- Refinement: Ensure proximity is considered for empty bins ---\n    # If a bin was empty (fill_ratio=0), combined_score would be 0.\n    # We want to ensure that even in this case, the proximity score is still considered,\n    # as an empty bin might be the only option or a good first fit.\n    # We take the maximum of the combined score and a modified proximity score\n    # where the fill_ratio_score component is only applied if fill_ratio > 0.\n    # This ensures that even empty bins get a score based on their proximity.\n    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))\n    \n    # Add a small constant to all valid priorities to ensure that even if\n    # all scores are very low, they are distinct and positive, aiding tie-breaking.\n    priorities[can_fit_mask] += 1e-6\n    \n    return priorities\n\n### Analyze & experience\n- *   **Heuristics 1 & 2 vs. 3 & 5:** Heuristics 1 and 2 use a weighted sum and include a logarithmic adaptive bonus, which is more nuanced than the multiplicative combination of Best Fit and Fill Ratio in 3 and 5. The inclusion of a \"fullness bonus\" (inverse of remaining capacity) and an \"adaptive bonus\" (logarithm of remaining capacity) in 1 and 2 provides a more sophisticated scoring mechanism. Heuristics 3 and 5 use a simple multiplicative combination, which might be less robust to extreme values.\n*   **Heuristics 1 & 2 vs. 4:** Heuristic 4 uses a multiplicative combination with a simpler fullness score than 1 and 2. Heuristics 1 and 2's additive combination with a logarithmic penalty seems more robust and less prone to over-penalizing due to multiplication. The \"adaptive bonus\" in 1 and 2 offers finer control over penalizing large leftover spaces.\n*   **Heuristics 1 & 2 vs. 6 & 9:** Heuristics 6 and 9 also use a multiplicative combination with a logarithmic bonus. However, they apply it as `best_fit_scores * (1.0 + fullness_bonus * 0.2)`, which might be less balanced than the additive approach in 1 and 2, especially if `fullness_bonus` becomes very large. Heuristics 1 and 2's use of a weighted sum with an *inversion* of the adaptive bonus (`- (adaptive_bonus * 0.2)`) suggests a more deliberate attempt to balance fitting tightness and residual space.\n*   **Heuristics 3 & 5 vs. 7 & 11 & 12 & 14 & 20:** Heuristics 7, 11, 12, 14, and 20 are similar in their multiplicative combination of Best Fit and Fill Ratio. However, 11, 12, 14, and 20 attempt to refine this by handling empty bins or adding small constants, making them slightly more robust. Heuristic 7's fill ratio calculation (`1.0 / (fittable_bins_remain_cap + 1e-9)`) is a bit simplistic and might not clearly represent \"fullness\" as well as calculating `1 - remaining_capacity/capacity`. Heuristics 11, 12, 14, and 20 are very similar, with the `np.maximum` refinement in 11, 12, and 14 adding a useful layer.\n*   **Heuristics 8 vs. others:** Heuristic 8 uses a multiplicative combination with a fullness score based on `1.0 - (fittable_bins_remain_cap / max_initial_remain_cap)`. This is a reasonable approach, but the specific formula for `best_fit_scores` (`1.0 / (fittable_bins_remain_cap - item + 1.0)`) is less aggressive than `1.0 / (fittable_bins_remain_cap - item + epsilon)`, potentially making it less sensitive to very tight fits.\n*   **Heuristics 10, 13, 15, 17, 19:** These heuristics have incomplete code bodies (only the function signature and docstring, or just the signature and mask). Their actual logic is not present, making direct comparison impossible. They seem to be placeholders or intended to be filled.\n*   **Heuristics 16 & 18:** Similar to the above, these also have incomplete implementations. They mention a \"fill ratio\" bonus but don't show its calculation or how it's combined.\n*   **Overall Ranking Rationale:** Heuristics 1 and 2 stand out due to their additive combination strategy, the inclusion of a weighted sum of multiple factors (Best Fit, Fullness Bonus, Adaptive Bonus), and the use of logarithmic scaling for finer control. This suggests a more balanced and adaptable approach. Heuristics 11, 12, 14, and 20 follow with their multiplicative Best Fit + Fill Ratio approach, enhanced by refinements for edge cases like empty bins. Heuristic 4 is a simpler version of the multiplicative approach. Heuristics 3 and 5 are basic multiplicative combinations. Heuristic 8 has a slightly less aggressive Best Fit component. Heuristics 7 is similar but with a less robust fill ratio calculation. Heuristics 6 and 9 use a multiplicative approach that might be less balanced than the additive approach in 1 and 2. The incomplete heuristics (10, 13, 15, 16, 17, 18, 19) are ranked lowest due to their lack of implementational detail.\n- \nHere's a redefined approach to self-reflection for designing better heuristics, focusing on overcoming ineffective practices:\n\n*   **Keywords:** Objective Combination, Adaptive Weighting, Multiplicative Scoring, Robustness.\n*   **Advice:** Focus on *why* certain objective combinations work, not just *that* they work. Explicitly model trade-offs using multiplicative or weighted additive functions, and proactively test for edge cases that break simple rules.\n*   **Avoid:** Redundant comparisons of nearly identical implementations, treating similar scoring mechanisms as distinct, and vague justifications for complexity. Do not overlook the *interaction* between objective components.\n*   **Explanation:** Effective self-reflection means dissecting the *mechanism* of success. Instead of stating \"combine objectives,\" analyze *how* a multiplicative approach balances fitting an item now versus leaving usable space for later. This analytical depth guides the creation of truly novel and robust heuristics.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}