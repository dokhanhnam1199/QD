{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit's tightness with a Fill Ratio that penalizes large remaining capacities.\n    Prioritizes bins that snugly fit the item and are already substantially full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    eligible_bins_caps = bins_remain_cap[fittable_bins_mask]\n\n    # Score 1: Best Fit (inverse of remaining capacity after packing)\n    # Higher score for smaller remaining capacity. Adding epsilon for numerical stability.\n    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)\n\n    # Score 2: Fill Ratio (inversely proportional to remaining capacity)\n    # Prioritizes bins that are more full. This is a refinement to penalize bins\n    # with a lot of leftover space more strongly than a simple ratio.\n    fill_ratio_scores = 1.0 / (eligible_bins_caps + 1e-9)\n\n    # Combine scores multiplicatively. This emphasizes bins that are good in both aspects.\n    # The addition of 1.0 in the fill_ratio_scores is removed to directly use the inverse\n    # of remaining capacity for a stronger penalty on larger remaining spaces.\n    combined_scores = best_fit_scores * fill_ratio_scores\n\n    # Assign combined scores to the priorities array for eligible bins.\n    priorities[fittable_bins_mask] = combined_scores\n\n    # Normalize priorities to the range [0, 1] for consistent comparison.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines Best Fit's preference for tight fits with a multiplicative\n    fullness bonus, prioritizing bins that are nearly full and can\n    accommodate the item with minimal remaining space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit component: Prioritize bins with smallest remaining capacity after fitting\n    # Adding a small epsilon to avoid division by zero if remaining capacity is exactly item size\n    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)\n\n    # Fullness component: Prioritize bins that are already more full.\n    # Assuming a normalized bin capacity of 1.0. If capacity varies, this needs adjustment.\n    # Higher fullness means smaller remaining capacity, so we want to penalize larger remaining capacities.\n    # A simple way is to use the inverse of remaining capacity, but to avoid zero for empty bins\n    # and to make it more comparable to best_fit, let's use a score derived from 1 - (remaining_cap / capacity)\n    # where capacity is assumed to be 1.0.\n    fullness_score = 1.0 - fittable_bins_remain_cap # Higher score for smaller remaining capacity\n\n    # Combine scores multiplicatively: Boosts bins that are both tight fits and more full.\n    # A small constant is added to fullness_score to prevent it from being zero,\n    # ensuring that even less full bins contribute to the multiplicative factor.\n    combined_scores = best_fit_score * (fullness_score + 0.5) # Adding a small boost to less full bins\n\n    priorities[fittable_bins_mask] = combined_scores\n\n    # Normalize priorities for fittable bins to a [0, 1] range.\n    max_priority = np.max(priorities[fittable_bins_mask])\n    if max_priority > 0:\n        priorities[fittable_bins_mask] /= max_priority\n\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1st (weighted additive with log bonus) vs. Heuristic 2nd (multiplicative best-fit and fill ratio): Heuristic 1st attempts a more nuanced combination with a logarithmic term to manage leftover space, which can be more stable. Heuristic 2nd uses a simple multiplicative approach which can be too aggressive.\n\nComparing Heuristic 1st (weighted additive with log bonus) vs. Heuristic 3rd (complex additive with multiple components): Heuristic 1st is simpler and more direct. Heuristic 3rd's attempt at \"Proximity to Half-Capacity\" and \"Worst Fit Incentive\" without clear definitions or robust proxies makes it less reliable.\n\nComparing Heuristic 2nd (multiplicative best-fit and fill ratio) vs. Heuristic 5th (identical to 2nd, possibly a copy-paste error): They are identical, making comparison moot for ranking. However, the core idea of multiplicative best-fit and fill ratio is present in 2nd, 5th, 6th, 7th, 8th, 10th, 15th, 16th, 17th, 18th, 19th, 20th. Heuristic 10th uses a logarithmic fill bonus, which is a slight variation. Heuristics 5th, 6th, 7th, 8th are indeed identical.\n\nComparing Heuristic 4th (multiplicative with explicit penalty/bonus) vs. Heuristic 9th (multiplicative best-fit and normalized fullness): Heuristic 4th's explicit `1.0 / (1.0 + leftover_space_penalty)` is a reasonable way to incorporate a penalty, but the interaction with other terms might be sensitive. Heuristic 9th's `fullness_scores = 1.0 - (fittable_bins_remain_cap / max_initial_remain_cap)` attempts to normalize fullness, which can be more robust than absolute remaining capacity. However, it adds a constant `+ 0.1` to `fullness_scores` before multiplication, which is a heuristic dampener.\n\nComparing Heuristic 1st (weighted additive) vs. Heuristic 12th (multiplicative with adaptive tightness): Heuristic 1st's additive approach is generally more controllable than Heuristic 12th's multiplicative approach, especially with an exponential tightness component which can be sensitive. Heuristic 12th's `(1.0 - large_bin_penalty_component)` might lead to negative values if `large_bin_penalty_component` is greater than 1, which is unlikely here but a potential issue.\n\nComparing Heuristic 2nd (multiplicative best-fit and fill ratio) vs. Heuristic 10th (multiplicative best-fit and log fullness bonus): Heuristic 10th's use of `log1p(1.0 / (fittable_bins_remain_cap + 1e-9))` for fullness is a more sophisticated way to handle varying levels of fullness compared to Heuristic 2nd's simple inverse.\n\nOverall: Heuristic 1st seems to strike a good balance between simplicity, interpretability, and robustness with its weighted additive approach. Multiplicative combinations (like Heuristics 2nd, 4th, 9th, 10th) can be powerful but risk being too sensitive to specific term values or interactions. Heuristics involving complex adaptive terms or unclear proxies (like parts of Heuristic 3rd, 12th, 13th, 14th) are harder to justify without empirical validation. The numerous identical heuristics (5th, 6th, 7th, 8th) are a clear weakness in the list.\n- \nHere's a redefined \"Current self-reflection\" focused on designing better heuristics, avoiding pitfalls of ineffective self-reflection:\n\n*   **Keywords:** Multi-objective, Adaptive Weighting, Robustness, Interpretability, Granular Control.\n*   **Advice:** Design heuristics with granular control via additive components, carefully normalized. Prioritize explicit balancing of immediate packing efficiency and future bin utility. Implement adaptive weighting based on item characteristics for improved robustness.\n*   **Avoid:** Redundant heuristics, overly aggressive multiplicative combinations without clear justification, and implicit assumptions about scale or edge cases. Do not rely on near-identical implementations.\n*   **Explanation:** This approach emphasizes clarity, adaptability, and the avoidance of duplication. It suggests building complex behaviors from well-understood, controlled components rather than relying on opaque, potentially brittle multiplicative interactions or redundant strategies.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}