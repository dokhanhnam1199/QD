```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit proximity with an adaptive bonus for moderate remaining capacity,
    favoring bins that are a close fit but also leave some useful space.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    if fitting_bins_cap.size > 0:
        # Best Fit proximity: Score higher for bins with smaller remaining capacity after fitting.
        differences = fitting_bins_cap - item
        proximity_scores = 1.0 / (differences + 1e-9)

        # Adaptive "Usefulness" Bonus: Reward bins that leave a moderate amount of space.
        # A logarithmic function provides diminishing returns, preventing excessively large remainders
        # from dominating the score, while still giving a bonus for leaving more space.
        # This encourages leaving space for future items without being overly wasteful.
        resulting_remainders = fitting_bins_cap - item
        
        # We use log(1 + remainder) so that even empty bins (remainder 0) get a small base bonus,
        # and the bonus increases with remaining space, but at a decreasing rate.
        # A small constant is added inside log to prevent log(0) if resulting_remainders is 0.
        adaptive_bonus = np.log(1 + resulting_remainders + 1e-9)
        
        # Combine proximity and adaptive bonus.
        # The proximity score drives the heuristic towards the tightest fit.
        # The adaptive bonus slightly counteracts pure greediness by rewarding bins
        # that leave more space, up to a point.
        # A multiplicative combination ensures that a good fit is still paramount,
        # but the bonus can differentiate between equally good fits.
        combined_scores = proximity_scores * (1 + 0.2 * adaptive_bonus) # 0.2 is a tunable parameter

        # Normalize scores for the bins that can fit the item.
        # Ensures the highest priority bin gets a score of 1.0, making priorities relative.
        max_score = np.max(combined_scores)
        if max_score > 0:
            priorities[can_fit_mask] = combined_scores / max_score

    return priorities
```
