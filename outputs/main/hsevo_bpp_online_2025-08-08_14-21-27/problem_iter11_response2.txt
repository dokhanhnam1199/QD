```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a bonus for bins that are already utilized,
    prioritizing snug fits in partially filled bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Best Fit score: Inverse of remaining capacity after fitting. High score for tight fits.
    proximity_score = 1.0 / (fitting_bins_remain_cap - item + 1e-9)
    
    # Fill Ratio Score: Bonus for bins that are already mostly full.
    # We use the inverse of the remaining capacity *before* placing the item as a proxy for fullness.
    # A higher value means the bin was less full, so we want to penalize that.
    # The lower the remaining capacity (before fitting), the fuller the bin.
    fullness_bonus = 1.0 / (fitting_bins_remain_cap + 1e-9)
    
    # Combine scores multiplicatively: prioritize tight fits that are also on already utilized bins.
    combined_score = proximity_score * fullness_bonus
    
    # Normalize scores to [0, 1] for better comparability and to avoid extreme values.
    # Add a small epsilon to avoid division by zero if all scores are zero.
    max_score = np.max(combined_score)
    if max_score > 1e-9:
        priorities[can_fit_mask] = combined_score / max_score
    else:
        # If all combined scores are near zero (e.g., only very large gaps available)
        # fallback to a simple proximity score, normalized.
        max_proximity = np.max(proximity_score)
        if max_proximity > 1e-9:
            priorities[can_fit_mask] = proximity_score / max_proximity

    return priorities
```
