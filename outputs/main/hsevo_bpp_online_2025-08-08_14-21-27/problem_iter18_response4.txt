```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:
    """
    A multi-objective priority function that balances:
    1. Best Fit: Minimizing leftover space after packing the current item.
    2. Fill Level Awareness: Prioritizing bins that are already relatively full,
       to encourage consolidating items.
    3. Item Size Adaptability: Adjusting the emphasis on fill level based on
       the current item's size relative to the bin capacity. Larger items
       might benefit more from prioritizing existing fuller bins to avoid
       creating many partially filled bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]
    fittable_bin_indices = np.where(fittable_bins_mask)[0]

    # Component 1: Best Fit Score
    # Higher score for bins that leave less remaining capacity.
    # Add epsilon to prevent division by zero.
    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)

    # Component 2: Fill Level Awareness
    # Higher score for bins that are more full (less remaining capacity).
    # Normalize by bin_capacity to get a relative fill level.
    # Use inverse of remaining capacity for higher score when capacity is low.
    fill_level_scores = (bin_capacity - fittable_bins_remain_cap) / bin_capacity

    # Component 3: Item Size Adaptability
    # This component modifies the weight given to the fill level based on item size.
    # If the item is large relative to bin capacity, we might want to be more
    # aggressive in filling existing bins.
    # We use a sigmoid-like function to smoothly transition from low to high emphasis.
    # Small items (item/bin_capacity close to 0) get low adaptability weight.
    # Large items (item/bin_capacity close to 1) get high adaptability weight.
    # Additive scaling factor for smooth transition, tunable.
    adaptability_factor = 0.5 * (1.0 / (1.0 + np.exp(-5 * (item / bin_capacity - 0.5))))

    # Combine the scores with adaptive weights
    # Best Fit is the primary driver.
    # Fill Level score is modulated by the adaptability factor.
    # Weight for fill_level_scores is adaptability_factor.
    # Weight for best_fit_scores is 1.0.
    # We want higher scores to be better.
    combined_scores = best_fit_scores + (fill_level_scores * adaptability_factor)

    # Normalize the combined scores for the fittable bins to a [0, 1] range.
    if np.max(combined_scores) > 1e-9:
        normalized_scores = np.clip(combined_scores / np.max(combined_scores), 0, 1)
        priorities[fittable_bin_indices] = normalized_scores
    else:
        # If all scores are near zero (e.g., very small item and many bins with similar large capacity),
        # assign a small uniform priority to fittable bins to ensure a selection.
        priorities[fittable_bin_indices] = 0.1

    return priorities
```
