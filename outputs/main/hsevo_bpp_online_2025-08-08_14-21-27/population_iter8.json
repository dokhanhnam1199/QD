[
  {
    "stdout_filepath": "problem_iter8_response0.txt_stdout.txt",
    "code_path": "problem_iter8_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a \"fill ratio\" bonus. Prioritizes bins that fit the item snugly\n    and are already relatively full, aiming for denser packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    eligible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(eligible_bins_mask):\n        return priorities\n\n    eligible_bins_caps = bins_remain_cap[eligible_bins_mask]\n\n    # Score 1: Best Fit - favors bins with minimal remaining capacity after packing.\n    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)\n\n    # Score 2: Fill Ratio - favors bins that are already more full.\n    # Using the ratio of current capacity to maximum possible capacity for fitting bins.\n    max_eligible_cap = np.max(eligible_bins_caps)\n    fill_ratio_scores = eligible_bins_caps / (max_eligible_cap + 1e-9)\n\n    # Combine scores multiplicatively: prioritize bins that are both a good fit and already full.\n    combined_scores = best_fit_scores * fill_ratio_scores\n\n    # Assign combined scores to the priorities array\n    priorities[eligible_bins_mask] = combined_scores\n\n    # Normalize priorities to the range [0, 1] for consistent comparison.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": null,
    "response_id": 1,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Invalid response!"
  },
  {
    "stdout_filepath": "problem_iter8_response2.txt_stdout.txt",
    "code_path": "problem_iter8_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a penalty for very small remaining capacity,\n    favoring tight fits while slightly discouraging bins that become overly full.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fitting_bins_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Inverse of remaining capacity after placement.\n    # Higher score for bins that leave less capacity (tighter fit).\n    best_fit_scores = 1.0 / (fitting_bins_cap - item + 1e-9)\n\n    # Adaptive Penalty for Small Residuals: Penalize bins that leave a very small remainder.\n    # This aims to avoid situations where a bin is *too* full, potentially leaving no room\n    # for even slightly larger items later. We use an inverse relationship with the remainder.\n    # A small remainder (e.g., 0.1) gets a lower penalty score (e.g., 0.1 / (0.1 + 0.5) ~ 0.16),\n    # while a larger remainder (e.g., 10) gets a higher penalty score (e.g., 10 / (10 + 0.5) ~ 0.95).\n    # We want to *discourage* very small remainders, so we'll use this score to adjust the best_fit_scores.\n    # Specifically, we'll multiply the best_fit_scores by a factor that decreases as the remainder gets smaller.\n    # Let's invert this penalty concept: a *good* residual quality score should be *high* for moderate remainders.\n    # Instead of penalty, let's frame it as a \"residual quality bonus\" where small residuals are penalized.\n    # A simple penalty function for small residuals: exp(-residual / sensitivity)\n    # Where sensitivity is a parameter controlling how quickly the penalty kicks in.\n    sensitivity = 2.0  # Controls how strongly small remainders are penalized.\n    residual_quality_factor = np.exp(-(fitting_bins_cap - item) / sensitivity)\n\n\n    # Combine scores: Multiply Best Fit by the residual quality factor.\n    # This prioritizes tight fits (high best_fit_scores) but reduces their priority\n    # if they leave an extremely small remainder (low residual_quality_factor).\n    combined_scores = best_fit_scores * residual_quality_factor\n\n    # Normalize combined scores to [0, 1] to make them comparable across different calls.\n    max_score = np.max(combined_scores)\n    if max_score > 1e-9:\n        priorities[fittable_bins_mask] = combined_scores / max_score\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best-Fit proximity with a fill ratio bonus, prioritizing tight fits\n    and the utilization of already fuller bins for better overall packing.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities\n\n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n    differences = fitting_bins_cap - item\n\n    # Best-Fit component: Higher score for smaller remaining capacity after fitting\n    # Add a small epsilon to prevent division by zero for perfect fits.\n    best_fit_score = 1.0 / (differences + 1e-9)\n\n    # Fill Ratio component: Bonus for bins that are already more utilized.\n    # Use the inverse of remaining capacity as a proxy for fullness relative to bin size.\n    # Normalize by the maximum remaining capacity to get a relative fullness score.\n    max_total_capacity = np.max(bins_remain_cap) # Assuming all bins have same max capacity\n    fill_ratio_bonus = fitting_bins_cap / (max_total_capacity + 1e-9)\n\n    # Combine scores multiplicatively, giving weight to both tight fit and fullness.\n    # The addition of 1 to fill_ratio_bonus ensures that even less full bins\n    # contribute positively to the score, preventing zeroing out the best_fit_score.\n    combined_scores = best_fit_score * (1 + fill_ratio_bonus * 0.7) # Tunable weight for bonus\n\n    priorities[can_fit_mask] = combined_scores\n\n    # Normalize priorities to ensure the highest score is 1.0 for consistent selection.\n    max_priority = np.max(priorities[can_fit_mask])\n    if max_priority > 0:\n        priorities[can_fit_mask] /= max_priority\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response4.txt_stdout.txt",
    "code_path": "problem_iter8_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit (proximity) with an adaptive bonus for bins that\n    leave a smaller residual capacity after packing, encouraging tighter fits.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n    \n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n    \n    if fitting_bins_cap.size > 0:\n        differences = fitting_bins_cap - item\n        # Base score: Inverse of residual capacity (Best Fit)\n        proximity_score = 1.0 / (differences + 1e-9)\n        \n        # Adaptive bonus: Penalize larger residuals more heavily (e.g., squared difference)\n        # This encourages bins where the difference is small.\n        adaptive_bonus = 1.0 / (differences**2 + 1e-9)\n        \n        # Combine scores: Multiplicative combination. Prioritize bins that are\n        # both good fits and have small residuals.\n        combined_score = proximity_score * adaptive_bonus\n        \n        # Normalize to ensure the best bin gets a score of 1.0\n        max_score = np.max(combined_score)\n        if max_score > 0:\n            priorities[can_fit_mask] = combined_score / max_score\n            \n        # Ensure that even if the adaptive bonus causes issues with very small differences,\n        # the proximity score still plays a role. This is a safeguard.\n        # If the combined score is still very low or zero for a fitting bin,\n        # boost it with its proximity score if it's higher.\n        priorities[can_fit_mask] = np.maximum(priorities[can_fit_mask], proximity_score / np.max(proximity_score + 1e-9))\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a fill-ratio bonus, favoring bins that are both a good fit and already utilized.\n    This heuristic prioritizes bins that are nearly full and leave minimal residual capacity.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Filter bins that can fit the item\n    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    \n    # Calculate the remaining capacity after fitting the item\n    remaining_capacity_after_fit = fitting_bins_remain_cap - item\n    \n    # --- Best Fit Component ---\n    # Score is inversely proportional to the residual capacity after fitting.\n    # Adding a small epsilon to avoid division by zero.\n    # A score of 1.0 means the bin is perfectly filled after adding the item.\n    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)\n    \n    # --- Fill Ratio Component ---\n    # Assumes a default bin capacity of 1.0.\n    # Fill ratio is the proportion of capacity already used. Higher is better.\n    bin_capacity = 1.0 \n    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity\n    fill_ratio_score = current_fill_ratio\n    \n    # --- Combined Score ---\n    # Multiply proximity score by fill ratio score.\n    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).\n    # The idea is to prefer bins that are already \"almost full\" and can still accommodate the item snugly.\n    combined_score = proximity_score * fill_ratio_score\n    \n    # --- Refinement: Ensure proximity is considered for empty bins ---\n    # If a bin was empty (fill_ratio=0), combined_score would be 0.\n    # We want to ensure that even in this case, the proximity score is still considered,\n    # as an empty bin might be the only option or a good first fit.\n    # We take the maximum of the combined score and the proximity score itself,\n    # effectively giving proximity score at least its due when fill ratio is zero.\n    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))\n    \n    # Add a small epsilon to all valid priorities to ensure that even if\n    # all scores are very low, they are distinct and positive, aiding tie-breaking.\n    priorities[can_fit_mask] += 1e-6\n    \n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit and a utility bonus for moderate remaining capacity.\n    Favors bins that are a tight fit but also leave some usable space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if not np.any(can_fit_mask):\n        return priorities\n\n    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item\n\n    # Best Fit component: favors bins that leave minimal remaining capacity.\n    # Higher score for smaller remaining capacity.\n    best_fit_score = 1.0 / (potential_remaining_cap + 1e-9)\n\n    # Utility component: favors bins that leave a moderate amount of capacity.\n    # This is a simplified Gaussian-like bonus, centered around item/2.\n    # It rewards bins that aren't too tight or too loose.\n    moderate_capacity_center = item / 2.0\n    utility_bonus = np.exp(-((potential_remaining_cap - moderate_capacity_center)**2) / (2 * (moderate_capacity_center**2 + 1e-9)))\n\n    # Combine scores multiplicatively: A bin must be good for both components.\n    # This balances the 'tightest fit' with the 'most useful residual space'.\n    combined_score = best_fit_score * utility_bonus\n\n    # Assign priorities to the valid bins.\n    priorities[can_fit_mask] = combined_score\n\n    # Normalize priorities to ensure relative ranking and prevent extreme values.\n    if np.any(priorities):\n        max_priority = np.max(priorities)\n        if max_priority > 1e-9:\n            priorities[can_fit_mask] /= max_priority\n        else:\n            # If all resulting priorities are near zero, assign a small uniform priority.\n            priorities[can_fit_mask] = 1e-6\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 4.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a bonus for already full bins, using a logarithmic bonus\n    to balance tight fits with encouraging fuller bins.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fittable_bins_mask = bins_remain_cap >= item\n\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]\n\n    # Best Fit Score: Higher for bins that leave less remaining capacity.\n    # Adding a small epsilon to avoid division by zero.\n    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-6)\n\n    # Fullness Bonus: A bonus for bins that are already more full.\n    # Using the inverse of remaining capacity on fittable bins.\n    # Normalize by the maximum remaining capacity among fittable bins to get a relative measure.\n    max_remaining_cap_fittable = np.max(fittable_bins_remain_cap)\n    fullness_bonus = (max_remaining_cap_fittable - fittable_bins_remain_cap) / (max_remaining_cap_fittable + 1e-6)\n\n    # Adaptive Bonus using logarithm of remaining capacity after fit.\n    # This penalizes leaving excessively large gaps but gives smaller penalties for smaller gaps.\n    # Adding 1 to prevent log(0) and ensure positive values.\n    adaptive_bonus = np.log1p(fittable_bins_remain_cap - item)\n\n    # Combine: Weighted sum of Best Fit and Fullness Bonus, with Adaptive Bonus as a modifier.\n    # Weights are heuristic and can be tuned. Here, Best Fit is primary, Fullness adds context,\n    # and the Adaptive Bonus influences the penalty for leftover space.\n    # We invert the adaptive bonus as smaller leftover space (lower log) should be better.\n    combined_scores = (best_fit_scores * 1.0) + (fullness_bonus * 0.5) - (adaptive_bonus * 0.2)\n\n    # Normalize priorities to a [0, 1] range for better comparability and to avoid extreme values.\n    if np.max(combined_scores) > 1e-9:\n        priorities[fittable_bins_mask] = np.clip(combined_scores / np.max(combined_scores), 0, 1)\n    else:\n        # If all scores are near zero, assign a small uniform priority to fittable bins.\n        priorities[fittable_bins_mask] = 0.1\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 3.9788591942560925,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response8.txt_stdout.txt",
    "code_path": "problem_iter8_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit preference with a bonus for bins that are already significantly filled,\n    aiming for efficient space utilization and minimizing the number of bins used.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n    \n    if fitting_bins_cap.size > 0:\n        differences = fitting_bins_cap - item\n        \n        # Best Fit component: Higher score for smaller remaining capacity\n        best_fit_score = 1.0 / (differences + 1e-9)\n        \n        # Fullness bonus: Reward bins that are already more utilized (closer to full)\n        # This is a simplified version of the fullness bonus from v0,\n        # focusing on the absolute remaining capacity as a proxy for fullness.\n        # Bins with less remaining capacity are considered \"more full\".\n        fullness_bonus = (np.max(bins_remain_cap) - fitting_bins_cap) / (np.max(bins_remain_cap) + 1e-9)\n        \n        # Combine scores: Additive combination. Prioritize tight fits (Best Fit)\n        # and give a boost to bins that are already quite full.\n        combined_scores = best_fit_score + fullness_bonus * 0.5 # Tunable weight for bonus\n        \n        priorities[can_fit_mask] = combined_scores\n        \n        # Normalize priorities for bins that can fit the item\n        max_priority = np.max(priorities[can_fit_mask])\n        if max_priority > 0:\n            priorities[can_fit_mask] /= max_priority\n            \n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response9.txt_stdout.txt",
    "code_path": "problem_iter8_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit proximity with an adaptive bonus for moderate remaining capacity,\n    favoring bins that are a close fit but also leave some useful space.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n\n    if fitting_bins_cap.size > 0:\n        # Best Fit proximity: Score higher for bins with smaller remaining capacity after fitting.\n        differences = fitting_bins_cap - item\n        proximity_scores = 1.0 / (differences + 1e-9)\n\n        # Adaptive \"Usefulness\" Bonus: Reward bins that leave a moderate amount of space.\n        # A logarithmic function provides diminishing returns, preventing excessively large remainders\n        # from dominating the score, while still giving a bonus for leaving more space.\n        # This encourages leaving space for future items without being overly wasteful.\n        resulting_remainders = fitting_bins_cap - item\n        \n        # We use log(1 + remainder) so that even empty bins (remainder 0) get a small base bonus,\n        # and the bonus increases with remaining space, but at a decreasing rate.\n        # A small constant is added inside log to prevent log(0) if resulting_remainders is 0.\n        adaptive_bonus = np.log(1 + resulting_remainders + 1e-9)\n        \n        # Combine proximity and adaptive bonus.\n        # The proximity score drives the heuristic towards the tightest fit.\n        # The adaptive bonus slightly counteracts pure greediness by rewarding bins\n        # that leave more space, up to a point.\n        # A multiplicative combination ensures that a good fit is still paramount,\n        # but the bonus can differentiate between equally good fits.\n        combined_scores = proximity_scores * (1 + 0.2 * adaptive_bonus) # 0.2 is a tunable parameter\n\n        # Normalize scores for the bins that can fit the item.\n        # Ensures the highest priority bin gets a score of 1.0, making priorities relative.\n        max_score = np.max(combined_scores)\n        if max_score > 0:\n            priorities[can_fit_mask] = combined_scores / max_score\n\n    return priorities",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]