```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for bins using an adaptive approach that
    prioritizes bins that are a "good fit" (not too much remaining capacity)
    while also considering bins that are "close fits" (just enough capacity).
    It also incorporates a slight penalty for bins that are *exactly* full
    to encourage more flexibility in future packing, and a bonus for bins
    that can accommodate the item with minimal waste.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_cap.size > 0:
        differences = fitting_bins_cap - item
        
        # Primary score: Inverse of the difference (proximity fit)
        # Add a small epsilon to avoid division by zero if an item perfectly fits a bin
        proximity_scores = 1.0 / (differences + 1e-9)
        
        # Secondary score: Bonus for minimal waste (closer to zero difference)
        # This emphasizes bins that are almost perfect fits
        minimal_waste_bonus = np.exp(-differences * 5.0)  # Exponentially rewards smaller differences
        
        # Tertiary consideration: Slight penalty for exact fits to encourage future flexibility
        # We do this by slightly reducing the score for bins where difference is near zero
        exact_fit_penalty = np.ones_like(differences)
        exact_fit_mask = np.abs(differences) < 1e-6
        exact_fit_penalty[exact_fit_mask] = 0.95 # Small penalty for perfect fits

        # Combine scores: Proximity as base, minimal waste as enhancement, with penalty for exact fits
        combined_scores = (proximity_scores * (1 + minimal_waste_bonus)) * exact_fit_penalty
        
        priorities[can_fit_mask] = combined_scores
        
        # Normalize priorities so that the best bin has a score of 1
        max_priority = np.max(priorities[can_fit_mask])
        if max_priority > 0:
            priorities[can_fit_mask] /= max_priority

    return priorities
```
