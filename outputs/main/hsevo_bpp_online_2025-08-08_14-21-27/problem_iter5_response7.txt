```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines the "Fill Ratio * Proximity" score with a sigmoid scaling
    to adaptively prioritize bins that are both a close fit and well-utilized,
    while amplifying differences for bins near the median fit.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    if fitting_bins_cap.size > 0:
        # Calculate Proximity: Higher score for bins closer to the item size.
        # Using 1 / (difference + epsilon) to prioritize minimal remaining capacity.
        differences = fitting_bins_cap - item
        proximity_scores = 1.0 / (differences + 1e-9)

        # Calculate Fill Ratio: Higher score for bins that are already well-utilized.
        # This penalizes bins with excessively large remaining capacities implicitly.
        fill_ratios = item / fitting_bins_cap
        
        # Combine Proximity and Fill Ratio multiplicatively.
        # This favors bins that are both a good fit (small difference) and already have
        # a high fill ratio (meaning they are not wasting much space).
        combined_scores = fill_ratios * proximity_scores
        
        # Adaptive Sigmoid Scaling: Applied to the combined scores.
        # This part aims to adapt to the distribution of fits.
        # It amplifies the differences for bins whose combined score is close to the median,
        # making the heuristic more sensitive to "average" good fits.
        median_score = np.median(combined_scores)
        k = 5.0  # Sensitivity parameter for the sigmoid. Adjust as needed.
        # Sigmoid function: 1 / (1 + exp(-k * (x - median)))
        # This function is close to 0 for x << median, 0.5 at x = median, and close to 1 for x >> median.
        # Multiplying the combined_scores by this sigmoid scales them up if they are better than the median,
        # and down if they are worse, accentuating the differences.
        adaptive_scaling = 1 / (1 + np.exp(-k * (combined_scores - median_score)))
        
        final_priorities = combined_scores * adaptive_scaling

        # Normalize the final priorities for the bins that can fit the item.
        # This ensures that the highest priority bin has a score of 1.0,
        # providing a consistent scale for comparison.
        max_priority = np.max(final_priorities)
        if max_priority > 0:
            priorities[can_fit_mask] = final_priorities / max_priority

    return priorities
```
