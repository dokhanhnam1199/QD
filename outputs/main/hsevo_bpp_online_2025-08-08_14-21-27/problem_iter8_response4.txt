```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (proximity) with an adaptive bonus for bins that
    leave a smaller residual capacity after packing, encouraging tighter fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_cap.size > 0:
        differences = fitting_bins_cap - item
        # Base score: Inverse of residual capacity (Best Fit)
        proximity_score = 1.0 / (differences + 1e-9)
        
        # Adaptive bonus: Penalize larger residuals more heavily (e.g., squared difference)
        # This encourages bins where the difference is small.
        adaptive_bonus = 1.0 / (differences**2 + 1e-9)
        
        # Combine scores: Multiplicative combination. Prioritize bins that are
        # both good fits and have small residuals.
        combined_score = proximity_score * adaptive_bonus
        
        # Normalize to ensure the best bin gets a score of 1.0
        max_score = np.max(combined_score)
        if max_score > 0:
            priorities[can_fit_mask] = combined_score / max_score
            
        # Ensure that even if the adaptive bonus causes issues with very small differences,
        # the proximity score still plays a role. This is a safeguard.
        # If the combined score is still very low or zero for a fitting bin,
        # boost it with its proximity score if it's higher.
        priorities[can_fit_mask] = np.maximum(priorities[can_fit_mask], proximity_score / np.max(proximity_score + 1e-9))

    return priorities
```
