{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Richard Feynman's \"Quantum Hop\" Priority for Bin Packing:\n    Let's think about this. We've got these items, right? And we've got these bins.\n    We want to pack 'em up, neat and tidy, with as few bins as possible.\n    It's like trying to fit all your thoughts into your brain, and you want to do it efficiently, so you don't get cluttered.\n\n    Now, with this \"Random Fit\" business, it's not about being perfectly clever every time.\n    It's more like... a hunch. A good guess. Sometimes, you gotta just pick a path and see where it leads.\n    We get an item, a new thought, and we have these bins, these mental compartments, each with some space left.\n    We want to assign a \"priority\" to each bin, saying how good a fit it *might* be.\n\n    My idea? Let's give a higher priority to bins that are *almost* full, but not *too* full.\n    Why? Because if a bin is almost full, putting this item in might just finish it off, or at least make it quite full. That's a good use of space, a satisfying \"closure.\"\n    But if a bin is practically empty, or if the item *barely* fits, well, that doesn't feel as right. It's like trying to cram a tiny pebble into a vast stadium \u2013 it doesn't quite *fill* the purpose.\n\n    So, for each bin, let's calculate this \"priority score.\"\n    It's like a little dance.\n    If the item fits in the bin (capacity >= item), that's a good start. No priority if it doesn't fit \u2013 that's a no-go zone.\n    If it fits, how much space is left *after* we put the item in? That's `bins_remain_cap - item`.\n    We want this remaining space to be small, but not negative (that's why we checked `bins_remain_cap >= item`).\n    Let's say `residual_capacity = bins_remain_cap - item`.\n    Now, we want to maximize the \"goodness\" of this residual capacity.\n    If `residual_capacity` is zero, that's perfect! The bin is full. Max priority.\n    If `residual_capacity` is small and positive, that's also good. High priority.\n    If `residual_capacity` is large, that's not as great. We're not using the bin efficiently. Lower priority.\n\n    So, let's try this:\n    For each bin, if the item fits:\n        Calculate the leftover space: `leftover = bin_capacity - item`\n        The priority is inversely related to `leftover`. More leftover, less priority.\n        A simple way to do this is to make the priority proportional to `1 / (1 + leftover)`.\n        This way, if `leftover` is 0, priority is 1. If `leftover` is large, priority approaches 0.\n\n    What if the item doesn't fit? The priority is 0. A firm no.\n\n    Let's put it all together.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fits_mask = bins_remain_cap >= item\n    residual_capacity = bins_remain_cap[fits_mask] - item\n    \n    # We want to give a higher priority to bins with less residual capacity after packing.\n    # A residual capacity of 0 is ideal. Large residual capacity is less ideal.\n    # The formula 1 / (1 + residual_capacity) captures this:\n    # If residual_capacity is 0, priority is 1 / (1 + 0) = 1.\n    # If residual_capacity is large, say 100, priority is 1 / (1 + 100) = 1/101, which is small.\n    # This gives a \"quantum hop\" towards the more filled bins without being too rigid.\n    priorities[fits_mask] = 1.0 / (1.0 + residual_capacity)\n    \n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    eligible_bins_mask = bins_remain_cap >= item\n    eligible_bins_remain_cap = bins_remain_cap[eligible_bins_mask]\n    \n    if eligible_bins_remain_cap.size > 0:\n        \n        inverse_distance = 1.0 / (bins_remain_cap[eligible_bins_mask] - item + 1e-9)\n        \n        priorities[eligible_bins_mask] = inverse_distance\n        \n        \n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    First Fit strategy with a priority score that favors bins with minimal remaining capacity\n    that can still accommodate the item. This encourages tighter packing and potentially\n    leaving larger bins available for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Assign priorities only to bins that can fit the item\n    # The priority is inversely proportional to the remaining capacity.\n    # A smaller remaining capacity (but still fitting) gets a higher priority.\n    # Add a small epsilon to avoid division by zero if a bin has exactly item size remaining.\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)\n    \n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins_mask = bins_remain_cap >= item\n    remaining_caps_for_valid_bins = bins_remain_cap[valid_bins_mask]\n    diffs = remaining_caps_for_valid_bins - item\n    priorities[valid_bins_mask] = 1.0 / (1.0 + diffs)\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    First Fit strategy with a priority score that favors bins with minimal remaining capacity\n    that can still accommodate the item. This encourages tighter packing and potentially\n    leaving larger bins available for future larger items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Assign priorities only to bins that can fit the item\n    # The priority is inversely proportional to the remaining capacity.\n    # A smaller remaining capacity (but still fitting) gets a higher priority.\n    # Add a small epsilon to avoid division by zero if a bin has exactly item size remaining.\n    priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] - item + 1e-9)\n    \n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i, capacity in enumerate(bins_remain_cap):\n        if capacity >= item:\n            priorities[i] = 1.0 / (capacity - item + 1e-9)\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins_mask = bins_remain_cap >= item\n    remaining_caps_for_valid_bins = bins_remain_cap[valid_bins_mask]\n    diffs = remaining_caps_for_valid_bins - item\n    priorities[valid_bins_mask] = 1.0 / (1.0 + diffs)\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Exploration rate\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    fittable_bins_mask = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    # Greedy choice: Prioritize bins with the least remaining capacity after placing the item\n    # This encourages filling bins more completely.\n    greedy_scores = 1.0 / (bins_remain_cap[fittable_bins_mask] - item + 1e-9) # Add epsilon for division by zero\n\n    # Epsilon-Greedy strategy:\n    # With probability epsilon, choose a random fittable bin.\n    # With probability 1-epsilon, choose the bin with the highest greedy score.\n\n    num_fittable_bins = np.sum(fittable_bins_mask)\n    random_indices = np.random.choice(num_fittable_bins, size=int(epsilon * num_fittable_bins), replace=True)\n    random_fittable_bins_mask = np.zeros(num_fittable_bins, dtype=bool)\n    random_fittable_bins_mask[random_indices] = True\n\n    # Assign high priority to randomly chosen bins\n    priorities[fittable_bins_mask][random_fittable_bins_mask] = 1.0\n\n    # Assign greedy scores to the remaining fittable bins\n    non_random_fittable_indices = np.where(~random_fittable_bins_mask)[0]\n    priorities[fittable_bins_mask][non_random_fittable_indices] = greedy_scores[non_random_fittable_indices]\n\n    # Normalize priorities to be between 0 and 1\n    if np.max(priorities) > 0:\n        priorities /= np.max(priorities)\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    available_bins_mask = bins_remain_cap >= item\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    if np.any(available_bins_mask):\n        available_bins_cap = bins_remain_cap[available_bins_mask]\n        \n        differences = available_bins_cap - item\n        \n        max_diff_index = np.argmax(differences)\n        \n        priorities[available_bins_mask][max_diff_index] = 1.0\n        \n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    \n    if not np.any(valid_bins_mask):\n        return np.zeros_like(bins_remain_cap)\n\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n    \n    utility = valid_bins_remain_cap - item\n    \n    exp_utility = np.exp(utility)\n    \n    probabilities = exp_utility / np.sum(exp_utility)\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins_mask] = probabilities\n    \n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Exploration rate\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    fittable_bins_mask = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    # Greedy choice: Prioritize bins with the least remaining capacity after placing the item\n    # This encourages filling bins more completely.\n    greedy_scores = 1.0 / (bins_remain_cap[fittable_bins_mask] - item + 1e-9) # Add epsilon for division by zero\n\n    # Epsilon-Greedy strategy:\n    # With probability epsilon, choose a random fittable bin.\n    # With probability 1-epsilon, choose the bin with the highest greedy score.\n\n    num_fittable_bins = np.sum(fittable_bins_mask)\n    random_indices = np.random.choice(num_fittable_bins, size=int(epsilon * num_fittable_bins), replace=True)\n    random_fittable_bins_mask = np.zeros(num_fittable_bins, dtype=bool)\n    random_fittable_bins_mask[random_indices] = True\n\n    # Assign high priority to randomly chosen bins\n    priorities[fittable_bins_mask][random_fittable_bins_mask] = 1.0\n\n    # Assign greedy scores to the remaining fittable bins\n    non_random_fittable_indices = np.where(~random_fittable_bins_mask)[0]\n    priorities[fittable_bins_mask][non_random_fittable_indices] = greedy_scores[non_random_fittable_indices]\n\n    # Normalize priorities to be between 0 and 1\n    if np.max(priorities) > 0:\n        priorities /= np.max(priorities)\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 0.1  # Exploration rate\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    fittable_bins_mask = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros\n    if not np.any(fittable_bins_mask):\n        return priorities\n\n    # Greedy choice: Prioritize bins with the least remaining capacity after placing the item\n    # This encourages filling bins more completely.\n    greedy_scores = 1.0 / (bins_remain_cap[fittable_bins_mask] - item + 1e-9) # Add epsilon for division by zero\n\n    # Epsilon-Greedy strategy:\n    # With probability epsilon, choose a random fittable bin.\n    # With probability 1-epsilon, choose the bin with the highest greedy score.\n\n    num_fittable_bins = np.sum(fittable_bins_mask)\n    random_indices = np.random.choice(num_fittable_bins, size=int(epsilon * num_fittable_bins), replace=True)\n    random_fittable_bins_mask = np.zeros(num_fittable_bins, dtype=bool)\n    random_fittable_bins_mask[random_indices] = True\n\n    # Assign high priority to randomly chosen bins\n    priorities[fittable_bins_mask][random_fittable_bins_mask] = 1.0\n\n    # Assign greedy scores to the remaining fittable bins\n    non_random_fittable_indices = np.where(~random_fittable_bins_mask)[0]\n    priorities[fittable_bins_mask][non_random_fittable_indices] = greedy_scores[non_random_fittable_indices]\n\n    # Normalize priorities to be between 0 and 1\n    if np.max(priorities) > 0:\n        priorities /= np.max(priorities)\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    possible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    if not np.any(possible_bins):\n        return priorities\n\n    remaining_capacities_for_possible = bins_remain_cap[possible_bins]\n    \n    differences = remaining_capacities_for_possible - item\n    \n    k = 10.0 \n    \n    sigmoid_scores = 1 / (1 + np.exp(-k * (differences - np.median(differences))))\n    \n    priorities[possible_bins] = sigmoid_scores\n    \n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    eligible_bins_mask = bins_remain_cap >= item\n    \n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    eligible_bins_remain_cap = bins_remain_cap[eligible_bins_mask]\n    \n    if eligible_bins_remain_cap.size > 0:\n        \n        utility = eligible_bins_remain_cap - item\n        \n        exp_utility = np.exp(utility)\n        \n        probabilities = exp_utility / np.sum(exp_utility)\n        \n        priorities[eligible_bins_mask] = probabilities\n        \n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    fits = bins_remain_cap >= item\n    valid_bins_cap = bins_remain_cap[fits]\n    if valid_bins_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    \n    diffs = valid_bins_cap - item\n    \n    \n    scaled_diffs = (diffs - np.min(diffs)) / (np.max(diffs) - np.min(diffs) + 1e-9)\n\n    \n    priorities = 1 / (1 + np.exp(-10 * (scaled_diffs - 0.5)))\n\n    \n    final_priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    final_priorities[fits] = priorities\n    \n    return final_priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    priorities[valid_bins] = bins_remain_cap[valid_bins] - item\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}