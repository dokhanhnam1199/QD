```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an adaptive fill ratio bonus, prioritizing tight fits
    that also contribute to fuller bins, weighted by item size.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # --- Best Fit Component ---
    # Score based on how little capacity is left after fitting.
    # Higher score for smaller remaining capacity.
    best_fit_score = 1.0 / (fitting_bins_remain_cap - item + 1e-9)
    
    # --- Adaptive Fill Ratio Component ---
    # This component encourages filling bins more, but it's modulated by how large the item is relative to the bin's capacity.
    # If an item is a large fraction of the bin's total capacity, we slightly de-emphasize the fill ratio contribution
    # to avoid over-packing small items into partially filled bins at the expense of better fits for larger items.
    # Assume a nominal bin capacity of 1.0 for fill ratio calculation.
    bin_capacity = 1.0
    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity
    
    # Adaptive weight for fill ratio: Higher weight for smaller items relative to bin capacity.
    # We want to encourage filling, but more so for smaller items that are less likely to "ruin" a bin for future items.
    # The item_size_ratio helps normalize this. A small item (e.g., 0.1) gets a higher weight (e.g., 1.0 / (0.1+1) = 0.9)
    # A large item (e.g., 0.8) gets a lower weight (e.g., 1.0 / (0.8+1) = 0.55).
    # We add 1 to the denominator to ensure the weight is <= 1 and to avoid issues when item_size_ratio is 0.
    item_size_ratio = item / bin_capacity 
    adaptive_fill_weight = 1.0 / (item_size_ratio + 1.0)

    fill_ratio_score = current_fill_ratio * adaptive_fill_weight
    
    # --- Combined Score ---
    # Multiplicatively combine Best Fit and the weighted Fill Ratio.
    # This prioritizes bins that are both a tight fit and contribute to overall bin fullness,
    # with the fill ratio component being more influential for smaller items.
    combined_score = best_fit_score * (1 + fill_ratio_score) # Add 1 to fill_ratio_score to ensure it boosts, not reduces, the BF score if fill_ratio_score is small.
    
    # Normalize scores to [0, 1]
    max_score = np.max(combined_score)
    if max_score > 1e-9:
        priorities[can_fit_mask] = combined_score / max_score
    else: # Handle cases where all scores are zero or near-zero
        priorities[can_fit_mask] = 1.0 / (len(fitting_bins_remain_cap) + 1e-9) # Give equal priority if no clear differentiator

    return priorities
```
