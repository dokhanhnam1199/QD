```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]
    fittable_indices = np.where(fittable_bins_mask)[0]

    # Component 1: Best Fit - Prioritize bins that leave minimal remaining capacity.
    # This encourages tighter packing. Use inverse of remaining space + epsilon.
    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)

    # Component 2: Worst Fit Incentive - Prioritize bins that have a larger remaining capacity
    # among the fittable bins. This aims to keep smaller remaining capacities available for
    # smaller items later, potentially leading to fewer bins being used overall.
    # Calculate the gap created if the item is placed, and then rank bins by the *largest* gap.
    gaps = fittable_bins_remain_cap - item
    worst_fit_score = gaps # Higher gap is better here.

    # Component 3: Proximity to Half-Capacity Bonus - This heuristic aims to balance bins
    # around the mid-point of their capacity. Bins that, after fitting, are closer to
    # half-full might be more versatile for future items.
    # We are interested in bins where (remaining_cap - item) is close to bin_capacity / 2.
    # For simplicity, we can approximate this by looking at the remaining capacity
    # relative to a "medium" size. Let's consider bins that, after fitting the item,
    # have a remaining capacity that is not too small and not too large.
    # A score that peaks when remaining_cap - item is around some threshold (e.g., 0.5 * bin_capacity).
    # For simplicity here, let's use a score that is high when the remaining capacity
    # after fit is "reasonable" (not too close to 0, not too close to full).
    # This is a simplification, a more robust approach might involve estimating typical item sizes.
    # For now, we'll use a score that is high when the leftover space is moderate.
    # A simple Gaussian-like function centered around a moderate leftover space.
    # Let's assume a moderate leftover space is around 0.3 of the original bin capacity.
    # Since we don't know the original bin capacity, we can use a proxy like the average
    # remaining capacity of fittable bins. This is heuristic.
    avg_fittable_remain_cap = np.mean(fittable_bins_remain_cap)
    # Score is higher when (fittable_bins_remain_cap - item) is closer to avg_fittable_remain_cap
    # We can use a Gaussian-like function, or simpler: penalize extremes.
    # Let's reward bins that leave a moderate amount of space, not too little (handled by BF)
    # and not too much (handled by WF).
    # Score is higher for leftover space that is not too small (but not too large either).
    # Let's consider the relative leftover space.
    relative_leftover = (fittable_bins_remain_cap - item) / (np.max(fittable_bins_remain_cap) + 1e-9)
    # We want to favor bins where relative_leftover is in a middle range, e.g., 0.2 to 0.7.
    # A simple approach: penalize very small or very large relative leftovers.
    # This is tricky without knowing the distribution of item sizes or bin capacities.
    # A simpler proxy: favor bins that are not already almost full, but also not almost empty.
    # Let's use a score that is higher for bins that are neither very full nor very empty.
    # This can be seen as a "balance" score.
    balance_score = (fittable_bins_remain_cap - item) / (fittable_bins_remain_cap + 1e-9) # Score closer to 1 means less remaining space.
    # We want to reward bins that have *some* remaining space, but not excessive.
    # So we want balance_score to be less than 1.
    # Let's invert it: higher score for more remaining space, capped.
    # Alternatively, prioritize bins that are "medium" full.
    # Consider remaining capacity as a proportion of total capacity (which is unknown, assume 1.0 for normalized).
    # A score that peaks when remaining_cap - item is around 0.5.
    # Let's simplify: reward bins that have a moderate remaining capacity after fitting.
    # This is inherently difficult without knowledge of total capacity.
    # Alternative interpretation of "balance": favor bins that are not too empty after fitting.
    # This means favoring bins where fittable_bins_remain_cap - item is not extremely small.
    # This is implicitly handled by Best Fit to some extent.

    # Let's try a different approach for Component 3: Affinity for a "central" remaining capacity.
    # Suppose we want to keep bins with remaining capacities in a mid-range.
    # This is hard to define without bin capacity.
    # A simpler approach: Reward bins that are not *too* full after placing the item.
    # Penalize bins that would become very full.
    # Score = 1 - (remaining_cap - item) / max_possible_remaining_space (which is max(bins_remain_cap))
    # This is similar to penalizing tight fits.

    # Let's combine Best Fit and Worst Fit with a multiplicative approach,
    # and add a term that encourages moderate usage of bins.
    # Multiplicative combines scores more aggressively.

    # Normalize component scores to a comparable range, e.g., [0, 1] or similar.
    # Best Fit: Already inverse, higher is better. Max value can be large.
    # Worst Fit: Higher gap is better. Max value can be large.
    # Let's normalize gaps to be in [0, 1] where 1 is the largest gap.
    normalized_worst_fit = gaps / (np.max(gaps) + 1e-9)

    # Let's try a score that favors bins that aren't too full, but also not too empty.
    # A score that is higher when the remaining capacity after fit is moderate.
    # This is hard without knowing the bin capacity.
    # Alternative: Reward bins that are "moderately used".
    # If we consider the remaining capacity `r` after fitting item `i`, we want `r` not too small and not too large.
    # A simple score could be: `exp(-k * (r - target_r)^2)`. But `target_r` is unknown.
    # Let's try a score that is higher for bins that have *some* remaining space, but not a lot.
    # This is difficult to formulate generally.

    # Let's reconsider the objective: Minimize the number of bins.
    # Heuristics typically aim to either:
    # 1. Pack tightly (Best Fit) to reduce wasted space *within* a bin.
    # 2. Leave larger gaps (Worst Fit) to accommodate potentially larger future items.
    # 3. Fill bins "evenly" (First Fit Decreasing style).

    # For v2, let's prioritize bins that are *close* to fitting the item (Best Fit aspect),
    # AND among those that are a "good fit", prefer those that are *more full* overall
    # (but not so full they become unusable later), and also slightly favor those that leave
    # a decent remaining space (Worst Fit aspect).

    # Let's try a weighted additive combination with focus on robustness and interaction.
    # Score = w1 * (BestFit) + w2 * (WorstFit) + w3 * (ModerateRemaining)

    # Best Fit score: Higher for smaller leftover space.
    # Let's scale it by the item size itself. The smaller the leftover relative to item size, the better.
    # scaled_best_fit = 1.0 / ((fittable_bins_remain_cap - item) / item + 1e-9)
    # This can be unstable if item size is small. Let's stick to inverse of absolute leftover.
    best_fit_term = 1.0 / (fittable_bins_remain_cap - item + 1e-9)

    # Worst Fit score: Higher for larger leftover space.
    # Let's normalize by the maximum possible leftover space.
    # Max leftover space can be the max remaining capacity among fittable bins.
    max_fittable_rem = np.max(fittable_bins_remain_cap)
    worst_fit_term = (fittable_bins_remain_cap - item) / (max_fittable_rem + 1e-9)

    # New component: "Bin Utilization Balance"
    # Favor bins that are not excessively empty or excessively full after fitting.
    # Consider the remaining capacity `r = fittable_bins_remain_cap[i] - item`.
    # We want `r` to be neither too close to 0 nor too close to `fittable_bins_remain_cap[i]`.
    # A simple score: The more remaining capacity, the less "balanced" it is in terms of filling.
    # However, we want to balance *usage*, not necessarily remaining space.
    # Let's try to encourage bins that are "moderately full".
    # If `fittable_bins_remain_cap[i]` is the current remaining capacity, and `item` is placed.
    # The *new* remaining capacity is `r = fittable_bins_remain_cap[i] - item`.
    # We want `r` to be "reasonable".
    # Consider the ratio of current remaining capacity to the capacity used.
    # Current remaining capacity: `c`. Item size: `i`. New remaining capacity: `c - i`.
    # Capacity used: `TotalCapacity - c`. Capacity used by item: `i`.
    # Let's consider the proportion of remaining capacity relative to the *original* bin capacity.
    # Since original bin capacity is unknown, let's use the *current* remaining capacity as a proxy for how "full" the bin is.
    # A bin with high `fittable_bins_remain_cap` is less full.
    # We want bins that are not too empty. So, `fittable_bins_remain_cap[i]` shouldn't be extremely large.
    # Let's create a score that penalizes bins that have a very large remaining capacity.
    # Higher score for smaller `fittable_bins_remain_cap`.
    # Let's use inverse of remaining capacity, but capped.
    # Or, inverse of remaining capacity to the power of some factor.
    # Let's try: `fittable_bins_remain_cap[i] / (fittable_bins_remain_cap[i] + item)` - proportion of capacity already filled with current item.
    # This doesn't consider the bin's state.

    # Let's try a score that promotes bins that are *not* almost full, and also *not* almost empty.
    # This is the "balanced" idea.
    # Score for being "not too empty": penalize large `fittable_bins_remain_cap`.
    # Score for being "not too full": penalize small `fittable_bins_remain_cap - item`.
    # This is conflicting with Best Fit.

    # Let's refine the idea of balancing: Aim for bins where the remaining capacity after fitting
    # is not too small (to avoid wasting tiny gaps) and not too large (to encourage fuller bins).
    # This is like a soft "Best Fit" and a soft "Worst Fit" simultaneously.

    # Let's consider the "effective remaining capacity" as `fittable_bins_remain_cap - item`.
    # We want this to be small (BestFit) but not too small.
    # And we want the bin to not be excessively full.
    # The previous v1 used `log1p(fittable_bins_remain_cap - item)` which penalizes larger gaps.
    # We want to penalize *very small* gaps and *very large* gaps.

    # Let's try a score that combines Best Fit and Worst Fit multiplicatively,
    # and add a term that rewards bins that are "medium" full.
    # Multiplicative combination: `(BestFitTerm) * (WorstFitTerm) * (MediumFillTerm)`
    # This requires all terms to be positive and well-behaved.

    # Let's define terms for the fittable bins:
    # Term 1: Tightness score (Best Fit proxy) - higher for less remaining space.
    # Score is proportional to 1 / (remaining_cap - item).
    tightness_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)

    # Term 2: Gap score (Worst Fit proxy) - higher for more remaining space.
    # Score is proportional to (remaining_cap - item).
    gap_score = fittable_bins_remain_cap - item

    # Term 3: Balance score - Higher for moderate remaining capacity.
    # This is tricky without bin capacity. Let's assume we want remaining capacity to be
    # in a "central" range. If the max remaining capacity among fittable bins is `M`,
    # we might want `fittable_bins_remain_cap[i] - item` to be around `M/2` or `item`.
    # Let's try a score that is higher when `fittable_bins_remain_cap[i] - item` is
    # not extremely small and not extremely large.
    # A Gaussian-like score: `exp(-k * (gap - target_gap)^2)`.
    # Let's simplify: penalize bins that leave very little space and bins that leave very much space.
    # This can be achieved by penalizing `gap` near 0 and `gap` near `max_fittable_rem`.
    # A score that is high in the middle range of gaps.
    # We can use a function like `sin(pi * gap / (max_fittable_rem + epsilon))` which peaks at `max_fittable_rem / 2`.
    # Or a simple heuristic: favor bins that are not already mostly full.
    # Let's consider the ratio of `item` to `fittable_bins_remain_cap`. A higher ratio means the item fills more of the *available* space.
    # `item / fittable_bins_remain_cap` -> higher means more "efficient" use of *current* remaining space.
    # However, `fittable_bins_remain_cap` itself varies.

    # Let's try a simpler additive combination with adjusted weights and terms.
    # We want to balance tight packing (Best Fit) with leaving useful gaps (Worst Fit).
    # Add a term that considers the absolute "fullness" of the bin relative to its current state.
    # Favor bins that have a good amount of remaining capacity, but not so much that they are nearly empty.
    # This is a delicate balance.

    # Proposed v2 strategy:
    # 1. Best Fit component: score = 1 / (residual_capacity + epsilon) - promotes tight fits.
    # 2. Worst Fit component: score = residual_capacity - promotes leaving larger gaps.
    # 3. "Fill Balance" component: score = (current_remaining_cap - residual_capacity) / (current_remaining_cap + epsilon)
    #    This term represents the proportion of the bin's *current available space* that is used by the item.
    #    A higher score means the item uses a larger fraction of the *current available space*.
    #    This favors bins that are not extremely empty, but also not extremely full.
    #    If a bin has 100 capacity and item is 60, score is 60/100 = 0.6.
    #    If a bin has 10 capacity and item is 8, score is 8/10 = 0.8.
    #    This implicitly favors bins that are more full.

    # Let's redefine components for fittable bins:
    residual_capacity = fittable_bins_remain_cap - item

    # Component 1: Best Fit (inverse residual)
    # Higher score for smaller residual capacity.
    best_fit_val = 1.0 / (residual_capacity + 1e-9)

    # Component 2: Worst Fit (residual capacity itself)
    # Higher score for larger residual capacity.
    worst_fit_val = residual_capacity

    # Component 3: "Proportional Fill" - How much of the *available space* does the item consume?
    # Score = item_size / available_space = item_size / fittable_bins_remain_cap
    # This favors using up a larger chunk of the existing available space.
    # If fittable_bins_remain_cap is small, this ratio can be large.
    # This term might favor bins that are already quite full.
    proportional_fill_val = item / (fittable_bins_remain_cap + 1e-9)

    # Combine these terms. A multiplicative combination can be powerful but sensitive.
    # Let's use weighted additive combination for better control.
    # Weights can be tuned. Let's give Best Fit a primary role, Worst Fit a secondary,
    # and Proportional Fill a moderating role.

    # Normalize terms to prevent dominance by scale.
    # Best Fit: can be large. Normalize by max BF score.
    normalized_bf = best_fit_val / (np.max(best_fit_val) + 1e-9)

    # Worst Fit: range is 0 to max_fittable_rem. Normalize by max_fittable_rem.
    normalized_wf = worst_fit_val / (np.max(fittable_bins_remain_cap) + 1e-9)

    # Proportional Fill: range is 0 to 1 (if item <= fittable_bins_remain_cap).
    normalized_pf = proportional_fill_val

    # Combine with weights.
    # Let's try:
    # w_bf = 1.0
    # w_wf = 0.5  # Slightly favor leaving gaps
    # w_pf = 0.3  # Moderate preference for using a good portion of available space
    # This combination aims to find bins that are a good fit (BF), and among them,
    # favors those that leave decent gaps (WF), and also prefer bins where the item
    # consumes a noticeable fraction of the current available space (PF).

    # Let's consider a different balance: Best Fit vs. Worst Fit.
    # Standard BF puts item in bin with minimum remaining capacity.
    # Standard WF puts item in bin with maximum remaining capacity.

    # For v2, let's try to bridge BF and WF.
    # Consider bins that are "good fits" (residual_capacity not too large).
    # Among these, prefer those that are tighter (BF) but also those that leave
    # a "reasonable" gap (WF).

    # How about a score that is a combination of the "tightness" and the "gap left"?
    # Let's use a score that is higher for bins that are a good fit,
    # and among those, prefer tighter fits, but not *extreme* tight fits if they leave
    # a very large capacity unused in other bins.

    # Let's reconsider the problem as selecting a bin that offers a good trade-off.
    # Consider the score as a function of the residual capacity `r = fittable_bins_remain_cap - item`.
    # We want `r` to be small (BF) but not zero if that means leaving other bins very empty.
    # We want `r` to be moderate (WF proxy).

    # Let's try a score that is high when `r` is small and when `fittable_bins_remain_cap` is also not too large.
    # This encourages using bins that are already somewhat full.

    # New strategy: Prioritize bins that have a remaining capacity not much larger than the item itself.
    # This is a "close fit" idea, but not necessarily the absolute tightest.
    # Score = 1.0 / (abs(fittable_bins_remain_cap - item - target_gap) + epsilon)
    # Where `target_gap` could be 0 (BF), or something positive.

    # Let's try a score based on the *ratio* of residual capacity to the bin's current remaining capacity.
    # `residual_capacity / fittable_bins_remain_cap`
    # This is `(fittable_bins_remain_cap - item) / fittable_bins_remain_cap`
    # This score is lower when the bin is more full.
    # We want this score to be not too high (meaning small residual) and not too low (meaning large residual).
    # This is like a "middle ground" score for the residual.

    # Let's combine Best Fit with a penalty for leaving *too much* empty space.
    # Score = BestFitScore * (1 - penalty for large residual)
    # Penalty for large residual could be `residual / max_residual`.

    # Proposed v2: Multiplicative combination of Best Fit and a "Fill Preference".
    # Best Fit Score: 1 / (residual_capacity + epsilon). Higher is better.
    # Fill Preference Score: Favor bins that are not "too empty".
    # If `fittable_bins_remain_cap` is large, the bin is "more empty".
    # So, we want to penalize large `fittable_bins_remain_cap`.
    # Score = `1 / (fittable_bins_remain_cap + epsilon)`. Higher is better.
    # Let's try `(1 / (residual_capacity + epsilon)) * (1 / (fittable_bins_remain_cap + epsilon))`
    # This would favor bins that are both tight fits AND are already quite full.
    # This might be too aggressive on filling early bins.

    # Let's try an additive combination that balances tight fits with leaving moderate gaps.
    # Term 1: Best Fit (inverse residual capacity)
    # Term 2: Worst Fit (residual capacity)
    # Combine: `w1 * (1 / residual) + w2 * residual`
    # This form tends to have a minimum when `w1 / residual^2 = w2`, so `residual = sqrt(w1/w2)`.
    # This suggests that this combination favors residuals around a specific value.

    # Let's use weighted combination of Best Fit and a "Balance" score.
    # Best Fit: `1 / (residual_capacity + epsilon)`
    # Balance: Favor bins that are not excessively full. This means penalizing bins
    # where `fittable_bins_remain_cap` is small.
    # So, favor bins with larger `fittable_bins_remain_cap`, but not too large.
    # Let's use `fittable_bins_remain_cap` itself as a score (higher is better, means more space).
    # This is akin to Worst Fit, but we want it to be moderate.

    # Let's consider the *efficiency* of filling.
    # Score = (item_size) / (bin_capacity). This requires bin capacity.
    # Proxy: (item_size) / (fittable_bins_remain_cap + item_size)
    # This is the proportion of the *used* space relative to the *new remaining* space.
    # This is `item / new_remaining_cap`.
    # This term is higher for tight fits. It's similar to Best Fit.

    # Let's try a score that balances Best Fit and Worst Fit, using a sigmoid-like function to shape the preference.
    # `score = BF_score * (1 - WF_score)`
    # `score = (1 / residual_capacity) * (1 - residual_capacity / max_residual)`
    # This rewards small residuals, but penalizes extremely small ones if max_residual is large.

    # Let's use a weighted sum of Best Fit and Worst Fit, with an adjustment factor.
    # Final proposed v2 strategy:
    # 1. Primary: Best Fit (favoring tightness)
    # 2. Secondary: Balance (favoring bins that are not too full, but also not too empty)
    #    This balance is tricky. Let's try favoring bins where the residual capacity
    #    is not excessively large compared to the item itself.
    #    Score: `1 - residual_capacity / (item + epsilon)`
    #    This term is higher when `residual_capacity` is small relative to `item`.
    #    So, it rewards tighter fits, but also penalizes leaving *much* more space than the item's size.

    residual_capacity = fittable_bins_remain_cap - item

    # Component 1: Best Fit (inverse of residual capacity)
    # Favors bins with smallest leftover space.
    best_fit_score = 1.0 / (residual_capacity + 1e-9)

    # Component 2: Balance / Moderate Fit
    # Favor bins where the residual capacity is not excessively large compared to the item.
    # This acts as a penalty for leaving very large gaps, especially if other bins could be filled more.
    # Score is higher when residual_capacity is small relative to item size.
    # `balance_score = (item + 1e-9) / (residual_capacity + item + 1e-9)`
    # This score is close to 1 for tight fits, and close to 0 for very large residuals.
    # Let's normalize it to make it more robust.
    # A simpler approach: `1 - (residual_capacity / (item + epsilon))`
    # This score is 1 when residual is 0, and goes to -inf as residual increases.
    # Let's try `exp(-k * residual_capacity / item)` for some k.
    # Or, a capped version: `max(0, 1 - residual_capacity / (item * 2))`
    # Let's use a simpler form: favor bins whose remaining capacity `fittable_bins_remain_cap` is not overwhelmingly large.
    # Use `1 / (fittable_bins_remain_cap + epsilon)` as a proxy for "not too empty".

    # Let's use a weighted sum of Best Fit and a "Gap Management" score.
    # Best Fit: `1 / residual_capacity`
    # Gap Management: Favor residual capacities that are not too small and not too large.
    # Let's normalize residual capacity by the maximum residual capacity among fittable bins.
    # `norm_residual = residual_capacity / (np.max(residual_capacity) + 1e-9)`
    # We want to avoid `norm_residual` being too close to 0 (tight fit, covered by BF)
    # and too close to 1 (large gap).
    # A score that peaks in the middle, e.g., `1 - (2 * norm_residual - 1)^2` or similar.

    # Final proposal for v2:
    # Combine Best Fit with a term that prefers bins that are neither too empty nor too full *after* fitting.
    # This means the `residual_capacity` should be in a moderate range.
    # Let's aim for residual capacity to be roughly proportional to the item size, but not excessively so.

    # Term 1: Best Fit (inverse of residual capacity)
    best_fit_term = 1.0 / (residual_capacity + 1e-9)

    # Term 2: Moderate Residual Capacity Preference
    # We want to favor `residual_capacity` that are not extremely small (handled by BF)
    # and not extremely large.
    # Let's try to score bins based on how close their residual capacity is to the *average* residual capacity.
    # `avg_residual = np.mean(residual_capacity)`
    # `balance_score = 1.0 / (abs(residual_capacity - avg_residual) + 1e-9)`
    # This could be unstable if `avg_residual` is close to `residual_capacity`.

    # Alternative Balance Term: Favor bins that use a good fraction of their available capacity.
    # Score = `item / fittable_bins_remain_cap` (already considered).

    # Let's try a simpler weighted sum, but with more carefully chosen terms.
    # Term 1: Best Fit (tightness) - `1 / (residual_capacity + epsilon)`
    # Term 2: Fill Preference (favoring not-too-empty bins) - `fittable_bins_remain_cap` itself.
    # This favors bins that have more space, which is "Worst Fit" like.

    # Let's aim for a score that rewards tightness, but with diminishing returns for extreme tightness.
    # And also rewards leaving some space, but with diminishing returns for extreme openness.

    # Final proposed v2 using multiplicative combination for stronger interactions:
    # Score = (BestFitScore) * (BalanceScore)
    # BestFitScore = 1 / (residual_capacity + epsilon)
    # BalanceScore = how "balanced" the bin is. Let's favor bins that have
    # a moderate amount of remaining capacity after fitting.
    # If `fittable_bins_remain_cap` is the current remaining capacity, and `r` is residual.
    # We want `r` to be not too small and not too large.
    # Let's define a "good" residual range. Suppose it's `[min_res, max_res]`.
    # Score is high when `r` is in this range.
    # This is hard to define without context.

    # Let's use Best Fit and Worst Fit combined, where the combination is non-linear.
    # Consider a score that prioritizes bins with small residuals, but gives a bonus
    # if the bin was already quite full.

    # Try: Score = (BestFit) + Alpha * (FillRatio)
    # FillRatio = `item / fittable_bins_remain_cap`

    # Let's try a score that is a trade-off between Best Fit and Worst Fit.
    # Score = `(1 / residual_capacity) * (1 - residual_capacity / max_possible_gap)`
    # `max_possible_gap` can be `max(fittable_bins_remain_cap)`.
    # `score = (1 / residual_capacity) * (1 - residual_capacity / max_fittable_rem)`
    # This score peaks when `residual_capacity` is around `max_fittable_rem / 3`.

    # Let's define our v2 heuristic as:
    # Combine Best Fit with a "fill percentage" score.
    # Best Fit: `1 / (residual_capacity + epsilon)`
    # Fill Percentage: The percentage of the *current available capacity* that the item uses.
    # This is `item / fittable_bins_remain_cap`.
    # Higher fill percentage is good, means the item is utilizing a good chunk of what's available.

    # Weighted Sum:
    # `score = w1 * (1 / residual_capacity) + w2 * (item / fittable_bins_remain_cap)`
    # Weights `w1` and `w2` need tuning.

    # Normalization:
    # Max residual capacity among fittable bins.
    max_residual = np.max(residual_capacity)
    # Max value for `item / fittable_bins_remain_cap` is 1.

    # Let's try a multiplicative approach again, with normalized terms.
    # Normalized Best Fit: `(1 / residual_capacity) / max(1 / residual_capacity)`
    # Normalized Fill Percentage: `(item / fittable_bins_remain_cap) / max(item / fittable_bins_remain_cap)`
    # This can be unstable if `max` is zero or very small.

    # Let's use an additive approach with robust terms.
    # Term 1: Best Fit - `1.0 / (residual_capacity + 1e-9)`
    # Term 2: "Bin Usage Balance" - Favor bins that are not nearly empty.
    # The "fuller" a bin is, the less remaining capacity it has.
    # So, we want to favor bins with *smaller* `fittable_bins_remain_cap`.
    # Score for this: `1.0 / (fittable_bins_remain_cap + 1e-9)`
    # This term encourages using bins that are already quite full.

    # Combine: `score = w1 * (1.0 / residual_capacity) + w2 * (1.0 / fittable_bins_remain_cap)`
    # Weights `w1` and `w2` determine the trade-off.
    # `w1` for tightness, `w2` for pre-existing fullness.
    # If `w1` is high, it's like Best Fit. If `w2` is high, it prefers already full bins.

    # Let's tune weights:
    # `w1 = 1.0` (primary focus on tightness)
    # `w2 = 0.5` (secondary focus on pre-existing fullness)

    # Calculate scores for fittable bins
    best_fit_score_fittable = 1.0 / (residual_capacity + 1e-9)
    bin_fullness_score_fittable = 1.0 / (fittable_bins_remain_cap + 1e-9) # Favor bins with less remaining capacity

    # Combine scores
    combined_scores = (best_fit_score_fittable * 1.0) + (bin_fullness_score_fittable * 0.5)

    # Normalize the combined scores to a [0, 1] range.
    if np.max(combined_scores) > 1e-9:
        priorities[fittable_bins_mask] = np.clip(combined_scores / np.max(combined_scores), 0, 1)
    else:
        # If all scores are near zero, assign a small uniform priority to fittable bins.
        priorities[fittable_bins_mask] = 0.1

    return priorities
```
