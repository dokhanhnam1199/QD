```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines proximity fit with a bonus for leaving 'useful' remaining capacity,
    favoring bins that are a close fit but not so tight they leave minimal space.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    if fitting_bins_cap.size > 0:
        # Proximity Score: Higher for bins closer to the item size.
        differences = fitting_bins_cap - item
        proximity_scores = 1.0 / (differences + 1e-9)

        # Adaptive "Usefulness" Score: Penalize bins that leave very small or very large remainders.
        # A simple approach is to reward remainders that are not too small.
        # Here, we reward remainders that are greater than a small fraction of the item size.
        # This encourages leaving some space for potential future items.
        # We use a linear scaling for remainders up to a certain point, and then a decaying score.
        # For simplicity, let's reward larger remainders, but capped to avoid dominance.
        # A simpler adaptive heuristic: reward bins that leave a moderate remainder.
        # We can use 1 + (remainder / average_remainder) but that can be unstable.
        # Let's try a score that favors remainders that are a fraction of the bin's original capacity.
        # Consider a score that peaks when the remainder is around 20-30% of the bin capacity.
        
        # A more direct adaptive approach: Favor bins that are a good fit (proximity)
        # AND leave a remainder that is not excessively small.
        # Let's use a score that is `proximity_score * (1 + residual_bonus)`
        # Where residual_bonus is higher for moderate residuals.
        # A simple way: `residual_bonus = log(1 + residual)` scaled.

        # Let's combine: Proximity score * (1 + log(1 + resulting_remainder))
        # This rewards close fits and adds a bonus for leaving more space.
        resulting_remainders = fitting_bins_cap - item
        
        # We want to avoid penalizing very small remainders too harshly, as tight fits are good.
        # Let's try to make the bonus more significant for larger remainders.
        # The log function provides diminishing returns.
        
        # A simpler combination: proximity * (1 + scaled_remainder).
        # Let's use a score that reflects how "full" the bin becomes, but with a penalty for being *too* full.
        # Fill ratio: item / fitting_bins_cap
        # This implicitly penalizes very large remainders.
        
        # Let's combine proximity with fill ratio as in heuristic_v0, but add a slight penalty for very small remainders.
        fill_ratios = item / fitting_bins_cap
        
        # We want to prioritize bins that are a good fit AND have a high fill ratio.
        # Combined score: `fill_ratios * (1 / (differences + epsilon))`
        # This inherently favors bins that are nearly full and have a small gap.
        
        # To make it more adaptive, let's add a term that slightly penalizes
        # bins that would leave an extremely small remainder.
        # If `resulting_remainders` is very small, reduce the score.
        # For example, `1 / (1 + resulting_remainder)` rewards small remainders.
        # We want the opposite: penalize small remainders.
        # Let's use `(resulting_remainders + 1) / (resulting_remainders + 1 + penalty_factor)`
        # where penalty_factor is small.
        
        penalty_factor = 5.0 # Adjust this parameter to tune the penalty
        remainder_quality_score = (resulting_remainders + 1) / (resulting_remainders + 1 + penalty_factor)
        
        # Combine proximity, fill ratio, and remainder quality.
        # The fill_ratio * proximity already favors tight fits.
        # The remainder_quality_score will slightly boost bins with moderate remainders
        # and slightly reduce bins with extremely small remainders.
        
        # Let's try a simpler combination:
        # Prioritize bins that are a close fit (proximity_score).
        # Among those, favor bins that leave a remainder that's not too small.
        # Score = proximity_score * (1 + alpha * log(resulting_remainders + 1))
        
        alpha = 0.1 # Tuning parameter for the bonus
        adaptive_bonus = np.log(1 + resulting_remainders + 1e-9)
        
        # Combine proximity and the adaptive bonus.
        # The proximity term drives towards the tightest fit.
        # The adaptive bonus slightly favors bins that leave more space,
        # making it less greedy on the absolute tightest fit.
        priorities[can_fit_mask] = proximity_scores + alpha * adaptive_bonus

    return priorities
```
