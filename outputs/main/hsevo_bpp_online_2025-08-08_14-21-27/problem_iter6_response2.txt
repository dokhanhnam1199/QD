```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for bins using a combined strategy.
    It prioritizes bins that offer the 'tightest' fit (smallest remaining capacity >= item)
    but also considers bins with more remaining capacity as a secondary factor,
    especially if no tight fit is available. This aims to balance immediate good fits
    with leaving larger gaps for future, larger items.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    fitting_bins_indices = np.where(can_fit_mask)[0]

    if fitting_bins_cap.size > 0:
        # Strategy 1: Prioritize bins with the smallest remaining capacity that can fit the item
        # This is similar to Best Fit. We invert the difference to give higher scores to smaller differences.
        differences = fitting_bins_cap - item
        # Add a small epsilon to avoid division by zero
        tight
