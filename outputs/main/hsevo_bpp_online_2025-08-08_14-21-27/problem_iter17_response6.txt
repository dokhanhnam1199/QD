```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tightness and a normalized fill ratio using additive weights.
    Balances immediate packing efficiency with future bin utility.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]

    # Component 1: Best Fit (inverse of remaining capacity after packing)
    # Prioritizes bins where the item fits most snugly.
    best_fit_scores = 1.0 / (fittable_bins_remain_cap - item + 1e-9)

    # Component 2: Normalized Fill Ratio
    # Measures how full a bin is relative to its capacity, encouraging use of already utilized bins.
    # We use (capacity - remaining_capacity) / capacity for the overall bin fill,
    # but for priority, we consider item/remaining_capacity as a measure of how much
    # the item "fills" the *available* space. A higher ratio is better.
    fill_ratio_scores = item / (fittable_bins_remain_cap + 1e-9)

    # Weights for combining components. These can be tuned.
    # Beta emphasizes fitting snugly, Alpha emphasizes already fuller bins.
    beta = 0.7
    alpha = 0.3

    # Combined score using weighted additive approach for better control.
    # We normalize each component before weighting to ensure fair contribution.
    # Normalize best_fit_scores (higher is better, higher score means smaller leftover)
    max_bf = np.max(best_fit_scores)
    normalized_best_fit = best_fit_scores / max_bf if max_bf > 1e-9 else np.ones_like(best_fit_scores)

    # Normalize fill_ratio_scores (higher is better, higher score means item is a larger fraction of available space)
    max_fr = np.max(fill_ratio_scores)
    normalized_fill_ratio = fill_ratio_scores / max_fr if max_fr > 1e-9 else np.ones_like(fill_ratio_scores)

    combined_scores = alpha * normalized_fill_ratio + beta * normalized_best_fit

    # Assign calculated scores back and normalize the final priorities.
    if np.max(combined_scores) > 1e-9:
        priorities[fittable_bins_mask] = combined_scores / np.max(combined_scores)
    else:
        # If all scores are zero or near-zero, assign uniform small priority
        priorities[fittable_bins_mask] = 0.1

    return priorities
```
