```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and a Fill Ratio bonus multiplicatively,
    prioritizing bins that are both a tight fit and already well-utilized.
    This aims for efficient packing by favoring dense bins that can snugly fit the item.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # --- Best Fit Component ---
    # Higher score for smaller remaining capacity after fitting.
    remaining_capacity_after_fit = fitting_bins_remain_cap - item
    proximity_score = 1.0 / (remaining_capacity_after_fit + 1e-9)
    
    # --- Fill Ratio Component ---
    # Using 1.0 as the assumed bin capacity. Higher fill ratio (less remaining capacity) is better.
    # This encourages using bins that are already somewhat full.
    bin_capacity = 1.0 
    current_fill_ratio = (bin_capacity - fitting_bins_remain_cap) / bin_capacity
    fill_ratio_score = current_fill_ratio
    
    # --- Combined Score ---
    # Multiplicatively combine Best Fit and Fill Ratio.
    # This prioritizes bins that are both a good fit (high proximity) AND already well-utilized (high fill ratio).
    # A bin that is nearly full and can snugly fit the item will get a high score.
    combined_score = proximity_score * fill_ratio_score
    
    # --- Refinement: Ensure proximity is considered for empty bins ---
    # If a bin was empty (fill_ratio=0), combined_score would be 0.
    # We want to ensure that even in this case, the proximity score is still considered,
    # as an empty bin might be the only option or a good first fit.
    # We take the maximum of the combined score and a modified proximity score
    # where the fill_ratio_score component is only applied if fill_ratio > 0.
    # This ensures that even empty bins get a score based on their proximity.
    priorities[can_fit_mask] = np.maximum(combined_score, proximity_score * (fill_ratio_score > 1e-9))
    
    # Add a small constant to all valid priorities to ensure that even if
    # all scores are very low, they are distinct and positive, aiding tie-breaking.
    priorities[can_fit_mask] += 1e-6
    
    return priorities
```
