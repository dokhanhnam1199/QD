```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive Priority: Combines 'Best Fit' with an 'Almost Full' bias.
    Prioritizes bins that leave minimal space, favoring near-perfect fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate remaining capacity for bins that can fit the item
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item
    
    # Heuristic: Prioritize bins that result in less remaining capacity.
    # This is a "Best Fit" like strategy.
    # Using 1 / (1 + residual_capacity) to give higher scores to smaller residuals.
    # A residual capacity of 0 gets a score of 1. A large residual gets a score close to 0.
    priorities[can_fit_mask] = 1.0 / (1.0 + remaining_capacity_after_fit)
    
    # Additional bias: Slightly boost priority for bins that become nearly full (e.g., residual < 0.1 * bin_capacity)
    # This "almost full" bias encourages tighter packing and potentially better overall utilization.
    # We'll apply a small multiplier to these bins.
    original_bin_capacities = bins_remain_cap[can_fit_mask] # Assuming we know original capacities or can infer
    # For this example, let's assume a fixed bin capacity, say 1.0, for demonstration
    # In a real scenario, bin capacity would be a parameter or known context.
    # If bin_capacity is not fixed, this bias needs adjustment or a different approach.
    # For simplicity here, let's assume a standard bin capacity is known or implied.
    # Let's use a placeholder if bin capacity is not explicitly available.
    # If bin_capacity is available, it would be:
    # almost_full_mask = remaining_capacity_after_fit < (bin_capacity * 0.1) 
    
    # Without explicit bin capacity, we'll use a small absolute residual as a proxy for 'almost full'
    # For example, if the remaining capacity is very small (e.g., less than 0.05)
    small_residual_bias_mask = remaining_capacity_after_fit < 0.05
    priorities[can_fit_mask][small_residual_bias_mask] *= 1.1 # Apply a small boost

    return priorities

```
