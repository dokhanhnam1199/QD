```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Epsilon-Greedy priority for Online Bin Packing Problem.

    This heuristic prioritizes bins that can accommodate the item and
    favors bins with less remaining capacity (Best Fit approach) to
    minimize wasted space. A small epsilon is introduced to allow for
    exploration of less optimal bins occasionally.
    """
    epsilon = 0.1  # Exploration parameter
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit, assign a priority based on remaining capacity
    # Smaller remaining capacity gets a higher priority (closer to 0)
    # Add a small epsilon to some bins to encourage exploration
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    if fitting_bins_capacities.size > 0:
        # Calculate priorities for fitting bins: higher priority for less remaining capacity
        # We use 1 / (remaining_capacity - item + 1) to ensure a positive value and to favor smaller remaining capacity
        # Adding item ensures we are comparing to the capacity AFTER placing the item.
        # Adding 1 prevents division by zero if remaining_capacity - item is 0.
        priorities[can_fit_mask] = 1.0 / (fitting_bins_capacities - item + 1.0)

        # Introduce epsilon-greedy exploration: randomly pick a subset of fitting bins and slightly alter their priority
        num_fitting_bins = fitting_bins_capacities.size
        num_explore = int(np.floor(epsilon * num_fitting_bins))
        if num_explore > 0:
            explore_indices_relative = np.random.choice(num_fitting_bins, num_explore, replace=False)
            explore_indices_absolute = np.where(can_fit_mask)[0][explore_indices_relative]
            # Slightly increase priority to make them more likely to be chosen if they are not the absolute best
            priorities[explore_indices_absolute] *= (1 + np.random.uniform(0, 0.2, num_explore)) # slight boost

    # Normalize priorities to be between 0 and 1 for a clear probabilistic interpretation
    if np.max(priorities) > 0:
        priorities = priorities / np.max(priorities)

    return priorities
```
