```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tightness with a modified Fill Ratio (item/bin_capacity).
    Prioritizes bins that fit the item snugly and are already substantially full.
    This aims for denser packing by favoring bins that are both a good fit and well-utilized.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the current item.
    eligible_bins_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros.
    if not np.any(eligible_bins_mask):
        return priorities

    # Get the remaining capacities of only the eligible bins.
    eligible_bins_caps = bins_remain_cap[eligible_bins_mask]

    # --- Best Fit Component ---
    # This component prioritizes bins where the item leaves the least remaining capacity.
    # A smaller remaining capacity after packing (eligible_bins_caps - item) results in a higher score.
    # Adding a small epsilon (1e-9) prevents division by zero for bins that will be exactly full.
    best_fit_scores = 1.0 / (eligible_bins_caps - item + 1e-9)

    # --- Fill Ratio Component ---
    # This component prioritizes bins that are already more full, relative to the item's size.
    # A higher item size relative to the bin's remaining capacity indicates a better "fill".
    # This encourages using bins that have already been utilized to a greater extent.
    fill_ratio_scores = item / (eligible_bins_caps + 1e-9)

    # --- Combined Score ---
    # Multiply the Best Fit and Fill Ratio scores. This multiplicative approach
    # ensures that bins excelling in BOTH criteria receive disproportionately higher scores.
    # Bins that are a tight fit AND are already quite full are strongly preferred.
    combined_scores = best_fit_scores * fill_ratio_scores

    # Assign the calculated combined scores back to the priorities array for the eligible bins.
    priorities[eligible_bins_mask] = combined_scores

    # Normalize priorities to the range [0, 1]. This makes scores comparable
    # across different item/bin configurations and helps in selecting the top bin.
    # Avoid division by zero if all priorities are zero (which shouldn't happen here
    # if eligible_bins_mask is true, but good practice).
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = priorities / max_priority

    return priorities
```
