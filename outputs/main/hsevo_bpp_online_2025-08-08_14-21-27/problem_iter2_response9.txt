```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by favoring those that leave minimal remaining capacity after packing,
    with an adaptive sigmoid scaling to emphasize better fits.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    valid_bins_mask = bins_remain_cap >= item
    
    if not np.any(valid_bins_mask):
        return priorities

    remaining_caps_for_valid_bins = bins_remain_cap[valid_bins_mask]
    diffs = remaining_caps_for_valid_bins - item
    
    # Using a scaled inverse difference for a preference towards tighter fits
    # Add a small epsilon to avoid division by zero if diff is exactly 0
    inverse_diff_scores = 1.0 / (diffs + 1e-9)
    
    # Adaptive sigmoid scaling to emphasize bins with very small differences (better fits)
    # This part is inspired by v1's idea of using sigmoid for better differentiation
    # We center the sigmoid around the median difference to adapt to the current state
    median_diff = np.median(diffs)
    k = 10.0 # Sensitivity parameter for sigmoid
    sigmoid_scores = 1 / (1 + np.exp(-k * (diffs - median_diff)))
    
    # Combine inverse difference for general preference and sigmoid for fine-tuning
    # The sigmoid amplifies the preference for bins closer to the median difference
    priorities[valid_bins_mask] = inverse_diff_scores * sigmoid_scores
    
    return priorities
```
