```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and First Fit Decreasing ideas with a focus on filling
    bins as much as possible, prioritizing bins that are nearly full or
    can accommodate the item with minimal remaining space.
    This version uses a multiplicative approach to balance fitting tightly
    and maintaining a good fill ratio.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]
    
    # Score 1: Best Fit - how much space is left after packing
    # Smaller remaining space is better, so we invert it. Add epsilon for stability.
    best_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-9)
    
    # Score 2: Fill Ratio - how full the bin is *after* packing the item
    # Higher fill ratio is better. Calculate as (bin_capacity - new_remaining_capacity) / bin_capacity
    # Assuming bin_capacity is constant (e.g., 1.0 for normalized capacities)
    # or we need to infer it. If we only have remaining capacity, we can use
    # (current_remaining_capacity + item) / (total_capacity_before_item).
    # A proxy for "fullness before item" can be (max_capacity - current_remaining_capacity).
    # Let's assume a standard bin capacity of 1.0 for simplicity in this context.
    # The 'fullness' here refers to the state *after* the item is packed.
    # A bin that becomes full or nearly full is good.
    # Let's use the proportion of capacity used by the item in the fittable bin.
    # This is `item / (bin_capacity - remaining_capacity_after_fit
