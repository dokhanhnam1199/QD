```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fit preference with a bonus for bins that are nearly full,
    prioritizing efficient use of space and minimizing waste.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_cap = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_cap.size > 0:
        differences = fitting_bins_cap - item
        
        # Proximity score: Inverse of the difference (higher for tighter fits)
        proximity_scores = 1.0 / (differences + 1e-9)
        
        # Fullness bonus: Higher for bins that are already more utilized
        # This rewards bins that are "nearly full" and can still accommodate the item.
        # We use the inverse of the remaining capacity as a proxy for fullness.
        fullness_bonus = fitting_bins_cap / (np.max(bins_remain_cap) + 1e-9) 
        
        # Combine scores: Multiply proximity by fullness bonus.
        # This favors bins that are both a tight fit AND are already substantially filled.
        combined_scores = proximity_scores * (1 + fullness_bonus * 0.5) # Slightly weight the fullness bonus
        
        priorities[can_fit_mask] = combined_scores
        
        # Normalize priorities to ensure the highest score is 1
        max_priority = np.max(priorities[can_fit_mask])
        if max_priority > 0:
            priorities[can_fit_mask] /= max_priority

    return priorities
```
