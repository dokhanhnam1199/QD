import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, almost_full_threshold: float = 0.10661384948388819, almost_full_boost_factor: float = 1.1209641805577244) -> np.ndarray:
    """
    Adaptive Priority: Combines 'Best Fit' with an 'Almost Full' bias.
    Prioritizes bins that leave minimal space, favoring near-perfect fits.

    Args:
        item: The size of the item to be placed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.
        almost_full_threshold: The maximum residual capacity for a bin to be considered "almost full".
        almost_full_boost_factor: The multiplier applied to the priority of "almost full" bins.

    Returns:
        A numpy array of priorities for each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate remaining capacity for bins that can fit the item
    remaining_capacity_after_fit = bins_remain_cap[can_fit_mask] - item

    # Heuristic: Prioritize bins that result in less remaining capacity.
    # This is a "Best Fit" like strategy.
    # Using 1 / (1 + residual_capacity) to give higher scores to smaller residuals.
    # A residual capacity of 0 gets a score of 1. A large residual gets a score close to 0.
    priorities[can_fit_mask] = 1.0 / (1.0 + remaining_capacity_after_fit)

    # Additional bias: Slightly boost priority for bins that become nearly full (e.g., residual < almost_full_threshold)
    # This "almost full" bias encourages tighter packing and potentially better overall utilization.
    small_residual_bias_mask = remaining_capacity_after_fit < almost_full_threshold
    priorities[can_fit_mask][small_residual_bias_mask] *= almost_full_boost_factor

    return priorities
