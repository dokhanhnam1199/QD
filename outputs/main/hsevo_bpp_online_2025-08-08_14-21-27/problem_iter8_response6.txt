```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and a utility bonus for moderate remaining capacity.
    Favors bins that are a tight fit but also leave some usable space.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item

    # Best Fit component: favors bins that leave minimal remaining capacity.
    # Higher score for smaller remaining capacity.
    best_fit_score = 1.0 / (potential_remaining_cap + 1e-9)

    # Utility component: favors bins that leave a moderate amount of capacity.
    # This is a simplified Gaussian-like bonus, centered around item/2.
    # It rewards bins that aren't too tight or too loose.
    moderate_capacity_center = item / 2.0
    utility_bonus = np.exp(-((potential_remaining_cap - moderate_capacity_center)**2) / (2 * (moderate_capacity_center**2 + 1e-9)))

    # Combine scores multiplicatively: A bin must be good for both components.
    # This balances the 'tightest fit' with the 'most useful residual space'.
    combined_score = best_fit_score * utility_bonus

    # Assign priorities to the valid bins.
    priorities[can_fit_mask] = combined_score

    # Normalize priorities to ensure relative ranking and prevent extreme values.
    if np.any(priorities):
        max_priority = np.max(priorities)
        if max_priority > 1e-9:
            priorities[can_fit_mask] /= max_priority
        else:
            # If all resulting priorities are near zero, assign a small uniform priority.
            priorities[can_fit_mask] = 1e-6

    return priorities
```
