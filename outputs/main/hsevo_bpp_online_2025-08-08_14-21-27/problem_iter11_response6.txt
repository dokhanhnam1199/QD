```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a fill ratio bonus using a multiplicative approach,
    prioritizing bins that offer a tight fit and are already well-utilized.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    fitting_bins_indices = np.where(can_fit_mask)[0]
    
    if fitting_bins_indices.size > 0:
        fitting_bins_cap = bins_remain_cap[fitting_bins_indices]
        
        # Best Fit component: Smaller difference is better (higher score)
        differences = fitting_bins_cap - item
        best_fit_score = 1.0 / (differences + 1e-9)
        
        # Fill Ratio component: Higher fill ratio is better (higher score)
        # Assuming bin capacity is constant (e.g., 1.0 for normalized problems or a known max_capacity)
        # Here, we use the total capacity before packing as the reference for fill ratio.
        # A simpler proxy for fullness is (bin_capacity - remaining_capacity).
        # Let's assume a hypothetical bin capacity of 1.0 for this calculation if not provided.
        # If bin_capacity is known, replace 1.0 with it.
        bin_capacity = 1.0 
        fullness = (bin_capacity - fitting_bins_cap) / bin_capacity
        fill_ratio_score = fullness 
        
        # Combine scores multiplicatively: Boosts bins that are both tight fits and fuller.
        # Adding a small constant to fill_ratio_score to avoid multiplying by zero if a bin is empty.
        combined_scores = best_fit_score * (fill_ratio_score + 0.1) # Add small bonus to slightly full bins
        
        priorities[fitting_bins_indices] = combined_scores
        
        # Normalize priorities to be between 0 and 1 for the fitting bins
        max_priority = np.max(priorities[fitting_bins_indices])
        if max_priority > 0:
            priorities[fitting_bins_indices] /= max_priority
            
    return priorities
```
