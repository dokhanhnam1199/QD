```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap)
    
    # Exact Fit First strategy:
    # Give higher priority to bins that can perfectly fit the item.
    # If no perfect fit, prioritize bins that have just enough space (smallest remaining capacity greater than or equal to item).
    # If multiple perfect fits, or multiple "just enough" fits, the order doesn't strictly matter for exact fit, 
    # but we can use the original bin index as a tie-breaker for consistency.
    
    perfect_fit_mask = (bins_remain_cap == item)
    if np.any(perfect_fit_mask):
        priorities[perfect_fit_mask] = 1.0
    else:
        # Find bins where remaining capacity is just enough for the item
        sufficient_capacity_mask = (bins_remain_cap >= item)
        if np.any(sufficient_capacity_mask):
            # Prioritize bins with the least remaining capacity that is still sufficient
            # This is a secondary heuristic: Best Fit variation when exact fit is not possible.
            sufficient_capacities = bins_remain_cap[sufficient_capacity_mask]
            
            # Calculate a score inversely proportional to remaining capacity for sufficient bins
            # A smaller remaining capacity (but still >= item) is better.
            # We want to maximize this score. So, we can use something like 1 / (remaining_capacity - item + 1) 
            # to give higher scores to tighter fits. Adding 1 to avoid division by zero if remaining_capacity == item.
            
            # Create temporary indices for sorting
            temp_indices = np.where(sufficient_capacity_mask)[0]
            
            # Sort these bins by their remaining capacity
            sorted_indices = temp_indices[np.argsort(bins_remain_cap[temp_indices])]
            
            # Assign priorities to the sorted bins. Higher priority for smaller remaining capacity.
            # We can assign decreasing priorities, e.g., N, N-1, ..., 1
            num_sufficient_bins = len(sorted_indices)
            for i, original_idx in enumerate(sorted_indices):
                # Assign a priority that decreases from N to 1 for bins with increasing capacity.
                # So, the bin with the smallest sufficient capacity gets the highest priority among these.
                priorities[original_idx] = num_sufficient_bins - i
        
    # Normalize priorities for potential future use or comparison, though not strictly necessary for selection here.
    # If all priorities are zero (no bin can fit the item), the array remains all zeros.
    if np.sum(priorities) > 0:
        priorities = priorities / np.sum(priorities)
    
    return priorities
```
