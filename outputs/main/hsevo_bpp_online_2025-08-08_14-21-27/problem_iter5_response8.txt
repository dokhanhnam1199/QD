```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit (tightest residual) with a bonus for bins that are not nearly full.
    This aims to leverage tight fits while encouraging the use of less filled bins for flexibility.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins = bins_remain_cap[fittable_bins_mask]

    # Best Fit component: higher score for smaller remaining capacity after placing item
    # We use 1 / (residual + epsilon) to get higher scores for smaller residuals.
    residuals = fittable_bins - item
    best_fit_scores = 1.0 / (residuals + 1e-9)

    # Exploration/Flexibility component: encourage bins that are not *too* full.
    # This is inspired by heuristic 13/14's idea of leaving capacity.
    # We want to penalize bins that would become almost full after placement,
    # but reward those that still have substantial capacity remaining.
    # A simple way is to look at the remaining capacity *after* placement.
    # We invert this so smaller remaining capacities get a smaller bonus (less attractive).
    # Add a small constant to avoid division by zero and to ensure a base score.
    flexibility_scores = 1.0 / (fittable_bins - item + 0.1)

    # Combine scores: Multiply Best Fit by flexibility.
    # This prioritizes bins that are a tight fit AND still have some room left.
    # The multiplication is chosen to amplify good fits in less full bins.
    combined_scores = best_fit_scores * flexibility_scores

    # Normalize to a [0, 1] range for consistent priority
    if np.max(combined_scores) > 1e-9:
        priorities[fittable_bins_mask] = combined_scores / np.max(combined_scores)
    else:
        # If all combined scores are near zero, assign a small uniform priority
        priorities[fittable_bins_mask] = 0.1

    return priorities
```
