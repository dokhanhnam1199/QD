```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A refined heuristic that balances immediate fit quality with long-term bin utilization,
    prioritizing bins that are nearly full but can still accommodate the item,
    while also considering the potential for future fits of smaller items.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]

    # Score 1: Tightness of Fit (Best Fit Component)
    # Prioritizes bins where the remaining capacity after packing is minimal.
    # Add a small epsilon to prevent division by zero.
    tightness_score = 1.0 / (fittable_bins_remain_cap - item + 1e-6)

    # Score 2: Bin Fullness (Encouraging fuller bins)
    # This score is high for bins that are already quite full (low remaining capacity).
    # We use the inverse of the remaining capacity.
    fullness_score = 1.0 / (fittable_bins_remain_cap + 1e-6)

    # Score 3: Future Fit Potential (Adaptive Component)
    # This score is higher for bins that, after fitting the current item,
    # will still have a significant amount of remaining capacity. This aims to
    # leave "room" for smaller items later, preventing premature bin exhaustion.
    # We use a logarithmic function to give diminishing returns for very large remaining capacities.
    # Adding 1 to prevent log(0) or log(negative).
    future_fit_score = np.log1p(bins_remain_cap[fittable_bins_mask] - item + 1)

    # Combine scores with adaptive weighting.
    # The weights are designed to:
    # - Heavily favor bins that offer a tight fit (tightness_score).
    # - Give a moderate boost to bins that are already fuller (fullness_score).
    # - Introduce a penalty for leaving excessively large gaps by inverting the future_fit_score.
    #   A smaller (less leftover space) future_fit_score is better, so we subtract it.
    # The coefficients (1.0, 0.7, 0.3) are hyperparameters that can be tuned.
    # We are emphasizing the tightness and fullness more, while still penalizing large leftovers.
    combined_scores = (tightness_score * 1.0) + (fullness_score * 0.7) - (future_fit_score * 0.3)

    # Normalize priorities to a [0, 1] range.
    max_score = np.max(combined_scores)
    if max_score > 1e-9:
        priorities[fittable_bins_mask] = np.clip(combined_scores / max_score, 0, 1)
    else:
        # If all scores are effectively zero, assign a minimal uniform priority to fittable bins.
        priorities[fittable_bins_mask] = 0.01

    return priorities
```
