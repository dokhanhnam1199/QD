```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]
    
    # Metric 1: Best Fit (minimize remaining capacity)
    # A smaller remaining capacity after fitting is better.
    best_fit_metric = fittable_bins_remain_cap - item
    
    # Metric 2: Fill Ratio (maximize current fill level)
    # This encourages using bins that are already relatively full.
    # We consider the capacity used by the item relative to the bin's original capacity.
    # Assuming bins have a standard capacity (e.g., bin_capacity), this would be (bin_capacity - bins_remain_cap + item) / bin_capacity
    # However, without bin_capacity, we can use the inverse of remaining capacity as a proxy for fullness.
    # A higher inverse remaining capacity means the bin is more full.
    # Adding a small epsilon to avoid division by zero and to make smaller remaining capacities yield larger values.
    fullness_metric = 1.0 / (fittable_bins_remain_cap + 1e-6)

    # Combine metrics multiplicatively to encourage both good fit and high fill ratio.
    # We want to minimize best_fit_metric and maximize fullness_metric.
    # So, we use 1 / (1 + best_fit_metric) to map it to a [0, 1] range where smaller is better,
    # and directly use fullness_metric (or a normalized version).
    # Let's normalize both to [0, 1] first for a cleaner multiplicative combination.

    # Normalize best_fit_metric: Smaller is better, so we invert and scale.
    # If best_fit_metric is 0, it's a perfect fit.
    normalized_best_fit = 1.0 - (best_fit_metric / np.max(fittable_bins_remain_cap + 1e-6))
    normalized_best_fit = np.clip(normalized_best_fit, 0, 1) # Ensure it's in [0, 1]

    # Normalize fullness_metric: Higher is better.
    # Use the inverse of remaining capacity.
    normalized_fullness = fullness_metric / np.max(fullness_metric + 1e-6)
    normalized_fullness = np.clip(normalized_fullness, 0, 1) # Ensure it's in [0, 1]

    # Multiplicative combination: Encourages bins that are both good fits and already full.
    # A bin needs to score well on *both* metrics.
    combined_scores = normalized_best_fit * normalized_fullness

    # Adjust weights if needed for emphasis. Let's keep it simple with equal weighting via multiplication.
    # For example, to give more weight to best fit: (normalized_best_fit**w1) * (normalized_fullness**w2)
    
    # Scale to [0, 1] range for priorities.
    if np.max(combined_scores) > 1e-9:
        priorities[fittable_bins_mask] = combined_scores / np.max(combined_scores)
    else:
        # If all scores are near zero, assign a small uniform priority to fittable bins.
        priorities[fittable_bins_mask] = 0.1

    return priorities
```
