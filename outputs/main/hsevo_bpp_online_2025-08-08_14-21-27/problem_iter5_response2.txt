```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by a combination of Best Fit and encouraging bins with moderate remaining capacity."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    potential_remaining_cap = bins_remain_cap[can_fit_mask] - item
    
    # Best Fit component: favors bins that leave minimal remaining capacity.
    best_fit_score = 1.0 / (potential_remaining_cap + 1e-9)
    
    # Utility component: favors bins that leave a moderate amount of capacity,
    # balancing tight fits with potential for future items. We use a Gaussian-like
    # approach centered on a moderate residual (e.g., half the item size)
    # to provide a bonus to bins that aren't extremely tight or extremely loose.
    # The 'center' is heuristic and could be tuned. Here, we use item/2 as a simple center.
    moderate_capacity_center = item / 2.0
    # Ensure we don't get negative exponents for negative remainders (already filtered by can_fit_mask)
    utility_score = np.exp(-((potential_remaining_cap - moderate_capacity_center)**2) / (2 * (moderate_capacity_center**2)))

    # Combine scores: Multiplies Best Fit with a utility bonus.
    # This favors bins that are both a good fit and leave useful remaining capacity.
    combined_score = best_fit_score * utility_score
    
    # Assign priorities to the valid bins
    priorities[can_fit_mask] = combined_score

    # Normalize priorities to prevent extreme values and ensure a relative ranking
    if np.any(priorities):
        max_priority = np.max(priorities)
        if max_priority > 1e-9: # Avoid division by zero if all priorities are near zero
            priorities[can_fit_mask] /= max_priority
        else: # If all are near zero, assign a small uniform priority to all valid bins
            priorities[can_fit_mask] = 1e-6

    return priorities
```
