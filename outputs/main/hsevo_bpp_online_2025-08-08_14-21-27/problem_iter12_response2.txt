```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a tight fit score (similar to Best Fit) with a bin fullness score
    using a multiplicative approach. It also incorporates a penalty for large remaining gaps.
    The multiplicative approach aims to prioritize bins that are both a good fit
    and contribute to overall higher bin utilization.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    fittable_bins_mask = bins_remain_cap >= item

    if not np.any(fittable_bins_mask):
        return priorities

    fittable_bins_remain_cap = bins_remain_cap[fittable_bins_mask]

    # Score 1: Tight Fit - Prioritize bins that leave minimal remaining capacity.
    # Adding a small epsilon to avoid division by zero and to prevent zero scores.
    # A higher score means a tighter fit.
    tight_fit_score = 1.0 / (fittable_bins_remain_cap - item + 1e-6)

    # Score 2: Bin Fullness - Prioritize bins that are already relatively full.
    # This encourages packing into already occupied bins.
    # We use the inverse of the remaining capacity (before fitting the item) as a proxy for fullness.
    # Higher remaining capacity means less full, so we invert it.
    # Adding a small epsilon to avoid division by zero.
    # We cap this score to avoid overly dominating the multiplicaton if some bins are almost empty.
    bin_fullness_score = 1.0 / (bins_remain_cap[fittable_bins_mask] + 1e-6)

    # Score 3: Gap Penalty - Penalize bins that will have a large remaining capacity after fitting the item.
    # This discourages creating very large empty spaces.
    # We use the logarithm of the remaining capacity after fitting.
    # Lower log values (smaller gaps) are better, so we'll subtract this.
    # Adding 1 to prevent log(0) and ensure positive values.
    # Smaller gaps should result in a higher overall priority.
    gap_penalty = np.log1p(fittable_bins_remain_cap - item)

    # Combine scores multiplicatively for tight fit and fullness,
    # then add the inverse of the gap penalty to boost bins with small gaps.
    # Weights are chosen to balance the influence of each component.
    # The multiplicative part ensures that both tight fit and fullness are important.
    # The additive part for the gap penalty provides a fine-tuning adjustment.
    combined_scores = (tight_fit_score * 0.8) * (bin_fullness_score * 0.7) + (1.0 / (gap_penalty + 1e-6) * 0.5)

    # Normalize the combined scores for the fittable bins to a [0, 1] range.
    max_score = np.max(combined_scores)
    if max_score > 1e-9:
        priorities[fittable_bins_mask] = combined_scores / max_score
    else:
        # If all scores are near zero, assign a small uniform priority to fittable bins.
        priorities[fittable_bins_mask] = 0.1

    return priorities
```
