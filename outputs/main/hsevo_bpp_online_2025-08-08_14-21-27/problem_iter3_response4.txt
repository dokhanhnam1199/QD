```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for bins using an adaptive strategy that
    considers both proximity and potential for future fits.
    Bins that can fit the item will have a non-zero priority.
    The priority is higher for bins that are a tighter fit, but also
    gives a slight bonus to bins that leave more remaining capacity,
    aiming to balance immediate packing efficiency with future flexibility.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    if fitting_bins_cap.size > 0:
        differences = fitting_bins_cap - item
        # Base proximity score: higher for tighter fits
        proximity_scores = 1.0 / (differences + 1e-9)

        # Adaptive bonus: encourage leaving more capacity if the fit is not perfect
        # This bonus is higher for bins that are not a perfect fit,
        # to encourage using them and saving tighter fits for potentially larger items.
        # The weight (0.1) can be tuned.
        adaptive_bonus = 0.1 * (fitting_bins_cap - item) / (np.max(fitting_bins_cap) + 1e-9)

        combined_scores = proximity_scores + adaptive_bonus

        priorities[can_fit_mask] = combined_scores

        # Normalize priorities so that the best bin has a score of 1 (or close to it)
        max_priority = np.max(priorities[can_fit_mask])
        if max_priority > 0:
            priorities[can_fit_mask] /= max_priority

    return priorities
```
