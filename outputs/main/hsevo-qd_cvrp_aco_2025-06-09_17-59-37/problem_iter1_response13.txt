```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and depot proximity.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Normalize distances for scaling. Adding a small value to avoid division by zero.
    normalized_distances = 1 / (distance_matrix + 1e-6)
    
    # Prioritize returning to the depot if vehicle close to full
    # Node specific information
    depot_distances = distance_matrix[0, :]  # Distance from each node to the depot
    
    total_demand = np.sum(demands)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # Disallow self-loops
                continue
                
            # Base heuristic based on normalized distance.
            heuristic_value = normalized_distances[i, j]

            # Factor in demand: discourage links between nodes with very high combined demand,
            # but also balance across nodes
            demand_penalty = (demands[i] + demands[j]) / (2 * capacity)
            heuristic_value /= (1 + demand_penalty**2) # Apply larger penalty for high demand pairs

            # Incorporate depot proximity: prioritize edges closer to the depot to help
            # facilitate returns when needed, only if the combined demand is a significant proportion of vehicle capacity
            depot_proximity = (depot_distances[i] + depot_distances[j]) / (2 * np.mean(depot_distances[1:])) # Normalize
            heuristic_value /= (1 + 0.5*depot_proximity) # weight factor to normalize the effect
                
            heuristics_matrix[i, j] = heuristic_value

    return heuristics_matrix
```
