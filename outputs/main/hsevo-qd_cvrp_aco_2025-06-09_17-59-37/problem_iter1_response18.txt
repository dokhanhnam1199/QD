```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates prior indicators for edges in a CVRP solution using a combination of distance,
    demand, and location-based factors. This heuristic prioritizes shorter distances,
    penalizes edges connecting to nodes with high demand if close to full capacity,
    and introduces a spatial clustering preference based on node proximity.

    Args:
        distance_matrix (np.ndarray): n x n distance matrix.
        coordinates (np.ndarray): n x 2 array of node coordinates.
        demands (np.ndarray): n array of customer demands.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: n x n array of prior indicators for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero
    heuristic_matrix = 1 / (distance_matrix + 1e-6)

    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.
    # Depot node (index 0) shouldn't influence this, so handle it separately
    for i in range(1, n): # Skip depot for source nodes in loop
        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0
            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand
            if (demands[i] + demands[j]) > capacity:
                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity
            else:
                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands

    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted "gravitational" effect
    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths
    for i in range(1, n):
        for j in range(1, n):
            if i!=j:
                delta_x = coordinates[i, 0] - coordinates[j, 0]
                delta_y = coordinates[i, 1] - coordinates[j, 1]
                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number
                heuristic_matrix[i,j] *= (spatial_proximity)


    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot
    for i in range(1, n):
        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot
        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot

    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)
    max_val = np.max(heuristic_matrix)
    heuristic_matrix = heuristic_matrix / max_val

    return heuristic_matrix
```
