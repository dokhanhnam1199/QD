{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}