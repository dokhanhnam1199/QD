```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    This version incorporates several factors to estimate the desirability of including each edge:
    - Inverse distance: Shorter distances are generally preferred.
    - Demand consideration: Penalizes edges connecting nodes that, if served consecutively,
      would likely violate capacity constraints. This is done by creating a 'demand-aware'
      distance.
    - Angle-based bonus: Edges forming sharper turns at a node are penalized.  The idea here
      is to encourage smoother, more direct routes. This helps avoid excessive zig-zagging.
    - Depot proximity: Rewards links from or to depot if the current demand in the node is very high.

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (n x 2).
        demands (np.ndarray): Customer demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge desirability matrix (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Demand-aware distance.  Inflate distances if demands are high.
    demand_factor = demands / capacity
    demand_aware_distance = distance_matrix * (1 + demand_factor[:, None] + demand_factor[None, :])

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Inverse distance (base heuristic)
                heuristic_value = 1 / demand_aware_distance[i, j]

                # Angle-based bonus (penalize sharp turns)
                # Iterate over each potential neighboring node 'k', different from 'i' and 'j'
                angle_penalty = 0
                num_angles = 0
                for k in range(n):
                  if k != i and k != j:
                    # Calculate the angle at node 'j' formed by nodes 'i', 'j', and 'k'
                    vector_ji = coordinates[i] - coordinates[j]
                    vector_jk = coordinates[k] - coordinates[j]

                    # Normalize vectors to have unit length
                    vector_ji = vector_ji / np.linalg.norm(vector_ji) if np.linalg.norm(vector_ji) > 0 else vector_ji
                    vector_jk = vector_jk / np.linalg.norm(vector_jk) if np.linalg.norm(vector_jk) > 0 else vector_jk

                    # Calculate the cosine of the angle
                    cos_angle = np.dot(vector_ji, vector_jk)
                    # Clip the value to the range [-1, 1] to avoid domain errors in arccos
                    cos_angle = np.clip(cos_angle, -1.0, 1.0)
                    # Convert the cosine to an angle in radians
                    angle = np.arccos(cos_angle)
                    angle_penalty += angle
                    num_angles +=1

                if num_angles > 0:
                    heuristic_value -= (angle_penalty / num_angles) * 0.1 # Reduce importance

                # Depot Proximity Bonus (encourage connection if i and j have large demand)
                if i == 0 or j == 0:
                    heuristic_value += (demands[i] + demands[j]) / capacity * 0.1 #Increase importance

                heuristic_matrix[i, j] = heuristic_value

    return heuristic_matrix
```
