```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Implements a more sophisticated heuristics function for the Capacitated Vehicle Routing Problem (CVRP).
    It combines distance, demand, and angular considerations to estimate the desirability of each edge.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix)

    # Parameters to control the influence of different factors
    distance_weight = 1.0  # Weight for the inverse of distance
    demand_weight = 0.5    # Weight for demand compatibility
    angle_weight = 0.2     # Weight for angular penalty

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # No self-loops
                continue

            # 1. Distance Component: Inverse of the distance.  Shorter distances are preferred.
            distance_component = distance_weight / distance_matrix[i, j]

            # 2. Demand Component:  Encourages edges connecting nodes whose combined demand fits within capacity. Penalizes edges where at least one is a large demand node, potentially triggering frequent return trips to depot.

            demand_penalty = 0.0
            if i == 0: # Depots have no demand
              demand_penalty = 0.0
            elif demands[i] > capacity/2: # Large demand nodes near depot require frequent trips.
              demand_penalty += 0.5
            if j == 0: # Depots have no demand
              demand_penalty = 0.0
            elif demands[j] > capacity/2:
              demand_penalty += 0.5
            demand_component = demand_weight * (1 - demand_penalty)

            # 3. Angular Component:  Penalizes sharp turns. It measures the angle between the line segments (depot -> i) and (i -> j).  Angles closer to 180 degrees (straight line) are preferred (lower penalty), while sharp turns (angles near 0) are penalized.

            if i != 0:  # Avoid computing angles from depot back to itself.  Zero angle causes division by zero!
                depot_x, depot_y = coordinates[0]
                node_i_x, node_i_y = coordinates[i]
                node_j_x, node_j_y = coordinates[j]

                vector_di = np.array([node_i_x - depot_x, node_i_y - depot_y])
                vector_ij = np.array([node_j_x - node_i_x, node_j_y - node_i_y])

                # Normalize vectors to compute cosine of the angle
                norm_di = np.linalg.norm(vector_di)
                norm_ij = np.linalg.norm(vector_ij)

                if norm_di > 0 and norm_ij > 0:  #Check for zero-length vectors to prevent runtime division by zero error.
                    cos_angle = np.dot(vector_di, vector_ij) / (norm_di * norm_ij)
                    cos_angle = np.clip(cos_angle, -1.0, 1.0) #Handle precision error that might cause values just slightly outside of range -1..1
                    angle = np.arccos(cos_angle)
                    angle_penalty = np.abs(angle - np.pi) / np.pi  # Normalize to [0, 1], where 0 is a straight line.

                else:
                    angle_penalty = 0 #If one or both vectors are zero length, set penalty to zero

            else:
                angle_penalty = 0.0  # No angle penalty if starting from the depot
            angle_component = angle_weight * (1 - angle_penalty) #Lower penalties are good

            # Combine the components
            heuristics_matrix[i, j] = distance_component + demand_component + angle_component

    return heuristics_matrix
```
