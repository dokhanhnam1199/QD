{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"A refined heuristic combining distance, demand, location, depot proximity,\n    connectivity, adaptive sparsification, and angle considerations.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # 1. Distance Factor: Inverse distance, crucial for solution length.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # 2. Demand Penalty: Discourage edges exceeding capacity.  Stricter penalty.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.001  # Very harsh penalty\n            else:\n                demand_penalty[i, j] = max(0.05, 1 - (combined_demand / capacity)**0.75)  # Adjusted exponent\n\n    heuristic_matrix *= demand_penalty\n\n    # 3. Spatial Proximity: Encourage edges between nearby nodes.  Increased weight.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.7 * spatial_proximity + 0.3)  # Increased weight on spatial proximity\n\n    # 4. Depot Connections:  Boost connections to/from the depot. Stronger boost.\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (2 / (distance_matrix[0, i] + 1e-6))  # Stronger boost\n        depot_boost[i, 0] = 1 + (2 / (distance_matrix[i, 0] + 1e-6))  # Stronger boost\n    heuristic_matrix *= depot_boost\n\n    # 5. Connectivity Prior: Favor connections to less connected nodes.  Adjusted weighting.\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (0.7 / (degree[i] + 1e-6)) + (0.3 / (degree[j] + 1e-6)) # Adjusted weighting\n    heuristic_matrix *= connectivity_boost\n\n    # 6. Angle Consideration: Penalize sharp turns.\n    angle_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Angle between depot -> i and i -> j\n                vector1 = coordinates[i] - coordinates[0]\n                vector2 = coordinates[j] - coordinates[i]\n                vector1 /= np.linalg.norm(vector1) + 1e-6\n                vector2 /= np.linalg.norm(vector2) + 1e-6\n                dot_product = np.dot(vector1, vector2)\n                angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Angle in radians\n\n                # Penalize sharp turns (angles close to pi)\n                angle_penalty[i, j] = 1 - (angle / np.pi)**2  # Reduced exponent\n\n    heuristic_matrix *= angle_penalty\n\n    # 7. Adaptive Sparsification: Zero out edges based on a dynamic threshold per node. More Aggressive\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.2  # More aggressive sparsification\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.2  # More aggressive sparsification\n        heuristic_matrix[col < threshold, i] = 0\n\n    # 8. Depot Sparsification: Remove less promising direct connections to the depot. More Aggressive.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.1 # More aggressive\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # 9. Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"A refined heuristic combining distance, demand, location, depot proximity,\n    connectivity, adaptive sparsification, and angle considerations.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # 1. Distance Factor: Inverse distance, crucial for solution length.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # 2. Demand Penalty: Discourage edges exceeding capacity.  Stricter penalty.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.001  # Very harsh penalty\n            else:\n                demand_penalty[i, j] = max(0.05, 1 - (combined_demand / capacity)**0.75)  # Adjusted exponent\n\n    heuristic_matrix *= demand_penalty\n\n    # 3. Spatial Proximity: Encourage edges between nearby nodes.  Increased weight.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.7 * spatial_proximity + 0.3)  # Increased weight on spatial proximity\n\n    # 4. Depot Connections:  Boost connections to/from the depot. Stronger boost.\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (2 / (distance_matrix[0, i] + 1e-6))  # Stronger boost\n        depot_boost[i, 0] = 1 + (2 / (distance_matrix[i, 0] + 1e-6))  # Stronger boost\n    heuristic_matrix *= depot_boost\n\n    # 5. Connectivity Prior: Favor connections to less connected nodes.  Adjusted weighting.\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (0.7 / (degree[i] + 1e-6)) + (0.3 / (degree[j] + 1e-6)) # Adjusted weighting\n    heuristic_matrix *= connectivity_boost\n\n    # 6. Angle Consideration: Penalize sharp turns.\n    angle_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                # Angle between depot -> i and i -> j\n                vector1 = coordinates[i] - coordinates[0]\n                vector2 = coordinates[j] - coordinates[i]\n                vector1 /= np.linalg.norm(vector1) + 1e-6\n                vector2 /= np.linalg.norm(vector2) + 1e-6\n                dot_product = np.dot(vector1, vector2)\n                angle = np.arccos(np.clip(dot_product, -1.0, 1.0))  # Angle in radians\n\n                # Penalize sharp turns (angles close to pi)\n                angle_penalty[i, j] = 1 - (angle / np.pi)**2  # Reduced exponent\n\n    heuristic_matrix *= angle_penalty\n\n    # 7. Adaptive Sparsification: Zero out edges based on a dynamic threshold per node. More Aggressive\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.2  # More aggressive sparsification\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.2  # More aggressive sparsification\n        heuristic_matrix[col < threshold, i] = 0\n\n    # 8. Depot Sparsification: Remove less promising direct connections to the depot. More Aggressive.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.1 # More aggressive\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # 9. Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"A heuristic combining distance, demand, location, depot proximity, connectivity, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 4th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"A heuristic combining distance, demand, location, depot proximity, connectivity, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 5th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"A heuristic combining distance, demand, location, depot proximity, connectivity, and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 6th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes, consider route capacity.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n              combined_demand = demands[i] + demands[j]\n              if combined_demand > capacity:\n                  demand_penalty[i, j] = 0.01  # Heavily penalize exceeding capacity\n              else:\n                  demand_factor = combined_demand / capacity\n                  demand_penalty[i, j] = max(0.1, 1 - demand_factor)  # Prefer routes using more capacity, but not exceeding it\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes, but less so for high demand\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                dist = np.sqrt(delta_x**2 + delta_y**2)\n                spatial_proximity[i, j] = 1 / (dist + 1e-6) #Invert distance\n                spatial_proximity[i, j] /= (demands[i] + demands[j])**0.25 #Reduce impact if high demand\n    heuristic_matrix *= spatial_proximity\n\n    # Depot Connections: Promote connections to and from the depot, adjust based on demand.\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6)) / demands[i]**0.5\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6)) / demands[i]**0.5\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected, also consider distance\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n            connectivity_boost[i,j] /= (distance_matrix[i,j]+1e-6)**0.5  #Penalize if long edges\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node, and adaptive parameter.\n    sparsification_factor = 0.3\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        # Calculate threshold based on both mean and median.\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * sparsification_factor  # Dynamic threshold based on both.\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * sparsification_factor\n        heuristic_matrix[col < threshold, i] = 0\n\n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Additional Sparsification: Remove edges that connect distant and high demand nodes\n    for i in range(1, n):\n        for j in range(i + 1, n):\n             if distance_matrix[i, j] > np.mean(distance_matrix) and (demands[i] + demands[j]) > capacity/2:\n                heuristic_matrix[i, j] = 0\n                heuristic_matrix[j, i] = 0\n                \n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 7th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_factor = combined_demand / capacity\n                demand_penalty[i, j] = max(0.1, 1 / (demand_factor + 1)) # Use inverse of demand factor\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= spatial_proximity\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n    \n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    # and introduce more agressive and dynamic sparsification\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        # Calculate threshold based on both mean and median.\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3  # Dynamic threshold based on both.\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n\n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n            \n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 8th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_factor = combined_demand / capacity\n                demand_penalty[i, j] = max(0.1, 1 / (demand_factor + 1)) # Use inverse of demand factor\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= spatial_proximity\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n    \n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    # and introduce more agressive and dynamic sparsification\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        # Calculate threshold based on both mean and median.\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3  # Dynamic threshold based on both.\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n\n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n            \n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 9th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_factor = combined_demand / capacity\n                demand_penalty[i, j] = max(0.1, 1 / (demand_factor + 1)) # Use inverse of demand factor\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= spatial_proximity\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n    \n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    # and introduce more agressive and dynamic sparsification\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        # Calculate threshold based on both mean and median.\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3  # Dynamic threshold based on both.\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n\n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n            \n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 10th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 11th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 12th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 13th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 14th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"Enhanced heuristic combining distance, demand, location, depot proximity, connectivity and adaptive sparsification.\"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5)\n\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)\n\n    # Depot Connections: Promote connections to and from the depot\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6))\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6))\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n\n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        mean_val = np.mean(row[row > 0]) if np.any(row > 0) else 0\n        median_val = np.median(row[row > 0]) if np.any(row > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[i, row < threshold] = 0\n\n        col = heuristic_matrix[:, i]\n        mean_val = np.mean(col[col > 0]) if np.any(col > 0) else 0\n        median_val = np.median(col[col > 0]) if np.any(col > 0) else 0\n        threshold = min(mean_val, median_val) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n        \n    # Depot Sparsification: Remove less promising direct connections to depot to diversify routes.\n    depot_threshold = np.mean(heuristic_matrix[0, 1:]) * 0.2\n    for i in range(1, n):\n        if heuristic_matrix[0, i] < depot_threshold:\n            heuristic_matrix[0, i] = 0\n        if heuristic_matrix[i, 0] < depot_threshold:\n            heuristic_matrix[i, 0] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 15th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristics combining distance, demand, location, and depot proximity.\n    Sparsifies matrix adaptively.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes, with non-linear scaling.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01  # Very strong penalty for exceeding capacity\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5) #Nonlinear scaling\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes, but less aggressively than before.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)  # Dampen the effect\n\n    # Depot Connections: Strongly promote connections to and from the depot, with distance decay.\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6)) #Proximity aware\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6)) #Proximity aware\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n    \n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        threshold = np.mean(row[row > 0]) * 0.3 #Dynamic threshold based on row average\n        heuristic_matrix[i, row < threshold] = 0\n        col = heuristic_matrix[:, i]\n        threshold = np.mean(col[col > 0]) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 16th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Enhanced heuristics combining distance, demand, location, and depot proximity.\n    Sparsifies matrix adaptively.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance: Shorter distances are preferred.\n    distance_factor = 1 / (distance_matrix + 1e-6)\n    heuristic_matrix = distance_factor.copy()\n\n    # Demand: Penalize edges connecting to high-demand nodes, with non-linear scaling.\n    demand_penalty = np.ones((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            combined_demand = demands[i] + demands[j]\n            if combined_demand > capacity:\n                demand_penalty[i, j] = 0.01  # Very strong penalty for exceeding capacity\n            else:\n                demand_penalty[i, j] = max(0.1, 1 - (combined_demand / capacity)**0.5) #Nonlinear scaling\n    heuristic_matrix *= demand_penalty\n\n    # Location: Encourage edges between spatially close nodes, but less aggressively than before.\n    spatial_proximity = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity[i, j] = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)\n    heuristic_matrix *= (0.5 * spatial_proximity + 0.5)  # Dampen the effect\n\n    # Depot Connections: Strongly promote connections to and from the depot, with distance decay.\n    depot_boost = np.ones((n, n))\n    for i in range(1, n):\n        depot_boost[0, i] = 1 + (1 / (distance_matrix[0, i] + 1e-6)) #Proximity aware\n        depot_boost[i, 0] = 1 + (1 / (distance_matrix[i, 0] + 1e-6)) #Proximity aware\n    heuristic_matrix *= depot_boost\n\n    # Connectivity Prior: Favor connections to nodes that are currently less connected\n    degree = np.sum(heuristic_matrix > 0, axis=0) + np.sum(heuristic_matrix > 0, axis=1)\n    connectivity_boost = np.zeros((n, n))\n    for i in range(1, n):\n        for j in range(1, n):\n            connectivity_boost[i, j] = (1 / (degree[i] + 1e-6)) + (1 / (degree[j] + 1e-6))\n    heuristic_matrix *= connectivity_boost\n    \n    # Adaptive Sparsification: Zero out edges based on a dynamic threshold per node\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        threshold = np.mean(row[row > 0]) * 0.3 #Dynamic threshold based on row average\n        heuristic_matrix[i, row < threshold] = 0\n        col = heuristic_matrix[:, i]\n        threshold = np.mean(col[col > 0]) * 0.3\n        heuristic_matrix[col < threshold, i] = 0\n\n    # Normalize\n    max_val = np.max(heuristic_matrix)\n    if max_val > 0:\n        heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 17th]\nimport numpy as np\n\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    \"\"\"\n    Generates prior indicators for edges in a CVRP solution using a combination of distance,\n    demand, and location-based factors. This heuristic prioritizes shorter distances,\n    penalizes edges connecting to nodes with high demand if close to full capacity,\n    and introduces a spatial clustering preference based on node proximity.\n\n    Args:\n        distance_matrix (np.ndarray): n x n distance matrix.\n        coordinates (np.ndarray): n x 2 array of node coordinates.\n        demands (np.ndarray): n array of customer demands.\n        capacity (int): Vehicle capacity.\n\n    Returns:\n        np.ndarray: n x n array of prior indicators for each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero\n    heuristic_matrix = 1 / (distance_matrix + 1e-6)\n\n    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.\n    # Depot node (index 0) shouldn't influence this, so handle it separately\n    for i in range(1, n): # Skip depot for source nodes in loop\n        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0\n            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand\n            if (demands[i] + demands[j]) > capacity:\n                heuristic_matrix[i,j] /= demand_factor*10 # Strongly discourage paths exceeding the capacity\n            else:\n                heuristic_matrix[i,j] /= (demand_factor+1)  # Penalize edges to bigger combined demands\n\n    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted \"gravitational\" effect\n    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!=j:\n                delta_x = coordinates[i, 0] - coordinates[j, 0]\n                delta_y = coordinates[i, 1] - coordinates[j, 1]\n                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + 1e-6)  # Smaller distance = Larger number\n                heuristic_matrix[i,j] *= (spatial_proximity)\n\n\n    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot\n    for i in range(1, n):\n        heuristic_matrix[0, i] *= 2  #Increase the heuristic values from the depot\n        heuristic_matrix[i, 0] *= 2  #Increase the heuristic values towards the depot\n\n    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)\n    max_val = np.max(heuristic_matrix)\n    heuristic_matrix = heuristic_matrix / max_val\n\n    return heuristic_matrix\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:\n    return 1 / distance_matrix\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}