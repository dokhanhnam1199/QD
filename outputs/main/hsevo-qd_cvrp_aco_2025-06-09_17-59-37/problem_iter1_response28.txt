```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A more sophisticated heuristics function for CVRP that considers distance,
    demand, and angular proximity to the depot.

    Args:
        distance_matrix (np.ndarray): n x n distance matrix.
        coordinates (np.ndarray): n x 2 Euclidean coordinates of nodes.
        demands (np.ndarray): Demand vector of size n.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge prior indicators (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Calculate angles from each customer to the depot (node 0)
    angles = np.arctan2(coordinates[:, 1] - coordinates[0, 1],
                        coordinates[:, 0] - coordinates[0, 0])

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance component: Inverse distance
                distance_component = 1 / distance_matrix[i, j]

                # Demand component: Encourage edges that connect customers with low and medimum demands
                demand_component = 1 / (demands[i] + demands[j] + 1e-6) # Avoid divide by zero

                # Angular proximity component:  Nodes closer to the depot tend to be more important
                angle_diff = np.abs(angles[i] - angles[j])
                angular_proximity = 1 / (angle_diff + 0.1) if angle_diff < np.pi/4 else 0.0 #Favor closer to depot
                angular_proximity = 0.0 if i == 0 or j == 0 else angular_proximity #Do not penalize for visiting or from depot

                heuristic_matrix[i, j] = (0.6 * distance_component +
                                          0.3 * demand_component +
                                          0.1 * angular_proximity)


    return heuristic_matrix
```
