```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristic function for Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.

    Args:
        distance_matrix: Distance matrix between nodes (shape: n by n).
        coordinates: Euclidean coordinates of nodes (shape: n by 2).
        demands: Vector of customer demands (shape: n).
        capacity: Vehicle capacity.

    Returns:
        A matrix of the same shape as the distance_matrix indicating the "promise" of each edge.
    """

    n = distance_matrix.shape[0]
    promise = np.zeros_like(distance_matrix)

    # Avoid division by zero and penalize self-loops heavily
    promise[distance_matrix == 0] = -np.inf
    promise[np.diag_indices_from(promise)] = -np.inf

    # 1. Distance based promise (shorter distances are better)
    promise = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Demand based promise (balance load, avoid exceeding capacity)
    #   - Edges connecting to nodes with higher demands are penalized
    demand_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            demand_penalty[i, j] = demands[i] + demands[j]

    promise -= 0.01 * demand_penalty  # Reduced penalty strength


    # 3. Location based promise (cluster nodes together)
    # edges going to a far point should have less weight.
    depot_distances = distance_matrix[0, :]
    location_penalty = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            location_penalty[i,j] = depot_distances[i] + depot_distances[j]
    promise -= 0.005 * location_penalty

    # 4. Combined promise

    return promise
```
