```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for CVRP using a combination of distance, demand, and spatial density.

    Args:
        distance_matrix: Distance between nodes (n x n).
        coordinates: Node coordinates (n x 2).
        demands: Node demands (n).
        capacity: Vehicle capacity.

    Returns:
        Prior indicators for edge inclusion (n x n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Adjust the inverse distance based on node proximity and depot proximity
    depot_distances = distance_matrix[0, :]
    proximity_factor = np.outer(depot_distances, depot_distances) # outer product creates a n x n matrix
    proximity_factor = 1 / (proximity_factor + 1e-6) # Avoid division by zero

    # Factor in the demand of each node
    demand_factor = np.outer(demands, demands) # creates a n x n matrix based on outer product
    demand_factor = 1 / (demand_factor + 1e-6) # Avoid division by zero

    # Adjust by normalized node spatial density (optional, might hurt performance)
    # Density is approximated by the inverse of sum of distances to each other node
    density = np.zeros(n)
    for i in range(n):
        density[i] = 1 / (np.sum(distance_matrix[i, :]) + 1e-6)  # inverse of sum of distances. add 1e-6 for numerical stability.
    density_factor = np.outer(density, density)

    # Combine factors - tune weights as needed.
    heuristic_matrix = (0.5 / (distance_matrix + 1e-6) + 0.3 * proximity_factor + 0.2 * demand_factor) # Original
    heuristic_matrix *= density_factor

    # Ensure no self-loops and block paths back to depot except from last customer
    for i in range(n):
        heuristic_matrix[i, i] = 0
    heuristic_matrix[0,0] = 0

    return heuristic_matrix
```
