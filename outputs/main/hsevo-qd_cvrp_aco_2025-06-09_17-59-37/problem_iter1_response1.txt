```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    This version considers distance, demand, and angular proximity to the depot.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # Calculate angles relative to the depot (node 0)
    depot_x, depot_y = coordinates[0]
    angles = np.arctan2(coordinates[:, 1] - depot_y, coordinates[:, 0] - depot_x)

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristics_matrix[i, j] = 0  # No self-loops
            else:
                # Base heuristic: Inverse distance
                heuristic_value = 1 / (distance_matrix[i, j] + 1e-6)  # Adding a small value to avoid division by zero

                # Demand consideration: Penalize edges connecting nodes with demands close to exceeding capacity
                # This helps to balance loads better.  If either node's demand is high relative to capacity, lower its prior
                demand_penalty = min(1.0, (demands[i] + demands[j]) / (2 * capacity)) #Values close to 1 are more penalized
                heuristic_value *= (1-demand_penalty)

                # Angular proximity to the depot: Favor connections that keep nodes somewhat close angularly to the depot.
                # Avoids excessively long routes that "wind around" the depot without returning.
                angle_diff = abs(angles[i] - angles[j])
                angle_proximity = 1 - (angle_diff / np.pi) # Scales angular distance from 0 to 1 then inverts it
                heuristic_value *= angle_proximity


                heuristics_matrix[i, j] = heuristic_value

    return heuristics_matrix
```
