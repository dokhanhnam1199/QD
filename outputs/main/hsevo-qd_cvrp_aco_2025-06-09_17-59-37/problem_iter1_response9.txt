```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    A more sophisticated heuristic for the Capacitated Vehicle Routing Problem (CVRP).
    This heuristic considers distance, demand, and node proximity to the depot.

    Args:
        distance_matrix: A numpy array representing the distance between each pair of nodes.
        coordinates: A numpy array representing the (x, y) coordinates of each node.
        demands: A numpy array representing the demand of each node.
        capacity: The capacity of each vehicle.

    Returns:
        A numpy array representing the desirability of each edge,
        with higher values indicating a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Heuristic components:
    # 1. Distance-based: Inverse distance (shorter distances are preferred)
    distance_heuristic = 1 / (distance_matrix + 1e-6)  # Add a small value to avoid division by zero

    # 2. Demand-based: Penalize edges connecting to nodes with high demand if close to capacity.
    demand_heuristic = np.ones((n, n))

    avg_demand = np.mean(demands[1:]) #exclude depot from avg calculation

    for i in range(1,n):
      for j in range(1, n):
        if i !=j:
            demand_heuristic[i,j] = 1.0 - min(1.0, (demands[i] + demands[j]) / (2 * capacity)) #scale between 0 and 1

    # 3. Depot proximity: Encourage edges closer to the depot, especially for high demand nodes.  Scaled by demand amount
    depot_proximity_heuristic = np.zeros((n, n))
    for i in range(1, n): #avoid the depot self loop
        for j in range(1, n):
            if i != j:
              depot_proximity_heuristic[i,j] = max(0.0, 1.0 - (distance_matrix[0,i] + distance_matrix[0,j]) / (2 * np.mean(distance_matrix[0,1:])) ) * (demands[i] + demands[j])/(2*avg_demand)

    # Combine heuristics (weighted sum)
    alpha = 0.6  # Weight for distance
    beta = 0.2   # Weight for demand
    gamma = 0.2  # Weight for depot proximity
    heuristic_matrix = alpha * distance_heuristic + beta * demand_heuristic + gamma * depot_proximity_heuristic

    # Ensure the depot node is linked appropriately
    for i in range(1, n): #edges to depot and from depot only
        heuristic_matrix[0, i] = alpha * distance_heuristic[0, i] + gamma* ( 1.0 - distance_matrix[0,i]/np.mean(distance_matrix[0,1:]))
        heuristic_matrix[i, 0] = alpha * distance_heuristic[i, 0] + gamma* ( 1.0 - distance_matrix[i,0]/np.mean(distance_matrix[0,1:]))


    return heuristic_matrix
```
