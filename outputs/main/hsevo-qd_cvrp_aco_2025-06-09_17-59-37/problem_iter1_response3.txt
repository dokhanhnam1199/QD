```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Generates heuristics for the Capacitated Vehicle Routing Problem (CVRP)
    based on a combination of distance, demand, and angular proximity to the depot.

    Args:
        distance_matrix (np.ndarray): A matrix of pairwise distances between nodes.
        coordinates (np.ndarray): Coordinates of each node (n by 2).
        demands (np.ndarray): Demands of each node.
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: A matrix of heuristic scores for each edge (n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    depot_x, depot_y = coordinates[0]

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
            else:
                # Distance component: inverse distance, penalizing longer edges
                distance_heuristic = 1 / distance_matrix[i, j]

                # Demand component: penalize connecting high-demand nodes
                # relative to remaining vehicle capacity.
                demand_penalty_i = demands[i] / capacity if i !=0 else 0
                demand_penalty_j = demands[j] / capacity if j !=0 else 0

                demand_heuristic = 1 / (1 + demand_penalty_i + demand_penalty_j)

                # Angle from depot: Favor edges connecting nodes closer in angle to depot.
                # Especially useful when combined with stochastic search.
                angle_i = np.arctan2(coordinates[i, 1] - depot_y, coordinates[i, 0] - depot_x)
                angle_j = np.arctan2(coordinates[j, 1] - depot_y, coordinates[j, 0] - depot_x)
                angle_diff = np.abs(angle_i - angle_j)
                angle_diff = np.minimum(angle_diff, 2 * np.pi - angle_diff) # Normalize for circular distance
                angle_heuristic = 1 / (1 + angle_diff)

                # Combine heuristics. Give strongest weight to distance, moderate to demand,
                # and lesser to angle difference relative to the depot.
                heuristic_matrix[i, j] = (0.6 * distance_heuristic +
                                            0.3 * demand_heuristic +
                                            0.1 * angle_heuristic)
    return heuristic_matrix
```
