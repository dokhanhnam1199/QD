```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Calculates heuristic scores for edges in a Capacitated Vehicle Routing Problem (CVRP).

    This function considers distance, node demand, and proximity to the depot when
    calculating the heuristic score for each edge. It favors shorter distances,
    edges connecting nodes with demands that, when combined, are less than the capacity,
    and edges connecting nodes closer to the depot. It also incorporates a 'gravity' concept,
    where nodes with higher demands exert a greater 'gravitational pull', influencing
    the probability of edges connecting to them.

    Args:
        distance_matrix (np.ndarray): A square matrix (n x n) representing the distance between all nodes.
        coordinates (np.ndarray): A matrix (n x 2) containing the Euclidean coordinates of each node.
        demands (np.ndarray): A vector (n) containing the demand of each node. The first element is the depot demand and it is zero.
        capacity (int): The capacity of each vehicle.

    Returns:
        np.ndarray: A matrix (n x n) of heuristic scores for each edge. Higher scores indicate more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    depot_distances = distance_matrix[0, :]  # Distances from the depot to each node
    total_demand = np.sum(demands)

    # Parameters (tuned emperically)
    alpha = 1.0  # Distance importance
    beta = 0.5   # Demand importance
    gamma = 0.7   # Depot proximity importance
    delta = 0.3  # Demand gravity importance

    for i in range(n):
        for j in range(n):
            if i != j:  # Avoid self-loops
                distance = distance_matrix[i, j]

                # Heuristic component based on distance
                distance_heuristic = alpha / distance

                # Heuristic component based on demand consideration
                demand_heuristic = 0.0
                if demands[i] + demands[j] <= capacity:
                    demand_heuristic = beta # Assign some value if meets the capacity criteria.  Could use 1/(demands[i] + demands[j])

                # Heuristic component based on depot proximity
                depot_proximity_heuristic = gamma / (depot_distances[i] + depot_distances[j]) # Prefer smaller sum, thus smaller distance.

                # Heuristic component based on gravity/demand influence
                demand_gravity = delta * (demands[i] + demands[j]) / total_demand # Normalized to total_demand

                # Combine heuristic components
                heuristic_matrix[i, j] = (
                    distance_heuristic + demand_heuristic + depot_proximity_heuristic + demand_gravity
                )

    return heuristic_matrix
```
