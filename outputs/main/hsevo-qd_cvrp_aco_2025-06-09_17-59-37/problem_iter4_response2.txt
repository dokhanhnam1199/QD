import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int,
                  distance_epsilon: float = 1.8764669186032778e-06, demand_factor_high_penalty: float = 9.96861337780468,
                  demand_factor_low_penalty_addition: float = 1.3751202542198828, spatial_proximity_epsilon: float = 6.545985880030561e-06,
                  depot_connection_boost: float = 1.9215616369513184) -> np.ndarray:
    """
    Generates prior indicators for edges in a CVRP solution using a combination of distance,
    demand, and location-based factors. This heuristic prioritizes shorter distances,
    penalizes edges connecting to nodes with high demand if close to full capacity,
    and introduces a spatial clustering preference based on node proximity.

    Args:
        distance_matrix (np.ndarray): n x n distance matrix.
        coordinates (np.ndarray): n x 2 array of node coordinates.
        demands (np.ndarray): n array of customer demands.
        capacity (int): Vehicle capacity.
        distance_epsilon (float): Small constant to avoid division by zero in distance calculation. Default is 1e-6.
        demand_factor_high_penalty (float): Factor to strongly discourage paths exceeding capacity. Default is 10.0.
        demand_factor_low_penalty_addition (float): Constant added to the demand factor when below capacity. Default is 1.0.
        spatial_proximity_epsilon (float): Small constant to avoid division by zero in spatial proximity calculation. Default is 1e-6.
        depot_connection_boost (float): Factor to increase heuristic values for depot connections. Default is 2.0.

    Returns:
        np.ndarray: n x n array of prior indicators for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Distance-based heuristic: Inverse of distance (shorter distances preferred). Add small constant to avoid division by zero
    heuristic_matrix = 1 / (distance_matrix + distance_epsilon)

    # Demand-based heuristic: Penalize edges connecting to high-demand nodes, especially when capacity is tight.
    # Depot node (index 0) shouldn't influence this, so handle it separately
    for i in range(1, n): # Skip depot for source nodes in loop
        for j in range(1, n):  #Skip depot for destination nodes in loop. Demands[0]=0
            demand_factor = (demands[i] + demands[j]) / (2 * capacity)  #Normalized Combined Demand
            if (demands[i] + demands[j]) > capacity:
                heuristic_matrix[i,j] /= demand_factor*demand_factor_high_penalty # Strongly discourage paths exceeding the capacity
            else:
                heuristic_matrix[i,j] /= (demand_factor+demand_factor_low_penalty_addition)  # Penalize edges to bigger combined demands

    # Location-based clustering heuristic: Encourage edges between nodes that are spatially close, based on an adjusted "gravitational" effect
    # This step biases towards forming local clusters, improving chance of using vehicle space efficiently. Avoids creating very long paths
    for i in range(1, n):
        for j in range(1, n):
            if i!=j:
                delta_x = coordinates[i, 0] - coordinates[j, 0]
                delta_y = coordinates[i, 1] - coordinates[j, 1]
                spatial_proximity = 1 / (np.sqrt(delta_x**2 + delta_y**2) + spatial_proximity_epsilon)  # Smaller distance = Larger number
                heuristic_matrix[i,j] *= (spatial_proximity)


    # Adjust Depot Connections: Promote initial connections from the depot and return connections back to depot
    for i in range(1, n):
        heuristic_matrix[0, i] *= depot_connection_boost  #Increase the heuristic values from the depot
        heuristic_matrix[i, 0] *= depot_connection_boost  #Increase the heuristic values towards the depot

    # Normalize to be between 0 and 1 (optional but useful for certain sampling methods)
    max_val = np.max(heuristic_matrix)
    heuristic_matrix = heuristic_matrix / max_val

    return heuristic_matrix
