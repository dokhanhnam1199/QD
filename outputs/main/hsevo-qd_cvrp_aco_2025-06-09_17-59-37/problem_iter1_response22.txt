```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for the Capacitated Vehicle Routing Problem (CVRP) using stochastic solution sampling principles.

    Args:
        distance_matrix: A numpy array of shape (n, n) representing the distance between each pair of nodes.
        coordinates: A numpy array of shape (n, 2) representing the (x, y) coordinates of each node.
        demands: A numpy array of shape (n,) representing the demand of each customer node.  Node 0 is the depot.
        capacity: An integer representing the capacity of each vehicle.

    Returns:
        A numpy array of the same shape as distance_matrix, representing prior indicators of how promising
        it is to include each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros((n, n))

    # 1. Distance-based heuristic (inverse distance)
    heuristics_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Demand-based heuristic (penalize edges connecting nodes with high combined demand)
    for i in range(n):
        for j in range(n):
            if i != j:
                combined_demand = demands[i] + demands[j]
                heuristics_matrix[i, j] /= (1 + combined_demand / capacity)  # Scale by capacity

    # 3. Depot proximity heuristic (encourage edges connecting to the depot)
    depot_proximity = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            depot_proximity[i,j] = np.exp(-distance_matrix[0,i]) + np.exp(-distance_matrix[0,j])

    heuristics_matrix = heuristics_matrix * depot_proximity #Combine distance, capacity and depot connection

    # 4. Angle-based heuristic (penalize sharp turns to improve smoothness)
    angle_penalty = np.ones((n, n))
    for i in range(1,n):
       for j in range(1,n):
           if i != j:
               vector_i = coordinates[i] - coordinates[0]
               vector_j = coordinates[j] - coordinates[0]
               norm_i = np.linalg.norm(vector_i)
               norm_j = np.linalg.norm(vector_j)
               if norm_i > 0 and norm_j > 0:
                  cos_angle = np.dot(vector_i, vector_j) / (norm_i * norm_j)
                  angle_penalty[i, j] = (1+cos_angle) # Angle range is [-1,1]. So 0 means sharp turn.
               else:
                  angle_penalty[i, j] = 1
    heuristics_matrix = heuristics_matrix * angle_penalty

    # Ensure depot connections are always preferred. Important for starting.
    for i in range(1, n):
        heuristics_matrix[0, i] = heuristics_matrix[0,i] * 10 # Strongly favour routes from depot

    return heuristics_matrix
```
