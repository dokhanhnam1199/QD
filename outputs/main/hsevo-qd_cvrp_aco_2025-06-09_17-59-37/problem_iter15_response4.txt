```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """A more sophisticated heuristic for the CVRP that combines several factors."""
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # 1. Inverse Distance with Exponential Decay
    distance_factor = np.exp(-distance_matrix / np.mean(distance_matrix))
    heuristic_matrix = distance_factor.copy()

    # 2. Demand-Based Penalty with Adaptive Scaling
    demand_penalty = np.ones((n, n))
    demand_scaling = np.mean(demands[1:]) / capacity  # Adjusts based on average demand
    for i in range(1, n):
        for j in range(1, n):
            combined_demand = demands[i] + demands[j]
            if combined_demand > capacity:
                demand_penalty[i, j] = 0.0001  # Severe penalty
            else:
                demand_ratio = (combined_demand / capacity)
                demand_penalty[i, j] = max(0.01, 1 - (demand_ratio ** (0.5 + demand_scaling))) # Adjust exponent

    heuristic_matrix *= demand_penalty

    # 3. Angle and Distance to Depot
    depot_angle_proximity = np.zeros((n, n))
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                # Angle from depot to i to j
                v1 = coordinates[i] - coordinates[0]
                v2 = coordinates[j] - coordinates[i]
                v1 /= np.linalg.norm(v1) + 1e-6
                v2 /= np.linalg.norm(v2) + 1e-6
                angle = np.arccos(np.clip(np.dot(v1, v2), -1.0, 1.0))

                # Distance from i and j to depot
                dist_i_depot = distance_matrix[i, 0]
                dist_j_depot = distance_matrix[j, 0]
                depot_proximity = np.exp(-(dist_i_depot + dist_j_depot) / (2 * np.mean(distance_matrix[0, 1:])))

                depot_angle_proximity[i, j] = (1 - (angle / np.pi)**2) * depot_proximity

    heuristic_matrix *= (0.6 * depot_angle_proximity + 0.4)

    # 4. Clustering Encouragement (Similar Demands)
    demand_similarity = np.zeros((n, n))
    mean_demand = np.mean(demands[1:])
    for i in range(1, n):
        for j in range(1, n):
            demand_diff = abs(demands[i] - demands[j])
            demand_similarity[i, j] = np.exp(-demand_diff / mean_demand) # Higher if demands are similar

    heuristic_matrix *= (0.2 * demand_similarity + 0.8) # blend with other factors

    # 5. Iterative Sparsification based on percentile
    percentile_threshold = 20 # Keep top 20%
    for i in range(n):
        row = heuristic_matrix[i, :]
        threshold = np.percentile(row[row > 0], percentile_threshold) if np.any(row > 0) else 0
        heuristic_matrix[i, row < threshold] = 0

        col = heuristic_matrix[:, i]
        threshold = np.percentile(col[col > 0], percentile_threshold) if np.any(col > 0) else 0
        heuristic_matrix[col < threshold, i] = 0

    # 6. Dynamic Depot Connection Prioritization (based on total demand)
    total_demand = np.sum(demands[1:])
    num_vehicles_needed = np.ceil(total_demand / capacity)
    top_connections = int(n / num_vehicles_needed)

    depot_connections = distance_matrix[0, 1:].copy()
    depot_connection_indices = np.argsort(depot_connections)[:top_connections] + 1  # Indices of closest nodes to depot

    depot_boost = np.zeros((n, n))
    for i in depot_connection_indices:
      depot_boost[0, i] = 1.5
      depot_boost[i, 0] = 1.5

    heuristic_matrix *= (0.3 * depot_boost + 0.7)

    # 7. Normalize
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        heuristic_matrix = heuristic_matrix / max_val

    return heuristic_matrix
```
