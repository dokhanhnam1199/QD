```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics function for Solving Capacitated Vehicle Routing Problem (CVRP) via stochastic solution sampling.
    CVRP requires finding the shortest path that visits all given nodes and returns to the starting node.
    Each node has a demand and each vehicle has a capacity.
    The total demand of the nodes visited by a vehicle cannot exceed the vehicle capacity.
    When the total demand exceeds the vehicle capacity, the vehicle must return to the starting node.

    This version considers distance, demand, and angular proximity to the depot to create a better heuristic.

    Args:
        distance_matrix (np.ndarray): Distance matrix (shape: n by n).
        coordinates (np.ndarray): Euclidean coordinates of nodes (shape: n by 2).
        demands (np.ndarray): Vector of customer demands (shape: n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Prior indicators of how promising it is to include each edge in a solution (shape: n by n).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix)

    # Parameters to control the influence of each factor. These are somewhat arbitrary and can be tuned.
    distance_weight = 1.0
    demand_weight = 0.5
    angle_weight = 0.5

    # Normalize demands and distances to range [0, 1] for stability.  Avoid division by zero.
    normalized_demands = demands / np.max(demands[1:]) if np.max(demands[1:]) > 0 else np.zeros_like(demands) # skip depot (index 0)
    normalized_distance = distance_matrix / np.max(distance_matrix) if np.max(distance_matrix) > 0 else np.zeros_like(distance_matrix)

    # Calculate angles to depot
    depot_coords = coordinates[0]
    angles = np.zeros(n)
    for i in range(1, n):  # Avoid calculating the angle from depot to depot
        delta_x = coordinates[i, 0] - depot_coords[0]
        delta_y = coordinates[i, 1] - depot_coords[1]
        angles[i] = np.arctan2(delta_y, delta_x)  # Returns angle in radians [-pi, pi]

    # Heuristic calculation
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops

            else:
                # Demand factor: prefer edges connecting nodes with lower combined demands (normalized to capacity).
                # demand_factor = 1 - min((demands[i] + demands[j]) / capacity, 1)

                # Penalize higher normalized demand
                demand_factor = 1 - (normalized_demands[i] + normalized_demands[j]) / 2

                # Angle factor: prefer edges that maintain a similar angle from the depot.
                angle_difference = abs(angles[i] - angles[j])
                angle_factor = 1 - (angle_difference / np.pi) # Scale to [0,1]

                # Combine factors
                heuristic_matrix[i, j] = (
                    distance_weight * (1 / (normalized_distance[i, j] + 1e-9))  # Add small value to avoid division by zero
                    + demand_weight * demand_factor
                    + angle_weight * angle_factor
                )


    return heuristic_matrix
```
