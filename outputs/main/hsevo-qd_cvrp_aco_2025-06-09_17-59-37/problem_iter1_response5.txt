```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, coordinates: np.ndarray, demands: np.ndarray, capacity: int) -> np.ndarray:
    """
    Heuristics for Capacitated Vehicle Routing Problem (CVRP) based on distance, demand,
    and angular relationships.  Prioritizes shorter distances, considers demand to avoid
    overloading vehicles, and incorporates angular considerations to encourage
    spatially coherent routes (less zig-zagging).

    Args:
        distance_matrix (np.ndarray): Distance matrix (n x n).
        coordinates (np.ndarray): Node coordinates (n x 2).
        demands (np.ndarray): Node demands (n).
        capacity (int): Vehicle capacity.

    Returns:
        np.ndarray: Edge inclusion indicators (n x n).
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros((n, n))

    # Parameters (tuned through experimentation; adjust for better performance)
    distance_weight = 1.0    # Relative importance of distance
    demand_weight = 0.5      # Relative importance of demand
    angle_weight = 0.2       # Relative importance of angular coherence

    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0  # No self-loops
                continue

            # Distance component (higher score for shorter distances)
            distance_score = 1 / distance_matrix[i, j]

            # Demand component (penalize edges that quickly lead to capacity violations)
            demand_score = 1.0  # Default, no penalty
            if i == 0:  # Starting from the depot. Consider immediate capacity constraints to *other* node.
                if demands[j] > capacity: #cannot pick immediately
                   demand_score = 0.0
                else:
                   demand_score = 1.0 #fine.
            else: #starting from another location. Not as immediate penalty.
                demand_score = 1.0 / (demands[j] + 1e-6) # slightly more penalize based on the demand of next customer

            # Angular coherence component (favor edges that minimize turns)
            angle_score = 0.0
            if i != 0:  # Only apply angle heuristic when not starting from the depot

                #Find best prior node to calculate angle change. If we came from the depot, there is no angle calculation.
                best_k = -1
                best_prior_distance = np.inf

                for k in range(n):
                  if k != i and k!= j: #dont compare to current node
                      if distance_matrix[k,i] < best_prior_distance:
                          best_prior_distance = distance_matrix[k,i]
                          best_k = k
                if best_k != -1: #able to find previous city to get incoming angle
                    # Calculate angle between vectors (k -> i) and (i -> j)
                    vector1 = coordinates[i] - coordinates[best_k]
                    vector2 = coordinates[j] - coordinates[i]

                    #Normalize to avoid divide by zero
                    norm1 = np.linalg.norm(vector1)
                    norm2 = np.linalg.norm(vector2)

                    if norm1 > 0 and norm2 > 0:
                        vector1 = vector1 / norm1
                        vector2 = vector2 / norm2
                        dot_product = np.dot(vector1, vector2)
                        angle = np.arccos(np.clip(dot_product, -1.0, 1.0)) #radians
                        angle_score = 1 / (np.degrees(angle) + 1e-6)  # Smaller angle = higher score
                    else:
                      angle_score = 0 #set to zero.


            # Combine the scores (weighted sum)
            heuristic_matrix[i, j] = (
                distance_weight * distance_score +
                demand_weight * demand_score +
                angle_weight * angle_score
            )

    return heuristic_matrix
```
