```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics for TSP using stochastic solution sampling.

    Combines multiple factors to estimate edge importance:
    - Inverse distance
    - Node degree (favoring nodes with fewer connections to avoid subcycles)
    - Global path contribution (estimated by considering shortest paths
      between nodes not directly connected by the edge).

    Args:
        distance_matrix: Distance matrix (n x n) representing edge costs.

    Returns:
        A heuristic matrix (n x n) indicating the prior probability of
        including each edge in a solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix)

    # Inverse distance: shorter edges are more promising.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding small constant to avoid division by zero.

    # Node degree: prefer connecting to less-connected nodes to avoid short cycles early on.
    degree = np.sum(distance_matrix > 0, axis=0) # considers nodes connected with edge

    # Global path contribution: Estimating how the edge contributes to reducing total path distance
    # by considering shortest paths between unconnected nodes.
    global_path_contribution = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] == 0:
                #If not directly connected find the distance
                shortest_path = float('inf')
                for k in range(n):
                    if k!=i and k!=j and distance_matrix[i,k]>0 and distance_matrix[k,j] > 0:
                            shortest_path = min(shortest_path,distance_matrix[i,k]+distance_matrix[k,j])

                global_path_contribution[i, j] = 1/(shortest_path + 1e-9)
    global_path_contribution = global_path_contribution + global_path_contribution.T
    # Combine factors. Experiment with different weights.
    heuristics = (0.6 * inverse_distance +
                  0.2 * (1 / (degree[np.newaxis, :] + degree[:, np.newaxis] + 1e-9)) +  # Encourage connecting to nodes with small degrees.
                  0.2 * global_path_contribution
                 )

    #Sparsify the matrix. Removes edges with extremely low probabilites
    threshold = np.quantile(heuristics[heuristics > 0], 0.2)
    heuristics[heuristics < threshold] = 0

    return heuristics
```
