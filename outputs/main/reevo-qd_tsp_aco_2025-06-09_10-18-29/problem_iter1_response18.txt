```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using stochastic solution sampling.

    This function combines several factors to estimate the probability of including an edge in the optimal tour.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j] represents the distance
                                       between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the heuristic
                    value (probability) of including the corresponding edge in the TSP tour.  Higher values
                    indicate a more promising edge.
    """

    n = distance_matrix.shape[0]

    # Initialize the heuristic matrix with the inverse of the distance (basic heuristic)
    heuristic_matrix = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Factor 1: Nearest Neighbor heuristic
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Find the 3 nearest neighbors for each node

    for i in range(n):
        for j in range(n):
            if j not in nearest_neighbors[i]:
                heuristic_matrix[i, j] *= 0.1  # Reduce the probability for non-nearest neighbors

    # Factor 2: Triangle Inequality - Penalize long edges
    mean_distance = np.mean(distance_matrix)
    heuristic_matrix = heuristic_matrix * np.exp(-(distance_matrix / mean_distance)) # Exponential decay based on distance relative to the mean

    # Factor 3: Degree Penalty (penalize high-degree nodes in the solution)
    # Assuming that on average, each node has 2 neighbors
    degree_penalty = np.ones((n, n))
    for i in range(n):
      for j in range(n):
        degree_penalty[i,j] = 1 # Default, no penality

    heuristic_matrix = heuristic_matrix * degree_penalty


    # Factor 4: Sparsification (set low probabilities to zero)
    threshold = np.percentile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 20)  # Keep top 80% of edges
    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Ensure symmetry (TSP is undirected)
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    # Normalize the matrix to represent probabilities
    heuristic_matrix = heuristic_matrix / np.sum(heuristic_matrix)


    return heuristic_matrix
```
