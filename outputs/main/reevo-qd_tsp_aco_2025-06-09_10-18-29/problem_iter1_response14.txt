```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using stochastic solution sampling principles.

    This version combines multiple factors to estimate the promise of including an edge in a solution
    and sparsifies the resulting matrix.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element represents the
                      "promise" of including the corresponding edge in a good TSP solution.  Higher values
                      indicate a more promising edge.  Unpromising edges are set to zero.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate inverse distance (shorter edges are generally better)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Calculate average distance to each node
    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True)

    # Calculate distance from each node to its nearest neighbors
    nearest_neighbor_distances = np.zeros(n)
    for i in range(n):
        temp_distances = np.copy(distance_matrix[i, :])
        temp_distances[i] = np.inf # Ensure we don't choose the node itself
        nearest_neighbor_distances[i] = np.min(temp_distances)

    # Calculate sum of reciprocals of distances to the 3 nearest neighbors
    reciprocal_nearest_neighbor_sums = np.zeros((n, n))
    for i in range(n):
        distances = distance_matrix[i, :]
        nearest_indices = np.argsort(distances)[1:4]  # Indices of 3 nearest neighbors, excluding self
        reciprocal_nearest_neighbor_sums[i, nearest_indices] = 1 / (distance_matrix[i, nearest_indices] + 1e-9)
        reciprocal_nearest_neighbor_sums[i, :] = np.sum(reciprocal_nearest_neighbor_sums[i, :])

    for i in range(n):
        for j in range(n):
            if i != j:
                # Combine factors:
                # 1. Inverse Distance: Favors shorter distances.
                # 2. Distance from Node to Average Distance to Others: penalizes edges if start/end nodes have large distance to others
                # 3. Nearest Neighbor indicator: Helps link up with other nodes.

                heuristic_matrix[i, j] = (
                    inverse_distance[i, j]
                    / (avg_distances[i] + avg_distances[j]) # nodes "centrally" located get a boost
                    * reciprocal_nearest_neighbor_sums[i,j]
                )
            else:
                heuristic_matrix[i, j] = 0  # No self-loops

    # Sparsify the matrix by setting elements below a threshold to zero
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.25) # Keep top 75% of edges
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
