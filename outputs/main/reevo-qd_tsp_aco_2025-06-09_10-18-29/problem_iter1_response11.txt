```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using stochastic solution sampling and edge weighting.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix,
                      representing the prior indicators (edge weights). Higher values
                      indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristics_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance: Shorter edges are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Node degree preference: Avoid high-degree nodes early on (reduces chance of isolated sub-tours)
    degree_preference = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            if i != j:
                degree_i = np.sum(inverse_distance[i, :]) - inverse_distance[i,i]
                degree_j = np.sum(inverse_distance[j, :]) - inverse_distance[j,j]

                degree_preference[i, j] = 1 / (degree_i * degree_j + 1e-9)

    # Nearest neighbor consideration: connecting to nearest neighbors is often a good start
    nearest_neighbor = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        distances = distance_matrix[i, :]
        nearest_neighbor_index = np.argsort(distances)[1] # Excluding the node itself. Index 0 will be i.
        nearest_neighbor[i, nearest_neighbor_index] = 1
        nearest_neighbor[nearest_neighbor_index, i] = 1

    # Combine factors with weights
    heuristics_matrix = (0.6 * inverse_distance + 0.2 * degree_preference + 0.2 * nearest_neighbor)

    # Sparsify the matrix (optional): Set low-probability edges to zero
    threshold = np.percentile(heuristics_matrix[heuristics_matrix > 0], 20)  # Keep top 80%
    heuristics_matrix[heuristics_matrix < threshold] = 0

    # Ensure diagonal elements are zero
    for i in range(n):
        heuristics_matrix[i, i] = 0

    return heuristics_matrix
```
