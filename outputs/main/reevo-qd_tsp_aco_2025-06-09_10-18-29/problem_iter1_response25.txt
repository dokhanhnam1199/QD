```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between cities.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, representing the heuristic values
                    for each edge. Higher values indicate a more promising edge.  Elements where no edge is viable will be 0.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate nearest neighbors for each city.  Consider only edges that connect to at least one of these.
    nearest_neighbors = []
    for i in range(n):
        distances = distance_matrix[i].copy()
        distances[i] = np.inf  # Avoid self-loops

        nearest_indices = np.argsort(distances)[:3] # Consider top 3 nearest neighbors
        nearest_neighbors.append(nearest_indices)

    # Edge weighting parameters:
    distance_weight = 1.0
    neighbor_weight = 0.5
    global_connectivity_weight = 0.2
    sparsity_threshold = 0.1 # Set edges with heuristic values below this to zero for sparsification.

    # Compute an edge rating, edges to nearby neighbors should get higher prior
    for i in range(n):
        for j in range(n):
            if i == j:
                heuristic_matrix[i, j] = 0.0  # No self-loops
                continue

            distance = distance_matrix[i, j]

            # Give higher score to shorter distances
            distance_heuristic = distance_weight / (distance + 1e-9) # Adding small constant for numerical stability

            # Prioritize connections to nearest neighbors:
            neighbor_heuristic = 0.0
            if j in nearest_neighbors[i] or i in nearest_neighbors[j]:
                neighbor_heuristic = neighbor_weight
            # Global Connectivity:  Encourage connections between disparate parts of the path by encouraging connecting to least-connected cities
            city_i_connectivity = np.sum(distance_matrix[i, :] < np.inf) # Number of finite distance entries to i
            city_j_connectivity = np.sum(distance_matrix[j, :] < np.inf) # Number of finite distance entries to j
            global_connectivity_heuristic = global_connectivity_weight / (city_i_connectivity + city_j_connectivity + 1e-9)

            # Combine the heuristics
            heuristic_matrix[i, j] = distance_heuristic + neighbor_heuristic + global_connectivity_heuristic

    # Sparsify the matrix: remove weak edges
    max_val = np.max(heuristic_matrix)
    if max_val > 0:
        normalized_matrix = heuristic_matrix / max_val
        heuristic_matrix[normalized_matrix < sparsity_threshold] = 0.0

    return heuristic_matrix
```
