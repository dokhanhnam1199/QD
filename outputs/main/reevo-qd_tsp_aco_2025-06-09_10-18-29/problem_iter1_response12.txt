```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristics function for solving Traveling Salesman Problem (TSP) via stochastic solution sampling.

    This version combines multiple factors to determine edge selection promise and sparsifies the matrix.

    Args:
        distance_matrix (np.ndarray): A distance matrix representing the distances between nodes.

    Returns:
        np.ndarray: A matrix of the same shape as the input, indicating the promise of each edge.
                     Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate the inverse distance (initial promise)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Calculate node degree preference
    degree_preference = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        # Encourage connection to nodes with few close neighbors
        distances_to_i = distance_matrix[i, :]
        sorted_indices = np.argsort(distances_to_i)
        k_nearest = sorted_indices[1:min(4, n)] #consider k nearest neighbours for degree calculation where k is up to 3 neighbours excluding self
        degree_preference[i, k_nearest] = 1


    # Combine factors
    heuristic_matrix = inverse_distance + 0.5*degree_preference # Weight inverse distance highest


    # Sparsify the matrix (optional, but can improve efficiency)
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2) # Only keep top 80% of edges
    heuristic_matrix[heuristic_matrix < threshold] = 0
    np.fill_diagonal(heuristic_matrix, 0) # Remove self loops

    return heuristic_matrix
```
