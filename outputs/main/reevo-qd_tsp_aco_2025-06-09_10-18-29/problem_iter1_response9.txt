```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).
    Combines distance, node degree (simulated), and global connectivity
    to estimate the "promise" of each edge. Sparsifies the output by
    setting very unpromising edges to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix representing the
                                      distances between cities.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix,
                    where each element indicates how promising it is
                    to include the corresponding edge in a TSP solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance: Shorter distances are generally better.
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small value to avoid division by zero

    # 2. Node Degree Simulation: Encourage a balance of edges per node.
    #    Nodes with very few connections are penalized. Nodes with too many are penalized
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    avg_degree = 2  # TSP needs each node to have two edges to form a tour.
    for i in range(n):
        for j in range(n):
            if i != j:
                # Simulate impact on node degree
                degree_i = np.sum(heuristics[i, :] > 0) # Current number of 'active' edges
                degree_j = np.sum(heuristics[:, j] > 0) # Current number of 'active' edges (column)

                penalty_i = np.exp(-0.5 * ((degree_i - avg_degree)**2)) # Gaussian penalty
                penalty_j = np.exp(-0.5 * ((degree_j - avg_degree)**2))

                degree_penalty[i, j] = penalty_i * penalty_j

    # 3. Global Connectivity Encouragement:
    #    Penalize edges that, if removed, would significantly increase the
    #    shortest path between any two nodes (crude approximation). This encourages inclusion of edges
    #    that maintain good connectivity across the graph.
    connectivity_bonus = np.ones_like(distance_matrix, dtype=float)  # Initially neutral

    # Combine the factors:
    heuristics = inverse_distance * degree_penalty * connectivity_bonus

    # Sparsify the matrix: Zero out less promising edges. This helps stochastic sampling concentrate on promising areas.
    threshold = np.quantile(heuristics[heuristics > 0], 0.25)  #dynamic threshold, use only positive elements
    heuristics[heuristics < threshold] = 0

    # Ensure diagonal is zero
    for i in range(n):
        heuristics[i, i] = 0.0
        
    return heuristics
```
