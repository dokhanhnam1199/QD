{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # Heuristic 2: Nearest neighbor desirability\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(1, min(4, n)):  # Give a bonus to the first 3 nearest neighbors\n            neighbor_index = nearest_neighbors[i, j]\n            nearest_neighbor_bonus[i, neighbor_index] = 1.0 / j # closer neighbors get higher bonus\n\n    # Heuristic 3: Avoidance of edges that are part of very long distances for the current city (penalty)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, ::-1]\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(min(3, n)):\n             neighbor_index = farthest_neighbors[i, j]\n             farthest_neighbor_penalty[i, neighbor_index] = -0.5  # Negative penalty\n\n\n    # Combine heuristics\n    heuristic_matrix = inverse_distance + nearest_neighbor_bonus + farthest_neighbor_penalty\n\n\n    # Sparsify the matrix (optional: keep only top k edges for each node)\n    k = min(5, n - 1) #keep at least 1 edge\n    for i in range(n):\n      row = heuristic_matrix[i, :]\n      threshold = np.sort(row)[-k]  # Find the kth largest value\n      heuristic_matrix[i, row < threshold] = 0.0 #set the value below k to zero.\n\n    # Normalize to 0-1 range (optional)\n    max_val = np.max(heuristic_matrix)\n    min_val = np.min(heuristic_matrix)\n\n    if max_val > min_val:\n       heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)\n    else:\n        heuristic_matrix[:] = 1.0  # if all heuristics are equal\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n    This version prioritizes stronger, direct neighbor bonuses/penalties, simpler\n    combinations, and aggressive sparsification with robust normalization.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Nearest neighbor bonus (focus on immediate neighbors)\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        neighbor_index = nearest_neighbors[i, 1]  # Only the very nearest neighbor\n        nearest_neighbor_bonus[i, neighbor_index] = 1.0\n\n    # Heuristic 3: Farthest neighbor penalty (avoid long edges)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, -1] #only the furthest\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n\n    for i in range(n):\n         neighbor_index = farthest_neighbors[i]\n         farthest_neighbor_penalty[i, neighbor_index] = -0.5\n\n    # Combined Heuristic (equal weights for simplicity)\n    heuristic_matrix = inverse_distance + nearest_neighbor_bonus + farthest_neighbor_penalty\n\n    # Aggressive Sparsification: Keep only top 20% of edges per row\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        threshold = np.percentile(row, 80)\n        heuristic_matrix[i, row < threshold] = 0.0\n\n    # Robust Normalization (row-wise softmax)\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        row_exp = np.exp(row - np.max(row))  # for numerical stability\n        row_sum = np.sum(row_exp)\n        if row_sum > 0:\n            heuristic_matrix[i, :] = row_exp / row_sum\n        else:\n            heuristic_matrix[i, :] = 1.0 / n  # Handle the case where all values are -inf\n\n    return heuristic_matrix\n\n[Reflection]\nFocus on strong neighbor signals, aggressive sparsification, and robust normalization like row-wise softmax.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}