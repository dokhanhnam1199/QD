```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This version combines several factors to determine the "promisingness"
    of including each edge in a solution. It considers:

    1.  Inverse distance: Shorter edges are preferred.
    2.  Nearest neighbor influence: Edges connecting to nodes with high
        'nearest neighbor density' are encouraged (nodes connected to many other nodes which are nearby are good)
    3. Sparsification: edges are pruned, so those are never selected.

    Args:
        distance_matrix (np.ndarray): A square matrix where
            `distance_matrix[i, j]` represents the distance between node `i`
            and node `j`.

    Returns:
        np.ndarray: A matrix of the same shape as `distance_matrix`, where
            each element indicates how promising it is to include the
            corresponding edge in a solution. Higher values indicate more
            promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to prevent division by zero.

    # 2. Nearest Neighbor Influence
    nearest_neighbor_density = np.zeros(n)
    for i in range(n):
        distances = distance_matrix[i, :]
        sorted_indices = np.argsort(distances)[1:6]  # Excluding itself and considering top 5 nearest neighbors
        nearest_neighbor_density[i] = np.sum(1 / (distances[sorted_indices] + 1e-9))  # Sum of inverse distances

    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = (
                    inverse_distance[i, j]
                    + 0.5 * (nearest_neighbor_density[i] + nearest_neighbor_density[j])
                )

    # 3. Sparsification (Pruning unlikely edges)
    # Thresholding: Keep only top k edges for each node

    k = int(np.sqrt(n))  # Dynamic k: depends on the input size, square root seems like a good number
    for i in range(n):
      row = heuristic_matrix[i, :]
      indices = np.argsort(row)[::-1][k:]  # Get indices of the elements to prune (smallest first)
      heuristic_matrix[i, indices] = 0 # zero out those elements
      heuristic_matrix[indices,i] = 0 # Maintain Symmetry - very important in TSP.
    return heuristic_matrix
```
