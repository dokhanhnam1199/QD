```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors
    to estimate the promise of each edge.  It aims to provide a better initial sampling
    distribution for stochastic solvers.

    Combines inverse distance, nearest neighbor information, and a sparsification strategy.
    """
    n = distance_matrix.shape[0]

    # 1. Inverse Distance: Basic indicator, shorter distances are more promising
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to prevent division by zero

    # 2. Nearest Neighbor Consideration: Penalize edges that don't connect to a node's nearest neighbors
    nearest_neighbors = np.zeros((n, n))
    for i in range(n):
        # Find indices of k-nearest neighbors excluding itself
        distances_from_i = distance_matrix[i, :]
        nearest_neighbor_indices = np.argsort(distances_from_i)[1:4] # Top 3 nearest neighbors
        for neighbor_index in nearest_neighbor_indices:
            nearest_neighbors[i, neighbor_index] = 1
            nearest_neighbors[neighbor_index, i] = 1

    # 3. Sparsification: Zero out edges that are considered very long compared to others
    median_distance = np.median(distance_matrix[distance_matrix > 0]) # Excluding zeros (if any) during median calc
    sparsification_threshold = 2.5 * median_distance # remove edges significantly larger than the typical distance

    # Combine the factors
    heuristic_matrix = inverse_distance * (0.7 + 0.3*nearest_neighbors) # Weighting and using NN information to enhance

    heuristic_matrix[distance_matrix > sparsification_threshold] = 0 # Explicit sparsification

    np.fill_diagonal(heuristic_matrix, 0) # remove self loops

    return heuristic_matrix
```
