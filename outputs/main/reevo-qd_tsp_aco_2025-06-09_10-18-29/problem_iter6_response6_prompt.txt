{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # Heuristic 2: Nearest neighbor desirability\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(1, min(5, n)):  # Give a bonus to the first 4 nearest neighbors\n            neighbor_index = nearest_neighbors[i, j]\n            nearest_neighbor_bonus[i, neighbor_index] = 1.0 / j # closer neighbors get higher bonus\n\n    # Heuristic 3: Avoidance of edges that are part of very long distances for the current city (penalty)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, ::-1]\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(min(4, n)):\n             neighbor_index = farthest_neighbors[i, j]\n             farthest_neighbor_penalty[i, neighbor_index] = -0.3 / (j+1) # smaller penalty for nodes closer to the i\n\n    # Heuristic 4: Node Degree Penalty (discourage high degree nodes early on)\n    degree_penalty = np.zeros_like(distance_matrix, dtype=float)\n    avg_distance = np.mean(distance_matrix) # Characteristic scale for \"long\" edges.\n\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > avg_distance:\n                degree_penalty[i,j] = -0.1\n\n\n    # Combine heuristics with adaptive weights\n    alpha = 0.5\n    beta = 0.3\n    gamma = 0.2\n    delta = 0.1\n\n    heuristic_matrix = alpha * inverse_distance + beta * nearest_neighbor_bonus + gamma * farthest_neighbor_penalty + delta * degree_penalty\n\n\n    # Sparsify the matrix (optional: keep only top k edges for each node)\n    k = min(6, n - 1) #keep at least 1 edge\n    for i in range(n):\n      row = heuristic_matrix[i, :]\n      threshold = np.sort(row)[-k]  # Find the kth largest value\n      heuristic_matrix[i, row < threshold] = 0.0 #set the value below k to zero.\n\n    # Normalize to 0-1 range (optional)\n    max_val = np.max(heuristic_matrix)\n    min_val = np.min(heuristic_matrix)\n\n    if max_val > min_val:\n       heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)\n    else:\n        heuristic_matrix[:] = 1.0  # if all heuristics are equal\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # Heuristic 2: Nearest neighbor bonus (stronger penalty for non-neighbors)\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        neighbor_index = nearest_neighbors[i, 1]  # Only consider the very nearest neighbor\n        nearest_neighbor_bonus[i, neighbor_index] = 1.0  # Strong bonus for the nearest neighbor\n\n    # Heuristic 3: Farthest neighbor penalty (direct penalty)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, -1] #only penalize the farthest neighbor.\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        farthest_neighbor_penalty[i, farthest_neighbors[i]] = -1.0\n\n    # Combine heuristics (direct summation, simpler)\n    heuristic_matrix = inverse_distance + nearest_neighbor_bonus + farthest_neighbor_penalty\n\n    # Sparsify the matrix (keep only top k edges for each node)\n    k = min(4, n - 1) # Reduced k for more sparsification, but keep at least one\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        threshold = np.sort(row)[-k]  # Find the kth largest value\n        heuristic_matrix[i, row < threshold] = 0.0  # Set values below k to zero\n\n    # Normalize to 0-1 range (more robust normalization)\n    if np.any(heuristic_matrix != 0): #Check if there is any non-zero value\n      max_val = np.max(heuristic_matrix)\n      min_val = np.min(heuristic_matrix[heuristic_matrix > 0]) if np.any(heuristic_matrix > 0) else max_val # Avoid zero division in normalization\n\n      if max_val > min_val:\n          heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)\n      else:\n          heuristic_matrix[heuristic_matrix > 0] = 1.0 # Handles the case when min and max are equal\n    else:\n        heuristic_matrix[:] = 0.0  #Handle the all zero case\n\n    return heuristic_matrix\n\n[Reflection]\nFocus on stronger nearest neighbor bonuses/farthest neighbor penalties, simpler combinations, and aggressive sparsification.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}