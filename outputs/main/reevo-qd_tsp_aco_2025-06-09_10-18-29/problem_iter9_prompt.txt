{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Prior reflection]\nAmplify neighbor signals with graded bonuses/penalties. Sparsify aggressively using adaptive thresholds. Normalize robustly with softmax. Combine heuristics simply, favoring equal or dynamically tuned weights.\n- Try combining various factors to determine how promising it is to select an edge.\n- Try sparsifying the matrix by setting unpromising elements to zero.\n\n[Code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n    This version prioritizes stronger, direct neighbor bonuses/penalties, simpler\n    combinations, and aggressive sparsification with robust normalization.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)\n\n    # Heuristic 2: Nearest neighbor bonus (focus on immediate neighbors)\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        neighbor_index = nearest_neighbors[i, 1]  # Only the very nearest neighbor\n        nearest_neighbor_bonus[i, neighbor_index] = 1.0\n\n    # Heuristic 3: Farthest neighbor penalty (avoid long edges)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, -1] #only the furthest\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n\n    for i in range(n):\n         neighbor_index = farthest_neighbors[i]\n         farthest_neighbor_penalty[i, neighbor_index] = -0.5\n\n    # Combined Heuristic (equal weights for simplicity)\n    heuristic_matrix = inverse_distance + nearest_neighbor_bonus + farthest_neighbor_penalty\n\n    # Aggressive Sparsification: Keep only top 20% of edges per row\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        threshold = np.percentile(row, 80)\n        heuristic_matrix[i, row < threshold] = 0.0\n\n    # Robust Normalization (row-wise softmax)\n    for i in range(n):\n        row = heuristic_matrix[i, :]\n        row_exp = np.exp(row - np.max(row))  # for numerical stability\n        row_sum = np.sum(row_exp)\n        if row_sum > 0:\n            heuristic_matrix[i, :] = row_exp / row_sum\n        else:\n            heuristic_matrix[i, :] = 1.0 / n  # Handle the case where all values are -inf\n\n    return heuristic_matrix\n\n[Improved code]\nPlease write a mutated function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}