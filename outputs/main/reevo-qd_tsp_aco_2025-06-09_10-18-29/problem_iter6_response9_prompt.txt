{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # Heuristic 2: Nearest neighbor desirability\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(1, min(5, n)):  # Give a bonus to the first 4 nearest neighbors\n            neighbor_index = nearest_neighbors[i, j]\n            nearest_neighbor_bonus[i, neighbor_index] = 1.0 / j # closer neighbors get higher bonus\n\n    # Heuristic 3: Avoidance of edges that are part of very long distances for the current city (penalty)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, ::-1]\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(min(4, n)):\n             neighbor_index = farthest_neighbors[i, j]\n             farthest_neighbor_penalty[i, neighbor_index] = -0.3 / (j+1) # smaller penalty for nodes closer to the i\n\n    # Heuristic 4: Node Degree Penalty (discourage high degree nodes early on)\n    degree_penalty = np.zeros_like(distance_matrix, dtype=float)\n    avg_distance = np.mean(distance_matrix) # Characteristic scale for \"long\" edges.\n\n    for i in range(n):\n        for j in range(n):\n            if distance_matrix[i, j] > avg_distance:\n                degree_penalty[i,j] = -0.1\n\n\n    # Combine heuristics with adaptive weights\n    alpha = 0.5\n    beta = 0.3\n    gamma = 0.2\n    delta = 0.1\n\n    heuristic_matrix = alpha * inverse_distance + beta * nearest_neighbor_bonus + gamma * farthest_neighbor_penalty + delta * degree_penalty\n\n\n    # Sparsify the matrix (optional: keep only top k edges for each node)\n    k = min(6, n - 1) #keep at least 1 edge\n    for i in range(n):\n      row = heuristic_matrix[i, :]\n      threshold = np.sort(row)[-k]  # Find the kth largest value\n      heuristic_matrix[i, row < threshold] = 0.0 #set the value below k to zero.\n\n    # Normalize to 0-1 range (optional)\n    max_val = np.max(heuristic_matrix)\n    min_val = np.min(heuristic_matrix)\n\n    if max_val > min_val:\n       heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)\n    else:\n        heuristic_matrix[:] = 1.0  # if all heuristics are equal\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) that combines\n    multiple factors to determine the likelihood of including an edge in a solution.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance\n            matrix between cities.  distance_matrix[i][j] is the distance\n            between city i and city j.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix,\n            where each element represents the prior probability or desirability\n            of including the corresponding edge in a TSP tour.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Heuristic 1: Inverse distance (shorter distances are more desirable)\n    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n\n    # Heuristic 2: Nearest neighbor desirability\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(1, min(4, n)):  # Give a bonus to the first 3 nearest neighbors\n            neighbor_index = nearest_neighbors[i, j]\n            nearest_neighbor_bonus[i, neighbor_index] = 1.0 / j # closer neighbors get higher bonus\n\n    # Heuristic 3: Avoidance of edges that are part of very long distances for the current city (penalty)\n    farthest_neighbors = np.argsort(distance_matrix, axis=1)[:, ::-1]\n    farthest_neighbor_penalty = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(min(3, n)):\n             neighbor_index = farthest_neighbors[i, j]\n             farthest_neighbor_penalty[i, neighbor_index] = -0.5  # Negative penalty\n\n\n    # Combine heuristics with different weights\n    heuristic_matrix = 0.6 * inverse_distance + 0.3 * nearest_neighbor_bonus + 0.1 * farthest_neighbor_penalty\n\n\n    # Sparsify the matrix (optional: keep only top k edges for each node)\n    k = min(5, n - 1) #keep at least 1 edge\n    for i in range(n):\n      row = heuristic_matrix[i, :]\n      threshold = np.sort(row)[-k]  # Find the kth largest value\n      heuristic_matrix[i, row < threshold] = 0.0 #set the value below k to zero.\n\n    # Normalize to 0-1 range (optional)\n    max_val = np.max(heuristic_matrix)\n    min_val = np.min(heuristic_matrix)\n\n    if max_val > min_val:\n       heuristic_matrix = (heuristic_matrix - min_val) / (max_val - min_val)\n    else:\n        heuristic_matrix[:] = 1.0  # if all heuristics are equal\n    return heuristic_matrix\n\n[Reflection]\nFewer neighbors, stronger penalties, and adjusted weights improved performance. Explore more tailored weight tuning.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}