```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling principles.

    This version incorporates a combination of factors, including distance, node degree,
    and a randomness to promote exploration. The heuristic values represent the
    prior probability of including each edge in a TSP solution.  It also introduces
    sparsity to reduce the computational burden in downstream optimization.

    Args:
        distance_matrix (np.ndarray): A square, symmetric matrix representing the pairwise
                                      distances between nodes.  distance_matrix[i, j] is the
                                      distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, containing heuristic
                      values representing the desirability of including each edge in a TSP tour.
                      Higher values indicate a more promising edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degrees based on inverse distance (initial desirability)
    node_degrees = np.sum(1 / (distance_matrix + np.eye(n)), axis=0) # avoid division by zero
    node_degree_matrix = np.tile(node_degrees, (n, 1)) + np.tile(node_degrees, (n, 1)).T

    # Combine distance, degree, and randomness
    heuristic_matrix = (1 / (distance_matrix + np.eye(n))) * np.sqrt(node_degree_matrix) # avoid division by zero. degree helps
    heuristic_matrix += np.random.rand(n, n) * 0.1  # Add some randomness for exploration


    # Sparsify the matrix: keep only the most promising edges for each node
    for i in range(n):
        row = heuristic_matrix[i, :]
        threshold = np.quantile(row, 0.75)  # Keep top 25% promising edges
        heuristic_matrix[i, row < threshold] = 0  # Set less promising edges to zero

    # Ensure symmetry (important for some solvers)
    heuristic_matrix = np.triu(heuristic_matrix) + np.triu(heuristic_matrix, 1).T


    return heuristic_matrix
```
