```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors
    to estimate the promise of including each edge in a solution. This version considers
    distance, node degree, and sparsification.

    Args:
        distance_matrix (np.ndarray): A square matrix where the element at [i, j] represents
                                      the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each element
                    represents a heuristic score for including the corresponding edge
                    in the TSP tour. Higher scores indicate more promising edges.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Avoid division by zero and self-loops
    distance_matrix = np.where(distance_matrix == 0, np.inf, distance_matrix)
    np.fill_diagonal(distance_matrix, np.inf)

    # 1. Inverse Distance: Shorter distances are more promising.
    inverse_distance = 1 / distance_matrix

    # 2. Node Degree Bias: Encourage connections to nodes with fewer connections.
    #    This is estimated by calculating the sum of inverse distances for each node.
    node_degree_bias = np.zeros((n, n), dtype=float)
    for i in range(n):
        for j in range(n):
            node_degree_bias[i, j] = inverse_distance[i, j] / (np.sum(inverse_distance[i, :]) + np.sum(inverse_distance[:, j]))

    # Combine Factors: weighted sum of inverse distance and node degree bias.
    heuristic_matrix = 0.7 * inverse_distance + 0.3 * node_degree_bias

    # Sparsification: Remove edges that are considered very unpromising to reduce search space.
    # For each node, keep only the top 'k' most promising edges (closest neighbors + degree bias).
    k = int(np.sqrt(n))  # Adjust k based on problem size.

    for i in range(n):
        # Find the indices of the top k most promising edges for node i.
        top_k_indices = np.argsort(heuristic_matrix[i, :])[::-1][:k] #indices of best edges to visit

        # Zero out all edges except the top k.
        row = np.ones(n, dtype=bool)
        row[top_k_indices] = False #only top_k_indices should be False (i.e. remain non zero after ~)
        heuristic_matrix[i, row] = 0.0
    # The same sparsification must apply to column, in addition to rows.
    for j in range(n):
        top_k_indices = np.argsort(heuristic_matrix[:, j])[::-1][:k] #indices of best edges to visit

        # Zero out all edges except the top k.
        col = np.ones(n, dtype=bool)
        col[top_k_indices] = False
        heuristic_matrix[col, j] = 0.0

    # Ensure heuristic values on edges connecting the same node are zero.
    np.fill_diagonal(heuristic_matrix, 0.0)

    return heuristic_matrix
```
