```python
import numpy as np
from typing import Sequence

def priority_v2(item: float, bins_remain_cap: Sequence[float]) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing (no global state).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : Sequence[float]
        Remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).
        Higher values indicate more desirable bins; infeasible bins receive -inf.
    """
    # Convert to a 1‑D NumPy float array
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.shape[0]

    # Edge case: no bins available
    if n_bins == 0:
        return np.array([], dtype=float)

    # Residual capacity after (potentially) placing the item
    residual = caps - item

    # Feasibility mask: bins that can accommodate the item
    feasible = residual >= 0

    # If nothing fits, return -inf for every bin
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Extract residuals of feasible bins for statistics
    feasible_res = residual[feasible]

    # Adaptive steepness based on spread of feasible residuals
    std = np.std(feasible_res)
    if std <= 0.0:
        # Fall back to range if standard deviation is zero
        spread = feasible_res.max() - feasible_res.min()
        std = spread if spread > 0.0 else 1.0

    base_steepness = 5.0          # Tunable base factor
    slope = base_steepness / std  # Larger std → softer sigmoid

    # Sigmoid of negative residual: tighter fit → larger score
    # Clamp exponent to avoid overflow/underflow in np.exp
    exp_arg = np.clip(slope * residual, -700, 700)
    scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Infeasible bins get -inf
    scores = np.where(feasible, scores, -np.inf)

    # Deterministic tie‑breaker: tiny bias favoring lower indices
    tie_bias = -np.arange(n_bins, dtype=float) * 1e-12
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
