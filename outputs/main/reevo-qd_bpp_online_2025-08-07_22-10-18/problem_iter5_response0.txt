```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid‑based priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as `bins_remain_cap`).
        Higher values indicate more desirable bins; infeasible bins are
        represented by ``-inf``.
    """
    # Ensure a NumPy float array.
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.size
    if n_bins == 0:
        return np.array([], dtype=float)

    # Residual capacity after placing the item in each bin.
    residual = caps - item
    feasible = residual >= 0

    # If nothing fits, return -inf for every bin.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Ratio of leftover after placement to the capacity before placement.
    # Use np.where to avoid division by zero for caps == 0 (though infeasible).
    ratio = np.where(caps > 0, residual / caps, 0.0)

    # Median of feasible residuals to adapt steepness.
    median_res = np.median(residual[feasible])
    if median_res <= 0.0:
        median_res = 1.0

    # Steepness parameter.
    base_slope = 10.0
    slope = base_slope / median_res

    # Sigmoid-like score that prefers small leftover ratio.
    exp_arg = slope * ratio
    exp_arg = np.clip(exp_arg, -700, 700)  # avoid overflow
    sigmoid_score = 2.0 / (1.0 + np.exp(exp_arg))

    # Exponential penalty for waste relative to item size.
    eps_item = 1e-12
    waste_ratio = residual / (item + eps_item)
    penalty = np.exp(-5.0 * waste_ratio)

    # Size weight (fraction of bin capacity taken by the item).
    size_weight = np.where(caps > 0, item / caps, 0.0)

    # Raw score.
    raw_score = sigmoid_score * penalty * size_weight
    raw_score = np.where(feasible, raw_score, -np.inf)

    # Deterministic tie‑breaker: tiny negative bias favouring lower indices.
    tie_bias = -np.arange(n_bins) * 1e-12
    raw_score = np.where(raw_score > -np.inf, raw_score + tie_bias, raw_score)

    return raw_score
```
