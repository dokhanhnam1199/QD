```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin for the online Bin Packing Problem.

    This implements a Best‑Fit style priority:
    * Bins that can accommodate ``item`` receive a priority proportional to the
      negative of the leftover space after insertion (i.e. the tighter the fit,
      the higher the priority).
    * Bins that cannot fit the item are assigned ``-np.inf`` so they are never
      selected.
    * An epsilon tie‑breaker prefers bins with lower index when priorities are
      otherwise identical.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``). The
        caller should select the bin with the highest score.
    """
    # Ensure we work with a floating‑point view of the capacities.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Compute prospective leftover capacity after placing the item.
    leftover = caps - item

    # Feasibility mask: only bins with non‑negative leftover can hold the item.
    feasible = leftover >= 0

    # Base priority: -leftover for feasible bins, -inf otherwise.
    priorities = np.where(feasible, -leftover, -np.inf)

    # ----------------------------------------------------------------------
    # Tie‑breaker: add a vanishing offset that prefers earlier bins.
    # ----------------------------------------------------------------------
    if priorities.size:
        # Determine an epsilon appropriate for the dtype.
        eps = (np.finfo(priorities.dtype).eps
               if np.issubdtype(priorities.dtype, np.floating)
               else np.finfo(np.float64).eps)

        # Offsets increase with bin index; subtract to give lower‑index bins a
        # slightly higher priority without affecting the main ordering.
        tie_break = np.arange(priorities.size, dtype=priorities.dtype) * eps
        priorities = priorities - tie_break

    return priorities
```
