```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute priority scores for each bin using a Sigmoid Fit Score strategy.
    Bins that cannot accommodate the item receive a very low priority (-inf).

    Parameters
    ----------
    item : float
        Size of the item to be packed.
    bins_remain_cap : np.ndarray
        Remaining capacities of each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores for each bin.  The bin with the highest
        priority score will be chosen to store the item.
    """
    # Ensure numeric types for accurate arithmetic
    rem = bins_remain_cap.astype(float, copy=False)

    # Mask of bins that can actually fit the item
    fit_mask = rem >= item

    # Initialize all priorities with negative infinity (bins that cannot fit)
    priorities = np.full_like(rem, -np.inf, dtype=float)

    if not np.any(fit_mask):
        return priorities  # no bin can fit the item

    # Compute the difference between remaining capacity and the item size
    diff = rem[fit_mask] - item

    # The fill ratio after placing the item: value in (0, 1]
    fill_ratio = 1.0 - diff / rem[fit_mask]

    # Logistic (sigmoid) transformation to obtain a smooth prioritization
    # Good fit (fill_ratio close to 1) → score close to 1
    # Poor fit (small fill_ratio)   → score close to 0
    k = 12.0  # Steepness of the sigmoid
    sigmoid = 1.0 / (1.0 + np.exp(-k * (fill_ratio - 0.5)))

    priorities[fit_mask] = sigmoid

    return priorities
```
