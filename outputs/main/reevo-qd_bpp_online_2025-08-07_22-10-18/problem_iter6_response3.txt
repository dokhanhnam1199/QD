```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority scoring for online bin packing.

    For each open bin the function returns a score that favours bins where the
    item fits tightly (small residual capacity after placement).  Scores are
    computed using a logistic (sigmoid) function whose steepness is adapted to
    the dispersion (standard deviation) of the feasible residual capacities.
    Infeasible bins receive ``-np.inf`` so they are never selected.  A tiny
    deterministic tie‑breaker bias is added to prefer lower‑indexed bins when
    scores are exactly equal.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``).  Higher
        scores indicate more desirable bins; infeasible bins are ``-np.inf``.
        If ``bins_remain_cap`` is empty, an empty array is returned.
    """
    # Ensure a NumPy array of floats.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # No bins available.
    if caps.size == 0:
        return np.array([], dtype=float)

    # Residual capacity after placing the item in each bin.
    residual = caps - item

    # Feasibility mask: bins that can accommodate the item.
    feasible = residual >= 0

    # If nothing fits, return -inf for every bin.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Standard deviation of residuals for feasible bins.
    feasible_res = residual[feasible]
    std = np.std(feasible_res)
    if std <= 0.0:
        # Fall back to range or a small epsilon to avoid division by zero.
        spread = feasible_res.max() - feasible_res.min()
        std = spread if spread > 0.0 else 1.0

    # Base steepness factor (tunable). Larger std → flatter sigmoid.
    base_steepness = 5.0
    slope = base_steepness / std

    # Logistic scoring: tighter fit (small residual) → higher score.
    # Using 2/(1+exp(slope*residual)) maps residual=0 to score=1.
    exp_arg = np.clip(slope * residual, -700, 700)   # avoid overflow
    scores = 2.0 / (1.0 + np.exp(exp_arg))

    # Infeasible bins get -inf.
    scores = np.where(feasible, scores, -np.inf)

    # Deterministic tie‑breaker: tiny bias favouring lower indices.
    tie_bias = -np.arange(caps.shape[0], dtype=float) * 1e-12
    scores = np.where(feasible, scores + tie_bias, scores)

    return scores
```
