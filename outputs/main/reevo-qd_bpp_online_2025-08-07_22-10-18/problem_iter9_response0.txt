```python
import numpy as np

# Global state
_call_counter = 0
_total_item_size = 0.0
_ema_item_size = 0.0
_ema_alpha = 0.2
_WASTE_PENALTY_WEIGHT = 0.35
_EPS = 1e-12

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is more preferable).
        Infeasible bins receive -inf.
    """
    global _call_counter, _total_item_size, _ema_item_size

    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Update statistics
    _call_counter += 1
    _total_item_size += item
    if _call_counter == 1:
        _ema_item_size = item
    else:
        _ema_item_size = _ema_alpha * item + (1.0 - _ema_alpha) * _ema_item_size

    # Feasible mask
    feasible_mask = bins_remain_cap >= item

    # Leftover space
    leftover = bins_remain_cap - item

    # Detect exact‑fit bins (zero leftover within tolerance)
    atol = 1e-9
    exact_fit_mask = np.isclose(leftover, 0.0, atol=atol) & feasible_mask

    # Prepare priority array with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Handle exact‑fit bins: highest priority (inf)
    priorities[exact_fit_mask] = np.inf

    # Non‑exact feasible bins
    non_exact_mask = feasible_mask & ~exact_fit_mask
    if np.any(non_exact_mask):
        # Base score: inverse of leftover (larger for tighter fit)
        base_score = 1.0 / (leftover[non_exact_mask] + _EPS)

        # Penalty for waste exceeding EMA of item sizes
        waste_excess = np.maximum(0.0, leftover[non_exact_mask] - _ema_item_size)

        # Adapt penalty weight by fraction of feasible bins
        fit_fraction = np.count_nonzero(feasible_mask) / bins_remain_cap.size
        penalty_weight = _WASTE_PENALTY_WEIGHT * (1.0 - fit_fraction)

        penalty = penalty_weight * waste_excess

        # Raw score before normalization
        score = base_score - penalty

        # Standardize scores: mean and MAD
        mean_score = np.mean(score)
        mad_score = np.median(np.abs(score - mean_score))
        mad = mad_score if mad_score > _EPS else _EPS

        std_score = (score - mean_score) / mad

        # Clip exponents to avoid overflow
        clip_val = 50.0
        std_score = np.clip(std_score, -clip_val, clip_val)

        # Monotonic sigmoid
        sigmoid_scores = 1.0 / (1.0 + np.exp(-std_score))

        # Assign priorities
        priorities[non_exact_mask] = sigmoid_scores

    # Tiny deterministic tie‑breaker based on bin index
    indices = np.arange(bins_remain_cap.size)
    priorities += indices * 1e-8

    return priorities
```
