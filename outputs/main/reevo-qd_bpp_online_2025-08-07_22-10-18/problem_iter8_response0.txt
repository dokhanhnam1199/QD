```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 0.05,
    base_slope: float = 12.0,
    waste_alpha: float = 5.0,
    random_state=None,
) -> np.ndarray:
    """
    Adaptive multiplicative priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of currently open bins.
    epsilon : float, optional
        Exploration probability for epsilon‑greedy selection (default 0.05).
    base_slope : float, optional
        Base steepness for the sigmoid term; adapted by median residual.
    waste_alpha : float, optional
        Exponential penalty factor for waste relative to the item size.
    random_state : int, np.random.Generator, or None, optional
        Seed or generator for reproducible randomness.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins receive -inf.
        The bin with the highest score should be chosen.
    """
    # -----------------------------------------------------------------
    # Normalise input.
    # -----------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.size
    if n_bins == 0:
        return np.array([], dtype=float)

    # -----------------------------------------------------------------
    # RNG handling – robust and reproducible.
    # -----------------------------------------------------------------
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    # -----------------------------------------------------------------
    # Exploration (epsilon‑greedy): random feasible scores.
    # -----------------------------------------------------------------
    if rng.random() < epsilon:
        rand_scores = rng.random(n_bins)
        feasible = caps >= item
        rand_scores[~feasible] = -np.inf
        # Deterministic tiny bias to break ties (prefer lower index).
        rand_scores -= np.arange(n_bins) * 1e-12
        return rand_scores

    # -----------------------------------------------------------------
    # Exploitation: compute a composite score for each feasible bin.
    # -----------------------------------------------------------------
    residual = caps - item
    feasible = residual >= 0

    # No feasible bin – return -inf for all.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # 1) Leftover ratio (smaller is better – tight fit).
    ratio = np.where(caps > 0, residual / caps, 0.0)

    # 2) Adaptive sigmoid steepness based on the median feasible residual.
    median_res = np.median(residual[feasible])
    median_res = max(median_res, 1e-6)               # avoid division by zero
    slope = base_slope / median_res

    # Sigmoid‑like score that favours small leftover ratios.
    exp_arg = slope *  # slope * ratio will be computed next
    exp_arg = slope * ratio
    exp_arg = np.clip(exp_arg, -700, 700)            # numerical stability
    sigmoid_score = 1.0 / (1.0 + np.exp(exp_arg))

    # 3) Waste penalty – exponential decay with waste relative to item size.
    eps = 1e-12
    waste_ratio = residual / (item + eps)
    waste_penalty = np.exp(-waste_alpha * waste_ratio)

    # 4) Utilization – fraction of bin capacity consumed by the item.
    utilization = np.where(caps > 0, item / caps, 0.0)

    # Composite multiplicative score (all components in [0, 1]).
    raw_score = sigmoid_score * waste_penalty * utilization

    # Mask infeasible bins.
    raw_score = np.where(feasible, raw_score, -np.inf)

    # Tiny deterministic tie‑breaker (prefer lower index when scores tie).
    raw_score -= np.arange(n_bins) * 1e-12

    return raw_score
```
