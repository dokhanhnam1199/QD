```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing.

    The function returns a priority score for each open bin. Higher scores
    indicate more desirable bins for placing the incoming ``item``. The
    scoring uses a sigmoid that adapts its steepness to the dispersion of
    feasible residual capacities, ensuring stable behaviour across different
    load patterns. Infeasible bins receive ``-np.inf``. A tiny deterministic
    bias based on bin index resolves ties in a reproducible way.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``).  Bins
        that cannot accommodate the item have a score of ``-np.inf``.
    """
    # Convert to 1‑D float array for safe arithmetic.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.shape[0]

    # Edge case: no bins at all.
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Residual capacity after (hypothetically) placing the item.
    residual = caps - item

    # Feasibility mask: bins that can actually hold the item.
    feasible = residual >= 0.0

    # Initialise scores with -inf for infeasible bins.
    scores = np.full(n_bins, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early.
    if not np.any(feasible):
        return scores

    # Residual capacities of feasible bins.
    feas_res = residual[feasible]

    # -----------------------------------------------------------------
    # Robust spread estimation (Median Absolute Deviation → std estimate)
    # -----------------------------------------------------------------
    median_res = np.median(feas_res)
    mad = np.median(np.abs(feas_res - median_res))
    # Convert MAD to an estimate of the standard deviation for normal data.
    spread = mad * 1.4826  # ≈ std for normal distribution

    # Fallback strategies if MAD yields zero spread.
    if spread <= 0.0:
        std = np.std(feas_res)
        if std > 0.0:
            spread = std
        else:
            # Use range as the last resort.
            rng = np.max(feas_res) - np.min(feas_res)
            spread = rng if rng > 0.0 else 1.0

    # -----------------------------------------------------------------
    # Adaptive steepness (slope) for the sigmoid.
    # Larger spread → softer sigmoid, smaller spread → steeper.
    # -----------------------------------------------------------------
    base_steepness = 6.0  # tunable constant; higher → sharper transition
    slope = base_steepness / spread

    # -----------------------------------------------------------------
    # Sigmoid scoring: decreasing with residual.
    #   score = 1 / (1 + exp(slope * (residual - median_res)))
    # This yields scores > 0.5 for residuals below the median (better fit)
    # and < 0.5 for residuals above the median.
    # -----------------------------------------------------------------
    # Clip exponent to avoid overflow/underflow (np.exp limited to ~709).
    exp_arg = np.clip(slope * (feas_res - median_res), -700, 700)
    feas_scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Assign computed scores to the feasible positions.
    scores[feasible] = feas_scores

    # -----------------------------------------------------------------
    # Deterministic tie‑breaker: tiny decreasing bias with index.
    # Guarantees stable ordering when scores are equal (within floating‑point noise).
    # -----------------------------------------------------------------
    epsilon = 1e-12
    tie_bias = -np.arange(n_bins, dtype=float) * epsilon
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
