```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float = None) -> np.ndarray:
    """
    Compute priority scores for each bin for the online bin packing problem.

    The scoring function prefers bins that tightly accommodate the item while
    penalizing bins that cannot fit the item. It yields a smooth, monotonic
    decreasing score as the leftover capacity after placement grows.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1â€‘D array of remaining capacities for each currently open bin.
    bin_capacity : float, optional
        The fixed capacity of a bin. If omitted, it is estimated as the
        maximum observed remaining capacity across all bins (exact if any bin
        is empty).

    Returns
    -------
    np.ndarray
        Array of priority scores with the same shape as ``bins_remain_cap``.
        Infeasible bins receive ``-np.inf``. The bin with the highest score should
        be selected for placement.
    """
    # Ensure we are working with a float array
    rem = np.asarray(bins_remain_cap, dtype=float)

    # Feasibility mask: bins that can accommodate the item
    fit_mask = rem >= item

    # Initialise priority array: infeasible bins get -inf
    priorities = np.full(rem.shape, -np.inf, dtype=float)

    # If no bin can fit the item, simply return the -inf array (caller may open a new bin)
    if not np.any(fit_mask):
        return priorities

    # Estimate bin capacity if not supplied
    if bin_capacity is None:
        # The bin capacity cannot exceed the largest remaining capacity observed.
        # This is exact if any bin is empty; otherwise it is a lower bound.
        bin_capacity_est = np.max(rem)
        # Guard against degenerate case where max is zero (should not happen in normal BPP)
        if bin_capacity_est <= 0:
            bin_capacity_est = item
    else:
        bin_capacity_est = float(bin_capacity)

    # Compute leftover capacity after placing the item in feasible bins
    leftover = rem[fit_mask] - item                     # >= 0

    # Normalised leftover fraction (0 = perfect fit, up to 1 = empty bin)
    leftover_frac = leftover / bin_capacity_est
    leftover_frac = np.clip(leftover_frac, 0.0, 1.0)

    # Fill ratio after placement (proportion of the bin that will be occupied)
    fill_ratio = 1.0 - leftover_frac                     # in [0, 1]

    # Dynamic steepness: larger items relative to bin capacity demand tighter fits
    base_k = 8.0
    steepness = base_k * (item / bin_capacity_est) + 2.0  # always > 0

    # Logistic transformation of fill ratio for smooth scoring (centered at 0.5)
    logistic_score = 1.0 / (1.0 + np.exp(-steepness * (fill_ratio - 0.5)))

    # Exponential decay on leftover fraction to reward tighter fits even more
    alpha = 5.0
    exp_score = np.exp(-alpha * leftover_frac)

    # Combine the two scores; give slightly more weight to the exponential term
    w_exp, w_log = 0.6, 0.4
    combined left over:
    combined_score = w_exp * exp_score + w_log * logistic_score

    # Normalise combined scores to [0, 1] among feasible bins for consistency
    min_score = combined_score.min()
    max_score = combined_score.max()
    if max_score > min_score:
        combined_score = (combined_score - min_score) / (max_score - min_score)

    # Assign the computed scores back to the full priority array
    priorities[fit_mask] = combined_score

    return priorities
```
