```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a deterministic priority score for each bin in an online Bin Packing
    problem using a pure best‑fit heuristic.

    The score is normalised to the interval [0, 1] for feasible bins.  The
    bin that would leave the smallest residual capacity after placing the
    incoming item receives the highest priority.  Infeasible bins are
    assigned ``-np.inf`` and will never be selected.

    A tiny deterministic tie‑breaker favours lower‑indexed bins when
    several bins achieve the same residual capacity.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each existing bin.

    Returns
    -------
    np.ndarray
        1‑D array of the same shape as ``bins_remain_cap`` containing the
        priority score for each bin (higher values are preferred).
    """
    caps = np.asarray(bins_remain_cap, dtype=float)

    leftover = caps - item
    feasible = leftover >= 0

    # Initialise all priorities as -inf (infeasible)
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities

    # Raw priority: negative leftover (smaller leftover → higher priority)
    raw_priority = -leftover[feasible]

    # Normalise to [0,1] within feasible bins
    min_raw = raw_priority.min()
    max_raw = raw_priority.max()
    if max_raw > min_raw:
        norm_priority = (raw_priority - min_raw) / (max_raw - min_raw)
    else:
        norm_priority = np.zeros_like(raw_priority)

    priorities[feasible] = norm_priority

    # Deterministic tie‑breaker: favour lower indices
    tie_breaker = -1e-9 * np.arange(len(priorities))
    priorities += tie_breaker

    return priorities
```
