```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Worst‑Fit priority for the online Bin Packing problem.

    The worst‑fit heuristic selects the bin that will retain the most free
    space after the item is placed. This implementation returns a score for
    each bin; higher scores indicate more attractive bins.

    Bins that cannot accommodate the item receive ``-np.inf`` so they are
    never selected.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array with the remaining capacity of each currently
                         open bin.

    Returns:
        A 1‑D ``np.ndarray`` of priority values, one per bin.
    """
    # ------------------------------------------------------------------
    # 1. Determine which bins can actually hold the item.
    # ------------------------------------------------------------------
    can_fit = bins_remain_cap >= item

    # ------------------------------------------------------------------
    # 2. Compute the remaining free space *after* the item would be placed.
    # ------------------------------------------------------------------
    leftover = bins_remain_cap - item

    # ------------------------------------------------------------------
    # 3. Exaggerate differences between large leftovers (non‑linear scaling).
    #    Using an exponent > 1 makes the algorithm favor bins with
    #    significantly more space even more strongly.
    # ------------------------------------------------------------------
    exponent = 1.2
    scaled_leftover = np.where(can_fit, leftover ** exponent, 0.0)

    # ------------------------------------------------------------------
    # 4. Tie‑breaker: when two bins would leave the same leftover, prefer the
    #    bin that started out larger. The factor is tiny so it does not disturb
    #    the main worst‑fit ordering.
    # ------------------------------------------------------------------
    tie_break = 1e-6 * bins_remain_cap

    # ------------------------------------------------------------------
    # 5. Small random jitter to break exact numerical ties in a reproducible
    #    way (useful when many bins have identical capacities).
    # ------------------------------------------------------------------
    rng = np.random.default_rng()
    jitter = rng.random(bins_remain_cap.shape) * 1e-9

    # ------------------------------------------------------------------
    # 6. Assemble the final priority: large values → strong preference.
    #    Non‑fitting bins get -inf to guarantee they are ignored.
    # ------------------------------------------------------------------
    priorities = np.where(
        can_fit,
        scaled_leftover + tie_break + jitter,
        -np.inf
    )
    return priorities
```
