{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# Global state\n_call_counter = 0\n_total_item_size = 0.0\n_ema_item_size = 0.0\n_ema_alpha = 0.2\n_WASTE_PENALTY_WEIGHT = 0.35\n_EPS = 1e-12\n\n    \"\"\"\n    Adaptive priority function for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is more preferable).\n        Infeasible bins receive -inf.\n    \"\"\"\n    global _call_counter, _total_item_size, _ema_item_size\n\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Update statistics\n    _call_counter += 1\n    _total_item_size += item\n    if _call_counter == 1:\n        _ema_item_size = item\n    else:\n        _ema_item_size = _ema_alpha * item + (1.0 - _ema_alpha) * _ema_item_size\n\n    # Feasible mask\n    feasible_mask = bins_remain_cap >= item\n\n    # Leftover space\n    leftover = bins_remain_cap - item\n\n    # Detect exact\u2011fit bins (zero leftover within tolerance)\n    atol = 1e-9\n    exact_fit_mask = np.isclose(leftover, 0.0, atol=atol) & feasible_mask\n\n    # Prepare priority array with -inf for infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Handle exact\u2011fit bins: highest priority (inf)\n    priorities[exact_fit_mask] = np.inf\n\n    # Non\u2011exact feasible bins\n    non_exact_mask = feasible_mask & ~exact_fit_mask\n    if np.any(non_exact_mask):\n        # Base score: inverse of leftover (larger for tighter fit)\n        base_score = 1.0 / (leftover[non_exact_mask] + _EPS)\n\n        # Penalty for waste exceeding EMA of item sizes\n        waste_excess = np.maximum(0.0, leftover[non_exact_mask] - _ema_item_size)\n\n        # Adapt penalty weight by fraction of feasible bins\n        fit_fraction = np.count_nonzero(feasible_mask) / bins_remain_cap.size\n        penalty_weight = _WASTE_PENALTY_WEIGHT * (1.0 - fit_fraction)\n\n        penalty = penalty_weight * waste_excess\n\n        # Raw score before normalization\n        score = base_score - penalty\n\n        # Standardize scores: mean and MAD\n        mean_score = np.mean(score)\n        mad_score = np.median(np.abs(score - mean_score))\n        mad = mad_score if mad_score > _EPS else _EPS\n\n        std_score = (score - mean_score) / mad\n\n        # Clip exponents to avoid overflow\n        clip_val = 50.0\n        std_score = np.clip(std_score, -clip_val, clip_val)\n\n        # Monotonic sigmoid\n        sigmoid_scores = 1.0 / (1.0 + np.exp(-std_score))\n\n        # Assign priorities\n        priorities[non_exact_mask] = sigmoid_scores\n\n    # Tiny deterministic tie\u2011breaker based on bin index\n    indices = np.arange(bins_remain_cap.size)\n    priorities += indices * 1e-8\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Sigmoid Fit Score priority for online bin packing.\n\n    This function assigns a higher priority to bins where the item fits tightly.\n    Bins that cannot accommodate the item receive a very low (\u2011inf) priority.\n    For feasible bins the remaining capacity after placement is fed through a\n    sigmoid: the smaller the leftover space, the larger the score.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        np.ndarray of the same shape as `bins_remain_cap` with priority scores.\n        Higher values indicate more desirable bins.\n    \"\"\"\n    # Ensure input is a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Residual capacity if we placed the item in each bin.\n    residual = bins_remain_cap - item\n\n    # Identify infeasible bins (item does not fit).\n    infeasible = residual < 0\n\n    # Feasible residuals for slope calibration.\n    feasible_res = residual[~infeasible]\n\n    # If there are no feasible bins, return an array of -inf.\n    if feasible_res.size == 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Adaptive sigmoid steepness:\n    # Larger spread of feasible residuals \u2192 softer sigmoid.\n    std = np.std(feasible_res)\n    # Guard against zero std (all residuals identical).\n    std = std if std > 0 else 1.0\n    slope = 5.0 / std  # 5.0 is a tunable base steepness.\n\n    # Compute sigmoid of negative residual: tighter fit \u2192 higher score.\n    # score = 1 / (1 + exp(slope * residual))\n    # Clip exponent to avoid overflow in np.exp.\n    exp_arg = np.clip(slope * residual, -700, 700)\n    scores = 1.0 / (1.0 + np.exp(exp_arg))\n\n    # Force infeasible bins to the lowest possible priority.\n    scores = np.where(infeasible, -np.inf, scores)\n\n    return scores\n\n[Reflection]\nPrefer simple adaptive scoring; calibrate sigmoid steepness by residual variance; avoid global state; favor exact fits.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}