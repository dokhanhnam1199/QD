```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Almost Full Fit priority: Choose the bin that, after placing the new item, will be
    as close to full as possible (i.e., with minimal remaining capacity). A small bias
    is added to break ties by favoring bins that already have more space (easier to
    place larger future items).
    
    Args:
        item:   The size of the incoming item.
        bins_remain_cap: An array of the remaining capacities of each bin.
    
    Returns:
        A float array of the same shape as ``bins_remain_cap`` containing the
        priority score for each bin.  The larger the score, the more preferred the
        bin.  Bins that cannot accommodate the item receive a priority of -inf.
    """
    import numpy as np
    
    # Bins that can accommodate the item
    fit = bins_remain_cap >= item
    
    # Start with a very low priority for all bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    if fit.any():
        # Remaining space after adding the item
        remaining = bins_remain_cap[fit] - item
        # Main priority: bins with the smallest remaining space get the highest priority
        # Bias: give a tiny advantage to bins that had more space originally, to aid tieâ€‘breaking
        bias = 1e-8 * bins_remain_cap[fit]
        priorities[fit] = -(remaining) + bias
    
    return priorities
```
