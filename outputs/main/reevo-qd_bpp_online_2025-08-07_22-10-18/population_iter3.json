[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011Fit priority for online Bin Packing.\n\n    The bin that leaves the smallest remaining capacity after receiving the\n    *item* gets the highest priority. Bins that cannot accommodate the item\n    receive a very low (\u2011inf) priority and will never be selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each existing bin.\n\n    Returns:\n        NumPy array with a priority score for each bin (higher means more\n        preferred). The shape matches ``bins_remain_cap``.\n    \"\"\"\n    # Work in floating point to safely use -inf for infeasible bins.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining space after the item would be placed.\n    leftover = caps - item\n\n    # Assign priority: bins that can fit the item get -leftover (higher for\n    # smaller leftover). Infeasible bins get -inf.\n    priorities = np.where(leftover >= 0, -leftover, -np.inf)\n\n    # Tiny tie\u2011breaker: favor lower\u2011index bins when leftover is identical.\n    # This epsilon is far smaller than any realistic leftover value.\n    epsilon = 1e-9\n    tie_break = -epsilon * np.arange(priorities.size)\n    priorities = priorities + tie_break\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for online Bin Packing.\n\n    For each bin the function evaluates the remaining space that would be left\n    after placing ``item``.  Bins that can accommodate the item receive a\n    priority proportional to the negative of this leftover \u2013 i.e. a smaller\n    leftover yields a larger priority.  Bins that cannot fit the item are\n    assigned ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``). The\n        caller should select the bin with the highest priority.\n    \"\"\"\n    # Compute the prospective leftover space after adding the item.\n    leftover = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative leftover can hold the item.\n    feasible = leftover >= 0\n\n    # Base priority: -leftover (smaller leftover \u2192 larger priority).\n    # Infeasible bins receive -inf.\n    priorities = np.where(feasible, -leftover, -np.inf)\n\n    # ----------------------------------------------------------------------\n    # OPTIONAL tie\u2011breaker: prefer earlier bins (lower index) when priorities\n    # are otherwise identical.  This adds a negligible offset that does not\n    # alter the main ordering.\n    # ----------------------------------------------------------------------\n    if priorities.size:\n        # Machine epsilon for the array's dtype (or float64 if integer).\n        eps = np.finfo(priorities.dtype).eps if np.issubdtype(priorities.dtype, np.floating) else np.finfo(np.float64).eps\n        tie_break = np.arange(priorities.size, dtype=priorities.dtype) * eps\n        priorities = priorities - tie_break\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\n# Exploration probability for the epsilon\u2011greedy strategy\nEPSILON = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority function for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of the remaining capacities of the open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. The bin with the highest score\n        will be selected. Bins that cannot accommodate the item are\n        assigned a very low priority (-\u221e).\n    \"\"\"\n    rng = np.random.default_rng()\n\n    # Exploration phase with probability EPSILON\n    if rng.random() < EPSILON:\n        # Generate uniform random scores for a purely random pick\n        return rng.random(bins_remain_cap.shape[0])\n\n    # Exploitation phase: best\u2011fit measure\n    leftover = bins_remain_cap - item\n    # Only bins that can hold the item are considered; others get -\u221e\n    priorities = np.where(leftover >= 0, leftover, -np.inf)\n    return priorities",
    "response_id": 8,
    "obj": 137.9537295572397,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for placing an incoming item into existing bins\n    based on the Exact\u2011Fit\u2011First heuristic.\n\n    Parameters\n    ----------\n    item : float\n        Size of the new item that needs to be packed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for all currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Same shape as *bins_remain_cap*; each entry is the priority score\n        for placing *item* into the corresponding bin.  The bin with the\n        maximum score will be selected by the scheduler.\n    \"\"\"\n    # Initialise with a very low score to effectively drop bins that\n    # cannot accommodate the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins that can hold the item\n    fit_mask = bins_remain_cap >= item\n\n    if not np.any(fit_mask):\n        # No bin can contain the item \u2013 all scores remain -inf\n        return priorities\n\n    # Space that would be left after the placement\n    leftovers = bins_remain_cap[fit_mask] - item\n\n    # Detect bins that would result in an exact fit\n    exact_mask = np.isclose(leftovers, 0.0, atol=1e-9)\n\n    # Base score prefers smaller leftover (best\u2011fit principle):\n    # larger (less negative) values correspond to better fit.\n    base_score = -leftovers\n    # Boost the score for exact fits so they outrank all non\u2011exact ones.\n    boost = 10.0  # arbitrary large constant\n\n    # Compute final scores\n    priorities[fit_mask] = base_score + (exact_mask * boost)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Inverse Distance (Proximity Fit) priority for online Bin Packing.\n\n    For each bin that can accommodate the item, compute the leftover capacity\n    after placing the item and assign a priority equal to the inverse of that\n    leftover (plus a tiny epsilon to avoid division by zero).  \n    Bins that cannot hold the item receive a very large negative priority,\n    ensuring they are never chosen.  \n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better).\n    \"\"\"\n    # Compute available space after packing `item`\n    space_left = bins_remain_cap - item\n\n    # Only consider bins that can hold the item\n    valid = space_left >= 0\n\n    # Avoid division by zero with a very small epsilon\n    eps = 1e-12\n\n    # Inverse distance priority: the closer the remaining space to zero,\n    # the higher the priority. Use -np.inf for invalid bins.\n    priorities = np.where(\n        valid,\n        1.0 / (space_left + eps),  # Inverse of leftover space\n        -np.inf                    # Completely invalid bins\n    )\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin using a Sigmoid Fit Score strategy.\n    Bins that cannot accommodate the item receive a very low priority (-inf).\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be packed.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores for each bin.  The bin with the highest\n        priority score will be chosen to store the item.\n    \"\"\"\n    # Ensure numeric types for accurate arithmetic\n    rem = bins_remain_cap.astype(float, copy=False)\n\n    # Mask of bins that can actually fit the item\n    fit_mask = rem >= item\n\n    # Initialize all priorities with negative infinity (bins that cannot fit)\n    priorities = np.full_like(rem, -np.inf, dtype=float)\n\n    if not np.any(fit_mask):\n        return priorities  # no bin can fit the item\n\n    # Compute the difference between remaining capacity and the item size\n    diff = rem[fit_mask] - item\n\n    # The fill ratio after placing the item: value in (0, 1]\n    fill_ratio = 1.0 - diff / rem[fit_mask]\n\n    # Logistic (sigmoid) transformation to obtain a smooth prioritization\n    # Good fit (fill_ratio close to 1) \u2192 score close to 1\n    # Poor fit (small fill_ratio)   \u2192 score close to 0\n    k = 12.0  # Steepness of the sigmoid\n    sigmoid = 1.0 / (1.0 + np.exp(-k * (fill_ratio - 0.5)))\n\n    priorities[fit_mask] = sigmoid\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost\u2011Full\u2011Fit priority for online Bin Packing.\n    Bins that become \"almost full\" after adding the item get higher priority.\n    An item is considered a fit for a bin if the remaining capacity is non\u2011negative.\n    Bins that do not fit receive a priority of -np.inf.\n    \n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n    \n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as bins_remain_cap).\n    \"\"\"\n    # Ensure we work with a NumPy array and avoid datatype surprises\n    rem_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Allocate priority vector\n    priorities = np.full_like(rem_cap, -np.inf, dtype=np.float64)\n\n    # Identify bins that can accommodate the item\n    fit_mask = rem_cap >= item\n    if not np.any(fit_mask):\n        # Nothing fits \u2013 return all -inf priorities\n        return priorities\n\n    # Remaining capacity after packing the item\n    remaining = rem_cap[fit_mask] - item\n    capacity   = rem_cap[fit_mask]\n\n    # Normalized slack: 0 means perfect fill, 1 means bin is empty\n    slack_ratio = remaining / capacity\n\n    # Heuristic: the smaller the slack_ratio, the higher the priority\n    # For \"almost full\" bins (slack_ratio <= THRESHOLD) we use a steeper penalty\n    THRESHOLD = 0.2  # <20% unused capacity is considered almost full\n    priorities[fit_mask] = np.where(\n        slack_ratio <= THRESHOLD,\n        1.0 / (slack_ratio + 1e-9),   # strongly favor very low slack\n        1.0 / (1.0 + slack_ratio)     # mild penalty for larger slack\n    )\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact\u2011Fit\u2011First priority function for online Bin Packing.\n    \n    Bins where the item fits exactly receive the highest priority (infinite).\n    Among the remaining bins that can accommodate the item, those that leave the\n    smallest waste (i.e., smallest remaining capacity after insertion) receive\n    higher priority, proportional to 1 / waste.\n    Bins that cannot accommodate the item get a very low (\u2212inf) priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher = more preferred).\n    \"\"\"\n    # Ensure a NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the waste that would remain after placing the item\n    waste = bins_remain_cap - item\n\n    # Floating\u2011point tolerance for equality checks\n    atol = 1e-9\n\n    # Masks\n    exact_fit_mask = np.isclose(waste, 0.0, atol=atol)      # exact fits\n    can_fit_mask   = waste >= -atol                         # fits (including exact)\n\n    # Initialize all priorities to \u2212inf (cannot fit)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Exact fits get the highest possible priority\n    priorities[exact_fit_mask] = np.inf\n\n    # Non\u2011exact but feasible bins get priority inversely proportional to waste\n    # (smaller waste \u2192 larger priority). Small epsilon avoids division by zero.\n    epsilon = 1e-12\n    non_exact_mask = can_fit_mask & ~exact_fit_mask\n    priorities[non_exact_mask] = 1.0 / (waste[non_exact_mask] + epsilon)\n\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority for online bin packing.\n\n    This function assigns a higher priority to bins where the item fits tightly.\n    Bins that cannot accommodate the item receive a very low (\u2011inf) priority.\n    For feasible bins the remaining capacity after placement is fed through a\n    sigmoid: the smaller the leftover space, the larger the score.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        np.ndarray of the same shape as `bins_remain_cap` with priority scores.\n        Higher values indicate more desirable bins.\n    \"\"\"\n    # Ensure input is a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Residual capacity if we placed the item in each bin.\n    residual = bins_remain_cap - item\n\n    # Identify infeasible bins (item does not fit).\n    infeasible = residual < 0\n\n    # Feasible residuals for slope calibration.\n    feasible_res = residual[~infeasible]\n\n    # If there are no feasible bins, return an array of -inf.\n    if feasible_res.size == 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Adaptive sigmoid steepness:\n    # Larger spread of feasible residuals \u2192 softer sigmoid.\n    std = np.std(feasible_res)\n    # Guard against zero std (all residuals identical).\n    std = std if std > 0 else 1.0\n    slope = 5.0 / std  # 5.0 is a tunable base steepness.\n\n    # Compute sigmoid of negative residual: tighter fit \u2192 higher score.\n    # score = 1 / (1 + exp(slope * residual))\n    # Clip exponent to avoid overflow in np.exp.\n    exp_arg = np.clip(slope * residual, -700, 700)\n    scores = 1.0 / (1.0 + np.exp(exp_arg))\n\n    # Force infeasible bins to the lowest possible priority.\n    scores = np.where(infeasible, -np.inf, scores)\n\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based Fit priority for online Bin Packing.\n\n    For each bin we compute the amount of *wasted* space that would remain\n    after inserting the item (if the item fits).  The priority is then an\n    exponential (softmax) decay of this waste \u2013 bins that leave little or no\n    waste get the highest scores.  A temperature parameter controls the\n    greediness: lower values behave like a Best\u2011Fit heuristic, higher values\n    produce a softer distribution (more exploration).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array containing the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (summing to 1 over feasible bins).  Bins that\n        cannot accommodate the item receive a priority of 0.\n    a new bin will be opened when all priorities are zero.\n    \"\"\"\n    # ---------------------- hyper\u2011parameters ----------------------\n    temperature: float = 0.3          # <1 \u2192 greedier (best\u2011fit), >1 \u2192 softer\n    waste_exponent: float = 1.0       # linear waste penalty (2.0 \u2192 quadratic)\n    # ----------------------------------------------------------------\n\n    # Compute how much space would remain if the item were placed.\n    waste = bins_remain_cap - item            # positive = leftover space, negative = cannot fit\n    feasible = waste >= 0                     # boolean mask of bins that can hold the item\n\n    # Raw scores: negative (penalised) waste. Infeasible bins get -inf \u2192 zero after exp.\n    raw_scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    raw_scores[feasible] = -np.power(waste[feasible], waste_exponent)\n\n    # If no bin can accommodate the item, return a zero vector (caller may open a new bin).\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # Numerically stable softmax:\n    #   softmax(x) = exp((x - max(x)) / temperature) / sum(exp(...))\n    max_raw = raw_scores[feasible].max()\n    shifted = (raw_scores - max_raw) / temperature\n    exp_vals = np.exp(shifted)               # exp(-inf) -> 0 for infeasible bins\n\n    total = exp_vals.sum()\n    if total > 0:\n        priorities = exp_vals / total\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Deterministic best\u2011fit with exact\u2011fit boost for online bin packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin.  The bin with the highest score\n        will be selected for placement.  Bins that cannot accommodate\n        the item receive a priority of -np.inf.\n    \"\"\"\n    # Ensure the input is a NumPy array of floats\n    bins = np.asarray(bins_remain_cap, dtype=float)\n\n    # Early exit for empty bin list\n    if bins.size == 0:\n        return np.array([], dtype=float)\n\n    # Initialize all priorities to -inf (infeasible bins)\n    priorities = np.full(bins.shape, -np.inf, dtype=float)\n\n    # Find bins that can hold the item\n    fit_mask = bins >= item\n    if not np.any(fit_mask):\n        # No bin can accommodate the item\n        return priorities\n\n    # Compute leftover capacity if the item were placed in each feasible bin\n    leftovers = bins[fit_mask] - item\n\n    # Base score: prefer bins with the smallest leftover (best\u2011fit principle)\n    base_score = -leftovers\n\n    # Identify exact fits within a small tolerance\n    exact_mask = np.isclose(leftovers, 0.0, atol=1e-9)\n\n    # Boost factor for exact fits\n    BOOST = 1e6  # large constant to guarantee exact fits outrank others\n\n    # Apply boost to exact fit bins\n    final_score = base_score.copy()\n    final_score[exact_mask] += BOOST\n\n    # Assign computed scores back to the corresponding bins\n    priorities[fit_mask] = final_score\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive priority function for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. Bins that cannot accommodate the item\n        receive -inf. The bin with the highest score should be selected.\n    \"\"\"\n    # Ensure input is a NumPy array of floats\n    rem = np.asarray(bins_remain_cap, dtype=float)\n    n_bins = rem.shape[0]  # number of currently open bins\n\n    # No bins open \u2013 caller should open a new bin\n    if n_bins == 0:\n        return np.array([], dtype=float)\n\n    # Feasibility mask: bins that can hold the item\n    fit_mask = rem >= item\n\n    # If no bin can accommodate the item, return -inf for all (open new bin)\n    if not np.any(fit_mask):\n        return np.full(n_bins, -np.inf, dtype=float)\n\n    # Adaptive epsilon\u2011greedy exploration\n    base_eps = 0.1\n    fit_frac = np.count_nonzero(fit_mask) / n_bins\n    epsilon = base_eps * (1.0 - fit_frac)  # more exploration when few bins fit\n\n    rng = np.random.default_rng()\n    if rng.random() < epsilon:\n        # Random scores for feasible bins\n        scores = rng.random(n_bins)\n        scores[~fit_mask] = -np.inf\n        return scores\n\n    # Estimate bin capacity (use the maximum observed remaining capacity)\n    bin_capacity = np.max(rem)\n    if bin_capacity <= 0:\n        # Fallback to a positive reference (item size)\n        # This situation occurs only if all bins are full, which we already handled\n        bin_capacity = item\n\n    # Average utilization of the current bins (used capacity / total capacity)\n    avg_util = 1.0 - np.mean(rem) / bin_capacity  # roughly in [0, 1]\n\n    # Dynamic sigmoid steepness: steeper when utilization is high\n    base_k = 12.0\n    k = base_k * (1.0 + avg_util)\n\n    # Fill ratio for feasible bins (item size / remaining capacity)\n    fill_ratio = np.zeros_like(rem)\n    fill_ratio[fit_mask] = item / rem[fit_mask]  # values in (0, 1]\n\n    # Logistic (sigmoid) transformation centered at 0.5 fill ratio\n    arg = -k * (fill_ratio[fit_mask] - 0.5)\n    arg = np.clip(arg, -700, 700)  # avoid overflow in exp\n    sigmoid = 1.0 / (1.0 + np.exp(arg))\n\n    # Waste fraction after placing the item (leftover capacity / original remaining)\n    waste_frac = np.zeros_like(rem)\n    waste_frac[fit_mask] = (rem[fit_mask] - item) / rem[fit_mask]  # = 1 - fill_ratio\n\n    # Weight for waste penalty\n    beta = 0.5\n\n    # Combine sigmoid score with waste penalty\n    priority = np.full_like(rem, -np.inf, dtype=float)\n    priority[fit_mask] = sigmoid - beta * waste_frac[fit_mask]\n\n    # Tiny random jitter for tie\u2011breaking\n    jitter = rng.random(n_bins) * 1e-9\n    priority[fit_mask] += jitter[fit_mask]\n\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 35.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute a normalized priority score for each bin in an online Bin Packing\n    scenario.\n\n    The priority reflects the *Best\u2011Fit* rule: a bin that leaves the smallest\n    remaining capacity after accommodating the item receives the highest\n    priority.  The score is normalised to the range [0,\u202f1] for the feasible\n    bins, and infeasible bins receive ``-np.inf`` so they are never chosen.\n    A tiny tie\u2011breaker favours lower\u2011index bins when priorities are equal.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        1\u2011D array of the same shape as ``bins_remain_cap`` containing the\n        priority score for each bin (higher means more preferred).\n    \"\"\"\n    # Ensure a floating\u2011point array for safe arithmetic\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining space if the item were to be added\n    leftover = caps - item\n    feasible = leftover >= 0\n\n    # Compute leftover ratio safely (avoid division by zero)\n    leftover_ratio = np.empty_like(caps)\n    if np.any(feasible):\n        valid = feasible & (caps > 0)\n        leftover_ratio[valid] = leftover[valid] / caps[valid]\n\n        zero_cap = feasible & (caps == 0)\n        # When capacity is zero and item fits (i.e., item==0), the ratio is 0\n        leftover_ratio[zero_cap] = 0.0\n\n    # Raw priority: negative leftover ratio (higher when leftover is smaller)\n    raw_priority = np.full_like(caps, -np.inf, dtype=float)\n    if np.any(feasible):\n        raw_priority[feasible] = -leftover_ratio[feasible]\n\n    # Normalise feasible priorities to [0,\u202f1], keep infeasible as -inf\n    if np.any(feasible):\n        min_f = np.min(raw_priority[feasible])\n        max_f = np.max(raw_priority[feasible])\n        norm_range = max_f - min_f\n        if norm_range > 0:\n            norm_priority = (raw_priority - min_f) / norm_range\n        else:\n            # All feasible priorities are equal \u2192 keep them all 0\n            norm_priority = raw_priority - min_f\n    else:\n        norm_priority = raw_priority\n\n    # Tie\u2011breaker: slightly favour lower\u2011index bins\n    epsilon = 1e-9\n    tie_breaker = -epsilon * np.arange(len(norm_priority))\n    priorities = norm_priority + tie_breaker\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 27.0,
    "cyclomatic_complexity": 5.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\n# ----------------------------------------------------------------------\n# Global state for adaptive behavior (maintained across calls)\n# ----------------------------------------------------------------------\n_call_counter: int = 0          # Number of items processed so far\n_total_item_size: float = 0.0   # Cumulative size of all processed items\n\n# Exploration parameters (epsilon\u2011greedy)\n_EPSILON0: float = 0.2          # Initial exploration probability\n_MIN_EPSILON: float = 0.01      # Lower bound for exploration\n_DECAY_RATE: float = 0.001      # Exponential decay rate of epsilon\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Adaptive deterministic priority for the online Bin Packing Problem.\n\n    Scoring combines several desiderata:\n      * **Deterministic best\u2011fit** \u2013 bins that leave the smallest leftover\n        after placing the item receive higher scores.\n      * **Item\u2011size distribution awareness** \u2013 bins whose leftover would be\n        far larger than the average observed item size are penalised.\n      * **Exploration** \u2013 an epsilon\u2011greedy component whose probability decays\n        over time, allowing occasional random choices early on.\n      * **Infeasibility handling** \u2013 bins that cannot accommodate the item are\n        assigned -inf so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacities of all currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better). Bins that cannot hold\n        the item receive -np.inf.\n    \"\"\"\n    global _call_counter, _total_item_size\n\n    # ------------------------------------------------------------------\n    # Update online statistics\n    # ------------------------------------------------------------------\n    _call_counter += 1\n    _total_item_size += item\n    avg_item_size = _total_item_size / _call_counter\n\n    # ------------------------------------------------------------------\n    # Compute dynamic epsilon (decays exponentially, never below _MIN_EPSILON)\n    # ------------------------------------------------------------------\n    epsilon = max(_MIN_EPSILON, _EPSILON0 * np.exp(-_DECAY_RATE * _call_counter))\n\n    rng = np.random.default_rng()\n\n    # ------------------------------------------------------------------\n    # Exploration branch: choose a random feasible bin with probability epsilon\n    # ------------------------------------------------------------------\n    if rng.random() < epsilon:\n        feasible = bins_remain_cap >= item\n        random_scores = rng.random(bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n\n    # ------------------------------------------------------------------\n    # Deterministic scoring branch\n    # ------------------------------------------------------------------\n    leftover = bins_remain_cap - item\n    feasible = leftover >= 0\n\n    # Avoid division by zero in the inverse\u2011leftover term\n    eps = 1e-12\n\n    # Base best\u2011fit score: larger when leftover is smaller\n    base_score = np.where(feasible, 1.0 / (leftover + eps), -np.inf)\n\n    # Distribution\u2011aware penalty:\n    #   If the leftover is significantly larger than the average item size,\n    #   we reduce the priority. This discourages leaving large gaps that are\n    #   unlikely to be filled by typical future items.\n    excess = np.maximum(0.0, leftover - avg_item_size)\n    alpha = 0.5          # Penalty weight (tunable)\n    penalty = alpha * excess\n\n    # Final priority: high base score minus penalty\n    priorities = np.where(feasible, base_score - penalty, -np.inf)\n\n    return priorities",
    "response_id": 8,
    "obj": 4.098524132429212,
    "SLOC": 20.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority function for online Bin Packing.\n\n    Returns a score for each bin; higher score means more preferred.\n    Infeasible bins receive -inf.\n    The scoring combines a sigmoid bias towards tight fits, an exponential\n    penalty for waste, a boost for exact fits, and a tiny tie\u2011breaker.\n    Scores are min\u2011max normalised to [0, 1] for comparability.\n    \"\"\"\n    # Ensure a NumPy array of floats\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining capacity after placing the item\n    leftover = caps - item\n\n    # Feasibility mask: only bins that can accommodate the item\n    feasible = leftover >= 0\n\n    # Initialise all scores to -inf (infeasible)\n    scores = np.full_like(caps, -np.inf, dtype=float)\n\n    # If no feasible bins exist, return early\n    if not np.any(feasible):\n        return scores\n\n    # ----------------------------------------------------------------------\n    # Adaptive steepness based on current leftover distribution\n    # ----------------------------------------------------------------------\n    median_leftover = np.median(leftover[feasible])\n    base_alpha = 5.0            # base steepness for the sigmoid\n    eps = 1e-12\n    # Larger steepness when median leftover is small (tight\u2011fit regime)\n    alpha = base_alpha / (median_leftover + eps)\n    # Clamp to avoid extreme exponentials\n    alpha = np.clip(alpha, 0.1, 100.0)\n\n    # Use the same parameter for the exponential waste penalty\n    beta = alpha\n\n    # ----------------------------------------------------------------------\n    # Sigmoid component (tight\u2011fit bias)\n    # ----------------------------------------------------------------------\n    max_exp = 50.0  # clip exponent to keep np.exp stable\n    exp_arg = np.clip(alpha * leftover[feasible], 0.0, max_exp)\n    # 2/(1+exp(alpha * leftover)) yields 1 at leftover=0 and decays smoothly\n    sigmoid = 2.0 / (1.0 + np.exp(exp_arg))\n\n    # ----------------------------------------------------------------------\n    # Exponential waste penalty\n    # ----------------------------------------------------------------------\n    pen_exp_arg = np.clip(beta * leftover[feasible], 0.0, max_exp)\n    penalty = np.exp(pen_exp_arg)\n\n    # Combine components; lambda balances penalty strength (set to 1.0)\n    lam = 1.0\n    raw = sigmoid - lam * penalty\n\n    # ----------------------------------------------------------------------\n    # Boost exact fits\n    # ----------------------------------------------------------------------\n    exact_fit_tol = 1e-9\n    exact_fit_bonus = 10.0\n    exact_fit_mask = leftover[feasible] <= exact_fit_tol\n    raw[exact_fit_mask] += exact_fit_bonus\n\n    # ----------------------------------------------------------------------\n    # Normalise to [0, 1]\n    # ----------------------------------------------------------------------\n    min_raw = raw.min()\n    max_raw = raw.max()\n    if max_raw > min_raw:\n        norm_raw = (raw - min_raw) / (max_raw - min_raw)\n    else:\n        # All values equal (e.g., all exact fits); give them zero before tie\u2011break\n        norm_raw = np.zeros_like(raw)\n\n    # ----------------------------------------------------------------------\n    # Tiny tie\u2011breaker preferring lower\u2011index bins\n    # ----------------------------------------------------------------------\n    epsilon = 1e-12\n    feasible_indices = np.nonzero(feasible)[0]  # original indices of feasible bins\n    norm_raw = norm_raw - epsilon * feasible_indices.astype(float)\n\n    # Populate the final scores array\n    scores[feasible] = norm_raw\n\n    return scores",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 35.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]