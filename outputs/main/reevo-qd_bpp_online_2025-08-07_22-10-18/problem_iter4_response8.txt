```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing.

    Gives higher priority to bins that accommodate the item tightly.
    The steepness of the sigmoid is calibrated to the spread of feasible
    residual capacities, ensuring a balanced exploitation of tight fits
    across different instance scales. Infeasible bins receive -inf.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as `bins_remain_cap`).
        Higher values indicate more desirable bins; infeasible bins are
        penalised with -inf.
    """
    # Ensure a NumPy float array.
    caps = np.asarray(bins_remain_cap, dtype=float)
    if caps.size == 0:
        return np.array([], dtype=float)

    # Residual capacity after placing the item in each bin.
    residual = caps - item

    # Feasibility mask.
    feasible = residual >= 0

    # If nothing fits, return -inf for every bin.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Residuals of feasible bins.
    feasible_res = residual[feasible]

    # Adaptive steepness: based on the more robust spread of feasible residuals.
    # Use standard deviation; fall back to range if std is zero.
    std = np.std(feasible_res)
    if std <= 0.0:
        spread = np.max(feasible_res) - np.min(feasible_res)
        std = spread if spread > 0.0 else 1.0

    # Base steepness factor (tunable). Larger std → softer sigmoid.
    base_steepness = 5.0
    slope = base_steepness / std

    # Sigmoid of negative residual: tighter fit → larger score.
    # score = 1 / (1 + exp(slope * residual))
    # Clip exponent to avoid overflow/underflow.
    exp_arg = np.clip(slope * residual, -700, 700)
    scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Penalise infeasible bins.
    scores = np.where(feasible, scores, -np.inf)

    # Deterministic tie‑breaker: tiny bias favouring lower indices.
    # This does not affect ordering unless scores are exactly equal.
    tie_bias = -np.arange(caps.shape[0]) * 1e-12
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
