```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority scoring for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority score for each bin (higher is better). Infeasible bins receive
        ``-np.inf``. If no bins are open, an empty array is returned.
    """
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask
    fit_mask = caps >= item
    if not np.any(fit_mask):
        return np.full(n_bins, -np.inf, dtype=float)

    # Lightweight epsilon‑greedy exploration
    rng = np.random.default_rng()
    base_eps = 0.05
    fit_frac = np.mean(fit_mask)
    epsilon = base_eps * (1.0 - fit_frac)
    if rng.random() < epsilon:
        scores = rng.random(n_bins)
        scores[~fit_mask] = -np.inf
        return scores

    # Estimate bin capacity from the largest remaining capacity
    bin_capacity = caps.max()
    if bin_capacity <= 0.0:
        bin_capacity = item

    # Compute metrics for feasible bins only
    fit_caps = caps[fit_mask]
    fill_ratio_fit = item / fit_caps
    waste_frac_fit = 1.0 - fill_ratio_fit
    utilisation_fit = 1.0 - fit_caps / bin_capacity

    # Simple scoring: encourage high fill ratio, penalise waste, reward utilisation
    beta = 1.0   # waste penalty weight
    delta = 0.3  # utilisation reward weight

    priority = np.full(n_bins, -np.inf, dtype=float)
    priority[fit_mask] = (
        fill_ratio_fit
        - beta * waste_frac_fit
        + delta * utilisation_fit
    )

    # Deterministic tie‑breaker (index‑based)
    priority += np.arange(n_bins) * 1e-9

    return priority
```
