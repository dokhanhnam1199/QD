```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online Bin Packing (version 2).

    For each currently open bin the function returns a score; higher scores
    indicate a more desirable bin for placing ``item``. Bins that cannot
    accommodate the item receive ``-inf`` so they are never selected.

    The scoring uses a logistic function whose steepness adapts to the
    dispersion of the feasible residual capacities, estimated robustly via
    the Median Absolute Deviation (MAD). A tiny deterministic bias breaks
    ties in favour of lower‑index bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``).
    """
    # Ensure a 1‑D float array.
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.shape[0]

    # Initialise all scores to -inf (infeasible by default).
    scores = np.full(n_bins, -np.inf, dtype=float)

    # No bins open → return empty score vector.
    if n_bins == 0:
        return scores

    # Residual capacity after hypothetically placing the item.
    residual = caps - item

    # Feasibility mask: only bins with enough remaining capacity.
    feasible = residual >= 0

    # If no bin can accommodate the item, return the -inf vector.
    if not np.any(feasible):
        return scores

    # Residual capacities of feasible bins.
    feas_res = residual[feasible]

    # ------------------------------------------------------------------
    # Robust spread estimation using MAD.
    # ------------------------------------------------------------------
    median_res = np.median(feas_res)
    mad = np.median(np.abs(feas_res - median_res))
    # Convert MAD to an estimate of standard deviation for normal data.
    spread = mad * 1.4826

    # Fallback strategies if MAD yields zero spread.
    if spread <= 0.0:
        std = np.std(feas_res)
        if std > 0.0:
            spread = std
        else:
            # Use range as last resort.
            rng = np.max(feas_res) - np.min(feas_res)
            spread = rng if rng > 0.0 else 1.0

    # ------------------------------------------------------------------
    # Adaptive logistic scoring.
    # ------------------------------------------------------------------
    base_steepness = 5.0  # tunable parameter controlling baseline steepness.
    slope = base_steepness / spread

    # Compute logistic scores for feasible bins.
    # Score = 1 / (1 + exp(slope * residual)), decreasing with larger residual.
    arg = slope * residual[feasible]
    # Clip arguments to avoid overflow in the exponential.
    arg = np.clip(arg, -700.0, 700.0)
    scores_feas = 1.0 / (1.0 + np.exp(arg))

    # Assign computed scores to the feasible positions.
    scores[feasible] = scores_feas

    # ------------------------------------------------------------------
    # Deterministic tie‑breaker: tiny bias favouring lower‑index bins.
    # ------------------------------------------------------------------
    epsilon = 1e-12
    tie_bias = -np.arange(n_bins, dtype=float) * epsilon
    # Apply bias only to feasible (non -inf) scores.
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
