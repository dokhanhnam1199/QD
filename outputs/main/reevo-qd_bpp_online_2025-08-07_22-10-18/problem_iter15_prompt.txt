{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Prior reflection]\nScale leftovers by MAD, feed into a smooth sigmoid with steepness set by median residual. Add a tiny deterministic tie\u2011breaker. Boost exact fits, penalize waste proportionally. Use adaptive \u03b5\u2011greedy (decaying), clip exponents, vectorise, avoid per\u2011call randomness and heavy normalisation. Handle zero spread.\n\n[Code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n# ----------------------------------------------------------------------\n# Global state (persisted across calls) \u2013 used for adaptive behaviour.\n# ----------------------------------------------------------------------\n_call_counter: int = 0               # Number of items processed so far\n_total_item_size: float = 0.0        # Cumulative size of all items seen\n_ema_item_size: float = 0.0          # Exponential moving average of item size\n_ema_alpha: float = 0.2              # Smoothing factor for EMA (0 < \u03b1 \u2264 1)\n\n# Exploration (epsilon\u2011greedy) schedule\n_EPSILON0: float = 0.15              # Initial exploration probability\n_MIN_EPSILON: float = 0.02           # Floor for exploration probability\n_DECAY_RATE: float = 5e-4           # Exponential decay rate (slower decay)\n\n# Waste\u2011penalty configuration\n_WASTE_PENALTY_WEIGHT: float = 0.35  # Relative importance of waste excess\n_EPS: float = 1e-12                  # Tiny epsilon to avoid division by zero\n\n# Random number generator (single instance for reproducibility)\n_rng = np.random.default_rng()\n\n\n    \"\"\"\n    Adaptive priority function for online Bin Packing.\n\n    Blends several heuristics:\n      \u2022 Exact\u2011fit bins (zero waste) get infinite priority.\n      \u2022 Best\u2011fit: for feasible non\u2011exact bins, priority \u221d 1 / waste.\n      \u2022 Waste penalty: bins whose waste exceeds the EMA of observed item\n        sizes are penalised proportionally.\n      \u2022 Adaptive epsilon\u2011greedy exploration: with a decaying probability a\n        random feasible bin is chosen to encourage diversification.\n      \u2022 Small random jitter is added to break ties deterministically.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item (must be non\u2011negative).\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher = more preferred).  Infeasible\n        bins receive -inf.\n    \"\"\"\n    global _call_counter, _total_item_size, _ema_item_size\n\n    # ------------------------------------------------------------------\n    # 1) Normalise input and update online statistics.\n    # ------------------------------------------------------------------\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    _call_counter += 1\n    _total_item_size += item\n\n    # Update exponential moving average of item size.\n    if _call_counter and _call_counter == 1:\n        _ema_item_size = item\n    else:\n        _ema_item_size = _ema_alpha * item + (1.0 - _ema_alpha) * _ema_item_size\n\n    # ------------------------------------------------------------------\n    # 2) Compute adaptive epsilon.\n    # ------------------------------------------------------------------\n    epsilon = max(_MIN_EPSILON, _EPSILON0 * np.exp(-_DECAY_RATE * _call_counter))\n\n    # ------------------------------------------------------------------\n    # 3) Exploration branch \u2013 random feasible bin with probability epsilon.\n    # ------------------------------------------------------------------\n    if _rng.random() < epsilon:\n        feasible = bins_remain_cap >= item\n        random_scores = _rng.random(bins_remain_cap.shape[0])\n        return np.where(feasible, random_scores, -np.inf)\n\n    # ------------------------------------------------------------------\n    # 4) Deterministic scoring branch.\n    # ------------------------------------------------------------------\n    waste = bins_remain_cap - item                      # Positive = leftover space\n    feasible_mask = waste >= -_EPS                       # Allow tiny negative tolerance\n\n    # Initialise all priorities to -inf (infeasible by default).\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Exact\u2011fit detection \u2013 give them a \"perfect\" priority.\n    atol = 1e-9\n    exact_fit_mask = np.isclose(waste, 0.0, atol=atol) & feasible_mask\n    priorities[exact_fit_mask] = np.inf\n\n    # Non\u2011exact but feasible bins.\n    non_exact_mask = feasible_mask & ~exact_fit_mask\n    if np.any(non_exact_mask):\n        # Base best\u2011fit score: inverse of leftover space.\n        base_score = 1.0 / (waste[non_exact_mask] + _EPS)\n\n        # Penalty for waste that exceeds the EMA of observed item sizes.\n        waste_excess = np.maximum(0.0, waste[non_exact_mask] - _ema_item_size)\n        penalty = _WASTE_PENALTY_WEIGHT * waste_excess\n\n        # Combine base score and penalty.\n        score = base_score - penalty\n\n        # Ensure scores stay positive (still better than -inf).\n        score = np.maximum(score, _EPS)\n        priorities[non_exact_mask] = score\n\n    # ------------------------------------------------------------------\n    # 5) Tie\u2011breaking jitter \u2013 very small random perturbation.\n    # ------------------------------------------------------------------\n    jitter = _rng.random(bins_remain_cap.shape[0]) * 1e-8\n    priorities += jitter\n\n    return priorities\n\n[Improved code]\nPlease write a mutated function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}