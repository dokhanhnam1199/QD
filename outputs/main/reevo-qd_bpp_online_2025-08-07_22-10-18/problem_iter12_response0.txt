```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher is better). Bins that cannot accommodate the item
        receive -inf so they are never selected.
    """
    # Ensure a 1‑D float array of capacities
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        return np.empty(0, dtype=float)

    residual = caps - item
    feasible = residual >= 0

    # Initialise all scores with -inf for infeasible bins
    scores = np.full(n_bins, -np.inf, dtype=float)

    if not np.any(feasible):
        # No bin can fit the item
        return scores

    feas_res = residual[feasible]

    # Robust spread estimation using MAD
    median_res = np.median(feas_res)
    mad = np.median(np.abs(feas_res - median_res))
    spread = mad * 1.4826

    # Fallback if MAD is zero
    if spread <= 0:
        std = np.std(feas_res)
        if std > 0:
            spread = std
        else:
            rng = feas_res.max() - feas_res.min()
            spread = rng if rng > 0 else 1.0

    # Adaptive sigmoid slope (larger spread → flatter curve)
    base_slope = 5.0
    slope = base_slope / spread

    # Logistic decreasing with residual capacity
    exp_arg = slope * residual[feasible]
    # Clip to avoid overflow in exp
    exp_arg = np.clip(exp_arg, -700, 700)
    scores_feas = 1.0 / (1.0 + np.exp(exp_arg))

    # Assign computed scores to feasible bins
    scores[feasible] = scores_feas

    # Deterministic tie‑breaker: tiny decreasing bias by bin index
    eps = 1e-12
    bias = -np.arange(n_bins, dtype=float) * eps
    scores += bias

    return scores
```
