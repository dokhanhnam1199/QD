```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid‑softmax priority for online Bin Packing.

    Computes a priority score for each open bin based on how tightly the
    incoming item would fit.  The steepness of the decay adapts to the
    spread of feasible residual capacities, providing a balance between
    greedy best‑fit and softer exploration.  Infeasible bins receive a
    heavy penalty (``-np.inf``).  A tiny deterministic tie‑bias favours
    lower‑indexed bins when scores are otherwise equal.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better).  Scores are
        positive for feasible bins and ``-np.inf`` for infeasible ones.
        The values are not normalized; the caller should select the bin
        with the highest score (e.g., ``np.argmax``).
    """
    # Convert to a float array for safety.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no bins at all.
    if caps.size == 0:
        return np.array([], dtype=float)

    # Residual capacity after hypothetically placing the item.
    residual = caps - item

    # Feasibility mask: only bins that can accommodate the item.
    feasible = residual >= 0

    # If nothing fits, penalise every bin heavily.
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Residuals of feasible bins.
    feasible_res = residual[feasible]

    # Estimate the spread of feasible residuals.
    # Use standard deviation; fall back to range if the std is (near) zero.
    eps = 1e-12
    std = np.std(feasible_res)
    if std <= eps:
        spread = feasible_res.max() - feasible_res.min()
        std = spread if spread > eps else eps

    # Base steepness (tunable). Larger value → sharper preference for tight fits.
    base_steepness = 5.0

    # Adaptive slope: inversely proportional to the spread.
    slope = base_steepness / std

    # Compute log‑scores (higher is better). For infeasible bins we keep -inf.
    log_scores = np.full_like(caps, -np.inf, dtype=float)
    # Tiny deterministic tie‑breaker: lower indices get a slight advantage.
    tie_bias = -np.arange(caps.shape[0]) * 1e-12
    # Log‑score = -slope * residual + tie bias (only for feasible bins).
    log_scores[feasible] = -slope * residual[feasible] + tie_bias[feasible]

    # Convert log‑scores to raw positive scores.
    scores = np.full_like(caps, -np.inf, dtype=float)
    scores[feasible] = np.exp(log_scores[feasible])

    return scores
```
