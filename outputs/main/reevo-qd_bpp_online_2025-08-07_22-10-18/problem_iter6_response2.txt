```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Smooth adaptive priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Higher values correspond to more
        desirable bins.  Infeasible bins receive -np.inf.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.size
    if n_bins == 0:
        return np.array([], dtype=float)

    residual = caps - item
    feasible = residual >= 0

    # No feasible bin: all priorities are -inf
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Compute spread of residuals in feasible bins to adapt the steepness
    feasible_res = residual[feasible]
    std = np.std(feasible_res)
    if std <= 0.0:
        spread = np.max(feasible_res) - np.min(feasible_res)
        std = spread if spread > 0 else 1.0

    # Base steepness factor (tunable). Larger spread -> softer sigmoid.
    base_steepness = 5.0
    slope = base_steepness / std

    # Logistic scoring: tighter fit => higher score
    exp_arg = np.clip(slope * residual, -700, 700)
    scores = 1.0 / (1.0 + np.exp(exp_arg))
    # Scale to [0,1] with max 1 at zero residual
    scores *= 2.0
    # Infeasible bins -> -inf
    scores = np.where(feasible, scores, -np.inf)

    # Deterministic tie‑breaker: lower index gets infinitesimal advantage
    tie_bias = -np.arange(n_bins, dtype=float) * 1e-12
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
