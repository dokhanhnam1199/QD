```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive priority function for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Bins that cannot accommodate the item
        receive -inf. The bin with the highest score should be selected.
    """
    # Ensure input is a NumPy array of floats
    rem = np.asarray(bins_remain_cap, dtype=float)
    n_bins = rem.shape[0]  # number of currently open bins

    # No bins open – caller should open a new bin
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask: bins that can hold the item
    fit_mask = rem >= item

    # If no bin can accommodate the item, return -inf for all (open new bin)
    if not np.any(fit_mask):
        return np.full(n_bins, -np.inf, dtype=float)

    # Adaptive epsilon‑greedy exploration
    base_eps = 0.1
    fit_frac = np.count_nonzero(fit_mask) / n_bins
    epsilon = base_eps * (1.0 - fit_frac)  # more exploration when few bins fit

    rng = np.random.default_rng()
    if rng.random() < epsilon:
        # Random scores for feasible bins
        scores = rng.random(n_bins)
        scores[~fit_mask] = -np.inf
        return scores

    # Estimate bin capacity (use the maximum observed remaining capacity)
    bin_capacity = np.max(rem)
    if bin_capacity <= 0:
        # Fallback to a positive reference (item size)
        # This situation occurs only if all bins are full, which we already handled
        bin_capacity = item

    # Average utilization of the current bins (used capacity / total capacity)
    avg_util = 1.0 - np.mean(rem) / bin_capacity  # roughly in [0, 1]

    # Dynamic sigmoid steepness: steeper when utilization is high
    base_k = 12.0
    k = base_k * (1.0 + avg_util)

    # Fill ratio for feasible bins (item size / remaining capacity)
    fill_ratio = np.zeros_like(rem)
    fill_ratio[fit_mask] = item / rem[fit_mask]  # values in (0, 1]

    # Logistic (sigmoid) transformation centered at 0.5 fill ratio
    arg = -k * (fill_ratio[fit_mask] - 0.5)
    arg = np.clip(arg, -700, 700)  # avoid overflow in exp
    sigmoid = 1.0 / (1.0 + np.exp(arg))

    # Waste fraction after placing the item (leftover capacity / original remaining)
    waste_frac = np.zeros_like(rem)
    waste_frac[fit_mask] = (rem[fit_mask] - item) / rem[fit_mask]  # = 1 - fill_ratio

    # Weight for waste penalty
    beta = 0.5

    # Combine sigmoid score with waste penalty
    priority = np.full_like(rem, -np.inf, dtype=float)
    priority[fit_mask] = sigmoid - beta * waste_frac[fit_mask]

    # Tiny random jitter for tie‑breaking
    jitter = rng.random(n_bins) * 1e-9
    priority[fit_mask] += jitter[fit_mask]

    return priority
```
