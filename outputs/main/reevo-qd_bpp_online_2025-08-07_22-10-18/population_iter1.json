[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Best\u2011Fit priority for online Bin Packing.\n\n    The bin that leaves the smallest remaining capacity after receiving the\n    *item* gets the highest priority. Bins that cannot accommodate the item\n    receive a very low (\u2011inf) priority and will never be selected.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array of remaining capacities for each existing bin.\n\n    Returns:\n        NumPy array with a priority score for each bin (higher means more\n        preferred). The shape matches ``bins_remain_cap``.\n    \"\"\"\n    # Work in floating point to safely use -inf for infeasible bins.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    # Remaining space after the item would be placed.\n    leftover = caps - item\n\n    # Assign priority: bins that can fit the item get -leftover (higher for\n    # smaller leftover). Infeasible bins get -inf.\n    priorities = np.where(leftover >= 0, -leftover, -np.inf)\n\n    # Tiny tie\u2011breaker: favor lower\u2011index bins when leftover is identical.\n    # This epsilon is far smaller than any realistic leftover value.\n    epsilon = 1e-9\n    tie_break = -epsilon * np.arange(priorities.size)\n    priorities = priorities + tie_break\n\n    return priorities",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Best\u2011Fit priority for online Bin Packing.\n\n    For each bin the function evaluates the remaining space that would be left\n    after placing ``item``.  Bins that can accommodate the item receive a\n    priority proportional to the negative of this leftover \u2013 i.e. a smaller\n    leftover yields a larger priority.  Bins that cannot fit the item are\n    assigned ``-np.inf`` so they are never selected.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of the remaining capacity of each currently open bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (same shape as ``bins_remain_cap``). The\n        caller should select the bin with the highest priority.\n    \"\"\"\n    # Compute the prospective leftover space after adding the item.\n    leftover = bins_remain_cap - item\n\n    # Feasibility mask: only bins with non\u2011negative leftover can hold the item.\n    feasible = leftover >= 0\n\n    # Base priority: -leftover (smaller leftover \u2192 larger priority).\n    # Infeasible bins receive -inf.\n    priorities = np.where(feasible, -leftover, -np.inf)\n\n    # ----------------------------------------------------------------------\n    # OPTIONAL tie\u2011breaker: prefer earlier bins (lower index) when priorities\n    # are otherwise identical.  This adds a negligible offset that does not\n    # alter the main ordering.\n    # ----------------------------------------------------------------------\n    if priorities.size:\n        # Machine epsilon for the array's dtype (or float64 if integer).\n        eps = np.finfo(priorities.dtype).eps if np.issubdtype(priorities.dtype, np.floating) else np.finfo(np.float64).eps\n        tie_break = np.arange(priorities.size, dtype=priorities.dtype) * eps\n        priorities = priorities - tie_break\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\n# Exploration probability for the epsilon\u2011greedy strategy\nEPSILON = 0.1\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011greedy priority function for online Bin Packing.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array of the remaining capacities of the open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin. The bin with the highest score\n        will be selected. Bins that cannot accommodate the item are\n        assigned a very low priority (-\u221e).\n    \"\"\"\n    rng = np.random.default_rng()\n\n    # Exploration phase with probability EPSILON\n    if rng.random() < EPSILON:\n        # Generate uniform random scores for a purely random pick\n        return rng.random(bins_remain_cap.shape[0])\n\n    # Exploitation phase: best\u2011fit measure\n    leftover = bins_remain_cap - item\n    # Only bins that can hold the item are considered; others get -\u221e\n    priorities = np.where(leftover >= 0, leftover, -np.inf)\n    return priorities",
    "response_id": 8,
    "obj": 137.9537295572397,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Return priority scores for placing an incoming item into existing bins\n    based on the Exact\u2011Fit\u2011First heuristic.\n\n    Parameters\n    ----------\n    item : float\n        Size of the new item that needs to be packed.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities for all currently open bins.\n\n    Returns\n    -------\n    np.ndarray\n        Same shape as *bins_remain_cap*; each entry is the priority score\n        for placing *item* into the corresponding bin.  The bin with the\n        maximum score will be selected by the scheduler.\n    \"\"\"\n    # Initialise with a very low score to effectively drop bins that\n    # cannot accommodate the item.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins that can hold the item\n    fit_mask = bins_remain_cap >= item\n\n    if not np.any(fit_mask):\n        # No bin can contain the item \u2013 all scores remain -inf\n        return priorities\n\n    # Space that would be left after the placement\n    leftovers = bins_remain_cap[fit_mask] - item\n\n    # Detect bins that would result in an exact fit\n    exact_mask = np.isclose(leftovers, 0.0, atol=1e-9)\n\n    # Base score prefers smaller leftover (best\u2011fit principle):\n    # larger (less negative) values correspond to better fit.\n    base_score = -leftovers\n    # Boost the score for exact fits so they outrank all non\u2011exact ones.\n    boost = 10.0  # arbitrary large constant\n\n    # Compute final scores\n    priorities[fit_mask] = base_score + (exact_mask * boost)\n\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Inverse Distance (Proximity Fit) priority for online Bin Packing.\n\n    For each bin that can accommodate the item, compute the leftover capacity\n    after placing the item and assign a priority equal to the inverse of that\n    leftover (plus a tiny epsilon to avoid division by zero).  \n    Bins that cannot hold the item receive a very large negative priority,\n    ensuring they are never chosen.  \n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Remaining capacity of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher is better).\n    \"\"\"\n    # Compute available space after packing `item`\n    space_left = bins_remain_cap - item\n\n    # Only consider bins that can hold the item\n    valid = space_left >= 0\n\n    # Avoid division by zero with a very small epsilon\n    eps = 1e-12\n\n    # Inverse distance priority: the closer the remaining space to zero,\n    # the higher the priority. Use -np.inf for invalid bins.\n    priorities = np.where(\n        valid,\n        1.0 / (space_left + eps),  # Inverse of leftover space\n        -np.inf                    # Completely invalid bins\n    )\n\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute priority scores for each bin using a Sigmoid Fit Score strategy.\n    Bins that cannot accommodate the item receive a very low priority (-inf).\n\n    Parameters\n    ----------\n    item : float\n        Size of the item to be packed.\n    bins_remain_cap : np.ndarray\n        Remaining capacities of each bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores for each bin.  The bin with the highest\n        priority score will be chosen to store the item.\n    \"\"\"\n    # Ensure numeric types for accurate arithmetic\n    rem = bins_remain_cap.astype(float, copy=False)\n\n    # Mask of bins that can actually fit the item\n    fit_mask = rem >= item\n\n    # Initialize all priorities with negative infinity (bins that cannot fit)\n    priorities = np.full_like(rem, -np.inf, dtype=float)\n\n    if not np.any(fit_mask):\n        return priorities  # no bin can fit the item\n\n    # Compute the difference between remaining capacity and the item size\n    diff = rem[fit_mask] - item\n\n    # The fill ratio after placing the item: value in (0, 1]\n    fill_ratio = 1.0 - diff / rem[fit_mask]\n\n    # Logistic (sigmoid) transformation to obtain a smooth prioritization\n    # Good fit (fill_ratio close to 1) \u2192 score close to 1\n    # Poor fit (small fill_ratio)   \u2192 score close to 0\n    k = 12.0  # Steepness of the sigmoid\n    sigmoid = 1.0 / (1.0 + np.exp(-k * (fill_ratio - 0.5)))\n\n    priorities[fit_mask] = sigmoid\n\n    return priorities",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Almost\u2011Full\u2011Fit priority for online Bin Packing.\n    Bins that become \"almost full\" after adding the item get higher priority.\n    An item is considered a fit for a bin if the remaining capacity is non\u2011negative.\n    Bins that do not fit receive a priority of -np.inf.\n    \n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array containing the remaining capacity of each bin.\n    \n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (same shape as bins_remain_cap).\n    \"\"\"\n    # Ensure we work with a NumPy array and avoid datatype surprises\n    rem_cap = np.asarray(bins_remain_cap, dtype=np.float64)\n\n    # Allocate priority vector\n    priorities = np.full_like(rem_cap, -np.inf, dtype=np.float64)\n\n    # Identify bins that can accommodate the item\n    fit_mask = rem_cap >= item\n    if not np.any(fit_mask):\n        # Nothing fits \u2013 return all -inf priorities\n        return priorities\n\n    # Remaining capacity after packing the item\n    remaining = rem_cap[fit_mask] - item\n    capacity   = rem_cap[fit_mask]\n\n    # Normalized slack: 0 means perfect fill, 1 means bin is empty\n    slack_ratio = remaining / capacity\n\n    # Heuristic: the smaller the slack_ratio, the higher the priority\n    # For \"almost full\" bins (slack_ratio <= THRESHOLD) we use a steeper penalty\n    THRESHOLD = 0.2  # <20% unused capacity is considered almost full\n    priorities[fit_mask] = np.where(\n        slack_ratio <= THRESHOLD,\n        1.0 / (slack_ratio + 1e-9),   # strongly favor very low slack\n        1.0 / (1.0 + slack_ratio)     # mild penalty for larger slack\n    )\n\n    return priorities",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 2.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Exact\u2011Fit\u2011First priority function for online Bin Packing.\n    \n    Bins where the item fits exactly receive the highest priority (infinite).\n    Among the remaining bins that can accommodate the item, those that leave the\n    smallest waste (i.e., smallest remaining capacity after insertion) receive\n    higher priority, proportional to 1 / waste.\n    Bins that cannot accommodate the item get a very low (\u2212inf) priority.\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        1\u2011D array of remaining capacities of the current bins.\n\n    Returns\n    -------\n    np.ndarray\n        Priority scores for each bin (higher = more preferred).\n    \"\"\"\n    # Ensure a NumPy array of floats\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Compute the waste that would remain after placing the item\n    waste = bins_remain_cap - item\n\n    # Floating\u2011point tolerance for equality checks\n    atol = 1e-9\n\n    # Masks\n    exact_fit_mask = np.isclose(waste, 0.0, atol=atol)      # exact fits\n    can_fit_mask   = waste >= -atol                         # fits (including exact)\n\n    # Initialize all priorities to \u2212inf (cannot fit)\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Exact fits get the highest possible priority\n    priorities[exact_fit_mask] = np.inf\n\n    # Non\u2011exact but feasible bins get priority inversely proportional to waste\n    # (smaller waste \u2192 larger priority). Small epsilon avoids division by zero.\n    epsilon = 1e-12\n    non_exact_mask = can_fit_mask & ~exact_fit_mask\n    priorities[non_exact_mask] = 1.0 / (waste[non_exact_mask] + epsilon)\n\n    return priorities",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sigmoid Fit Score priority for online bin packing.\n\n    This function assigns a higher priority to bins where the item fits tightly.\n    Bins that cannot accommodate the item receive a very low (\u2011inf) priority.\n    For feasible bins the remaining capacity after placement is fed through a\n    sigmoid: the smaller the leftover space, the larger the score.\n\n    Args:\n        item: Size of the incoming item.\n        bins_remain_cap: 1\u2011D array with the remaining capacity of each bin.\n\n    Returns:\n        np.ndarray of the same shape as `bins_remain_cap` with priority scores.\n        Higher values indicate more desirable bins.\n    \"\"\"\n    # Ensure input is a NumPy array of floats.\n    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)\n\n    # Residual capacity if we placed the item in each bin.\n    residual = bins_remain_cap - item\n\n    # Identify infeasible bins (item does not fit).\n    infeasible = residual < 0\n\n    # Feasible residuals for slope calibration.\n    feasible_res = residual[~infeasible]\n\n    # If there are no feasible bins, return an array of -inf.\n    if feasible_res.size == 0:\n        return np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Adaptive sigmoid steepness:\n    # Larger spread of feasible residuals \u2192 softer sigmoid.\n    std = np.std(feasible_res)\n    # Guard against zero std (all residuals identical).\n    std = std if std > 0 else 1.0\n    slope = 5.0 / std  # 5.0 is a tunable base steepness.\n\n    # Compute sigmoid of negative residual: tighter fit \u2192 higher score.\n    # score = 1 / (1 + exp(slope * residual))\n    # Clip exponent to avoid overflow in np.exp.\n    exp_arg = np.clip(slope * residual, -700, 700)\n    scores = 1.0 / (1.0 + np.exp(exp_arg))\n\n    # Force infeasible bins to the lowest possible priority.\n    scores = np.where(infeasible, -np.inf, scores)\n\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Softmax\u2011Based Fit priority for online Bin Packing.\n\n    For each bin we compute the amount of *wasted* space that would remain\n    after inserting the item (if the item fits).  The priority is then an\n    exponential (softmax) decay of this waste \u2013 bins that leave little or no\n    waste get the highest scores.  A temperature parameter controls the\n    greediness: lower values behave like a Best\u2011Fit heuristic, higher values\n    produce a softer distribution (more exploration).\n\n    Parameters\n    ----------\n    item : float\n        Size of the incoming item.\n    bins_remain_cap : np.ndarray\n        Array containing the remaining capacity of each existing bin.\n\n    Returns\n    -------\n    np.ndarray\n        Array of priority scores (summing to 1 over feasible bins).  Bins that\n        cannot accommodate the item receive a priority of 0.\n    a new bin will be opened when all priorities are zero.\n    \"\"\"\n    # ---------------------- hyper\u2011parameters ----------------------\n    temperature: float = 0.3          # <1 \u2192 greedier (best\u2011fit), >1 \u2192 softer\n    waste_exponent: float = 1.0       # linear waste penalty (2.0 \u2192 quadratic)\n    # ----------------------------------------------------------------\n\n    # Compute how much space would remain if the item were placed.\n    waste = bins_remain_cap - item            # positive = leftover space, negative = cannot fit\n    feasible = waste >= 0                     # boolean mask of bins that can hold the item\n\n    # Raw scores: negative (penalised) waste. Infeasible bins get -inf \u2192 zero after exp.\n    raw_scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    raw_scores[feasible] = -np.power(waste[feasible], waste_exponent)\n\n    # If no bin can accommodate the item, return a zero vector (caller may open a new bin).\n    if not feasible.any():\n        return np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    # Numerically stable softmax:\n    #   softmax(x) = exp((x - max(x)) / temperature) / sum(exp(...))\n    max_raw = raw_scores[feasible].max()\n    shifted = (raw_scores - max_raw) / temperature\n    exp_vals = np.exp(shifted)               # exp(-inf) -> 0 for infeasible bins\n\n    total = exp_vals.sum()\n    if total > 0:\n        priorities = exp_vals / total\n    else:\n        priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)\n\n    return priorities",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                epsilon: float = 0.1,\n                seed: int | None = None) -> np.ndarray:\n    \"\"\"\n    Epsilon\u2011Greedy priority heuristic for the online Bin Packing Problem.\n    \n    The function returns a score array, one score per bin, where the\n    bin with the largest score will be selected for packing the current\n    item.\n    \n    With probability (1 - epsilon) the best\u2011fit rule is applied:\n        * Bins that can accommodate the item are ranked by the\n          *remaining* capacity after placement (smaller remaining\n          capacity is better).\n        * Bins that cannot fit the item receive a very negative score.\n    \n    With probability epsilon the algorithm performs exploration:\n        * One of the feasible bins (that can accommodate the item)\n          is chosen uniformly at random and given a neutral score.\n        * All other bins receive a very negative score, ensuring that\n          the random bin will be selected.\n    \n    Args:\n        item:   Size of the current item to be packed.\n        bins_remain_cap:  1\u2011D array of the remaining capacities of each bin.\n        epsilon:  Exploration probability (default 0.1). Must be in [0, 1].\n        seed:    Optional seed for the random number generator, for\n                 reproducibility. If None, a non\u2011deterministic seed is used.\n    \n    Returns:\n        A numpy array of float scores, same shape as `bins_remain_cap`,\n        suitable for use with `np.argmax` to pick the bin.\n    \"\"\"\n    # Ensure we are working with a float array.\n    caps = np.asarray(bins_remain_cap, dtype=float)\n\n    rng = np.random.default_rng(seed)\n    feasible = caps >= item\n\n    # Start with very low scores for all bins.\n    priorities = np.full(caps.shape, -np.inf, dtype=float)\n\n    if rng.random() < epsilon:  # Exploration\n        feasible_idx = np.where(feasible)[0]\n        if feasible_idx.size:\n            chosen = rng.choice(feasible_idx)\n            priorities[chosen] = 0.0\n        # If no bin can accommodate the item, all scores stay at -inf.\n    else:  # Exploitation (best\u2011fit)\n        remaining_after = caps - item\n        # Higher scores are better: the smaller the remaining space after\n        # placing the item, the higher the priority.\n        priorities[feasible] = -remaining_after[feasible]\n\n    return priorities",
    "response_id": 28,
    "obj": 4.15835660151576,
    "SLOC": 17.0,
    "cyclomatic_complexity": 3.0,
    "exec_success": true
  }
]