```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Create a priority array using a First‑Fit with a compact packing bonus.

    Bins that can accommodate the new item receive a score that combines
    the *position* of the bin in the array (smaller index → larger score) and
    the amount of space that would remain after placing the item.  The
    `1e6` multiplier ensures that the linear index dominates; the
    residual‐after‑packing acts as a fine‑tuning secondary objective that
    prefers tightly filled bins.  Bins that cannot accept the item receive a
    large negative value to guarantee they are never chosen.

    Parameters
    ----------
    item : float
        Size of the item to add.
    bins_remain_cap : np.ndarray
        Current remaining capacities of all bins.

    Returns
    -------
    np.ndarray
        Priority values per bin; higher values correspond to more preferable
        bins for the item.
    """
    # Flag if a bin can still hold the item
    can_fit = bins_remain_cap >= item

    # Composite priority: 
    #   * Index factor to enforce first‑fit order (lower indices get higher score)
    #   * Residual factor to prefer bins that leave minimal unused space after placement
    priorities = np.where(
        can_fit,
        -1_000_000 * np.arange(bins_remain_cap.size, dtype=float) - (bins_remain_cap - item),
        -1_000_000_000   # strongly penalize bins that can't fit
    )
    return priorities
```
