```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Exact‑Fit‑First priority for the online Bin Packing Problem.

    The function returns a priority score for each existing bin:
    * Bins that can accommodate the item exactly receive the highest possible
      priority (``np.inf``).
    * Among the other feasible bins, the one that leaves the smallest leftover
      after placement gets the highest priority (implemented as a negative
      leftover so that a smaller slack yields a larger score).
    * Infeasible bins receive ``-np.inf`` so they are never chosen.

    Args:
        item: Size of the incoming item.
        bins_remain_cap: 1‑D array of remaining capacities of the current bins.

    Returns:
        A NumPy array of the same shape as ``bins_remain_cap`` containing the
        priority of each bin (higher is better).
    """
    # Numerical tolerance for floating‑point equality checks
    eps = 1e-12

    # Initialise all priorities as infeasible
    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)

    # Determine which bins can at least hold the item
    feasible = bins_remain_cap + eps >= item

    # Exact‑fit mask (remaining capacity essentially equals item size)
    exact_fit = feasible & (np.abs(bins_remain_cap - item) <= eps)

    # Give exact‑fit bins the maximal priority
    priorities[exact_fit] = np.inf

    # For the remaining feasible bins, use a Best‑Fit metric:
    # smaller leftover ⇒ larger priority (negative leftover achieves this)
    other = feasible & ~exact_fit
    leftovers = bins_remain_cap[other] - item          # non‑negative by feasibility
    priorities[other] = -leftovers                     # closer to zero → higher score

    return priorities
```
