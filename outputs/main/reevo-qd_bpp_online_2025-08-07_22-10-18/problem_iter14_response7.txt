```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing (Version 2).

    For each currently open bin the function returns a priority score;
    higher scores indicate a more desirable bin for placing the incoming
    ``item``.  The scoring uses a smooth logistic function whose steepness
    adapts to the dispersion of feasible residual capacities, computed via
    the Median Absolute Deviation (MAD).  Infeasible bins receive ``-inf``.
    A deterministic tie‑breaker adds a tiny decreasing bias with the bin
    index, guaranteeing stable ordering when scores are equal.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the open bins.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``).
    """
    # ------------------------------------------------------------
    # 1. Normalise input
    # ------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.shape[0]

    if n_bins == 0:
        return np.empty(0, dtype=float)

    # ------------------------------------------------------------
    # 2. Compute residual capacities after (hypothetically) placing the item
    # ------------------------------------------------------------
    residual = caps - item
    feasible = residual >= 0  # mask of bins that can hold the item

    # Initialise all scores to -inf (infeasible)
    scores = np.full(n_bins, -np.inf, dtype=float)

    # If no bin can accommodate the item, return early
    if not np.any(feasible):
        return scores

    # ------------------------------------------------------------
    # 3. Estimate spread of feasible residuals using MAD
    # ------------------------------------------------------------
    feas_res = residual[feasible]                     # residuals of feasible bins
    median_res = np.median(feas_res)
    mad = np.median(np.abs(feas_res - median_res))
    # Convert MAD to an estimate of standard deviation for normal data
    spread = mad * 1.4826

    # Fallbacks if MAD yields zero spread
    if spread <= 0.0:
        std = np.std(feas_res)
        if std > 0.0:
            spread = std
        else:
            # Use range as a last resort; guarantee non‑zero
            rng = np.max(feas_res) - np.min(feas_res)
            spread = rng if rng > 0.0 else 1.0

    # ------------------------------------------------------------
    # 4. Adaptive logistic scoring
    # ------------------------------------------------------------
    base_steepness = 5.0               # tunable; larger → sharper transition
    slope = base_steepness / spread    # steeper when spread is small

    # Logistic function decreasing with residual:
    #   score = 1 / (1 + exp(slope * residual))
    # Clip exponent to avoid overflow/underflow
    exp_arg = np.clip(slope * feas_res, -700, 700)
    scores_feas = 1.0 / (1.0 + np.exp(exp_arg))

    # Populate scores for feasible bins
    scores[feasible] = scores_feas

    # ------------------------------------------------------------
    # 5. Deterministic tie‑breaker (tiny decreasing bias with index)
    # ------------------------------------------------------------
    epsilon = 1e-12
    tie_bias = -np.arange(n_bins, dtype=float) * epsilon
    # Add bias only to finite scores; keep -inf unchanged
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
