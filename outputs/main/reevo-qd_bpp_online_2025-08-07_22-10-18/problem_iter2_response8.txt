```python
import numpy as np

# ----------------------------------------------------------------------
# Global state for adaptive behavior (maintained across calls)
# ----------------------------------------------------------------------
_call_counter: int = 0          # Number of items processed so far
_total_item_size: float = 0.0   # Cumulative size of all processed items

# Exploration parameters (epsilon‑greedy)
_EPSILON0: float = 0.2          # Initial exploration probability
_MIN_EPSILON: float = 0.01      # Lower bound for exploration
_DECAY_RATE: float = 0.001      # Exponential decay rate of epsilon

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive deterministic priority for the online Bin Packing Problem.

    Scoring combines several desiderata:
      * **Deterministic best‑fit** – bins that leave the smallest leftover
        after placing the item receive higher scores.
      * **Item‑size distribution awareness** – bins whose leftover would be
        far larger than the average observed item size are penalised.
      * **Exploration** – an epsilon‑greedy component whose probability decays
        over time, allowing occasional random choices early on.
      * **Infeasibility handling** – bins that cannot accommodate the item are
        assigned -inf so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of all currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is better). Bins that cannot hold
        the item receive -np.inf.
    """
    global _call_counter, _total_item_size

    # ------------------------------------------------------------------
    # Update online statistics
    # ------------------------------------------------------------------
    _call_counter += 1
    _total_item_size += item
    avg_item_size = _total_item_size / _call_counter

    # ------------------------------------------------------------------
    # Compute dynamic epsilon (decays exponentially, never below _MIN_EPSILON)
    # ------------------------------------------------------------------
    epsilon = max(_MIN_EPSILON, _EPSILON0 * np.exp(-_DECAY_RATE * _call_counter))

    rng = np.random.default_rng()

    # ------------------------------------------------------------------
    # Exploration branch: choose a random feasible bin with probability epsilon
    # ------------------------------------------------------------------
    if rng.random() < epsilon:
        feasible = bins_remain_cap >= item
        random_scores = rng.random(bins_remain_cap.shape[0])
        return np.where(feasible, random_scores, -np.inf)

    # ------------------------------------------------------------------
    # Deterministic scoring branch
    # ------------------------------------------------------------------
    leftover = bins_remain_cap - item
    feasible = leftover >= 0

    # Avoid division by zero in the inverse‑leftover term
    eps = 1e-12

    # Base best‑fit score: larger when leftover is smaller
    base_score = np.where(feasible, 1.0 / (leftover + eps), -np.inf)

    # Distribution‑aware penalty:
    #   If the leftover is significantly larger than the average item size,
    #   we reduce the priority. This discourages leaving large gaps that are
    #   unlikely to be filled by typical future items.
    excess = np.maximum(0.0, leftover - avg_item_size)
    alpha = 0.5          # Penalty weight (tunable)
    penalty = alpha * excess

    # Final priority: high base score minus penalty
    priorities = np.where(feasible, base_score - penalty, -np.inf)

    return priorities
```
