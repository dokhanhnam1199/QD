```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher = more desirable). Shape matches
        `bins_remain_cap`.  Bins that cannot accommodate the item receive
        -inf and will never be selected.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    if caps.size == 0:
        return np.empty(0, dtype=float)

    # Residual capacity after placing the item in each bin.
    leftover = caps - item
    feasible = leftover >= 0

    # Base score: lower leftover gives higher score.
    base_score = np.where(feasible, -leftover, -np.inf)

    if np.any(feasible):
        # Use the largest capacity as a normalisation reference.
        bin_capacity = np.max(caps)
        if bin_capacity <= 0:
            bin_capacity = 1.0

        # Normalised leftover ratio (0 at perfect fit, <=1 otherwise).
        leftover_ratio = np.where(feasible, leftover / bin_capacity, np.nan)

        # Exponential near‑fit bonus: 1 for perfect fit, decays with residual.
        alpha = 5.0
        bonus = np.exp(-alpha * leftover_ratio)

        # Combined score.
        score = base_score + bonus
    else:
        score = base_score

    # Decaying exploration noise.
    if not hasattr(priority_v2, "_call_count"):
        priority_v2._call_count = 0
    priority_v2._call_count += 1
    epsilon0 = 0.01
    epsilon = epsilon0 / np.sqrt(priority_v2._call_count)
    noise = np.random.rand(caps.size) * epsilon
    score = np.where(feasible, score + noise, score)

    # Deterministic tie‑breaker: slight bias toward lower indices.
    tie_bias = -np.arange(caps.size) * 1e-12
    score = np.where(score > -np.inf, score + tie_bias, score)

    return score
```
