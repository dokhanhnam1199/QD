```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute a softmax‑based priority for placing an incoming item into existing bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin.  Bins that cannot accommodate the item
        receive a priority of 0.  The bin with the highest score will be
        chosen.  If no bin can fit the item, a zero vector is returned
        (the caller can then open a new bin).

    Notes
    -----
    The function uses a softmax of the negative waste (remaining capacity
    after placement).  A higher score indicates a tighter fit.  The
    temperature of the softmax is adapted based on how full the bins are,
    providing a form of adaptive exploration: the more the bins are
    filled, the higher the temperature and the more the distribution is
    flattened.  A small random noise is added to break deterministic ties.
    """
    rng = np.random.default_rng()

    waste = bins_remain_cap - item
    feasible = waste >= 0

    # No feasible bin → signal caller to open a new bin
    if not np.any(feasible):
        return np.zeros_like(bins_remain_cap, dtype=float)

    # ---- Adaptive exploration probability ----
    max_cap = np.max(bins_remain_cap)
    load_factor = 0.0 if max_cap == 0 else np.mean(bins_remain_cap) / max_cap
    epsilon = 0.1 * (1.0 - load_factor)  # explore more when bins are nearly full

    if rng.random() < epsilon:
        # Random exploration over feasible bins
        priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
        priorities[feasible] = rng.random(np.sum(feasible))
        return priorities

    # ---- Softmax scoring ----
    # Hyper‑parameters
    temperature_base = 0.3
    waste_exponent = 1.0
    # Adapt temperature based on load factor (higher when bins are full)
    min_temp = temperature_base
    max_temp = temperature_base * 5.0
    temperature = min_temp + (max_temp - min_temp) * (1.0 - load_factor)

    # Raw scores: negative waste (better fit → higher score)
    raw_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    raw_scores[feasible] = -np.power(waste[feasible], waste_exponent)

    # Tiny noise to break deterministic ties
    raw_scores += 1e-6 * rng.random(raw_scores.shape)

    # Numerically stable softmax
    max_raw = raw_scores[feasible].max()
    shifted = (raw_scores - max_raw) / temperature
    exp_vals = np.exp(shifted)               # exp(-inf) → 0 for infeasible bins
    total = exp_vals.sum()
    if total > 0:
        priorities = exp_vals / total
    else:
        priorities = np.zeros_like(raw_scores)

    return priorities
```
