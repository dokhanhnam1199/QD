```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic best‑fit priority for online Bin Packing.

    For each bin the function evaluates the remaining space that would be left
    after placing ``item``. Bins that can accommodate the item receive a priority
    equal to the negative of this leftover – a smaller leftover yields a larger
    priority. Infeasible bins are assigned ``-np.inf`` so they are never chosen.
    Ties are broken deterministically by preferring bins with lower indices.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``). The
        caller should select the bin with the highest priority.
    """
    # Ensure the capacities are a NumPy array of floats.
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Prospective leftover capacity after placing the item.
    leftover = caps - item

    # Feasibility mask: bins with non‑negative leftover can hold the item.
    feasible = leftover >= 0

    # Base priority: -leftover (smaller leftover → larger priority).
    # Infeasible bins receive -inf.
    priorities = np.where(feasible, -leftover, -np.inf)

    # Deterministic tie‑breaker: prefer lower‑index bins when priorities tie.
    if priorities.size:
        # Machine epsilon for the array's dtype (fallback to float64).
        eps = (np.finfo(priorities.dtype).eps
               if np.issubdtype(priorities.dtype, np.floating)
               else np.finfo(np.float64).eps)
        # Tiny offset proportional to bin index.
        tie_break = np.arange(priorities.size, dtype=priorities.dtype) * eps
        priorities = priorities - tie_break

    return priorities
```
