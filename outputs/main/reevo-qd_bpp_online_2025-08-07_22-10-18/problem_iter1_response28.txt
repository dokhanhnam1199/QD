```python
import numpy as np

def priority_v2(item: float,
                bins_remain_cap: np.ndarray,
                epsilon: float = 0.1,
                seed: int | None = None) -> np.ndarray:
    """
    Epsilon‑Greedy priority heuristic for the online Bin Packing Problem.
    
    The function returns a score array, one score per bin, where the
    bin with the largest score will be selected for packing the current
    item.
    
    With probability (1 - epsilon) the best‑fit rule is applied:
        * Bins that can accommodate the item are ranked by the
          *remaining* capacity after placement (smaller remaining
          capacity is better).
        * Bins that cannot fit the item receive a very negative score.
    
    With probability epsilon the algorithm performs exploration:
        * One of the feasible bins (that can accommodate the item)
          is chosen uniformly at random and given a neutral score.
        * All other bins receive a very negative score, ensuring that
          the random bin will be selected.
    
    Args:
        item:   Size of the current item to be packed.
        bins_remain_cap:  1‑D array of the remaining capacities of each bin.
        epsilon:  Exploration probability (default 0.1). Must be in [0, 1].
        seed:    Optional seed for the random number generator, for
                 reproducibility. If None, a non‑deterministic seed is used.
    
    Returns:
        A numpy array of float scores, same shape as `bins_remain_cap`,
        suitable for use with `np.argmax` to pick the bin.
    """
    # Ensure we are working with a float array.
    caps = np.asarray(bins_remain_cap, dtype=float)

    rng = np.random.default_rng(seed)
    feasible = caps >= item

    # Start with very low scores for all bins.
    priorities = np.full(caps.shape, -np.inf, dtype=float)

    if rng.random() < epsilon:  # Exploration
        feasible_idx = np.where(feasible)[0]
        if feasible_idx.size:
            chosen = rng.choice(feasible_idx)
            priorities[chosen] = 0.0
        # If no bin can accommodate the item, all scores stay at -inf.
    else:  # Exploitation (best‑fit)
        remaining_after = caps - item
        # Higher scores are better: the smaller the remaining space after
        # placing the item, the higher the priority.
        priorities[feasible] = -remaining_after[feasible]

    return priorities
```
