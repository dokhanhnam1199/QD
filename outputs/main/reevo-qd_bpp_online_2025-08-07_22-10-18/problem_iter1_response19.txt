```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Softmax‑Based Fit priority for online Bin Packing.

    For each bin we compute the amount of *wasted* space that would remain
    after inserting the item (if the item fits).  The priority is then an
    exponential (softmax) decay of this waste – bins that leave little or no
    waste get the highest scores.  A temperature parameter controls the
    greediness: lower values behave like a Best‑Fit heuristic, higher values
    produce a softer distribution (more exploration).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Array containing the remaining capacity of each existing bin.

    Returns
    -------
    np.ndarray
        Array of priority scores (summing to 1 over feasible bins).  Bins that
        cannot accommodate the item receive a priority of 0.
    a new bin will be opened when all priorities are zero.
    """
    # ---------------------- hyper‑parameters ----------------------
    temperature: float = 0.3          # <1 → greedier (best‑fit), >1 → softer
    waste_exponent: float = 1.0       # linear waste penalty (2.0 → quadratic)
    # ----------------------------------------------------------------

    # Compute how much space would remain if the item were placed.
    waste = bins_remain_cap - item            # positive = leftover space, negative = cannot fit
    feasible = waste >= 0                     # boolean mask of bins that can hold the item

    # Raw scores: negative (penalised) waste. Infeasible bins get -inf → zero after exp.
    raw_scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)
    raw_scores[feasible] = -np.power(waste[feasible], waste_exponent)

    # If no bin can accommodate the item, return a zero vector (caller may open a new bin).
    if not feasible.any():
        return np.zeros_like(bins_remain_cap, dtype=np.float64)

    # Numerically stable softmax:
    #   softmax(x) = exp((x - max(x)) / temperature) / sum(exp(...))
    max_raw = raw_scores[feasible].max()
    shifted = (raw_scores - max_raw) / temperature
    exp_vals = np.exp(shifted)               # exp(-inf) -> 0 for infeasible bins

    total = exp_vals.sum()
    if total > 0:
        priorities = exp_vals / total
    else:
        priorities = np.zeros_like(bins_remain_cap, dtype=np.float64)

    return priorities
```
