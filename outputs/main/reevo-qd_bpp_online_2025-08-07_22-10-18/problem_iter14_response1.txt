```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Simple adaptive priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (higher is more preferable).
        Infeasible bins receive -inf. Exact‑fit bins receive +inf.
    """
    # Ensure a NumPy array of floats.
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Residual capacity after placing the item.
    residual = bins_remain_cap - item

    # Infeasible bins (item does not fit).
    infeasible = residual < 0.0

    # Initialize priorities with -inf for infeasible bins.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Exact‑fit detection (within tolerance).
    atol = 1e-9
    exact_fit = np.isclose(residual, 0.0, atol=atol) & ~infeasible
    priorities[exact_fit] = np.inf  # highest possible priority.

    # Feasible but not exact‑fit bins.
    feasible = ~infeasible & ~exact_fit
    if np.any(feasible):
        # Residuals of feasible bins.
        feasible_res = residual[feasible]

        # Adaptive sigmoid steepness: inversely proportional to residual variance.
        std_res = np.std(feasible_res)
        eps = 1e-12
        std_res = std_res if std_res > eps else eps
        base_slope = 5.0          # tunable base steepness.
        slope = base_slope / std_res

        # Compute sigmoid score: tighter fit (smaller residual) → larger score.
        # score = 1 / (1 + exp(slope * residual))
        # Clip exponent to avoid overflow.
        exp_arg = np.clip(slope * residual[feasible], -700.0, 700.0)
        scores = 1.0 / (1.0 + np.exp(exp_arg))

        priorities[feasible] = scores

    # Deterministic tie‑breaker (tiny increment based on bin index).
    # Does not affect -inf or +inf values.
    idx = np.arange(bins_remain_cap.size, dtype=float)
    tie_break = idx * 1e-12
    priorities = np.where(np.isfinite(priorities), priorities + tie_break, priorities)

    return priorities
```
