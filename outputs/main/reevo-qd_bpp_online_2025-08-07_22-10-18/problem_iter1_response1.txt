```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Best‑Fit priority for online Bin Packing.

    For each bin the function evaluates the remaining space that would be left
    after placing ``item``.  Bins that can accommodate the item receive a
    priority proportional to the negative of this leftover – i.e. a smaller
    leftover yields a larger priority.  Bins that cannot fit the item are
    assigned ``-np.inf`` so they are never selected.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as ``bins_remain_cap``). The
        caller should select the bin with the highest priority.
    """
    # Compute the prospective leftover space after adding the item.
    leftover = bins_remain_cap - item

    # Feasibility mask: only bins with non‑negative leftover can hold the item.
    feasible = leftover >= 0

    # Base priority: -leftover (smaller leftover → larger priority).
    # Infeasible bins receive -inf.
    priorities = np.where(feasible, -leftover, -np.inf)

    # ----------------------------------------------------------------------
    # OPTIONAL tie‑breaker: prefer earlier bins (lower index) when priorities
    # are otherwise identical.  This adds a negligible offset that does not
    # alter the main ordering.
    # ----------------------------------------------------------------------
    if priorities.size:
        # Machine epsilon for the array's dtype (or float64 if integer).
        eps = np.finfo(priorities.dtype).eps if np.issubdtype(priorities.dtype, np.floating) else np.finfo(np.float64).eps
        tie_break = np.arange(priorities.size, dtype=priorities.dtype) * eps
        priorities = priorities - tie_break

    return priorities
```
