```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 0.1,
    boost: float = 10.0,
    rng: np.random.Generator | None = None,
) -> np.ndarray:
    """
    Compute priority scores for placing an incoming item into existing bins.

    The function implements an epsilon‑greedy strategy combined with an
    Exact‑Fit‑First (best‑fit) heuristic and random tie‑breaking.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacity of each open bin.
    epsilon : float, optional
        Exploration probability for epsilon‑greedy. With probability ``epsilon``
        a random feasible bin is favoured. Default is 0.1.
    boost : float, optional
        Additive bonus for bins that achieve an exact fit (remaining capacity
        ~0). Must be larger than the typical range of the base scores to
        guarantee precedence. Default is 10.0.
    rng : np.random.Generator, optional
        Random number generator. If ``None`` a new default generator is created.

    Returns
    -------
    np.ndarray
        Array of priority scores (same shape as ``bins_remain_cap``). Bins that
        cannot accommodate the item receive ``-np.inf``. The bin with the highest
        score should be selected.
    """
    if rng is None:
        rng = np.random.default_rng()

    # Feasibility mask: bins that can hold the item
    feasible_mask = bins_remain_cap >= item

    # If no bin can accommodate the item, return all -inf
    if not np.any(feasible_mask):
        return np.full(bins_remain_cap.shape, -np.inf, dtype=float)

    # Exploration phase: random scores for feasible bins
    if rng.random() < epsilon:
        random_scores = rng.random(bins_remain_cap.shape)
        random_scores[~feasible_mask] = -np.inf
        return random_scores

    # Exploitation phase: best‑fit with exact‑fit boost
    # Compute leftover capacity for feasible bins
    leftovers = bins_remain_cap[feasible_mask] - item

    # Base score prefers smaller leftover (best‑fit). Use negative leftover
    # so that larger scores correspond to tighter fits.
    base_score = -leftovers

    # Detect exact fits (within numerical tolerance)
    exact_fit_mask = np.isclose(leftovers, 0.0, atol=1e-9)

    # Apply boost to exact fits
    scores = base_score + boost * exact_fit_mask.astype(float)

    # Random tie‑breaking: add a tiny noise term to avoid deterministic ties
    tie_noise = 1e-6 * rng.random(scores.shape)
    scores += tie_noise

    # Assemble full priority array
    priorities = np.full(bins_remain_cap.shape, -np.inf, dtype=float)
    priorities[feasible_mask] = scores

    return priorities
```
