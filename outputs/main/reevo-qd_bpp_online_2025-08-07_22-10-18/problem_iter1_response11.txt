```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Best‑Fit priority for online Bin Packing.

    The function returns a high score for the bin that would leave the smallest
    remaining capacity after placing ``item`` (tightest fit). Bins that cannot
    accommodate the item receive ``-inf`` so they are never selected. An
    additional tiny random jitter breaks ties deterministically, and a huge
    bonus is granted to exact fits (zero leftover) to prioritize perfect
    fillings.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacity of each currently open bin.

    Returns
    -------
    np.ndarray
        Array of the same shape as ``bins_remain_cap`` containing the priority
        score for each bin.
    """
    # Remaining capacity if the item were placed in each bin
    leftover = bins_remain_cap - item

    # Feasibility mask: only bins with enough space are considered
    feasible = leftover >= 0

    # Initialise all priorities as -inf (infeasible bins)
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)

    # Base priority: tighter fits (smaller leftover) get larger scores.
    # Since we want to maximise priority, we use the negative leftover.
    priorities[feasible] = -leftover[feasible]

    # Give an overwhelming boost to bins that would be exactly filled.
    exact_fit = feasible & np.isclose(leftover, 0.0, atol=1e-12)
    priorities[exact_fit] = 1e6

    # Add a tiny random jitter to the remaining feasible bins to break ties.
    non_exact = feasible & ~exact_fit
    if np.any(non_exact):
        jitter = np.random.rand(np.count_nonzero(non_exact)) * 1e-9
        priorities[non_exact] += jitter

    return priorities
```
