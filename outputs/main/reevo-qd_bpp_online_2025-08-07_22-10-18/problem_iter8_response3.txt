```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    rng: Optional[np.random.Generator] = None,
    base_eps: float = 0.10,
    base_k: float = 12.0,
    beta: float = 0.5,
    delta: float = 0.30,
    boost: float = 5.0,
    exact_fit_tol: float = 1e-9,
) -> np.ndarray:
    """
    Adaptive priority scoring for the online bin packing problem.

    The function combines an epsilon‑greedy exploration scheme with a smooth
    sigmoid fill‑ratio scoring, penalises waste, rewards already‑utilised bins
    and gives a small boost to exact‑fit placements.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array with the remaining capacities of the currently open bins.
    rng : np.random.Generator, optional
        Random generator for exploration decisions and jitter.
        If ``None`` a default generator is created.
    base_eps : float, optional
        Base exploration probability (default 0.10).
    base_k : float, optional
        Base steepness of the sigmoid used for fill‑ratio scoring (default 12.0).
    beta : float, optional
        Weight of the waste‑penalty term (default 0.5).
    delta : float, optional
        Weight of the utilization‑reward term (default 0.30).
    boost : float, optional
        Additive boost given to bins that achieve an (almost) exact fit
        (default 5.0).
    exact_fit_tol : float, optional
        Numerical tolerance for detecting an exact fit (default 1e-9).

    Returns
    -------
    np.ndarray
        Priority score for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf``.  The caller should select the bin
        with the highest score; if all scores are ``-np.inf`` a new bin must be
        opened.  An empty array is returned when ``bins_remain_cap`` is empty.
    """
    # ------------------------------------------------------------------
    # Input preparation
    # ------------------------------------------------------------------
    rem = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = rem.size

    # No open bins → caller must open a new bin
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask: bins that can accommodate the item
    fit_mask = rem >= item

    # If no bin can hold the item, return -inf for all bins
    if not np.any(fit_mask):
        return np.full(n_bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # Random number generator
    # ------------------------------------------------------------------
    if rng is None:
        rng = np.random.default_rng()

    # ------------------------------------------------------------------
    # Adaptive epsilon‑greedy exploration probability
    # ------------------------------------------------------------------
    # Fraction of bins that can fit the item
    fit_frac = np.count_nonzero(fit_mask) / n_bins

    # Estimate bin capacity (all bins share the same fixed capacity)
    # Using the maximum remaining capacity is safe because no bin can have
    # more remaining capacity than its total capacity.
    bin_capacity = np.max(rem)
    if bin_capacity <= 0.0:
        # Defensive fallback – should not happen for valid data
        bin_capacity = item

    # Utilisation of each bin (higher = more filled)
    utilization = 1.0 - rem / bin_capacity
    avg_util = np.mean(utilization)

    # Exploration probability grows when few bins fit or utilization is low
    epsilon = base_eps * (1.0 - fit_frac) * (1.0 + (1.0 - avg_util))
    epsilon = np.clip(epsilon, 0.0, 1.0)

    # Exploration: random feasible scores
    if rng.random() < epsilon:
        scores = rng.random(n_bins)
        scores[~fit_mask] = -np.inf
        return scores

    # ------------------------------------------------------------------
    # Deterministic exploitation scoring
    # ------------------------------------------------------------------
    # Leftover capacity after placing the item (only defined for feasible bins)
    leftover = np.empty_like(rem)
    leftover.fill(np.nan)
    leftover[fit_mask] = rem[fit_mask] - item

    # ensure leftover for infeasible bins stays NaN (won't be used)

    # Fill ratio: portion of the bin's remaining capacity taken by the item
    fill_ratio = np.empty_like(rem)
    fill_ratio.fill(np.nan)
    fill_ratio[fit_mask] = item / rem[fit_mask]  # in (0, 1]

    # Waste fraction after placement (same as leftover / original remaining)
    waste_frac = np.empty_like(rem)
    waste_frac.fill(np.nan)
    waste_frac[fit_mask] = leftover[fit_mask] / rem[fit_mask]  # = 1 - fill_ratio

    # Sigmoid scoring that favours fill ratios > 0.5.
    # Steepness grows with average utilisation (more aggressive when bins are tight).
    k = base_k * (1.0 + avg_util)          # k ∈ [base_k, 2*base_k]
    arg = -k * (fill_ratio[fit_mask] - 0.5)   # negative for fill>0.5 → larger sigmoid
    # Clip to avoid overflow in exp
    arg = np.clip(arg, -700.0, 700.0)
    sigmoid = 1.0 / (1.0 + np.exp(arg))

    # Exact‑fit boost (detect near‑zero leftover)
    exact_fit = np.isclose(leftover[fit_mask], 0.0, atol=exact_fit_tol)
    exact_boost = boost * exact_fit.astype(float)

    # Combine components
    priority = np.full(n_bins, -np.inf, dtype=float)
    priority[fit_mask] = (
        sigmoid                                 # base sigmoid (higher = better)
        - beta * waste_frac[fit_mask]           # penalise waste
        + delta * utilization[fit_mask]         # reward already used bins
        + exact_boost                           # reward exact fits
    )

    # Tiny random jitter to break ties reproducibly
    jitter = rng.random(n_bins) * 1e-9
    priority[fit_mask] += jitter[fit_mask]

    return priority
```
