```python
import numpy as np

# Global state for adaptive behavior (maintained across calls)
_call_counter: int = 0          # Number of items processed so far
_total_item_size: float = 0.0   # Cumulative size of all processed items

# Adaptive parameters
_ALPHA0: float = 0.3            # Base penalty weight for large leftovers
_ALPHA_DECAY: float = 500.0     # Controls how fast the penalty weight grows
_K0: float = 8.0                # Base steepness of the sigmoid
_K_DECAY: float = 500.0         # Controls how fast the sigmoid steepness grows


def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Compute deterministic priority scores for each bin using an adaptive
    sigmoid fit strategy with a penalty for large leftovers.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        Remaining capacities of each currently open bin.

    Returns
    -------
    np.ndarray
        Array of priority scores for each bin.  Bins that cannot accommodate
        the item receive -np.inf and are never selected.
    """
    global _call_counter, _total_item_size

    # ------------------------------------------------------------------
    # Update online statistics
    # ------------------------------------------------------------------
    _call_counter += 1
    _total_item_size += item
    avg_item_size = _total_item_size / _call_counter

    # Ensure numeric types for accurate arithmetic
    rem = bins_remain_cap.astype(float, copy=False)

    # Mask of bins that can actually fit the item
    fit_mask = rem >= item

    # Initialize all priorities with negative infinity (bins that cannot fit)
    priorities = np.full_like(rem, -np.inf, dtype=float)

    if not np.any(fit_mask):
        return priorities  # no bin can fit the item

    # Compute leftover after placing the item
    leftover = rem - item

    # Fit ratio after placing the item (fraction of bin that is filled)
    fit_ratio = 1.0 - leftover / rem

    # Adaptive sigmoid parameters (increase over time)
    k = _K0 * (_call_counter / (_call_counter + _K_DECAY))
    alpha = _ALPHA0 * (_call_counter / (_call_counter + _ALPHA_DECAY))

    # Logistic (sigmoid) transformation to obtain a smooth prioritization
    # Good fit (fit_ratio close to 1) → score close to 1
    # Poor fit (fit_ratio close to 0)   → score close to 0
    sigmoid = 1.0 / (1.0 + np.exp(-k * (fit_ratio - 0.5)))

    # Penalty for large leftover relative to bin capacity
    penalty = alpha * (leftover / rem)

    # Final priority: high sigmoid minus penalty
    scores = sigmoid - penalty

    # Assign scores to the corresponding bins
    priorities[fit_mask] = scores[fit_mask]

    return priorities
```
