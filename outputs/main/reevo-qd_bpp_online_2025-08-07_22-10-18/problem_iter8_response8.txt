```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority scoring for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority score for each bin (higher is better). Infeasible bins receive
        ``-np.inf``. If no bins are open, an empty array is returned.
    """
    # ------------------------------------------------------------------
    # Normalise input
    # ------------------------------------------------------------------
    caps = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = caps.size

    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask: bins that can accommodate the item
    fit_mask = caps >= item

    # If nothing fits, force creation of a new bin
    if not np.any(fit_mask):
        return np.full(n_bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # Estimate fixed bin capacity and utilisation
    # ------------------------------------------------------------------
    # All bins share the same (unknown) capacity; infer it from the max
    bin_capacity = caps.max()
    if bin_capacity <= 0.0:               # safety fallback
        bin_capacity = item

    # Utilisation = fraction of capacity already used (higher = more filled)
    utilisation = 1.0 - caps / bin_capacity
    avg_util = utilisation.mean()

    # Fraction of bins that can fit the item
    fit_frac = np.mean(fit_mask)

    # ------------------------------------------------------------------
    # Exploration (epsilon‑greedy) scaled by fit fraction and utilisation
    # ------------------------------------------------------------------
    base_eps = 0.10                       # baseline exploration probability
    epsilon = base_eps * (1.0 - fit_frac) * (1.0 + (1.0 - avg_util))

    rng = np.random.default_rng()
    if rng.random() < epsilon:
        # Random scores for feasible bins; infeasible remain -inf
        scores = rng.random(n_bins)
        scores[~fit_mask] = -np.inf
        return scores

    # ------------------------------------------------------------------
    # Deterministic exploitation scoring
    # ------------------------------------------------------------------
    # Fill ratio: proportion of the bin's remaining capacity taken by the item
    fill_ratio = np.empty(n_bins, dtype=float)
    fill_ratio.fill(np.nan)
    fill_ratio[fit_mask] = item / caps[fit_mask]

    # Waste fraction after placement (1 - fill_ratio)
    waste_frac = np.empty(n_bins, dtype=float)
    waste_frac.fill(np.nan)
    waste_frac[fit_mask] = 1.0 - fill_ratio[fit_mask]

    # Sigmoid that favours fill ratios > 0.  Steepness grows with avg utilisation.
    base_k = 12.0
    k = base_k * (1.0 + avg_util)          # more loaded bins → sharper sigmoid
    arg = -k * (fill_ratio[fit_mask] - 0.5)   # negative for fill>0.5 → larger σ
    arg = np.clip(arg, -700.0, 700.0)         # protect against overflow
    sigmoid = 1.0 / (1.0 + np.exp(arg))

    # ------------------------------------------------------------------
    # Combine components
    # ------------------------------------------------------------------
    beta = 0.5   # weight of waste penalty
    delta = 0.30  # weight of utilisation reward

    priority = np.full(n_bins, -np.inf, dtype=float)
    priority[fit_mask] = (
        sigmoid
        - beta * waste_frac[fit_mask]
        + delta * utilisation[fit_mask]
    )

    # Tiny random jitter to break ties reproducibly
    jitter = rng.random(n_bins) * 1e-9
    priority[fit_mask] += jitter[fit_mask]

    return priority
```
