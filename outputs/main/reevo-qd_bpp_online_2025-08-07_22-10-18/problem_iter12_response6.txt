```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Deterministic best‑fit priority for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores for each bin. Bins that cannot accommodate the item
        receive a priority of -np.inf.  The bin with the highest score will
        be selected for placement.
    """
    # Ensure NumPy array
    bins = np.asarray(bins_remain_cap, dtype=float)
    n_bins = bins.size
    if n_bins == 0:
        return np.empty(0, dtype=float)

    # Base priority array filled with -inf for infeasible bins
    priorities = np.full(n_bins, -np.inf, dtype=float)

    # Mask of bins that can hold the item
    fit_mask = bins >= item
    if not np.any(fit_mask):
        # No bin can accommodate the item
        return priorities

    # Compute leftover capacity after placing the item
    leftovers = bins[fit_mask] - item

    # Base score: prefer bins with the smallest leftover (best‑fit)
    # Use negative leftover so larger score means better fit
    base_scores = -leftovers

    # Boost exact fits to guarantee they win ties
    exact_fit_mask = np.isclose(leftovers, 0.0, atol=1e-9)
    BOOST = 1e6  # sufficiently large to dominate other scores
    base_scores[exact_fit_mask] += BOOST

    # Optional tiny deterministic tie‑breaker (not strictly necessary)
    tie_breaker = -np.arange(np.sum(fit_mask)) * 1e-12
    base_scores += tie_breaker

    # Place computed scores back into the priority array
    priorities[fit_mask] = base_scores

    return priorities
```
