```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Return priority scores for placing an incoming item into existing bins
    based on the Exact‑Fit‑First heuristic.

    Parameters
    ----------
    item : float
        Size of the new item that needs to be packed.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for all currently open bins.

    Returns
    -------
    np.ndarray
        Same shape as *bins_remain_cap*; each entry is the priority score
        for placing *item* into the corresponding bin.  The bin with the
        maximum score will be selected by the scheduler.
    """
    # Initialise with a very low score to effectively drop bins that
    # cannot accommodate the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Mask for bins that can hold the item
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        # No bin can contain the item – all scores remain -inf
        return priorities

    # Space that would be left after the placement
    leftovers = bins_remain_cap[fit_mask] - item

    # Detect bins that would result in an exact fit
    exact_mask = np.isclose(leftovers, 0.0, atol=1e-9)

    # Base score prefers smaller leftover (best‑fit principle):
    # larger (less negative) values correspond to better fit.
    base_score = -leftovers
    # Boost the score for exact fits so they outrank all non‑exact ones.
    boost = 10.0  # arbitrary large constant

    # Compute final scores
    priorities[fit_mask] = base_score + (exact_mask * boost)

    return priorities
```
