```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Smooth, scale‑aware priority scoring for online bin packing.

    Higher scores are assigned to bins that tightly fit the incoming item.
    The steepness of the exponential decay is calibrated from the spread
    of feasible residual capacities, making the function adaptive to
    different instance scales. Infeasible bins receive -inf. A tiny
    index‑based bias breaks ties in favor of lower‑indexed bins.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher = more desirable) for each bin,
        same shape as ``bins_remain_cap``.
    """
    # Convert to NumPy float array.
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.shape[0]

    # Empty bin list -> nothing to be scored.
    if n_bins == 0:
        return np.array([], dtype=float)

    # Residual capacity after placing the item.
    residual = caps - item

    # Feasibility mask (bins that can accommodate the item).
    feasible = residual >= 0

    # Initialise scores with -inf for infeasible bins.
    scores = np.full_like(caps, -np.inf, dtype=float)

    # If no bin can accommodate the item, return all -inf.
    if not np.any(feasible):
        return scores

    # Residuals of feasible bins.
    feasible_res = residual[feasible]

    # ---- Robust spread estimation ----------------------------------------
    # Median Absolute Deviation (MAD) as a robust scale estimator.
    median_res = np.median(feasible_res)
    mad = np.median(np.abs(feasible_res - median_res))

    if mad > 0:
        spread = mad
    else:
        # Fall back to standard deviation if MAD is zero.
        std = np.std(feasible_res)
        if std > 0:
            spread = std
        else:
            # Fall back to range, and finally to 1.0 to avoid division by zero.
            rng = feasible_res = feasible_res.max() - feasible_res.min()
            spread = rng if rng > 0 else 1.0

    # Base steepness factor (tunable). Larger spread → softer decay.
    base_steepness = 5.0
    slope = base_steepness / spread

    # ---- Smooth exponential scoring ----------------------------------------
    # Exponential of the negative residual: tighter fits yield larger scores.
    # Clip exponent to avoid overflow/underflow.
    exp_arg = -slope * residual
    exp_arg = np.clip(exp_arg, -700, 700)  # np.exp over/underflow guard
    raw_scores = np.exp(exp_arg)

    # Assign scores to feasible bins.
    scores[feasible] = raw_scores[feasible]

    # ---- Tie‑breaking bias -------------------------------------------------
    # Tiny bias that favours lower‑indexed bins when scores are equal.
    epsilon = 1e-12
    tie_bias = -np.arange(n_bins, dtype=float) * epsilon
    scores = np.where(scores > -np.inf, scores + tie_bias, scores)

    return scores
```
