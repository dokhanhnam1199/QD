```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Simple deterministic priority for online bin packing.

    For each bin, the priority is based on how tightly the item would fit.
    It uses the remaining capacity after placing the item, normalised by the
    bin's current capacity. The priority is higher for smaller waste.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher = more desirable). Shape matches
        `bins_remain_cap`.  Infeasible bins receive ``-np.inf``.
    """
    # Ensure a float array
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Handle empty input
    if caps.size == 0:
        return np.array([], dtype=float)

    # Residual capacity if the item were placed in each bin
    residual = caps - item

    # Feasibility mask
    feasible = residual >= 0

    # Initialise with -inf for infeasible bins
    scores = np.full_like(caps, -np.inf, dtype=float)

    # Compute priority only for feasible bins:
    # 1 - residual / cap  -> 1 for a perfect fit (residual=0)
    #                           0 for an almost empty bin after placing item
    # This keeps priorities in [0, 1].
    # For very small caps that could be zero (rare), use a safe fallback.
    safe_caps = np.where(caps > 0, caps, 1.0)
    scores[feasible] = 1.0 - residual[feasible] / safe_caps[feasible]

    # Deterministic tie‑breaker: slight bias towards lower indices
    # to ensure stable ordering when priorities are equal.
    tie_bias = -1e-12 * np.arange(caps.size)
    scores += tie_bias

    return scores
```
