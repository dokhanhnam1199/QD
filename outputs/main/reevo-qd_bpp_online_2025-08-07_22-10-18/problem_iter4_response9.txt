```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive, exploration‑aware priority scoring for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= bin capacity).
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of currently open bins.

    Returns
    -------
    np.ndarray
        Priority score for each bin (same shape as ``bins_remain_cap``).
        Infeasible bins receive ``-np.inf``.  The bin with the highest
        score should be selected for the item.  If there are no open bins,
        an empty array is returned (caller should open a new bin).
    """
    # ------------------------------------------------------------------
    # Pre‑process input
    # ------------------------------------------------------------------
    rem = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = rem.size

    # No open bins – caller must create a new one
    if n_bins == 0:
        return np.array([], dtype=float)

    # Feasibility mask: bins that can accommodate the item
    fit_mask = rem >= item

    # If nothing fits, return -inf for all bins (force new bin creation)
    if not np.any(fit_mask):
        return np.full(n_bins, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # Adaptive epsilon‑greedy exploration
    # ------------------------------------------------------------------
    base_eps = 0.10                     # baseline exploration prob.
    fit_frac = np.count_nonzero(fit_mask) / n_bins

    # Estimate bin capacity (all bins have the same fixed capacity)
    bin_capacity = np.max(rem)
    if bin_capacity <= 0.0:
        bin_capacity = item   # fallback, should not happen for valid data

    # Current utilization of each bin (higher = more filled)
    utilization = 1.0 - rem / bin_capacity
    avg_util = np.mean(utilization)

    # Exploration probability rises when few bins fit or utilization is low
    epsilon = base_eps * (1.0 - fit_frac) * (1.0 + (1.0 - avg_util))

    rng = np.random.default_rng()
    if rng.random() < epsilon:
        # Purely random scores for feasible bins, -inf otherwise
        scores = rng.random(n_bins)
        scores[~fit_mask] = -np.inf
        return scores

    # ------------------------------------------------------------------
    # Deterministic scoring for exploitation
    # ------------------------------------------------------------------
    # Leftover capacity after placing the item (only for feasible bins)
    leftover = np.empty_like(rem)
    leftover.fill(np.nan)
    leftover[fit_mask] = rem[fit_mask] - item

    # Fill ratio: fraction of a bin's remaining capacity that the item occupies
    fill_ratio = np.empty_like(rem)
    fill_ratio.fill(np.nan)
    fill_ratio[fit_mask] = item / rem[fit_mask]          # in (0, 1]

    # Waste fraction after placement (same as leftover / original remaining)
    waste_frac = np.empty_like(rem)
    waste_frac.fill(np.nan)
    waste_frac[fit_mask] = leftover[fit_mask] / rem[fit_mask]   # = 1 - fill_ratio

    # Sigmoid scoring that favours fill ratios > 0.5.
    # Steepness grows with average utilization (more aggressive when bins are tight).
    base_k = 12.0
    k = base_k * (1.0 + avg_util)          # k ∈ [base_k, 2*base_k]

    # Compute sigmoid: σ(x) = 1 / (1 + exp(-k*(x - 0.5)))
    arg = -k * (fill_ratio[fit_mask] - 0.5)   # negative for fill>0.5 → large σ
    # Clip to avoid overflow in exp
    arg = np.clip(arg, -700.0, 700.0)
    sigmoid = 1.0 / (1.0 + np.exp(arg))

    # ------------------------------------------------------------------
    # Combine components into a single priority value
    # ------------------------------------------------------------------
    # Weight parameters (tunable)
    beta = 0.5      # waste penalty weight
    delta = 0.30    # utilization reward weight

    priority = np.full(n_bins, -np.inf, dtype=float)

    # Base score: sigmoid (higher for larger fill ratios)
    # Penalise waste and reward already‑used bins (higher utilization)
    priority[fit_mask] = (
        sigmoid
        - beta * waste_frac[fit_mask]
        + delta * utilization[fit_mask]
    )

    # Tiny random jitter to break ties in a reproducible way
    jitter = rng.random(n_bins) * 1e-9
    priority[fit_mask] += jitter[fit_mask]

    return priority
```
