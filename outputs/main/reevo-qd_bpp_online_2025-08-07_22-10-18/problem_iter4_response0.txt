```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    For a given item size and the remaining capacities of the bins, this
    function returns a score for each bin. Higher scores indicate bins that
    are more desirable for placing the item.

    The scoring combines:
      * a sigmoid of the fill ratio (item / remaining capacity) to favour
        bins that will become tightly packed after the item is placed,
      * an adaptive steepness parameter that grows with the relative size
        of the item, and
      * a weighting by the relative item size so that larger items receive
        proportionally higher scores.

    Bins that cannot accommodate the item receive ``-np.inf`` priority.

    Parameters
    ----------
    item : float
        Size of the item to be packed.
    bins_remain_cap : np.ndarray
        1‑D array containing the remaining capacity of each bin.

    Returns
    -------
    np.ndarray
        Array of priority scores, one per bin.
    """
    # Ensure we are working with a float array
    rem = np.asarray(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    fit_mask = rem >= item

    # Initialise priorities with -inf for bins that cannot fit
    priorities = np.full_like(rem, -np.inf, dtype=float)

    # Early exit if no bin can accommodate the item
    if not np.any(fit_mask):
        return priorities

    # Approximate original bin capacity as the maximum remaining capacity.
    # Works for homogeneous bins where all bins have the same total capacity.
    max_cap = np.max(rem) if np.max(rem) > 0 else 1.0

    # Relative size of the item (clamped to [0,1] to avoid >1 if max_cap is underestimated)
    rel_item_size = np.clip(item / max_cap, 0.0, 1.0)

    # Fill ratio: fraction of the current remaining capacity that will be used by the item.
    # Range: (0, 1].
    fill_ratio = item / rem[fit_mask]

    # Adaptive sigmoid steepness: larger items get a steeper curve,
    # encouraging tighter fits.
    k_base = 12.0
    # Scale k in the interval [k_base*0.5, k_base*1.5]
    k = k_base * (0.0 + 0.5 + rel_item_size)

    # Center the sigmoid at fill_ratio = 0.5 (mid‑fill). Clip the exponent to avoid overflow.
    exponent = -k * (fill_ratio - 0.5)
    exponent = np.clip(exponent, -50, 50)
    sigmoid = 1.0 / (1.0 + np.exp(exponent))

    # Weight the sigmoid by the relative item size; larger items get higher absolute priority.
    weight = rel_item_size + 1e-8  # epsilon prevents zero weight

    priorities[fit_mask] = sigmoid * weight

    return priorities
```
