```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Priority scores for each bin using an Almost‑Full‑Fit (AFF) heuristic.

    The AFF heuristic strongly prefers bins that will become *almost full*
    after placing the incoming item.  A bin is considered "almost full"
    when the leftover capacity after insertion is below a small threshold.
    Among all feasible bins the priority also grows when the resulting slack
    is smaller, i.e., we still emulate a Best‑Fit behavior when no bin is
    almost full.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities for all currently open bins.

    Returns
    -------
    np.ndarray
        Priority array of the same shape as ``bins_remain_cap``. Infeasible
        bins (those that cannot accommodate the item) receive ``-np.inf`` so
        they are never selected.
    """
    # Ensure a floating point view
    bins_remain_cap = np.asarray(bins_remain_cap, dtype=float)

    # Slack that would remain after placing the item
    slack = bins_remain_cap - item

    # Feasibility mask
    feasible = slack >= 0

    # Initialise priorities with -inf for infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # ---------- Core Almost‑Full‑Fit scoring ----------
    ----------
    # Base score: -slack (larger when slack is smaller)
    base_score = -slack[feasible]

    # Threshold for “almost full” (absolute, assuming unit bin capacity)
    ALMOST_FULL_THRESHOLD = 0.05  # 5 % of a unit‑capacity bin

    # Large bonus for bins that become almost full after insertion
    BONUS = 10.0

    # Apply the bonus only when the post‑placement slack is within the threshold
    bonus = np.where(slack[feasible] <= ALMOST_FULL_THRESHOLD, BONUS, 0.0)

    # Final priority for feasible bins = base_score + bonus
    priorities[feasible] = base_score + bonus

    return priorities
```
