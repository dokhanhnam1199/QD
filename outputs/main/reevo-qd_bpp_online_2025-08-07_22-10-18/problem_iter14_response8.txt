```python
import numpy as np
from typing import Optional


def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    *,
    bin_capacity: Optional[float] = None,
    rng: Optional[np.random.Generator] = None,
    base_eps: float = 0.10,
    beta: float = 0.5,
    delta: float = 0.30,
    gamma: float = 0.20,
    alpha: float = 50.0,
    base_k: float = 12.0,
    jitter_scale: float = 1e-9,
) -> np.ndarray:
    """
    Adaptive, smooth priority scoring for the online Bin Packing Problem (BPP).

    The function returns a priority score for each currently open bin.
    Bins that cannot accommodate the incoming ``item`` receive ``-np.inf``.
    The caller should select the bin with the highest score; if all scores are
    ``-inf`` a new bin must be opened.

    Parameters
    ----------
    item : float
        Size of the incoming item (0 < item <= ``bin_capacity``).
    bins_remain_cap : np.ndarray
        1‑D array of the remaining capacities of the currently open bins.
    bin_capacity : float, optional
        Fixed capacity of each bin. If ``None`` the maximum value in
        ``bins_remain_cap`` is used as a proxy (reasonable when at least one
        bin is empty or nearly empty).
    rng : np.random.Generator, optional
        Random number generator for stochastic components. If ``None`` a
        default generator is created.
    base_eps : float, optional
        Baseline exploration probability (default 0.10).
    beta : float, optional
        Weight for waste‑penalty term (default 0.5).
    delta : float, optional
        Weight for utilization‑reward term (default 0.30).
    gamma : float, optional
        Weight for exact‑fit boost (exponential term, default 0.20).
    alpha : float, optional
        Sharpness of the exact‑fit boost (larger → stronger near‑zero boost,
        default 50.0).
    base_k : float, optional
        Base steepness for the sigmoid fill‑ratio term (default 12.0).
    jitter_scale : float, optional
        Scale of random jitter added to break ties (default 1e-9).

    Returns
    -------
    np.ndarray
        Priority score for each bin (same shape as ``bins_remain_cap``).
    """
    # ------------------------------------------------------------------
    # Basic sanitisation and early exits
    # ------------------------------------------------------------------
    rem = np.asarray(bins_remain_cap, dtype=float).ravel()
    n_bins = rem.size

    if n_bins == 0:
        # No open bins – caller must open a new one
        return np.array([], dtype=float)

    if rng is None:
        rng = np.random.default_rng()

    # Infer bin capacity if not supplied (fallback to max remaining capacity)
    if bin_capacity is None:
        bin_capacity = float(np.max(rem))
    if bin_capacity <= 0.0:
        raise ValueError("Bin capacity must be positive.")

    # ------------------------------------------------------------------
    # Feasibility mask
    # ------------------------------------------------------------------
    feasible = rem >= item
    if not np.any(feasible):
        # Nothing fits – force new bin creation by returning all -inf
        return np.full_like(rem, -np.inf, dtype=float)

    # ------------------------------------------------------------------
    # Adaptive epsilon‑greedy exploration
    # ------------------------------------------------------------------
    fit_frac = feasible.sum() / n_bins                     # proportion of bins that can hold the item
    utilization = 1.0 - rem / bin_capacity                  # current fill level of each bin
    avg_util = utilization.mean()                          # overall utilisation

    # Exploration probability grows when few bins fit or utilisation is low
    epsilon = base_eps * (1.0 - fit_frac) * (1.0 + (1.0 - avg_util))
    epsilon = min(epsilon, 0.5)  # sanity cap

    if rng.random() < epsilon:
        # Purely random scores for feasible bins, -inf otherwise
        scores = rng.random(n_bins)
        scores[~fe = feasible] = -np.inf
        return scores

    # ------------------------------------------------------------------
    # Deterministic (exploitation) scoring
    # ------------------------------------------------------------------
    # Fill ratio: how much of the *remaining* capacity the item occupies
    fill_ratio = np.empty_like(rem)
    fill_ratio.fill(np.nan)
    fill_ratio[feasible] = item / rem[feasible]               # in (0, 1]

    # Leftover capacity after placing the item
    leftover = np.empty_like(rem)
    leftover.fill(np.nan)
    leftover[feasible] = rem[feasible] - item

    # Waste fraction: portion of the *total* bin capacity that would be left unused
    waste_frac = np.empty_like(rem)
    waste_frac.fill(np.nan)
    waste_frac[feasible] = leftover[feasible] / bin_capacity  # = 1 - (item + used)/capacity

    # Sigmoid term favouring fill ratios > 0.5; steepness adapts to avg utilisation
    k = base_k * (1.0 + avg_util)  # higher utilisation → steeper sigmoid
    arg = -k * (fill_ratio[feasible] - 0.5)  # negative for fill>0.5 → larger σ
    # Clip to avoid overflow in exp
    arg = np.clip(arg, -700.0, 700.0)
    sigmoid = 1.0 / (1.0 + np.exp(arg))

    # Exact‑fit boost: exponential decay with leftover (stronger when leftover≈0)
    exact_fit = gamma * np.exp(-alpha * leftover[feasible])

    # ------------------------------------------------------------------
    # Combine components
    # ------------------------------------------------------------------
    priority = np.full_like(rem, -np.inf, dtype=float)

    # Core score: sigmoid – waste penalty + utilisation reward + exact‑fit boost
    priority[feasible] = (
        sigmoid
        - beta * waste_frac[feasible]
        + delta * utilization[feasible]
        + exact_fit
    )

    # Tiny random jitter to break ties deterministically yet reproducibly
    jitter = rng.random(n_bins) * jitter_scale
    priority[feasible] += jitter[feasible]

    return priority
```
