```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, base_steepness: float = 5.0) -> np.ndarray:
    """
    Adaptive sigmoid priority for online bin packing (no global state).

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.
    base_steepness : float, optional
        Base factor controlling the sigmoid slope; larger values make the
        1/(1+exp) curve steeper. Default is 5.0.

    Returns
    -------
    np.ndarray
        Priority scores for each bin (same shape as `bins_remain_cap`).
        Higher values indicate more desirable bins; infeasible bins are
        penalised with -inf. A tiny deterministic bias favours lower‑index
        bins when scores tie.
    """
    # Ensure a NumPy float array.
    caps = np.asarray(bins_remain_cap, dtype=float)
    if caps.size == 0:
        return np.array([], dtype=float)

    # Residual capacity after placing the item.
    residual = caps - item

    # Feasibility mask: bins that can accommodate the item.
    feasible = residual >= 0

    # Initialise priorities with -inf for infeasible bins.
    priorities = np.full_like(caps, -np.inf, dtype=float)

    if not np.any(feasible):
        return priorities  # no bin can fit the item

    # Residuals of feasible bins.
    feasible_res = residual[feasible]

    # Estimate spread of feasible residuals using standard deviation.
    std = np.std(feasible_res)
    if std <= 0.0:
        # Fall back to range if variance is zero.
        spread = np.max(feasible_res) - np.min(feasible_res)
        std = spread if spread > 0.0 else 1.0

    # Adaptive sigmoid slope: tighter spread → steeper sigmoid.
    slope = base_steepness / std

    # Sigmoid of (negative) residual: tighter fit → larger score.
    # Clip exponent to avoid overflow/underflow.
    exp_arg = np.clip(slope * residual, -700, 700)
    raw_scores = 1.0 / (1.0 + np.exp(exp_arg))

    # Assign scores only to feasible bins.
    priorities[feasible] = raw_scores[feasible]

    # Deterministic tie‑breaker: tiny bias favouring lower indices.
    tie_bias = -np.arange(caps.shape[0]) * 1e-12
    priorities = np.where(priorities > -np.inf, priorities + tie_bias, priorities)

    return priorities
```
