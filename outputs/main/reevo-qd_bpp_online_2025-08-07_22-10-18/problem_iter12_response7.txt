```python
import numpy as np

def priority_v2(
    item: float,
    bins_remain_cap: np.ndarray,
    epsilon: float = 0.05,
    base_slope: float = 12.0,
    waste_alpha: float = 5.0,
    random_state=None,
) -> np.ndarray:
    """
    Priority score for online bin packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the current bins.
    epsilon : float, optional
        Exploration probability (default 0.05).
    base_slope : float, optional
        Base steepness for the sigmoid component (default 12.0).
    waste_alpha : float, optional
        Exponential penalty factor for waste (default 5.0).
    random_state : int or np.random.Generator, optional
        Seed or generator for reproducible randomness.

    Returns
    -------
    np.ndarray
        Priority scores for each bin; infeasible bins receive -inf.
    """
    caps = np.asarray(bins_remain_cap, dtype=float)
    n_bins = caps.size
    if n_bins == 0:
        return np.array([], dtype=float)

    # RNG handling
    if isinstance(random_state, np.random.Generator):
        rng = random_state
    else:
        rng = np.random.default_rng(random_state)

    # Exploration phase
    if rng.random() < epsilon:
        feasible = caps >= item
        scores = rng.random(n_bins)
        scores[~feasible] = -np.inf
        # Tiny deterministic bias to break ties by index
        scores += -np.arange(n_bins) * 1e-12
        return scores

    # Exploitation phase
    residual = caps - item
    feasible = residual >= 0
    if not np.any(feasible):
        return np.full_like(caps, -np.inf, dtype=float)

    # Adaptive slope based on median residual of feasible bins
    median_res = np.median(residual[feasible])
    slope = base_slope / median_res if median_res > 0 else base_slope

    # Ratio of residual to capacity, avoiding division by zero
    ratio = np.where(caps > 0, residual / caps, 0.0)
    ratio_feasible = ratio[feasible]

    # Sigmoid-like component that prefers tighter fits
    exp_arg = -slope * ratio_feasible
    sigmoid_score = np.exp(exp_arg)  # values in (0,1]

    # Waste penalty: exponential decay with waste ratio
    eps = 1e-12
    waste_ratio = residual[feasible] / (item + eps)
    waste_penalty = np.exp(-waste_alpha * waste_ratio)

    # Utilization weight
    utilization = np.where(caps > 0, item / caps, 0.0)
    utilization_feasible = utilization[feasible]

    # Raw score for feasible bins
    raw_score = sigmoid_score * waste_penalty * utilization_feasible

    # Build final priority array
    scores = np.full_like(caps, -np.inf, dtype=float)
    scores[feasible] = raw_score
    # Tiny deterministic tie‑breaker
    scores += -np.arange(n_bins) * 1e-12

    return scores
```
