```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Priority function for online Bin Packing.

    Parameters
    ----------
    item : float
        Size of the incoming item.
    bins_remain_cap : np.ndarray
        1‑D array of remaining capacities of the currently open bins.

    Returns
    -------
    np.ndarray
        Priority scores (higher = more desirable). Infeasible bins receive
        -np.inf. Shape matches ``bins_remain_cap``.
    """
    # Ensure a NumPy array of floats
    caps = np.asarray(bins_remain_cap, dtype=float)

    # Edge case: no bins
    if caps.size == 0:
        return np.empty_like(caps, dtype=float)

    # Compute leftover capacity after placing the item
    leftover = caps - item

    # Feasibility mask: only bins that can accommodate the item
    feasible = leftover >= 0

    # Initialise scores to -inf (infeasible bins)
    scores = np.full_like(caps, -np.inf, dtype=float)

    # Early exit if nothing fits
    if not np.any(feasible):
        return scores

    # --------------------------------------------------------------
    # Adaptive steepness based on the distribution of feasible leftovers
    # --------------------------------------------------------------
    median_leftover = np.median(leftover[feasible])
    base_alpha = 5.0               # base steepness for sigmoid & penalty
    eps = 1e-12
    # Larger steepness when the median leftover is small (tight‑fit regime)
    alpha = base_alpha / (median_leftover + eps)
    # Clamp to avoid extreme values that could cause overflow
    alpha = np.clip(alpha, 0.1, 100.0)
    beta = alpha                   # use the same factor for waste penalty

    # --------------------------------------------------------------
    # Sigmoid component: bias towards tight fits
    # --------------------------------------------------------------
    max_exp = 50.0                 # clip exponent to keep np.exp stable
    exp_sig = np.clip(alpha * leftover[feasible], 0.0, max_exp)
    # 2/(1+exp(alpha * leftover)) yields 1 at leftover=0 and decays smoothly
    sigmoid = 2.0 / (1.0 + np.exp(exp_sig))

    # --------------------------------------------------------------
    # Exponential waste penalty
    # --------------------------------------------------------------
    exp_pen = np.clip(beta * leftover[feasible], 0.0, max_exp)
    penalty = np.exp(exp_pen)     # >= 1

    # Combine components (lambda balances penalty strength)
    lam = 1.0
    raw = sigmoid - lam * penalty

    # --------------------------------------------------------------
    # Boost exact fits
    # --------------------------------------------------------------
    exact_fit_tol = 1e-9
    exact_fit_bonus = 10.0
    exact_fit_mask = leftover[feasible] <= exact_fit_tol
    raw[exact_fit_mask] += exact_fit_bonus

    # --------------------------------------------------------------
    # Normalise to [0, 1] for comparability
    # --------------------------------------------------------------
    min_raw = raw.min()
    max_raw = raw.max()
    if max_raw > min_raw:
        norm_raw = (raw - min_raw) / (max_raw - min_raw)
    else:
        # All values equal (e.g., all exact fits); assign zero before tie‑break
        norm_raw = np.zeros_like(raw)

    # --------------------------------------------------------------
    # Deterministic tie‑breaker preferring lower‑index bins
    # --------------------------------------------------------------
    tie_epsilon = 1e-12
    feasible_indices = np.nonzero(feasible)[0].astype(float)
    norm_raw -= tie_epsilon * feasible_indices

    # Populate the final scores array
    scores[feasible] = norm_raw

    return scores
```
