[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "mi": 100.0,
    "token_count": 32.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is the negative of the remaining capacity after addition\n    # This encourages the algorithm to choose the bin with the least remaining capacity that can still fit the item\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # The bin with the least remaining capacity that can still fit the item gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap - item + 1e-6), -1.0)\n    # Add a small random noise to break ties\n    priority += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    Bins with remaining capacity closest to the item size are given higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    diff[bins_remain_cap < item] = np.inf\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    priority = -diff\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    Bins with remaining capacity closest to the item size are given higher priority.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Calculate the priority score as the negative of the difference (lower difference means higher priority)\n    # Add a small value to avoid division by zero when bins_remain_cap equals item\n    priority = -diff + 1e-6\n    \n    # Set the priority score to negative infinity for bins that cannot hold the item\n    priority[bins_remain_cap < item] = -np.inf\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity = bins_remain_cap - item\n    \n    # Assign high priority to bins that have enough capacity for the item\n    # and the remaining capacity is as small as possible (i.e., best fit)\n    priority = np.where(remaining_capacity >= 0, -remaining_capacity, -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on how well the item fits into the remaining capacity of each bin.\n    A higher priority is given to bins that have just enough capacity to hold the item.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot hold the item should have a priority of negative infinity\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority != -np.inf:  # Check if there are bins that can hold the item\n        priority = np.where(priority != -np.inf, np.exp(priority - max_priority), priority)\n    else:\n        priority = np.zeros_like(bins_remain_cap)\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements a priority function for the online Bin Packing Problem.\n    The priority is higher for bins that have enough capacity for the item and \n    have less remaining capacity, thus packing items tightly.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # For bins that can fit the item, the priority is inversely proportional to the remaining capacity\n    # For bins that cannot fit the item, the priority is negative infinity\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a heuristic that prefers bins with just enough remaining capacity.\"\"\"\n    # Priority is high when the remaining capacity is just enough for the item, and low otherwise\n    priorities = np.where(bins_remain_cap >= item, np.exp(-(bins_remain_cap - item)), -np.inf)\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority score is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size will have the highest priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -1e9, -diff)\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements the First-Fit decreasing heuristic with a twist.\n    It prioritizes bins that have just enough capacity to fit the item.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is higher if the bin has enough capacity and is not too large\n    priority_scores = np.where(bins_remain_cap >= item, \n                               1 / (1 + np.abs(bins_remain_cap - item)), \n                               0)\n    \n    # Normalize the scores to ensure they are between 0 and 1\n    max_score = np.max(priority_scores)\n    if max_score > 0:\n        priority_scores /= max_score\n    \n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is higher for bins that have enough capacity for the item and \n    have smaller remaining capacity, indicating a tighter fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # For bins that can fit the item, priority is inversely proportional to the remaining capacity\n    # For bins that cannot fit the item, priority is negative infinity (represented by a very low number)\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-6), -1e6)\n    \n    return priority",
    "response_id": 10,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is higher for bins that have enough capacity to hold the item and \n    have less remaining capacity, indicating a better fit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # For bins that can hold the item, priority is inversely proportional to the remaining capacity\n    # For bins that cannot hold the item, priority is negative infinity\n    priority = np.where(bins_remain_cap >= item, 1 / (bins_remain_cap + 1e-8), -np.inf)\n    \n    return priority",
    "response_id": 11,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    This function implements the First-Fit decreasing heuristic. It prioritizes \n    bins that have just enough remaining capacity to fit the item. If a bin \n    doesn't have enough capacity, its priority is set to negative infinity.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit into each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Initialize priority scores with negative infinity for bins that are too small\n    priority = np.where(valid_bins, bins_remain_cap - item, -np.inf)\n    \n    # Prioritize bins that are filled the most after adding the item\n    priority = np.where(valid_bins, -priority, priority)\n    \n    return priority",
    "response_id": 12,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on the remaining capacity\n    # and how well the item fits into it. The bin that has just enough capacity \n    # for the item gets the highest priority.\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    # Convert the distance to priority score; smaller distance means higher priority\n    priority_score = 1 / (1 + priority)\n    # Special handling for bins that cannot fit the item; give them a score of 0\n    priority_score[priority == np.inf] = 0\n    return priority_score",
    "response_id": 13,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin based on how well the item fits\n    # A bin with remaining capacity closest to the item size gets the highest priority\n    priority = np.where(bins_remain_cap >= item, \n                        1 - np.abs(bins_remain_cap - item) / item, \n                        0)\n    \n    return priority",
    "response_id": 14,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is higher for bins that have enough capacity and are more full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # Priority is higher for bins that have enough capacity\n    enough_capacity = (bins_remain_cap >= item).astype(float)\n    \n    # Priority is higher for bins that are more full (i.e., have less remaining capacity)\n    fullness = 1 - bins_remain_cap / np.max(bins_remain_cap)\n    \n    # Combine the two factors into a single priority score\n    priority = enough_capacity * fullness\n    \n    return priority",
    "response_id": 15,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is determined by how well the item fits into the bin.\n    A higher priority is given to bins where the item fits perfectly or \n    almost perfectly (i.e., remaining capacity is minimized after adding \n    the item). Bins that cannot accommodate the item are given a priority \n    of negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item should have a priority of negative infinity\n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition, -np.inf)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority == -np.inf:  # All bins are too small\n        return np.zeros_like(bins_remain_cap)\n    else:\n        return (priority + np.inf) / (max_priority + np.inf)",
    "response_id": 16,
    "tryHS": false,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    Bins with remaining capacity closest to the item size are given higher priority.\n    If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate the priority for valid bins based on the remaining capacity\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 17,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The bin that has just enough capacity to fit the item gets the highest priority\n    priority = np.where(bins_remain_cap >= item, 1 - (bins_remain_cap - item) / bins_remain_cap, -1)\n    \n    # To avoid division by zero when bins_remain_cap is zero\n    priority = np.where(bins_remain_cap == 0, -1, priority)\n    \n    return priority",
    "response_id": 18,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        # For bins that can accommodate the item, \n                        # prioritize the one with the least remaining capacity\n                        1 / (1 + remaining_cap_after_addition), \n                        # For bins that cannot accommodate the item, assign a very low priority\n                        -np.inf)\n    \n    return priority",
    "response_id": 19,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    The bin with the least remaining capacity that can still fit the item gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit in the bin\n    can_fit = bins_remain_cap >= item\n    \n    # Calculate the priority score for each bin\n    # The bin with the least remaining capacity that can still fit the item gets the highest priority\n    priority = np.where(can_fit, 1 / (bins_remain_cap + 1e-6), 0)\n    \n    # Normalize the priority scores to be between 0 and 1\n    max_priority = np.max(priority)\n    if max_priority > 0:\n        priority = priority / max_priority\n    \n    return priority",
    "response_id": 20,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    The priority is calculated based on the remaining capacity of each bin and the size of the item.\n    Bins with remaining capacity close to the item size will have higher priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # The score is high when the remaining capacity is close to the item size\n    # and low when the remaining capacity is much larger or smaller than the item size\n    priority_scores = np.where(bins_remain_cap >= item, \n                               1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item), \n                               0)\n    \n    return priority_scores",
    "response_id": 21,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_capacity_after_addition = bins_remain_cap - item\n    \n    # Mask for bins that have enough capacity to hold the item\n    valid_bins_mask = remaining_capacity_after_addition >= 0\n    \n    # Priority score is the negative of the remaining capacity after addition for valid bins\n    # and a very low value for bins that cannot hold the item\n    priority_scores = np.where(valid_bins_mask, -remaining_capacity_after_addition, -1e10)\n    \n    return priority_scores",
    "response_id": 22,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is calculated based on the remaining capacity of each bin.\n    A bin with a remaining capacity closest to the item size gets the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + diff), -1e9)\n    \n    return priority",
    "response_id": 23,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Give higher priority to bins that have just enough capacity for the item\n    # and lower priority to bins that are either too full or too empty\n    priority = np.where(bins_remain_cap >= item, bins_remain_cap - item, np.inf)\n    # Use negative priority to simulate \"smaller is better\" for np.inf\n    # and avoid division by zero\n    return -priority",
    "response_id": 24,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n    \n    The priority is calculated based on the remaining capacity of each bin. \n    Bins with remaining capacity closest to the item size are given higher priority.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Check if the item can fit in the bin\n    valid_bins = remaining_cap_after_addition >= 0\n    \n    # Calculate the priority score for valid bins\n    # Bins with remaining capacity closest to 0 are given higher priority\n    priority_scores = np.where(valid_bins, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    return priority_scores",
    "response_id": 25,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    The priority is higher for bins that have just enough remaining capacity to fit the item.\n    If a bin cannot fit the item, its priority is set to negative infinity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the priority score for each bin\n    # Priority is higher when the remaining capacity is just enough to fit the item\n    priority = np.where(bins_remain_cap >= item, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    return priority",
    "response_id": 26,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Check if the item can fit into the bin\n    valid_bins = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the remaining capacity after adding the item\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Prioritize bins with the least remaining capacity after addition, \n    # which indicates the best fit\n    priority = np.where(valid_bins == 1, -remaining_cap_after_addition, -np.inf)\n    \n    return priority",
    "response_id": 27,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This function implements a priority function that prefers bins with \n    remaining capacity closest to the item size, thus minimizing waste.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity of each bin\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(bins_remain_cap >= item, -diff, -np.inf)\n    \n    return priority",
    "response_id": 28,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_after_addition = bins_remain_cap - item\n    \n    # Give high priority to bins that have just enough capacity for the item\n    # and low priority to bins that would have a lot of remaining capacity or not enough capacity\n    priority = np.where(remaining_after_addition >= 0, -np.abs(remaining_after_addition), -np.inf)\n    \n    # Normalize the priority scores to ensure they are on the same scale\n    # and handle the case when all bins are too small for the item\n    if np.all(np.isinf(priority)):\n        priority = np.zeros_like(bins_remain_cap)\n    else:\n        priority = np.where(np.isinf(priority), np.min(priority[~np.isinf(priority)]) - 1, priority)\n    \n    return priority",
    "response_id": 29,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "mi": 80.72468809474,
    "token_count": 134.0,
    "exec_success": true
  }
]