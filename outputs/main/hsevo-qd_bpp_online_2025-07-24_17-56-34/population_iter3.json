[
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score based on how well the item fits into the bin and a small random noise to break ties.\n    \"\"\"\n    # Calculate priority based on remaining capacity after adding the item\n    priority = np.where(bins_remain_cap >= item, - (bins_remain_cap - item), -np.inf)\n    # Add a small random noise to break ties\n    priority += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins where the item fits well and breaks ties using a small noise.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to bins that can accommodate the item and have remaining capacity close to the item size\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + diff), -1e9)\n    \n    # Add a small random noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priority += noise\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritize bins based on remaining capacity after adding item and use noise to break ties.\"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Assign a very low priority to bins that cannot accommodate the item\n    # For bins that can accommodate the item, prioritize the one with the least remaining capacity\n    # Add a small random noise to break ties\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        1 / (1 + remaining_cap_after_addition) + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                        -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with remaining capacity closest to the item size, with tie-breaking.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # Bins that cannot accommodate the item should have a priority of negative infinity\n    priority = np.where(remaining_cap_after_addition >= 0, -np.abs(remaining_cap_after_addition), -np.inf)\n    \n    # Add a small random noise to break ties\n    priority = priority + np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response4.txt_stdout.txt",
    "code_path": "problem_iter2_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for adding an item to each bin.\n    Prioritizes bins where the item fits well and adds noise to break ties.\n    \"\"\"\n    # Calculate the priority score for each bin where the item fits\n    scores = np.where(bins_remain_cap >= item, \n                       1 - np.abs(bins_remain_cap - item) / (bins_remain_cap + item), \n                       0)\n    # Add a small random noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    return scores + noise",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins where the item fits well, with a tie-breaker for close fits.\n    \"\"\"\n    # Calculate priority based on how well the item fits into the bin\n    priority = np.where(bins_remain_cap >= item, \n                        1 - np.abs(bins_remain_cap - item) / item,  # Similar to priority_v0\n                        -np.inf)  # Similar to priority_v1 for bins that are too small\n    \n    # Add a small random noise to break ties\n    priority += np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    \n    return priority",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and a tie-breaker.\n\n    The priority is inversely proportional to the remaining capacity after adding the item.\n    A small random noise is added to break ties.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is inversely proportional to the remaining capacity after addition\n    # Add a small random noise to break ties\n    priority = np.where(remaining_cap_after_addition >= 0, 1 / (remaining_cap_after_addition + 1e-6) + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), -np.inf)\n    \n    return priority",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Priority score based on the remaining capacity and a tie-breaker.\n    \n    Bins with remaining capacity closest to the item size get the highest priority.\n    A small random noise is added to break ties.\n    \"\"\"\n    # Calculate the absolute difference between the item size and the remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign a very low priority to bins that cannot hold the item\n    priority = np.where(bins_remain_cap < item, -1e9, -diff + np.random.uniform(0, 1e-6, size=diff.shape))\n    \n    return priority",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins where the item fits well, with a small random noise for tie-breaking.\n    \"\"\"\n    # Check if the item can fit in each bin\n    valid_bins = bins_remain_cap >= item\n    \n    # Calculate priority based on how well the item fits into the bin\n    priority = np.where(valid_bins, -np.abs(bins_remain_cap - item), -np.inf)\n    \n    # Add a small random noise to break ties\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))\n    priority += noise\n    \n    return priority",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority score for each bin based on remaining capacity and item size.\n    Prioritizes bins with capacity closest to item size and adds noise to break ties.\n    \"\"\"\n    # Calculate the absolute difference between item size and remaining capacity\n    diff = np.abs(bins_remain_cap - item)\n    \n    # Assign high priority to bins that can accommodate the item and have capacity closest to item size\n    # Add a small random noise to break ties\n    priority = np.where(bins_remain_cap >= item, 1 / (1 + diff) + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), -1e9)\n    \n    return priority",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 62.907475208398566,
    "mi": 83.4233565754286,
    "token_count": 86.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is a combination of the negative of the remaining capacity after addition\n    # and a noise term to break ties. The noise term is a small random value that is different for each bin.\n    # This encourages the algorithm to choose the bin with the least remaining capacity that can still fit the item,\n    # and breaks ties in a way that is unlikely to cause oscillations.\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))  # Small random noise\n    \n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition + noise, -np.inf)\n    \n    return priority",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 44.97261104228487,
    "mi": 65.93130662034544,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is a combination of the negative of the remaining capacity after addition\n    # and a noise term to break ties. The noise term is a small random value that helps to avoid always choosing the same bin\n    # when multiple bins have the same remaining capacity.\n    priority = np.where(remaining_cap_after_addition >= 0, \n                        -remaining_cap_after_addition + np.random.uniform(0, 1e-6, size=len(bins_remain_cap)), \n                        -np.inf)\n    \n    return priority",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 44.97261104228487,
    "mi": 65.93130662034544,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is a combination of the negative of the remaining capacity after addition\n    # and a noise term to break ties. The noise term is a small random value that is different for each bin.\n    # This encourages the algorithm to choose the bin with the least remaining capacity that can still fit the item,\n    # and breaks ties in a way that is robust to the specific characteristics of the input data.\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))  # Small random noise\n    \n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition + noise, -np.inf)\n    \n    return priority",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 44.97261104228487,
    "mi": 65.93130662034544,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is a combination of the negative of the remaining capacity after addition\n    # and a noise term to break ties. The noise term is a small random value that is different for each bin.\n    # This encourages the algorithm to choose the bin with the least remaining capacity that can still fit the item,\n    # and breaks ties in a way that is robust to the specific characteristics of the input data.\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))  # Small random noise\n    \n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition + noise, -np.inf)\n    \n    return priority",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 44.97261104228487,
    "mi": 65.93130662034544,
    "token_count": 98.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response4.txt_stdout.txt",
    "code_path": "problem_iter3_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity after adding the item to each bin\n    remaining_cap_after_addition = bins_remain_cap - item\n    \n    # For bins that can fit the item, the priority is a combination of the negative of the remaining capacity after addition\n    # and a noise term to break ties. The noise term is a small random value that is different for each bin.\n    # This encourages the algorithm to choose the bin with the least remaining capacity that can still fit the item,\n    # and breaks ties in a way that is robust to the specific characteristics of the input data.\n    np.random.seed(0)  # For reproducibility\n    noise = np.random.uniform(0, 1e-6, size=len(bins_remain_cap))  # Small random noise\n    \n    priority = np.where(remaining_cap_after_addition >= 0, -remaining_cap_after_addition + noise, -np.inf)\n    \n    return priority",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 44.97261104228487,
    "mi": 65.93130662034544,
    "token_count": 98.0,
    "exec_success": true
  }
]