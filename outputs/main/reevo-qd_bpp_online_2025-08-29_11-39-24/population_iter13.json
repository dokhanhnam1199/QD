[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using First Fit Decreasing-inspired approach.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0  # Highest priority\n\n    # Next, prioritize bins where the item fits with the least remaining space\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_space = bins_remain_cap[fits] - item\n        priorities[fits] = 1.0 / (remaining_space + 1e-6)  # Avoid division by zero\n        \n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diffs = bins_remain_cap - item\n    # Only consider bins where the item can fit\n    valid_bins = diffs >= 0\n    if np.any(valid_bins):\n        # The best fit is the bin with the smallest difference between the item size and its remaining capacity\n        min_diff = np.min(diffs[valid_bins])\n        priorities[valid_bins] = -min_diff  # Negative since we want to maximize the priority\n\n    return priorities",
    "response_id": 1,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign highest priority to bins that exactly fit the item\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, assign priority based on how close the bin capacity is to the item size,\n    # favoring smaller bins with remaining capacity close to the item size.\n    if np.sum(priorities) == 0:\n        diff = np.abs(bins_remain_cap - item)\n        priorities = 1.0 / (diff + 1e-6)  # Adding a small value to avoid division by zero\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n    distances = remaining_capacities - item\n    \n    # Inverse distance: smaller distance gets higher priority\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)  # Add a small epsilon to avoid division by zero\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin using a sigmoid function\n    # Fit score = sigmoid( (bin_remaining_capacity - item) / item)\n    # The sigmoid function ensures that the fit score is between 0 and 1\n    # A higher fit score indicates a better fit for the item\n\n    fit_scores = 1 / (1 + np.exp(-(bins_remain_cap - item) / item))\n\n    # Penalize bins that are nearly full, promoting filling smaller bins first.  Scale factor helps finetuning\n    #scale_factor = 0.1\n    #penalties = np.exp(-bins_remain_cap / (item * scale_factor))\n    #priorities = fit_scores * (1 - penalties)\n\n    #Adjust fit_scores with a small penalty for bins with extremely low remaining capacity, so prevent divide by zero.\n    #priorities = np.where(bins_remain_cap < 1e-6, -np.inf, fit_scores)\n\n    priorities = fit_scores\n\n    return priorities",
    "response_id": 6,
    "obj": 149.27203829278022,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1000  # High priority for exact fit\n\n    # Then prioritize bins where the item fits with minimal waste\n    waste = bins_remain_cap - item\n    priorities[waste >= 0] = 1 / (waste[waste >= 0] + 1e-6) # Avoid division by zero\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.60791492653966,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the 'greedy' priority - Best Fit Decreasing heuristic\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = 1.0 / (remaining_space + 1e-6)  # Add a small value to avoid division by zero\n\n    # Exploration: Assign a random priority to some bins\n    if np.random.rand() < epsilon:\n        num_explore = np.random.randint(1, len(bins_remain_cap) + 1)\n        explore_indices = np.random.choice(len(bins_remain_cap), num_explore, replace=False)\n        for idx in explore_indices:\n            if bins_remain_cap[idx] >= item:\n                priorities[idx] = np.random.rand() #assigning random exploration value\n            else:\n                priorities[idx] = -1 # to avoid placing it \n\n    return priorities",
    "response_id": 8,
    "obj": 4.2580773833266905,
    "SLOC": 15.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate fit score for each bin\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Calculate softmax probabilities\n    if np.sum(fit_scores) > 0:  # Avoid division by zero if no bins can fit\n        exp_fit_scores = np.exp(fit_scores / 1.0)  # Adjust temperature 1.0 as needed\n        probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    else:\n        probabilities = np.zeros_like(bins_remain_cap)\n\n    return probabilities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin capacity and the item size\n    diff = bins_remain_cap - item\n    # Assign a priority based on how close the remaining capacity is to the item size\n    # Prefer bins where the item fits exactly or leaves a small remaining space.\n    # Handle cases where the item doesn't fit in a bin (diff < 0) by assigning a very low priority.\n    priorities = np.where(diff >= 0, -diff, -np.inf)\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    worst_fit_capacity = np.max(bins_remain_cap[valid_bins])\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the ratio of item size to remaining bin capacity.\n    # Prioritize bins where the item fits almost perfectly,\n    # but avoid bins that are too small.\n\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = (bins_remain_cap[i] - item) / bins_remain_cap[i]\n\n    return priorities",
    "response_id": 13,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # Very high priority\n\n    # Next best fit based on remaining capacity (smaller is better)\n    remaining_capacities = bins_remain_cap[bins_remain_cap >= item]\n    if len(remaining_capacities) > 0:\n        min_waste = np.min(remaining_capacities - item)\n        waste_indices = np.where(bins_remain_cap >= item)[0]\n\n        for i in waste_indices:\n            if bins_remain_cap[i] >= item:\n                priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)\n    \n    return priorities",
    "response_id": 14,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 110.36149671375918,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Handle the case where a bin has exactly the item size to avoid division by zero.\n    distances[distances == 0] = 1e-6  # Replace 0 with a very small value\n\n    # Calculate the inverse distance (priority) for each bin.\n    priorities = 1.0 / distances\n\n    # If a bin's capacity is less than the item size, set its priority to 0.\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1 / (remaining_capacity[valid_bins] + 1e-6) #avoid division by zero\n    return priorities",
    "response_id": 17,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'greedy' priority: preference for bins with enough capacity.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        fit_indices = np.where(valid_bins)[0]\n        # Prioritize bins with the smallest remaining capacity.\n        priorities[fit_indices] = 1.0 / (bins_remain_cap[fit_indices] - item + 1e-6)\n\n    # Epsilon-greedy exploration: randomly assign priority to some bins.\n    if np.random.rand() < epsilon:\n        random_bins = np.random.choice(num_bins, size=min(num_bins, 5), replace=False)  # Explore up to 5 bins.\n        priorities[random_bins] = np.random.rand(len(random_bins))\n\n    return priorities",
    "response_id": 18,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Normalize the fit scores using softmax to get probabilities\n    \n    # Avoid division by zero by adding a small value to all scores\n    fit_scores = np.maximum(fit_scores, 1e-6)\n    \n    exp_fit_scores = np.exp(fit_scores)\n    \n    softmax_probs = exp_fit_scores / np.sum(exp_fit_scores)\n\n    return softmax_probs",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 25.26619429851844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diffs = bins_remain_cap - item\n    # Assign priority based on the smallest difference (Best Fit)\n    # We want to prioritize bins where the item fits with the least amount of leftover space.\n    # Avoid bins where the item doesn't fit (diff < 0) by assigning them a very low priority (-1).\n    for i in range(len(bins_remain_cap)):\n        if diffs[i] >= 0:\n            priorities[i] = diffs[i]  # Higher priority for smaller difference\n        else:\n            priorities[i] = -1      # Very low priority for bins that can't fit the item\n    return priorities",
    "response_id": 21,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin capacity and the item size\n    differences = bins_remain_cap - item\n\n    # Only consider bins that can accommodate the item\n    valid_bins = differences >= 0\n\n    if not np.any(valid_bins):\n        return priorities  # No bin can accommodate the item\n\n    # Assign priority based on the remaining capacity.  Bigger remaining cap, higher priority.\n    priorities[valid_bins] = differences[valid_bins]\n\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Give highest priority to bins that have exact fit\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize bins with least remaining capacity that can still accommodate the item.\n    # However, we only give a small boost to these bins, to avoid always selecting these\n    # if no exact fit is found. We want exact fit first.\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        min_remaining = np.min(bins_remain_cap[possible_bins])\n        for i in range(len(bins_remain_cap)):\n            if possible_bins[i]:\n                if bins_remain_cap[i] == min_remaining:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.1\n    return priorities",
    "response_id": 24,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 23.264662506490403,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Avoid division by zero. Add a small epsilon to the denominator.\n    epsilon = 1e-6\n    \n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diff = np.abs(bins_remain_cap - item)\n\n    # For bins that have sufficient capacity, the priority is inversely proportional to the difference.\n    # This favors bins where the item fits snugly.\n    # For bins that don't have sufficient capacity, assign a very low priority.\n    \n    sufficient_capacity = bins_remain_cap >= item\n    \n    priorities[sufficient_capacity] = 1.0 / (diff[sufficient_capacity] + epsilon)\n    \n    return priorities",
    "response_id": 25,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Apply the sigmoid function to the fit scores\n    # Sigmoid function: f(x) = 1 / (1 + exp(-k * (x - x0)))\n    # Parameters:\n    #   k: Steeperness of the curve\n    #   x0: Midpoint of the curve\n\n    k = 2  # Adjust k to control the sigmoid steepness\n    x0 = 0.5  # Adjust x0 to control where the sigmoid transitions\n\n    priorities = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n\n    # Normalize priorities to avoid extreme values.  Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities))\n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    suitable_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return zeros\n    if not np.any(suitable_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Assign random priorities to suitable bins.  Smaller remainder gives higher priority\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[suitable_bins] = bins_remain_cap[suitable_bins] - item\n\n    # normalize the priority value with the total bins_remain_cap value\n    priorities = priorities / np.sum(bins_remain_cap)\n\n    return priorities",
    "response_id": 27,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n\n    # Calculate the 'greedy' priority - how well the item fits.\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        fit_scores = bins_remain_cap[feasible_bins] - item  # How much space is left after adding the item\n        priorities[feasible_bins] = fit_scores / bins_remain_cap[feasible_bins]  # Normalize by bin capacity. Higher is better.\n\n    # Epsilon-greedy exploration\n    if np.random.random() < epsilon:\n        # Explore: Assign a random priority to each bin, even if the item doesn't fit\n        priorities = np.random.rand(n_bins)\n\n    return priorities",
    "response_id": 28,
    "obj": 138.7614678899083,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin (how well the item fits into the remaining capacity).\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Normalize the fit scores using softmax to get probability-like priorities.\n    # Add a small epsilon to avoid division by zero and to ensure probabilities sum to 1.\n    epsilon = 1e-8\n    exp_fit_scores = np.exp(fit_scores / (max(fit_scores) + epsilon))\n    priorities = exp_fit_scores / (np.sum(exp_fit_scores) + epsilon)\n\n    return priorities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.60791492653966,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Assign highest priority to bins that exactly fit the item\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, assign priority based on how close the bin capacity is to the item size,\n    # favoring smaller bins with remaining capacity close to the item size.\n    if np.sum(priorities) == 0:\n        # Prioritize bins where the item can fit\n        valid_bins = bins_remain_cap >= item\n        if np.any(valid_bins):\n            fit_indices = np.where(valid_bins)[0]\n            diff = bins_remain_cap[fit_indices] - item\n            priorities[fit_indices] = 1.0 / (diff + 1e-6)  # Smaller difference = higher priority\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.53238859703687,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Apply the sigmoid function to the fit scores\n    # Sigmoid function: f(x) = 1 / (1 + exp(-k * (x - x0)))\n    # Parameters:\n    # k: Steeperness of the curve\n    # x0: Midpoint of the curve\n    k = 2  # Adjust k to control the sigmoid steepness\n    x0 = 0.5  # Adjust x0 to control where the sigmoid transitions\n\n    # Avoid division by zero or inf by setting a minimum remaining capacity\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-6)\n    fit_scores = item / bins_remain_cap\n\n    priorities = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n\n    # Normalize priorities to avoid extreme values. Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-8)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Normalize the fit scores using softmax to get probabilities\n    # Avoid division by zero by adding a small value to all scores\n    fit_scores = np.maximum(fit_scores, 1e-6)\n    exp_fit_scores = np.exp(fit_scores)\n    softmax_probs = exp_fit_scores / np.sum(exp_fit_scores)\n\n    return softmax_probs",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 25.26619429851844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response0.txt_stdout.txt",
    "code_path": "problem_iter6_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, item / bins_remain_cap, 0)\n\n    # Calculate the fullness score for each bin (lower is better)\n    fullness_scores = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # Combine fit and fullness scores.  Weight fullness more heavily.\n    combined_scores = 0.6 * fit_scores - 0.4 * fullness_scores\n\n    # Apply the sigmoid function to the combined scores\n    k = 3  # Adjust k to control the sigmoid steepness\n    x0 = 0.3  # Adjust x0 to control where the sigmoid transitions\n    priorities = 1 / (1 + np.exp(-k * (combined_scores - x0)))\n\n    # Normalize priorities to avoid extreme values. Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-8)\n\n    return priorities",
    "response_id": 0,
    "obj": 16.384124451535698,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 235.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-6\n\n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diff = np.abs(bins_remain_cap - item)\n\n    # Prioritize bins where the item fits snugly.\n    sufficient_capacity = bins_remain_cap >= item\n    priorities[sufficient_capacity] = 1.0 / (diff[sufficient_capacity] + epsilon)\n\n    # Penalize nearly full bins.\n    nearly_full = bins_remain_cap < item * 0.1\n    priorities[nearly_full] = -1.0\n\n    # Penalize almost empty bins.\n    almost_empty = bins_remain_cap > 0.9\n    priorities[almost_empty] = -0.5\n\n    return priorities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 104.2481250360578,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1.0\n\n    # Next best fit based on remaining capacity (smaller waste is better)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (waste + 1e-6)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1000.0\n\n    # If no exact fit, prioritize bins with minimal waste\n    remaining_bins = np.where(priorities == 0)[0]\n    if len(remaining_bins) > 0:\n        waste = bins_remain_cap[remaining_bins] - item\n        valid_bins = remaining_bins[waste >= 0]\n\n        if len(valid_bins) > 0:\n            # Prioritize bins that are less full (higher remaining capacity)\n            # and minimize waste.\n            priorities[valid_bins] = (bins_remain_cap[valid_bins] / (item + 1e-6)) / (waste[waste >= 0] + 1e-6)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 142.62362713128297,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit Decreasing strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin capacity and the item size\n    diff = bins_remain_cap - item\n    # Assign a priority based on how close the remaining capacity is to the item size\n    # Prefer bins where the item fits exactly or leaves a small remaining space.\n    # Handle cases where the item doesn't fit in a bin (diff < 0) by assigning a very low priority.\n    priorities = np.where(diff >= 0, -diff, -np.inf)\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n    distances = np.abs(remaining_capacities - item)\n    \n    # Prioritize bins where the remaining capacity is close to the item size\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    \n    # Further boost priority for bins with smaller remaining capacities (avoiding large gaps)\n    priorities[valid_bins] *= remaining_capacities \n    \n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact Fit First: Highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # Calculate waste and normalized distance to item size\n    remaining_bins = np.where(priorities == 0)[0]\n    if len(remaining_bins) > 0:\n        waste = bins_remain_cap[remaining_bins] - item\n        normalized_distance = waste / item\n        \n        # Sigmoid function to score nuanced fits (avoiding near-empty or near-full bins)\n        # Adjust steepness and center for desired behavior\n        steepness = 2.0\n        center = 0.1  # Shifted to favor bins closer to being full but not completely full\n        sigmoid_scores = 1 / (1 + np.exp(-steepness * (normalized_distance - center)))\n        \n        # Normalize scores to avoid large differences\n        priorities[remaining_bins] = sigmoid_scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.208216992421225,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 2.0  # Higher than other priorities\n\n    # Calculate waste and distance from ideal fill (half-full)\n    waste = bins_remain_cap - item\n    distance_from_half = np.abs(bins_remain_cap - (1.0))  # Assuming bin capacity is 1.0\n\n    # Use a sigmoid function to score nuanced fits, normalizing by item size\n    sigmoid_scores = 1.0 / (1.0 + np.exp(-(bins_remain_cap - item) / item))\n    \n    # Combine factors: prioritize minimal waste, distance to half, and sigmoid score\n    priorities = np.where(priorities == 0,\n                          0.5 * sigmoid_scores + 0.3 / (waste + 1e-6) - 0.2 * distance_from_half,\n                          priorities)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 209.21505009519265,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, calculate priority based on waste and bin fullness\n    if np.sum(priorities) == 0:\n        diff = np.abs(bins_remain_cap - item)\n        waste = diff  # Waste is simply the absolute difference\n        \n        # Sigmoid function to normalize waste and bin fullness\n        fullness = bins_remain_cap\n        \n        # Avoid division by zero and overly strong preference for very small bins\n        normalized_waste = waste / (item + 1e-6)\n        normalized_fullness = fullness / (1.0 + 1e-6) # Scale bin fullness\n        \n        # Combine waste and bin fullness. Lower waste and medium fullness is best.\n        priority = np.exp(-normalized_waste) * normalized_fullness\n        priorities = priority\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize based on minimizing waste and avoiding near-empty/full bins\n    if np.sum(priorities) == 0:\n        diff = np.abs(bins_remain_cap - item)\n        # Sigmoid function to score nuanced fits\n        sigmoid_input = -diff  # Negative difference for sigmoid\n        priorities = 1.0 / (1.0 + np.exp(-0.5 * sigmoid_input))  # Sigmoid function\n\n        # Normalize priorities based on bin fullness\n        fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n        priorities = priorities * (1.0 - fullness)  # Penalize almost full bins\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 151.6206750336681,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response1.txt_stdout.txt",
    "code_path": "problem_iter4_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 2.0  # Highest priority\n\n    # If no exact fit, prioritize based on minimizing waste and avoiding near-empty/full bins\n    if np.sum(priorities) == 0:\n        diff = bins_remain_cap - item\n        valid_bins = diff >= 0  # Only consider bins that can fit the item\n\n        if np.sum(valid_bins) > 0:\n            # Score based on waste (smaller waste is better)\n            waste_scores = -diff[valid_bins]\n\n            # Score based on bin fullness (avoid extremes)\n            fullness = 1.0 - (bins_remain_cap[valid_bins] / np.max(bins_remain_cap))\n            fullness_scores = -np.abs(fullness - 0.5)  # Penalize bins that are very empty or very full\n\n            # Combine scores (weighted sum)\n            combined_scores = 0.7 * waste_scores + 0.3 * fullness_scores\n\n            # Apply sigmoid to get priorities\n            priorities[valid_bins] = 1.0 / (1.0 + np.exp(-combined_scores))\n\n            # Normalize priorities\n            priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-8)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 301.26792647514816,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response3.txt_stdout.txt",
    "code_path": "problem_iter4_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diffs = bins_remain_cap - item\n    \n    # Consider only bins where the item can fit.\n    valid_bins = diffs >= 0\n    \n    if np.any(valid_bins):\n        # Calculate the ratio of remaining space after adding the item to the bin.\n        ratios = diffs[valid_bins] / bins_remain_cap[valid_bins]\n        \n        # Assign priority based on the ratio. Higher ratio means better fit.\n        priorities[valid_bins] = ratios\n        \n    return priorities",
    "response_id": 3,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 28.529325012980813,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response7.txt_stdout.txt",
    "code_path": "problem_iter4_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Prioritize bins where the item fits with minimal remaining capacity and highest fullness\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n\n    if np.any(valid_bins):\n        fullness = 1 - (remaining_capacity[valid_bins] / bins_remain_cap[valid_bins])\n        priorities[valid_bins] = fullness + 1 / (remaining_capacity[valid_bins] + 1e-6) # Combine fullness and minimal waste\n\n    return priorities",
    "response_id": 7,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 100.07820003461549,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter4_response8.txt_stdout.txt",
    "code_path": "problem_iter4_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize based on minimizing waste and avoiding near-empty/full bins\n    if np.sum(priorities) == 0:\n        fits = bins_remain_cap >= item\n        if np.any(fits):\n            diff = bins_remain_cap[fits] - item\n            # Sigmoid function to score nuanced fits\n            sigmoid_input = -diff  # Negative difference for sigmoid\n            sigmoid_scores = 1.0 / (1.0 + np.exp(-0.5 * sigmoid_input))\n\n            # Normalize priorities based on bin fullness\n            fullness = 1.0 - (bins_remain_cap[fits] / np.max(bins_remain_cap))\n            priorities[fits] = sigmoid_scores * (1.0 - fullness)\n    \n    # Add a small bonus for bins that are not completely empty\n    not_empty = bins_remain_cap > 0\n    priorities[not_empty] += 0.01\n\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 15.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 206.71626164847697,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Prioritize bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n\n        # Sigmoid scoring for snugness\n        snugness = 1 / (1 + np.exp(-5 * (1 - (item / bins_remain_cap[valid_bins]))))\n        \n        # Avoid extremely full or empty bins\n        fullness_penalty = np.exp(-abs(fullness - 0.5) * 10)\n\n        priorities[valid_bins] = snugness * fullness * fullness_penalty + 1e-6 #small value to avoid zero\n\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 242.75561920895692,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response1.txt_stdout.txt",
    "code_path": "problem_iter5_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit = np.isclose(bins_remain_cap, item)\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n\n        # Sigmoid scoring for \"snugness\"\n        snugness = 1 / (remaining_capacity + 1e-6)  # Avoid division by zero\n        snugness = 1 / (1 + np.exp(-5 * (snugness - np.mean(snugness)))) # Scale and sigmoid\n\n        # Combine fullness and snugness, with a bias towards higher fullness\n        priorities[valid_bins] = 0.7 * fullness + 0.3 * snugness\n\n    # Avoid extremely full or empty bins\n    bin_fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n    priorities = priorities * (1 - np.abs(bin_fullness - 0.5))  # Penalize extreme fullness\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 284.897919110019,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response1.txt_stdout.txt",
    "code_path": "problem_iter6_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    # Calculate the difference between item size and remaining bin capacity\n    distances = np.abs(bins_remain_cap[valid_bins] - item)\n\n    # Calculate the density of the item within each bin if it were placed there\n    densities = item / bins_remain_cap[valid_bins]\n\n    # Combine distance and density to create a priority score.\n    # Closer distance and higher density mean higher priority.\n    priorities[valid_bins] = (1.0 / (distances + 1e-6)) * densities\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 87.56842503028855,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response5.txt_stdout.txt",
    "code_path": "problem_iter10_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the fit score for each bin\n    fit_scores = np.where(bins_remain_cap >= item, item / bins_remain_cap, 0.0)\n\n    # Apply the sigmoid function to the fit scores\n    k = 4  # Adjust k to control the sigmoid steepness\n    x0 = 0.7 # Adjust x0 to control where the sigmoid transitions\n    sigmoid_scores = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n\n    # Add an exploration factor to encourage trying different bins\n    exploration_factor = 0.15\n    exploration_scores = np.random.rand(num_bins) * exploration_factor\n\n    # Combine fit and exploration scores\n    priorities = sigmoid_scores + exploration_scores\n\n    # Normalize priorities to avoid extreme values. Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-6)\n\n    return priorities",
    "response_id": 5,
    "obj": 4.11846828879138,
    "SLOC": 12.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 182.67948703818894,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response5.txt_stdout.txt",
    "code_path": "problem_iter6_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (remaining_capacity + 1e-6)\n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response6.txt_stdout.txt",
    "code_path": "problem_iter6_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'greedy' priority: preference for bins with enough capacity.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        fit_indices = np.where(valid_bins)[0]\n        # Prioritize bins with the smallest remaining capacity.\n        priorities[fit_indices] = 1.0 / (bins_remain_cap[fit_indices] - item + 1e-6)\n\n    # Epsilon-greedy exploration: randomly assign priority to some bins.\n    if np.random.rand() < epsilon:\n        num_explore = min(num_bins, 5)  # Explore up to 5 bins\n        random_bins = np.random.choice(num_bins, size=num_explore, replace=False)\n        priorities[random_bins] = np.random.rand(num_explore)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response7.txt_stdout.txt",
    "code_path": "problem_iter6_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0\n\n    # Next, prioritize bins where the item fits with the least remaining space\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_space = bins_remain_cap[fits] - item\n        priorities[fits] = 1.0 / (remaining_space + 1e-6)  # Avoid division by zero\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response8.txt_stdout.txt",
    "code_path": "problem_iter6_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Handle the case where a bin has exactly the item size to avoid division by zero.\n    distances[distances == 0] = 1e-6\n\n    # Combine fit and inverse distance.  Give more weight to fit.\n    priorities = fit_scores / (distances)\n\n    # If a bin's capacity is less than the item size, set its priority to 0.\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities",
    "response_id": 8,
    "obj": 5.534503390506582,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 59.794705707972525,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response0.txt_stdout.txt",
    "code_path": "problem_iter7_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Prioritize bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # Calculate fit score (how close the bin capacity is to the item size)\n        fit_score = np.abs(bins_remain_cap[valid_bins] - item)\n        # Calculate remaining capacity\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        # Calculate fullness\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n\n        # Combine fit and fullness using sigmoid scaling\n        # Sigmoid scaling helps to balance the two factors\n        rate = 2.0  # Adjust this rate to control the balance\n        sigmoid_fit = 1 / (1 + np.exp(-rate * (bins_remain_cap[valid_bins] - item)))\n        priorities[valid_bins] = fullness + sigmoid_fit\n\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 158.32466846199546,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response1.txt_stdout.txt",
    "code_path": "problem_iter7_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Consider bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # Calculate fit score (how close the item size is to bin capacity)\n        fit_score = np.abs(bins_remain_cap[valid_bins] - item)\n        # Calculate remaining capacity after placing the item\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        # Calculate fullness (how full the bin will be after placing the item)\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n\n        # Combine fit and fullness using sigmoid scaling\n        # This balances minimizing waste with bin fullness\n        rate = 2.0  # Adjust this rate to control the balance\n        priority = (fullness * np.exp(-rate * fit_score)) + (1.0 / (fit_score + 1e-6))\n\n        priorities[valid_bins] = priority\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 160.4736875252405,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response3.txt_stdout.txt",
    "code_path": "problem_iter7_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n    \n    # Prioritize bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # Calculate fit score (how close the bin capacity is to the item size)\n        fit_score = np.abs(bins_remain_cap[valid_bins] - item)\n        \n        # Normalize fit score using sigmoid function\n        # Scale the sigmoid to emphasize closer fits\n        fit_score_scaled = 1.0 / (1.0 + np.exp(fit_score))\n        \n        # Calculate remaining capacity\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        \n        # Calculate fullness (how full the bin will be after adding the item)\n        fullness = 1.0 - (remaining_capacity / bins_remain_cap[valid_bins])\n        \n        # Combine fit and fullness using a weighted sum\n        # Adjust the weights to balance fit and fullness\n        priority = 0.6 * fullness + 0.4 * fit_score_scaled\n        \n        priorities[valid_bins] = priority\n    \n    return priorities",
    "response_id": 3,
    "obj": 4.487435181491823,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 147.1612434150308,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter7_response4.txt_stdout.txt",
    "code_path": "problem_iter7_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        # Calculate fit score (how close to the bin size the item is)\n        fit_score = np.exp(-((bins_remain_cap[valid_bins] - item) / item)**2)  # Sigmoid-like scaling\n\n        # Calculate fullness score (how full the bin is after adding the item)\n        fullness_score = 1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]\n\n        # Combine fit and fullness scores (weighted sum)\n        priorities[valid_bins] = 0.7 * fullness_score + 0.3 * fit_score\n\n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 164.51539013493823,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response1.txt_stdout.txt",
    "code_path": "problem_iter8_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score with Epsilon-Greedy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the fit score for each bin\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-6)  # Avoid division by zero\n    fit_scores = item / bins_remain_cap\n\n    # Apply the sigmoid function to the fit scores\n    k = 2  # Steeperness of the curve\n    x0 = 0.5  # Midpoint of the curve\n    sigmoid_scores = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n\n    # Normalize priorities to avoid extreme values\n    priorities = (sigmoid_scores - np.min(sigmoid_scores)) / (np.max(sigmoid_scores) - np.min(sigmoid_scores) + 1e-8)\n\n    # Epsilon-greedy exploration\n    if np.random.rand() < epsilon:\n        num_explore = min(num_bins, 5)\n        explore_indices = np.random.choice(num_bins, size=num_explore, replace=False)\n        priorities[explore_indices] += np.random.rand(num_explore) * 0.2  # Add a small random bonus\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 186.46184263312372,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response3.txt_stdout.txt",
    "code_path": "problem_iter8_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a refined Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin. A good fit means the item isn't too big\n    # relative to the bin's remaining capacity, but also isn't too small (avoiding tiny waste).\n    fit_scores = (bins_remain_cap - item) / bins_remain_cap\n\n    # Apply the sigmoid function to the fit scores.\n    k = 3  # Steeperness of the curve. Higher k means more emphasis on good fits.\n    x0 = 0.25  # Midpoint of the curve. Adjust to prefer tighter or looser fits.\n    \n    # Avoid division by zero or inf by setting a minimum remaining capacity\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-6)\n    fit_scores = (bins_remain_cap - item) / bins_remain_cap\n    \n    priorities = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n    \n    # Normalize priorities to avoid extreme values. Helps prevent a single bin always being favored.\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-8)\n    \n    # Boost priority for bins where the item fits exactly (or very closely)\n    exact_fit_bins = np.where(np.abs(bins_remain_cap - item) < 1e-6)[0]\n    priorities[exact_fit_bins] += 0.5  # Add a constant boost. Can tune this value.\n\n    return priorities",
    "response_id": 3,
    "obj": 149.30195452732352,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 230.62385799360038,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response5.txt_stdout.txt",
    "code_path": "problem_iter8_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give highest priority to bins that have exact fit\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize bins with least remaining capacity that can still accommodate the item.\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        min_remaining = np.min(bins_remain_cap[possible_bins])\n        for i in range(len(bins_remain_cap)):\n            if possible_bins[i]:\n                if bins_remain_cap[i] == min_remaining:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.1\n\n    return priorities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 23.264662506490403,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response6.txt_stdout.txt",
    "code_path": "problem_iter8_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Handle the case where a bin has exactly the item size to avoid division by zero.\n    distances[distances == 0] = 1e-6\n\n    # Combine fit and inverse distance. Give more weight to fit.\n    priorities = fit_scores / (distances)\n\n    # If a bin's capacity is less than the item size, set its priority to 0.\n    priorities[bins_remain_cap < item] = 0\n\n    # Penalize bins that are almost full.\n    remaining_capacity_ratio = bins_remain_cap / 100  # Assuming bin size is 100\n    priorities = priorities * (1 - remaining_capacity_ratio)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.956122856003196,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 108.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter8_response7.txt_stdout.txt",
    "code_path": "problem_iter8_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combined score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Fit score: how well the item fits in the bin (smaller is better)\n    fit_score = item / bins_remain_cap\n    fit_score[~valid_bins] = np.inf  # Assign a very low priority to invalid bins\n\n    # Waste score: how much space is left after adding the item (smaller is better)\n    waste_score = (bins_remain_cap - item)\n    waste_score[~valid_bins] = -np.inf\n\n    # Interaction score: combine fit and waste\n    interaction_score = waste_score / (fit_score + 1e-6)  # Avoid division by zero\n\n    # Normalize and scale scores\n    normalized_interaction_score = (interaction_score - np.min(interaction_score[valid_bins])) / \\\n                                 (np.max(interaction_score[valid_bins]) - np.min(interaction_score[valid_bins]))\n\n    priorities[valid_bins] = normalized_interaction_score\n\n    return priorities",
    "response_id": 7,
    "obj": 149.30195452732352,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 142.7018117963935,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response3.txt_stdout.txt",
    "code_path": "problem_iter13_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0  # High priority for exact fits\n\n    # If no exact fit, prioritize based on minimizing waste and bin fullness\n    if np.sum(priorities) == 0:\n        diff = bins_remain_cap - item\n        feasible_bins = diff >= 0\n\n        if np.any(feasible_bins):\n            # Calculate waste\n            waste = diff[feasible_bins]\n            # Normalize waste - smaller waste is better\n            normalized_waste = 1.0 / (waste + 1e-6)\n\n            # Consider bin fullness\n            fullness = bins_remain_cap / np.max(bins_remain_cap)\n            # Prioritize bins that are moderately full\n            fullness_factor = np.exp(-((fullness - 0.5) ** 2) / 0.05)\n\n            # Combine waste and fullness factors. Increased weight on waste\n            priorities[feasible_bins] = 0.7 * normalized_waste + 0.3 * fullness_factor\n        else:\n            priorities[:] = -1.0  # No bin can fit the item\n\n    return priorities",
    "response_id": 3,
    "obj": 3.5101715197447194,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 213.03044134663566,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response0.txt_stdout.txt",
    "code_path": "problem_iter9_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize exact fits!\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Calculate fit and remaining capacity for valid bins\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n\n    if np.any(valid_bins):\n        # Normalize remaining capacity\n        normalized_capacity = remaining_capacity[valid_bins] / bins_remain_cap[valid_bins]\n        \n        # Sigmoid scaling for non-linear combination of fit & remaining capacity\n        fullness = 1 - normalized_capacity\n        \n        # Adjust the scaling factor (e.g., 2) and shift (e.g., 0.5) as needed\n        priority_score = fullness * np.exp(-5 * (1 - fullness)) + 1 / (remaining_capacity[valid_bins] + 1e-6) \n        \n        priorities[valid_bins] = priority_score\n\n    return priorities",
    "response_id": 0,
    "obj": 4.068607897885915,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 162.53496664211536,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Calculate the normalized fit and remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n\n    if np.any(valid_bins):\n        fullness = remaining_capacity[valid_bins] / bins_remain_cap[valid_bins]\n        fullness = 1 - fullness # Higher fullness is better\n\n        # Sigmoid scaling to balance fit and remaining capacity\n        sigmoid_scale = 5.0\n        priority_component = fullness * np.exp(-sigmoid_scale * remaining_capacity[valid_bins])\n        priorities[valid_bins] = priority_component\n\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response2.txt_stdout.txt",
    "code_path": "problem_iter9_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return: Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize exact fits!\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Score bins by a normalized, non-linear combination of fit & remaining capacity\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n\n        # Sigmoid scaling to control exploration vs. exploitation\n        sigmoid_scale = 5  # Tune this parameter\n        sigmoid = 1 / (1 + np.exp(-sigmoid_scale * fullness))\n\n        # Combine fullness (via sigmoid) and remaining capacity\n        priorities[valid_bins] = sigmoid + 1 / (remaining_capacity + 1e-6)\n\n    return priorities",
    "response_id": 2,
    "obj": 4.397686477862,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 158.32466846199546,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response4.txt_stdout.txt",
    "code_path": "problem_iter12_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n    # For bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n        # Sigmoid function to normalize and emphasize fullness\n        sigmoid_fullness = 1 / (1 + np.exp(-8 * (fullness - 0.5)))  # Increased sensitivity\n        # Combine fullness and inverse remaining capacity, with a higher weight on fullness\n        priorities[valid_bins] = 2 * sigmoid_fullness + 1 / (remaining_capacity + 1e-6)\n    return priorities",
    "response_id": 4,
    "obj": 4.058635819704831,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 194.95038758870223,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response2.txt_stdout.txt",
    "code_path": "problem_iter10_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n\n    # Calculate the 'best fit' priority - how well the item fits.\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        fit_scores = bins_remain_cap[feasible_bins] - item  # How much space is left\n        priorities[feasible_bins] = -fit_scores  # Prefer tighter fits (smaller remaining space)\n\n    # Epsilon-greedy exploration: Add a small random value to priorities to encourage exploration\n    if np.random.random() < epsilon:\n        priorities += np.random.rand(n_bins) * 0.1  # Add small random value\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response8.txt_stdout.txt",
    "code_path": "problem_iter10_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    num_bins = len(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 10.0  # Significantly higher priority\n\n    # Bins with enough capacity\n    valid_bins = bins_remain_cap >= item\n    fit_indices = np.where(valid_bins)[0]\n\n    if len(fit_indices) > 0:\n        # Calculate waste\n        waste = bins_remain_cap[fit_indices] - item\n\n        # Calculate distance from ideal fill (half-full) - assuming bin capacity is 1\n        distance_from_half = np.abs(bins_remain_cap[fit_indices] - 0.5)\n\n        # Calculate a 'fullness' score - how full the bin will be after adding the item\n        fullness = (bins_remain_cap[fit_indices] - item) / bins_remain_cap[fit_indices]\n\n        # Combine factors - prioritize minimal waste, closeness to half-full, and fullness\n        priorities[fit_indices] = 0.6 * (1.0 / (waste + 1e-6)) - 0.3 * distance_from_half + 0.1 * fullness\n\n    # Epsilon-greedy exploration\n    epsilon = 0.05\n    if np.random.rand() < epsilon:\n        num_explore = min(num_bins, 3)\n        random_bins = np.random.choice(num_bins, size=num_explore, replace=False)\n        priorities[random_bins] = np.random.rand(num_explore) * 2.0  # Give exploration a reasonable priority\n\n    return priorities",
    "response_id": 8,
    "obj": 4.068607897885915,
    "SLOC": 18.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 248.15640006923098,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter10_response9.txt_stdout.txt",
    "code_path": "problem_iter10_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n\n    # Prioritize bins where the item fits with minimal remaining capacity and highest fullness\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n\n    if np.any(valid_bins):\n        fullness = 1 - (remaining_capacity[valid_bins] / bins_remain_cap[valid_bins])\n        waste_penalty = 1 / (remaining_capacity[valid_bins] + 1e-6)\n        priorities[valid_bins] = 0.8 * fullness + 0.2 * waste_penalty  # Combine fullness and minimal waste\n\n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 135.7068586817104,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response3.txt_stdout.txt",
    "code_path": "problem_iter11_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Prioritize bins where the item fits\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        fullness = 1.0 - (remaining_capacity / bins_remain_cap[valid_bins])\n\n        # Sigmoid function for normalized, non-linear combination of fit and remaining capacity\n        sigmoid_input = fullness * 10  # Scale fullness for better sigmoid response\n        sigmoid_values = 1.0 / (1.0 + np.exp(-sigmoid_input))\n\n        priorities[valid_bins] = sigmoid_values + 1.0 / (remaining_capacity + 1e-6)\n\n    return priorities",
    "response_id": 3,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 158.32466846199546,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Exact fit gets highest priority\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000.0\n\n    # Calculate normalized fit and remaining capacity for other bins\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        remaining_capacity = bins_remain_cap[valid_bins] - item\n        fullness = 1 - (remaining_capacity / bins_remain_cap[valid_bins])\n        \n        # Sigmoid function to combine fullness and waste reduction\n        # Adjust parameters (scale=2, shift=0) to tune the exploration-exploitation balance\n        scale = 2.0\n        shift = 0.0\n        \n        priority = fullness * scale + shift\n        priorities[valid_bins] = priority\n    \n    return priorities",
    "response_id": 4,
    "obj": 4.198244914240141,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 85.83671966625714,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response1.txt_stdout.txt",
    "code_path": "problem_iter12_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize feasible bins (where the item fits)\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        # Calculate the remaining capacity if the item is placed in each feasible bin\n        remaining_space = bins_remain_cap[feasible_bins] - item\n        # Prioritize bins with the smallest remaining space (proximity fit)\n        priorities[feasible_bins] = 1.0 / (remaining_space + 1e-6)\n    return priorities",
    "response_id": 1,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response2.txt_stdout.txt",
    "code_path": "problem_iter12_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1000.0\n\n    # If no exact fit, prioritize based on minimizing waste and avoiding near-empty/full bins\n    if np.sum(priorities) == 0:\n        waste = bins_remain_cap - item\n        valid_bins = waste >= 0\n\n        if np.any(valid_bins):\n            # Use a combination of waste and fullness\n            fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n            priority = 1.0 / (waste[valid_bins] + 1e-6) * (1.0 - fullness[valid_bins])\n            priorities[valid_bins] = priority\n        else:\n            # If the item doesn't fit in any bin, assign a low priority to all bins\n            priorities[:] = -1.0\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 140.55415752892034,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response5.txt_stdout.txt",
    "code_path": "problem_iter12_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.where(bins_remain_cap >= item, - (bins_remain_cap - item), -np.inf)\n    return priorities",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 28.07354922057604,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response9.txt_stdout.txt",
    "code_path": "problem_iter12_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-6\n    sufficient_capacity = bins_remain_cap >= item\n    priorities[sufficient_capacity] = 1.0 / (np.abs(bins_remain_cap[sufficient_capacity] - item) + epsilon)\n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response0.txt_stdout.txt",
    "code_path": "problem_iter13_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin. Args:\n    item: Size of item to be added to the bin.\n    bins_remain_cap: Array of capacities for each bin.\n    Returns: Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0  # High priority for exact fits\n\n    # If no exact fit, prioritize based on minimizing waste and remaining capacity\n    if np.sum(priorities) == 0:\n        diff = bins_remain_cap - item\n        feasible_bins = diff >= 0\n        if np.any(feasible_bins):\n            # Calculate waste\n            waste = diff[feasible_bins]\n            # Normalize waste - smaller waste is better\n            normalized_waste = 1.0 / (waste + 1e-6)\n            # Prioritize based on remaining capacity (bins with less remaining capacity are preferred)\n            remaining_cap_factor = bins_remain_cap[feasible_bins]\n            normalized_remaining_cap = remaining_cap_factor / np.max(bins_remain_cap)\n            priorities[feasible_bins] = normalized_waste * normalized_remaining_cap\n        else:\n            priorities[:] = -1.0  # No bin can fit the item\n    return priorities",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 16.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 112.37013046707143,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter13_response2.txt_stdout.txt",
    "code_path": "problem_iter13_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0  # High priority for exact fits\n\n    # If no exact fit, prioritize based on minimizing waste and remaining capacity\n    if np.sum(priorities) == 0:\n        diff = bins_remain_cap - item\n        feasible_bins = diff >= 0\n\n        if np.any(feasible_bins):\n            # Calculate waste (remaining capacity after placing item)\n            waste = diff[feasible_bins]\n            # Prioritize lower waste (higher priority)\n            priorities[feasible_bins] = 1.0 / (waste + 1e-6)\n            # Also consider remaining capacity - prefer bins with more remaining capacity\n            priorities[feasible_bins] *= bins_remain_cap[feasible_bins]\n        else:\n            priorities[:] = -1.0  # No bin can fit the item\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 14.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 95.90827503317318,
    "exec_success": true
  }
]