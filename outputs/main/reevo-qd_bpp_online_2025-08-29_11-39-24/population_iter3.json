[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 3.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 0.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using First Fit Decreasing-inspired approach.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1.0  # Highest priority\n\n    # Next, prioritize bins where the item fits with the least remaining space\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_space = bins_remain_cap[fits] - item\n        priorities[fits] = 1.0 / (remaining_space + 1e-6)  # Avoid division by zero\n        \n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diffs = bins_remain_cap - item\n    # Only consider bins where the item can fit\n    valid_bins = diffs >= 0\n    if np.any(valid_bins):\n        # The best fit is the bin with the smallest difference between the item size and its remaining capacity\n        min_diff = np.min(diffs[valid_bins])\n        priorities[valid_bins] = -min_diff  # Negative since we want to maximize the priority\n\n    return priorities",
    "response_id": 1,
    "obj": 4.487435181491823,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Assign highest priority to bins that exactly fit the item\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, assign priority based on how close the bin capacity is to the item size,\n    # favoring smaller bins with remaining capacity close to the item size.\n    if np.sum(priorities) == 0:\n        diff = np.abs(bins_remain_cap - item)\n        priorities = 1.0 / (diff + 1e-6)  # Adding a small value to avoid division by zero\n    return priorities",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n    distances = remaining_capacities - item\n    \n    # Inverse distance: smaller distance gets higher priority\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)  # Add a small epsilon to avoid division by zero\n    \n    return priorities",
    "response_id": 5,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin using a sigmoid function\n    # Fit score = sigmoid( (bin_remaining_capacity - item) / item)\n    # The sigmoid function ensures that the fit score is between 0 and 1\n    # A higher fit score indicates a better fit for the item\n\n    fit_scores = 1 / (1 + np.exp(-(bins_remain_cap - item) / item))\n\n    # Penalize bins that are nearly full, promoting filling smaller bins first.  Scale factor helps finetuning\n    #scale_factor = 0.1\n    #penalties = np.exp(-bins_remain_cap / (item * scale_factor))\n    #priorities = fit_scores * (1 - penalties)\n\n    #Adjust fit_scores with a small penalty for bins with extremely low remaining capacity, so prevent divide by zero.\n    #priorities = np.where(bins_remain_cap < 1e-6, -np.inf, fit_scores)\n\n    priorities = fit_scores\n\n    return priorities",
    "response_id": 6,
    "obj": 149.27203829278022,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 48.43204266092217,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = (bins_remain_cap == item)\n    priorities[exact_fit] = 1000  # High priority for exact fit\n\n    # Then prioritize bins where the item fits with minimal waste\n    waste = bins_remain_cap - item\n    priorities[waste >= 0] = 1 / (waste[waste >= 0] + 1e-6) # Avoid division by zero\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.60791492653966,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Probability of exploration.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the 'greedy' priority - Best Fit Decreasing heuristic\n    eligible_bins = bins_remain_cap >= item\n    if np.any(eligible_bins):\n        remaining_space = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = 1.0 / (remaining_space + 1e-6)  # Add a small value to avoid division by zero\n\n    # Exploration: Assign a random priority to some bins\n    if np.random.rand() < epsilon:\n        num_explore = np.random.randint(1, len(bins_remain_cap) + 1)\n        explore_indices = np.random.choice(len(bins_remain_cap), num_explore, replace=False)\n        for idx in explore_indices:\n            if bins_remain_cap[idx] >= item:\n                priorities[idx] = np.random.rand() #assigning random exploration value\n            else:\n                priorities[idx] = -1 # to avoid placing it \n\n    return priorities",
    "response_id": 8,
    "obj": 4.2580773833266905,
    "SLOC": 15.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 94.01164534875782,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate fit score for each bin\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Calculate softmax probabilities\n    if np.sum(fit_scores) > 0:  # Avoid division by zero if no bins can fit\n        exp_fit_scores = np.exp(fit_scores / 1.0)  # Adjust temperature 1.0 as needed\n        probabilities = exp_fit_scores / np.sum(exp_fit_scores)\n    else:\n        probabilities = np.zeros_like(bins_remain_cap)\n\n    return probabilities",
    "response_id": 9,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin capacity and the item size\n    diff = bins_remain_cap - item\n    # Assign a priority based on how close the remaining capacity is to the item size\n    # Prefer bins where the item fits exactly or leaves a small remaining space.\n    # Handle cases where the item doesn't fit in a bin (diff < 0) by assigning a very low priority.\n    priorities = np.where(diff >= 0, -diff, -np.inf)\n\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    worst_fit_capacity = np.max(bins_remain_cap[valid_bins])\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = bins_remain_cap[i] - item\n    return priorities",
    "response_id": 12,
    "obj": 149.30195452732352,
    "SLOC": 10.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin, using Almost Full Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Calculate the ratio of item size to remaining bin capacity.\n    # Prioritize bins where the item fits almost perfectly,\n    # but avoid bins that are too small.\n\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = (bins_remain_cap[i] - item) / bins_remain_cap[i]\n\n    return priorities",
    "response_id": 13,
    "obj": 4.487435181491823,
    "SLOC": 6.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 27.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1000  # Very high priority\n\n    # Next best fit based on remaining capacity (smaller is better)\n    remaining_capacities = bins_remain_cap[bins_remain_cap >= item]\n    if len(remaining_capacities) > 0:\n        min_waste = np.min(remaining_capacities - item)\n        waste_indices = np.where(bins_remain_cap >= item)[0]\n\n        for i in waste_indices:\n            if bins_remain_cap[i] >= item:\n                priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)\n    \n    return priorities",
    "response_id": 14,
    "obj": 4.198244914240141,
    "SLOC": 12.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 110.36149671375918,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the distance between the item size and the remaining capacity of each bin.\n    distances = np.abs(bins_remain_cap - item)\n\n    # Handle the case where a bin has exactly the item size to avoid division by zero.\n    distances[distances == 0] = 1e-6  # Replace 0 with a very small value\n\n    # Calculate the inverse distance (priority) for each bin.\n    priorities = 1.0 / distances\n\n    # If a bin's capacity is less than the item size, set its priority to 0.\n    priorities[bins_remain_cap < item] = 0\n\n    return priorities",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 38.03910001730775,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Prioritize bins where the item fits exactly\n    exact_fit = bins_remain_cap == item\n    priorities[exact_fit] = 1000  # Highest priority\n    # Then, prioritize bins where the item fits with minimal remaining capacity\n    remaining_capacity = bins_remain_cap - item\n    valid_bins = remaining_capacity >= 0\n    if np.any(valid_bins):\n        priorities[valid_bins] = 1 / (remaining_capacity[valid_bins] + 1e-6) #avoid division by zero\n    return priorities",
    "response_id": 17,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 55.506595772116384,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the 'greedy' priority: preference for bins with enough capacity.\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        fit_indices = np.where(valid_bins)[0]\n        # Prioritize bins with the smallest remaining capacity.\n        priorities[fit_indices] = 1.0 / (bins_remain_cap[fit_indices] - item + 1e-6)\n\n    # Epsilon-greedy exploration: randomly assign priority to some bins.\n    if np.random.rand() < epsilon:\n        random_bins = np.random.choice(num_bins, size=min(num_bins, 5), replace=False)  # Explore up to 5 bins.\n        priorities[random_bins] = np.random.rand(len(random_bins))\n\n    return priorities",
    "response_id": 18,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 57.110323830864054,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    \n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Normalize the fit scores using softmax to get probabilities\n    \n    # Avoid division by zero by adding a small value to all scores\n    fit_scores = np.maximum(fit_scores, 1e-6)\n    \n    exp_fit_scores = np.exp(fit_scores)\n    \n    softmax_probs = exp_fit_scores / np.sum(exp_fit_scores)\n\n    return softmax_probs",
    "response_id": 19,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 25.26619429851844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the item size and the remaining capacity of each bin\n    diffs = bins_remain_cap - item\n    # Assign priority based on the smallest difference (Best Fit)\n    # We want to prioritize bins where the item fits with the least amount of leftover space.\n    # Avoid bins where the item doesn't fit (diff < 0) by assigning them a very low priority (-1).\n    for i in range(len(bins_remain_cap)):\n        if diffs[i] >= 0:\n            priorities[i] = diffs[i]  # Higher priority for smaller difference\n        else:\n            priorities[i] = -1      # Very low priority for bins that can't fit the item\n    return priorities",
    "response_id": 21,
    "obj": 149.30195452732352,
    "SLOC": 9.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin capacity and the item size\n    differences = bins_remain_cap - item\n\n    # Only consider bins that can accommodate the item\n    valid_bins = differences >= 0\n\n    if not np.any(valid_bins):\n        return priorities  # No bin can accommodate the item\n\n    # Assign priority based on the remaining capacity.  Bigger remaining cap, higher priority.\n    priorities[valid_bins] = differences[valid_bins]\n\n    return priorities",
    "response_id": 22,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 24.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Exact Fit First strategy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Give highest priority to bins that have exact fit\n    exact_fit_bins = (bins_remain_cap == item)\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize bins with least remaining capacity that can still accommodate the item.\n    # However, we only give a small boost to these bins, to avoid always selecting these\n    # if no exact fit is found. We want exact fit first.\n    possible_bins = bins_remain_cap >= item\n    if np.any(possible_bins):\n        min_remaining = np.min(bins_remain_cap[possible_bins])\n        for i in range(len(bins_remain_cap)):\n            if possible_bins[i]:\n                if bins_remain_cap[i] == min_remaining:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.1\n    return priorities",
    "response_id": 24,
    "obj": 4.487435181491823,
    "SLOC": 14.0,
    "cyclomatic_complexity": 5.0,
    "halstead": 23.264662506490403,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    \n    # Avoid division by zero. Add a small epsilon to the denominator.\n    epsilon = 1e-6\n    \n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diff = np.abs(bins_remain_cap - item)\n\n    # For bins that have sufficient capacity, the priority is inversely proportional to the difference.\n    # This favors bins where the item fits snugly.\n    # For bins that don't have sufficient capacity, assign a very low priority.\n    \n    sufficient_capacity = bins_remain_cap >= item\n    \n    priorities[sufficient_capacity] = 1.0 / (diff[sufficient_capacity] + epsilon)\n    \n    return priorities",
    "response_id": 25,
    "obj": 4.198244914240141,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 39.863137138648355,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Apply the sigmoid function to the fit scores\n    # Sigmoid function: f(x) = 1 / (1 + exp(-k * (x - x0)))\n    # Parameters:\n    #   k: Steeperness of the curve\n    #   x0: Midpoint of the curve\n\n    k = 2  # Adjust k to control the sigmoid steepness\n    x0 = 0.5  # Adjust x0 to control where the sigmoid transitions\n\n    priorities = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n\n    # Normalize priorities to avoid extreme values.  Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities))\n    \n    return priorities",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 7.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 114.20025299224778,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Find bins that can accommodate the item\n    suitable_bins = bins_remain_cap >= item\n\n    # If no bin can accommodate the item, return zeros\n    if not np.any(suitable_bins):\n        return np.zeros_like(bins_remain_cap)\n\n    # Assign random priorities to suitable bins.  Smaller remainder gives higher priority\n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[suitable_bins] = bins_remain_cap[suitable_bins] - item\n\n    # normalize the priority value with the total bins_remain_cap value\n    priorities = priorities / np.sum(bins_remain_cap)\n\n    return priorities",
    "response_id": 27,
    "obj": 149.30195452732352,
    "SLOC": 8.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 36.541209043760986,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, epsilon: float = 0.1) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Epsilon-Greedy.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        epsilon: Exploration rate.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    n_bins = len(bins_remain_cap)\n    priorities = np.zeros(n_bins)\n\n    # Calculate the 'greedy' priority - how well the item fits.\n    feasible_bins = bins_remain_cap >= item\n    if np.any(feasible_bins):\n        fit_scores = bins_remain_cap[feasible_bins] - item  # How much space is left after adding the item\n        priorities[feasible_bins] = fit_scores / bins_remain_cap[feasible_bins]  # Normalize by bin capacity. Higher is better.\n\n    # Epsilon-greedy exploration\n    if np.random.random() < epsilon:\n        # Explore: Assign a random priority to each bin, even if the item doesn't fit\n        priorities = np.random.rand(n_bins)\n\n    return priorities",
    "response_id": 28,
    "obj": 138.7614678899083,
    "SLOC": 10.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 41.51317942364757,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    return priorities\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Softmax-Based Fit strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin (how well the item fits into the remaining capacity).\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n    \n    # Normalize the fit scores using softmax to get probability-like priorities.\n    # Add a small epsilon to avoid division by zero and to ensure probabilities sum to 1.\n    epsilon = 1e-8\n    exp_fit_scores = np.exp(fit_scores / (max(fit_scores) + epsilon))\n    priorities = exp_fit_scores / (np.sum(exp_fit_scores) + epsilon)\n\n    return priorities",
    "response_id": 29,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 66.60791492653966,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response0.txt_stdout.txt",
    "code_path": "problem_iter2_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Assign highest priority to bins that exactly fit the item\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, assign priority based on how close the bin capacity is to the item size,\n    # favoring smaller bins with remaining capacity close to the item size.\n    if np.sum(priorities) == 0:\n        # Prioritize bins where the item can fit\n        valid_bins = bins_remain_cap >= item\n        if np.any(valid_bins):\n            fit_indices = np.where(valid_bins)[0]\n            diff = bins_remain_cap[fit_indices] - item\n            priorities[fit_indices] = 1.0 / (diff + 1e-6)  # Smaller difference = higher priority\n\n    return priorities",
    "response_id": 0,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 68.53238859703687,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response1.txt_stdout.txt",
    "code_path": "problem_iter2_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Sigmoid Fit Score.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Apply the sigmoid function to the fit scores\n    # Sigmoid function: f(x) = 1 / (1 + exp(-k * (x - x0)))\n    # Parameters:\n    # k: Steeperness of the curve\n    # x0: Midpoint of the curve\n    k = 2  # Adjust k to control the sigmoid steepness\n    x0 = 0.5  # Adjust x0 to control where the sigmoid transitions\n\n    # Avoid division by zero or inf by setting a minimum remaining capacity\n    bins_remain_cap = np.maximum(bins_remain_cap, 1e-6)\n    fit_scores = item / bins_remain_cap\n\n    priorities = 1 / (1 + np.exp(-k * (fit_scores - x0)))\n\n    # Normalize priorities to avoid extreme values. Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities) + 1e-8)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 144.75398259382442,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response2.txt_stdout.txt",
    "code_path": "problem_iter2_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin: how well the item fits in the remaining capacity\n    fit_scores = np.where(bins_remain_cap >= item, bins_remain_cap - item, 0)\n\n    # Normalize the fit scores using softmax to get probabilities\n    # Avoid division by zero by adding a small value to all scores\n    fit_scores = np.maximum(fit_scores, 1e-6)\n    exp_fit_scores = np.exp(fit_scores)\n    softmax_probs = exp_fit_scores / np.sum(exp_fit_scores)\n\n    return softmax_probs",
    "response_id": 2,
    "obj": 149.30195452732352,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 25.26619429851844,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the fit score for each bin\n    fit_scores = item / bins_remain_cap\n\n    # Calculate the fullness score for each bin (lower is better)\n    fullness_scores = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # Combine fit and fullness scores\n    combined_scores = fit_scores - fullness_scores\n\n    # Apply the sigmoid function to the combined scores\n    k = 2  # Adjust k to control the sigmoid steepness\n    x0 = 0.5  # Adjust x0 to control where the sigmoid transitions\n    priorities = 1 / (1 + np.exp(-k * (combined_scores - x0)))\n\n    # Normalize priorities to avoid extreme values. Helps prevent a single bin always being favored\n    priorities = (priorities - np.min(priorities)) / (np.max(priorities) - np.min(priorities))\n\n    return priorities",
    "response_id": 3,
    "obj": 86.58755484643,
    "SLOC": 9.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 162.53496664211536,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response5.txt_stdout.txt",
    "code_path": "problem_iter2_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    epsilon = 1e-6\n\n    # Calculate the difference between the item size and the remaining capacity of each bin.\n    diff = np.abs(bins_remain_cap - item)\n\n    # Prioritize bins where the item fits snugly.\n    sufficient_capacity = bins_remain_cap >= item\n    priorities[sufficient_capacity] = 1.0 / (diff[sufficient_capacity] + epsilon)\n\n    # Penalize nearly full bins.\n    nearly_full = bins_remain_cap < item * 0.1\n    priorities[nearly_full] = -1.0\n\n    # Penalize almost empty bins.\n    almost_empty = bins_remain_cap > 0.9\n    priorities[almost_empty] = -0.5\n\n    return priorities",
    "response_id": 5,
    "obj": 4.487435181491823,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 104.2481250360578,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit_indices = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_indices] = 1.0\n\n    # Next best fit based on remaining capacity (smaller waste is better)\n    valid_bins = bins_remain_cap >= item\n    if np.any(valid_bins):\n        waste = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = 1.0 / (waste + 1e-6)\n\n    return priorities",
    "response_id": 6,
    "obj": 4.198244914240141,
    "SLOC": 9.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 53.77443751081735,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response7.txt_stdout.txt",
    "code_path": "problem_iter2_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Prioritize exact fits\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1000.0\n\n    # If no exact fit, prioritize bins with minimal waste\n    remaining_bins = np.where(priorities == 0)[0]\n    if len(remaining_bins) > 0:\n        waste = bins_remain_cap[remaining_bins] - item\n        valid_bins = remaining_bins[waste >= 0]\n\n        if len(valid_bins) > 0:\n            # Prioritize bins that are less full (higher remaining capacity)\n            # and minimize waste.\n            priorities[valid_bins] = (bins_remain_cap[valid_bins] / (item + 1e-6)) / (waste[waste >= 0] + 1e-6)\n\n    return priorities",
    "response_id": 7,
    "obj": 4.198244914240141,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 142.62362713128297,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response8.txt_stdout.txt",
    "code_path": "problem_iter2_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit Decreasing strategy.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    # Calculate the difference between the bin capacity and the item size\n    diff = bins_remain_cap - item\n    # Assign a priority based on how close the remaining capacity is to the item size\n    # Prefer bins where the item fits exactly or leaves a small remaining space.\n    # Handle cases where the item doesn't fit in a bin (diff < 0) by assigning a very low priority.\n    priorities = np.where(diff >= 0, -diff, -np.inf)\n    return priorities",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 30.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response9.txt_stdout.txt",
    "code_path": "problem_iter2_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    valid_bins = bins_remain_cap >= item\n    if np.sum(valid_bins) == 0:\n        return priorities\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n    distances = np.abs(remaining_capacities - item)\n    \n    # Prioritize bins where the remaining capacity is close to the item size\n    priorities[valid_bins] = 1.0 / (distances + 1e-6)\n    \n    # Further boost priority for bins with smaller remaining capacities (avoiding large gaps)\n    priorities[valid_bins] *= remaining_capacities \n    \n    return priorities",
    "response_id": 9,
    "obj": 4.198244914240141,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 72.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact Fit First: Highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # Calculate waste and normalized distance to item size\n    remaining_bins = np.where(priorities == 0)[0]\n    if len(remaining_bins) > 0:\n        waste = bins_remain_cap[remaining_bins] - item\n        normalized_distance = waste / item\n        \n        # Sigmoid function to score nuanced fits (avoiding near-empty or near-full bins)\n        # Adjust steepness and center for desired behavior\n        steepness = 2.0\n        center = 0.1  # Shifted to favor bins closer to being full but not completely full\n        sigmoid_scores = 1 / (1 + np.exp(-steepness * (normalized_distance - center)))\n        \n        # Normalize scores to avoid large differences\n        priorities[remaining_bins] = sigmoid_scores\n\n    return priorities",
    "response_id": 0,
    "obj": 4.208216992421225,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 129.32351694048162,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response1.txt_stdout.txt",
    "code_path": "problem_iter3_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit gets highest priority\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 2.0  # Higher than other priorities\n\n    # Calculate waste and distance from ideal fill (half-full)\n    waste = bins_remain_cap - item\n    distance_from_half = np.abs(bins_remain_cap - (1.0))  # Assuming bin capacity is 1.0\n\n    # Use a sigmoid function to score nuanced fits, normalizing by item size\n    sigmoid_scores = 1.0 / (1.0 + np.exp(-(bins_remain_cap - item) / item))\n    \n    # Combine factors: prioritize minimal waste, distance to half, and sigmoid score\n    priorities = np.where(priorities == 0,\n                          0.5 * sigmoid_scores + 0.3 / (waste + 1e-6) - 0.2 * distance_from_half,\n                          priorities)\n\n    return priorities",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 209.21505009519265,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, calculate priority based on waste and bin fullness\n    if np.sum(priorities) == 0:\n        diff = np.abs(bins_remain_cap - item)\n        waste = diff  # Waste is simply the absolute difference\n        \n        # Sigmoid function to normalize waste and bin fullness\n        fullness = bins_remain_cap\n        \n        # Avoid division by zero and overly strong preference for very small bins\n        normalized_waste = waste / (item + 1e-6)\n        normalized_fullness = fullness / (1.0 + 1e-6) # Scale bin fullness\n        \n        # Combine waste and bin fullness. Lower waste and medium fullness is best.\n        priority = np.exp(-normalized_waste) * normalized_fullness\n        priorities = priority\n\n    return priorities",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 110.44611534953322,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response3.txt_stdout.txt",
    "code_path": "problem_iter3_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Exact fit first\n    exact_fit_bins = np.where(bins_remain_cap == item)[0]\n    priorities[exact_fit_bins] = 1.0\n\n    # If no exact fit, prioritize based on minimizing waste and avoiding near-empty/full bins\n    if np.sum(priorities) == 0:\n        diff = np.abs(bins_remain_cap - item)\n        # Sigmoid function to score nuanced fits\n        sigmoid_input = -diff  # Negative difference for sigmoid\n        priorities = 1.0 / (1.0 + np.exp(-0.5 * sigmoid_input))  # Sigmoid function\n\n        # Normalize priorities based on bin fullness\n        fullness = 1.0 - (bins_remain_cap / np.max(bins_remain_cap))\n        priorities = priorities * (1.0 - fullness)  # Penalize almost full bins\n\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 151.6206750336681,
    "exec_success": true
  }
]