```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item without
    leaving excessive space. It aims to balance fitting the item and
    avoiding fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility check: Can the item fit?
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        return priorities  # No feasible bins, all priorities remain zero

    # 2. Calculate remaining space after placing the item
    remaining_space = bins_remain_cap[feasible_bins] - item

    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins
    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)
    #    and not too large (to avoid fragmentation)
    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size
    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size

    # 4. Give a bonus to bins that are reasonably full after placing the item
    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)
    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity

    # 5. Combine factors
    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus

    return priorities
```
