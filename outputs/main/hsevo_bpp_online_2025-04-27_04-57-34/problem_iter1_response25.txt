```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the dance of planets! We favour bins where the item fits comfortably (like Venus nestled near the Sun), but also consider bins nearing fullness (like Jupiter pulling objects into its orbit).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # First, consider only bins that can accommodate the item. Ignore those that cannot.
    feasible_bins = bins_remain_cap >= item
    
    if not np.any(feasible_bins):
        # No suitable bin exists. Return very low priorities. This will likely result in opening a new bin.
        return priorities

    #Calculate emptiness - bigger values mean less space
    emptiness = 1 - (bins_remain_cap / np.max(bins_remain_cap))

    # A measure of 'fit'. Smaller ratios are better (item fits comfortably).
    fit_ratios = item / bins_remain_cap
    
    # Scale the fit ratio to be between 0 and 1. We take exponent of 1 / fitness for making differences more distinct.
    # Subtracting from 1 in the power will decrease impact for tight fitting bins and increase the impact of lose fitting bins
    scaled_fit = (1 - np.clip(fit_ratios, 0, 1)) ** (1/3)
    
    # Increase reward of filling up space of the bin
    scaled_emptiness = 1 / (1 + emptiness)

    # Final score with two combined bonuses
    priorities = feasible_bins * (scaled_fit + scaled_emptiness)

    return priorities
```
