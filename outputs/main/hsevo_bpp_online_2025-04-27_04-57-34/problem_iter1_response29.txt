```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins with remaining capacity slightly larger than the item size
    to avoid excessive fragmentation. It also disincentivizes bins that are too full or too empty.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    for i, cap in enumerate(bins_remain_cap):
        if cap < item:
            priorities[i] = -np.inf  # Cannot fit
        else:
            # Heuristic: Higher priority for bins that can fit the item snugly.

            # Base priority is inverse of wasted space. Small waste is good. Avoid too full
            wasted_space = cap - item
            priorities[i] = -wasted_space

            # Bonus for not being too empty either. Want to actually fill a bin
            bin_size = 1 # Assuming bins of size 1 for now; generalize as needed if the problem is more general.

            if wasted_space > 0.5 * bin_size:
                priorities[i] -= 0.5 # Slightly penalize bins with too much remaining space
            
            # Additional encouragement for utilizing partially filled bins if possible.
            # This encourages filling bins beyond some level before opening new ones.
            fill_level = (bin_size - cap) / bin_size
            if fill_level > 0.25: # If already 25% full, encourage filling more
                priorities[i] += fill_level
                
    return priorities
```
