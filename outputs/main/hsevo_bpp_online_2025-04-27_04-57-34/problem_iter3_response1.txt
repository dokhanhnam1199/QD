```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version refines the priority calculation by:
    1. Adding a "best fit" bonus to prioritize bins that closely match the item size.
    2. Introducing a penalty for bins that are significantly larger than the item,
       but making this penalty adaptive to the item size.
    3. Incorporating a small random factor to encourage exploration and break ties.
    4. Handles edge cases with very small remaining capacities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return priorities

    valid_remain_cap = bins_remain_cap[valid_bins]

    # 1. Best Fit Bonus: Prioritize bins with capacity close to item size.
    # Smaller absolute difference gets a higher bonus.
    best_fit_bonus = np.exp(-np.abs(valid_remain_cap - item) / (0.1 * item + 1e-6))  # Added small constant to avoid division by zero

    # 2. Large Bin Penalty: Penalize bins that are much larger than the item.
    # The penalty is scaled relative to the item size.
    large_bin_threshold = 1.5 * item  # Example: Penalize bins > 1.5x item size
    large_bin_penalty = np.where(valid_remain_cap > large_bin_threshold,
                                 0.5 * (1 - np.exp(-(valid_remain_cap - large_bin_threshold) / (0.5 * item + 1e-6))), # added small constant to denominator
                                 1.0)

    # 3. Capacity Factor: Favor bins with higher (but not too high) remaining capacity.
    capacity_factor = valid_remain_cap / np.max(valid_remain_cap)


    # 4. Small Random Factor: Break ties and encourage exploration.
    random_factor = 0.01 * np.random.rand(len(valid_remain_cap))

    # Combine all factors:
    priorities[valid_bins] = best_fit_bonus * large_bin_penalty * capacity_factor + random_factor

    # Normalize priorities to be between 0 and 1 (optional, but can be helpful)
    if np.sum(priorities) > 0 :
        priorities = priorities / np.max(priorities)

    return priorities
```
