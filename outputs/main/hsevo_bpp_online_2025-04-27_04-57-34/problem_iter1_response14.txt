```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This priority function considers the remaining capacity and penalizes bins
    that are either too full or too empty after adding the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    for i, capacity in enumerate(bins_remain_cap):
        if capacity >= item:
            remaining = capacity - item
            # Calculate a score based on how well the item fits
            # A higher score means a better fit

            # Encourage bins to be neither too full nor too empty. Ideal remaining space 0.25.
            fit_score = np.exp(-((remaining - 0.25)**2) / 0.1) # Gaussian-like fit

            # Penalize bins that are too full. Avoid near zero capacity.
            near_full_penalty = np.exp(-capacity / 0.1) # Exponential decay when close to zero
            
            #Reward higher capactiy bins, for even use, reduce frgmentation
            cap_score = capacity
            
            priorities[i] = fit_score + cap_score - near_full_penalty
        else:
            priorities[i] = -np.inf  # Cannot fit, so lowest priority
    return priorities
```
