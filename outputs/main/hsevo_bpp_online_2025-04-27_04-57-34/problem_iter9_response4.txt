```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item snugly while also
    considering the overall fullness of the bin after packing. It also adds
    a small bonus for bins that are almost full before packing the item.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
        valid_remain_cap = bins_remain_cap[valid_bins]

        # 1. Snug fit: Prioritize bins where the remaining space after adding the item is small
        remaining_space = valid_remain_cap - item
        snug_fit = np.exp(-remaining_space / item)  # Exponential decay for small remaining space

        # 2. Fullness: Prioritize bins that are already relatively full
        fullness = (np.max(bins_remain_cap) - valid_remain_cap) / np.max(bins_remain_cap)

        # 3. Almost Full Bonus: Give a boost to bins that are almost full before packing
        almost_full = np.where(valid_remain_cap <= 1.2 * item, 1.2, 1)  # Boost if remaining capacity is slightly larger than item
       
        # Combine the factors
        priorities[valid_bins] = snug_fit * (fullness+0.1) * almost_full # Adding small number to fullness to avoid zero value when bin is empty

    return priorities
```
