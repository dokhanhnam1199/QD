```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal
    waste, but also considers the overall fill level of the bins.  It tries
    to balance fitting the item well and keeping bins relatively full to avoid
    creating many nearly-empty bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins that can accommodate the item
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
        return priorities # No suitable bin, return all zeros

    # Calculate waste for valid bins
    waste = bins_remain_cap[valid_bins] - item

    # Give higher priority to bins with less waste. Add small constant to avoid division by zero
    waste_priority = 1 / (waste + 0.0001)

    # Encourage filling bins by considering remaining capacity ratio
    capacity_ratio = (bins_remain_cap[valid_bins] - item) / bins_remain_cap[valid_bins]

    # Combine waste priority and capacity ratio. The `waste_priority` component is more important than capacity_ratio
    priorities[valid_bins] = waste_priority * (1 - capacity_ratio)
        
    return priorities
```
