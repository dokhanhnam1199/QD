```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins where the item fits best with minimal wasted space,
    while also considering the overall remaining capacity. It uses a simpler, more
    interpretable scoring function than v1.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item fits
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
        valid_remain_cap = bins_remain_cap[valid_bins]

        # Waste factor: prioritize bins with minimal waste after adding the item.
        waste = valid_remain_cap - item
        # Avoid negative waste
        waste = np.maximum(waste, 0)

        # Capacity utilization: higher utilization is generally better, penalize large gaps
        utilization = item / valid_remain_cap

        # Combine waste and utilization, prioritizing minimal waste, high utilization
        priorities[valid_bins] = utilization / (waste + 0.0001) # Small value to avoid division by zero.
        # Normalizing the priority scores
        priorities[valid_bins] = priorities[valid_bins] / np.max(priorities[valid_bins])

    return priorities
```
