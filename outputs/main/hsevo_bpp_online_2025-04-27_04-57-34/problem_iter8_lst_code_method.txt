{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities balancing waste, capacity utilization, and a fill bonus.\"\"\"\n\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(eligible_bins):\n        waste = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -waste # Prioritize smaller waste\n\n        # Capacity utilization\n        capacity_ratio = item / bins_remain_cap[eligible_bins]\n        priorities[eligible_bins] += np.clip(capacity_ratio, 0, 1)\n\n        # Fill bonus: bonus when item almost fills the bin\n        best_fit_threshold = 0.05 * item\n        best_fit_bonus = np.where(waste <= best_fit_threshold, 0.5, 0.0)\n        priorities[eligible_bins] += best_fit_bonus\n\n        priorities[eligible_bins] += 0.001  #Small boost for tie-breaking\n\n    else:\n        priorities[:] = -1e9 # Big penalty for bins that can't fit item\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste, utilization, and close fit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) + 1e-9\n    waste = bins_remain_cap - item\n    priorities[waste < 0] = -np.inf\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = 1.0 / (waste[valid_bins] + 1e-9)\n\n    utilization = 1.0 - bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] *= (1 + utilization[valid_bins])\n\n    close_fit_threshold = 0.1 * item\n    close_fit = (waste >= 0) & (waste <= close_fit_threshold)\n    priorities[close_fit] += 10\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits best, but also\n    considers bin utilization. It aims for a balance between fitting items\n    snugly and avoiding excessive fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: item must fit in the bin\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining capacity AFTER placing the item (if we hypothetically placed it)\n    remaining_after_placement = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize based on tightness of fit (lower remaining_after_placement is better, but avoid zero)\n    # Avoid division by zero by adding a small constant. Larger value leads to more spread.\n    fit_priority = np.exp(-remaining_after_placement / (0.1 * item)) # The constant term mitigates issues with very small remaining capacities after placement\n    # 4. Introduce a bin utilization factor.  Bins with already moderate fill are favored.\n\n    utilization = 1 - bins_remain_cap[feasible_bins] / np.max(bins_remain_cap) # Use normalized form\n    utilization_priority = utilization # Higher utilization gets higher priority (encourages fill of existing bins). Simple linear for now\n\n    # Combine fit and utilization\n    priorities[feasible_bins] = fit_priority * utilization_priority\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on waste, utilization, and close fit.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) + 1e-9\n    waste = bins_remain_cap - item\n    priorities[waste < 0] = -np.inf\n\n    valid_bins = waste >= 0\n    priorities[valid_bins] = 1.0 / (waste[valid_bins] + 1e-9)\n\n    utilization = 1.0 - bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] *= (1 + utilization[valid_bins])\n\n    close_fit_threshold = 0.1 * item\n    close_fit = (waste >= 0) & (waste <= close_fit_threshold)\n    priorities[close_fit] += 10\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by balancing waste, capacity, and best-fit.\"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(eligible_bins):\n        waste = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -waste \n\n        capacity_factor = bins_remain_cap[eligible_bins] / np.max(bins_remain_cap)\n        priorities[eligible_bins] += capacity_factor\n\n        best_fit_bonus = np.exp(-np.abs(waste) / (0.1 * item + 1e-6))\n        priorities[eligible_bins] += best_fit_bonus\n\n    else:\n        priorities[:] = -1e9\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by balancing waste, capacity, and best-fit.\"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(eligible_bins):\n        waste = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -waste \n\n        capacity_factor = bins_remain_cap[eligible_bins] / np.max(bins_remain_cap)\n        priorities[eligible_bins] += capacity_factor\n\n        best_fit_bonus = np.exp(-np.abs(waste) / (0.1 * item + 1e-6))\n        priorities[eligible_bins] += best_fit_bonus\n\n    else:\n        priorities[:] = -1e9\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, waste_weight: float = -1.6135313844546284, capacity_weight: float = 0.4827923108235661, best_fit_scale: float = 0.36801645219525525, best_fit_epsilon: float = 6.685130548419745e-06, ineligible_priority: float = -9949787255.26964) -> np.ndarray:\n    \"\"\"Prioritizes bins by balancing waste, capacity, and best-fit.\"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(eligible_bins):\n        waste = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = waste_weight * waste\n\n        capacity_factor = bins_remain_cap[eligible_bins] / np.max(bins_remain_cap)\n        priorities[eligible_bins] += capacity_weight * capacity_factor\n\n        best_fit_bonus = np.exp(-np.abs(waste) / (best_fit_scale * item + best_fit_epsilon))\n        priorities[eligible_bins] += best_fit_bonus\n\n    else:\n        priorities[:] = ineligible_priority\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by balancing waste, capacity, and best-fit.\"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(eligible_bins):\n        waste = bins_remain_cap[eligible_bins] - item\n        priorities[eligible_bins] = -waste \n\n        capacity_factor = bins_remain_cap[eligible_bins] / np.max(bins_remain_cap)\n        priorities[eligible_bins] += capacity_factor\n\n        best_fit_bonus = np.exp(-np.abs(waste) / (0.1 * item + 1e-6))\n        priorities[eligible_bins] += best_fit_bonus\n\n    else:\n        priorities[:] = -1e9\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit with capacity-aware bonus.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    feasible_mask = ~infeasible_mask\n    if not np.any(feasible_mask):\n        return priorities\n\n    remaining_capacities_after_fit = bins_remain_cap[feasible_mask] - item\n    space_score = -np.abs(remaining_capacities_after_fit)\n\n    # Capacity-aware bonus\n    capacity_ratio = bins_remain_cap[feasible_mask] / bins_remain_cap.max()\n    bonus = capacity_ratio # Directly use capacity as bonus\n    priorities[feasible_mask] = space_score + bonus\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Utilizes a combination of factors, inspired by gravitational attraction and\n    the principle of minimizing wasted space. Higher remaining capacity with closer\n    size to the item results in higher priority, encouraging efficient packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Ensure bins_remain_cap is a numpy array to handle potential errors\n    bins_remain_cap = np.array(bins_remain_cap)\n\n    # Avoid division by zero and negative values inside log\n    valid_bins = bins_remain_cap > 0\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)  # Initialize all priorities to 0\n\n    if np.any(valid_bins): # only compute priority if at least one bin is non-empty\n        valid_remain_cap = bins_remain_cap[valid_bins]\n\n        # Proximity factor: smaller difference between item and bin capacity is better\n        proximity = np.exp(-np.abs(valid_remain_cap - item) / item)\n\n        # Capacity factor: higher remaining capacity is generally better, but penalize bins that are too large compared to the item\n        capacity = valid_remain_cap / np.max(valid_remain_cap)\n        capacity_penalty = np.where(valid_remain_cap > 2 * item, 0.5, 1) # slightly penalize bins where capacity is way larger than the item\n\n        # Combine factors to produce priority\n        priorities[valid_bins] = proximity * capacity * capacity_penalty\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item without\n    leaving excessive space. It aims to balance fitting the item and\n    avoiding fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    bins_remain_cap = np.array(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Can the item fit?\n    feasible_bins = bins_remain_cap >= item\n\n    if not np.any(feasible_bins):\n        return priorities  # No feasible bins, all priorities remain zero\n\n    # 2. Calculate remaining space after placing the item\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # 3. Prioritize bins with smaller remaining space, but penalize near-full bins\n    #    The ideal remaining space is not zero (to avoid perfect fits that may block later, larger items)\n    #    and not too large (to avoid fragmentation)\n    # proximity_to_ideal = np.exp(-np.abs(remaining_space - (item/2)) / item) # Ideal remaining space is half the item size\n    proximity_to_ideal = np.exp(-np.abs(remaining_space - (0.2 * item)) / item) # Ideal remaining space is 20% of item size\n\n    # 4. Give a bonus to bins that are reasonably full after placing the item\n    fullness_bonus = np.clip((bins_remain_cap[feasible_bins] - remaining_space) / np.max(bins_remain_cap), 0, 1)\n    fullness_bonus = fullness_bonus * 0.5  # Scale the bonus to avoid dominating the proximity\n\n    # 5. Combine factors\n    priorities[feasible_bins] = proximity_to_ideal + fullness_bonus\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}