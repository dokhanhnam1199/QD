```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins that can accommodate the item closely
    (minimizing wasted space), but also avoids bins that are *too* close,
    to preserve options for larger items later.  It penalizes bins
    that cannot fit the item strongly.  Uses a sigmoid-like function to
    shape the priorities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Penalize bins that cannot fit the item.  Give them a very negative priority.
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -1e9  # Extremely low priority

    # For feasible bins, compute a score based on remaining space
    feasible_bins = ~infeasible_bins
    remaining_space = bins_remain_cap[feasible_bins] - item

    # Scale remaining space to be around 0
    scaled_remaining_space = remaining_space / item

    # Use a sigmoid-like function to give higher priority to smaller remaining space,
    # but not *too* small. This encourages close fits without filling almost completely.
    # The constant values have been tuned through trial and error to acheive better packings.
    priorities[feasible_bins] = 1 / (1 + np.exp(5 - 10*scaled_remaining_space)) - 0.5*np.exp(10*scaled_remaining_space-5) #1 / (1 + np.exp(8 * scaled_remaining_space - 4))


    return priorities
```
