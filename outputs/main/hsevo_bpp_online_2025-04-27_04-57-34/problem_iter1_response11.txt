```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers the remaining capacity, the waste
    created after adding the item, and the fullness of the bin after packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    penalties = np.zeros_like(bins_remain_cap)
    # Infinite penalty for bins that cannot fit the item
    penalties[bins_remain_cap < item] = np.inf

    # Waste calculation
    waste = bins_remain_cap - item
    waste[waste < 0] = np.inf  # Effectively handled by penalties above, but still

    # A smaller waste is better, but not the only factor

    # Fullness after packing, try to aim for a certain fullness threshold
    fullness_after = (bins_remain_cap - waste) / np.max(bins_remain_cap) # Normalize bin capacity, assuming all the bins have the same capacity
    target_fullness = 0.8  # Aim for around 80% fullness

    # Cost of being away from target fullness
    fullness_cost = np.abs(fullness_after - target_fullness)

    # Combine the cost/benefits
    priority = - (1 / (waste + 1e-9) + np.exp(-fullness_cost)) - penalties # small waste -> high priority; fullness near target -> high priority, high penalties-> low priority

    return priority
```
