```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Utilizes a combination of factors, inspired by gravitational attraction and
    the principle of minimizing wasted space. Higher remaining capacity with closer
    size to the item results in higher priority, encouraging efficient packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Ensure bins_remain_cap is a numpy array to handle potential errors
    bins_remain_cap = np.array(bins_remain_cap)

    # Avoid division by zero and negative values inside log
    valid_bins = bins_remain_cap > 0
    priorities = np.zeros_like(bins_remain_cap, dtype=float)  # Initialize all priorities to 0

    if np.any(valid_bins): # only compute priority if at least one bin is non-empty
        valid_remain_cap = bins_remain_cap[valid_bins]

        # Proximity factor: smaller difference between item and bin capacity is better
        proximity = np.exp(-np.abs(valid_remain_cap - item) / item)

        # Capacity factor: higher remaining capacity is generally better, but penalize bins that are too large compared to the item
        capacity = valid_remain_cap / np.max(valid_remain_cap)
        capacity_penalty = np.where(valid_remain_cap > 2 * item, 0.5, 1) # slightly penalize bins where capacity is way larger than the item

        # Combine factors to produce priority
        priorities[valid_bins] = proximity * capacity * capacity_penalty
    return priorities
```
