```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that closely fit the item, but also considers
    the overall fill level of the bin.  It introduces a non-linear scaling
    to the capacity and proximity factors, and provides a mechanism to penalize
    overfilling or leaving too much space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap > 0

    if not np.any(valid_bins):
        return priorities

    valid_remain_cap = bins_remain_cap[valid_bins]

    # Proximity factor: closer fit is better, with sigmoid scaling
    proximity = np.exp(-np.abs(valid_remain_cap - item) / (0.5 * item))  # Scale by half the item size

    # Capacity factor: scaled to emphasize bins that are already somewhat full
    capacity = (valid_remain_cap / np.max(bins_remain_cap))**0.5 # square root
    
    # Overfill Penalty: avoid overfilling the bins
    overfill_penalty = np.where(valid_remain_cap < item, 0, 1)
    
    # Waste penalty: Slightly penalize if the remaining capacity is too large compared to item
    waste_threshold = 1.75 * item
    waste_penalty = np.where(valid_remain_cap > waste_threshold, 0.75, 1) # slight penalty

    # Combine factors, scaling for fine tuning
    priorities[valid_bins] = proximity * capacity * overfill_penalty * waste_penalty

    return priorities
```
