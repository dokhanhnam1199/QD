```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines best aspects of v0 and v1, balancing fit and fragmentation."""
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Infeasible bins get a very low priority
    infeasible_bins = bins_remain_cap < item
    priorities[infeasible_bins] = -1e9

    # Perfect fit gets highest priority
    perfect_fit = np.isclose(bins_remain_cap, item)
    priorities[perfect_fit] = 1e9

    # Prioritize bins with smaller remaining space, but avoid near-full
    feasible_bins = ~infeasible_bins & ~perfect_fit
    remaining_space = bins_remain_cap[feasible_bins] - item
    scaled_remaining_space = remaining_space / item
    priorities[feasible_bins] = 1 / (1 + np.exp(5 - 10*scaled_remaining_space)) - 0.5*np.exp(10*scaled_remaining_space-5)

    # Penalize bins with large leftover space
    large_leftover = (bins_remain_cap > item) & (bins_remain_cap - item > np.mean(bins_remain_cap))
    priorities[large_leftover] = -50

    return priorities
```
