{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Iterate through each bin and calculate its priority.\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if remaining_capacity >= item:  # Can the item fit?\n\n            # Heuristic 1: Maximize filled space. A bin closer to being full after placement gets higher priority.\n            fill_ratio = item / remaining_capacity\n            priorities[i] += fill_ratio\n\n            # Heuristic 2: Minimize wasted space (if item fits perfectly).\n            if remaining_capacity - item < 1e-6: # consider very small difference as equals\n                priorities[i] += 1.0  # Boost priority if item fits perfectly\n            else:\n                 # Heuristic 3: Avoid Fragmentation.\n                 priorities[i] +=  1.0 / (remaining_capacity-item)\n\n\n        else:\n            priorities[i] = -np.inf  # Very low priority if item doesn't fit.\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    eligible_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if np.any(eligible_bins):\n        # Prioritize bins with capacity closest to item size (minimize waste)\n        waste = bins_remain_cap - item\n        waste[~eligible_bins] = np.inf  # Ignore ineligible bins\n        priorities[eligible_bins] = -np.abs(waste[eligible_bins])\n\n        # Also, factor in the remaining capacity as a secondary priority.\n        # This helps to fill bins more completely before opening new ones, but after minimizing waste for existing candidates.\n        priorities[eligible_bins] += bins_remain_cap[eligible_bins] / np.max(bins_remain_cap) # scale to between 0 and 1 for balance\n\n        # A small constant bonus can help break ties between bins with very similar remaining capacities.\n        priorities[eligible_bins] += 0.001\n\n    else:\n        # If no bin can fit the item, assign all bins very negative priority to avoid selecting them (effectively creating a new bin).\n        priorities[:] = -1e9\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a small value to avoid division by zero and negative infinities later\n    priorities = np.zeros_like(bins_remain_cap, dtype=float) + 1e-9\n\n    # Calculate waste if item is placed in the bin. A smaller waste is better\n    waste = bins_remain_cap - item\n    \n    # Bins that cannot fit the item get a very low priority.\n    priorities[waste < 0] = -np.inf\n\n    # Adjust priority based on the inverse of waste. Smaller waste means higher priority, but only for fitting bins\n    valid_bins = waste >= 0\n    priorities[valid_bins] = 1.0 / (waste[valid_bins] + 1e-9)  # Add a small constant to avoid division by zero\n    \n    # Incorporate bin utilization: a bin with higher initial fullness is preferred to consolidate items, provided it still fits\n    utilization = 1.0 - bins_remain_cap / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(bins_remain_cap)\n\n    priorities[valid_bins] *= (1 + utilization[valid_bins]) # Encourage filling bins that are already partly full\n\n    # Add a bonus to bins that are just large enough to accomodate the item\n    close_fit_threshold = 0.1 * item # close fit is when the waste is less than 10% of item size\n    close_fit = (waste >= 0) & (waste <= close_fit_threshold)\n    priorities[close_fit] += 10 # Boost for close fits. This is to try reduce number of bins used.\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins where the item fits (remaining capacity >= item size).\n    It aims to fill bins more completely by favoring tighter fits,\n    but also incorporates a penalty for bins that are almost full\n    to avoid extreme fragmentation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n\n    if np.any(fits):\n        # Calculate remaining space after placing the item\n        remaining_space = bins_remain_cap - item\n\n        # Prioritize bins where item fits.\n        priorities[fits] = (item / bins_remain_cap[fits])  #Fill ratio (higher is better)\n        priorities[fits] += (1 / (1 + remaining_space[fits])) # Prefer tighter fits\n\n        #Small penalty to discourage near-full packing, preventing very small fragmentations.\n        nearly_full = (bins_remain_cap[fits] - item) < 0.1  # e.g., < 0.1 considered nearly full\n        priorities[fits][nearly_full] *= 0.9 #Slight reduction for bins considered near full\n\n    else:\n         #If nothing fits, give highest priority to smallest bin. This will ensure one bin has items instead of lots with few.\n         priorities = -bins_remain_cap\n         priorities = priorities - np.min(priorities) +1e-9 #to ensure its not zero, shift all values > 0\n         pass\n\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the cosmos, where larger bodies attract smaller ones. This heuristic\n    prioritizes bins that can accommodate the item with minimal remaining space (gravity)\n    while also discouraging fragmentation of nearly full bins (stellar wind).\n    Further considerations include a probabilistic element (quantum uncertainty) to allow\n    for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Ensure capacities are positive.\n    bins_remain_cap = np.maximum(bins_remain_cap, 0)\n\n    # Initialize priorities with a base score of zero.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item.\n    fit_mask = bins_remain_cap >= item\n\n    if not np.any(fit_mask):\n        # No bin can fit the item. Assign a small, random priority to all bins.\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.0001\n        return priorities\n    # Gravity: Higher priority for bins with smaller remaining space AFTER packing, IF they can contain item.\n    remaining_after_pack = bins_remain_cap - item\n    remaining_after_pack[remaining_after_pack < 0] = np.inf #make very undesirable\n    priorities[fit_mask] += np.max(bins_remain_cap) / (remaining_after_pack[fit_mask] + 0.0001) #Add a small epsilon to avoid divide by zero.\n    # Stellar Wind: Discourage placing the item in nearly full bins to avoid creating tiny fragments.\n    nearly_full_threshold = 0.1 #consider bins with <10% capacity almost full\n    nearly_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < nearly_full_threshold)\n    priorities[nearly_full_mask] -= np.max(bins_remain_cap) * 0.5 # Reduce Priority significantly\n\n    # Quantum Uncertainty: Introduce a small degree of randomness for exploration.\n    priorities[fit_mask] += np.random.rand(np.sum(fit_mask)) * np.std(priorities[fit_mask]) * 0.01\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Inspired by the cosmos, where larger bodies attract smaller ones. This heuristic\n    prioritizes bins that can accommodate the item with minimal remaining space (gravity)\n    while also discouraging fragmentation of nearly full bins (stellar wind).\n    Further considerations include a probabilistic element (quantum uncertainty) to allow\n    for exploration.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Ensure capacities are positive.\n    bins_remain_cap = np.maximum(bins_remain_cap, 0)\n\n    # Initialize priorities with a base score of zero.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item.\n    fit_mask = bins_remain_cap >= item\n\n    if not np.any(fit_mask):\n        # No bin can fit the item. Assign a small, random priority to all bins.\n        priorities = np.random.rand(len(bins_remain_cap)) * 0.0001\n        return priorities\n    # Gravity: Higher priority for bins with smaller remaining space AFTER packing, IF they can contain item.\n    remaining_after_pack = bins_remain_cap - item\n    remaining_after_pack[remaining_after_pack < 0] = np.inf #make very undesirable\n    priorities[fit_mask] += np.max(bins_remain_cap) / (remaining_after_pack[fit_mask] + 0.0001) #Add a small epsilon to avoid divide by zero.\n    # Stellar Wind: Discourage placing the item in nearly full bins to avoid creating tiny fragments.\n    nearly_full_threshold = 0.1 #consider bins with <10% capacity almost full\n    nearly_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < nearly_full_threshold)\n    priorities[nearly_full_mask] -= np.max(bins_remain_cap) * 0.5 # Reduce Priority significantly\n\n    # Quantum Uncertainty: Introduce a small degree of randomness for exploration.\n    priorities[fit_mask] += np.random.rand(np.sum(fit_mask)) * np.std(priorities[fit_mask]) * 0.01\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign very low priority if the item doesn't fit.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit heuristic: Prioritize bins with smallest remaining capacity AFTER adding the item.\n    #   - Avoids creating too many bins with near-empty space at the end.\n    feasible_mask = ~infeasible_mask\n    remaining_capacities_after_fit = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -np.abs(remaining_capacities_after_fit) # Smaller absolute remaining capacity gets higher priority\n\n    # 3. Bonus for bins that are already somewhat full (but not too full - avoid overfilling).\n    #   A sigmoid function can be used to scale the bonus smoothly.  The parameters (location and scale)\n    #   are chosen such that it peaks around 0.7 * bins_remain_cap initially and flattens out to zero as the\n    #   remaining capacity decreases to 0 (or increases beyond the ideal point). This encourages using already used bins.\n    # bins_used_ratio = (np.max(bins_remain_cap) - bins_remain_cap[feasible_mask]) / np.max(bins_remain_cap)\n    bins_used_ratio = (bins_remain_cap.max() - bins_remain_cap[feasible_mask]) / bins_remain_cap.max()\n\n    bonus = 1 / (1 + np.exp(-10 * (bins_used_ratio - 0.7)))\n    priorities[feasible_mask] += bonus\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Feasibility check: Assign very low priority if the item doesn't fit.\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf\n\n    # 2. Best Fit heuristic: Prioritize bins with smallest remaining capacity AFTER adding the item.\n    #   - Avoids creating too many bins with near-empty space at the end.\n    feasible_mask = ~infeasible_mask\n    remaining_capacities_after_fit = bins_remain_cap[feasible_mask] - item\n    priorities[feasible_mask] = -np.abs(remaining_capacities_after_fit) # Smaller absolute remaining capacity gets higher priority\n\n    # 3. Bonus for bins that are already somewhat full (but not too full - avoid overfilling).\n    #   A sigmoid function can be used to scale the bonus smoothly.  The parameters (location and scale)\n    #   are chosen such that it peaks around 0.7 * bins_remain_cap initially and flattens out to zero as the\n    #   remaining capacity decreases to 0 (or increases beyond the ideal point). This encourages using already used bins.\n    # bins_used_ratio = (np.max(bins_remain_cap) - bins_remain_cap[feasible_mask]) / np.max(bins_remain_cap)\n    bins_used_ratio = (bins_remain_cap.max() - bins_remain_cap[feasible_mask]) / bins_remain_cap.max()\n\n    bonus = 1 / (1 + np.exp(-10 * (bins_used_ratio - 0.7)))\n    priorities[feasible_mask] += bonus\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Higher priority means we want to add item to the bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Immediate fit gets highest priority\n    immediate_fit = np.isclose(bins_remain_cap, item)\n    priorities[immediate_fit] = 1000  # Highest priority\n\n    # Next best fit gets higher priority. Close to full, but still has capacity\n    almost_full = (bins_remain_cap > item)\n    space_left = bins_remain_cap - item\n    priorities[almost_full] = 100 - (space_left[almost_full] / np.max(bins_remain_cap)) * 100 # Scale space_left to get score from 0 to 100\n\n    # Penalize bins that will be nearly empty after packing\n    nearly_empty = (item > bins_remain_cap)\n    priorities[nearly_empty] = -1000 # large negative penalty\n\n    # Moderate penalty to bins that fit, but have huge amount of leftover space.\n    large_leftover = (bins_remain_cap > item) & (bins_remain_cap - item > np.mean(bins_remain_cap))\n    priorities[large_leftover] = -50  # moderate negative penalty\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a base value (e.g., 0).\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Iterate through each bin and calculate its priority.\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if remaining_capacity >= item:  # Can the item fit?\n\n            # Heuristic 1: Maximize filled space. A bin closer to being full after placement gets higher priority.\n            fill_ratio = item / remaining_capacity\n            priorities[i] += fill_ratio\n\n            # Heuristic 2: Minimize wasted space (if item fits perfectly).\n            if remaining_capacity - item < 1e-6: # consider very small difference as equals\n                priorities[i] += 1.0  # Boost priority if item fits perfectly\n            else:\n                 # Heuristic 3: Avoid Fragmentation.\n                 priorities[i] +=  1.0 / (remaining_capacity-item)\n\n\n        else:\n            priorities[i] = -np.inf  # Very low priority if item doesn't fit.\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Consider only bins that can accommodate the item.\n    eligible_bins = bins_remain_cap >= item\n\n    if not np.any(eligible_bins):\n        # No bin can fit the item. Give minimum priority to all existing bins to signal a new bin is needed.\n        return priorities\n\n    # Calculate space utilization: how much of the bin will be filled if the item is added.\n    space_utilization = item / bins_remain_cap[eligible_bins]\n\n    # Encourage tighter packing by prioritizing bins with higher utilization. However, we don't want it to\n    # always choose the absolute tightest pack, as that can be greedy. So we introduce a non-linear term.\n    # A small value such as 0.001 is added to aviod numerical unstability when the bin is exactly same size as the item.\n    packing_density_score = space_utilization / (1 + space_utilization**2 + 0.001)  # Non-linear to avoid being *too* greedy.\n\n    # Consider the remaining capacity *after* the item is added. Bins with lower *remaining* capacity\n    # should be preferred to avoid leaving large, unusable gaps. Introduce noise to escape local optima.\n    remaining_capacity_after_fit = bins_remain_cap[eligible_bins] - item\n    remaining_capacity_score = np.exp(-remaining_capacity_after_fit)  # Exponential decay\n\n    # Combine the two scores, with some added randomness.\n    priorities[eligible_bins] = packing_density_score + remaining_capacity_score + np.random.normal(0, 0.01, size=np.sum(eligible_bins)) # Introduce some randomness\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot accommodate the item should have zero priority\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Only calculate priority for valid bins\n    if np.any(valid_bins):\n      remaining_space_after_fit = bins_remain_cap[valid_bins] - item\n      \n      # Calculate a score based on how much space is left after packing\n      space_score = np.exp(-remaining_space_after_fit) # Encourage bins to be filled as much as possible but also not overly full.\n\n      # Prefer bins that are not too empty initially (reduces fragmentation)\n      initial_fullness = 1 - bins_remain_cap[valid_bins] / bins_remain_cap.max()\n      fullness_score = np.exp(-1/ initial_fullness) # want to prioritize the full bins\n      # A combined score, blending space usage and original fullness\n      priorities[valid_bins] = space_score * (fullness_score +1e-6) # Add small value to avoid zero divide\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Bins that cannot accommodate the item should have zero priority\n    valid_bins = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Only calculate priority for valid bins\n    if np.any(valid_bins):\n      remaining_space_after_fit = bins_remain_cap[valid_bins] - item\n      \n      # Calculate a score based on how much space is left after packing\n      space_score = np.exp(-remaining_space_after_fit) # Encourage bins to be filled as much as possible but also not overly full.\n\n      # Prefer bins that are not too empty initially (reduces fragmentation)\n      initial_fullness = 1 - bins_remain_cap[valid_bins] / bins_remain_cap.max()\n      fullness_score = np.exp(-1/ initial_fullness) # want to prioritize the full bins\n      # A combined score, blending space usage and original fullness\n      priorities[valid_bins] = space_score * (fullness_score +1e-6) # Add small value to avoid zero divide\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item closely\n    (minimizing wasted space), but also avoids bins that are *too* close,\n    to preserve options for larger items later.  It penalizes bins\n    that cannot fit the item strongly.  Uses a sigmoid-like function to\n    shape the priorities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item.  Give them a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Extremely low priority\n\n    # For feasible bins, compute a score based on remaining space\n    feasible_bins = ~infeasible_bins\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # Scale remaining space to be around 0\n    scaled_remaining_space = remaining_space / item\n\n    # Use a sigmoid-like function to give higher priority to smaller remaining space,\n    # but not *too* small. This encourages close fits without filling almost completely.\n    # The constant values have been tuned through trial and error to acheive better packings.\n    priorities[feasible_bins] = 1 / (1 + np.exp(5 - 10*scaled_remaining_space)) - 0.5*np.exp(10*scaled_remaining_space-5) #1 / (1 + np.exp(8 * scaled_remaining_space - 4))\n\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version prioritizes bins that can accommodate the item closely\n    (minimizing wasted space), but also avoids bins that are *too* close,\n    to preserve options for larger items later.  It penalizes bins\n    that cannot fit the item strongly.  Uses a sigmoid-like function to\n    shape the priorities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Penalize bins that cannot fit the item.  Give them a very negative priority.\n    infeasible_bins = bins_remain_cap < item\n    priorities[infeasible_bins] = -1e9  # Extremely low priority\n\n    # For feasible bins, compute a score based on remaining space\n    feasible_bins = ~infeasible_bins\n    remaining_space = bins_remain_cap[feasible_bins] - item\n\n    # Scale remaining space to be around 0\n    scaled_remaining_space = remaining_space / item\n\n    # Use a sigmoid-like function to give higher priority to smaller remaining space,\n    # but not *too* small. This encourages close fits without filling almost completely.\n    # The constant values have been tuned through trial and error to acheive better packings.\n    priorities[feasible_bins] = 1 / (1 + np.exp(5 - 10*scaled_remaining_space)) - 0.5*np.exp(10*scaled_remaining_space-5) #1 / (1 + np.exp(8 * scaled_remaining_space - 4))\n\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the dance of planets! We favour bins where the item fits comfortably (like Venus nestled near the Sun), but also consider bins nearing fullness (like Jupiter pulling objects into its orbit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can accommodate the item. Ignore those that cannot.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # No suitable bin exists. Return very low priorities. This will likely result in opening a new bin.\n        return priorities\n\n    #Calculate emptiness - bigger values mean less space\n    emptiness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # A measure of 'fit'. Smaller ratios are better (item fits comfortably).\n    fit_ratios = item / bins_remain_cap\n    \n    # Scale the fit ratio to be between 0 and 1. We take exponent of 1 / fitness for making differences more distinct.\n    # Subtracting from 1 in the power will decrease impact for tight fitting bins and increase the impact of lose fitting bins\n    scaled_fit = (1 - np.clip(fit_ratios, 0, 1)) ** (1/3)\n    \n    # Increase reward of filling up space of the bin\n    scaled_emptiness = 1 / (1 + emptiness)\n\n    # Final score with two combined bonuses\n    priorities = feasible_bins * (scaled_fit + scaled_emptiness)\n\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the dance of planets! We favour bins where the item fits comfortably (like Venus nestled near the Sun), but also consider bins nearing fullness (like Jupiter pulling objects into its orbit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can accommodate the item. Ignore those that cannot.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # No suitable bin exists. Return very low priorities. This will likely result in opening a new bin.\n        return priorities\n\n    #Calculate emptiness - bigger values mean less space\n    emptiness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # A measure of 'fit'. Smaller ratios are better (item fits comfortably).\n    fit_ratios = item / bins_remain_cap\n    \n    # Scale the fit ratio to be between 0 and 1. We take exponent of 1 / fitness for making differences more distinct.\n    # Subtracting from 1 in the power will decrease impact for tight fitting bins and increase the impact of lose fitting bins\n    scaled_fit = (1 - np.clip(fit_ratios, 0, 1)) ** (1/3)\n    \n    # Increase reward of filling up space of the bin\n    scaled_emptiness = 1 / (1 + emptiness)\n\n    # Final score with two combined bonuses\n    priorities = feasible_bins * (scaled_fit + scaled_emptiness)\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the dance of planets! We favour bins where the item fits comfortably (like Venus nestled near the Sun), but also consider bins nearing fullness (like Jupiter pulling objects into its orbit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can accommodate the item. Ignore those that cannot.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # No suitable bin exists. Return very low priorities. This will likely result in opening a new bin.\n        return priorities\n\n    #Calculate emptiness - bigger values mean less space\n    emptiness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # A measure of 'fit'. Smaller ratios are better (item fits comfortably).\n    fit_ratios = item / bins_remain_cap\n    \n    # Scale the fit ratio to be between 0 and 1. We take exponent of 1 / fitness for making differences more distinct.\n    # Subtracting from 1 in the power will decrease impact for tight fitting bins and increase the impact of lose fitting bins\n    scaled_fit = (1 - np.clip(fit_ratios, 0, 1)) ** (1/3)\n    \n    # Increase reward of filling up space of the bin\n    scaled_emptiness = 1 / (1 + emptiness)\n\n    # Final score with two combined bonuses\n    priorities = feasible_bins * (scaled_fit + scaled_emptiness)\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the dance of planets! We favour bins where the item fits comfortably (like Venus nestled near the Sun), but also consider bins nearing fullness (like Jupiter pulling objects into its orbit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can accommodate the item. Ignore those that cannot.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # No suitable bin exists. Return very low priorities. This will likely result in opening a new bin.\n        return priorities\n\n    #Calculate emptiness - bigger values mean less space\n    emptiness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # A measure of 'fit'. Smaller ratios are better (item fits comfortably).\n    fit_ratios = item / bins_remain_cap\n    \n    # Scale the fit ratio to be between 0 and 1. We take exponent of 1 / fitness for making differences more distinct.\n    # Subtracting from 1 in the power will decrease impact for tight fitting bins and increase the impact of lose fitting bins\n    scaled_fit = (1 - np.clip(fit_ratios, 0, 1)) ** (1/3)\n    \n    # Increase reward of filling up space of the bin\n    scaled_emptiness = 1 / (1 + emptiness)\n\n    # Final score with two combined bonuses\n    priorities = feasible_bins * (scaled_fit + scaled_emptiness)\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the dance of planets! We favour bins where the item fits comfortably (like Venus nestled near the Sun), but also consider bins nearing fullness (like Jupiter pulling objects into its orbit).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # First, consider only bins that can accommodate the item. Ignore those that cannot.\n    feasible_bins = bins_remain_cap >= item\n    \n    if not np.any(feasible_bins):\n        # No suitable bin exists. Return very low priorities. This will likely result in opening a new bin.\n        return priorities\n\n    #Calculate emptiness - bigger values mean less space\n    emptiness = 1 - (bins_remain_cap / np.max(bins_remain_cap))\n\n    # A measure of 'fit'. Smaller ratios are better (item fits comfortably).\n    fit_ratios = item / bins_remain_cap\n    \n    # Scale the fit ratio to be between 0 and 1. We take exponent of 1 / fitness for making differences more distinct.\n    # Subtracting from 1 in the power will decrease impact for tight fitting bins and increase the impact of lose fitting bins\n    scaled_fit = (1 - np.clip(fit_ratios, 0, 1)) ** (1/3)\n    \n    # Increase reward of filling up space of the bin\n    scaled_emptiness = 1 / (1 + emptiness)\n\n    # Final score with two combined bonuses\n    priorities = feasible_bins * (scaled_fit + scaled_emptiness)\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}