```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Inspired by the cosmos, where larger bodies attract smaller ones. This heuristic
    prioritizes bins that can accommodate the item with minimal remaining space (gravity)
    while also discouraging fragmentation of nearly full bins (stellar wind).
    Further considerations include a probabilistic element (quantum uncertainty) to allow
    for exploration.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Ensure capacities are positive.
    bins_remain_cap = np.maximum(bins_remain_cap, 0)

    # Initialize priorities with a base score of zero.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item.
    fit_mask = bins_remain_cap >= item

    if not np.any(fit_mask):
        # No bin can fit the item. Assign a small, random priority to all bins.
        priorities = np.random.rand(len(bins_remain_cap)) * 0.0001
        return priorities
    # Gravity: Higher priority for bins with smaller remaining space AFTER packing, IF they can contain item.
    remaining_after_pack = bins_remain_cap - item
    remaining_after_pack[remaining_after_pack < 0] = np.inf #make very undesirable
    priorities[fit_mask] += np.max(bins_remain_cap) / (remaining_after_pack[fit_mask] + 0.0001) #Add a small epsilon to avoid divide by zero.
    # Stellar Wind: Discourage placing the item in nearly full bins to avoid creating tiny fragments.
    nearly_full_threshold = 0.1 #consider bins with <10% capacity almost full
    nearly_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < nearly_full_threshold)
    priorities[nearly_full_mask] -= np.max(bins_remain_cap) * 0.5 # Reduce Priority significantly

    # Quantum Uncertainty: Introduce a small degree of randomness for exploration.
    priorities[fit_mask] += np.random.rand(np.sum(fit_mask)) * np.std(priorities[fit_mask]) * 0.01

    return priorities
```
