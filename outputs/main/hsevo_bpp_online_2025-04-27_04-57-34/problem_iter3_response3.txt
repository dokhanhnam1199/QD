```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that are a close fit for the item,
    but also incorporates a 'first-fit' element to avoid excessive fragmentation
    by favoring bins with higher remaining capacity when multiple bins offer
    a reasonably good fit. It includes a penalty for bins that are almost full,
    discouraging placing items that might lead to near-empty bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    bins_remain_cap = np.array(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    valid_bins = bins_remain_cap > 0
    if not np.any(valid_bins):
        return priorities

    valid_remain_cap = bins_remain_cap[valid_bins]

    # Proximity factor: Closer fit is better
    proximity = np.exp(-np.abs(valid_remain_cap - item) / item)

    # Capacity factor: Higher capacity is good, encouraging first-fit-like behavior
    capacity = valid_remain_cap / np.max(bins_remain_cap)  # Normalize by overall max, not just valid ones.

    # Penalty for almost full bins: avoid creating tiny fragments
    almost_full_penalty = np.where(valid_remain_cap < 0.1 * np.max(bins_remain_cap), 0.2, 1) # Heavily penalize almost full bins. Previously used item*0.1, changed to a proportion of maximum bin size.

    # Bonus for bins where the item fits perfectly (or very close)
    perfect_fit_bonus = np.where(np.abs(valid_remain_cap - item) < 0.05 * item, 1.5, 1) # Give a significant bonus for near-perfect fits

    # Combine factors
    priorities[valid_bins] = proximity * capacity * almost_full_penalty * perfect_fit_bonus

    return priorities
```
