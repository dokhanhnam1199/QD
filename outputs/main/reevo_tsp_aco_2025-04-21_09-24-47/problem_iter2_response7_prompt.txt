{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP that combines several factors and sparsifies the matrix.\n\n    Args:\n        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.\n\n    Returns:\n        np.ndarray: Heuristic matrix indicating the promisingness of each edge.\n    \"\"\"\n    n = distance_matrix.shape[0]\n\n    # 1. Inverse Distance: Closer edges are generally better.\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to avoid division by zero\n\n    # 2. Node Degree Preference: Encourage edges connecting to nodes with few connections in current solution.\n    #    This aims to avoid prematurely isolating nodes.  Initially, all nodes have \"equal\" degree.\n    #    We don't have an evolving \"solution\" here to assess the degree, so approximate\n    #    by considering the number of relatively short edges connected to each node.\n\n    degree_heuristic = np.zeros_like(distance_matrix)\n    for i in range(n):\n        # Count how many edges connected to node i are relatively short.\n        # Shorter relative to the mean distance.\n        mean_dist = np.mean(distance_matrix[i, :])\n        short_edges_count = np.sum(distance_matrix[i, :] < mean_dist)\n        for j in range(n):\n            if i != j:\n                degree_heuristic[i, j] = short_edges_count # lower \"short edges count\" is better\n\n    degree_heuristic = 1 / (degree_heuristic + 1e-9) # Give high weights to lower-degree (isolated) nodes.\n\n    # 3. Sparsification:  Zero out edges that are \"too long\".\n\n    threshold = np.mean(distance_matrix) * 2  # Remove edges significantly longer than average.\n\n    sparse_mask = distance_matrix < threshold\n\n\n    # 4. Combine factors: Weight each factor and combine.\n    heuristic_matrix = (0.7 * inverse_distance + 0.3 * degree_heuristic) * sparse_mask\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) using a combination of factors.\n\n    This version incorporates the following ideas:\n    1. Inverse distance: Shorter distances are generally more promising.\n    2. Node degree: Avoid edges that would lead to high-degree nodes early in the tour.\n    3. Sparsification: Set unpromising elements (high distances) to zero.\n\n    Args:\n        distance_matrix (np.ndarray): A square matrix representing the distances between cities.\n\n    Returns:\n        np.ndarray: A matrix of the same shape as distance_matrix, where each element\n                      indicates the \"promise\" of including the corresponding edge in a solution.\n    \"\"\"\n    n = distance_matrix.shape[0]\n    heuristics = np.zeros_like(distance_matrix, dtype=float)\n\n    # Inverse distance\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Add a small constant to avoid division by zero\n    heuristics = inverse_distance\n\n    # Node degree component - trying to encourage more uniformly selected nodes\n\n    # Sparsification\n    threshold = np.percentile(distance_matrix[distance_matrix > 0], 75)  # Keep top 75% \"best\" connections\n    heuristics[distance_matrix > threshold] = 0\n\n    # Encourage inclusion of edges connected to nodes that are far apart\n    # This step aims to create a more balanced initial graph and potentially better exploration.\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                max_dist_i = np.max(distance_matrix[i, :])\n                max_dist_j = np.max(distance_matrix[j, :])\n                heuristics[i, j] += (max_dist_i + max_dist_j) / (2 * n * np.mean(distance_matrix)) # normalize range 0 to 1\n    # Ensuring Symmetry\n    heuristics = (heuristics + heuristics.T) / 2\n\n    # Removing self loops (diagonal)\n    np.fill_diagonal(heuristics, 0)\n\n\n    return heuristics\n\n[Reflection]\nThe better code uses percentile-based sparsification, balances node connections, and enforces symmetry, improving exploration.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}