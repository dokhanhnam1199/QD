```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on distance, node degree, and global connectivity,
    with adaptive sparsification.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix,
        representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degree heuristic (encourage low-degree nodes) based on neighbor count
    degree_heuristic = np.zeros(n)
    for i in range(n):
        degree_heuristic[i] = np.sum(distance_matrix[i, :] > 0)  # Count neighbors

    # Calculate global connectivity heuristic (penalize edges that disconnect the graph)
    # Approximate by the inverse of the average distance from each node to all other nodes.
    avg_distance_heuristic = np.zeros(n)
    for i in range(n):
        neighbors = distance_matrix[i, :][distance_matrix[i, :] > 0]
        if neighbors.size > 0:  # Handle isolated nodes
            avg_distance_heuristic[i] = np.mean(neighbors)
        else:
            avg_distance_heuristic[i] = np.inf  # Assign a large penalty to isolated nodes
            
        if np.isnan(avg_distance_heuristic[i]):
            avg_distance_heuristic[i] = np.inf # Avoid NaN issues if a node is completely isolated
        if avg_distance_heuristic[i] == 0: #Another edge case where all distances could be to itself and are 0.
            avg_distance_heuristic[i] = 1 # avoid division by 0 issues, could be set higher


    # Combine heuristics
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] > 0:
                # Combine distance, degree, and connectivity heuristics
                heuristic_matrix[i, j] = (
                    (1 / (distance_matrix[i, j] + 1e-9))  # Favor shorter distances, prevent div by zero
                    * (1 / (degree_heuristic[i] + degree_heuristic[j] + 1e-9))  # Favor lower-degree nodes, prevent div by zero
                    * (1 / (avg_distance_heuristic[i] + avg_distance_heuristic[j] + 1e-9))  # Favor well-connected nodes, prevent div by zero
                )

    # Adaptive sparsification: keep only the k-nearest neighbors for each node
    # where k is a function of the graph size and average degree
    avg_degree = np.mean(degree_heuristic)
    k = int(min(np.sqrt(n) + avg_degree/2, n-1))  # Adjust k based on graph density, but keep it <= n-1
    
    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[::-1]
        # Keep only the top k neighbors
        for j in range(n):
            if j not in indices[:k]:
                heuristic_matrix[i,j] = 0

    # Normalize the heuristic matrix
    heuristic_matrix = heuristic_matrix / (np.sum(heuristic_matrix) + 1e-9)


    return heuristic_matrix
```
