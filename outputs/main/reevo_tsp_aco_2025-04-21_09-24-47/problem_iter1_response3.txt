```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling ideas.
    Combines distance, node degree, and global context to estimate the suitability of including each edge.

    Args:
        distance_matrix (np.ndarray): A square matrix where element [i, j] represents the distance between node i and node j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, representing the prior indicator (suitability score) for each edge.
                       Higher values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]

    # 1. Inverse distance: Shorter distances are generally more desirable.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node degree encouragement: Encourages selecting edges connected to nodes with low degree so far
    # that helps in covering all the nodes faster in random sampling, not get trapped in local subgraphs.
    # Initially all nodes have degree 0. Represent degree-based heuristic factor using all ones for now.
    node_degree_factor = np.ones_like(distance_matrix)

    # 3. Global context: Estimate how well an edge connects different clusters or regions of the graph.
    #    A simple approach: Use shortest path distances as approximation.

    #    Consider the shortest path between two nodes i and j (excluding the direct edge i-j).  If the distance of shortest path is much greater than d(i, j) then edge (i, j) can be included in a shorter tour

    shortest_path_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
      for j in range(n):
        if i != j:
          temp_matrix = distance_matrix.copy()
          temp_matrix[i,j]= np.inf
          temp_matrix[j,i]= np.inf
          shortest_path = find_shortest_path(temp_matrix, i, j)

          if shortest_path is not None:
             shortest_path_matrix[i,j] = shortest_path

          else:
             shortest_path_matrix[i,j] = np.inf

    global_context_factor = 1/ (np.abs(distance_matrix - shortest_path_matrix) + 1)


    # Combine the factors (you can experiment with different weights)
    heuristic_matrix = (0.6 * inverse_distance +
                          0.1* node_degree_factor+
                          0.3* global_context_factor
                          )


    # Sparsify the matrix (optional): Remove unpromising edges by setting them to zero

    threshold = np.quantile(heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)], 0.2)  #Keep top 80% only to avoid disconnected graph
    heuristic_matrix[heuristic_matrix < threshold] = 0

    # Ensure symmetry (as TSP distance matrices are typically symmetric)
    heuristic_matrix = np.maximum(heuristic_matrix, heuristic_matrix.T) # make sure we preserve best paths


    return heuristic_matrix

def find_shortest_path(distance_matrix, start_node, end_node):

  n= distance_matrix.shape[0]
  dist = {node: np.inf for node in range(n)}
  dist[start_node]=0
  visited = set()

  while len(visited) < n:
      closest_node = None
      min_distance = np.inf

      for node in range(n):
          if node not in visited and dist[node] < min_distance:
              closest_node = node
              min_distance = dist[node]

      if closest_node is None:
          break  # No more reachable nodes

      visited.add(closest_node)


      for neighbor in range(n):
          if distance_matrix[closest_node, neighbor] != np.inf:
              new_distance = dist[closest_node] + distance_matrix[closest_node, neighbor]
              if new_distance < dist[neighbor]:
                  dist[neighbor] = new_distance

  return dist[end_node] if dist[end_node] != np.inf else None
```
