```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function combines several factors to determine how promising it is to
    include each edge in a solution and sparsifies the matrix by setting
    unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix where the element at
            [i, j] represents the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
            element represents the prior probability of including the corresponding
            edge in the TSP tour. Higher values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]

    # 1. Inverse Distance: Shorter edges are generally more promising.
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Nearest Neighbor Consideration: Edges connecting to cities with fewer
    #    nearby neighbors are potentially more critical.
    nearest_neighbors = np.zeros((n, n))
    for i in range(n):
        distances = distance_matrix[i, :]
        sorted_indices = np.argsort(distances)
        # Consider only the 'k' nearest neighbors
        k = min(5, n - 1)  #Limit to prevent infinite loops
        for j in sorted_indices[1:k+1]: # Exclude self-loop
            nearest_neighbors[i,j] = 1
            nearest_neighbors[j,i] = 1

    # 3. Sparsification and Combination: Combine factors and sparsify the matrix.

    # Create a combined heuristic matrix. Experiment with weights.
    heuristic_matrix = 0.7 * inverse_distance + 0.3 * nearest_neighbors

    # Sparsify: Zero out edges that are likely not to be in the optimal tour.
    # For example, only keep the 'sparsification_factor' nearest neighbors for each node
    sparsification_factor = 4
    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[::-1]
        keep_indices = indices[:sparsification_factor]
        mask = np.ones(n, dtype=bool)
        mask[keep_indices] = False
        heuristic_matrix[i, mask] = 0

    # Ensure that diagonal elements are zero, as they represent self-loops.
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
