```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that estimates the desirability of including each edge in the optimal tour.

    This version incorporates multiple factors:
        1. Inverse distance: Shorter distances are generally more desirable.
        2. Node degree desirability: Nodes with fewer close neighbors should prioritize those neighbors.
        3. Sparsification:  Zeroes out highly undesirable edges based on a dynamic threshold.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between cities.
                                      distance_matrix[i, j] is the distance between city i and city j.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each element represents
                    the heuristic value (prior indicator) for including the corresponding edge in the TSP tour.
                    Higher values indicate a more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance: Shorter distances are more desirable
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # 2. Node degree desirability:  Nodes should prioritize closer neighbors
    degree_desirability = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        distances = distance_matrix[i, :]
        sorted_indices = np.argsort(distances)  # Indices of cities sorted by distance from city i

        # Prioritize closer neighbors, but penalize very distant ones
        for j in range(n):
            index = sorted_indices[j]
            degree_desirability[i, index] = max(0, 1 - (j / n))  # Closer neighbors get higher values

    # Combine factors
    heuristic_matrix = inverse_distance * degree_desirability

    # 3. Sparsification: Remove edges that are clearly not promising
    # Adaptive threshold based on distances
    average_distance = np.mean(distance_matrix)
    threshold = 3 * average_distance  # Heuristic: Cut off edges significantly longer than average
    heuristic_matrix[distance_matrix > threshold] = 0

    # Ensure diagonal elements are zero
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
