```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors and sparsification.

    Args:
        distance_matrix: A numpy ndarray representing the distance matrix.

    Returns:
        A numpy ndarray of the same shape as distance_matrix, representing the
        heuristic scores for each edge. Higher score indicates a more promising edge.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate nearest neighbors for each node
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Top 3 nearest neighbors

    # Heuristic based on inverse distance (like v1)
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Heuristic based on being a nearest neighbor
    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for neighbor in nearest_neighbors[i]:
            nearest_neighbor_bonus[i, neighbor] = 1

    # Heuristic to favor edges that connect nodes with high average distance to other nodes
    # This encourages connecting "isolated" nodes earlier
    avg_distances = np.mean(distance_matrix, axis=1)
    isolation_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in range(n):
            isolation_bonus[i, j] = avg_distances[i] + avg_distances[j]
            
    # Combine the heuristics with weights
    heuristic_matrix = (0.6 * inverse_distance +
                         0.3 * nearest_neighbor_bonus +
                         0.1 * isolation_bonus)
    
    #Sparsify the matrix: only keep edges with heuristic score above a threshold
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2) #keep top 80% nonzero values.

    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
