```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP using a combination of factors, adaptive sparsification, and edge combination.
    Includes normalization and slight randomness.

    Args:
        distance_matrix (np.ndarray): Distance matrix representing the TSP instance.

    Returns:
        np.ndarray: Prior indicators (probabilities) of edge inclusion.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance heuristic
    inverse_distance = 1.0 / (distance_matrix + 1e-9)

    # Node degree heuristic (favor nodes with shorter total distance)
    node_degree_heuristic = np.zeros_like(distance_matrix, dtype=float)
    node_distances = np.sum(distance_matrix, axis=1)
    for i in range(n):
        for j in range(n):
            if i != j:
                node_degree_heuristic[i, j] = 1.0 / (node_distances[i] + 1e-9) # Bias towards nodes with small distances

    # Sparsification - Adaptive k based on percentile.  This is the target neighborhood size.
    k = max(2, int(n * 0.1))  # Start with a small percentage
    k = min(k, n - 1) # Clamp it.
    # Combination and Sparsification
    combined_heuristic = inverse_distance * node_degree_heuristic
    for i in range(n):
        row = combined_heuristic[i].copy()
        indices_to_keep = np.argsort(row)[-k:] # Keep k best edges.
        mask = np.zeros(n, dtype=bool)
        mask[indices_to_keep] = True
        combined_heuristic[i, ~mask] = 0
        combined_heuristic[i, i] = 0 # Remove Self loop.

    # Add some randomness to maintain some level of exploration to get unstuck from local optima
    randomness = np.random.rand(n, n) * 0.01 # Add small random noise.

    heuristic_matrix = combined_heuristic + randomness # Combine randomness.

    # Normalization (Probability-like)
    row_sums = heuristic_matrix.sum(axis=1, keepdims=True)
    heuristic_matrix = np.nan_to_num(heuristic_matrix / (row_sums + 1e-9)) # Adding small constant to avoid division by zero

    return heuristic_matrix
```
