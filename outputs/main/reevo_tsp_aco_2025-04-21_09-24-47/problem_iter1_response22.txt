```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that combines
    distance, node degree, and connectivity information to estimate the
    promise of including each edge in a solution.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i][j]
                                      represents the distance between node i and node j.
                                      Assume it is symmetric.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
                    element represents a heuristic score indicating the
                    likelihood of including the corresponding edge in an
                    optimal TSP tour.  Higher score indicates higher likelihood.
                    Sparse matrix: many entries will be 0, indicating edge is likely not good.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance: Shorter edges are generally better.
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero

    # Node degree: Penalize high-degree nodes (to avoid early cycles). Initially, all nodes have degree 0
    degree_penalty = np.ones((n, n))

    # Sparsification threshold (remove very long edges)
    distance_threshold = np.mean(distance_matrix) + np.std(distance_matrix) # dynamic sparsification
    #distance_threshold = np.quantile(distance_matrix[distance_matrix>0], 0.75)

    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] < distance_threshold:
                # Combine factors to get the heuristic score
                heuristic_matrix[i, j] = inverse_distance[i, j] * degree_penalty[i, j] * degree_penalty[j, i] # product of inverse distance and degree penalty.

                # Consider a higher-order connectivity heuristic to guide edge selection
                # Add a penalty for longer paths through neighbors.
                neighbor_penalty = 0
                num_neighbors = 0

                for k in range(n):
                    if k != i and k!= j and distance_matrix[i, k] < distance_threshold and distance_matrix[j,k] < distance_threshold:
                        neighbor_penalty += distance_matrix[i, k] + distance_matrix[j,k]
                        num_neighbors += 1
                if num_neighbors >0:
                  neighbor_penalty = neighbor_penalty/ num_neighbors

                heuristic_matrix[i,j] /= (1 + neighbor_penalty/distance_threshold)


            else:
                heuristic_matrix[i, j] = 0  # Sparsify: set unpromising edges to zero

    # Enforce symmetry (TSP is usually undirected)
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    # Node degree dynamic update within heuristic function for even better results
    sum_heuristic_per_node = np.sum(heuristic_matrix, axis = 0)
    # penalty nodes having too large connections with many other node.
    for i in range(n):
        for j in range(n):
            if i!= j and heuristic_matrix[i,j] >0:
                heuristic_matrix[i, j] /= (sum_heuristic_per_node[i] + sum_heuristic_per_node[j] + 1e-9)
                if heuristic_matrix[i,j] > 0: # apply again symetry
                    heuristic_matrix[j, i] = heuristic_matrix[i, j]

    return heuristic_matrix
```
