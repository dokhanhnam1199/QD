{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a heuristics function for Solving Traveling Salesman Problem (TSP) via stochastic solution sampling following \"heuristics\". TSP requires finding the shortest path that visits all given nodes and returns to the starting node.\nThe `heuristics` function takes as input a distance matrix, and returns prior indicators of how promising it is to include each edge in a solution. The return is of the same shape as the input.\n\n\n[Worse code]\ndef heuristics_v0(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for TSP using a combination of factors and sparsification.\n\n    Args:\n        distance_matrix: A numpy ndarray representing the distance matrix.\n\n    Returns:\n        A numpy ndarray of the same shape as distance_matrix, representing the\n        heuristic scores for each edge. Higher score indicates a more promising edge.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)\n\n    # Calculate nearest neighbors for each node\n    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Top 3 nearest neighbors\n\n    # Heuristic based on inverse distance (like v1)\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero\n\n    # Heuristic based on being a nearest neighbor\n    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for neighbor in nearest_neighbors[i]:\n            nearest_neighbor_bonus[i, neighbor] = 1\n\n    # Heuristic to favor edges that connect nodes with high average distance to other nodes\n    # This encourages connecting \"isolated\" nodes earlier\n    avg_distances = np.mean(distance_matrix, axis=1)\n    isolation_bonus = np.zeros_like(distance_matrix, dtype=float)\n    for i in range(n):\n        for j in range(n):\n            isolation_bonus[i, j] = avg_distances[i] + avg_distances[j]\n            \n    # Combine the heuristics with weights\n    heuristic_matrix = (0.6 * inverse_distance +\n                         0.3 * nearest_neighbor_bonus +\n                         0.1 * isolation_bonus)\n    \n    #Sparsify the matrix: only keep edges with heuristic score above a threshold\n    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.2) #keep top 80% nonzero values.\n\n    heuristic_matrix[heuristic_matrix < threshold] = 0\n\n    return heuristic_matrix\n\n[Better code]\ndef heuristics_v1(distance_matrix: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Heuristic function for the Traveling Salesman Problem (TSP) based on stochastic solution sampling principles.\n\n    This version combines several factors to assess the desirability of including each edge in a potential TSP solution.\n    It considers:\n\n    1.  Inverse distance: Shorter edges are generally more desirable.\n    2.  Node degree preference: Favors edges connected to nodes with fewer connections (exploration).\n    3.  Global shortest edges: Encourages participation of top shortest edges.\n    4.  Sparsification: Sets probabilities for the longer edges to zero, which improves focus.\n\n    Args:\n        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between nodes.\n                                        distance_matrix[i, j] is the distance between node i and node j.\n                                        Assume that distance_matrix[i, i] = np.inf.\n\n    Returns:\n        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each element\n                    represents the desirability score for including the corresponding edge in the TSP solution.\n    \"\"\"\n\n    n = distance_matrix.shape[0]\n    heuristic_matrix = np.zeros((n, n))\n\n    # 1. Inverse distance\n    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small constant to avoid division by zero\n\n    # 2. Node degree preference - prioritize edges connecting to less connected nodes\n    degree_preference = np.zeros((n, n))\n    for i in range(n):\n        # A crude approximation of degree would be the sum of the desirability for neighboring nodes\n        neighbor_desirability = np.sum(inverse_distance[i, :])\n        for j in range(n):\n            if i != j:\n                degree_preference[i, j] = 1 / (neighbor_desirability + 1e-9)  # Penalize edges to nodes with high neighbor desirability\n\n    # 3. Global shortest edges\n    shortest_edges_bonus = np.zeros((n, n))\n    k = n  # Number of top edges to consider (can be tuned)\n    top_k_edges = np.argpartition(distance_matrix.flatten(), k)[:k] #indices of k smallest distances\n    for index in top_k_edges:\n        i = index // n\n        j = index % n\n        shortest_edges_bonus[i, j] = 1  # Assign a bonus to edges among the top k shortest\n\n    # Combine the factors\n    heuristic_matrix = inverse_distance * (0.6 + 0.4 * degree_preference) + 0.2* shortest_edges_bonus\n\n    # 4. Sparsification - set unpromising elements (longer edges) to zero.\n    threshold = np.quantile(distance_matrix[np.isfinite(distance_matrix)], 0.75)  # Dynamic threshold\n    heuristic_matrix[distance_matrix > threshold] = 0.0\n\n    # Ensure diagonal elements are 0\n    for i in range(n):\n        heuristic_matrix[i, i] = 0.0\n\n    return heuristic_matrix\n\n[Reflection]\nPrioritize node degree, shortest edges, and dynamic sparsification based on distance for improved exploration.\n\n\n[Improved code]\nPlease write an improved function `heuristics_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}