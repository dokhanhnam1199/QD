```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on distance, node degree,
    and random sampling to explore diverse solutions.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degrees based on inverse distance.  Nodes with shorter
    # distances to other nodes are considered to have a higher degree.
    node_degrees = np.sum(1.0 / (distance_matrix + np.eye(n)), axis=1)

    # Combine inverse distance with node degrees to prioritize edges
    # connecting high-degree nodes with short distances.
    for i in range(n):
        for j in range(n):
            if i != j:
                heuristic_matrix[i, j] = (1.0 / distance_matrix[i, j]) * (node_degrees[i] + node_degrees[j])

    # Sparsify the heuristic matrix by setting less promising edges to zero.
    # Threshold is calculated based on the mean of the heuristic values.

    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2 # changed the threshold
    heuristic_matrix[heuristic_matrix < threshold] = 0.0

    # Introduce some randomness to promote exploration.  This adds a small
    # probability of considering edges that would otherwise be excluded.

    random_matrix = np.random.rand(n, n) * 0.01  # small random values
    heuristic_matrix += random_matrix

    # Ensure no self-loops or zero distances.
    np.fill_diagonal(heuristic_matrix, 0.0)

    return heuristic_matrix
```
