```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that prioritizes
    degree-based heuristics with adaptive sparsification and controlled noise injection
    for exploration.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between nodes.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each element indicates
                      the heuristic value (promise) of including the corresponding edge in the solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degree heuristic (prefer less connected nodes)
    degree_heuristic = np.zeros((n, n))
    node_degrees = np.zeros(n)
    for i in range(n):
        node_degrees[i] = np.sum(1 / (distance_matrix[i, :] + 1e-9))

    for i in range(n):
        for j in range(n):
            degree_heuristic[i, j] = 1 / (node_degrees[i] + node_degrees[j] + 1e-9)

    # Incorporate distance information (shorter distances are better)
    distance_heuristic = 1 / (distance_matrix + 1e-9)

    # Add random noise for exploration
    random_noise = np.random.rand(n, n) * 0.01

    # Combine heuristics with adjusted weights (prioritizing degree)
    heuristics = 0.3 * distance_heuristic + 0.6 * degree_heuristic + 0.1 * random_noise

    # Set diagonal elements to zero (no self-loops)
    np.fill_diagonal(heuristics, 0)

    # Adaptive Sparsification: only keep the most promising edges for each node
    for i in range(n):
        # Determine node-specific sparsity threshold adaptively. Adjust the range
        k = max(2, int(np.sqrt(n))) #keep at least 2
        row = heuristics[i, :].copy()
        indices_to_keep = np.argsort(row)[-k:]  # Keep top k edges
        mask = np.zeros(n, dtype=bool)
        mask[indices_to_keep] = True
        heuristics[i, ~mask] = 0  # Sparsify

    # Ensure symmetry
    heuristics = (heuristics + heuristics.T) / 2

    # Normalize rows to represent probabilities
    row_sums = heuristics.sum(axis=1, keepdims=True)
    heuristics = np.nan_to_num(heuristics / row_sums)
    heuristics = np.clip(heuristics, 0, 1)

    return heuristics
```
