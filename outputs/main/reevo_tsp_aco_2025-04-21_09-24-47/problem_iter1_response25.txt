```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on distance, node degree, and global connectivity.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix,
        representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degree heuristic (encourage low-degree nodes)
    degree_heuristic = np.zeros(n)
    for i in range(n):
        degree_heuristic[i] = np.sum(distance_matrix[i, :] > 0)  # Count neighbors

    # Calculate global connectivity heuristic (penalize edges that disconnect the graph)
    # For simplicity, we approximate this by the inverse of the average distance from each node
    # to all other nodes.  Nodes with large average distance might be more "isolated".
    avg_distance_heuristic = np.zeros(n)
    for i in range(n):
        avg_distance_heuristic[i] = np.mean(distance_matrix[i, :][distance_matrix[i, :] > 0])
        if np.isnan(avg_distance_heuristic[i]):
            avg_distance_heuristic[i] = np.inf # Avoid NaN issues if a node is completely isolated
        if avg_distance_heuristic[i] == 0: #Another edge case where all distances could be to itself and are 0.
            avg_distance_heuristic[i] = 1 # avoid division by 0 issues, could be set higher

    # Combine heuristics
    for i in range(n):
        for j in range(n):
            if i != j and distance_matrix[i, j] > 0:
                # Combine distance, degree, and connectivity heuristics
                heuristic_matrix[i, j] = (
                    (1 / distance_matrix[i, j])  # Favor shorter distances
                    * (1 / (degree_heuristic[i] + degree_heuristic[j])) # Favor edges connected to lower-degree nodes
                    * (1 / (avg_distance_heuristic[i] + avg_distance_heuristic[j]))  # Favor edges connected to well-connected nodes (small avg distance to others)
                )
    
    #Sparsify the matrix: keep only the k-nearest neighbors for each node
    k = int(np.sqrt(n)) # dynamically decide k to allow for varied network sizes
    for i in range(n):
        row = heuristic_matrix[i, :]
        indices = np.argsort(row)[::-1]
        # Keep only the top k neighbors
        for j in range(n):
            if j not in indices[:k]:
                heuristic_matrix[i,j] = 0

    return heuristic_matrix
```
