```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function calculates a heuristic matrix indicating the desirability of including
    each edge in the TSP tour. It considers a combination of factors:

    1. Inverse distance: Shorter edges are generally more desirable.
    2. Nearest neighbor consideration: Edges connecting nodes with few close neighbors
       are penalized, as these nodes are likely to be bottlenecks.
    3. Sparsification: Edges with very low desirability scores are set to zero
       to reduce the search space.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance
                                       matrix between nodes.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as the distance matrix,
                    where each element represents the heuristic value of including
                    the corresponding edge in the TSP tour. Higher values indicate
                    more promising edges.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Inverse distance
    inverse_distance = 1 / (distance_matrix + 1e-9)  # Adding a small value to prevent division by zero

    # Nearest neighbor consideration
    nearest_neighbors = np.zeros(n)
    for i in range(n):
        distances = distance_matrix[i, :]
        nearest_neighbors[i] = np.sum(distances < np.mean(distances))  # Count of nodes within mean distance

    for i in range(n):
        for j in range(n):
            if i != j:
                # Penalize edges connecting nodes with few neighbors. The idea here is that if
                # a node only has one or two close neighbors, that edge MUST be in the optimal tour
                # So penalize its inclusion for the purpose of generating a diverse set of candidate tours.
                neighbor_penalty = (nearest_neighbors[i] * nearest_neighbors[j])
                heuristic_matrix[i, j] = inverse_distance[i, j] * np.sqrt(neighbor_penalty)

    # Normalize heuristic matrix
    heuristic_matrix = (heuristic_matrix - np.min(heuristic_matrix)) / (np.max(heuristic_matrix) - np.min(heuristic_matrix) + 1e-9)


    # Sparsification: Set very low desirability scores to zero to reduce search space
    threshold = np.quantile(heuristic_matrix[heuristic_matrix > 0], 0.1)  # Remove the worst 10%
    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
