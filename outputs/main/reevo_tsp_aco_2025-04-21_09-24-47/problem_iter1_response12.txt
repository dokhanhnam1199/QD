```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that combines multiple factors to estimate
    the promise of each edge. This version considers distance, node degree (preference for less-connected nodes),
    and random noise for exploration. It also sparsifies the matrix.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between nodes.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each element indicates
                      the heuristic value (promise) of including the corresponding edge in the solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degree heuristic (prefer less connected nodes)
    degree_heuristic = np.ones((n, n))  # Initialize with ones to avoid division by zero if a node is isolated
    for i in range(n):
        # Approximate degree by summing inverse distances. Closer nodes increase degree
        degree = np.sum(1 / (distance_matrix[i, :] + 1e-9))  # Adding small constant to avoid division by zero
        degree_heuristic[i, :] = 1 / degree  # Inverse relation, less connected gets higher heuristic score.
        degree_heuristic[:, i] = 1 / degree

    # Incorporate distance information (shorter distances are better)
    distance_heuristic = 1 / (distance_matrix + 1e-9)

    # Add random noise for exploration
    random_noise = np.random.rand(n, n) * 0.1  # Scale random noise to a small fraction

    # Combine heuristics. Experiment with different weights.
    heuristics = 0.6 * distance_heuristic + 0.3 * degree_heuristic + 0.1 * random_noise

    # Set diagonal elements to zero (no self-loops)
    np.fill_diagonal(heuristics, 0)

    # Sparsify the matrix: only keep the most promising edges for each node
    sparsity_threshold = 0.7  # Experiment with different thresholds to control sparsity. Higher = sparser
    for i in range(n):
        row = heuristics[i, :]
        threshold = np.quantile(row[row > 0], sparsity_threshold)  # Filter zeros
        heuristics[i, row < threshold] = 0
    for j in range(n):
        col = heuristics[:, j]
        threshold = np.quantile(col[col > 0], sparsity_threshold)
        heuristics[col < threshold, j] = 0


    # Ensure symmetry (important for some TSP solvers/algorithms that expect it).
    heuristics = (heuristics + heuristics.T) / 2

    return heuristics
```
