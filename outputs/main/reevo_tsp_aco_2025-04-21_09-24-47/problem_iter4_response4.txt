```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) that combines multiple factors to estimate
    the promise of each edge. This version considers distance, node degree (preference for less-connected nodes),
    and random noise for exploration. It sparsifies the matrix by node and ensures symmetry. It also refines
    the degree heuristic and incorporates an edge reciprocity factor.

    Args:
        distance_matrix (np.ndarray): A 2D numpy array representing the distance matrix between nodes.

    Returns:
        np.ndarray: A 2D numpy array of the same shape as distance_matrix, where each element indicates
                      the heuristic value (promise) of including the corresponding edge in the solution.
    """

    n = distance_matrix.shape[0]
    heuristics = np.zeros_like(distance_matrix, dtype=float)

    # Calculate node degree heuristic (prefer less connected nodes)
    degree_heuristic = np.zeros((n, n))
    for i in range(n):
        # Refined degree calculation: considers the inverse of the distances to other nodes
        degree = np.sum(1 / (distance_matrix[i, :] + 1e-9)) - (1 / (distance_matrix[i,i]+1e-9)) #subtract self-loop
        degree_heuristic[i, :] = 1 / (degree + 1e-9)  # Avoid division by zero and give low score to high degree
        degree_heuristic[:, i] = 1 / (degree + 1e-9)


    # Incorporate distance information (shorter distances are better)
    distance_heuristic = 1 / (distance_matrix + 1e-9)

    # Edge Reciprocity: Encourage edges that are mutually close.
    reciprocity_heuristic = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            reciprocity_heuristic[i,j] = 1 / (distance_matrix[i,j] + distance_matrix[j,i] + 1e-9)

    # Add random noise for exploration
    random_noise = np.random.rand(n, n) * 0.01

    # Combine heuristics with adjusted weights
    heuristics = 0.4 * distance_heuristic + 0.4 * degree_heuristic + 0.1 * random_noise + 0.1* reciprocity_heuristic

    # Set diagonal elements to zero (no self-loops)
    np.fill_diagonal(heuristics, 0)

    # Sparsify the matrix: only keep the most promising edges for each node
    sparsity_threshold = 0.7
    for i in range(n):
        row = heuristics[i, :]
        threshold = np.quantile(row[row > 0], sparsity_threshold) if np.any(row > 0) else -1 #handle edge case
        heuristics[i, row < threshold] = 0

    # Ensure symmetry
    heuristics = (heuristics + heuristics.T) / 2

    return heuristics
```
