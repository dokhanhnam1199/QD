```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP) using a combination
    of factors and sparsification.

    Args:
        distance_matrix (np.ndarray): A 2D NumPy array representing the distance
                                       matrix between cities.

    Returns:
        np.ndarray: A 2D NumPy array of the same shape as distance_matrix,
                    representing the heuristic values for each edge.  Higher values
                    indicate a more promising edge.  Some values may be zero to
                    sparsify the search space.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # Calculate inverse distance (nearness)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)  # Adding a small value to prevent division by zero

    # Calculate average distance for each city
    avg_distances = np.mean(distance_matrix, axis=1, keepdims=True)

    # Calculate distance relative to average distances of connected cities
    relative_distance = 1.0 / (distance_matrix / (avg_distances + avg_distances.T) + 1e-9)
    
    # Degree of nodes (encourages visiting nodes that are less connected)
    degree_penalty = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            degree_penalty[i,j] = np.sum(distance_matrix[i,:] < np.mean(distance_matrix[i,:]) + 1e-6) + np.sum(distance_matrix[j,:] < np.mean(distance_matrix[j,:]) + 1e-6) #number of nodes closer than the mean

    degree_penalty = 1/(degree_penalty + 1e-9)

    # Combine factors (you can adjust the weights)
    heuristic_matrix = (0.5 * inverse_distance + 0.3 * relative_distance + 0.2 * degree_penalty)
    

    # Sparsify the matrix: keep only top k edges for each node
    k = int(np.sqrt(n))  # Adjust k based on problem size. Keep around sqrt(n) closest neighbors
    for i in range(n):
        row = heuristic_matrix[i, :].copy()
        indices_to_keep = np.argsort(row)[-k:] #Indices of top k elements in the row
        heuristic_matrix[i, :] = 0 # reset the row
        heuristic_matrix[i, indices_to_keep] = row[indices_to_keep] # put the top k back to their original values
        
    # Make sure the matrix is symmetric if the distance_matrix is supposed to represent an undirected graph (e.g. cities)
    heuristic_matrix = (heuristic_matrix + heuristic_matrix.T) / 2

    # Ensure diagonal is zero since TSP doesn't allow self-loops
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
