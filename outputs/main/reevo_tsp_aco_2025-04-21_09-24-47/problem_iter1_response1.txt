```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for the Traveling Salesman Problem (TSP).

    This function combines several factors to determine how promising it is to
    include each edge in a solution.  It prioritizes shorter edges and edges
    that connect to nodes with high average distance to other nodes (nodes
    that are effectively "in the middle" of the node distribution).
    The matrix is also sparsified by setting unpromising elements to zero.

    Args:
        distance_matrix (np.ndarray): A square matrix where distance_matrix[i, j]
            is the distance between city i and city j.

    Returns:
        np.ndarray: A matrix of the same shape as distance_matrix, where each
            element indicates how promising it is to include the corresponding
            edge in a solution.  Higher values indicate more promising edges.
    """
    n = distance_matrix.shape[0]

    # 1. Inverse distance (shorter edges are more promising)
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add a small constant to avoid division by zero

    # 2. Node centrality: Nodes with high average distance to other nodes are
    #    likely to be centrally located and should be connected to avoid
    #    having many very long edges.
    avg_distances = np.mean(distance_matrix, axis=1)
    centrality_matrix = np.zeros_like(distance_matrix)
    for i in range(n):
        for j in range(n):
            centrality_matrix[i, j] = avg_distances[i] + avg_distances[j]

    # 3. Combine the factors
    heuristic_matrix = inverse_distance * centrality_matrix

    # 4. Sparsify the matrix: Zero out less promising edges to reduce search space.
    #    We will keep edges that score higher than some threshold based on the mean of all entries
    threshold = np.mean(heuristic_matrix) * 0.5 #remove links with scores lower than half of the mean.

    heuristic_matrix[heuristic_matrix < threshold] = 0  #set elements lower than threshold to 0.

    # Zero out diagonal elements because there are no self-loops.
    np.fill_diagonal(heuristic_matrix, 0)

    return heuristic_matrix
```
