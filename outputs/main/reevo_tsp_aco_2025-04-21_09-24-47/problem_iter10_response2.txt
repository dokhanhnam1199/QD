```python
import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import minimum_spanning_tree


def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on distance, node degree, and global connectivity,
    with adaptive, node-specific sparsification and normalization.  This version prioritizes
    speed and efficiency, while maintaining effectiveness.

    Args:
        distance_matrix: A numpy array representing the distance matrix.

    Returns:
        A numpy array of the same shape as distance_matrix,
        representing the heuristic values for each edge.
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse Distance Heuristic (Fast and Efficient)
    inverse_distance = 1.0 / (distance_matrix + 1e-9)
    max_inv_dist = np.max(inverse_distance)
    if max_inv_dist > 0:
        inverse_distance = inverse_distance / max_inv_dist

    # 2. Node Degree Heuristic (Simplified and Faster)
    degree_heuristic = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        neighbors = np.argsort(distance_matrix[i, :])
        for j in range(n):
            rank = np.where(neighbors == j)[0][0]
            degree_heuristic[i, j] = max(0, 1 - (rank / (n // 2)))  # Scale by half the nodes

    max_degree = np.max(degree_heuristic)
    if max_degree > 0:
        degree_heuristic = degree_heuristic / max_degree
    # 3. Global Connectivity Heuristic (Efficient MST)
    mst_heuristic = np.zeros_like(distance_matrix, dtype=float)
    mst = minimum_spanning_tree(csr_matrix(distance_matrix))
    mst_matrix = mst.toarray()

    mst_heuristic = np.where(mst_matrix > 0, 1.0, 0.0)
    max_mst = np.max(mst_heuristic)
    if max_mst > 0:
        mst_heuristic = mst_heuristic / max_mst

    # Combine heuristics (Adjusted Weights)
    heuristic_matrix = (0.5 * inverse_distance +
                        0.3 * degree_heuristic +
                        0.2 * mst_heuristic)

    # Adaptive Sparsification (Node-Specific k, Optimized)
    for i in range(n):
        k = min(max(2, int(np.sqrt(n))), n - 1)
        row = heuristic_matrix[i].copy()
        threshold = np.partition(row, -k)[-k]  # Use partition for efficiency
        heuristic_matrix[i, row < threshold] = 0


    # Normalize Rows (Handles all-zero rows)
    row_sums = np.sum(heuristic_matrix, axis=1, keepdims=True)
    heuristic_matrix = np.where(row_sums > 0, heuristic_matrix / row_sums, 0)


    heuristic_matrix[np.diag_indices_from(heuristic_matrix)] = 0  # Remove self-loops


    return heuristic_matrix
```
