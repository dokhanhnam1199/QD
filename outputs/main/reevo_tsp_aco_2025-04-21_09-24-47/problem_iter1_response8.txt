```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on a combination of factors:

    1. Inverse distance: Shorter distances are generally more promising.
    2. Nearest neighbor: Edges connecting nodes to their nearest neighbors are good.
    3. Sparsification: Set low-promise edges to zero to focus on the best candidates.
    """

    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Add small constant to avoid division by zero

    # 2. Nearest neighbor
    nearest_neighbors = np.argsort(distance_matrix, axis=1)[:, 1:4]  # Top 3 nearest neighbors (excluding self)
    nearest_neighbor_bonus = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        for j in nearest_neighbors[i]:
            nearest_neighbor_bonus[i, j] = 1.0  # Assign a bonus to edges connecting nearest neighbors

    # Combine factors
    heuristic_matrix = inverse_distance + 0.5 * nearest_neighbor_bonus

    # 3. Sparsification
    # Identify edges with heuristic values below a threshold and set them to zero.
    # The threshold is adaptive and based on the mean heuristic value.

    threshold = np.mean(heuristic_matrix[heuristic_matrix > 0]) * 0.2  #Dynamic thresholding based on mean

    heuristic_matrix[heuristic_matrix < threshold] = 0

    return heuristic_matrix
```
