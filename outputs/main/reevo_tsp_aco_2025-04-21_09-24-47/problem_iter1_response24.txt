```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray) -> np.ndarray:
    """
    Heuristic function for TSP based on distance, node degree,
    and sparsification.  Combines multiple heuristics to provide
    more informed prior indicators.

    Args:
        distance_matrix (np.ndarray):  Distance matrix representing the TSP.

    Returns:
        np.ndarray: Prior indicators for each edge (same shape as distance_matrix).
    """
    n = distance_matrix.shape[0]
    heuristic_matrix = np.zeros_like(distance_matrix, dtype=float)

    # 1. Inverse distance (basic heuristic)
    inverse_distance = 1 / (distance_matrix + 1e-6)  # Adding a small constant to avoid division by zero

    # 2. Node degree penalty: penalize edges connected to nodes with many close neighbors.
    degree_penalty = np.zeros_like(distance_matrix, dtype=float)
    for i in range(n):
        # Find the k nearest neighbors (excluding itself)
        distances_from_i = distance_matrix[i, :]
        nearest_neighbors_indices = np.argsort(distances_from_i)[1:min(4, n)] # k=3 or less, excluding self

        # Calculate average distance to these neighbors
        avg_neighbor_distance = np.mean(distances_from_i[nearest_neighbors_indices]) if len(nearest_neighbors_indices) > 0 else np.inf

        for j in range(n):
            if i != j:
                # Higher avg_neighbor_distance indicates node 'i' is less likely to over-connect, 
                # hence a smaller penalty.
                degree_penalty[i, j] = 1 / (avg_neighbor_distance + 1e-6) # Small constant to prevent div by zero.  Larger values imply a heavier penalty

    # 3. Combination of heuristics.  Experiment with weights.
    heuristic_matrix = (0.7 * inverse_distance + 0.3 * degree_penalty)

    # 4. Sparsification:  Zero out less promising edges
    threshold = np.percentile(heuristic_matrix[heuristic_matrix > 0], 50)  # Keep top 50% edges.  Exclude zeros.
    heuristic_matrix[heuristic_matrix < threshold] = 0
    # Ensure that rows and columns have some degree
    for i in range(n):
        if np.sum(heuristic_matrix[i,:]) == 0:
            idx = np.argsort(distance_matrix[i,:])[1] #closest non-self neighbor
            heuristic_matrix[i,idx] = 1
            heuristic_matrix[idx,i] = 1

    return heuristic_matrix
```
