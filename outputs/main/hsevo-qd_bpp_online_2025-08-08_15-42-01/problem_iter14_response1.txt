```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a dynamic exploration strategy.
    Prioritizes bins leaving minimal residual space, with a bonus for perfect fits.
    Exploration is guided by favoring bins with moderate remaining capacity
    and introducing a small random perturbation to selected candidates.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    # --- Objective 1: Tightest Fit & Perfect Fit Bonus ---
    remaining_after_fit = valid_bins_capacities - item
    tight_fit_score = -remaining_after_fit
    perfect_fit_bonus = 50.0  # Significant bonus for exact fits
    tight_fit_score[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus

    # --- Objective 2: Future Utility (Moderate Remaining Capacity) ---
    # Reward bins that leave a "useful" amount of space, not too little, not too much.
    # Define "useful" as a range that can potentially fit medium-sized items.
    # We'll penalize very small residuals (waste) and very large residuals (potential waste).
    # A simple approach: a parabolic function favoring residuals around a certain proportion of item size.
    # Let's aim for residuals around 25-50% of the item's size.
    utility_score_component = np.zeros_like(remaining_after_fit)
    lower_utility_bound = item * 0.20
    upper_utility_bound = item * 0.50

    # Penalize residuals outside the utility bounds
    penalty_for_too_small = np.maximum(0, lower_utility_bound - remaining_after_fit) * 50.0
    penalty_for_too_large = np.maximum(0, remaining_after_fit - upper_utility_bound) * 20.0

    utility_score_component = -(penalty_for_too_small + penalty_for_too_large)

    # Combine primary scores (tightness and utility)
    combined_exploitation_scores = tight_fit_score + utility_score_component * 0.5 # Weight utility lower

    # --- Adaptive Exploration ---
    # Define a probability of exploring (not purely picking the best)
    exploration_prob = 0.10  # Base probability of considering exploration

    # Select candidates for exploration:
    # 1. Top-performing bins based on combined_exploitation_scores.
    # 2. Bins with residuals that are moderately useful (within utility bounds).
    sorted_indices_exploitation = np.argsort(combined_exploitation_scores)[::-1]
    num_top_candidates = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.1))) # Top 10%

    exploration_candidate_mask = np.zeros_like(combined_exploitation_scores, dtype=bool)
    exploration_candidate_mask[sorted_indices_exploitation[:num_top_candidates]] = True

    moderate_remaining_mask = (remaining_after_fit >= lower_utility_bound) & (remaining_after_fit <= upper_utility_bound)
    exploration_candidate_mask[moderate_remaining_mask] = True

    final_scores = np.copy(combined_exploitation_scores)

    # Apply a small random perturbation to selected exploration candidates
    perturbation_magnitude = 0.01
    exploration_decision_mask = np.random.rand(len(valid_bins_capacities)) < exploration_prob

    apply_exploration_mask = exploration_candidate_mask & exploration_decision_mask
    perturbation = (np.random.rand(len(valid_bins_capacities)) - 0.5) * 2 * perturbation_magnitude
    final_scores[apply_exploration_mask] += perturbation[apply_exploration_mask]

    priorities[valid_bins_indices] = final_scores

    return priorities
```
