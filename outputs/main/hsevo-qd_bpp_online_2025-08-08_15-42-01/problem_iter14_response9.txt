```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with perfect fit bonus and a guided exploration strategy,
    favoring bins that leave a moderate surplus after packing, with a probabilistic switch.
    """

    epsilon = 0.1  # Probability of exploring a candidate bin
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item

    # --- Exploitation: Tightest Fit with Bonuses ---
    # Score based on negative remaining capacity (tighter fit is better).
    exploitation_scores = -remaining_after_fit

    # Bonus for perfect fits (remaining capacity is negligible).
    perfect_fit_bonus = 10.0
    exploitation_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus

    # Penalty for leaving too much surplus relative to the item size.
    # Discourages bins that become excessively empty.
    large_surplus_threshold_ratio = 1.0  # If remaining capacity > item size
    large_surplus_penalty_factor = 0.5
    surplus_penalty_mask = remaining_after_fit > (item * large_surplus_threshold_ratio)
    exploitation_scores[surplus_penalty_mask] -= (remaining_after_fit[surplus_penalty_mask] / item) * large_surplus_penalty_factor

    # --- Guided Exploration Candidates ---
    # Identify bins that are good candidates for exploration.
    # These are bins that are either tight fits or leave a "moderate" surplus.
    
    # Sort by exploitation score to identify top candidates.
    sorted_indices_exploitation = np.argsort(exploitation_scores)[::-1]
    
    # Select top 20% of bins based on exploitation score as candidates.
    num_top_candidates = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.2)))
    exploration_candidate_mask_exploitation = np.zeros_like(exploitation_scores, dtype=bool)
    exploration_candidate_mask_exploitation[sorted_indices_exploitation[:num_top_candidates]] = True

    # Also consider bins that leave a moderate surplus (not too tight, not too empty).
    # Moderate surplus: between 20% and 100% of the item size.
    moderate_surplus_ratio_min = 0.2
    moderate_surplus_ratio_max = 1.0
    surplus_ratios = np.where(remaining_after_fit > 1e-9, remaining_after_fit / item, 0)
    
    exploration_candidate_mask_moderate = (surplus_ratios >= moderate_surplus_ratio_min) & \
                                           (surplus_ratios <= moderate_surplus_ratio_max)

    # Combine candidate masks: bins that are in top exploitation OR have moderate surplus.
    exploration_candidate_mask = exploration_candidate_mask_exploitation | exploration_candidate_mask_moderate
    
    # Generate small random exploration scores for these candidates.
    exploration_scores_for_candidates = np.random.rand(len(valid_bins_capacities)) * 0.05

    # --- Combine Exploitation and Exploration ---
    final_scores = np.copy(exploitation_scores)

    # Probabilistically switch to exploration score for selected candidates.
    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    apply_exploration_mask = exploration_candidate_mask & use_exploration_decision
    
    final_scores[apply_exploration_mask] = exploration_scores_for_candidates[apply_exploration_mask]

    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
