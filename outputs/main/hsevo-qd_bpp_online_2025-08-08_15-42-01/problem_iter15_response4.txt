```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using a multi-objective approach:
    1. Tightest fit (minimizing residual capacity).
    2. Penalizing bins that leave very large remaining capacity (waste).
    3. Rewarding bins that are "almost perfect" fits.
    4. Adaptive exploration biased towards bins with moderate remaining capacity,
       which might be useful for future items.
    """

    epsilon = 0.1  # Probability of exploration
    priorities = np.full_like(bins_remain_cap, -np.inf)

    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item

    # --- Scoring Components ---

    # 1. Tightest Fit Score: Negative of remaining capacity
    # Maximizing this means minimizing remaining capacity.
    tightness_score = -remaining_after_fit

    # 2. Waste Penalty: Penalize large remaining capacities to encourage packing efficiency.
    # Use a sigmoid-like function to penalize large residuals more significantly.
    # Scale the residual by a typical bin capacity or a large value to normalize.
    # Assume a default max capacity if not provided, or use a large number.
    max_bin_capacity_estimate = 1.0 # Can be a parameter or estimated
    large_residual_threshold = 0.7 * max_bin_capacity_estimate
    waste_penalty = -10 * (1 / (1 + np.exp(-(remaining_after_fit - large_residual_threshold))))
    # Higher penalty for larger residuals beyond the threshold.

    # 3. Near-Perfect Fit Bonus: Reward bins that are very close to a perfect fit.
    near_perfect_threshold = 0.01 * item # Within 1% of item size
    near_perfect_bonus = 5.0
    near_perfect_bonus_applied = np.where(np.abs(remaining_after_fit) < near_perfect_threshold, near_perfect_bonus, 0)

    # Combine scores for exploitation
    exploitation_scores = tightness_score + waste_penalty + near_perfect_bonus_applied

    # --- Exploration Strategy ---
    # Select a subset of bins for potential exploration.
    # Prioritize bins that are 'good enough' but not necessarily the absolute best.
    # This means considering bins with moderate remaining capacity.

    # Candidate selection:
    # - Bins with low exploitation scores (i.e., not very tight fits) but still viable.
    # - Bins with moderate remaining capacity (e.g., between 10% and 50% of item size).
    exploration_candidate_mask = np.zeros_like(exploitation_scores, dtype=bool)

    # Identify bins with moderate remaining capacity
    moderate_capacity_lower_bound = 0.1 * item
    moderate_capacity_upper_bound = 0.5 * item
    moderate_capacity_mask = (remaining_after_fit >= moderate_capacity_lower_bound) & (remaining_after_fit <= moderate_capacity_upper_bound)
    exploration_candidate_mask[moderate_capacity_mask] = True

    # Also include some of the "okay" fits that didn't make the top exploitation scores
    # but are still decent. Consider bins in the middle range of exploitation scores.
    sorted_exploitation_indices = np.argsort(exploitation_scores)
    num_exploration_candidates = max(1, int(len(valid_bins_capacities) * 0.2)) # Top 20% for exploration focus
    
    # Ensure we don't pick exclusively "bad" candidates if moderate_capacity is sparse
    num_from_top_exploitation = max(0, num_exploration_candidates - np.sum(exploration_candidate_mask))
    exploration_candidate_mask[sorted_exploitation_indices[-num_from_top_exploitation:]] = True


    # Generate small random scores for exploration candidates
    exploration_scores_random = np.random.rand(len(valid_bins_capacities)) * 0.1 # Small random variation

    # --- Combine Exploitation and Exploration ---
    final_scores = np.copy(exploitation_scores)

    # For bins chosen for exploration, randomly decide whether to use the exploration score
    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon
    apply_exploration_mask = exploration_candidate_mask & use_exploration_decision

    final_scores[apply_exploration_mask] = exploitation_scores[apply_exploration_mask] * (1 - epsilon) + exploration_scores_random[apply_exploration_mask] * epsilon

    priorities[valid_bins_indices] = final_scores

    return priorities
```
