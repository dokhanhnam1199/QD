```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements the Almost Full Fit strategy for the online Bin Packing Problem.

    This priority function aims to select a bin that is "almost full" but can still accommodate the item.
    It prioritizes bins that have a remaining capacity slightly larger than the item's size,
    aiming to leave minimal remaining space in the chosen bin.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element represents
        the priority score for placing the item in the corresponding bin. Higher scores
        indicate a higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            remaining_after_fit = bins_remain_cap[i] - item
            
            # High priority for bins that are almost full after fitting the item
            # This is achieved by giving a higher score to bins with smaller remaining capacity
            # after fitting, and penalizing bins that become exactly full (remaining_after_fit == 0)
            # slightly to encourage utilization of bins that can still hold more.
            
            # A simple approach: score is the inverse of the remaining capacity (larger is better, closer to 0)
            # Adding a small epsilon to avoid division by zero if remaining capacity is 0
            score = 1.0 / (remaining_after_fit + 1e-9) 
            
            # We can also consider the "closeness" to being full as the primary driver
            # A bin that fits the item with very little remaining space is highly desirable.
            # Let's combine these ideas. A bin that leaves a small but positive remainder is ideal.
            # A bin that leaves exactly 0 remainder is also good, but perhaps slightly less so than one
            # that leaves a tiny bit of space for future small items.

            # Let's prioritize bins where (remaining_capacity - item) is minimized but non-negative.
            # We want to maximize bins_remain_cap[i] - item.
            # If remaining_after_fit is small and positive, it's good.
            # If remaining_after_fit is 0, it's also good.
            # If remaining_after_fit is large, it's less good.

            # We can create a scoring function that peaks at a small positive remainder and
            # also gives good scores for zero remainder.
            # A gaussian-like function centered around 0 or a small value could work.

            # Let's simplify: prioritize bins that are *almost* full, meaning they have
            # a small remaining capacity *before* fitting the item.
            # The "almost full" strategy often implies picking the bin that will be
            # tightest after packing. So, we want to minimize `bins_remain_cap[i] - item`.
            # This is equivalent to maximizing `-(bins_remain_cap[i] - item)` or maximizing `item - bins_remain_cap[i]`.
            # But we also need the bin to fit the item, so `bins_remain_cap[i] >= item`.
            
            # Let's try to directly implement "almost full".
            # A bin is almost full if its remaining capacity is small, but still fits the item.
            # The "almost full" aspect is about the state *before* fitting.
            # A common interpretation is to pick the bin with the smallest capacity that can still fit the item.
            # If we interpret "Almost Full Fit" as minimizing `bins_remain_cap[i]` among those that fit,
            # then our priority should be inversely related to `bins_remain_cap[i]` for bins that fit.

            # To be "almost full" means having little remaining capacity.
            # So, we want the `bins_remain_cap[i]` to be as small as possible, but still `>= item`.
            # A common way to implement this for selection is to use `1 / (bins_remain_cap[i] - item)` or similar.
            # However, let's consider the prompt's emphasis on "almost full" for *selecting* the bin.
            # This usually means choosing the bin that becomes most full *after* adding the item.
            # So, we want to maximize `bins_remain_cap[i] - item` when it's close to 0.

            # Let's try prioritizing bins that result in the *smallest* positive remaining capacity after fitting.
            # This means we want to *minimize* `bins_remain_cap[i] - item`.
            # So, we should *maximize* `-(bins_remain_cap[i] - item)`.
            # A higher priority score should go to bins where `bins_remain_cap[i]` is just slightly larger than `item`.

            # Let's assign a score that is higher when `bins_remain_cap[i]` is closer to `item`.
            # Consider `bins_remain_cap[i] - item`. We want this value to be small and non-negative.
            # A simple way to reward small values is `1 / (value + epsilon)`.
            # So, `1 / (bins_remain_cap[i] - item + epsilon)`.
            
            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-6)
            
            # Alternative interpretation of "Almost Full":
            # Pick the bin whose remaining capacity `bins_remain_cap[i]` is "closest" to the bin capacity `C`,
            # given that `bins_remain_cap[i] >= item`.
            # If we consider the *total* capacity of the bins to be `C_total` (though not provided directly),
            # this interpretation is hard.
            
            # Let's stick to the interpretation of "Almost Full" as resulting in minimal remaining space after fitting.
            # This means minimizing `bins_remain_cap[i] - item`.
            # So, we want to give higher scores to smaller positive values of `bins_remain_cap[i] - item`.
            
            # Let's refine:
            # If `bins_remain_cap[i] - item` is 0, it's a perfect fit, assign a very high score.
            # If `bins_remain_cap[i] - item` is small and positive, assign a high score (close to perfect fit).
            # If `bins_remain_cap[i] - item` is larger, assign a lower score.
            
            if remaining_after_fit == 0:
                priorities[i] = 1e6  # Very high priority for a perfect fit
            else:
                # Score decreases as remaining capacity increases
                priorities[i] = 1.0 / remaining_after_fit
        
        else:
            # Bin cannot fit the item, assign a priority of 0 (or a very low number)
            priorities[i] = 0.0
            
    return priorities
```
