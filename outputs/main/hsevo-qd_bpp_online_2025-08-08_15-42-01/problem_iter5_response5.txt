```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with an epsilon-greedy exploration to balance fitting
    tightly and exploring diverse bin options.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    
    if valid_bins_capacities.size == 0:
        return priorities

    # Exploitation: Prioritize bins with the least remaining capacity after fitting.
    # This is the core of the Best Fit strategy.
    tight_fit_scores = -(valid_bins_capacities - item)
    
    # Add a small bonus for perfect fits to encourage minimizing waste.
    perfect_fit_bonus = 1e-6
    tight_fit_scores[np.abs(valid_bins_capacities - item) < 1e-9] += perfect_fit_bonus

    # Exploration: Assign random scores to a portion of valid bins.
    # This helps in discovering potentially better, non-obvious fits.
    exploration_scores = np.random.rand(len(valid_bins_capacities))

    # Epsilon-greedy: With probability epsilon, choose an exploration score,
    # otherwise, choose the exploitation (tight fit) score.
    use_exploration = np.random.rand(len(valid_bins_capacities)) < epsilon
    combined_scores = np.where(use_exploration, exploration_scores, tight_fit_scores)

    priorities[can_fit_mask] = combined_scores
    
    return priorities
```
