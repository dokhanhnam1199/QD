```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins that result in the tightest fit after packing,
    with a bonus for perfect fits and a fallback for worst-fit among remaining options."""

    # Initialize priorities with a very low value for bins that cannot fit the item.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item.
    fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after placing the item in valid bins.
    potential_remain_cap = bins_remain_cap[fit_mask] - item

    # Assign scores:
    # 1. High priority for perfect fits (remaining capacity = 0).
    #    We give a bonus score (e.g., 1.0) to indicate preference.
    perfect_fit_mask = potential_remain_cap == 0
    priorities[fit_mask][perfect_fit_mask] = 1.0

    # 2. For other valid fits, prioritize bins that leave less remaining capacity.
    #    This encourages a "tight" packing. We use the negative of the remaining capacity.
    #    The smallest non-negative remaining capacity will get the highest score here.
    non_perfect_fit_mask = ~perfect_fit_mask
    priorities[fit_mask][non_perfect_fit_mask] = -potential_remain_cap[non_perfect_fit_mask]

    # 3. Tie-breaking for bins that result in the same remaining capacity (or are perfect fits):
    #    Among bins with the same resulting remaining capacity, favor the one with the
    #    largest original remaining capacity (closer to worst-fit among good fits).
    #    This helps to keep smaller bins available for smaller items.
    #    We can achieve this by adding a small bonus proportional to the original capacity.
    #    Add a small epsilon to the priority to break ties.
    #    For perfect fits, they already have a score of 1.0. We want to differentiate them.
    #    Let's use the negative of the original remaining capacity as a secondary score.
    #    This means, for equally good fits, we prefer the one that was originally larger.
    #    The `item - bins_remain_cap[fit_mask]` was a good starting point for 'tightness'
    #    but did not handle tie-breaking well.

    # Let's combine the score: Prioritize by minimizing remaining capacity.
    # A simple way is to maximize `-(remaining_capacity)`.
    # To differentiate between equally good fits, we can use the original capacity.
    # If two bins result in the same remaining capacity, the one that started larger
    # (worst fit among the tightest) is preferred.
    # So, for the same `-(remaining_capacity)`, we want to maximize the original capacity.

    # Re-calculating for clarity and combined logic:
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    fit_mask = bins_remain_cap >= item

    # Calculate potential remaining capacity for fitting bins.
    potential_remain_cap_vals = bins_remain_cap[fit_mask] - item

    # Score: Primarily, minimize remaining capacity. Maximize -(remaining_capacity).
    # Secondary: For ties in remaining capacity, prefer larger original capacity.
    # This can be achieved by maximizing `original_capacity - item`.
    # Or more simply, `item - original_capacity` (smaller is better here, so maximize `-(item - original_capacity)`)
    # Let's focus on minimizing `potential_remain_cap_vals`.
    # A good score would be `-(potential_remain_cap_vals)`.
    # To break ties (same `potential_remain_cap_vals`), we prefer bins that had higher initial capacity.
    # So, we can add `bins_remain_cap[fit_mask]` as a secondary factor.
    # This means we want to maximize: `-(potential_remain_cap_vals) + C * bins_remain_cap[fit_mask]`
    # where C is a small constant to ensure primary sorting is by remaining capacity.

    # Let's use a simpler approach that captures the essence:
    # Prioritize bins that leave the least remainder.
    # For ties, pick the one that was originally larger.
    # Score = -(remaining_capacity) + small_bonus * original_capacity

    # Let's refine the score calculation.
    # For bins that fit:
    # Primary goal: Minimize `potential_remain_cap`.
    # Secondary goal: If `potential_remain_cap` is the same, pick the bin that was originally largest.

    # Score: `item - bins_remain_cap[fit_mask]` works well for tight fits.
    # The highest score is for `bins_remain_cap[fit_mask] == item`.
    # If there are multiple such bins, they have the same score.
    # To break ties, we can add a small value related to the original capacity.
    # Higher original capacity is preferred for ties in remaining capacity.

    # Let's use the inverse of remaining capacity, but penalize bins that are too large.
    # The "perfect fit" is ideal.
    # So, let's try a combined score:
    # - Perfect fit: Highest score (e.g., 100)
    # - Tight fit (small remaining capacity): Score inversely proportional to remaining capacity.
    # - Break ties by original capacity: Higher original capacity gets a small bonus.

    # Final approach:
    # 1. Perfect fits get a significant bonus (e.g., 1000).
    # 2. Other fits get a score based on inverse of remaining capacity + a small bonus
    #    for larger original capacity to break ties.
    #    Score = 1 / (potential_remain_cap + epsilon) + original_capacity * epsilon_small
    #    where epsilon is for avoiding division by zero and epsilon_small for tie-breaking.

    # Revised attempt focusing on minimizing remaining capacity and then maximizing original capacity for ties.
    # Score = -(remaining_capacity) + (original_capacity / MaxCapacity) * epsilon_tiebreak
    # This needs careful scaling.

    # Let's use a scoring that strongly favors perfect fits, then tight fits, and then larger original bins.
    scores = np.zeros_like(bins_remain_cap, dtype=float)
    scores.fill(-np.inf) # Initialize with a very low score

    can_fit_mask = bins_remain_cap >= item
    fitting_bins_capacity = bins_remain_cap[can_fit_mask]
    potential_remain_cap_vals = fitting_bins_capacity - item

    # Perfect fits have the highest priority
    perfect_fit_indices_in_fitting = np.where(potential_remain_cap_vals == 0)[0]
    if len(perfect_fit_indices_in_fitting) > 0:
        scores[can_fit_mask][perfect_fit_indices_in_fitting] = 1000.0

    # Tight fits get priority based on negative remaining capacity
    # Add a small factor to ensure they are ranked below perfect fits but above others.
    # The secondary criterion: prefer larger original capacity among those with same remainder.
    # We can add `fitting_bins_capacity` multiplied by a small factor.
    # Let's combine this into a single score for non-perfect fits.
    non_perfect_fit_indices_in_fitting = np.where(potential_remain_cap_vals > 0)[0]
    if len(non_perfect_fit_indices_in_fitting) > 0:
        # Score = -(remaining_capacity) + bonus for larger original capacity
        # The bonus should be small enough not to override the primary goal of minimizing remainder.
        # Use a small fraction of max possible capacity as tie-breaker.
        # Max possible remainder is roughly bin_capacity. So, max of `fitting_bins_capacity` can be used.
        max_cap_val = np.max(fitting_bins_capacity) if fitting_bins_capacity.size > 0 else 1.0
        tie_breaker_factor = 1e-6 # A very small factor for tie-breaking

        # Score for non-perfect fits: prioritize less remaining capacity, then more original capacity.
        scores[can_fit_mask][non_perfect_fit_indices_in_fitting] = \
            -(potential_remain_cap_vals[non_perfect_fit_indices_in_fitting]) \
            + (fitting_bins_capacity[non_perfect_fit_indices_in_fitting] / max_cap_val) * tie_breaker_factor

    # Ensure perfect fits still have highest priority if they exist
    # If perfect fits were assigned 1000.0, and non-perfect fits get scores like -0.1 + 0.99 * 1e-6,
    # this order is maintained.

    # If there are no perfect fits, and multiple bins have the same minimal remainder,
    # the tie-breaker correctly selects the one with higher original capacity.

    return scores
```
