{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines tight-fitting (Best Fit) with a penalty for large unused capacity\n    and a bonus for perfect fits, guided by adaptive exploration principles.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    fitting_bins_capacities = bins_remain_cap[can_fit_mask]\n    \n    # Score: Primarily, minimize remaining capacity. Maximize -(remaining_capacity).\n    # Secondary: For ties in remaining capacity, prefer larger original capacity (closer to worst-fit among good fits).\n    # Bonus for perfect fit, penalty for large unused capacity.\n    \n    # Calculate remaining capacity if item fits\n    potential_remain_cap_vals = fitting_bins_capacities - item\n    \n    # Base score: favoring tight fits (smaller remaining capacity)\n    # Use negative remaining capacity to maximize for smaller remainders.\n    scores = -potential_remain_cap_vals\n    \n    # Bonus for perfect fits\n    perfect_fit_mask = np.isclose(potential_remain_cap_vals, 0)\n    scores[perfect_fit_mask] += 10.0 # Significant bonus for perfect fit\n    \n    # Penalty for large unused capacity: Discourage bins that are much larger than needed.\n    # This is a form of guided exploration towards \"good enough\" bins.\n    # We penalize bins where the remaining capacity is significantly larger than a small residual.\n    # A simple penalty could be proportional to the surplus capacity, but we want it to be less\n    # impactful than the tight-fitting score.\n    # Let's add a penalty that decreases the score for bins with large remaining capacity.\n    # This penalty should be smaller than the gains from tight fits.\n    # Penalty factor: For every unit of capacity above a small threshold (e.g., 10% of item size),\n    # we slightly reduce the score.\n    \n    # Define a threshold for \"large unused capacity\"\n    large_capacity_threshold = item * 0.5 # e.g., if remaining capacity is > 50% of item size\n\n    # Calculate penalty: linearly decreasing score for capacity beyond the threshold.\n    # Bins with capacity <= threshold get no penalty.\n    penalty = np.zeros_like(scores)\n    large_surplus_mask = potential_remain_cap_vals > large_capacity_threshold\n    \n    # The penalty is proportional to how much the surplus exceeds the threshold.\n    # We want this penalty to be relatively small compared to the tight-fit scores.\n    # e.g., subtract (surplus - threshold) / max_possible_surplus * small_value\n    max_possible_surplus = np.max(fitting_bins_capacities) # An upper bound on surplus\n    \n    if np.any(large_surplus_mask) and max_possible_surplus > 0:\n        penalty[large_surplus_mask] = (potential_remain_cap_vals[large_surplus_mask] - large_capacity_threshold) / max_possible_surplus * 5.0\n        \n    scores -= penalty\n\n    # Assign the calculated scores to the original bins array\n    priorities[can_fit_mask] = scores\n    \n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}