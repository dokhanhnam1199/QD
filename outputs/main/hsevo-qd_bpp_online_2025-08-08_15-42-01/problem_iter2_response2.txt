```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Assigns priorities to bins based on a hybrid Best-Fit and penalty strategy.
    Prioritizes bins that result in minimal remaining capacity (tightest fit),
    giving a significant bonus for perfect fits and a slight penalty for
    bins that become too full.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Calculate potential remaining capacity for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    potential_remain_cap = bins_remain_cap[can_fit_mask] - item

    # Assign base priority: favor bins with less remaining capacity after packing
    # Maximizing -(potential_remain_cap) is equivalent to minimizing potential_remain_cap
    priorities[can_fit_mask] = -potential_remain_cap

    # Apply bonus for perfect fits (remaining capacity is zero)
    perfect_fit_mask = (potential_remain_cap == 0)
    if np.any(perfect_fit_mask):
        priorities[can_fit_mask][perfect_fit_mask] += 1.0  # Bonus for perfect fit

    # Apply a small penalty for bins that would become "too full" (negative remaining capacity, though handled by mask)
    # Or a slightly reduced priority for bins that have a lot of leftover space.
    # This can be implicitly handled by the negative remaining capacity scoring,
    # but we can also make it more explicit if needed.
    # For now, the negative remaining capacity score already penalizes larger leftovers.

    # Consider a penalty for bins that *can* fit but leave a very large remainder.
    # This discourages placing small items in very large bins if a tighter fit exists.
    large_remainder_mask = (potential_remain_cap > item * 0.5) & ~perfect_fit_mask
    if np.any(large_remainder_mask):
        priorities[can_fit_mask][large_remainder_mask] -= 0.5 # Small penalty for large remainders

    return priorities
```
