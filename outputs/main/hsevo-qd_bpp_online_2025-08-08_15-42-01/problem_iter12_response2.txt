```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins using an adaptive multi-objective approach.
    It balances tightest fit, perfect fit bonus, and a novel "future-proofing"
    score that favors bins with capacities that are good divisors or multiples
    of common item sizes, promoting better long-term packing efficiency.
    Exploration is guided by prioritizing bins that are not yet too full and
    could accommodate future items.
    """

    epsilon = 0.1  # Increased probability of exploration for better adaptation
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    # --- Core Exploitation: Tightest Fit & Perfect Fit ---
    remaining_after_fit = valid_bins_capacities - item
    exploitation_scores = -remaining_after_fit
    perfect_fit_bonus = 1000.0
    exploitation_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus
    
    # Penalty for large surplus: reduced to be more sensitive to smaller items
    large_surplus_threshold_ratio = 0.3
    large_surplus_penalty_factor = 0.05
    surplus_penalty_mask = remaining_after_fit > (item * large_surplus_threshold_ratio)
    exploitation_scores[surplus_penalty_mask] -= (remaining_after_fit[surplus_penalty_mask] / item) * large_surplus_penalty_factor

    # --- Novel Feature: Future-Proofing Score ---
    # This score aims to identify bins that might be more useful for future items.
    # It favors bins whose remaining capacity is a "good" size relative to the item.
    # "Good" is defined here as capacities that are multiples or divisors of common item sizes (e.g., 0.5, 0.25).
    # This encourages leaving capacities that are easier to fill with subsequent items.
    
    future_proofing_scores = np.zeros_like(valid_bins_capacities)
    
    # Consider capacities that are multiples of smaller standard fractions
    common_fractions = [0.1, 0.2, 0.25, 0.33, 0.5]
    
    for frac in common_fractions:
        # Score higher if remaining capacity is close to a multiple of the fraction
        for multiple in range(1, int(np.max(valid_bins_capacities) / frac) + 2):
            target_capacity = frac * multiple
            diff = np.abs(valid_bins_capacities - target_capacity)
            # Add a bonus if the difference is small relative to the bin's current remaining capacity
            # and also small in absolute terms.
            bonus_mask = (diff < 0.1) & (diff / valid_bins_capacities < 0.1)
            future_proofing_scores[bonus_mask] += (1.0 - diff[bonus_mask] / 0.1) * (0.5 * frac) # Bonus proportional to fraction size

    # Favor bins that, after packing, have a reasonable amount of remaining space,
    # but not excessively much. This part complements future-proofing.
    # Bins that are nearly full but not perfectly full might be less ideal for future items.
    # This score is a bit inverse to the surplus penalty.
    moderate_remaining_bonus_mask = (remaining_after_fit > item * 0.1) & (remaining_after_fit < item * 0.8)
    future_proofing_scores[moderate_remaining_bonus_mask] += 0.2 * (remaining_after_fit[moderate_remaining_bonus_mask] / item)


    # --- Adaptive Exploration Strategy ---
    # Exploration candidates are bins that are not excessively full and
    # also have some potential for future-proofing.
    
    # Combine exploitation and future-proofing for candidate selection
    combined_strategic_score = exploitation_scores + future_proofing_scores * 0.5 # Give future-proofing a moderate weight
    sorted_indices_strategic = np.argsort(combined_strategic_score)[::-1]

    exploration_candidate_mask = np.zeros_like(combined_strategic_score, dtype=bool)
    
    # Select top 25% based on strategic score for exploration
    num_candidates_from_top = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.25)))
    exploration_candidate_mask[sorted_indices_strategic[:num_candidates_from_top]] = True
    
    # Also include bins that are "moderately fit" and have good future-proofing potential
    moderate_fit_mask = (remaining_after_fit > item * 0.1) & (remaining_after_fit < item * 0.5)
    good_future_proofing_mask = future_proofing_scores > np.median(future_proofing_scores)
    exploration_candidate_mask[moderate_fit_mask & good_future_proofing_mask] = True

    # Generate low-magnitude random noise for exploration candidates
    exploration_noise = np.random.rand(len(valid_bins_capacities)) * 0.02

    # --- Combine Exploitation and Exploration ---
    # With probability epsilon, use exploration score for candidates; otherwise, use the combined strategic score.
    # For non-candidates, use the combined strategic score.
    
    final_scores = np.copy(combined_strategic_score)
    
    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    apply_exploration_mask = exploration_candidate_mask & use_exploration_decision
    final_scores[apply_exploration_mask] = exploration_noise[apply_exploration_mask]

    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
