```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_original_cap: np.ndarray, max_capacity: float) -> np.ndarray:
    """
    Combines Best Fit with a penalty for large remaining capacity and a bonus
    for bins with higher original capacity to promote packing larger items.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item

    # Base score: Prioritize tighter fits (negative remaining capacity)
    tight_fit_score = -bins_remain_cap[can_fit_mask]

    # Penalty for large remaining capacity to avoid extreme waste
    waste_penalty = 0.1 * bins_remain_cap[can_fit_mask]

    # Bonus for bins with higher original capacity to keep them available for larger items
    # Normalize original capacity to avoid extreme values dominating the score
    capacity_bonus = (bin_original_cap[can_fit_mask] / max_capacity) * 10

    # Combine scores: favor tight fits, penalize waste, reward retaining capacity
    priorities[can_fit_mask] = tight_fit_score - waste_penalty + capacity_bonus

    return priorities
```
