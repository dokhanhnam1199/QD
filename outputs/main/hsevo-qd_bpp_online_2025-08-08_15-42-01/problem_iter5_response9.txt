```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tight packing preference with a penalty for large wasted space,
    and a bonus for near-perfect fits, aiming for efficient and strategic packing.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item

    if np.sum(can_fit_mask) == 0:
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    remaining_after_fit = valid_bins_capacities - item

    # Score 1: Best Fit component - prioritize bins with minimal remaining space after fitting.
    # This is essentially prioritizing the smallest positive `remaining_after_fit`.
    # We use a negative value so that smaller remaining_after_fit gets a higher score.
    # Adding a small epsilon to avoid division by zero for perfect fits, then scaling.
    best_fit_score = -100.0 / (remaining_after_fit + 1e-9)

    # Score 2: Penalty for large wasted space - penalize bins that leave a lot of capacity.
    # This discourages using a bin that is only slightly occupied.
    # Normalize remaining capacity to bound the penalty.
    max_residual = np.max(bins_remain_cap) # Max possible remaining capacity before fitting
    large_waste_penalty = - (remaining_after_fit / max_residual) * 50.0 if max_residual > 0 else 0.0

    # Score 3: Bonus for near-perfect fits - reward bins that leave very little space.
    near_perfect_fit_threshold = 0.05
    perfect_fit_bonus = 20.0
    near_perfect_fit_bonus = 10.0

    perfect_fit_mask = np.isclose(remaining_after_fit, 0.0, atol=1e-9)
    near_perfect_fit_mask = (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_fit_threshold)

    fit_bonus = np.zeros_like(remaining_after_fit)
    fit_bonus[perfect_fit_mask] = perfect_fit_bonus
    fit_bonus[near_perfect_fit_mask] = near_perfect_fit_bonus

    # Combine scores: Prioritize tight fits (Best Fit), penalize large waste, and reward near-perfect fits.
    # The weights are empirical and can be tuned.
    combined_scores = best_fit_score + large_waste_penalty + fit_bonus

    priorities[can_fit_mask] = combined_scores

    return priorities
```
