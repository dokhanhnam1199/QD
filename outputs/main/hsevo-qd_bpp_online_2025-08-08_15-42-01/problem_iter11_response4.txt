```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best-Fit with a penalty for large remainders and a bonus for perfect fits,
    prioritizing tighter fits and penalizing inefficient packing.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    potential_remain_cap = bins_remain_cap[can_fit_mask] - item

    # Primary objective: favor bins with minimal remaining capacity (tightest fit)
    priorities[can_fit_mask] = -potential_remain_cap

    # Bonus for perfect fits
    perfect_fit_mask = (potential_remain_cap == 0)
    if np.any(perfect_fit_mask):
        priorities[can_fit_mask][perfect_fit_mask] += 1.5  # Increased bonus for perfect fit

    # Penalty for bins that leave a large remainder, discouraging suboptimal fits
    # Only apply penalty if it's not a perfect fit and remainder is significant
    large_remainder_mask = (potential_remain_cap > item * 0.5) & ~perfect_fit_mask
    if np.any(large_remainder_mask):
        priorities[can_fit_mask][large_remainder_mask] -= 0.75 # Increased penalty

    # Ensure that bins that cannot fit the item have the lowest priority (-inf)
    # This is already handled by initialization, but explicit check for clarity.
    priorities[~can_fit_mask] = -np.inf

    return priorities
```
