```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    
    epsilon = 0.03
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # Multi-objective scoring:
    # 1. Tightness score: Prioritize bins that leave minimum remaining capacity.
    # 2. Waste avoidance score: Penalize bins that would have a large surplus.
    # 3. Future capacity score: Reward bins that still have substantial capacity after packing.
    
    tightness_score = -remaining_after_fit
    
    # Penalty for large remainders, scaled by item size
    waste_penalty_factor = 0.005
    waste_avoidance_score = (remaining_after_fit / item) * waste_penalty_factor
    
    # Reward for significant remaining capacity - can be useful for larger items later
    future_capacity_score = remaining_after_fit / np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else np.zeros_like(remaining_after_fit)
    
    # Combine objectives with weights. These weights can be tuned.
    # We want to strongly favor tightness, moderately avoid waste, and lightly favor future capacity.
    weight_tightness = 1.0
    weight_waste = 0.5
    weight_future_capacity = 0.2
    
    combined_scores = (weight_tightness * tightness_score - 
                       weight_waste * waste_avoidance_score + 
                       weight_future_capacity * future_capacity_score)

    # Enhanced Exploration:
    # Instead of random exploration, we can introduce guided exploration.
    # This means exploring bins that are "good enough" but not necessarily the absolute best.
    # We can define "good enough" as bins that fall within a certain percentile of the best fits.
    
    # Sort bins by the combined score to identify top candidates
    sorted_indices_combined = np.argsort(combined_scores)[::-1]
    
    exploration_candidate_indices_in_valid = []
    
    # Identify a range of bins to consider for exploration
    # This could be the top K bins, or bins within a certain score range.
    # Let's consider bins within the top 30% of scores, or at least the top 3 bins.
    num_top_bins = max(3, int(len(valid_bins_capacities) * 0.3))
    top_candidate_indices_in_valid = sorted_indices_combined[:num_top_bins]
    
    # Also consider bins that offer a "balanced" fit, not too tight, not too empty.
    # A bin that leaves a moderate amount of space might be more versatile.
    # Let's consider bins where remaining_after_fit is between a small fraction and a larger fraction of bin capacity.
    
    # To define "moderate", we can look at the distribution of remaining capacities.
    # Let's use quartiles for guidance.
    q1_rem = np.percentile(remaining_after_fit, 25)
    q3_rem = np.percentile(remaining_after_fit, 75)
    
    # Bins with remaining capacity between Q1 and Q3 (inclusive of Q3) are considered moderately remaining.
    moderate_capacity_mask = (remaining_after_fit >= q1_rem) & (remaining_after_fit <= q3_rem)
    
    # Combine indices for exploration candidates
    all_candidate_indices_in_valid = set(top_candidate_indices_in_valid)
    all_candidate_indices_in_valid.update(np.where(moderate_capacity_mask)[0])
    
    exploration_candidate_indices_in_valid = list(all_candidate_indices_in_valid)

    # Generate exploration scores for these candidates
    # We want these exploration scores to be slightly random but not too high,
    # to offer a chance for diversity without sacrificing too much performance.
    exploration_scores = np.random.uniform(-0.1, 0.1, size=len(valid_bins_capacities))
    
    # Apply exploration scores:
    # With probability epsilon, use exploration score for exploration candidates.
    # Otherwise, use the combined score.
    # For non-candidates, always use the combined score.
    
    final_scores = np.copy(combined_scores)
    
    # Create a mask for the identified exploration candidates
    exploration_mask = np.zeros_like(valid_bins_capacities, dtype=bool)
    if exploration_candidate_indices_in_valid:
        exploration_mask[exploration_candidate_indices_in_valid] = True
    
    # Decide whether to use exploration score for exploration candidates
    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply the exploration scores only to the chosen candidates
    final_scores[exploration_mask & use_exploration_for_candidates] = exploration_scores[exploration_mask & use_exploration_for_candidates]
    
    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
