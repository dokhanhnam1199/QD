```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit's tight packing preference with a bonus for perfect fits
    and a penalty for large wasted space, inspired by heuristic_v1 and heuristic_v18.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item

    if np.sum(can_fit_mask) == 0:
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    remaining_after_fit = valid_bins_capacities - item

    # Score 1: Best Fit component - prioritize bins with minimal remaining space.
    # Add a small epsilon for numerical stability and to ensure positive scores for tight fits.
    best_fit_score = 1.0 / (remaining_after_fit + 1e-9)

    # Score 2: Penalty for large wasted space.
    # Scale by the maximum possible original bin capacity to normalize the penalty.
    # Use a fraction of the maximum possible remaining capacity.
    max_original_capacity = np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0
    large_waste_penalty = - (remaining_after_fit / max_original_capacity) * 5.0

    # Score 3: Bonus for near-perfect fits.
    # Higher bonus for exact fits, smaller bonus for very small remaining space.
    near_perfect_threshold = 0.05 * max_original_capacity
    perfect_fit_bonus = 100.0
    near_perfect_fit_bonus = 10.0

    perfect_fit_mask = np.isclose(remaining_after_fit, 0.0, atol=1e-9)
    near_perfect_fit_mask = (remaining_after_fit > 0) & (remaining_after_fit <= near_perfect_threshold)

    fit_bonus = np.zeros_like(remaining_after_fit)
    fit_bonus[perfect_fit_mask] = perfect_fit_bonus
    fit_bonus[near_perfect_fit_mask] = near_perfect_fit_bonus

    # Combine scores: Emphasize tight fits, penalize significant waste, reward perfect fits.
    # Weights are tuned for a balance.
    combined_scores = best_fit_score + large_waste_penalty + fit_bonus

    priorities[can_fit_mask] = combined_scores

    return priorities
```
