```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by favoring tight fits and perfect fits, with a fallback to worst fit.

    Combines the tight-fitting approach of v0 with the explicit bonus for perfect fits
    and a tie-breaking mechanism for the worst fit among available bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    available_bins_mask = bins_remain_cap >= item

    if not np.any(available_bins_mask):
        return priorities

    available_bins_cap = bins_remain_cap[available_bins_mask]

    # Base priority: inverse of remaining capacity after placing the item (favors tight fits)
    # Add epsilon to avoid division by zero.
    priorities[available_bins_mask] = 1.0 / (available_bins_cap - item + 1e-6)

    # Bonus for perfect fits: highest priority if an item exactly fills a bin
    perfect_fit_mask = np.isclose(bins_remain_cap, item)
    perfect_fit_available_mask = perfect_fit_mask & available_bins_mask
    if np.any(perfect_fit_available_mask):
        priorities[perfect_fit_available_mask] = np.max(priorities[available_bins_mask]) + 1.0

    # Tie-breaking for bins that are not perfect fits:
    # If there are multiple bins with the same "tightest fit" score (and not perfect fits),
    # we can use a secondary criterion. Here, we'll give a slight bonus to the
    # bin with the largest remaining capacity among these "equally tight" bins,
    # similar to a worst-fit among the tightest options, to leave more options for later small items.
    # This logic needs to be applied carefully to avoid overwriting perfect fit bonuses.

    # Find the maximum priority score among non-perfect fits
    non_perfect_fit_available_mask = available_bins_mask & ~perfect_fit_mask
    if np.any(non_perfect_fit_available_mask):
        max_non_perfect_priority = np.max(priorities[non_perfect_fit_available_mask])
        
        # Identify bins that have this max non-perfect priority
        bins_with_max_priority_mask = np.isclose(priorities, max_non_perfect_priority) & non_perfect_fit_available_mask

        if np.any(bins_with_max_priority_mask):
            # Among those, find the one with the largest remaining capacity
            capacities_at_max_priority = bins_remain_cap[bins_with_max_priority_mask]
            worst_fit_among_tight_idx = np.argmax(capacities_at_max_priority)
            
            # Get the original index in bins_remain_cap
            original_indices = np.where(bins_with_max_priority_mask)[0]
            worst_fit_original_idx = original_indices[worst_fit_among_tight_idx]

            # Apply a slight bonus (less than perfect fit bonus)
            priorities[worst_fit_original_idx] = max_non_perfect_priority + 0.5

    return priorities
```
