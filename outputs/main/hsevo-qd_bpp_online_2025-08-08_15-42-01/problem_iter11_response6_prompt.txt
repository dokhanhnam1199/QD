{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins for tightest fit, with a bonus for perfect fits.\n\n    Combines the 'Almost Full Fit' idea with a bonus for bins that become exactly full,\n    and a small penalty for bins that leave significant residual space,\n    while ensuring unfillable bins receive the lowest priority.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    fit_mask = bins_remain_cap >= item\n\n    # Calculate scores for bins that can fit the item\n    remaining_capacities_after_fit = bins_remain_cap[fit_mask] - item\n\n    # Prioritize bins that result in smallest remaining capacity (tightest fit)\n    # Use the negative of remaining capacity to turn minimization into maximization\n    # Add a small value to ensure negative remaining capacities are prioritized\n    # over positive ones.\n    scores = -remaining_capacities_after_fit\n\n    # Add a bonus for perfect fits (remaining capacity is zero)\n    # This encourages using bins that are exactly filled.\n    perfect_fit_bonus = 1.0\n    scores[remaining_capacities_after_fit == 0] += perfect_fit_bonus\n\n    # Assign the calculated scores to the valid bins\n    priorities[fit_mask] = scores\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a Random Fit strategy.\"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n    fitting_bins_indices = np.where(bins_remain_cap >= item)[0]\n    if len(fitting_bins_indices) > 0:\n        priorities[fitting_bins_indices] = np.random.rand(len(fitting_bins_indices))\n    return priorities\n\n### Analyze & experience\n- Comparing Heuristic 1 (Best) vs. Heuristic 2 (Worst in this comparison): Both heuristics implement a multi-objective scoring system with exploration. Heuristic 1 is marginally better as it defines exploration candidates based on a combination of top scores and percentile-based moderate capacity, making its exploration more guided. Heuristic 2's exploration candidate selection is identical.\n\nComparing Heuristic 1 vs. Heuristic 3: Heuristic 1 uses a more sophisticated multi-objective approach (tightness, waste, future capacity) compared to Heuristic 3's simple tight fit with a perfect fit bonus and basic epsilon-greedy exploration. Heuristic 1's guided exploration is also more nuanced than Heuristic 3's random assignment.\n\nComparing Heuristic 3 vs. Heuristic 5: Heuristic 3 combines tight fitting with random exploration (epsilon-greedy), while Heuristic 5 focuses purely on tight fitting with a perfect fit bonus. Heuristic 3's exploration component, though basic, offers more potential for finding diverse solutions than Heuristic 5's deterministic approach.\n\nComparing Heuristic 5 vs. Heuristic 7: These heuristics are identical, both focusing on tight fitting with a perfect fit bonus.\n\nComparing Heuristic 8 vs. Heuristic 12: Heuristic 8 employs a more refined strategy, balancing tight fitting, perfect fit bonuses, and penalties for large remainders. Heuristic 12 uses a simple inverse capacity for scoring and a binary perfect fit bonus. Heuristic 8's more nuanced scoring and penalty system likely leads to better packing.\n\nComparing Heuristic 12 vs. Heuristic 15: Both use a simple approach where capacity dictates priority. Heuristic 12 assigns a value of 1.0 for perfect fits and `1.0 / remaining_capacity` otherwise, while Heuristic 15 assigns a random value to fitting bins. Heuristic 12's deterministic scoring for good fits is generally more desirable than random assignment.\n\nComparing Heuristic 14 vs. Heuristic 17: Heuristic 14 implements a multi-objective scoring system (tightest fit, future utility, awkward empty penalty) with a guided exploration strategy. Heuristic 17 uses similar concepts but with different weighting and thresholds, and its parameters are tuned. Without knowing the exact performance impact of the specific parameter values in Heuristic 17, it's difficult to definitively rank them, but Heuristic 14's systematic approach to multi-objective scoring and guided exploration makes it a strong contender.\n\nOverall: Heuristics that combine a primary objective (like tight fitting) with secondary objectives (like waste avoidance, future utility) and employ guided exploration strategies (rather than pure random exploration) tend to perform better. The inclusion of specific bonuses for perfect fits and penalties for undesirable states (e.g., large surpluses) also improves heuristic design. Simple random or worst-fit strategies are generally the least effective.\n- \nHere's a redefined approach to self-reflection for designing better optimization heuristics:\n\n*   **Keywords:** Adaptive, multi-objective, guided exploration, performance feedback.\n*   **Advice:** Focus on heuristics that learn from past placements and dynamically adjust their strategy. Integrate feedback mechanisms to refine scoring and exploration parameters based on actual packing outcomes.\n*   **Avoid:** Static rules, brute-force random sampling, or heuristics that don't adapt to problem instance characteristics.\n*   **Explanation:** True self-reflection involves understanding *why* a heuristic performs well or poorly on specific instances, leading to more intelligent adaptation rather than just applying predefined complex rules.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}