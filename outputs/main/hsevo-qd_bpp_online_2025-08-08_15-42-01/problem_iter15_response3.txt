```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:

    epsilon = 0.05  # Probability of exploration
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # --- Multi-Objective Scoring ---
    # Objective 1: Tightness (minimize remaining capacity)
    # Use a Softmax-like approach for tight fits, giving higher scores to smaller residuals.
    # Add a constant to avoid log(0) issues if residual is exactly 0.
    tightness_score = -remaining_after_fit
    
    # Objective 2: Future Utility (reward bins with capacity that can still fit moderate items)
    # This encourages leaving some space, but not too much.
    # A bin with remaining capacity equal to item size is a good candidate for future items.
    # Use a Gaussian-like function centered around the item size.
    future_utility_score = np.exp(-((remaining_after_fit - item) / item)**2)

    # Objective 3: Penalty for Excessive Waste (discourage very large remaining capacities)
    # Use an inverse relationship with remaining capacity, but capped to avoid extreme penalties.
    # We'll penalize bins where remaining_after_fit is significantly larger than 'item'.
    waste_penalty = -np.tanh(remaining_after_fit / max(1.0, item * 2)) # Penalize larger residuals

    # Combine objectives with weights
    # Weights can be tuned. Here, tightness is prioritized, with future utility and waste penalty as secondary.
    tightness_weight = 1.0
    future_utility_weight = 0.5
    waste_penalty_weight = 0.3
    
    combined_exploitation_scores = (tightness_weight * tightness_score +
                                   future_utility_weight * future_utility_score +
                                   waste_penalty_weight * waste_penalty)

    # --- Adaptive Exploration ---
    # Explore among bins that are either very good fits (low residual) or have moderate future utility.
    # Instead of purely random, select candidates based on a mix of objectives.

    # Identify promising candidates for exploration:
    # 1. Top K% of bins by combined exploitation score.
    # 2. Bins with very small residuals (potential perfect fits).
    # 3. Bins with moderate future utility.

    sorted_indices_exploitation = np.argsort(combined_exploitation_scores)[::-1]
    
    exploration_candidate_mask = np.zeros_like(combined_exploitation_scores, dtype=bool)
    
    num_top_k = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.25))) # Top 25%
    exploration_candidate_mask[sorted_indices_exploitation[:num_top_k]] = True
    
    # Add bins with very small residuals
    very_small_residual_threshold = 1e-3
    exploration_candidate_mask[remaining_after_fit < very_small_residual_threshold] = True

    # Add bins with good future utility (e.g., where remaining capacity is around item size)
    moderate_future_utility_threshold = 0.8 # Based on the exp function
    exploration_candidate_mask[future_utility_score > moderate_future_utility_threshold] = True

    # Generate exploration scores for candidates.
    # The scores should be distinct but not deterministic.
    # We can use a combination of their objective scores but add a small noise.
    # Ensure the noise doesn't completely override the score.
    exploration_scores_raw = combined_exploitation_scores[exploration_candidate_mask]
    noise = np.random.randn(np.sum(exploration_candidate_mask)) * 0.05 # Small Gaussian noise
    exploration_scores_processed = exploration_scores_raw + noise

    # --- Combine Exploitation and Exploration ---
    
    # Create final scores, starting with exploitation scores for all valid bins.
    final_scores = np.copy(combined_exploitation_scores)
    
    # For the selected exploration candidates, with probability epsilon, use their processed exploration score.
    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply exploration scores only to candidates where exploration is chosen.
    exploration_indices_to_apply = np.where(exploration_candidate_mask & use_exploration_decision)[0]
    
    # Map these indices back to the original valid_bins_indices
    original_indices_for_exploration = valid_bins_indices[exploration_candidate_mask]
    
    if len(exploration_indices_to_apply) > 0:
        # Get the raw exploration scores for these specific bins
        raw_exploration_scores_for_selected = combined_exploitation_scores[original_indices_for_exploration]
        noise_for_selected = np.random.randn(len(exploration_indices_to_apply)) * 0.05
        final_scores[original_indices_for_exploration[exploration_indices_to_apply]] = raw_exploration_scores_for_selected + noise_for_selected

    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
