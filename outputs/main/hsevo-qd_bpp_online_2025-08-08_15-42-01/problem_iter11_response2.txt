```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a bonus for perfect fits and an epsilon-greedy
    strategy that prioritizes bins with moderate remaining capacity for exploration.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    # Exploitation: Prioritize bins with least remaining capacity after fitting (tight fit)
    # Add a bonus for perfect fits.
    remaining_after_fit = valid_bins_capacities - item
    tight_fit_scores = -remaining_after_fit
    perfect_fit_bonus = 1.0  # Higher bonus for exact fits
    tight_fit_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus

    # Exploration: Select a subset of bins for exploration.
    # Prefer bins with moderate remaining capacity (not too full, not too empty)
    # to allow for future packing flexibility.
    exploration_candidates_mask = np.logical_and(remaining_after_fit > 1e-9, remaining_after_fit < np.median(remaining_after_fit[remaining_after_fit > 1e-9] if np.any(remaining_after_fit > 1e-9) else [0]))
    
    exploration_scores = np.zeros_like(valid_bins_capacities)
    if np.any(exploration_candidates_mask):
        exploration_scores[exploration_candidates_mask] = np.random.rand(np.sum(exploration_candidates_mask))
    else: # If no moderate bins, explore any fitting bin randomly
        exploration_scores = np.random.rand(len(valid_bins_capacities))

    # Combine exploitation and exploration using epsilon-greedy
    use_exploration_mask = np.random.rand(len(valid_bins_capacities)) < epsilon
    combined_scores = np.where(use_exploration_mask, exploration_scores, tight_fit_scores)

    priorities[valid_bins_indices] = combined_scores
    
    return priorities
```
