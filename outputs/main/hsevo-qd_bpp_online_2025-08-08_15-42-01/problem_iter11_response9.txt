```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for large remaining capacity and a bonus for near-perfect fits,
    prioritizing bins that can fit the item and are most efficient.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item

    # Calculate scores for bins that can fit the item
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # Base score: Prioritize tighter fits (Best Fit)
    best_fit_score = -fitting_bins_remain_cap
    
    # Penalty for large remaining capacity to avoid overly sparse bins
    waste_penalty = 0.5 * fitting_bins_remain_cap
    
    # Bonus for near-perfect fits to exploit efficient packing opportunities
    # Using a Gaussian-like function to reward fits close to zero remaining capacity
    perfect_fit_bonus = 5 * np.exp(-((fitting_bins_remain_cap - item)**2) / 0.1)

    # Combine scores: Prioritize best fit, penalize waste, reward perfect fits
    scores = best_fit_score - waste_penalty + perfect_fit_bonus

    priorities[can_fit_mask] = scores

    return priorities
```
