```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a penalty for significant waste and a bonus for future utility,
    using guided exploration for diversity.
    """
    epsilon = 0.05  # Probability for exploration
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # --- Multi-objective Scoring ---
    # 1. Tightness score: Prioritize bins that leave minimum remaining capacity.
    tightness_score = -remaining_after_fit
    
    # 2. Waste avoidance score: Penalize bins that leave a large surplus relative to the item size.
    # This encourages using bins that are not excessively large for the item.
    waste_penalty_factor = 0.01
    # Use max(1, item) to prevent division by zero and handle very small items gracefully.
    waste_avoidance_score = (remaining_after_fit / np.maximum(1.0, item)) * waste_penalty_factor
    
    # 3. Future capacity utility: Reward bins that, after fitting, still offer substantial capacity.
    # This can be useful for packing larger items later. Normalize by max possible bin capacity for scale.
    max_bin_capacity = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0
    future_capacity_score = remaining_after_fit / np.maximum(max_bin_capacity, 1e-9) # Avoid division by zero
    
    # Combine objectives with tunable weights
    weight_tightness = 1.0
    weight_waste = 0.6  # Slightly more emphasis on avoiding waste than previous example
    weight_future_capacity = 0.3 # Slightly more emphasis on future utility
    
    combined_scores = (weight_tightness * tightness_score - 
                       weight_waste * waste_avoidance_score + 
                       weight_future_capacity * future_capacity_score)

    # --- Guided Exploration ---
    # Identify candidate bins for exploration:
    # a) Top-scoring bins: Bins that are generally good fits.
    # b) Bins with moderate remaining capacity: Offer a balance between tight fit and future utility.

    # Sort by combined score to find top candidates
    sorted_indices_combined = np.argsort(combined_scores)[::-1]
    
    # Consider top N bins or top X percentile, whichever is more
    num_top_bins = max(2, int(len(valid_bins_capacities) * 0.25)) # Top 25% or at least 2 bins
    top_candidate_indices_in_valid = sorted_indices_combined[:num_top_bins]
    
    # Identify bins with moderate remaining capacity (e.g., between 25th and 75th percentile)
    if len(valid_bins_capacities) > 1:
        q1_rem = np.percentile(remaining_after_fit, 25)
        q3_rem = np.percentile(remaining_after_fit, 75)
        # Ensure moderate capacity is not too small or too large
        moderate_capacity_mask = (remaining_after_fit >= q1_rem) & (remaining_after_fit <= q3_rem)
        moderate_capacity_indices_in_valid = np.where(moderate_capacity_mask)[0]
    else:
        moderate_capacity_indices_in_valid = np.array([], dtype=int)

    # Combine unique indices for exploration candidates
    exploration_candidate_indices_in_valid_set = set(top_candidate_indices_in_valid)
    exploration_candidate_indices_in_valid_set.update(moderate_capacity_indices_in_valid)
    exploration_candidate_indices_in_valid = list(exploration_candidate_indices_in_valid_set)
    
    # Assign slightly perturbed scores to exploration candidates
    exploration_scores = np.random.uniform(-0.15, 0.15, size=len(valid_bins_capacities)) # Wider exploration range
    
    final_scores = np.copy(combined_scores)
    
    # Create a mask for the identified exploration candidates within the valid subset
    exploration_mask_for_valid = np.zeros(len(valid_bins_capacities), dtype=bool)
    if exploration_candidate_indices_in_valid:
        exploration_mask_for_valid[exploration_candidate_indices_in_valid] = True
    
    # Determine which candidates will use exploration scores based on epsilon
    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply exploration scores only to selected candidates
    indices_to_perturb = np.where(exploration_mask_for_valid & use_exploration_for_candidates)[0]
    final_scores[indices_to_perturb] = exploration_scores[indices_to_perturb]
    
    # Map the final scores back to the original bins array
    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
