```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines tightest fit with a penalty for waste and a bonus for under-utilization.
    Prioritizes bins that minimize remaining capacity and penalizes bins that leave excessive space."""

    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_indices = np.where(can_fit_mask)[0]
    valid_bins_capacities = bins_remain_cap[can_fit_mask]

    # --- Objective 1: Tightest Fit ---
    # Score is inversely proportional to the remaining capacity after fitting the item.
    # Higher score means less remaining capacity.
    remaining_after_fit = valid_bins_capacities - item
    tightness_score = -remaining_after_fit

    # --- Objective 2: Penalty for Waste ---
    # Penalize bins that leave a large amount of remaining capacity.
    # This is a penalty based on the *original* remaining capacity of the eligible bin.
    # We want to avoid placing small items into very large bins if tighter fits exist.
    # Penalty is higher for bins that were already large.
    waste_penalty = np.zeros_like(valid_bins_capacities)
    # Consider bins with remaining capacity > item size (i.e., non-perfect fits)
    significant_remainder_mask = (remaining_after_fit > 0)
    # Apply a penalty that increases with the original remaining capacity,
    # but only if the remaining capacity is substantial relative to the item.
    # Let's penalize bins where remaining_after_fit > item/2 (arbitrary threshold)
    large_residual_mask = remaining_after_fit > item * 0.5
    waste_penalty[large_residual_mask] = -(remaining_after_fit[large_residual_mask] * 0.5) # Penalize larger residuals more

    # --- Objective 3: Bonus for Under-utilization (but not excessive waste) ---
    # Reward bins that are not "too full" after packing, but also not too empty.
    # This is a softer penalty for very small remainders (tight fits).
    # We already reward tight fits with `tightness_score`. This is more about
    # fine-tuning. A small positive remainder might be slightly better than zero.
    # For simplicity, let's ensure perfect fits get a strong boost, and
    # slightly under-utilized bins (very small positive remainder) are favored.
    perfect_fit_bonus = 1.0
    tight_fit_bonus_mask = np.abs(remaining_after_fit) < 1e-9
    tightness_score[tight_fit_bonus_mask] += perfect_fit_bonus

    # Combine scores: Tightness is primary, waste penalty is secondary.
    # The waste penalty acts as a negative additive term.
    combined_score = tightness_score + waste_penalty

    priorities[valid_bins_indices] = combined_score

    return priorities
```
