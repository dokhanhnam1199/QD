```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins using a hybrid approach: tightest fit with perfect fit bonus,
    and guided exploration favoring promising bins, balancing exploitation and exploration."""

    epsilon = 0.05  # Probability of exploration
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    # --- Exploitation Strategy (Based on Heuristic 15th/17th and 18th/19th) ---
    # Prioritize perfect fits, then tight fits. Add a small bonus for bins
    # that are not excessively empty after packing.
    
    remaining_after_fit = valid_bins_capacities - item
    
    # Score for tightest fit: maximize negative remaining capacity
    exploitation_scores = -remaining_after_fit
    
    # Bonus for perfect fits (exactly zero remaining capacity)
    perfect_fit_bonus = 1000.0  # High bonus for exact matches
    exploitation_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus
    
    # Add a small penalty for bins that would have a very large surplus,
    # encouraging more efficient use of space for the current item.
    # Scale penalty by item size and bin capacity to make it relative.
    large_surplus_threshold_ratio = 0.5 # If remaining capacity is more than 50% of item size
    large_surplus_penalty_factor = 0.1
    surplus_penalty_mask = remaining_after_fit > (item * large_surplus_threshold_ratio)
    exploitation_scores[surplus_penalty_mask] -= (remaining_after_fit[surplus_penalty_mask] / item) * large_surplus_penalty_factor

    # --- Exploration Strategy (Guided by Heuristic 1st/6th) ---
    # Instead of purely random, explore among the 'good enough' bins.
    # This involves selecting a subset of bins that are either very good fits
    # or have moderate remaining capacity (potentially useful for future larger items).
    
    sorted_indices_exploitation = np.argsort(exploitation_scores)[::-1] # Indices sorted by exploitation score
    
    # Candidate selection for exploration:
    # 1. Top X% of bins based on exploitation score.
    # 2. Bins with moderate remaining capacity.
    exploration_candidate_mask = np.zeros_like(exploitation_scores, dtype=bool)
    
    num_candidates_from_top = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.2))) # Top 20%
    exploration_candidate_mask[sorted_indices_exploitation[:num_candidates_from_top]] = True
    
    # Consider bins that are not too tight, but not too empty.
    median_capacity = np.median(valid_bins_capacities)
    moderate_capacity_mask = (remaining_after_fit > item * 0.1) & (remaining_after_fit < median_capacity) # Greater than 10% of item, less than median remaining
    exploration_candidate_mask[moderate_capacity_mask] = True

    # Generate random scores for exploration candidates
    exploration_scores = np.random.rand(len(valid_bins_capacities)) * 0.01 # Small random noise

    # --- Combine Exploitation and Exploration ---
    # With probability epsilon, use exploration score for candidates; otherwise, use exploitation.
    # For non-candidates, always use exploitation score.
    
    combined_priorities = np.copy(exploitation_scores)
    
    # Decide for each candidate whether to use exploration score
    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply exploration scores only to candidates selected for exploration AND where exploration is chosen
    apply_exploration_mask = exploration_candidate_mask & use_exploration_decision
    combined_priorities[apply_exploration_mask] = exploration_scores[apply_exploration_mask]

    priorities[valid_bins_indices] = combined_priorities
    
    return priorities
```
