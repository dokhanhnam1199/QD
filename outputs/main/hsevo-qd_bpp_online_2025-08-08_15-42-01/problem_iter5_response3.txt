```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best-Fit with a bonus for near-perfect fits and a penalty for large remainders."""
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    potential_remain_cap = bins_remain_cap[can_fit_mask] - item

    # Base priority: favor bins with less remaining capacity (Best Fit)
    priorities[can_fit_mask] = -potential_remain_cap

    # Bonus for perfect fits
    perfect_fit_mask = (potential_remain_cap == 0)
    if np.any(perfect_fit_mask):
        priorities[can_fit_mask][perfect_fit_mask] += 1.5 # Increased bonus for perfect fit

    # Penalty for bins that leave a large remainder (discourage inefficient packing)
    large_remainder_mask = (potential_remain_cap > item * 0.75) & ~perfect_fit_mask
    if np.any(large_remainder_mask):
        priorities[can_fit_mask][large_remainder_mask] -= 1.0 # Increased penalty for large remainders

    # Small penalty for bins that are tight but not perfect, to slightly favor more room if available
    # This is implicitly handled by the negative remaining capacity, but can be tuned.
    # We can also introduce a small bonus for bins that have *some* remaining capacity
    # but are still a relatively tight fit.
    tight_but_not_perfect_mask = (potential_remain_cap > 0) & (potential_remain_cap <= item * 0.25)
    if np.any(tight_but_not_perfect_mask):
        priorities[can_fit_mask][tight_but_not_perfect_mask] += 0.75 # Moderate bonus for tight, non-perfect fits

    return priorities
```
