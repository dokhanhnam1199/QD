```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a bonus for near-perfect fits and a bonus for
    bins that offer a good balance for future items, with probabilistic exploration.
    """
    epsilon = 0.1  # Exploration probability
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # --- Core Scoring (Exploitation) ---
    # Primarily, penalize larger remainders (favor tightest fit).
    # Add a significant bonus for perfect or near-perfect fits.
    # Also, add a smaller bonus for bins that leave a "useful" amount of space.
    
    # Base score: negative of remaining capacity (higher score for smaller remainder)
    exploitation_scores = -remaining_after_fit
    
    # Bonus for perfect/near-perfect fits
    perfect_fit_bonus = 1000.0
    exploitation_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus

    # Bonus for bins leaving moderate remaining capacity (e.g., half of item size)
    # This encourages keeping bins that might fit subsequent medium-sized items well.
    moderate_capacity_bonus_factor = 0.1
    moderate_capacity_mask = (remaining_after_fit > item * 0.4) & (remaining_after_fit < item * 0.6)
    exploitation_scores[moderate_capacity_mask] += item * moderate_capacity_bonus_factor
    
    # --- Exploration ---
    # Select a subset of bins to potentially explore.
    # Candidates are top-scoring bins and those with moderate remaining capacity.
    exploration_candidate_mask = np.zeros_like(exploitation_scores, dtype=bool)
    
    # Top 30% of bins by exploitation score are candidates
    num_top_candidates = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.3)))
    sorted_indices_exploitation = np.argsort(exploitation_scores)[::-1]
    exploration_candidate_mask[sorted_indices_exploitation[:num_top_candidates]] = True

    # Bins with moderate remaining capacity are also candidates
    moderate_capacity_exploration_mask = (remaining_after_fit > item * 0.2) & (remaining_after_fit < item * 0.8)
    exploration_candidate_mask[moderate_capacity_exploration_mask] = True
    
    # Random exploration scores for candidates
    exploration_scores = np.random.rand(len(valid_bins_capacities)) * 0.05 # Small random noise

    # --- Combine ---
    # With probability epsilon, candidates get their exploration score.
    # Otherwise, all bins (candidates and non-candidates) get their exploitation score.
    
    combined_priorities = np.copy(exploitation_scores)
    
    # Decide probabilistically for each candidate whether to use exploration score
    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply exploration score only to candidates where exploration is chosen
    apply_exploration_mask = exploration_candidate_mask & use_exploration_decision
    combined_priorities[apply_exploration_mask] = exploration_scores[apply_exploration_mask]

    priorities[valid_bins_indices] = combined_priorities
    
    return priorities
```
