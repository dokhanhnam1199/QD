```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best-Fit with a penalty for large remaining capacity and a bonus for perfect fits.
    This heuristic prioritizes tight fits while discouraging overly large surpluses.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    potential_remain_cap = bins_remain_cap[can_fit_mask] - item
    
    # Base priority: favor bins with less remaining capacity (tighter fit)
    # Score is negative of remaining capacity, so higher score is better.
    priorities[can_fit_mask] = -potential_remain_cap
    
    # Bonus for perfect fits
    perfect_fit_mask = np.isclose(potential_remain_cap, 0)
    if np.any(perfect_fit_mask):
        priorities[can_fit_mask][perfect_fit_mask] += 1.0 
        
    # Penalty for bins that leave a large remainder after fitting the item
    # This encourages filling bins more completely, penalizing placements that leave disproportionately large space.
    large_remainder_threshold = item * 0.5  # Define what "large" means relative to item size
    large_remainder_mask = (potential_remain_cap > large_remainder_threshold) & ~perfect_fit_mask
    if np.any(large_remainder_mask):
        priorities[can_fit_mask][large_remainder_mask] -= 0.5 

    return priorities
```
