```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines FFD-inspired tight fitting with an epsilon-greedy exploration strategy
    to balance exploitation of good fits and discovery of potentially better packings.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf)
    
    can_fit_mask = bins_remain_cap >= item
    
    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    
    if np.sum(can_fit_mask) == 0:
        return priorities

    # Exploitation: Prioritize bins with least remaining capacity after fitting (tight fit)
    # Add a small bonus for perfect fits, similar to FFD's goal of minimizing waste.
    tight_fit_scores = -(valid_bins_capacities - item)
    perfect_fit_bonus = 1e-6 # Small bonus for bins that will be exactly filled
    tight_fit_scores[valid_bins_capacities - item < 1e-9] += perfect_fit_bonus

    # Exploration: Random scores for a subset of valid bins to explore options
    exploration_scores = np.random.rand(len(valid_bins_capacities))

    # Combine exploitation and exploration using epsilon-greedy
    use_exploration = np.random.rand(len(valid_bins_capacities)) < epsilon
    combined_scores = np.where(use_exploration, exploration_scores, tight_fit_scores)

    priorities[can_fit_mask] = combined_scores
    
    return priorities
```
