```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A multi-objective priority function that balances tightest fit with future bin utility,
    using an adaptive exploration strategy that favors bins with diverse remaining capacities.
    """

    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item

    # Objective 1: Tightest Fit (Minimize remaining capacity)
    # Higher score for smaller remaining capacity
    tightness_scores = -remaining_after_fit

    # Objective 2: Future Bin Utility (Maximize remaining capacity, but not excessively)
    # Favor bins that leave a "useful" amount of space.
    # A moderate remaining capacity is often better than a very small or very large one.
    # We'll use a Gaussian-like function centered around a "good" remaining capacity range.
    # Let's define a target remaining capacity, e.g., 20% of the item size.
    target_remaining = item * 0.2
    # Score decreases as we move away from the target in either direction (too little or too much).
    # Sigma determines how quickly the score drops off.
    sigma = item * 0.3
    utility_scores = np.exp(-((remaining_after_fit - target_remaining) ** 2) / (2 * sigma ** 2))

    # Combine objectives with weights. Weights can be adjusted.
    # Let's give a bit more weight to tightness initially.
    weight_tightness = 0.6
    weight_utility = 0.4
    combined_scores = (weight_tightness * tightness_scores) + (weight_utility * utility_scores)

    # Exploration Strategy: Guided by diversity of remaining capacities
    # Instead of random exploration, we select a diverse set of "good" bins.
    # Good bins are those with high combined_scores.
    # We want to explore bins that are not too similar in their remaining capacity.

    sorted_indices_by_score = np.argsort(combined_scores)[::-1]
    num_valid_bins = len(valid_bins_capacities)
    exploration_candidates_indices = []

    # Select a subset of bins to potentially explore
    num_exploration_candidates = min(num_valid_bins, max(1, int(num_valid_bins * 0.3))) # Top 30% as candidates
    top_candidate_indices = sorted_indices_by_score[:num_exploration_candidates]

    # From the top candidates, select a diverse subset using a greedy approach
    # (similar to Max-Min or Diversity-based selection)
    selected_remaining_caps = []
    sorted_valid_bins_capacities = valid_bins_capacities[top_candidate_indices]

    for i in top_candidate_indices:
        current_remaining = valid_bins_capacities[i]
        if not exploration_candidates_indices:
            exploration_candidates_indices.append(i)
            selected_remaining_caps.append(current_remaining)
        else:
            # Calculate minimum distance to already selected remaining capacities
            min_dist = np.min(np.abs(np.array(selected_remaining_caps) - current_remaining))
            # Add if it's significantly different from existing selections
            # The threshold here is heuristic - could be a fraction of bin size or item size
            diversity_threshold = 0.1 * item
            if min_dist > diversity_threshold:
                exploration_candidates_indices.append(i)
                selected_remaining_caps.append(current_remaining)
        if len(exploration_candidates_indices) >= max(1, int(num_exploration_candidates * 0.5)): # Limit diversity selection
            break
    
    # Assign exploration scores to the selected diverse candidates.
    # Exploration scores are random, but slightly biased towards the combined score.
    # This provides a small perturbation to the deterministic combined score.
    exploration_boost = 0.1 # Small boost for explored bins
    exploration_scores_for_candidates = combined_scores[exploration_candidates_indices] * (1 + np.random.rand(len(exploration_candidates_indices)) * exploration_boost)
    
    # Update combined scores for the exploration candidates with their exploration scores
    final_scores = np.copy(combined_scores)
    final_scores[exploration_candidates_indices] = exploration_scores_for_candidates

    # Normalize scores to be between 0 and 1 (optional, but good for some selection methods)
    min_score = np.min(final_scores)
    max_score = np.max(final_scores)
    if max_score - min_score > 1e-9:
        normalized_scores = (final_scores - min_score) / (max_score - min_score)
    else:
        normalized_scores = np.ones_like(final_scores) * 0.5 # All scores are the same

    # Assign the normalized scores back to the priorities array
    priorities[valid_bins_indices] = normalized_scores

    return priorities
```
