```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fitting, a bonus for perfect fits, and guided exploration.
    Penalizes bins with excessive remaining capacity to encourage efficient packing.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_indices = np.where(can_fit_mask)[0]
    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    
    # Score: Primarily, minimize remaining capacity (maximize negative remaining capacity).
    potential_remain_cap_vals = fitting_bins_capacities - item
    
    # Base score favoring tight fits
    scores = -potential_remain_cap_vals
    
    # Bonus for perfect fits
    perfect_fit_mask = np.isclose(potential_remain_cap_vals, 0)
    scores[perfect_fit_mask] += 10.0 # Significant bonus for perfect fit
    
    # Penalty for large unused capacity: Discourage bins that are much larger than needed.
    # A simple penalty proportional to the surplus capacity, but less impactful than tight-fit gain.
    large_capacity_threshold = item * 0.5 
    
    penalty = np.zeros_like(scores)
    large_surplus_mask = potential_remain_cap_vals > large_capacity_threshold
    
    if np.any(large_surplus_mask):
        # Penalty is proportional to surplus above threshold, scaled down.
        max_possible_surplus = np.max(fitting_bins_capacities) # Upper bound on surplus
        if max_possible_surplus > 0:
            penalty[large_surplus_mask] = (potential_remain_cap_vals[large_surplus_mask] - large_capacity_threshold) / max_possible_surplus * 5.0
        
    scores -= penalty

    # Assign calculated scores to the original bins array
    priorities[can_fit_mask] = scores
    
    # Guided Exploration: Introduce a small probability of exploring less optimal bins
    # to avoid local optima, especially when multiple bins have similar high scores.
    exploration_prob = 0.1
    random_scores = np.random.rand(len(scores)) * 0.1 # Small random noise for exploration
    
    explore_mask = np.random.rand(len(scores)) < exploration_prob
    
    # Apply random scores to a subset of fitting bins, ensuring they don't dominate good fits.
    # Only explore bins that are not perfect fits to maintain focus on optimal.
    non_perfect_fit_mask_for_exploration = ~perfect_fit_mask
    
    # Combine exploration mask with non-perfect fit mask, and ensure we don't explore if it hurts
    final_explore_mask = explore_mask & non_perfect_fit_mask_for_exploration
    
    # Override scores with exploration scores for selected bins
    priorities[fitting_bins_indices[final_explore_mask]] = random_scores[final_explore_mask]
    
    return priorities
```
