```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins based on a weighted combination of tight-fitting potential
    and a penalty for leaving very small, unusable remaining capacities.
    Includes a small exploration factor for bins that are not perfect fits.
    """
    epsilon = 0.05  # Reduced exploration probability
    priorities = np.full_like(bins_remain_cap, -np.inf)

    can_fit_mask = bins_remain_cap >= item

    if np.sum(can_fit_mask) == 0:
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    # Calculate scores for valid bins
    # Score is primarily based on how tightly the item fits (minimizing remaining capacity)
    # We invert the remaining capacity after fitting to get a "tightness" score.
    # Higher score means tighter fit.
    tight_fit_scores = valid_bins_capacities - item

    # Penalize very small remaining capacities that might be "wasted space"
    # This encourages filling bins more completely when possible.
    # We use a small value for remaining capacities close to zero to avoid large penalties for perfect fits.
    small_residual_penalty = np.maximum(0, 0.1 - tight_fit_scores) * 1000  # Heavier penalty for unusable space
    
    # Combine tight fit score with penalty.
    # We want to maximize tight_fit_scores (minimize remaining capacity)
    # and minimize small_residual_penalty.
    # So, score = tight_fit_scores - small_residual_penalty
    exploitation_scores = tight_fit_scores - small_residual_penalty

    # Add a small bonus for perfect fits to explicitly favor them.
    perfect_fit_bonus = 1e-3
    exploitation_scores[np.abs(tight_fit_scores) < 1e-9] += perfect_fit_bonus

    # Exploration: For bins that are not perfect fits, introduce a small random component
    # to explore alternatives that might lead to better overall packing.
    # We apply exploration only to a subset of non-perfect-fit bins.
    exploration_mask = np.abs(tight_fit_scores) >= 1e-9
    
    if np.sum(exploration_mask) > 0:
        exploration_scores_part = np.random.rand(np.sum(exploration_mask)) * 0.1 # Small random exploration score
        
        # Apply exploration scores probabilistically to a subset of non-perfect fit bins
        exploration_indices_in_valid = np.where(exploration_mask)[0]
        exploration_selection_prob = np.random.rand(len(exploration_indices_in_valid)) < epsilon

        selected_exploration_indices_in_valid = exploration_indices_in_valid[exploration_selection_prob]
        
        exploitation_scores[selected_exploration_indices_in_valid] += exploration_scores_part[np.where(exploration_selection_prob)[0]]

    priorities[can_fit_mask] = exploitation_scores

    return priorities
```
