```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for large remainders and a bonus for perfect fits,
    plus a tie-breaker favouring bins with larger original capacity to enhance exploration.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    fitting_bins_capacity = bins_remain_cap[can_fit_mask]
    
    if fitting_bins_capacity.size == 0:
        return priorities
        
    potential_remain_cap_vals = fitting_bins_capacity - item
    
    # High priority for perfect fits
    perfect_fit_indices_in_fitting = np.where(potential_remain_cap_vals == 0)[0]
    if len(perfect_fit_indices_in_fitting) > 0:
        priorities[can_fit_mask][perfect_fit_indices_in_fitting] = 1000.0  # Strong bonus for perfect fits
        
    # For non-perfect fits, prioritize by inverse of remaining capacity (tight fit)
    # Add a tie-breaker: prefer bins with larger original capacity among those with same remainder.
    # The score is designed so that smaller remainders (more negative values) are preferred,
    # and for equal remainders, larger original capacity (higher tie-breaker bonus) is preferred.
    non_perfect_fit_indices_in_fitting = np.where(potential_remain_cap_vals > 0)[0]
    if len(non_perfect_fit_indices_in_fitting) > 0:
        # Normalize tie-breaker bonus to prevent it from dominating the primary score
        max_cap_val = np.max(fitting_bins_capacity) if fitting_bins_capacity.size > 0 else 1.0
        tie_breaker_scale = 1e-4  # Small scale for tie-breaker
        
        # Score: -remaining_capacity + normalized_original_capacity * scale
        scores_for_non_perfect = -(potential_remain_cap_vals[non_perfect_fit_indices_in_fitting]) + \
                                  (fitting_bins_capacity[non_perfect_fit_indices_in_fitting] / max_cap_val) * tie_breaker_scale
                                  
        priorities[can_fit_mask][non_perfect_fit_indices_in_fitting] = scores_for_non_perfect
        
    return priorities
```
