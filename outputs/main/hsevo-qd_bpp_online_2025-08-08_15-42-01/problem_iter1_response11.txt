```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap)
    
    if np.any(available_bins_mask):
        available_bins_capacities = bins_remain_cap[available_bins_mask]
        differences = available_bins_capacities - item
        
        # Higher priority for bins that have just enough space (smaller difference)
        # To avoid tiny spaces being prioritized over slightly larger but still fitting spaces,
        # we invert the differences and add a small constant if necessary to avoid division by zero.
        # A small difference (tight fit) should result in a large priority score.
        # If differences are 0, this means it's a perfect fit. We can assign a very high priority to these.
        
        # Calculate a factor that is high for small differences (tight fits)
        # We can use 1 / (difference + epsilon) or some other function.
        # Let's try to make it so that a difference of 0 is the highest, then small differences.
        # A simple inverse: 1 / (difference + 1e-9)
        
        inverted_differences = 1 / (differences + 1e-9)
        
        # We can also consider the original capacity or current fill level.
        # For best fit, we want to minimize remaining space.
        # The difference `available_bins_capacities - item` directly represents the remaining space AFTER placing the item.
        # Minimizing this difference is the goal.
        # So, bins with smaller positive differences are better.
        # A good way to score this is to take the negative of the difference and add a large constant
        # to ensure positive scores. Or, use the reciprocal.
        
        # Let's use the reciprocal of (difference + small_constant) as the priority.
        # Higher reciprocal means smaller difference.
        
        priorities[available_bins_mask] = inverted_differences
        
        # Optional: Boost perfectly fitting bins
        perfect_fit_mask = (available_bins_mask) & (bins_remain_cap == item)
        if np.any(perfect_fit_mask):
            priorities[perfect_fit_mask] = np.max(priorities) + 1.0 # Give a small boost
            
    return priorities
```
