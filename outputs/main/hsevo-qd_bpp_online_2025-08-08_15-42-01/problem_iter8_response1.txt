```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit exploitation with an epsilon-greedy exploration strategy,
    prioritizing bins that leave minimal remaining capacity, with a bonus for perfect fits.
    """
    epsilon = 0.1
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    
    # Exploitation: Prioritize bins with least remaining capacity after fitting (tight fit)
    # Higher score for smaller remaining capacity (closer to zero)
    remaining_after_fit = valid_bins_capacities - item
    tight_fit_scores = -remaining_after_fit  # Negative to maximize smaller values

    # Add a bonus for perfect fits (remaining capacity is exactly zero)
    perfect_fit_bonus = 1.0  # Significant bonus for exact fits
    tight_fit_scores[np.isclose(remaining_after_fit, 0, atol=1e-9)] += perfect_fit_bonus

    # Exploration: Random scores for a subset of valid bins using epsilon-greedy
    exploration_scores = np.random.rand(len(valid_bins_capacities))

    # Decide whether to use exploitation or exploration for each bin
    use_exploration = np.random.rand(len(valid_bins_capacities)) < epsilon
    combined_scores = np.where(use_exploration, exploration_scores, tight_fit_scores)

    priorities[can_fit_mask] = combined_scores
    
    return priorities
```
