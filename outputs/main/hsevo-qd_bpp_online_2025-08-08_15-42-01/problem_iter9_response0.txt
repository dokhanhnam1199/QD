```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A multi-objective priority function for online Bin Packing Problem (BPP).
    It balances tightest fit, perfect fit bonus, and considers future item packing
    by favoring bins with moderate remaining capacity. It also includes a guided
    exploration mechanism that samples from a pool of promising bins.
    """
    
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # --- Objective 1: Tightest Fit ---
    # Maximize the negative remaining capacity (smaller remaining capacity is better)
    tightest_fit_score = -remaining_after_fit

    # --- Objective 2: Perfect Fit Bonus ---
    # High bonus for bins that result in exactly zero remaining capacity
    perfect_fit_bonus = 100.0
    perfect_fit_mask = np.abs(remaining_after_fit) < 1e-9
    tightest_fit_score[perfect_fit_mask] += perfect_fit_bonus

    # --- Objective 3: Future Utility (Avoid Over-filling) ---
    # Penalize bins that leave very little space after fitting the current item,
    # as they might be less useful for future slightly larger items.
    # This is a soft penalty, not as strong as the perfect fit bonus.
    future_utility_penalty_factor = 0.05
    # Penalize if remaining capacity is less than 10% of the bin's original capacity after fitting
    small_remaining_mask = remaining_after_fit < (valid_bins_capacities * 0.1)
    tightest_fit_score[small_remaining_mask] -= (1 - (remaining_after_fit[small_remaining_mask] / (valid_bins_capacities * 0.1))) * future_utility_penalty_factor


    # --- Guided Exploration Strategy ---
    # We want to explore bins that are good fits but also those that might
    # be good for future items (i.e., not too full, not too empty).

    # Identify candidate bins for exploration:
    # 1. Top-k bins based on the current combined score (tightest fit + perfect fit).
    # 2. Bins with "moderate" remaining capacity, which might be useful for future items.
    
    # Calculate initial combined scores for candidates
    initial_combined_scores = tightest_fit_score
    
    sorted_indices_initial = np.argsort(initial_combined_scores)[::-1]
    
    # Select top 20% as initial exploration candidates
    num_top_candidates = max(1, int(len(valid_bins_capacities) * 0.2))
    exploration_candidate_mask = np.zeros_like(initial_combined_scores, dtype=bool)
    exploration_candidate_mask[sorted_indices_initial[:num_top_candidates]] = True

    # Add bins with moderate remaining capacity as exploration candidates
    # Moderate capacity: remaining capacity is between 20% and 60% of the item size.
    # This range aims to capture bins that are not overly tight but not too spacious.
    moderate_capacity_lower_bound = item * 0.2
    moderate_capacity_upper_bound = item * 0.6
    moderate_capacity_mask = (remaining_after_fit > moderate_capacity_lower_bound) & \
                             (remaining_after_fit < moderate_capacity_upper_bound)
    exploration_candidate_mask[moderate_capacity_mask] = True

    # Assign exploration scores to the selected candidates.
    # These scores are slightly randomized but biased towards the initial good fits.
    # Exploration scores are on a smaller scale than exploitation scores to not
    # dominate the primary objective unless chosen.
    exploration_scores = np.copy(initial_combined_scores)
    
    # Add a small random perturbation to explore around good solutions
    exploration_scores[exploration_candidate_mask] += np.random.normal(0, 0.5, size=np.sum(exploration_candidate_mask))
    
    # Introduce a "diversity" bonus: slightly favor bins with different remaining capacities
    # among the candidates to encourage wider exploration.
    candidate_indices = np.where(exploration_candidate_mask)[0]
    if len(candidate_indices) > 1:
        unique_remaining_caps = np.unique(remaining_after_fit[candidate_indices])
        for i, idx in enumerate(candidate_indices):
            # Simple diversity bonus: slightly boost bins whose remaining capacity
            # is not very common among other candidates.
            if np.sum(remaining_after_fit[candidate_indices] == remaining_after_fit[idx]) < len(candidate_indices) / 2:
                exploration_scores[idx] += 0.1

    # --- Combine Exploitation and Exploration ---
    # With a probability (epsilon), we use the exploration score for the candidates.
    # Otherwise, we use the exploitation score. Non-candidates always use exploitation.
    
    epsilon_exploration = 0.3  # Probability to use exploration score for candidates
    
    final_scores = np.copy(initial_combined_scores) # Default to exploitation
    
    # For candidates, decide whether to use exploration or exploitation
    use_exploration_for_candidate = np.random.rand(len(initial_combined_scores)) < epsilon_exploration
    
    # Apply exploration scores only if the bin is a candidate AND exploration is chosen
    apply_exploration_mask = exploration_candidate_mask & use_exploration_for_candidate
    final_scores[apply_exploration_mask] = exploration_scores[apply_exploration_mask]

    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
