```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Almost Full Fit.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)
    
    # Define a threshold for "almost full". This could be a percentage of bin capacity.
    # For simplicity, let's assume bins have a fixed total capacity and we can infer it.
    # A common approach is to use a fraction of the *average* remaining capacity of all bins.
    # However, the prompt implies we don't know the *total* capacity, only *remaining*.
    # A more direct interpretation of "Almost Full Fit" without knowing total capacity
    # is to prioritize bins that have *just enough* remaining capacity for the item.
    # This means bins where `remaining_capacity - item` is minimized and non-negative.
    
    # Calculate the difference between remaining capacity and item size.
    # We only consider bins where the item *can* fit.
    possible_fits = bins_remain_cap >= item
    
    # For bins where the item fits, calculate the "waste" if the item is placed there.
    # Smaller waste means the bin is "closer" to being full after placing the item.
    # This is the core idea of Almost Full Fit.
    waste = bins_remain_cap[possible_fits] - item
    
    # The priority should be inversely related to the waste.
    # Higher priority for smaller waste.
    # We want to avoid division by zero, so add a small epsilon or handle zero waste.
    # A common heuristic is to use `1 / (waste + epsilon)` or `max(0, -waste)` if we want to maximize.
    # Let's define priority such that higher means better fit.
    # A good priority could be related to the negative of the waste, scaled appropriately.
    
    # Let's prioritize bins where the remaining capacity is closest to 'item'.
    # This means minimizing `bins_remain_cap - item` for `bins_remain_cap >= item`.
    
    # Initialize priorities to a very low value (or negative infinity) for bins that cannot fit the item.
    priorities[~possible_fits] = -np.inf

    # For bins that can fit the item, assign priority based on how "almost full" they become.
    # A bin becomes "almost full" if, after placing the item, its remaining capacity is small.
    # This is equivalent to minimizing `bins_remain_cap - item`.
    # So, we can assign priorities inversely proportional to this difference.
    
    # If we want higher priority for smaller `bins_remain_cap - item`, we can use:
    # priority = - (bins_remain_cap[possible_fits] - item)
    # This assigns a higher (less negative) score to bins that leave less space.
    
    priorities[possible_fits] = -waste
    
    # Normalize priorities or apply a scaling factor if needed, but for a direct priority
    # score where higher is better, this should work.
    
    # A common variation is to consider the "slack" or `bins_remain_cap - item`.
    # We want to pick the bin with the minimum slack. So, the priority could be -slack.
    
    # Let's refine: A higher priority score means the bin is a better candidate.
    # "Almost Full Fit" means we prefer bins that are nearly full, *but can still fit the item*.
    # This translates to choosing the bin where `bins_remain_cap - item` is minimal (and non-negative).
    # So, the priority is proportional to `-(bins_remain_cap - item)`.
    
    # We can add a small constant to ensure all priorities are positive if needed, or just work with negative values.
    # Let's stick with `-(bins_remain_cap - item)` which means higher priority for less remaining space.
    
    return priorities
```
