```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for large remaining space and a bonus for near-perfect fits.
    This hybrid approach balances minimizing wasted space with encouraging fuller bins.
    """
    # Ensure item fits in at least one bin
    can_fit_mask = bins_remain_cap >= item
    if not np.any(can_fit_mask):
        return np.zeros_like(bins_remain_cap)

    # Calculate remaining space after fitting the item
    remaining_space = bins_remain_cap - item

    # Initialize priorities to a very low value for bins where item cannot fit
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Define parameters for scoring
    epsilon = 1e-9  # Small value to avoid division by zero
    perfect_fit_bonus = 1.0  # Bonus for a very tight fit
    large_remainder_penalty_factor = 0.1 # Penalty for leaving significant space

    # Calculate scores for bins where the item can fit
    # Score is primarily based on minimizing remaining space (Best Fit)
    # Add a bonus for near-perfect fits
    # Penalize bins that leave a large amount of space
    
    # Calculate a score that prioritizes minimal remaining space, with a bonus for perfect fits.
    # Using 1/(remaining_space + epsilon) makes smaller remaining space have higher priority.
    # Add a bonus for bins that are close to a perfect fit (remaining_space close to 0).
    # Penalize bins that leave a large remainder.
    
    # Base score: inverse of remaining space (higher for tighter fits)
    tight_fit_score = 1 / (remaining_space[can_fit_mask] + epsilon)

    # Bonus for near-perfect fits: boost score if remaining space is small
    near_perfect_fit_mask = (remaining_space[can_fit_mask] >= 0) & (remaining_space[can_fit_mask] < 1.0)
    bonus_scores = np.where(near_perfect_fit_mask, perfect_fit_bonus, 0)
    
    # Penalty for large remainders: reduce score if remaining space is large
    large_remainder_mask = remaining_space[can_fit_mask] > (np.max(bins_remain_cap[can_fit_mask]) / 2) # Threshold is half of the largest possible remaining capacity for this item
    penalty_scores = np.where(large_remainder_mask, -large_remainder_penalty_factor * remaining_space[can_fit_mask], 0)
    
    # Combine scores
    combined_scores = tight_fit_score + bonus_scores + penalty_scores
    
    # Assign the combined scores to the priorities array
    priorities[can_fit_mask] = combined_scores

    # Ensure no negative priorities if not fitting
    priorities[~can_fit_mask] = 0

    return priorities
```
