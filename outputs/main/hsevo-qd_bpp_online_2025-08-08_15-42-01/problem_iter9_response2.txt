```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A multi-objective priority function for online Bin Packing.
    It considers bin tightness, potential for future packing (based on remaining capacity distribution),
    and introduces an adaptive exploration mechanism favoring bins that are not excessively full or empty.
    """
    
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Mask for bins that can fit the current item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]
    
    # --- Objective 1: Tightest Fit (Exploitation) ---
    # Minimize remaining capacity after packing the item.
    remaining_after_fit = valid_bins_capacities - item
    tightness_score = -remaining_after_fit  # Higher score for smaller remaining capacity

    # --- Objective 2: Future Usability (Guided Exploration) ---
    # Favor bins that, after packing, still have a "useful" amount of remaining capacity.
    # This is relative to the item size itself, aiming to leave space that could accommodate
    # future items of moderate size. Avoid bins that become too empty.
    
    # Define "useful" range: between a small fraction and a moderate fraction of the item size.
    min_useful_surplus_ratio = 0.2 # e.g., at least 20% of item size left
    max_useful_surplus_ratio = 1.0 # e.g., at most 100% of item size left

    # Calculate surplus relative to item size for bins that are not perfect fits
    surplus_relative_to_item = np.where(remaining_after_fit > 1e-9, remaining_after_fit / item, 0)

    # Create a score that rewards fitting within the useful surplus range
    future_usability_score = np.zeros_like(valid_bins_capacities)
    
    # Reward bins that leave a moderate surplus
    moderate_surplus_mask = (surplus_relative_to_item >= min_useful_surplus_ratio) & \
                            (surplus_relative_to_item <= max_useful_surplus_ratio)
    future_usability_score[moderate_surplus_mask] = 1.0 # Base reward for "good" surplus
    
    # Add a bonus for perfect fits (zero remaining capacity) as they are optimally exploited.
    perfect_fit_mask = np.abs(remaining_after_fit) < 1e-9
    future_usability_score[perfect_fit_mask] = 1.5 # Higher reward for perfect fits
    
    # Penalize bins that become excessively empty (surplus > max_useful_surplus_ratio)
    excessively_empty_mask = surplus_relative_to_item > max_useful_surplus_ratio
    future_usability_score[excessively_empty_mask] = -0.5 # Penalty for leaving too much space

    # --- Objective 3: Adaptive Exploration ---
    # Introduce a small exploration component. Instead of pure random,
    # explore among bins that are good candidates based on the other objectives.
    # We'll use a probability to switch from a combined score to an exploration score.
    exploration_probability = 0.1 # 10% chance to use exploration score for a candidate
    
    # Define candidates for exploration: bins with good tightness or good future usability.
    # A simple thresholding based on combined scores before adding exploration noise.
    # Let's combine tightness and usability for initial candidate selection.
    # Normalize scores to be in a similar range if needed, or use weighted sum.
    # For simplicity, let's consider bins that are among the top percentile for either metric.
    
    # Rank bins by tightness and future usability
    sorted_indices_tightness = np.argsort(tightness_score)[::-1]
    sorted_indices_usability = np.argsort(future_usability_score)[::-1]
    
    num_candidates = max(1, int(len(valid_bins_capacities) * 0.25)) # Top 25% of bins for consideration
    
    exploration_candidate_mask = np.zeros_like(valid_bins_capacities, dtype=bool)
    exploration_candidate_mask[sorted_indices_tightness[:num_candidates]] = True
    exploration_candidate_mask[sorted_indices_usability[:num_candidates]] = True
    
    # Generate exploration scores for candidates (small random values to break ties or explore)
    exploration_scores_for_candidates = np.random.rand(len(valid_bins_capacities)) * 0.05
    
    # --- Combining Objectives ---
    # Weighted sum of exploitation (tightness) and guided exploration (future usability).
    # We add a slight bias to tightness.
    weight_tightness = 0.7
    weight_usability = 0.3
    
    combined_exploitation_score = (weight_tightness * tightness_score) + (weight_usability * future_usability_score)
    
    # Apply exploration probabilistically
    final_scores = np.copy(combined_exploitation_score)
    
    # Decide for each bin whether to potentially use exploration score
    use_exploration_roll = np.random.rand(len(valid_bins_capacities)) < exploration_probability
    
    # Apply exploration score ONLY to candidates that are selected for exploration AND the roll succeeds
    apply_exploration_mask = exploration_candidate_mask & use_exploration_roll
    
    final_scores[apply_exploration_mask] = exploration_scores_for_candidates[apply_exploration_mask]
    
    # Assign the calculated scores back to the original priority array
    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
