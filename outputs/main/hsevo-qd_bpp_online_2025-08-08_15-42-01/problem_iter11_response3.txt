```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fitting with penalties for large surpluses and guided exploration
    to balance fitting efficiency and search diversification.
    """
    epsilon = 0.1  # Exploration probability
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Mask for bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    valid_bins_indices = np.where(can_fit_mask)[0]

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]

    # Score 1: Tight Fit - Maximize negative remaining capacity (prioritize minimal remainder)
    remaining_after_fit = valid_bins_capacities - item
    tight_fit_scores = -remaining_after_fit

    # Score 2: Perfect Fit Bonus - Add a bonus for exact fits
    perfect_fit_bonus = 0.1  # Slightly reduced bonus compared to v1
    tight_fit_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus

    # Score 3: Surplus Penalty - Mild penalty for bins that would have a large surplus
    # This helps avoid bins that are much larger than needed, promoting tighter overall packing.
    large_remainder_penalty_factor = 0.0015 # Adjusted penalty factor
    surplus_penalty = (remaining_after_fit / item) * large_remainder_penalty_factor
    tight_fit_scores -= surplus_penalty

    # Guided Exploration:
    # Introduce randomness to a subset of "good enough" bins.
    # Candidates are the top-fitting bins.
    sorted_indices_tight = np.argsort(tight_fit_scores)[::-1]  # Indices sorted by tight fit score (desc)
    
    # Select top K% of bins for exploration, ensuring at least one bin if possible
    num_exploration_candidates = max(1, int(len(valid_bins_capacities) * 0.3))
    exploration_candidate_indices_in_valid = sorted_indices_tight[:num_exploration_candidates]

    # Generate exploration scores (small random noise)
    exploration_scores = np.random.rand(len(valid_bins_capacities)) * 0.015 # Slightly wider exploration noise

    # Combine scores: use exploration score for candidates with probability epsilon, otherwise tight fit score.
    final_scores = np.copy(tight_fit_scores)
    
    # Create a mask for the candidate bins within the valid set
    is_candidate_mask_in_valid = np.zeros(len(valid_bins_capacities), dtype=bool)
    is_candidate_mask_in_valid[exploration_candidate_indices_in_valid] = True
    
    # Decide probabilistically whether to use exploration score for candidates
    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply exploration scores to candidates if chosen
    explore_mask_combined = is_candidate_mask_in_valid & use_exploration_for_candidates
    final_scores[explore_mask_combined] = exploration_scores[explore_mask_combined]

    # Assign the final scores to the priorities array
    priorities[valid_bins_indices] = final_scores

    return priorities
```
