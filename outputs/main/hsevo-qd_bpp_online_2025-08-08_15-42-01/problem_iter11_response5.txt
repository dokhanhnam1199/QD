```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines Best Fit with guided exploration and waste penalty.

    Prioritizes bins that offer the tightest fit, with a penalty for creating large surpluses.
    Explores "good enough" bins with a probability to promote diversity.
    """
    epsilon = 0.05
    priorities = np.full_like(bins_remain_cap, -np.inf)

    can_fit_mask = bins_remain_cap >= item

    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item

    # Primary objective: Tightest fit
    tightness_score = -remaining_after_fit

    # Secondary objective: Penalize large waste
    # Scale penalty by item size to be more sensitive to significant leftovers relative to item
    waste_penalty = (remaining_after_fit / item) * 0.02
    
    # Bonus for perfect fit
    perfect_fit_bonus = np.where(remaining_after_fit == 0, 10.0, 0.0)

    combined_scores = tightness_score - waste_penalty + perfect_fit_bonus

    # Guided Exploration: Select a subset of bins for potential random selection
    # Consider top-scoring bins and bins with moderate remaining capacity
    sorted_indices_combined = np.argsort(combined_scores)[::-1]
    num_top_bins = max(3, int(len(valid_bins_capacities) * 0.25))
    top_candidate_indices = sorted_indices_combined[:num_top_bins]

    q1_rem = np.percentile(remaining_after_fit, 25)
    q3_rem = np.percentile(remaining_after_fit, 75)
    moderate_capacity_mask = (remaining_after_fit >= q1_rem) & (remaining_after_fit <= q3_rem)
    moderate_candidate_indices = np.where(moderate_capacity_mask)[0]
    
    exploration_candidate_indices_in_valid = list(set(top_candidate_indices) | set(moderate_candidate_indices))

    final_scores = np.copy(combined_scores)

    if exploration_candidate_indices_in_valid:
        exploration_mask_in_valid = np.zeros_like(valid_bins_capacities, dtype=bool)
        exploration_mask_in_valid[exploration_candidate_indices_in_valid] = True
        
        # Apply random exploration score with probability epsilon
        random_scores = np.random.uniform(-0.5, 0.5, size=len(valid_bins_capacities))
        
        use_exploration_prob = np.random.rand(len(valid_bins_capacities)) < epsilon
        
        apply_exploration = exploration_mask_in_valid & use_exploration_prob
        
        final_scores[apply_exploration] = random_scores[apply_exploration]

    priorities[valid_bins_indices] = final_scores

    return priorities
```
