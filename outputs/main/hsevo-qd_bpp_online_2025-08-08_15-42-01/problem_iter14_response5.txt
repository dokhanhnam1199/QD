```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines sophisticated multi-objective scoring with a robust guided exploration strategy.
    Prioritizes tight fits, rewards less waste, and explores promising bins.
    """
    epsilon = 0.07  # Exploration probability
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # --- Multi-objective Scoring ---
    # 1. Tightest Fit: Maximize the negative remaining capacity (minimize remaining capacity).
    tightness_score = -remaining_after_fit
    
    # 2. Perfect Fit Bonus: Significantly reward bins that result in zero remaining capacity.
    perfect_fit_bonus = 1000.0
    tightness_score[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus
    
    # 3. Waste Penalty: Penalize bins where the remaining capacity is a large fraction of the item's size.
    # This discourages packing small items into very large bins.
    waste_penalty_factor = 0.15
    large_surplus_threshold_ratio = 0.6 # If remaining capacity > 60% of item size
    surplus_penalty_mask = remaining_after_fit > (item * large_surplus_threshold_ratio)
    tightness_score[surplus_penalty_mask] -= (remaining_after_fit[surplus_penalty_mask] / np.maximum(item, 1e-9)) * waste_penalty_factor

    # 4. Future Utility Score: Reward bins that retain substantial capacity, normalized for scale.
    # This encourages leaving space for potentially larger items.
    max_possible_capacity = np.max(bins_remain_cap) if bins_remain_cap.size > 0 else 1.0
    future_utility_score = remaining_after_fit / np.maximum(max_possible_capacity, 1e-9)
    
    # Combine scores: primarily tightness, with adjustments for waste and future utility.
    # Weights are tuned to prioritize tight fits and waste avoidance.
    weight_tightness = 1.0
    weight_future_utility = 0.3
    combined_scores = weight_tightness * tightness_score + weight_future_utility * future_utility_score

    # --- Guided Exploration ---
    # Candidates for exploration: top-scoring bins and bins with moderate remaining capacity.
    
    # Sort by combined score to identify top candidates
    sorted_indices_by_score = np.argsort(combined_scores)[::-1]
    
    # Top 20% of bins based on score, at least 1
    num_top_candidates = max(1, int(len(valid_bins_capacities) * 0.2))
    top_score_candidate_indices_in_valid = sorted_indices_by_score[:num_top_candidates]
    
    # Bins with moderate remaining capacity (e.g., between 25th and 75th percentile)
    moderate_capacity_indices_in_valid = []
    if len(valid_bins_capacities) > 1:
        q1_rem = np.percentile(remaining_after_fit, 25)
        q3_rem = np.percentile(remaining_after_fit, 75)
        # Ensure moderate capacity is not too tight or too empty
        moderate_capacity_mask = (remaining_after_fit >= q1_rem) & (remaining_after_fit <= q3_rem)
        moderate_capacity_indices_in_valid = np.where(moderate_capacity_mask)[0]

    # Combine unique indices for exploration candidates
    exploration_candidate_mask_for_valid = np.zeros(len(valid_bins_capacities), dtype=bool)
    exploration_candidate_indices_in_valid_set = set(top_score_candidate_indices_in_valid)
    exploration_candidate_indices_in_valid_set.update(moderate_capacity_indices_in_valid)
    
    if exploration_candidate_indices_in_valid_set:
        exploration_candidate_indices_in_valid = list(exploration_candidate_indices_in_valid_set)
        exploration_candidate_mask_for_valid[exploration_candidate_indices_in_valid] = True

    # Generate random scores for exploration
    exploration_scores = np.random.uniform(-0.5, 0.5, size=len(valid_bins_capacities)) 
    
    final_scores = np.copy(combined_scores)
    
    # Decide which candidates use exploration scores
    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    # Apply exploration scores only to selected candidates
    indices_to_perturb = np.where(exploration_candidate_mask_for_valid & use_exploration_for_candidates)[0]
    final_scores[indices_to_perturb] = exploration_scores[indices_to_perturb]
    
    # Map the final scores back to the original bins array
    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
