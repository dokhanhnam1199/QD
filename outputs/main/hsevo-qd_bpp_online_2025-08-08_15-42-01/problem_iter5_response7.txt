```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines a Best Fit strategy with a penalty for large remaining capacity
    and a bonus for near-perfect fits, aiming for efficient packing.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf)
    can_fit_mask = bins_remain_cap >= item

    # Prioritize bins that can fit the item
    # Use negative remaining capacity to favor tighter fits (Best Fit)
    # Add a small penalty for larger remaining capacities to avoid extremely sparse bins
    # Add a bonus for near-perfect fits to exploit efficient packing opportunities
    priorities[can_fit_mask] = -bins_remain_cap[can_fit_mask] - 0.1 * (bins_remain_cap[can_fit_mask] - item) + 10 * np.exp(-(bins_remain_cap[can_fit_mask] - item)**2 / 0.1)

    return priorities
```
