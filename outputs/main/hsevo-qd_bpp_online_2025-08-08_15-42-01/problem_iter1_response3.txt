```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Almost Full Fit: Prioritize bins that will be closest to full after adding the item.
    # Calculate the remaining capacity after placing the item.
    potential_remain_cap = bins_remain_cap - item

    # We want bins where potential_remain_cap is as close to zero as possible (but non-negative)
    # A simple way to achieve this is to maximize the negative of the absolute difference from zero.
    # However, to encourage fitting rather than just being close, we can also consider
    # bins that can actually fit the item.

    # Create a mask for bins that can fit the item
    can_fit_mask = potential_remain_cap >= 0

    # For bins that can fit, calculate a score based on how full they will become.
    # A higher score means the bin will be closer to full.
    # We can use -(potential_remain_cap) as a measure of "fullness" after packing.
    # To avoid prioritizing bins that become "too full" or negative capacity,
    # we only consider valid fits.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[can_fit_mask] = -potential_remain_cap[can_fit_mask]

    # We can add a small bonus for fitting the item at all to ensure
    # that fitting items is generally preferred over not fitting.
    # However, the negative of remaining capacity already does this indirectly.
    # A more sophisticated approach might involve considering the original capacity
    # to prioritize filling larger bins more.

    # For "Almost Full Fit", we want to minimize the remaining capacity.
    # So, we want to maximize the negative of the remaining capacity.
    # Let's refine this. We want the remaining capacity to be as close to 0 as possible.
    # The value `potential_remain_cap` represents this.
    # We want to maximize this value if it's negative (meaning it's a good fit).
    # Let's re-evaluate. For Almost Full Fit, we want the resulting remaining capacity
    # to be as small as possible, but still non-negative.
    # So, we want to maximize `-(potential_remain_cap)` for valid fits.

    # Consider the difference between the bin's original capacity and the item size.
    # We want to prioritize bins where this difference is minimized, but non-negative.
    # The `potential_remain_cap` already captures this.
    # We want the most "positive" value of `-(potential_remain_cap)` for bins that fit.

    # Another perspective: prioritize bins that have the *least* remaining capacity *after* the item is placed.
    # This directly translates to maximizing `-(potential_remain_cap)`.

    # Let's consider a small perturbation or a "niceness" factor.
    # Perhaps bins that are already somewhat full are preferred.
    # But for "Almost Full Fit", the focus is purely on the state *after* packing.

    # We want to maximize the remaining capacity in a way that favors being close to zero.
    # The score should be higher for bins that result in less remaining capacity.
    # So, we want to maximize `-(bins_remain_cap - item)` for valid bins.
    # This is equivalent to maximizing `item - bins_remain_cap`. This isn't quite right.

    # The goal is to make the bin as "full" as possible *after* adding the item.
    # "Full" means having small remaining capacity.
    # So, we want to minimize `potential_remain_cap`.
    # To turn this into a maximization problem for priority, we can use `-potential_remain_cap`.
    # We also need to ensure that bins that *cannot* fit the item get a very low priority.

    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    can_fit_mask = bins_remain_cap >= item
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    # Let's refine the "Almost Full Fit" idea. We want the bin with the smallest remaining capacity after packing.
    # This means we want to minimize `bins_remain_cap - item`.
    # For a priority score (higher is better), we can use the negative of this difference.
    # So, we want to maximize `-(bins_remain_cap - item)` which is `item - bins_remain_cap`.

    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    fit_mask = bins_remain_cap >= item
    priorities[fit_mask] = item - bins_remain_cap[fit_mask]

    # This score will be highest for bins where `bins_remain_cap` is just slightly larger than `item`.
    # Example: item=5
    # bin1_rem=6  -> priority = 5 - 6 = -1
    # bin2_rem=5  -> priority = 5 - 5 = 0
    # bin3_rem=10 -> priority = 5 - 10 = -5
    # bin4_rem=3  -> priority = -inf (cannot fit)

    # The highest score is 0, from the bin that becomes exactly full.
    # This seems correct for "Almost Full Fit".

    # Consider a scenario where there are multiple bins that become exactly full.
    # The current heuristic doesn't differentiate between them.
    # For this strategy, simply picking any of them is fine.

    return priorities
```
