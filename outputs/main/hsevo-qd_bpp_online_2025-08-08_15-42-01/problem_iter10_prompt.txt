{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining tight fitting with a penalty for large surpluses\n    and a bonus for perfect fits, with guided exploration.\n    \"\"\"\n    epsilon = 0.08  # Exploration probability\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n    valid_bins_indices = np.where(can_fit_mask)[0]\n\n    if not np.any(can_fit_mask):\n        return priorities\n\n    valid_bins_capacities = bins_remain_cap[can_fit_mask]\n\n    # Calculate remaining capacity after fitting the item\n    remaining_after_fit = valid_bins_capacities - item\n\n    # Score 1: Tight Fit - Maximize negative remaining capacity (prioritize minimal remainder)\n    tight_fit_scores = -remaining_after_fit\n\n    # Score 2: Perfect Fit Bonus - Add a bonus for exact fits\n    perfect_fit_bonus = 0.15\n    tight_fit_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus\n\n    # Score 3: Surplus Penalty - Mild penalty for bins that would have a large surplus\n    # Scaled by item size to make it relative to the item being packed.\n    large_remainder_penalty_factor = 0.002\n    surplus_penalty = (remaining_after_fit / item) * large_remainder_penalty_factor\n    tight_fit_scores -= surplus_penalty\n\n    # Guided Exploration:\n    # Introduce randomness to a subset of \"good enough\" bins.\n    # Candidates are the top-fitting bins and those with moderate remaining capacity.\n    \n    sorted_indices_tight = np.argsort(tight_fit_scores)[::-1] # Indices sorted by tight fit score (desc)\n    \n    exploration_candidate_indices_in_valid = []\n    \n    # Select top K% of bins for exploration\n    num_top_candidates = max(1, int(len(valid_bins_capacities) * 0.3))\n    exploration_candidate_indices_in_valid.extend(sorted_indices_tight[:num_top_candidates])\n    \n    # Add bins with moderate remaining capacity (e.g., less than twice the item size, but not too small)\n    moderate_capacity_threshold_upper = np.median(valid_bins_capacities) * 1.5 if len(valid_bins_capacities) > 0 else float('inf')\n    moderate_capacity_threshold_lower = item * 1.1 # Avoid bins that are only slightly larger than item\n    \n    moderate_capacity_mask_in_valid = (remaining_after_fit > (item * 0.1)) & \\\n                                      (remaining_after_fit < moderate_capacity_threshold_upper)\n    \n    moderate_capacity_indices_in_valid = np.where(moderate_capacity_mask_in_valid)[0]\n    exploration_candidate_indices_in_valid.extend(moderate_capacity_indices_in_valid)\n    \n    # Remove duplicates and ensure indices are within bounds\n    exploration_candidate_indices_in_valid = np.unique(exploration_candidate_indices_in_valid)\n    exploration_candidate_indices_in_valid = exploration_candidate_indices_in_valid[\n        exploration_candidate_indices_in_valid < len(valid_bins_capacities)\n    ]\n\n    # Generate exploration scores (small random noise)\n    exploration_scores = np.random.rand(len(valid_bins_capacities)) * 0.02\n\n    # Combine scores: use exploration score for candidates with probability epsilon, otherwise tight fit score.\n    # For non-candidates, always use the tight fit score.\n    \n    final_scores = np.copy(tight_fit_scores)\n    \n    # Create a mask for the candidate bins within the valid set\n    is_candidate_mask_in_valid = np.zeros(len(valid_bins_capacities), dtype=bool)\n    is_candidate_mask_in_valid[exploration_candidate_indices_in_valid] = True\n    \n    # Decide probabilistically whether to use exploration score for candidates\n    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon\n    \n    # Apply exploration scores to candidates if chosen\n    explore_mask_combined = is_candidate_mask_in_valid & use_exploration_for_candidates\n    final_scores[explore_mask_combined] = exploration_scores[explore_mask_combined]\n\n    # Assign the final scores to the priorities array\n    priorities[valid_bins_indices] = final_scores\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}