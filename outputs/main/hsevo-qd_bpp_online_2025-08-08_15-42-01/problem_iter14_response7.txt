```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tightest fit with a penalty for significant waste and rewards future utility,
    using guided exploration for diversity among top candidates.
    """
    epsilon = 0.1  # Probability for exploration
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    remaining_after_fit = valid_bins_capacities - item
    
    # Score 1: Tightness score (minimize remaining capacity)
    tightness_score = -remaining_after_fit
    
    # Score 2: Waste avoidance score (penalize large surplus relative to item)
    waste_penalty_factor = 0.02
    waste_avoidance_score = (remaining_after_fit / np.maximum(item, 1.0)) * waste_penalty_factor
    
    # Score 3: Future capacity utility (reward remaining capacity relative to item size)
    future_capacity_score = remaining_after_fit / np.maximum(item, 1.0)
    
    # Combine objectives with tunable weights
    weight_tightness = 1.5
    weight_waste = 0.5
    weight_future_capacity = 0.7
    
    combined_scores = (weight_tightness * tightness_score - 
                       weight_waste * waste_avoidance_score + 
                       weight_future_capacity * future_capacity_score)

    # Guided Exploration: Perturb scores of selected candidates
    # Candidates are top scoring bins or bins with moderate remaining capacity.
    sorted_indices_combined = np.argsort(combined_scores)[::-1]
    num_top_bins = max(2, int(len(valid_bins_capacities) * 0.3)) # Top 30% or at least 2 bins
    top_candidate_indices_in_valid = sorted_indices_combined[:num_top_bins]
    
    if len(valid_bins_capacities) > 1:
        q1_rem = np.percentile(remaining_after_fit, 20)
        q3_rem = np.percentile(remaining_after_fit, 80)
        moderate_capacity_mask = (remaining_after_fit >= q1_rem) & (remaining_after_fit <= q3_rem)
        moderate_capacity_indices_in_valid = np.where(moderate_capacity_mask)[0]
    else:
        moderate_capacity_indices_in_valid = np.array([], dtype=int)

    exploration_candidate_indices_in_valid_set = set(top_candidate_indices_in_valid)
    exploration_candidate_indices_in_valid_set.update(moderate_capacity_indices_in_valid)
    exploration_candidate_indices_in_valid = list(exploration_candidate_indices_in_valid_set)
    
    # Apply a small random perturbation to exploration candidates' scores
    exploration_perturbation_range = 0.2
    final_scores = np.copy(combined_scores)
    
    exploration_mask_for_valid = np.zeros(len(valid_bins_capacities), dtype=bool)
    if exploration_candidate_indices_in_valid:
        exploration_mask_for_valid[exploration_candidate_indices_in_valid] = True
    
    # Decide probabilistically which candidates to explore
    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    indices_to_perturb = np.where(exploration_mask_for_valid & use_exploration_for_candidates)[0]
    perturbations = np.random.uniform(-exploration_perturbation_range, exploration_perturbation_range, size=len(indices_to_perturb))
    final_scores[indices_to_perturb] += perturbations
    
    # Map the final scores back to the original bins array
    priorities[valid_bins_indices] = final_scores
    
    return priorities
```
