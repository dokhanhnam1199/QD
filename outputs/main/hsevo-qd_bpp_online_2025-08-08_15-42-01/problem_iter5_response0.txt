```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight fitting with adaptive exploration and surplus penalties.
    Prioritizes bins with minimal remaining capacity after packing,
    rewards perfect fits, penalizes large surpluses, and includes
    guided exploration for non-optimal but promising bins.
    """
    epsilon = 0.05  # Probability of exploration
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[can_fit_mask]
    valid_bins_indices = np.where(can_fit_mask)[0]

    # Calculate the remaining capacity after fitting the item
    remaining_after_fit = valid_bins_capacities - item
    
    # Heuristic: Prioritize bins that leave minimal remaining capacity (tight fit)
    # Invert the remaining capacity to make smaller remaining capacities have higher scores.
    tight_fit_scores = -remaining_after_fit 
    
    # Bonus for perfect fits (remaining capacity is close to zero)
    perfect_fit_bonus = 0.2  # Increased bonus for perfect fits
    tight_fit_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus

    # Penalty for large surpluses: Reduce priority for bins that would have significantly more capacity left.
    # Scale penalty by item size to make it relative to the item being packed.
    large_remainder_penalty_factor = 0.01 
    surplus_penalty = (remaining_after_fit / (item + 1e-9)) * large_remainder_penalty_factor
    tight_fit_scores -= surplus_penalty
    
    # Adaptive Exploration: Introduce a small random component to explore "good enough" bins.
    # Select a subset of bins that are either among the best fits or have moderate capacity.
    
    # Sort bins by tight fit score to identify top candidates for exploration focus
    sorted_indices_tight = np.argsort(tight_fit_scores)[::-1]
    
    exploration_candidate_mask_for_scores = np.zeros_like(tight_fit_scores, dtype=bool)
    
    # Select a portion of the best fitting bins to have a chance of being explored
    num_explore_candidates = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.3))) # Explore top 30%
    exploration_candidate_mask_for_scores[sorted_indices_tight[:num_explore_candidates]] = True
    
    # Also include bins that are not too tightly packed, but have a moderate amount of remaining capacity.
    # This offers exploration for bins that are less "full" but still potentially useful.
    moderate_capacity_threshold_upper = np.median(valid_bins_capacities) if valid_bins_capacities.size > 0 else 0
    moderate_capacity_threshold_lower = item * 1.5 # avoid bins that are only slightly larger than item
    moderate_capacity_mask = (valid_bins_capacities > moderate_capacity_threshold_lower) & \
                             (valid_bins_capacities < moderate_capacity_threshold_upper * 2.0) 
    exploration_candidate_mask_for_scores[moderate_capacity_mask] = True

    # Generate random scores for exploration candidates
    exploration_scores = np.random.rand(len(valid_bins_capacities)) * 0.05 # Small random noise for exploration

    # Combine exploitation (tight fit scores) and exploration (random scores)
    # For exploration candidates, with probability epsilon, use the random exploration score.
    # Otherwise (or if not an exploration candidate), use the tight fit score.
    
    use_exploration_for_candidates = np.random.rand(len(valid_bins_capacities)) < epsilon
    
    combined_scores = np.copy(tight_fit_scores)
    
    # Apply exploration scores only to the identified exploration candidates with probability epsilon
    combined_scores[exploration_candidate_mask_for_scores & use_exploration_for_candidates] = \
        exploration_scores[exploration_candidate_mask_for_scores & use_exploration_for_candidates]

    # Assign the computed priorities to the original bins array
    priorities[valid_bins_indices] = combined_scores
    
    return priorities
```
