{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code only and do not add comments into the code. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins using a hybrid approach: tightest fit with perfect fit bonus,\n    and guided exploration favoring promising bins, balancing exploitation and exploration.\"\"\"\n\n    epsilon = 0.05  # Probability of exploration\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    \n    can_fit_mask = bins_remain_cap >= item\n    \n    if not np.any(can_fit_mask):\n        return priorities\n\n    valid_bins_capacities = bins_remain_cap[can_fit_mask]\n    valid_bins_indices = np.where(can_fit_mask)[0]\n\n    # --- Exploitation Strategy (Based on Heuristic 15th/17th and 18th/19th) ---\n    # Prioritize perfect fits, then tight fits. Add a small bonus for bins\n    # that are not excessively empty after packing.\n    \n    remaining_after_fit = valid_bins_capacities - item\n    \n    # Score for tightest fit: maximize negative remaining capacity\n    exploitation_scores = -remaining_after_fit\n    \n    # Bonus for perfect fits (exactly zero remaining capacity)\n    perfect_fit_bonus = 1000.0  # High bonus for exact matches\n    exploitation_scores[np.abs(remaining_after_fit) < 1e-9] += perfect_fit_bonus\n    \n    # Add a small penalty for bins that would have a very large surplus,\n    # encouraging more efficient use of space for the current item.\n    # Scale penalty by item size and bin capacity to make it relative.\n    large_surplus_threshold_ratio = 0.5 # If remaining capacity is more than 50% of item size\n    large_surplus_penalty_factor = 0.1\n    surplus_penalty_mask = remaining_after_fit > (item * large_surplus_threshold_ratio)\n    exploitation_scores[surplus_penalty_mask] -= (remaining_after_fit[surplus_penalty_mask] / item) * large_surplus_penalty_factor\n\n    # --- Exploration Strategy (Guided by Heuristic 1st/6th) ---\n    # Instead of purely random, explore among the 'good enough' bins.\n    # This involves selecting a subset of bins that are either very good fits\n    # or have moderate remaining capacity (potentially useful for future larger items).\n    \n    sorted_indices_exploitation = np.argsort(exploitation_scores)[::-1] # Indices sorted by exploitation score\n    \n    # Candidate selection for exploration:\n    # 1. Top X% of bins based on exploitation score.\n    # 2. Bins with moderate remaining capacity.\n    exploration_candidate_mask = np.zeros_like(exploitation_scores, dtype=bool)\n    \n    num_candidates_from_top = min(len(valid_bins_capacities), max(1, int(len(valid_bins_capacities) * 0.2))) # Top 20%\n    exploration_candidate_mask[sorted_indices_exploitation[:num_candidates_from_top]] = True\n    \n    # Consider bins that are not too tight, but not too empty.\n    median_capacity = np.median(valid_bins_capacities)\n    moderate_capacity_mask = (remaining_after_fit > item * 0.1) & (remaining_after_fit < median_capacity) # Greater than 10% of item, less than median remaining\n    exploration_candidate_mask[moderate_capacity_mask] = True\n\n    # Generate random scores for exploration candidates\n    exploration_scores = np.random.rand(len(valid_bins_capacities)) * 0.01 # Small random noise\n\n    # --- Combine Exploitation and Exploration ---\n    # With probability epsilon, use exploration score for candidates; otherwise, use exploitation.\n    # For non-candidates, always use exploitation score.\n    \n    combined_priorities = np.copy(exploitation_scores)\n    \n    # Decide for each candidate whether to use exploration score\n    use_exploration_decision = np.random.rand(len(valid_bins_capacities)) < epsilon\n    \n    # Apply exploration scores only to candidates selected for exploration AND where exploration is chosen\n    apply_exploration_mask = exploration_candidate_mask & use_exploration_decision\n    combined_priorities[apply_exploration_mask] = exploration_scores[apply_exploration_mask]\n\n    priorities[valid_bins_indices] = combined_priorities\n    \n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nHere's a redefinition of \"Current self-reflection\" to guide heuristic design, avoiding ineffective approaches:\n\n*   **Keywords:** Multi-objective, adaptive exploration, sophisticated scoring, penalized residuals, rewarded fits.\n*   **Advice:** Design heuristics that dynamically balance multiple objectives (e.g., tightness, future utility, waste) using adaptive exploration strategies that sample promising candidates rather than relying on pure randomness.\n*   **Avoid:** Overly simplistic strategies like pure Best Fit or random assignments. Also avoid neglecting the trade-off between exploration and exploitation.\n*   **Explanation:** Complex, multi-objective heuristics with nuanced scoring (e.g., softmax, explicit penalties/bonuses) and guided exploration are essential for outperforming simpler methods, especially in complex packing problems.\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}