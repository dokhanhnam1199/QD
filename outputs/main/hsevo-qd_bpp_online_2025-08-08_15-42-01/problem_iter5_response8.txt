```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines tight-fitting (Best Fit) with a penalty for large unused capacity
    and a bonus for perfect fits, guided by adaptive exploration principles.
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)
    
    can_fit_mask = bins_remain_cap >= item
    
    if not np.any(can_fit_mask):
        return priorities

    fitting_bins_capacities = bins_remain_cap[can_fit_mask]
    
    # Score: Primarily, minimize remaining capacity. Maximize -(remaining_capacity).
    # Secondary: For ties in remaining capacity, prefer larger original capacity (closer to worst-fit among good fits).
    # Bonus for perfect fit, penalty for large unused capacity.
    
    # Calculate remaining capacity if item fits
    potential_remain_cap_vals = fitting_bins_capacities - item
    
    # Base score: favoring tight fits (smaller remaining capacity)
    # Use negative remaining capacity to maximize for smaller remainders.
    scores = -potential_remain_cap_vals
    
    # Bonus for perfect fits
    perfect_fit_mask = np.isclose(potential_remain_cap_vals, 0)
    scores[perfect_fit_mask] += 10.0 # Significant bonus for perfect fit
    
    # Penalty for large unused capacity: Discourage bins that are much larger than needed.
    # This is a form of guided exploration towards "good enough" bins.
    # We penalize bins where the remaining capacity is significantly larger than a small residual.
    # A simple penalty could be proportional to the surplus capacity, but we want it to be less
    # impactful than the tight-fitting score.
    # Let's add a penalty that decreases the score for bins with large remaining capacity.
    # This penalty should be smaller than the gains from tight fits.
    # Penalty factor: For every unit of capacity above a small threshold (e.g., 10% of item size),
    # we slightly reduce the score.
    
    # Define a threshold for "large unused capacity"
    large_capacity_threshold = item * 0.5 # e.g., if remaining capacity is > 50% of item size

    # Calculate penalty: linearly decreasing score for capacity beyond the threshold.
    # Bins with capacity <= threshold get no penalty.
    penalty = np.zeros_like(scores)
    large_surplus_mask = potential_remain_cap_vals > large_capacity_threshold
    
    # The penalty is proportional to how much the surplus exceeds the threshold.
    # We want this penalty to be relatively small compared to the tight-fit scores.
    # e.g., subtract (surplus - threshold) / max_possible_surplus * small_value
    max_possible_surplus = np.max(fitting_bins_capacities) # An upper bound on surplus
    
    if np.any(large_surplus_mask) and max_possible_surplus > 0:
        penalty[large_surplus_mask] = (potential_remain_cap_vals[large_surplus_mask] - large_capacity_threshold) / max_possible_surplus * 5.0
        
    scores -= penalty

    # Assign the calculated scores to the original bins array
    priorities[can_fit_mask] = scores
    
    return priorities
```
