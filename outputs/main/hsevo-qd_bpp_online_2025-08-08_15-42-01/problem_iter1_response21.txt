```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap)
    if not np.any(available_bins_mask):
        return priorities
    
    available_bins_caps = bins_remain_cap[available_bins_mask]
    
    differences = available_bins_caps - item
    
    # Prioritize bins that leave the smallest remaining space
    # A small difference means a "better fit"
    # We want to maximize priority, so we invert the difference (add a constant to ensure positivity)
    # The constant can be the maximum possible difference to keep priorities positive.
    max_diff = np.max(bins_remain_cap) - item
    priorities[available_bins_mask] = max_diff - differences + 1 # +1 to avoid zero priority if diff is max_diff
    
    return priorities
```
