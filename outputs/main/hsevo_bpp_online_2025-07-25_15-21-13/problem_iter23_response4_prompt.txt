{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins using adaptive sigmoid penalties and normalized fit feasibility.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    midpoint = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    k = 5.0  # Steepness of the sigmoid\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    penalty_factor = 1 / (1 + np.exp(5 * ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6))))\n    priority_scores = can_fit * sigmoid_penalty * penalty_factor\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties and midpoint adjustments for refined decision-making.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(can_fit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 2.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (norm_leftover - x0)))) / (adaptive_penalty + 1e-6)  # Sigmoid priority with adaptive penalty\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) Heuristics 1st vs (worst) Heuristics 20th, we see that the best version includes a more nuanced approach by using a sigmoid dynamic midpoint based on the item size and a penalty calculation that ensures stability; the worst version has less fine-grained control over the sigmoid parameters and less adaptive penalty handling. \n(Second best) Heuristics 2nd vs (second worst) Heuristics 19th, we see minor differences in parameters affecting the steepness and midpoint, but the best version remains more adaptable and robust to different item sizes and remaining capacities.\nComparing (1st) vs (2nd), we see a refinement in the midpoint calculation and improved handling of penalties, indicating that dynamic sigmoid calculations significantly enhance performance.\n(3rd) vs (4th) show identical logic, thus ranking equally; however, (3rd) still ranks above others due to adaptability in sigmoid steepness and midpoint.\nComparing (second worst) Heuristics 19th vs (worst) Heuristics 20th, the parameters differ slightly, but the fundamental adaptation mechanism and penalty calculation logic remains subpar in the worst version.\nOverall:\n- \n- **Keywords**: Normalization, adaptive sigmoid functions, dynamic parameters, bin selection, item characteristics.\n- **Advice**: Focus on adaptive dynamic parameter tuning based on item and bin characteristics, using normalization and adaptive sigmoid functions to fine-tune bin selection.\n- **Avoid**: Avoid incorporating space efficiency directly as a penalty or incorporating paradoxical adaptive factors that reduce heuristic efficiency.\n- **Explanation**: By dynamically adjusting parameters based on item and bin specifics, and using adaptive functions like sigmoids for sensitive tuning, the heuristic can better adapt to varying conditions and improve decision-making. Avoiding static penalties and paradoxical adaptability ensures the heuristic remains efficient and effective without unnecessary complexity.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}