{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines normalized fit feasibility and dynamically adjusted sigmoid penalty for bin prioritization.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    sigmoid_penalty = 1 / (1 + np.exp(-5 * (norm_remain_cap - item / (np.mean(bins_remain_cap) + 1e-6))))\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    return priority_score\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility with dynamic adaptive penalties.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid-based penalty that adjusts based on the item size relative to the remaining capacity\n    sigmoid_penalty = 1 / (1 + np.exp(-20 * (norm_remain_cap - 2 * (item / np.max(bins_remain_cap)))))\n    \n    # Combine feasibility and adaptive penalty\n    priority_scores = ifbinsfit * sigmoid_penalty\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) Heuristics 1st vs (worst) Heuristics 20th, we see that the best avoids unnecessary adaptive penalties and balances better between fit feasibility and space efficiency. Heuristics 20th uses a redundant factor (spread_factor) which introduces extra complexity without significant benefit. \n(Second best) Heuristics 13th vs (second worst) Heuristics 19th highlights that heuristic simplification can improve performance by focusing on essential adaptive penalization techniques. \n(1st) vs (2nd) Heuristics, there are no significant differences, indicating that the initial ranking may have been influenced by minor variations. \n(3rd) vs (4th) Heuristics, the overly complicated penalty structures contribute to less effective prioritization, as seen in Heuristics 4th.\nComparing (second worst) Heuristics 19th vs (worst) Heuristics 20th, we see that removing complexity by reducing the number of adaptive factors in Heuristics 20th slightly improves the priority calculation. \nOverall: The best heuristic effectively combines normalized fit feasibility and sigmoid penalization dynamically, avoiding unnecessary complexity.\n- \n- **Keywords:** Dynamic Adaptation, Sigmoid Function, Priority Adjustment, Normalization\n- **Advice:** Integrate dynamic adjustments based on current problem state and use sigmoid functions to smoothly balance penalties and bin prioritization.\n- **Avoid:** Fixed penalties, redundant calculations, incorporating space efficiency checks specifically as penalties, and overly simplistic penalties.\n- **Explanation:** Dynamic adjustments ensure the heuristic remains responsive to changes in the problem landscape, while sigmoid functions provide a nuanced way to penalize inefficiency or penalize space in a way that promotes adaptability over rigidity. Avoiding fixed penalties and redundant calculations prevents the heuristic from becoming ineffective or overly complex.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}