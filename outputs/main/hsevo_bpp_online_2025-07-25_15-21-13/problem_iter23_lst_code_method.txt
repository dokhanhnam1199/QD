{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility and dynamic sigmoid penalties with tunable parameters.\n    \"\"\"\n    sigmoid_steepness = 8.060154863007442\n    max_cap_offset = 9.629999168879228e-06\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + max_cap_offset)\n    x0 = item / (np.max(bins_remain_cap) + max_cap_offset)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + max_cap_offset)  # Adaptive penalty\n    priority_scores = can_fit * (1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))) / (penalty + max_cap_offset)\n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 8.060154863007442, \n    max_cap_offset: float = 9.629999168879228e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, and adaptive item fit.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + max_cap_offset)\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))  # Dynamic midpoint\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + max_cap_offset)  # Adaptive penalty\n    return ifbinsfit * sigmoid_priority / (penalty + max_cap_offset)  # Combine feasibility, sigmoid, and penalty\n\n[Heuristics 3rd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 9.78504159548925, \n    max_cap_offset: float = 1.8869258099912255e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility and dynamic sigmoid penalties with tunable parameters.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + max_cap_offset)\n    x0 = item / (np.max(bins_remain_cap) + max_cap_offset)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + max_cap_offset)  # Adaptive penalty\n    priority_scores = can_fit * (1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))) / (penalty + max_cap_offset)\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 9.78504159548925, \n    max_cap_offset: float = 1.8869258099912255e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility and dynamic sigmoid penalties with tunable parameters.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + max_cap_offset)\n    x0 = item / (np.max(bins_remain_cap) + max_cap_offset)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + max_cap_offset)  # Adaptive penalty\n    priority_scores = can_fit * (1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))) / (penalty + max_cap_offset)\n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties, integrating dynamic adjustments for fine-tuned decision-making.\n    \"\"\"\n    # Check if item fits into the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint and steepness\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    penalty_factor = 14.931397941541181 + 5 * (item / np.max(bins_remain_cap))\n    \n    # Calculate sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate priority score by combining feasibility and penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, adaptive sigmoid penalties, and dynamic midpoint adjustment for balanced prioritization.\n    \"\"\"\n    # Fit feasibility\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Adaptive midpoint calculation\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid steepness\n    k = 1.0 + (item / np.max(bins_remain_cap)) * 5\n    \n    # Dynamic sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, adaptive sigmoid penalties, and dynamic midpoint adjustment for balanced prioritization.\n    \"\"\"\n    # Fit feasibility\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Adaptive midpoint calculation\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid steepness\n    k = 1.0 + (item / np.max(bins_remain_cap)) * 5\n    \n    # Dynamic sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties, integrating dynamic adjustments for fine-tuned decision-making.\n    \"\"\"\n    # Check if item fits into the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint and steepness\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    penalty_factor = 14.931397941541181 + 5 * (item / np.max(bins_remain_cap))\n    \n    # Calculate sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate priority score by combining feasibility and penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties, integrating dynamic adjustments for fine-tuned decision-making.\n    \"\"\"\n    # Check if item fits into the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint and steepness\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    penalty_factor = 14.931397941541181 + 5 * (item / np.max(bins_remain_cap))\n    \n    # Calculate sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate priority score by combining feasibility and penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using adaptive sigmoid penalties and normalized fit feasibility.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    midpoint = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    k = 5.0  # Steepness of the sigmoid\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    penalty_factor = 1 / (1 + np.exp(5 * ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6))))\n    priority_scores = can_fit * sigmoid_penalty * penalty_factor\n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines adaptive fit feasibility with dynamic sigmoid penalization for precise bin selection.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    penalty_factor = np.where(norm_leftover < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (adaptive_penalty * penalty_factor + 1e-6)  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines adaptive fit feasibility with dynamic sigmoid penalization for precise bin selection.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    penalty_factor = np.where(norm_leftover < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (adaptive_penalty * penalty_factor + 1e-6)  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines adaptive fit feasibility with dynamic sigmoid penalization for precise bin selection.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    penalty_factor = np.where(norm_leftover < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (adaptive_penalty * penalty_factor + 1e-6)  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties and midpoint adjustments for refined decision-making.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(can_fit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 2.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (norm_leftover - x0)))) / (adaptive_penalty + 1e-6)  # Sigmoid priority with adaptive penalty\n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, steepness: float = 10.0, influence: float = 0.5, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by using an adaptive mechanism that combines fit feasibility,\n    a dynamic sigmoid function, and an influence factor to balance the decision-making.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity ensuring no division by zero\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + epsilon)\n    \n    # Calculate the sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))\n    \n    # Influence of the item size on the priority, with adaptive steepness\n    adaptive_influence = sigmoid_priority * (1 - influence * (1 - item / np.max(bins_remain_cap)))\n    \n    # Combine feasibility with adaptive influence\n    priority_score = ifbinsfit * adaptive_influence\n    \n    return priority_score\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, steepness: float = 10.0, influence: float = 0.5, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by using an adaptive mechanism that combines fit feasibility,\n    a dynamic sigmoid function, and an influence factor to balance the decision-making.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity ensuring no division by zero\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + epsilon)\n    \n    # Calculate the sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))\n    \n    # Influence of the item size on the priority, with adaptive steepness\n    adaptive_influence = sigmoid_priority * (1 - influence * (1 - item / np.max(bins_remain_cap)))\n    \n    # Combine feasibility with adaptive influence\n    priority_score = ifbinsfit * adaptive_influence\n    \n    return priority_score\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility with a dynamic sigmoid function to adaptively balance space utilization.\n    \"\"\"\n    # Check if the item fits in each bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate normalized remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.mean(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid function to prioritize bins based on normalized remaining capacity\n    sigmoid_steepness = 10.0  # Adjust steepness for sensitivity\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * norm_remain_cap))\n    \n    # Combine feasibility with sigmoid priority\n    priority_scores = can_fit * sigmoid_priority\n    \n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, steepness: float = 10.0, influence: float = 0.5, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by using an adaptive mechanism that combines fit feasibility,\n    a dynamic sigmoid function, and an influence factor to balance the decision-making.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity ensuring no division by zero\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + epsilon)\n    \n    # Calculate the sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))\n    \n    # Influence of the item size on the priority, with adaptive steepness\n    adaptive_influence = sigmoid_priority * (1 - influence * (1 - item / np.max(bins_remain_cap)))\n    \n    # Combine feasibility with adaptive influence\n    priority_score = ifbinsfit * adaptive_influence\n    \n    return priority_score\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, steepness: float = 10.0, influence: float = 0.5, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by using an adaptive mechanism that combines fit feasibility,\n    a dynamic sigmoid function, and an influence factor to balance the decision-making.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity ensuring no division by zero\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + epsilon)\n    \n    # Calculate the sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))\n    \n    # Influence of the item size on the priority, with adaptive steepness\n    adaptive_influence = sigmoid_priority * (1 - influence * (1 - item / np.max(bins_remain_cap)))\n    \n    # Combine feasibility with adaptive influence\n    priority_score = ifbinsfit * adaptive_influence\n    \n    return priority_score\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, steepness: float = 10.0, influence: float = 0.5, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by using an adaptive mechanism that combines fit feasibility,\n    a dynamic sigmoid function, and an influence factor to balance the decision-making.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity ensuring no division by zero\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + epsilon)\n    \n    # Calculate the sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))\n    \n    # Influence of the item size on the priority, with adaptive steepness\n    adaptive_influence = sigmoid_priority * (1 - influence * (1 - item / np.max(bins_remain_cap)))\n    \n    # Combine feasibility with adaptive influence\n    priority_score = ifbinsfit * adaptive_influence\n    \n    return priority_score\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}