{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (adaptive_penalty + 1e-6)  # Sigmoid priority calculation\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins using a dynamic and adaptive approach that considers item-specific fits, \n    normalized remaining capacity, and a refined penalty mechanism.\n    \n    Parameters:\n    - item (float): The size of the current item to be packed.\n    - bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n    \n    Returns:\n    - np.ndarray: A priority score for each bin, where higher scores indicate a better fit.\n    \"\"\"\n    # Check if the item can fit in each bin\n    fit_feasibility = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize the remaining capacities\n    total_remaining_cap = np.sum(bins_remain_cap)\n    if total_remaining_cap == 0:\n        total_remaining_cap = 1e-9  # Avoid division by zero\n    norm_remain_cap = bins_remain_cap / total_remaining_cap\n    \n    # Calculate the normalized fit of the item to each bin\n    item_fit = (bins_remain_cap - item) / total_remaining_cap\n    \n    # Adaptive penalty function to avoid very small remainders\n    penalty_factor = np.where(item_fit < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    \n    # Dynamic adjustment based on current item size relative to average bin capacity\n    avg_bin_cap = np.mean(bins_remain_cap)\n    item_rel_size = item / avg_bin_cap\n    dynamic_adjustment = np.exp(-np.abs(item_rel_size - norm_remain_cap))\n    \n    # Combine feasibility, normalized fit, and dynamic adjustment with adaptive penalty\n    priority_scores = fit_feasibility * (dynamic_adjustment * norm_remain_cap) / penalty_factor\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing **Heuristics 1st** vs **Heuristics 20th**, we see that **Heuristics 1st** introduces additional parameters (`sigmoid_steepness` and `max_cap_offset`) and a more nuanced calculation for penalties and probabilities, leading to a more fine-grained control over prioritization. In contrast, **Heuristics 20th** uses a fixed sigmoid steepness and a simplified penalty calculation.\n**Second Best** vs **Second Worst** (Heuristics 2nd vs Heuristics 19th), **Heuristics 2nd** is simpler and avoids the complex dynamic adjustments and penalty factors seen in **Heuristics 19th**, which makes it more straightforward and easier to understand without a significant loss in effectiveness.\nComparing **Heuristics 1st** vs **Heuristics 2nd**, **Heuristics 1st** includes two sigmoid penalties and a penalty factor, which allow for more detailed and adaptive decision-making, whereas **Heuristics 2nd** primarily relies on a single sigmoid penalty adjusted with the item size.\n**Heuristics 3rd** vs **Heuristics 18th** highlights that **Heuristics 3rd** has an additional penalty factor and a more comprehensive penalty adjustment, providing more precise tuning of the priority scores.\nComparing **Heuristics 17th** vs **Worst** (**Heuristics 20th**), **Heuristics 17th** integrates a sophisticated dynamic adjustment mechanism that considers the current item size relative to the average bin capacity, providing a more refined adaptability and priority scoring system.\nOverall: The top-ranked heuristics tend to include more parameters and mechanisms for adaptive adjustment, whereas the lower-ranked heuristics are simpler with fewer adaptive elements.\n- \n- **Keywords**: Adaptive mechanisms, tunable parameters, sensitivity, decision-making precision, item and bin characteristics, normalized normalization, dynamic parameter adjustment.\n- **Advice**: \n  - Implement adaptive mechanisms that allow for real-time changes in heuristic behavior based on the current state of items and bins.\n  - Use tunable parameters to finely adjust the sensitivity of the heuristic to various conditions, enhancing decision-making precision.\n  - Integrate normalized normalization techniques to ensure that all factors influencing bin selection and packing decisions are on a comparable scale.\n  - Develop flexible, dynamic parameter adjustment methods that respond to changes in item and bin characteristics, promoting better adaptability and performance.\n- **Avoid**: \n  - Static or fixed methods that do not allow for adjustments based on changing conditions.\n  - Unnecessary complexity and redundant calculations that do not add value to the heuristic's effectiveness.\n  - Paradoxical adaptive factors that may reduce efficiency or introduce inefficiencies into the system.\n  - Incorporating and penalizing leftover space in a way that space efficiency and item fit checks lead to more effective bin packing solutions, as it can distort heuristic priorities.\n- **Explanation**: By focusing on adaptive mechanisms and tunable parameters, the heuristic can dynamically respond to different problem scenarios, improving its overall effectiveness and efficiency. Normalized normalization ensures equitable consideration of various factors, while avoiding unnecessary complexity helps in maintaining computational efficiency and simplicity, ultimately leading to better decision-making in bin packing scenarios.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}