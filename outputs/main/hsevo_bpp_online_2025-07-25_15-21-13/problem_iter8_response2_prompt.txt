{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This design implements a heuristic based on the remaining capacity of the bins.\n    Is a priority score based on filling tighter bins first, aiming to close the \n    bins as much as possible to trigger first fit for new bins sooner.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Inverse of remaining capacity (sinusoidal function to prioritize the almost full bins)\n    return 1.0 / (bins_remain_cap + 1e-6) * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)))\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines normalized remaining capacity and sigmoid function to prioritize bins effectively.\"\"\"\n    \n    # Ensure item can fit in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize the remaining capacities\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Calculate the sigmoid priority based on normalized capacity\n    sigmoid_priority = 1 / (1 + np.exp(-10 * (norm_remain_cap - 0.5)))\n    \n    # Combine the sigmoid priority with the fit feasibility\n    priority_score = sigmoid_priority * can_fit\n    \n    return priority_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics use combinations of normalized fit feasibility, dynamic penalties, and sigmoid functions to balance between filling bins and minimizing leftover space, whereas the worst simply use an inverse of remaining capacity with a sinusoidal function, which does not dynamically adapt to item sizes or bin capacities. \n\n(Second best) vs (second worst), we observe that the second best uses a sigmoid function to dynamically adjust priorities, ensuring a balance between fit feasibility and leftover space minimization, whereas the second worst again uses a fixed inverse and sinusoidal function, ignoring dynamic adjustments.\n\nComparing (1st) vs (2nd), we see minimal differences, with both highly adaptive and using sigmoid functions; however, the first version slightly better exploits item size in its dynamic parameters.\n\n(3rd) vs (4th), both use fixed methods without adaptability, with the third using sinusoidal adjustment which slightly outperforms the fourth due to its mathematical form balancing capacities better.\n\nComparing (second worst) vs (worst), we see little differentiation as both are non-adaptive and do not incorporate item size or dynamic adjustments in their methods.\n\nOverall:\n- \n- **Keywords**: Dynamic adjustments, adaptive functions, flexible penalties, item fit checks, bin prioritization, simplicity.\n  \n- **Advice**: Focus on real-time evaluation and updating of heuristic parameters based on evolving problem conditions. Leverage adaptive functions to dynamically adjust penalties and priorities. Prioritize simplicity while ensuring robustness in bin fit evaluation.\n\n- **Avoid**: Fixed heuristic designs, static penalties, unnecessary complexity, and redundant recalculations. Do not rigidly incorporate space efficiency checks and penalization as these can lead to suboptimal solutions in some scenarios.\n\n- **Explanation**: Effective heuristics adapt to the problem's landscape. By using dynamic adjustments and adaptive functions, the heuristic can better navigate through complex optimization spaces. Flexibility allows the heuristic to respond to changing conditions, improving its robustness and scalability. Emphasizing simplicity ensures that the heuristic remains efficient and easy to implement, avoiding the pitfalls of overly complex models that can lead to poor performance and unnecessary computational costs.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}