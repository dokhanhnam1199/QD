{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility with dynamic adaptive penalties.\n    This version uses a more adaptive and dynamic approach to penalize bins, focusing on real-time\n    item-bin interactions and avoiding fixed parameters or static methods.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacities\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive penalty based on item size compared to remaining capacity\n    adaptive_penalty = np.abs(norm_remain_cap - (item / np.max(bins_remain_cap)))\n    \n    # Dynamic sigmoid function to balance feasibility and space efficiency\n    sigmoid_balance = 1 / (1 + np.exp(-5 * (norm_remain_cap - (item / np.mean(bins_remain_cap)))))\n    \n    # Calculate priority score by combining feasibility and dynamically adjusted penalties\n    priority_scores = ifbinsfit * sigmoid_balance / (adaptive_penalty + 1e-6)\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines normalized remaining capacity and fit feasibility with a sigmoid function\n    that adjusts dynamically based on item size to prioritize bins efficiently.\n    \"\"\"\n    # Fit feasibility\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    # Normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    # Adjusted fit score\n    fit_score = np.where(ifbinsfit, bins_remain_cap - item, np.inf)\n    # Normalized fit score\n    normalized_fit_score = fit_score / (np.max(fit_score) + 1e-6)\n    # Sigmoid function with dynamic adjustment based on item size\n    k = 1.0  # Steepness of the sigmoid function, can be tuned\n    x0 = 0.5 - (item / (max_cap + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = norm_remain_cap * 1 / (1 + np.exp(-k * (1 - normalized_fit_score - x0)))\n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) Heuristics 1st vs (worst) Heuristics 20th, we see that the best avoids unnecessary adaptive penalties and balances better between fit feasibility and space efficiency. Heuristics 20th uses a redundant factor (spread_factor) which introduces extra complexity without significant benefit. \n(Second best) Heuristics 13th vs (second worst) Heuristics 19th highlights that heuristic simplification can improve performance by focusing on essential adaptive penalization techniques. \n(1st) vs (2nd) Heuristics, there are no significant differences, indicating that the initial ranking may have been influenced by minor variations. \n(3rd) vs (4th) Heuristics, the overly complicated penalty structures contribute to less effective prioritization, as seen in Heuristics 4th.\nComparing (second worst) Heuristics 19th vs (worst) Heuristics 20th, we see that removing complexity by reducing the number of adaptive factors in Heuristics 20th slightly improves the priority calculation. \nOverall: The best heuristic effectively combines normalized fit feasibility and sigmoid penalization dynamically, avoiding unnecessary complexity.\n- \n- **Keywords:** Dynamic Adaptation, Sigmoid Function, Priority Adjustment, Normalization\n- **Advice:** Integrate dynamic adjustments based on current problem state and use sigmoid functions to smoothly balance penalties and bin prioritization.\n- **Avoid:** Fixed penalties, redundant calculations, incorporating space efficiency checks specifically as penalties, and overly simplistic penalties.\n- **Explanation:** Dynamic adjustments ensure the heuristic remains responsive to changes in the problem landscape, while sigmoid functions provide a nuanced way to penalize inefficiency or penalize space in a way that promotes adaptability over rigidity. Avoiding fixed penalties and redundant calculations prevents the heuristic from becoming ineffective or overly complex.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}