{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 8.060154863007442, \n    max_cap_offset: float = 9.629999168879228e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, and adaptive item fit.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + max_cap_offset)\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))  # Dynamic midpoint\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + max_cap_offset)  # Adaptive penalty\n    return ifbinsfit * sigmoid_priority / (penalty + max_cap_offset)  # Combine feasibility, sigmoid, and penalty\n\n[Heuristics 2nd]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    epsilon: float = 5.771679170479951e-06, \n    sigmoid_steepness: float = 10.174665715128466) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamically adjusted sigmoid penalty.\n    \"\"\"\n    # Check if item fits in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + epsilon)\n    \n    # Adaptive sigmoid-based penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - item / (np.mean(bins_remain_cap) + epsilon))))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0))))  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility with a dynamic sigmoid penalty to balance space efficiency.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(can_fit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0))))  # Sigmoid penalty for space efficiency\n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility with a dynamic sigmoid penalty to balance space efficiency.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(can_fit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0))))  # Sigmoid penalty for space efficiency\n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0))))  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamically adjusted sigmoid penalty.\n    \"\"\"\n    # Check if item fits in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid-based penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-10 * (norm_remain_cap - item / (np.mean(bins_remain_cap) + 1e-6))))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Dynamic midpoint calculation based on current item and remaining capacities\n    midpoint = (np.median(bins_remain_cap) - item) / (max_cap - min_cap + 1e-6)\n    \n    # Sigmoid function to balance priorities\n    sigmoid_steepness = 10.0  # Adjusted for stronger steepness\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - midpoint)))\n    \n    # Adaptive priority adjustment based on the remaining capacity and item size\n    priority_adjustment_factor = (max_cap - bins_remain_cap) / (max_cap - item + 1e-6)\n    adjusted_priority = sigmoid_priority * priority_adjustment_factor\n    \n    # Final priority considering fit feasibility and adjusted priority\n    return ifbinsfit * adjusted_priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Dynamic midpoint calculation based on current item and remaining capacities\n    midpoint = (np.median(bins_remain_cap) - item) / (max_cap - min_cap + 1e-6)\n    \n    # Sigmoid function to balance priorities\n    sigmoid_steepness = 10.0  # Adjusted for stronger steepness\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - midpoint)))\n    \n    # Adaptive priority adjustment based on the remaining capacity and item size\n    priority_adjustment_factor = (max_cap - bins_remain_cap) / (max_cap - item + 1e-6)\n    adjusted_priority = sigmoid_priority * priority_adjustment_factor\n    \n    # Final priority considering fit feasibility and adjusted priority\n    return ifbinsfit * adjusted_priority\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive penalties with a sigmoid function.\n    \"\"\"\n    # Fit feasibility\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive penalty based on item size compared to remaining capacity\n    adaptive_penalty = np.abs(norm_remain_cap - (item / np.max(bins_remain_cap)))\n    \n    # Sigmoid function for balancing feasibility and adaptive penalties\n    sigmoid_balance = 1 / (1 + np.exp(-5 * (norm_remain_cap - (item / np.mean(bins_remain_cap)))))\n    \n    # Calculate priority score\n    priority_scores = ifbinsfit * sigmoid_balance / (adaptive_penalty + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate normalized item size\n    norm_item_size = item / max_cap\n    \n    # Dynamic sigmoid steepness based on item size and remaining capacity\n    sigmoid_steepness = 10 * (1 - norm_item_size)  # More steep as item size decreases\n    \n    # Calculate sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - norm_item_size)))\n    \n    # Calculate adaptive adjustment factor\n    adjustment_factor = 0.5 + 0.5 * np.exp(-8 * ((bins_remain_cap - item) / max_cap) ** 2)\n    \n    # Calculate final priority score\n    priority_score = ifbinsfit * sigmoid_priority * adjustment_factor\n    \n    return priority_score\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate normalized item size relative to max bin capacity\n    norm_item_size = item / (max_cap + 1e-6)\n    \n    # Dynamic sigmoid function to prioritize bins with more remaining capacity\n    sigmoid_steepness = 5.0  # Adjusted steepness for better control\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - norm_item_size)))\n    \n    # Adaptive penalty adjustment based on the difference between bin capacity and item size\n    penalty_factor = 0.5\n    adaptive_penalty = (bins_remain_cap - item) / (max_cap + 1e-6)\n    penalty_adjustment = 1 / (1 + np.exp(penalty_factor * adaptive_penalty))\n    \n    # Combine feasibility, sigmoid priority, and penalty adjustment\n    priority_score = ifbinsfit * sigmoid_priority * penalty_adjustment\n    \n    return priority_score\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate normalized item size relative to max bin capacity\n    norm_item_size = item / (max_cap + 1e-6)\n    \n    # Dynamic sigmoid function to prioritize bins with more remaining capacity\n    sigmoid_steepness = 5.0  # Adjusted steepness for better control\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - norm_item_size)))\n    \n    # Adaptive penalty adjustment based on the difference between bin capacity and item size\n    penalty_factor = 0.5\n    adaptive_penalty = (bins_remain_cap - item) / (max_cap + 1e-6)\n    penalty_adjustment = 1 / (1 + np.exp(penalty_factor * adaptive_penalty))\n    \n    # Combine feasibility, sigmoid priority, and penalty adjustment\n    priority_score = ifbinsfit * sigmoid_priority * penalty_adjustment\n    \n    return priority_score\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties adjusted based on item size and remaining capacity.\n    \"\"\"\n    # Fit feasibility\n    fit_feasibility = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic sigmoid penalty\n    midpoint = item / (np.max(bins_remain_cap) + 1e-6)\n    sigmoid_penalty = 1 / (1 + np.exp(-5 * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and sigmoid penalty\n    priority_score = fit_feasibility * sigmoid_penalty\n    \n    return priority_score\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties adjusted based on item size and remaining capacity.\n    \"\"\"\n    # Fit feasibility\n    fit_feasibility = (bins_remain_cap >= item).astype(float)\n    \n    # Normalized remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic sigmoid penalty\n    midpoint = item / (np.max(bins_remain_cap) + 1e-6)\n    sigmoid_penalty = 1 / (1 + np.exp(-5 * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and sigmoid penalty\n    priority_score = fit_feasibility * sigmoid_penalty\n    \n    return priority_score\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate item fit ratio dynamically\n    item_fit_ratio = item / (max_cap + 1e-6)\n    \n    # Dynamic sigmoid steepness based on current problem state\n    sigmoid_steepness = 10 * (1 - item_fit_ratio)\n    \n    # Sigmoid priority with dynamic midpoint\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - item_fit_ratio)))\n    \n    # Priority adjustment for bins with nearly full capacity\n    priority_adjustment = np.exp(-np.abs(norm_remain_cap - 1) * 10)\n    \n    # Combine feasibility, sigmoid priority, and priority adjustment\n    return ifbinsfit * sigmoid_priority * priority_adjustment\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties for adaptive bin prioritization.\n    \"\"\"\n    # Normalized remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Fit feasibility\n    fit_feasibility = (bins_remain_cap >= item).astype(float)\n    \n    # Dynamic adaptive sigmoid penalty\n    midpoint = item / (np.max(bins_remain_cap) + 1e-6)\n    penalty = 1 / (1 + np.exp(-10 * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and penalty\n    priority_score = fit_feasibility * penalty\n    \n    return priority_score\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic sigmoid steepness adjustment based on the item size relative to max capacity\n    sigmoid_steepness = 1 + (item / np.max(bins_remain_cap)) * 10\n    \n    # Calculate dynamic sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - 0.5)))\n    \n    # Adaptive penalty based on the normalized remaining capacity after placing the item\n    penalty = np.maximum(0, 1 - ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)))\n    \n    # Dynamic adjustment for priority based on the number of empty bins\n    empty_bin_adjustment = 1 + (np.mean(bins_remain_cap == np.max(bins_remain_cap)) ** 2) * 5\n    \n    # Combine feasibility, sigmoid, penalty, and dynamic adjustments\n    priority_scores = ifbinsfit * sigmoid_priority / (penalty + 1e-6) * empty_bin_adjustment\n    \n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate item fit ratio dynamically\n    item_fit_ratio = item / (max_cap + 1e-6)\n    \n    # Dynamic sigmoid steepness based on current problem state\n    sigmoid_steepness = 10 * (1 - item_fit_ratio)\n    \n    # Sigmoid priority with dynamic midpoint\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - item_fit_ratio)))\n    \n    # Priority adjustment for bins with nearly full capacity\n    priority_adjustment = np.exp(-np.abs(norm_remain_cap - 1) * 10)\n    \n    # Combine feasibility, sigmoid priority, and priority adjustment\n    return ifbinsfit * sigmoid_priority * priority_adjustment\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic sigmoid steepness adjustment based on the item size relative to max capacity\n    sigmoid_steepness = 1 + (item / np.max(bins_remain_cap)) * 10\n    \n    # Calculate dynamic sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - 0.5)))\n    \n    # Adaptive penalty based on the normalized remaining capacity after placing the item\n    penalty = np.maximum(0, 1 - ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)))\n    \n    # Dynamic adjustment for priority based on the number of empty bins\n    empty_bin_adjustment = 1 + (np.mean(bins_remain_cap == np.max(bins_remain_cap)) ** 2) * 5\n    \n    # Combine feasibility, sigmoid, penalty, and dynamic adjustments\n    priority_scores = ifbinsfit * sigmoid_priority / (penalty + 1e-6) * empty_bin_adjustment\n    \n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}