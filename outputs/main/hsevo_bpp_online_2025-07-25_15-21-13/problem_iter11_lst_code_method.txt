{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit feasibility with normalized penalties and adaptive sigmoid to prioritize bins.\"\"\"\n    # Fit feasibility\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    # Leftover space\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)\n    # Normalized leftover space\n    normalized_leftover = leftover_space / (np.max(leftover_space) + 1e-6)\n    # Sigmoid function with dynamic adjustment based on item size\n    k = 1.0  # Steepness of the sigmoid function, can be tuned\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * 1 / (1 + np.exp(-k * (1 - normalized_leftover - x0)))\n    return priority_scores\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines normalized fit feasibility, dynamic penalties, and sigmoid to balance bin packing priorities.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    # Adaptive penalty based on leftover space, with normalization\n    penalty = leftover_space / (np.max(bins_remain_cap) + 1e-6)\n    # Sigmoid function with dynamic parameters based on item size and remaining capacity\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - penalty - x0))))\n    return priority_scores\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines normalized fit feasibility, dynamic penalties, and sigmoid to balance bin packing priorities.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    # Adaptive penalty based on leftover space, with normalization\n    penalty = leftover_space / (np.max(bins_remain_cap) + 1e-6)\n    # Sigmoid function with dynamic parameters based on item size and remaining capacity\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - penalty - x0))))\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines normalized fit feasibility, dynamic penalties, and sigmoid to balance bin packing priorities.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    # Adaptive penalty based on leftover space, with normalization\n    penalty = leftover_space / (np.max(bins_remain_cap) + 1e-6)\n    # Sigmoid function with dynamic parameters based on item size and remaining capacity\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - penalty - x0))))\n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines normalized fit feasibility, dynamic penalties, and sigmoid to balance bin packing priorities.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    # Adaptive penalty based on leftover space, with normalization\n    penalty = leftover_space / (np.max(bins_remain_cap) + 1e-6)\n    # Sigmoid function with dynamic parameters based on item size and remaining capacity\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - penalty - x0))))\n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines normalized fit feasibility and sigmoid-based adaptive penalty for better bin prioritization.\"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    sigmoid_penalty = 1 / (1 + np.exp(-10 * (norm_remain_cap - item / (np.mean(bins_remain_cap) + 1e-6))))\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    return priority_score\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines normalized fit feasibility, dynamic penalties, and sigmoid to balance bin packing priorities.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    # Adaptive penalty based on leftover space, with normalization\n    penalty = leftover_space / (np.max(bins_remain_cap) + 1e-6)\n    # Sigmoid function with dynamic parameters based on item size and remaining capacity\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - penalty - x0))))\n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit feasibility with normalized penalties and adaptive sigmoid to prioritize bins.\"\"\"\n    # Fit feasibility\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    # Leftover space\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)\n    # Normalized leftover space\n    normalized_leftover = leftover_space / (np.max(leftover_space) + 1e-6)\n    # Sigmoid function with dynamic adjustment based on item size\n    k = 1.0  # Steepness of the sigmoid function, can be tuned\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Midpoint adjusted by item size\n    priority_scores = ifbinsfit * 1 / (1 + np.exp(-k * (1 - normalized_leftover - x0)))\n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive penalty with sigmoid.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    sigmoid_priority = 1 / (1 + np.exp(-10 * (norm_remain_cap - 0.5)))  # Prioritize bins closer to being full\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty based on leftover space\n    return ifbinsfit * sigmoid_priority / (penalty + 1e-6)  # Combine feasibility, sigmoid, and adaptive penalty\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive penalty with sigmoid.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    sigmoid_priority = 1 / (1 + np.exp(-10 * (norm_remain_cap - 0.5)))  # Prioritize bins closer to being full\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty based on leftover space\n    return ifbinsfit * sigmoid_priority / (penalty + 1e-6)  # Combine feasibility, sigmoid, and adaptive penalty\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic dynamically adjusts the priority score based on the item size\n    relative to the remaining capacity of each bin. It aims to balance filling bins\n    efficiently without overly penalizing bins with less remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero and ensure numerical stability\n    epsilon = 1e-6\n    \n    # Calculate the relative space available in each bin for the current item\n    relative_space = bins_remain_cap / (item + epsilon)\n    \n    # Use a sigmoid function to create a smooth transition from low to high priority\n    # This ensures that bins with just enough space also get considered\n    priority_score = 1.0 / (1.0 + np.exp(-(relative_space - 1.5)))\n    \n    return priority_score\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic dynamically adjusts the priority score based on the item size\n    relative to the remaining capacity of each bin. It aims to balance filling bins\n    efficiently without overly penalizing bins with very little remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate the fit score: how well the item fits in the bin\n    # Smaller values are better as they indicate a better fit\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Use a combination of the normalized remaining capacity and fit score\n    # Higher priority for bins where the item fits well and the bin is relatively full\n    priority_score = norm_remain_cap / (fit_score + 1e-6)\n    \n    return priority_score\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit feasibility with sigmoid-based dynamic penalty for adaptive bin prioritization.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    normalized_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    k = 2.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    penalty = 1 / (1 + np.exp(-k * (normalized_cap - x0)))\n    return ifbinsfit * penalty\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic dynamically adjusts priorities based on the item size relative to the remaining\n    capacity of each bin, with a focus on adaptive fitting. It avoids static penalties and aims for\n    simplicity and real-time evaluation.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-6\n    # Use an adaptive function that considers the ratio of item size to remaining capacity\n    priority_scores = (bins_remain_cap - item) / (bins_remain_cap + epsilon)\n    # Penalize bins that cannot fit the item by setting their priority to a very low value\n    priority_scores[bins_remain_cap < item] = -np.inf\n    # Add a small sinusoidal component to create a subtle preference for nearly full bins\n    sinusoidal_adjustment = 0.1 * np.sin(np.pi / 2 * (bins_remain_cap / (np.max(bins_remain_cap) + epsilon)))\n    priority_scores += sinusoidal_adjustment\n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using adaptive sigmoid function and fit feasibility checks.\"\"\"\n    \n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    sigmoid_priority = 1 / (1 + np.exp(-10 * (norm_remain_cap - 0.5)))\n    \n    return sigmoid_priority * can_fit\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit feasibility with sigmoid-based dynamic penalty for adaptive bin prioritization.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    normalized_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    k = 2.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    penalty = 1 / (1 + np.exp(-k * (normalized_cap - x0)))\n    return ifbinsfit * penalty\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins based on normalized remaining capacity and adaptive sigmoid penalization for item fit.\n    \"\"\"\n    # Normalize remaining capacities\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Sigmoid function to prioritize bins that are closer to being full\n    sigmoid_priority = 1 / (1 + np.exp(-10 * (norm_remain_cap - 0.5)))\n    \n    # Penalty for bins that cannot fit the item\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Combine sigmoid priority with fit feasibility, emphasizing item fit\n    priority_score = sigmoid_priority * can_fit * (1 + np.exp(-np.abs(bins_remain_cap - item)))\n    \n    return priority_score\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Dynamic priority function combining normalized fit, adaptive penalties, and sigmoid for online BPP.\"\"\"\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    normalized_cap = bins_remain_cap / np.max(bins_remain_cap, initial=1.0)\n    k = 1.0  # Steepness of the sigmoid function\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    sigmoid_factor = 1 / (1 + np.exp(-k * (normalized_cap - x0)))\n    priority = can_fit * (normalized_cap - (space_left / bins_remain_cap)) * sigmoid_factor\n    return priority\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic dynamically adjusts the priority score based on the item size\n    relative to the remaining capacity of each bin. It aims to balance filling bins\n    efficiently without overly penalizing bins with very little remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the normalized remaining capacity\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Calculate the fit score: how well the item fits in the bin\n    # Smaller values are better as they indicate a better fit\n    fit_score = np.abs(bins_remain_cap - item)\n    \n    # Use a combination of the normalized remaining capacity and fit score\n    # Higher priority for bins where the item fits well and the bin is relatively full\n    priority_score = norm_remain_cap / (fit_score + 1e-6)\n    \n    return priority_score\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fit feasibility with sigmoid-based dynamic penalty for adaptive bin prioritization.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    normalized_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    k = 2.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    penalty = 1 / (1 + np.exp(-k * (normalized_cap - x0)))\n    return ifbinsfit * penalty\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}