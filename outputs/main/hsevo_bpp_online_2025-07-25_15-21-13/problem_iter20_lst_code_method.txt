{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    sigmoid_steepness: float = 8.060154863007442, \n    max_cap_offset: float = 9.629999168879228e-06) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, and adaptive item fit.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + max_cap_offset)\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - (item / np.max(bins_remain_cap)))))  # Dynamic midpoint\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + max_cap_offset)  # Adaptive penalty\n    return ifbinsfit * sigmoid_priority / (penalty + max_cap_offset)  # Combine feasibility, sigmoid, and penalty\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties, adjusting for item size and remaining capacity.\n    \"\"\"\n    # Fit feasibility\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Adaptive midpoint calculation\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    \n    # Dynamic sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-10 * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility, dynamic sigmoid penalties, and item-specific adaptive adjustments.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(can_fit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 2.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))  # Sigmoid penalty for space efficiency\n    penalty_factor = 0.7  # Factor to adjust penalty strength\n    adaptive_penalty = 1 / (1 + np.exp(penalty_factor * ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6))))\n    priority_scores = can_fit * sigmoid_penalty * adaptive_penalty  # Combine penalties and feasibility\n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float, \n    bins_remain_cap: np.ndarray, \n    max_cap_addition: float = 9.774850987562268e-06, \n    penalty_factor: float = 14.931397941541181) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties, adjusting for item size and remaining capacity.\n    \"\"\"\n    # Fit feasibility\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + max_cap_addition)\n    \n    # Adaptive midpoint calculation\n    midpoint = item / (np.mean(bins_remain_cap) + max_cap_addition)\n    \n    # Dynamic sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (adaptive_penalty + 1e-6)  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (adaptive_penalty + 1e-6)  # Sigmoid priority calculation\n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility, dynamic sigmoid penalties, and adaptive adjustments.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic midpoint calculation\n    midpoint = (np.median(bins_remain_cap) - item) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Sigmoid function to balance priorities with dynamic steepness\n    sigmoid_steepness = 10.0\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - midpoint)))\n    \n    # Adaptive priority adjustment\n    priority_adjustment_factor = (np.max(bins_remain_cap) - bins_remain_cap) / (np.max(bins_remain_cap) - item + 1e-6)\n    adjusted_priority = sigmoid_priority * priority_adjustment_factor\n    \n    # Final priority considering fit feasibility and adjusted priority\n    return ifbinsfit * adjusted_priority\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility, dynamic sigmoid penalties, and adaptive adjustments.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic midpoint calculation\n    midpoint = (np.median(bins_remain_cap) - item) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Sigmoid function to balance priorities with dynamic steepness\n    sigmoid_steepness = 10.0\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - midpoint)))\n    \n    # Adaptive priority adjustment\n    priority_adjustment_factor = (np.max(bins_remain_cap) - bins_remain_cap) / (np.max(bins_remain_cap) - item + 1e-6)\n    adjusted_priority = sigmoid_priority * priority_adjustment_factor\n    \n    # Final priority considering fit feasibility and adjusted priority\n    return ifbinsfit * adjusted_priority\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, sigmoid penalties, and\n    adaptive adjustments considering both remaining capacity and item specifics.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Dynamic midpoint calculation based on current item and remaining capacities\n    midpoint = (np.median(bins_remain_cap) - item) / (max_cap - min_cap + 1e-6)\n    \n    # Sigmoid function to balance priorities with increased steepness\n    sigmoid_steepness = 10.0\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - midpoint)))\n    \n    # Adaptive penalty adjustment based on the difference between bin capacity and item size\n    penalty_factor = 0.5\n    adaptive_penalty = (bins_remain_cap - item) / (max_cap + 1e-6)\n    penalty_adjustment = 1 / (1 + np.exp(penalty_factor * adaptive_penalty))\n    \n    # Combine feasibility, sigmoid priority, and penalty adjustment\n    priority_score = ifbinsfit * sigmoid_priority * penalty_adjustment\n    \n    return priority_score\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, sigmoid penalties, and\n    adaptive adjustments considering both remaining capacity and item specifics.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    min_cap, max_cap = np.min(bins_remain_cap), np.max(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Dynamic midpoint calculation based on current item and remaining capacities\n    midpoint = (np.median(bins_remain_cap) - item) / (max_cap - min_cap + 1e-6)\n    \n    # Sigmoid function to balance priorities with increased steepness\n    sigmoid_steepness = 10.0\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - midpoint)))\n    \n    # Adaptive penalty adjustment based on the difference between bin capacity and item size\n    penalty_factor = 0.5\n    adaptive_penalty = (bins_remain_cap - item) / (max_cap + 1e-6)\n    penalty_adjustment = 1 / (1 + np.exp(penalty_factor * adaptive_penalty))\n    \n    # Combine feasibility, sigmoid priority, and penalty adjustment\n    priority_score = ifbinsfit * sigmoid_priority * penalty_adjustment\n    \n    return priority_score\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a dynamic and adaptive approach that considers item-specific fitting, \n    normalized remaining capacity, and a soft capacity limit to better balance the packing process.\n    \"\"\"\n    # Check if the item fits in each bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the dynamic midpoint based on the current item size and remaining capacities\n    midpoint = (item / np.max(bins_remain_cap)) + (bins_remain_cap / np.max(bins_remain_cap)).mean() / 2\n    \n    # Normalize remaining capacities for fair comparison\n    norm_remain_cap = (bins_remain_cap - midpoint) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid function to prioritize bins close to the dynamic midpoint\n    sigmoid_steepness = 10.0  # Adjust steepness for sensitivity\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap)))\n    \n    # Combine feasibility with sigmoid priority\n    priority_scores = ifbinsfit * sigmoid_priority\n    \n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a dynamic and adaptive approach that considers item-specific fitting, \n    normalized remaining capacity, and a soft capacity limit to better balance the packing process.\n    \"\"\"\n    # Check if the item fits in each bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the dynamic midpoint based on the current item size and remaining capacities\n    midpoint = (item / np.max(bins_remain_cap)) + (bins_remain_cap / np.max(bins_remain_cap)).mean() / 2\n    \n    # Normalize remaining capacities for fair comparison\n    norm_remain_cap = (bins_remain_cap - midpoint) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid function to prioritize bins close to the dynamic midpoint\n    sigmoid_steepness = 10.0  # Adjust steepness for sensitivity\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap)))\n    \n    # Combine feasibility with sigmoid priority\n    priority_scores = ifbinsfit * sigmoid_priority\n    \n    return priority_scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties and adaptive midpoint calculations.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_leftover = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 5.0  # Steepness of the sigmoid\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (norm_leftover - x0))))  # Sigmoid penalty for space efficiency\n    return priority_scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties and adaptive midpoint calculations.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_leftover = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 5.0  # Steepness of the sigmoid\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (norm_leftover - x0))))  # Sigmoid penalty for space efficiency\n    return priority_scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization and item-specific adjustments.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0 + (item / np.max(bins_remain_cap)) * 5  # Adaptive sigmoid steepness based on item size\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    penalty = np.maximum(0, 1 - ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)))  # Adaptive penalty\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (penalty + 1e-6)  # Sigmoid priority with penalty\n    return priority_scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility, dynamic sigmoid penalties, and adaptive adjustments.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity dynamically\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Calculate normalized item size\n    norm_item_size = item / np.max(bins_remain_cap)\n    \n    # Dynamic sigmoid steepness based on item size and remaining capacity\n    sigmoid_steepness = 10 * (1 - norm_item_size)\n    \n    # Calculate sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - norm_item_size)))\n    \n    # Adaptive penalty based on remaining capacity after placing the item\n    penalty = np.maximum(0, 1 - ((bins_remain_cap - item) / np.max(bins_remain_cap)))\n    \n    # Combine feasibility, sigmoid penalty, and adaptive adjustments\n    priority_score = ifbinsfit * sigmoid_priority / (penalty + 1e-6)\n    \n    return priority_score\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a dynamic and adaptive approach that considers item-specific fits, \n    normalized remaining capacity, and a refined penalty mechanism.\n    \n    Parameters:\n    - item (float): The size of the current item to be packed.\n    - bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n    \n    Returns:\n    - np.ndarray: A priority score for each bin, where higher scores indicate a better fit.\n    \"\"\"\n    # Check if the item can fit in each bin\n    fit_feasibility = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize the remaining capacities\n    total_remaining_cap = np.sum(bins_remain_cap)\n    if total_remaining_cap == 0:\n        total_remaining_cap = 1e-9  # Avoid division by zero\n    norm_remain_cap = bins_remain_cap / total_remaining_cap\n    \n    # Calculate the normalized fit of the item to each bin\n    item_fit = (bins_remain_cap - item) / total_remaining_cap\n    \n    # Adaptive penalty function to avoid very small remainders\n    penalty_factor = np.where(item_fit < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    \n    # Dynamic adjustment based on current item size relative to average bin capacity\n    avg_bin_cap = np.mean(bins_remain_cap)\n    item_rel_size = item / avg_bin_cap\n    dynamic_adjustment = np.exp(-np.abs(item_rel_size - norm_remain_cap))\n    \n    # Combine feasibility, normalized fit, and dynamic adjustment with adaptive penalty\n    priority_scores = fit_feasibility * (dynamic_adjustment * norm_remain_cap) / penalty_factor\n    \n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization and item-specific adjustments.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0 + (item / np.max(bins_remain_cap)) * 5  # Adaptive sigmoid steepness based on item size\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    penalty = np.maximum(0, 1 - ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)))  # Adaptive penalty\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0)))) / (penalty + 1e-6)  # Sigmoid priority with penalty\n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using a dynamic and adaptive approach that considers item-specific fits, \n    normalized remaining capacity, and a refined penalty mechanism.\n    \n    Parameters:\n    - item (float): The size of the current item to be packed.\n    - bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.\n    \n    Returns:\n    - np.ndarray: A priority score for each bin, where higher scores indicate a better fit.\n    \"\"\"\n    # Check if the item can fit in each bin\n    fit_feasibility = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize the remaining capacities\n    total_remaining_cap = np.sum(bins_remain_cap)\n    if total_remaining_cap == 0:\n        total_remaining_cap = 1e-9  # Avoid division by zero\n    norm_remain_cap = bins_remain_cap / total_remaining_cap\n    \n    # Calculate the normalized fit of the item to each bin\n    item_fit = (bins_remain_cap - item) / total_remaining_cap\n    \n    # Adaptive penalty function to avoid very small remainders\n    penalty_factor = np.where(item_fit < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    \n    # Dynamic adjustment based on current item size relative to average bin capacity\n    avg_bin_cap = np.mean(bins_remain_cap)\n    item_rel_size = item / avg_bin_cap\n    dynamic_adjustment = np.exp(-np.abs(item_rel_size - norm_remain_cap))\n    \n    # Combine feasibility, normalized fit, and dynamic adjustment with adaptive penalty\n    priority_scores = fit_feasibility * (dynamic_adjustment * norm_remain_cap) / penalty_factor\n    \n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties and adaptive midpoint calculations.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_leftover = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 5.0  # Steepness of the sigmoid\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (norm_leftover - x0))))  # Sigmoid penalty for space efficiency\n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}