{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, adaptive sigmoid penalty, and dynamic midpoint.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    midpoint = item / np.max(bins_remain_cap)\n    penalty_factor = 8.060154863007442 + 3 * (item / np.max(bins_remain_cap))\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    return can_fit * sigmoid_penalty / (penalty + 1e-6)\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, adaptive sigmoid penalty, and dynamic midpoint.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    midpoint = item / np.max(bins_remain_cap)\n    penalty_factor = 8.060154863007442 + 3 * (item / np.max(bins_remain_cap))\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    return can_fit * sigmoid_penalty / (penalty + 1e-6)\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamically adjusted sigmoid penalties,\n    and adaptive midpoint based on item and bin characteristics.\n    \"\"\"\n    # Check if the item can fit in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint based on item size relative to bin capacity\n    midpoint = item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6)\n    \n    # Calculate dynamic penalty factor based on item size\n    penalty_factor = 6.0 + 2 * (item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6))\n    \n    # Calculate adaptive sigmoid penalty to adjust priority based on remaining capacity and item size\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate adjusted penalty based on remaining capacity and item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine feasibility, sigmoid penalty, and adjusted penalty to calculate priority scores\n    priority_scores = can_fit * sigmoid_penalty / (penalty + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamically adjusted sigmoid penalties,\n    and adaptive midpoint based on item and bin characteristics.\n    \"\"\"\n    # Check if the item can fit in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint based on item size relative to bin capacity\n    midpoint = item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6)\n    \n    # Calculate dynamic penalty factor based on item size\n    penalty_factor = 6.0 + 2 * (item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6))\n    \n    # Calculate adaptive sigmoid penalty to adjust priority based on remaining capacity and item size\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate adjusted penalty based on remaining capacity and item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine feasibility, sigmoid penalty, and adjusted penalty to calculate priority scores\n    priority_scores = can_fit * sigmoid_penalty / (penalty + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamically adjusted sigmoid penalties,\n    and adaptive midpoint based on item and bin characteristics.\n    \"\"\"\n    # Check if the item can fit in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint based on item size relative to bin capacity\n    midpoint = item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6)\n    \n    # Calculate dynamic penalty factor based on item size\n    penalty_factor = 6.0 + 2 * (item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6))\n    \n    # Calculate adaptive sigmoid penalty to adjust priority based on remaining capacity and item size\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate adjusted penalty based on remaining capacity and item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine feasibility, sigmoid penalty, and adjusted penalty to calculate priority scores\n    priority_scores = can_fit * sigmoid_penalty / (penalty + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamically adjusted sigmoid penalties,\n    and adaptive midpoint based on item and bin characteristics.\n    \"\"\"\n    # Check if the item can fit in the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint based on item size relative to bin capacity\n    midpoint = item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6)\n    \n    # Calculate dynamic penalty factor based on item size\n    penalty_factor = 6.0 + 2 * (item / (np.max(bins_remain_cap) if np.max(bins_remain_cap) > 0 else 1e-6))\n    \n    # Calculate adaptive sigmoid penalty to adjust priority based on remaining capacity and item size\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate adjusted penalty based on remaining capacity and item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Combine feasibility, sigmoid penalty, and adjusted penalty to calculate priority scores\n    priority_scores = can_fit * sigmoid_penalty / (penalty + 1e-6)\n    \n    return priority_scores\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive sigmoid penalties with dynamic tuning.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty\n    sigmoid_steepness = 9.78504159548925  # Tuned sigmoid steepness\n    priority_scores = can_fit * (1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))) / (penalty + 1e-6)\n    return priority_scores\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive sigmoid penalties with dynamic tuning.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty\n    sigmoid_steepness = 9.78504159548925  # Tuned sigmoid steepness\n    priority_scores = can_fit * (1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))) / (penalty + 1e-6)\n    return priority_scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining fit feasibility, dynamic sigmoid penalties, and normalized capacity.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty\n    sigmoid_steepness = 10.0  # Tuned sigmoid steepness\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))\n    adaptive_influence = sigmoid_priority / (penalty + 1e-6)\n    priority_scores = can_fit * adaptive_influence\n    return priority_scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining fit feasibility, dynamic sigmoid penalties, and normalized capacity.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty\n    sigmoid_steepness = 10.0  # Tuned sigmoid steepness\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))\n    adaptive_influence = sigmoid_priority / (penalty + 1e-6)\n    priority_scores = can_fit * adaptive_influence\n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins by combining fit feasibility, dynamic sigmoid penalties, and normalized capacity.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    penalty = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Adaptive penalty\n    sigmoid_steepness = 10.0  # Tuned sigmoid steepness\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - x0)))\n    adaptive_influence = sigmoid_priority / (penalty + 1e-6)\n    priority_scores = can_fit * adaptive_influence\n    return priority_scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties for robust bin selection.\n    \"\"\"\n    # Fit feasibility\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Adaptive midpoint calculation\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid steepness\n    k = 1.0 + (item / np.max(bins_remain_cap)) * 5\n    \n    # Dynamic sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines normalized fit feasibility with adaptive sigmoid penalties for robust bin selection.\n    \"\"\"\n    # Fit feasibility\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Adaptive midpoint calculation\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid steepness\n    k = 1.0 + (item / np.max(bins_remain_cap)) * 5\n    \n    # Dynamic sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    \n    # Combine feasibility and adaptive penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, normalized remaining capacity, and an adaptive sigmoid penalty based on item size.\n    \"\"\"\n    # Check if item fits into the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Calculate adaptive midpoint and steepness\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    penalty_factor = 10 + 4 * (item / np.max(bins_remain_cap))\n    \n    # Calculate sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate priority score by combining feasibility and penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, normalized capacity, and adaptive sigmoid penalties for nuanced bin selection.\n    \"\"\"\n    # Check if item fits into the bin\n    can_fit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    \n    # Calculate dynamic midpoint and steepness\n    midpoint = item / (np.mean(bins_remain_cap) + 1e-6)\n    penalty_factor = 10 + 3 * (item / np.max(bins_remain_cap))\n    \n    # Calculate sigmoid penalty\n    sigmoid_penalty = 1 / (1 + np.exp(-penalty_factor * (norm_remain_cap - midpoint)))\n    \n    # Calculate priority score by combining feasibility and penalty\n    priority_score = can_fit * (1 - sigmoid_penalty)\n    \n    return priority_score\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive sigmoid penalties with dynamic midpoints.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    midpoint = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    k = 5.0  # Steepness of the sigmoid\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    adaptive_penalty = 1 / (1 + np.exp(5 * ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6))))\n    priority_scores = can_fit * sigmoid_penalty * adaptive_penalty\n    return priority_scores\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Prioritizes bins using normalized fit feasibility and adaptive sigmoid penalties with dynamic midpoints.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)\n    norm_remain_cap = bins_remain_cap / (np.max(bins_remain_cap) + 1e-6)\n    midpoint = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))\n    k = 5.0  # Steepness of the sigmoid\n    sigmoid_penalty = 1 / (1 + np.exp(-k * (norm_remain_cap - midpoint)))\n    adaptive_penalty = 1 / (1 + np.exp(5 * ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6))))\n    priority_scores = can_fit * sigmoid_penalty * adaptive_penalty\n    return priority_scores\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, dynamic sigmoid midpoint, and adaptive penalty for precise bin selection.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    penalty_factor = np.where(norm_leftover < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    sigmoid_priority = 1 / (1 + np.exp(-k * (norm_leftover - x0)))  # Sigmoid probability of bin fit\n    priority_scores = ifbinsfit * (sigmoid_priority / (adaptive_penalty * penalty_factor + 1e-6))  # Combined priority score\n    return priority_scores\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, dynamic sigmoid midpoint, and adaptive penalty for precise bin selection.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    penalty_factor = np.where(norm_leftover < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    sigmoid_priority = 1 / (1 + np.exp(-k * (norm_leftover - x0)))  # Sigmoid-based priority calculation\n    priority_scores = ifbinsfit * sigmoid_priority / (adaptive_penalty * penalty_factor + 1e-6)  # Final priority score\n    return priority_scores\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines fit feasibility, dynamic sigmoid midpoint, and adaptive penalty for precise bin selection.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    adaptive_penalty = np.abs(norm_leftover - x0)  # Adaptive penalty based on normalized leftover space\n    penalty_factor = np.where(norm_leftover < 0, 1e6, 1)  # Strong penalty for over-capacity bins\n    sigmoid_priority = 1 / (1 + np.exp(-k * (norm_leftover - x0)))  # Sigmoid-based priority calculation\n    priority_scores = ifbinsfit * sigmoid_priority / (adaptive_penalty * penalty_factor + 1e-6)  # Final priority score\n    return priority_scores\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}