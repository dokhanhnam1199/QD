{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines capacity fit and penalizes leftover space to prioritize bins efficiently.\"\"\"\n    # Ensure item can fit in the bin\n    can_fit = bins_remain_cap >= item\n    space_left = bins_remain_cap - item\n    # Priority based on remaining capacity and penalty for leftover space\n    priority = can_fit * (1 - (space_left / bins_remain_cap))\n    return priority\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version of the heuristic implements a dynamic penalty system that evaluates the\n    insertion of an item into each bin by considering both the remaining capacity and\n    the potential for future space inefficiency. It uses a sigmoid function to prioritize\n    bins that are closer to being full while also penalizing bins that are too empty.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize the remaining capacities\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    norm_remain_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n\n    # Calculate the sigmoid priority based on normalized capacity\n    sigmoid_priority = 1 / (1 + np.exp(-10 * (norm_remain_cap - 0.5)))\n\n    # Calculate a penalty for bins that can't even fit the item\n    can_fit = (bins_remain_cap >= item).astype(float)\n\n    # Combine the sigmoid priority with the penalty\n    priority_score = sigmoid_priority * can_fit\n\n    return priority_score\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristic uses a combination of normalized remaining capacity with a sigmoid function to prioritize bins while considering fit feasibility, leading to efficient space utilization and bin closure. The worst heuristic, on the other hand, uses complex and redundant calculations involving sine and clipping functions, which introduce unnecessary computational overhead and do not effectively prioritize bins for optimal placement. Comparing (second best) vs (second worst), we observe a distinction where the second best uses a simplified yet effective dynamic threshold adjustment, whereas the second worst uses a complex sinusoidal function that does not lead to better prioritization. Comparing (1st) vs (2nd), we see that while both incorporate penalties for leftover space, the first uses a sigmoid function for better refinement and fit feasibility. (3rd) vs (4th) indicates that both attempt to minimize leftover space, but the fourth heuristic directly penalizes tight bins slightly, which does not align with the goal of efficiently filling bins. Comparing (second worst) vs (worst), we see redundancy in methodologies but no substantial difference in effectiveness. Overall, the top-ranked heuristics prioritize through normalization, sigmoid functions, and adaptive penalization, leading to better space utilization compared to the bottom ranked which includes unnecessary complexity without added benefit.\n- \n- **Keywords**: Normalization, Sigmoid Functions, Dynamic Penalization, Bin Placement, Prioritization\n- **Advice**: Focus on fine-tuning normalization techniques to handle variable bin sizes and item weights more effectively. Explore adaptive sigmoid functions to dynamically adjust penalties based on the current state of placement. Implement dynamic penalization to not only penalize leftover space but also underutilized bins.\n- **Avoid**: Do not incorporate static or rigid space efficiency checks and item fit criteria as penalties within your heuristic. Avoid redundant calculations of penalties and inefficiency checks for the same placement scenarios.\n- **Explanation**: By focusing on adaptive methods and avoiding static penalties, the heuristic can better respond to diverse and changing conditions, leading to more optimized solutions in bin placement. This approach aims to streamline the decision-making process, focusing computational resources on significant variables that impact bin packing efficiency.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}