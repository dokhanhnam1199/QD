{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins using a dynamic and adaptive approach that considers item-specific fitting, \n    normalized remaining capacity, and a soft capacity limit to better balance the packing process.\n    \"\"\"\n    # Check if the item fits in each bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Calculate the dynamic midpoint based on the current item size and remaining capacities\n    midpoint = (item / np.max(bins_remain_cap)) + (bins_remain_cap / np.max(bins_remain_cap)).mean() / 2\n    \n    # Normalize remaining capacities for fair comparison\n    norm_remain_cap = (bins_remain_cap - midpoint) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Adaptive sigmoid function to prioritize bins close to the dynamic midpoint\n    sigmoid_steepness = 10.0  # Adjust steepness for sensitivity\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap)))\n    \n    # Combine feasibility with sigmoid priority\n    priority_scores = ifbinsfit * sigmoid_priority\n    \n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalties and adaptive midpoint calculations.\n    \"\"\"\n    can_fit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    norm_leftover = (bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 5.0  # Steepness of the sigmoid\n    x0 = item / (np.max(bins_remain_cap) + 1e-6)  # Dynamic midpoint based on item size\n    priority_scores = can_fit * (1 / (1 + np.exp(-k * (norm_leftover - x0))))  # Sigmoid penalty for space efficiency\n    return priority_scores\n\n### Analyze & experience\n- Comparing **Heuristics 1st** vs **Heuristics 20th**, we see that **Heuristics 1st** introduces additional parameters (`sigmoid_steepness` and `max_cap_offset`) and a more nuanced calculation for penalties and probabilities, leading to a more fine-grained control over prioritization. In contrast, **Heuristics 20th** uses a fixed sigmoid steepness and a simplified penalty calculation.\n**Second Best** vs **Second Worst** (Heuristics 2nd vs Heuristics 19th), **Heuristics 2nd** is simpler and avoids the complex dynamic adjustments and penalty factors seen in **Heuristics 19th**, which makes it more straightforward and easier to understand without a significant loss in effectiveness.\nComparing **Heuristics 1st** vs **Heuristics 2nd**, **Heuristics 1st** includes two sigmoid penalties and a penalty factor, which allow for more detailed and adaptive decision-making, whereas **Heuristics 2nd** primarily relies on a single sigmoid penalty adjusted with the item size.\n**Heuristics 3rd** vs **Heuristics 18th** highlights that **Heuristics 3rd** has an additional penalty factor and a more comprehensive penalty adjustment, providing more precise tuning of the priority scores.\nComparing **Heuristics 17th** vs **Worst** (**Heuristics 20th**), **Heuristics 17th** integrates a sophisticated dynamic adjustment mechanism that considers the current item size relative to the average bin capacity, providing a more refined adaptability and priority scoring system.\nOverall: The top-ranked heuristics tend to include more parameters and mechanisms for adaptive adjustment, whereas the lower-ranked heuristics are simpler with fewer adaptive elements.\n- \n- **Keywords**: Adaptive mechanisms, tunable parameters, sensitivity, decision-making precision, item and bin characteristics, normalized normalization, dynamic parameter adjustment.\n- **Advice**: \n  - Implement adaptive mechanisms that allow for real-time changes in heuristic behavior based on the current state of items and bins.\n  - Use tunable parameters to finely adjust the sensitivity of the heuristic to various conditions, enhancing decision-making precision.\n  - Integrate normalized normalization techniques to ensure that all factors influencing bin selection and packing decisions are on a comparable scale.\n  - Develop flexible, dynamic parameter adjustment methods that respond to changes in item and bin characteristics, promoting better adaptability and performance.\n- **Avoid**: \n  - Static or fixed methods that do not allow for adjustments based on changing conditions.\n  - Unnecessary complexity and redundant calculations that do not add value to the heuristic's effectiveness.\n  - Paradoxical adaptive factors that may reduce efficiency or introduce inefficiencies into the system.\n  - Incorporating and penalizing leftover space in a way that space efficiency and item fit checks lead to more effective bin packing solutions, as it can distort heuristic priorities.\n- **Explanation**: By focusing on adaptive mechanisms and tunable parameters, the heuristic can dynamically respond to different problem scenarios, improving its overall effectiveness and efficiency. Normalized normalization ensures equitable consideration of various factors, while avoiding unnecessary complexity helps in maintaining computational efficiency and simplicity, ultimately leading to better decision-making in bin packing scenarios.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}