{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Combines normalized fit feasibility with dynamic sigmoid penalization, focusing on adaptive space utilization.\n    \"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    norm_leftover = leftover_space / (np.max(bins_remain_cap) + 1e-6)  # Normalize leftover space\n    k = 1.0  # Steepness of the sigmoid\n    x0 = 0.5 - (item / (np.max(bins_remain_cap) + 1e-6))  # Dynamic midpoint based on item size\n    priority_scores = ifbinsfit * (1 / (1 + np.exp(-k * (1 - norm_leftover - x0))))  # Sigmoid priority calculation\n    return priority_scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Prioritizes bins by combining normalized fit feasibility, dynamic sigmoid penalty, \n    and adaptive item fit with dynamic adjustments based on current problem state.\n    \"\"\"\n    # Check if item fits in the bin\n    ifbinsfit = (bins_remain_cap >= item).astype(float)\n    \n    # Normalize remaining capacity\n    norm_remain_cap = (bins_remain_cap - np.min(bins_remain_cap)) / (np.max(bins_remain_cap) - np.min(bins_remain_cap) + 1e-6)\n    \n    # Dynamic sigmoid steepness adjustment based on the item size relative to max capacity\n    sigmoid_steepness = 1 + (item / np.max(bins_remain_cap)) * 10\n    \n    # Calculate dynamic sigmoid priority\n    sigmoid_priority = 1 / (1 + np.exp(-sigmoid_steepness * (norm_remain_cap - 0.5)))\n    \n    # Adaptive penalty based on the normalized remaining capacity after placing the item\n    penalty = np.maximum(0, 1 - ((bins_remain_cap - item) / (np.max(bins_remain_cap) + 1e-6)))\n    \n    # Dynamic adjustment for priority based on the number of empty bins\n    empty_bin_adjustment = 1 + (np.mean(bins_remain_cap == np.max(bins_remain_cap)) ** 2) * 5\n    \n    # Combine feasibility, sigmoid, penalty, and dynamic adjustments\n    priority_scores = ifbinsfit * sigmoid_priority / (penalty + 1e-6) * empty_bin_adjustment\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) Heuristics 1st vs (worst) Heuristics 20th, we see that the best approach includes a more nuanced combination of normalized fit feasibility, sigmoid penalties, and adaptive adjustments that consider both remaining capacity and item specifics. The worst approach also tries to incorporate similar elements but lacks dynamic adjustments, leading to less optimal prioritization. Comparing (second best) Heuristics 2nd vs (second worst) Heuristics 19th, we observe better handling of dynamic sigmoid steepness and adaptive penalties in the second best, which accounts for the item size and remaining capacity more effectively. Comparing (1st) vs (2nd), the first includes an additional penalty component and a more detailed midpoint calculation, aligning with better prioritization. (3rd) vs (4th) and (5th) vs (6th) show redundancy, where the code is almost identical across these ranks, indicating that while they perform reasonably well, they do not stand out as innovative or more effective. Comparing (7th) vs (8th), the 8th introduces an adaptive priority adjustment that considers current problem state more explicitly, indicating an advantage in dynamic adjustment. Comparing (second worst) vs (worst), we see little to no difference in key logic components, both failing to optimize beyond basic sigmoid penalties and fit feasibility. Overall: The top-ranked heuristics consistently incorporate sophisticated dynamic adjustments for midpoint calculations and penalties, leading to more effective bin prioritization.\n- \n- **Keywords:** Dynamic adjustments, adaptive functions, item-specific calculations, normalization\n- **Advice:** Implement problem-specific calculations that dynamically adjust according to current conditions and item characteristics to balance objectives effectively.\n- **Avoid:** Static penalization, unnecessary complexity, fixed methods, paradoxical adaptive factors\n- **Explanation:** By using dynamic and adaptive mechanisms, the heuristic can respond more accurately to the changing nature of the bin packing problem, improving its effectiveness without adding unnecessary complexity. Normalization should be continuously applied to ensure comparability and fair prioritization across varying scenarios.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}