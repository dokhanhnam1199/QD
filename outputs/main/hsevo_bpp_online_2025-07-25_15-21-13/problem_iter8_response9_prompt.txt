{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Prioritizes bins by normalized fit feasibility and adaptive penalty on leftover space.\"\"\"\n    ifbinsfit = (bins_remain_cap >= item).astype(float)  # Check if item fits in the bin\n    leftover_space = np.where(ifbinsfit, bins_remain_cap - item, np.inf)  # Calculate leftover space\n    # Use an adaptive penalty based on leftover space, with normalization\n    penalty = leftover_space / (np.max(bins_remain_cap) + 1e-6)\n    # Combine fit feasibility with adaptive penalty\n    return ifbinsfit / (penalty + 1e-6)\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version uses a sigmoid function to dynamically adjust the priority scores based on the item size and remaining bin capacities. The goal is to balance between filling bins well and not over-penalizing bins that are almost full.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Normalize remaining capacities\n    max_cap = np.max(bins_remain_cap)\n    min_cap = np.min(bins_remain_cap)\n    normalized_cap = (bins_remain_cap - min_cap) / (max_cap - min_cap + 1e-6)\n    \n    # Sigmoid function with dynamic parameters based on item size\n    k = 1.0  # Steepness of the sigmoid function, can be tuned\n    x0 = 0.5 - (item / (max_cap + 1e-6))  # Midpoint of the sigmoid function, adjusted by item size\n    priority_scores = 1 / (1 + np.exp(-k * (normalized_cap - x0)))\n    \n    return priority_scores\n\n### Analyze & experience\n- Comparing (best) vs (worst), we see that the best heuristics use combinations of normalized fit feasibility, dynamic penalties, and sigmoid functions to balance between filling bins and minimizing leftover space, whereas the worst simply use an inverse of remaining capacity with a sinusoidal function, which does not dynamically adapt to item sizes or bin capacities. \n\n(Second best) vs (second worst), we observe that the second best uses a sigmoid function to dynamically adjust priorities, ensuring a balance between fit feasibility and leftover space minimization, whereas the second worst again uses a fixed inverse and sinusoidal function, ignoring dynamic adjustments.\n\nComparing (1st) vs (2nd), we see minimal differences, with both highly adaptive and using sigmoid functions; however, the first version slightly better exploits item size in its dynamic parameters.\n\n(3rd) vs (4th), both use fixed methods without adaptability, with the third using sinusoidal adjustment which slightly outperforms the fourth due to its mathematical form balancing capacities better.\n\nComparing (second worst) vs (worst), we see little differentiation as both are non-adaptive and do not incorporate item size or dynamic adjustments in their methods.\n\nOverall:\n- \n- **Keywords**: Dynamic adjustments, adaptive functions, flexible penalties, item fit checks, bin prioritization, simplicity.\n  \n- **Advice**: Focus on real-time evaluation and updating of heuristic parameters based on evolving problem conditions. Leverage adaptive functions to dynamically adjust penalties and priorities. Prioritize simplicity while ensuring robustness in bin fit evaluation.\n\n- **Avoid**: Fixed heuristic designs, static penalties, unnecessary complexity, and redundant recalculations. Do not rigidly incorporate space efficiency checks and penalization as these can lead to suboptimal solutions in some scenarios.\n\n- **Explanation**: Effective heuristics adapt to the problem's landscape. By using dynamic adjustments and adaptive functions, the heuristic can better navigate through complex optimization spaces. Flexibility allows the heuristic to respond to changing conditions, improving its robustness and scalability. Emphasizing simplicity ensures that the heuristic remains efficient and easy to implement, avoiding the pitfalls of overly complex models that can lead to poor performance and unnecessary computational costs.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}