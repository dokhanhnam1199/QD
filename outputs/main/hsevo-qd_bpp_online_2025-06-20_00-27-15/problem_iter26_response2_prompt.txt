{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance:\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities.\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n\n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # 4. Introduce a \"best fit\" component: prioritize bins where the remaining space is small but non-zero.\n    best_fit_score = np.exp(-10 * remaining_space / bins_remain_cap[valid_bins])  # Exponential decay\n\n    # 5. Introduce a penalty for bins that are already nearly full\n    nearly_full_penalty = np.where(bins_remain_cap[valid_bins] < 2 * item, 0.2, 0.0)\n\n    # Combine the factors to create the priority score, adjusting weights.\n    priorities[valid_bins] = (\n        0.3 * fill_ratio +\n        0.2 * remaining_space_penalty +\n        0.3 * capacity_utilization +\n        0.2 * best_fit_score -\n        nearly_full_penalty  # Subtract the penalty\n    )\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), we see that they are identical. This indicates that the ranking might not be based on functional differences between these two.\nComparing (1st) vs (3rd), we see that the first heuristic includes capacity diversity penalty, and fill target penalty, while the third heuristic does not include them. Additionally, (1st) has adaptive weights and prefer filling empty bins initially, while the (3rd) lacks these.\nComparing (3rd) vs (5th), (6th), (7th), (8th), (9th), (11th), (13th), (15th), (17th), we find that (3rd) uses adaptive weighting based on item size relative to bin sizes, while the others either don't or have simpler weighting mechanisms (e.g., item_size_weight = item in 5th, 8th, 9th). (3rd) also includes a \"space_balance\" factor.\nComparing (5th) vs (6th), we see that (5th) adds `item_size_weight = item`.\nComparing (11th) vs (12th), we see that (12th) uses default values for invalid_priority and epsilon, and simplifies the if statement.\nComparing (15th) vs (16th), we see that they are identical.\nComparing (17th) vs (18th), we see that they are identical.\nComparing (10th) vs (11th), we see that (10th) uses external variables for invalid_priority and epsilon, while (11th) hardcodes them. (10th) imports `random`, `math`, `scipy`, and `torch` but does not use them.\nComparing (19th) vs (20th), we see that (19th) uses external variables with specific values for fill ratio weight, remaining space penalty weight, capacity utilization weight, space balance threshold, etc, but the code block is incomplete, whereas (20th) only uses `item` and `bins_remain_cap`. It directly computes the ratios of item size to bin capacities, takes the logarithm of these ratios, and uses the negative logarithm as the priority.\n\nOverall: The better heuristics attempt to incorporate more factors into their priority calculation, such as adaptive weights based on item size, bin diversity, target fill levels and empty bin preference. Simpler heuristics focus on fill ratio and remaining space. The worst heuristic directly uses log ratios of item size to bin capacity, which may not be as effective at balancing the various factors involved in efficient bin packing. The use of constants, default values, and unnecessary imports also seems to correlate with lower ranking.\n- \nOkay, let's redefine \"Current self-reflection\" for designing better heuristics, focusing on actionable insights and avoiding common pitfalls, aiming for that million-dollar insight!\n\nHere's a refined perspective:\n\n*   **Keywords:** Multi-factor, adaptive weights, parameter tuning, iterative refinement, edge case handling, domain relevance, performance analysis.\n\n*   **Advice:** Combine relevant, interacting factors; use adaptive weights driven by input characteristics; tune parameters systematically. Iteratively refine based on performance analysis. Explicitly handle edge cases.\n\n*   **Avoid:** Hardcoding parameters; oversimplification without justification; premature complexity; neglecting thorough testing and validation.\n\n*   **Explanation:** Build heuristics by intelligently merging relevant factors, allowing adaptability through parameter tuning and weighted contributions. Rigorous testing and iterative refinement based on performance analysis are essential for robust and effective solutions.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}