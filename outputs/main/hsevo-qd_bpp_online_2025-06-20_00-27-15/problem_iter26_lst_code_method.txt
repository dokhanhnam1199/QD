{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance:\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities.\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance:\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities.\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins for an item, balancing fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n    item_size_weight = item\n\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, remaining space penalty, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n    item_size_weight = item\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1) #Reduced weighting\n\n    #5. Introduce item size weighting. Larger items should be packed first.\n    item_size_weight = item\n\n    # Combine the factors to create the priority score.\n    # Reduced the weightage to space_balance\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1) #Reduced weighting\n\n    #5. Introduce item size weighting. Larger items should be packed first.\n    item_size_weight = item\n\n    # Combine the factors to create the priority score.\n    # Reduced the weightage to space_balance\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -9.387025694128482, epsilon: float = 1.8518136137948416e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority for bins that cannot accommodate the item.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 0.000001))\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -np.inf, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"Assigns priority to bins based on fullness and remaining space.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness after packing and remaining space.\"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 1e-6))\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -9.387025694128482, epsilon: float = 1.8518136137948416e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority for bins that cannot accommodate the item.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    # Prioritize bins with remaining capacity close to item size (Best Fit)\n    # and also factor in fullness (item/bin_capacity). Add a small constant for stability.\n    \n    priorities[valid_bins] = (1 / (np.abs(remaining_space) + 0.000001)) + (item / bins_remain_cap[valid_bins])\n\n    # Add a bonus for bins that are relatively empty, encouraging better space utilization\n    # The emptier the bin, the higher the bonus.  This helps avoid creating too many almost-empty bins.\n    empty_bin_bonus = (1 / (bins_remain_cap + 0.000001)) * 0.1  # Scale down the bonus\n\n    priorities = priorities + empty_bin_bonus # Add the bonus to all bins, but invalid bins remain with -inf\n    \n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    # Prioritize bins with remaining capacity close to item size (Best Fit)\n    # and also factor in fullness (item/bin_capacity). Add a small constant for stability.\n    \n    priorities[valid_bins] = (1 / (np.abs(remaining_space) + 0.000001)) + (item / bins_remain_cap[valid_bins])\n\n    # Add a bonus for bins that are relatively empty, encouraging better space utilization\n    # The emptier the bin, the higher the bonus.  This helps avoid creating too many almost-empty bins.\n    empty_bin_bonus = (1 / (bins_remain_cap + 0.000001)) * 0.1  # Scale down the bonus\n\n    priorities = priorities + empty_bin_bonus # Add the bonus to all bins, but invalid bins remain with -inf\n    \n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n\n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # 4. Introduce a \"best fit\" component: prioritize bins where the remaining space is small but non-zero.\n    best_fit_score = np.exp(-10 * remaining_space / bins_remain_cap[valid_bins])  # Exponential decay\n\n    # 5. Introduce a penalty for bins that are already nearly full\n    nearly_full_penalty = np.where(bins_remain_cap[valid_bins] < 2 * item, 0.2, 0.0)\n\n    # Combine the factors to create the priority score, adjusting weights.\n    priorities[valid_bins] = (\n        0.3 * fill_ratio +\n        0.2 * remaining_space_penalty +\n        0.3 * capacity_utilization +\n        0.2 * best_fit_score -\n        nearly_full_penalty  # Subtract the penalty\n    )\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n\n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # 4. Introduce a \"best fit\" component: prioritize bins where the remaining space is small but non-zero.\n    best_fit_score = np.exp(-10 * remaining_space / bins_remain_cap[valid_bins])  # Exponential decay\n\n    # 5. Introduce a penalty for bins that are already nearly full\n    nearly_full_penalty = np.where(bins_remain_cap[valid_bins] < 2 * item, 0.2, 0.0)\n\n    # Combine the factors to create the priority score, adjusting weights.\n    priorities[valid_bins] = (\n        0.3 * fill_ratio +\n        0.2 * remaining_space_penalty +\n        0.3 * capacity_utilization +\n        0.2 * best_fit_score -\n        nearly_full_penalty  # Subtract the penalty\n    )\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 1.383352297928545,\n                remaining_space_penalty_weight: float = 1.5591283372979048, capacity_utilization_weight: float = 0.49252209073339603,\n                space_balance_threshold: float = 0.5764856540655822, space_balance_high: float = 0.4420637087883818,\n                space_balance_low: float = 0.1394491911814592, remaining_space_epsilon: float = 2.4457024732011557e-05,\n                item_size_weight_value: float = 0.9370963396346099) -> np.ndarray:\n    \"\"\"Prioritizes bins for an item, balancing fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}