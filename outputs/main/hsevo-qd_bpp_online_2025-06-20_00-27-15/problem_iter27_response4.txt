```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins based on a combination of factors, including fill ratio,
    remaining space, capacity utilization, space balance, item size, bin diversity, and
    a bin-level fill target. Adaptive weights are used to adjust the importance of each factor
    based on the item size and remaining bin capacities. Edge cases are handled to ensure stability.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item.
    new_capacities = bins_remain_cap - item

    # Identify bins that can accommodate the item.
    valid_bins = new_capacities >= 0

    # Initialize priorities with a very low value for invalid bins.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # If no bin can accommodate the item, return the initial priorities
    if not np.any(valid_bins):
        return priorities

    # Prioritize bins that can fit the item.
    priorities[valid_bins] = 0.0  # Initialize to zero before adding priority scores.

    remaining_space = bins_remain_cap[valid_bins] - item

    # 1. Fill ratio: How much of the bin will be filled by the item.
    fill_ratio = item / bins_remain_cap[valid_bins]

    # 2. Remaining space penalty: Penalize bins with little space left after adding the item.
    remaining_space_penalty = 1 / (remaining_space + 0.000001)

    # 3. Capacity utilization: How much of the bin's capacity is used after adding the item.
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]

    # 4. Space balance: Prefer bins where the remaining space is not too large relative to the item.
    space_balance = np.where(remaining_space > item / 2, 0.2, 0.8)

    # 5. Adaptive weight based on item size relative to average bin capacity
    item_size_ratio = item / np.mean(bins_remain_cap)
    adaptive_weight = 1.0
    if item_size_ratio > 0.7:
        adaptive_weight = 1.2  # Larger items are more important to place well
    elif item_size_ratio < 0.3:
        adaptive_weight = 0.8  # Smaller items give more placement flexibility

    # 6. Bin Diversity Penalty: Penalize bins with remaining capacities close to the mean. Encourages different fill levels.
    capacity_std = np.std(bins_remain_cap)
    if capacity_std > 0:
        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)
        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)
    else:
        capacity_diversity_penalty = 0  # if all capacities same, no diversity penalty

    # 7. Bin-level fill target to encourage balanced filling. Target around 75% fill.
    bin_fill_target = 0.75
    fill_from_empty_bonus = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.3, 0)  # prefer filling emptier bins initially

    current_fill_level = 1 - bins_remain_cap[valid_bins] / bins_remain_cap.max() #current fill level
    predicted_fill_level = 1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() #expected fill level
    fill_target_diff = np.abs(predicted_fill_level - bin_fill_target)
    fill_target_penalty = 1 / (fill_target_diff + 0.00001)

    # 8.  Symmetry Breaking: If multiple bins have very similar scores, choose one randomly
    # to prevent oscillations and promote exploration of different packing configurations.

    # Combine the factors to create the priority score.  Experiment with weights.
    priorities[valid_bins] = adaptive_weight * fill_ratio + \
                             0.8 * remaining_space_penalty + \
                             0.9 * capacity_utilization + \
                             0.7 * space_balance + \
                             0.2 * capacity_diversity_penalty + \
                             fill_from_empty_bonus + \
                             0.1 * fill_target_penalty

    #Add a small random number to break symetry
    priorities[valid_bins] += np.random.rand(len(remaining_space)) * 0.0001

    return priorities
```
