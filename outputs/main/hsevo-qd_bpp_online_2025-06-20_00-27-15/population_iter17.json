[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 0.000001))\n\n    return priorities",
    "response_id": 28,
    "tryHS": true,
    "obj": 4.038691663342641,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "mi": 66.45210158779007,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness after packing and remaining space.\"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 1e-6))\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 95.90827503317318,
    "mi": 84.72819187848067,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    # Prioritize bins with remaining capacity close to item size (Best Fit)\n    # and also factor in fullness (item/bin_capacity). Add a small constant for stability.\n    \n    priorities[valid_bins] = (1 / (np.abs(remaining_space) + 0.000001)) + (item / bins_remain_cap[valid_bins])\n\n    # Add a bonus for bins that are relatively empty, encouraging better space utilization\n    # The emptier the bin, the higher the bonus.  This helps avoid creating too many almost-empty bins.\n    empty_bin_bonus = (1 / (bins_remain_cap + 0.000001)) * 0.1  # Scale down the bonus\n\n    priorities = priorities + empty_bin_bonus # Add the bonus to all bins, but invalid bins remain with -inf\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 166.4210625757214,
    "mi": 70.73171345752299,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter16_response0.txt_stdout.txt",
    "code_path": "problem_iter16_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -9.366032542332638, epsilon: float = 3.383455546862948e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority for bins that cannot accommodate the item.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 84.0,
    "mi": 74.33633396121473,
    "token_count": 119.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -np.inf, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"Assigns priority to bins based on fullness and remaining space.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.4736875252405,
    "mi": 85.08702249349118,
    "token_count": 127.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. How full the bin would become (packing density).\n    2. A \"tight fit\" bonus, preferring bins where the remaining space is small but non-zero.\n    3. A penalty for bins that would become too empty.\n    4. Adaptive parameter adjustments based on item size relative to bin size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # Only calculate scores for valid bins\n    valid_capacities = bins_remain_cap[valid_bins]\n    valid_new_capacities = new_capacities[valid_bins]\n\n    # Calculate packing density (higher is better)\n    packing_density = item / valid_capacities\n\n    # Tight fit bonus (remaining space is small, higher is better)\n    # Avoid division by zero by adding a small constant\n    tight_fit_bonus = 1 / (valid_new_capacities + 0.000001)\n\n    # Penalty for bins that become too empty (lower is better)\n    empty_penalty = (valid_new_capacities / np.max(bins_remain_cap))  # Normalize to bin size\n\n    # Adaptive parameter adjustments based on item size\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    # Adjust weights based on item size ratio\n    density_weight = 1.0 + item_size_ratio * 0.5  # Increase importance for larger items\n    tight_fit_weight = 1.0 - item_size_ratio * 0.3  # Decrease importance for larger items, prioritize utilization\n    empty_penalty_weight = 0.5 + item_size_ratio * 0.2 # Increase importance for larger items\n    \n    # Combine factors with weights\n    priorities[valid_bins] = (\n        density_weight * packing_density +\n        tight_fit_weight * tight_fit_bonus -\n        empty_penalty_weight * empty_penalty\n    )\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 166.4210625757214,
    "mi": 80.42758909917298,
    "token_count": 160.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 184.60327781484776,
    "mi": 74.24232436042227,
    "token_count": 155.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities considering fill ratio, remaining space, and a space balance.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item / 2, 0.5, 0.1)\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 210.99629561116632,
    "mi": 57.80117879641227,
    "token_count": 151.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1) #Reduced weighting\n\n    #5. Introduce item size weighting. Larger items should be packed first.\n    item_size_weight = item\n\n    # Combine the factors to create the priority score.\n    # Reduced the weightage to space_balance\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 349.403623592787,
    "mi": 77.29696456753466,
    "token_count": 290.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Assigns priority to bins based on fill ratio, remaining space, item size.\n    Prioritizes bins that fit the item well and balances space utilization.\n    \"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item / 2, 0.3, 0.1)\n    item_size_weight = item\n\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 249.28567922126666,
    "mi": 76.75472715602044,
    "token_count": 183.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n\n    #5. Item size relative to the average remaining bin capacity\n    avg_remaining_capacity = np.mean(bins_remain_cap)\n    item_size_vs_avg_capacity = item / (avg_remaining_capacity + 0.000001)\n\n    #6. Penalize bins that are too empty compared to item size. If remaining capacity is much bigger than item.\n    empty_bin_penalty = np.where(bins_remain_cap[valid_bins] > 2*item, -0.1, 0)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + empty_bin_penalty - item_size_vs_avg_capacity * 0.05\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 28.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 421.10323830864064,
    "mi": 78.73837628011665,
    "token_count": 278.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins for an item, balancing fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n    item_size_weight = item\n\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 355.89294990339823,
    "mi": 54.48415298824115,
    "token_count": 199.0,
    "exec_success": true
  }
]