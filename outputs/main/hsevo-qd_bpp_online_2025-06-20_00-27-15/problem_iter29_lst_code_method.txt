{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance: Aim for bins to have similar fill levels\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size -  Larger items need more careful placement\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Penalize very full bins more strongly\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8 # Be less picky when items are small\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities to encourage variance\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n    \n    #8. Introduce Penalty for bins almost full. Encourages use of emptier bins, creates space for future large objects.\n    almost_full_threshold = 0.9\n    almost_full_penalty = np.where((bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() < (1-almost_full_threshold), -0.3, 0)\n    \n    #9. Sort remaining capacities and add a bonus to bins close to the median\n    sorted_caps = np.sort(bins_remain_cap)\n    median_cap = np.median(bins_remain_cap)\n    median_proximity_bonus = np.exp(-np.abs(bins_remain_cap[valid_bins] - median_cap) / (0.1 * bins_remain_cap.max())) * 0.1 # gaussian bonus near median\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty + almost_full_penalty + median_proximity_bonus\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance: Aim for bins to have similar fill levels\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size -  Larger items need more careful placement\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Penalize very full bins more strongly\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8 # Be less picky when items are small\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities to encourage variance\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n    \n    #8. Introduce Penalty for bins almost full. Encourages use of emptier bins, creates space for future large objects.\n    almost_full_threshold = 0.9\n    almost_full_penalty = np.where((bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() < (1-almost_full_threshold), -0.3, 0)\n    \n    #9. Sort remaining capacities and add a bonus to bins close to the median\n    sorted_caps = np.sort(bins_remain_cap)\n    median_cap = np.median(bins_remain_cap)\n    median_proximity_bonus = np.exp(-np.abs(bins_remain_cap[valid_bins] - median_cap) / (0.1 * bins_remain_cap.max())) * 0.1 # gaussian bonus near median\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty + almost_full_penalty + median_proximity_bonus\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance: Aim for bins to have similar fill levels\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size -  Larger items need more careful placement\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Penalize very full bins more strongly\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8 # Be less picky when items are small\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities to encourage variance\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n    \n    #8. Introduce Penalty for bins almost full. Encourages use of emptier bins, creates space for future large objects.\n    almost_full_threshold = 0.9\n    almost_full_penalty = np.where((bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() < (1-almost_full_threshold), -0.3, 0)\n    \n    #9. Sort remaining capacities and add a bonus to bins close to the median\n    sorted_caps = np.sort(bins_remain_cap)\n    median_cap = np.median(bins_remain_cap)\n    median_proximity_bonus = np.exp(-np.abs(bins_remain_cap[valid_bins] - median_cap) / (0.1 * bins_remain_cap.max())) * 0.1 # gaussian bonus near median\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty + almost_full_penalty + median_proximity_bonus\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance:\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities.\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Calculate fill ratio and remaining space for valid bins.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Remaining space penalty:\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # Capacity utilization:\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # Space balance:\n    space_balance = np.where(remaining_space > item / 2, 0.5, 0.1)\n\n    # Adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n\n    # Combine factors to create priority score.\n    priorities[valid_bins] = (adaptive_weight * fill_ratio +\n                               remaining_space_penalty +\n                               capacity_utilization +\n                               space_balance)\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Calculate fill ratio and remaining space for valid bins.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Remaining space penalty:\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # Capacity utilization:\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # Space balance:\n    space_balance = np.where(remaining_space > item / 2, 0.5, 0.1)\n\n    # Adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n\n    # Combine factors to create priority score.\n    priorities[valid_bins] = (adaptive_weight * fill_ratio +\n                               remaining_space_penalty +\n                               capacity_utilization +\n                               space_balance)\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    # Calculate fill ratio and remaining space for valid bins.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Remaining space penalty:\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # Capacity utilization:\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # Space balance:\n    space_balance = np.where(remaining_space > item / 2, 0.5, 0.1)\n\n    # Adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n\n    # Combine factors to create priority score.\n    priorities[valid_bins] = (adaptive_weight * fill_ratio +\n                               remaining_space_penalty +\n                               capacity_utilization +\n                               space_balance)\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities considering fill ratio, remaining space, and a space balance.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item / 2, 0.5, 0.1)\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n\n    #5. Item size relative to the average remaining bin capacity\n    avg_remaining_capacity = np.mean(bins_remain_cap)\n    item_size_vs_avg_capacity = item / (avg_remaining_capacity + 0.000001)\n\n    #6. Penalize bins that are too empty compared to item size. If remaining capacity is much bigger than item.\n    empty_bin_penalty = np.where(bins_remain_cap[valid_bins] > 2*item, -0.1, 0)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + empty_bin_penalty - item_size_vs_avg_capacity * 0.05\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. How full the bin would become (packing density).\n    2. A \"tight fit\" bonus, preferring bins where the remaining space is small but non-zero.\n    3. A penalty for bins that would become too empty.\n    4. Adaptive parameter adjustments based on item size relative to bin size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # Only calculate scores for valid bins\n    valid_capacities = bins_remain_cap[valid_bins]\n    valid_new_capacities = new_capacities[valid_bins]\n\n    # Calculate packing density (higher is better)\n    packing_density = item / valid_capacities\n\n    # Tight fit bonus (remaining space is small, higher is better)\n    # Avoid division by zero by adding a small constant\n    tight_fit_bonus = 1 / (valid_new_capacities + 0.000001)\n\n    # Penalty for bins that become too empty (lower is better)\n    empty_penalty = (valid_new_capacities / np.max(bins_remain_cap))  # Normalize to bin size\n\n    # Adaptive parameter adjustments based on item size\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    # Adjust weights based on item size ratio\n    density_weight = 1.0 + item_size_ratio * 0.5  # Increase importance for larger items\n    tight_fit_weight = 1.0 - item_size_ratio * 0.3  # Decrease importance for larger items, prioritize utilization\n    empty_penalty_weight = 0.5 + item_size_ratio * 0.2 # Increase importance for larger items\n    \n    # Combine factors with weights\n    priorities[valid_bins] = (\n        density_weight * packing_density +\n        tight_fit_weight * tight_fit_bonus -\n        empty_penalty_weight * empty_penalty\n    )\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness after packing and remaining space.\"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 1e-6))\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. How full the bin would become (packing density).\n    2. A \"tight fit\" bonus, preferring bins where the remaining space is small but non-zero.\n    3. A penalty for bins that would become too empty.\n    4. Adaptive parameter adjustments based on item size relative to bin size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # Only calculate scores for valid bins\n    valid_capacities = bins_remain_cap[valid_bins]\n    valid_new_capacities = new_capacities[valid_bins]\n\n    # Calculate packing density (higher is better)\n    packing_density = item / valid_capacities\n\n    # Tight fit bonus (remaining space is small, higher is better)\n    # Avoid division by zero by adding a small constant\n    tight_fit_bonus = 1 / (valid_new_capacities + 0.000001)\n\n    # Penalty for bins that become too empty (lower is better)\n    empty_penalty = (valid_new_capacities / np.max(bins_remain_cap))  # Normalize to bin size\n\n    # Adaptive parameter adjustments based on item size\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    # Adjust weights based on item size ratio\n    density_weight = 1.0 + item_size_ratio * 0.5  # Increase importance for larger items\n    tight_fit_weight = 1.0 - item_size_ratio * 0.3  # Decrease importance for larger items, prioritize utilization\n    empty_penalty_weight = 0.5 + item_size_ratio * 0.2 # Increase importance for larger items\n    \n    # Combine factors with weights\n    priorities[valid_bins] = (\n        density_weight * packing_density +\n        tight_fit_weight * tight_fit_bonus -\n        empty_penalty_weight * empty_penalty\n    )\n\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -np.inf, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"Assigns priority to bins based on fullness and remaining space.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                nearly_full_threshold: float = 1.4702982996529879,\n                nearly_full_penalty_value: float = 0.00027356739540163044,\n                fill_ratio_weight: float = 0.8222736095723572,\n                remaining_space_penalty_weight: float = 0.2863616697247634,\n                capacity_utilization_weight: float = 0.6326955372343582,\n                best_fit_score_weight: float = 0.6275805799509675,\n                remaining_space_epsilon: float = 7.830513505271675e-05,\n                best_fit_exponent: float = 14.392442476340706) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, \n                nearly_full_threshold: float = 1.4702982996529879,\n                nearly_full_penalty_value: float = 0.00027356739540163044,\n                fill_ratio_weight: float = 0.8222736095723572,\n                remaining_space_penalty_weight: float = 0.2863616697247634,\n                capacity_utilization_weight: float = 0.6326955372343582,\n                best_fit_score_weight: float = 0.6275805799509675,\n                remaining_space_epsilon: float = 7.830513505271675e-05,\n                best_fit_exponent: float = 14.392442476340706) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}