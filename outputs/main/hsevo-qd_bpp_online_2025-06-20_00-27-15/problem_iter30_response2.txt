```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item.
    new_capacities = bins_remain_cap - item

    # Identify bins that can accommodate the item.
    valid_bins = new_capacities >= 0

    # Initialize priorities with a very low value for invalid bins.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # If no bin can accommodate the item, return the default low priority.
    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0  # Valid bins get a base priority of 0

    remaining_space = bins_remain_cap[valid_bins] - item
    
    # 1. Fill ratio: Prioritize bins that will be filled more completely.
    fill_ratio = item / bins_remain_cap[valid_bins]

    # 2. Remaining space penalty: Discourage leaving too much space.  Adjusted scaling.
    remaining_space_penalty = 1 / (remaining_space + 0.000001) 

    # 3. Capacity utilization: Encourage higher utilization.
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap.max()

    # 4. Space balance: Target more even fill levels across bins, but make it adaptive.
    mean_remaining = np.mean(bins_remain_cap)
    space_balance_diff = np.abs(remaining_space - (mean_remaining - item))
    space_balance_penalty = np.exp(-space_balance_diff / (0.1 * bins_remain_cap.max())) * 0.2 # Gaussian penalty near mean

    # 5. Adaptive weight based on item size.  More aggressive penalties.
    item_size_ratio = item / bins_remain_cap.max()
    adaptive_weight = 1.0
    if item_size_ratio > 0.7:
        adaptive_weight = 1.5  # Strongly penalize nearly full bins
    elif item_size_ratio < 0.2:
        adaptive_weight = 0.7 # Less picky for very small items
    
    # 6. Bin Diversity Penalty: Encourage bins with different fill levels
    capacity_std = np.std(bins_remain_cap)
    if capacity_std > 0:
        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)
        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1) * 0.2 #Reduce weight for diversity penalty
    else:
        capacity_diversity_penalty = 0

    # 7. Bin-level fill target: Encourage filling to a target level. Use remaining capacity.
    bin_fill_target = 0.8 #Target fill level of 80%. Changed from 75
    fill_target_diff = np.abs((bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - (1 - bin_fill_target))
    fill_target_penalty = np.exp(-fill_target_diff / 0.1) * 0.3 #Gaussian penalty near fill target

    # 8. Penalty for nearly full bins: Stronger penalty.
    almost_full_threshold = 0.9
    almost_full_penalty = np.where((bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() < (1 - almost_full_threshold), -0.5, 0) #Increased magnitude

    # 9. Introduce bonus for filling empty bins
    empty_bin_bonus = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.3, 0) #Bonus for filling empty bins
    
    # Combine factors with adjusted weights:
    priorities[valid_bins] = (adaptive_weight * fill_ratio +
                               0.7 * remaining_space_penalty + #Reduced weight of remaining space penalty
                               capacity_utilization +
                               space_balance_penalty +
                               0.1 * capacity_diversity_penalty +
                               fill_target_penalty +
                               almost_full_penalty +
                               empty_bin_bonus)
    return priorities
```
