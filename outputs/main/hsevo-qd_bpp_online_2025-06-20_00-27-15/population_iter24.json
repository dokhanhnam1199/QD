[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 0.000001))\n\n    return priorities",
    "response_id": 28,
    "tryHS": true,
    "obj": 4.038691663342641,
    "SLOC": 13.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 114.20025299224778,
    "mi": 66.45210158779007,
    "token_count": 170.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response3.txt_stdout.txt",
    "code_path": "problem_iter2_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins based on fullness after packing and remaining space.\"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + 1e-6))\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 95.90827503317318,
    "mi": 84.72819187848067,
    "token_count": 96.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response2.txt_stdout.txt",
    "code_path": "problem_iter3_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    # Prioritize bins with remaining capacity close to item size (Best Fit)\n    # and also factor in fullness (item/bin_capacity). Add a small constant for stability.\n    \n    priorities[valid_bins] = (1 / (np.abs(remaining_space) + 0.000001)) + (item / bins_remain_cap[valid_bins])\n\n    # Add a bonus for bins that are relatively empty, encouraging better space utilization\n    # The emptier the bin, the higher the bonus.  This helps avoid creating too many almost-empty bins.\n    empty_bin_bonus = (1 / (bins_remain_cap + 0.000001)) * 0.1  # Scale down the bonus\n\n    priorities = priorities + empty_bin_bonus # Add the bonus to all bins, but invalid bins remain with -inf\n    \n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 166.4210625757214,
    "mi": 70.73171345752299,
    "token_count": 146.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter19_response0.txt_stdout.txt",
    "code_path": "problem_iter19_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -9.387025694128482, epsilon: float = 1.8518136137948416e-05) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority for bins that cannot accommodate the item.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.038691663342641,
    "SLOC": 8.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 84.0,
    "mi": 74.33633396121473,
    "token_count": 119.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter5_response0.txt_stdout.txt",
    "code_path": "problem_iter5_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, invalid_priority: float = -np.inf, epsilon: float = 1e-6) -> np.ndarray:\n    \"\"\"Assigns priority to bins based on fullness and remaining space.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0\n\n    if np.any(valid_bins):\n        remaining_space = bins_remain_cap[valid_bins] - item\n        priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.038691663342641,
    "SLOC": 10.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 160.4736875252405,
    "mi": 85.08702249349118,
    "token_count": 127.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter6_response2.txt_stdout.txt",
    "code_path": "problem_iter6_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. How full the bin would become (packing density).\n    2. A \"tight fit\" bonus, preferring bins where the remaining space is small but non-zero.\n    3. A penalty for bins that would become too empty.\n    4. Adaptive parameter adjustments based on item size relative to bin size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # Only calculate scores for valid bins\n    valid_capacities = bins_remain_cap[valid_bins]\n    valid_new_capacities = new_capacities[valid_bins]\n\n    # Calculate packing density (higher is better)\n    packing_density = item / valid_capacities\n\n    # Tight fit bonus (remaining space is small, higher is better)\n    # Avoid division by zero by adding a small constant\n    tight_fit_bonus = 1 / (valid_new_capacities + 0.000001)\n\n    # Penalty for bins that become too empty (lower is better)\n    empty_penalty = (valid_new_capacities / np.max(bins_remain_cap))  # Normalize to bin size\n\n    # Adaptive parameter adjustments based on item size\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    # Adjust weights based on item size ratio\n    density_weight = 1.0 + item_size_ratio * 0.5  # Increase importance for larger items\n    tight_fit_weight = 1.0 - item_size_ratio * 0.3  # Decrease importance for larger items, prioritize utilization\n    empty_penalty_weight = 0.5 + item_size_ratio * 0.2 # Increase importance for larger items\n    \n    # Combine factors with weights\n    priorities[valid_bins] = (\n        density_weight * packing_density +\n        tight_fit_weight * tight_fit_bonus -\n        empty_penalty_weight * empty_penalty\n    )\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.038691663342641,
    "SLOC": 15.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 166.4210625757214,
    "mi": 80.42758909917298,
    "token_count": 160.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter9_response1.txt_stdout.txt",
    "code_path": "problem_iter9_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 184.60327781484776,
    "mi": 74.24232436042227,
    "token_count": 155.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter11_response4.txt_stdout.txt",
    "code_path": "problem_iter11_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Calculate bin priorities considering fill ratio, remaining space, and a space balance.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item / 2, 0.5, 0.1)\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 14.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 210.99629561116632,
    "mi": 57.80117879641227,
    "token_count": 151.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter12_response0.txt_stdout.txt",
    "code_path": "problem_iter12_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1) #Reduced weighting\n\n    #5. Introduce item size weighting. Larger items should be packed first.\n    item_size_weight = item\n\n    # Combine the factors to create the priority score.\n    # Reduced the weightage to space_balance\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 21.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 349.403623592787,
    "mi": 77.29696456753466,
    "token_count": 290.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter14_response1.txt_stdout.txt",
    "code_path": "problem_iter14_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Assigns priority to bins based on fill ratio, remaining space, item size.\n    Prioritizes bins that fit the item well and balances space utilization.\n    \"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item / 2, 0.3, 0.1)\n    item_size_weight = item\n\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities",
    "response_id": 1,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 249.28567922126666,
    "mi": 76.75472715602044,
    "token_count": 183.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter15_response0.txt_stdout.txt",
    "code_path": "problem_iter15_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n\n    #5. Item size relative to the average remaining bin capacity\n    avg_remaining_capacity = np.mean(bins_remain_cap)\n    item_size_vs_avg_capacity = item / (avg_remaining_capacity + 0.000001)\n\n    #6. Penalize bins that are too empty compared to item size. If remaining capacity is much bigger than item.\n    empty_bin_penalty = np.where(bins_remain_cap[valid_bins] > 2*item, -0.1, 0)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + empty_bin_penalty - item_size_vs_avg_capacity * 0.05\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.01874750698045,
    "SLOC": 28.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 421.10323830864064,
    "mi": 78.73837628011665,
    "token_count": 278.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter17_response0.txt_stdout.txt",
    "code_path": "problem_iter17_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins for an item, balancing fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n    item_size_weight = item\n\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 3.9688871160749857,
    "SLOC": 17.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 355.89294990339823,
    "mi": 54.48415298824115,
    "token_count": 199.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter18_response2.txt_stdout.txt",
    "code_path": "problem_iter18_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n\n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n\n    # 4. Introduce a \"best fit\" component: prioritize bins where the remaining space is small but non-zero.\n    best_fit_score = np.exp(-10 * remaining_space / bins_remain_cap[valid_bins])  # Exponential decay\n\n    # 5. Introduce a penalty for bins that are already nearly full\n    nearly_full_penalty = np.where(bins_remain_cap[valid_bins] < 2 * item, 0.2, 0.0)\n\n    # Combine the factors to create the priority score, adjusting weights.\n    priorities[valid_bins] = (\n        0.3 * fill_ratio +\n        0.2 * remaining_space_penalty +\n        0.3 * capacity_utilization +\n        0.2 * best_fit_score -\n        nearly_full_penalty  # Subtract the penalty\n    )\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.198244914240141,
    "SLOC": 40.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 404.259108776295,
    "mi": 76.75051606155583,
    "token_count": 316.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter20_response3.txt_stdout.txt",
    "code_path": "problem_iter20_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins using fill ratio, remaining space penalty, and space balance.\"\"\"\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 23.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 402.1173000519233,
    "mi": 54.65431337584345,
    "token_count": 200.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter21_response2.txt_stdout.txt",
    "code_path": "problem_iter21_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 3.948942959712818,
    "SLOC": 25.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 424.4571500548079,
    "mi": 77.860035789445,
    "token_count": 287.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter22_response0.txt_stdout.txt",
    "code_path": "problem_iter22_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 1.383352297928545,\n                remaining_space_penalty_weight: float = 1.5591283372979048, capacity_utilization_weight: float = 0.49252209073339603,\n                space_balance_threshold: float = 0.5764856540655822, space_balance_high: float = 0.4420637087883818,\n                space_balance_low: float = 0.1394491911814592, remaining_space_epsilon: float = 2.4457024732011557e-05,\n                item_size_weight_value: float = 0.9370963396346099) -> np.ndarray:\n    \"\"\"Prioritizes bins for an item, balancing fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities",
    "response_id": 0,
    "tryHS": true,
    "obj": 4.487435181491823,
    "SLOC": 10.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 33.219280948873624,
    "mi": 70.64326152012914,
    "token_count": 119.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter23_response3.txt_stdout.txt",
    "code_path": "problem_iter23_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines fill ratio, remaining space penalty, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n    remaining_space = bins_remain_cap[valid_bins] - item\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1)\n    item_size_weight = item\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.9688871160749857,
    "SLOC": 15.0,
    "cyclomatic_complexity": 2.0,
    "halstead": 266.72271688113824,
    "mi": 56.477060089230356,
    "token_count": 171.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter24_response3.txt_stdout.txt",
    "code_path": "problem_iter24_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance:\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities.\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 3.470283207020339,
    "SLOC": 32.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 486.87323863787196,
    "mi": 74.71872521613327,
    "token_count": 318.0,
    "exec_success": true
  }
]