```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates adaptive weighting and focuses on balancing bin utilization
    while penalizing fragmentation. It also dynamically adjusts its behavior based on
    item size relative to average bin capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item.
    new_capacities = bins_remain_cap - item

    # Identify bins that can accommodate the item.
    valid_bins = new_capacities >= 0

    # Initialize priorities with a very low value for invalid bins.
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # No valid bins, return default priorities.
    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0  # Base priority for valid bins

    # Calculate remaining space after packing for valid bins
    remaining_space = bins_remain_cap[valid_bins] - item

    # 1. Fill ratio: How much of the bin's capacity is used by the item.
    fill_ratio = item / bins_remain_cap[valid_bins]

    # 2. Remaining space penalty: Higher penalty for leaving too little or too much space.
    #    Uses a quadratic penalty to discourage both near-full and near-empty bins.
    avg_bin_capacity = np.mean(bins_remain_cap)
    space_diff = remaining_space - (avg_bin_capacity / 2)  # Target remaining space around half the average bin size
    remaining_space_penalty = - (space_diff ** 2) / (avg_bin_capacity ** 2 + 0.000001)  # Normalized quadratic penalty. Negative because we *want* higher priority with smaller penalty.
    remaining_space_penalty = np.clip(remaining_space_penalty, -1, 0) #Bound it

    # 3. Capacity utilization: Higher remaining capacity utilization
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]

    # 4. Adaptive weighting based on item size
    item_size_ratio = item / avg_bin_capacity
    adaptive_weight_fill = 1.0
    adaptive_weight_space = 1.0

    if item_size_ratio > 0.7:
        adaptive_weight_fill = 1.3  # Emphasize fill ratio for large items
        adaptive_weight_space = 0.7 # De-emphasize space penalty
    elif item_size_ratio < 0.3:
        adaptive_weight_fill = 0.8  # De-emphasize fill ratio for small items
        adaptive_weight_space = 1.2 # Emphasize space penalty to avoid overfilling a single bin.

    # 5. Encourage filling bins close to full, but not perfectly
    near_full_bonus = np.exp(-((bins_remain_cap[valid_bins] - item) / (0.1 * avg_bin_capacity))**2)
    near_full_bonus = np.clip(near_full_bonus, 0, 1) #Bounds

    # Combine the factors to create the priority score
    priorities[valid_bins] = (
        adaptive_weight_fill * fill_ratio +
        adaptive_weight_space * remaining_space_penalty +
        capacity_utilization +
        0.5 * near_full_bonus #Scale bonus down.
    )

    return priorities
```
