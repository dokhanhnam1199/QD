import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 1.9854832149562402,
                remaining_space_penalty_weight: float = 1.8310488454462364, capacity_utilization_weight: float = 0.5896665016466722,
                space_balance_threshold: float = 0.06575142228422781, space_balance_high: float = 0.04401499429514938,
                space_balance_low: float = 0.15822203850904193, remaining_space_epsilon: float = 4.656574146803257e-05,
                item_size_weight_value: float = 0.03916594730223322) -> np.ndarray:
    """Prioritizes bins for an item, balancing fill ratio, remaining space, and item size."""

    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0
    remaining_space = bins_remain_cap[valid_bins] - item
    fill_ratio = item / bins_remain_cap[valid_bins]
    remaining_space_penalty = 1 / (remaining_space + remaining_space_epsilon)
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]
    space_balance = np.where(remaining_space > item * space_balance_threshold, space_balance_high, space_balance_low)
    item_size_weight = item * item_size_weight_value

    priorities[valid_bins] = (fill_ratio * fill_ratio_weight +
                               remaining_space_penalty * remaining_space_penalty_weight +
                               capacity_utilization * capacity_utilization_weight +
                               space_balance + item_size_weight)
    return priorities
