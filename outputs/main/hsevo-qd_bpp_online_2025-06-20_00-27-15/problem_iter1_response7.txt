```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Inspired by the many-worlds interpretation, consider multiple packing possibilities.
    A good heuristic is to prioritize bins where the item fits relatively well and leaves minimal wasted space.
    However, we must also account for the case where the item almost doesn't fit but does - this suggests a good placement.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    valid_bins = bins_remain_cap >= item
    if np.any(valid_bins):
        # Prioritize based on fill ratio *within the valid bins*
        fill_ratios = item / bins_remain_cap[valid_bins]
        priorities[valid_bins] = fill_ratios  # Higher ratio is better
        # Small adjustment to prioritize bins that *just* fit. Consider that near misses are valuable
        just_fit_threshold = 0.95 # can also explore a range
        just_fit_bins = (fill_ratios > just_fit_threshold)
        priorities[valid_bins][just_fit_bins] += 0.5  # Give a small boost if its a close fit
        remaining_space = bins_remain_cap[valid_bins] - item
        #Minimize the fragmentation
        priorities[valid_bins] += 1/(remaining_space+0.00001) # Add priority.

    else:
       # All the bins are useless. Should never arrive at this point.
       return bins_remain_cap - 100*item  # Very Low priority, but still there

    return priorities
```
