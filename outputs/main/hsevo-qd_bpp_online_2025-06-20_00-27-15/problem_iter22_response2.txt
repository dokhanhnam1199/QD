import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 0.06429870772393276,
                remaining_space_penalty_weight: float = 1.6620265251838022, capacity_utilization_weight: float = 0.9402082470179216,
                space_balance_threshold: float = 0.812643205455248, space_balance_high: float = 0.10669816873935267,
                space_balance_low: float = 0.13269760655024482, remaining_space_epsilon: float = 1.6164370069868965e-05,
                item_size_weight_value: float = 1.598402891372113) -> np.ndarray:
    """Prioritizes bins for an item, balancing fill ratio, remaining space, and item size."""

    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0
    remaining_space = bins_remain_cap[valid_bins] - item
    fill_ratio = item / bins_remain_cap[valid_bins]
    remaining_space_penalty = 1 / (remaining_space + remaining_space_epsilon)
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]
    space_balance = np.where(remaining_space > item * space_balance_threshold, space_balance_high, space_balance_low)
    item_size_weight = item * item_size_weight_value

    priorities[valid_bins] = (fill_ratio * fill_ratio_weight +
                               remaining_space_penalty * remaining_space_penalty_weight +
                               capacity_utilization * capacity_utilization_weight +
                               space_balance + item_size_weight)
    return priorities
