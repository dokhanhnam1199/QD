{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1) #Reduced weighting\n\n    #5. Introduce item size weighting. Larger items should be packed first.\n    item_size_weight = item\n\n    # Combine the factors to create the priority score.\n    # Reduced the weightage to space_balance\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority for bins that cannot accommodate the item.\n        epsilon: Small value to avoid division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the 1st one includes `item_size_weight` while the 20th does not; (2nd best) vs (second worst) ...; Comparing (1st) vs (2nd), we see the weight of `space_balance` reduced; (3rd) vs (4th) ..., there are no differences; Comparing (second worst) vs (worst), there are no differences; Overall: The better heuristics consider the item size and dynamically adjust weights of different factors based on the item size relative to the bin capacities. The worst heuristics often lack a mechanism to prioritize larger items or to penalize bins that become too empty. They also do not effectively adjust the weights of different factors based on item size or bin capacity.\n- \nOkay, let's refine \"Current self-reflection\" to design better heuristics, specifically targeting the pitfalls of \"Ineffective self-reflection.\"\n\nHere's a redefined and more actionable approach:\n\n*   **Keywords:** Factor prioritization, dynamic adaptation, edge case robustness, concise implementation, performance validation.\n\n*   **Advice:** Start with relevant factors, meticulously validate their impact, prioritize them adaptively based on problem characteristics, and explicitly handle edge cases with concise code.\n\n*   **Avoid:** Oversimplification, unjustified complexity/parameters, neglecting performance validation, and static, inflexible approaches.\n\n*   **Explanation:** Focus on a data-driven, adaptive approach. Prioritize rigorous validation of each component and avoid introducing complexity without demonstrable performance improvement.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}