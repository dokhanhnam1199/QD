```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that have enough space for the item
    but penalizes bins that are either too full (little remaining capacity)
    or excessively empty after the item is placed. It aims to balance
    packing efficiently while avoiding fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Give a large negative priority to bins that cannot fit the item
    infeasible = bins_remain_cap < item
    priorities[infeasible] = -np.inf

    # For feasible bins, calculate remaining capacity after adding the item
    remaining_after = bins_remain_cap - item
    feasible = ~infeasible #reusing existing variable

    # Give a boost to bins where the remaining capacity is a moderate value
    # This encourages filling bins reasonably well
    priorities[feasible] = (item / bins_remain_cap[feasible])  # Favor closer fit initially

    # Penalize very small remaining capacity - to prevent overfilling
    small_remaining = remaining_after < 0.1 #tune the threshold
    priorities[feasible] -= small_remaining[feasible] * 5  # Large penalty if almost full

    # Penalize large remaining capacity - to prevent fragmentation, but not too strongly
    large_remaining = remaining_after > 0.5 #tune the threshold
    priorities[feasible] -= large_remaining[feasible] * 0.1 # Smaller penalty if significantly empty


    return priorities
```
