```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with remaining capacity close to the item size
    and also considers the overall fill level of the bin.  It also adaptively
    adjusts the weight given to these two factors based on the item size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0

    remaining_space = bins_remain_cap[valid_bins] - item

    # Factor 1:  How well the item fits (lower remaining space is better)
    fit_score = 1 / (remaining_space + 0.000001)

    # Factor 2:  Fill level of the bin (higher fill is better, but penalize almost full)
    fill_level = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]
    fill_score = fill_level

    # Factor 3: Proximity to item size
    proximity_score = np.exp(-np.abs(bins_remain_cap[valid_bins] - item) / item)

    # Adaptive weighting:  If the item is large, prioritize fit. If small, prioritize fill.
    item_size_factor = min(1.0, item)  # Scale between 0 and 1

    # Combine the factors, with adaptive weights
    priorities[valid_bins] = (item_size_factor * fit_score +
                               (1 - item_size_factor) * fill_score +
                               0.5 * proximity_score)

    return priorities
```
