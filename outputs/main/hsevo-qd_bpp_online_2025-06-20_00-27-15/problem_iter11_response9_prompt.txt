{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins based on a combination of factors:\n    1. How full the bin would become (packing density).\n    2. A \"tight fit\" bonus, preferring bins where the remaining space is small but non-zero.\n    3. A penalty for bins that would become too empty.\n    4. Adaptive parameter adjustments based on item size relative to bin size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # Only calculate scores for valid bins\n    valid_capacities = bins_remain_cap[valid_bins]\n    valid_new_capacities = new_capacities[valid_bins]\n\n    # Calculate packing density (higher is better)\n    packing_density = item / valid_capacities\n\n    # Tight fit bonus (remaining space is small, higher is better)\n    # Avoid division by zero by adding a small constant\n    tight_fit_bonus = 1 / (valid_new_capacities + 0.000001)\n\n    # Penalty for bins that become too empty (lower is better)\n    empty_penalty = (valid_new_capacities / np.max(bins_remain_cap))  # Normalize to bin size\n\n    # Adaptive parameter adjustments based on item size\n    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size\n\n    # Adjust weights based on item size ratio\n    density_weight = 1.0 + item_size_ratio * 0.5  # Increase importance for larger items\n    tight_fit_weight = 1.0 - item_size_ratio * 0.3  # Decrease importance for larger items, prioritize utilization\n    empty_penalty_weight = 0.5 + item_size_ratio * 0.2 # Increase importance for larger items\n    \n    # Combine factors with weights\n    priorities[valid_bins] = (\n        density_weight * packing_density +\n        tight_fit_weight * tight_fit_bonus -\n        empty_penalty_weight * empty_penalty\n    )\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the 1st one considers remaining space, fill ratio, capacity utilization, and space balance, while the 20th only considers log ratios of item size to bin capacity. This suggests a more comprehensive evaluation of bin suitability leads to better performance.\n\n(2nd) vs (19th) and (3rd) vs (18th) show a similar pattern. The initial versions incorporate multiple factors, while the later versions rely solely on the log ratio of item size to bin capacity. The more nuanced approach is superior.\n\nComparing (4th) vs (17th) and onward, we see the introduction of `invalid_priority` and `epsilon` parameters. Although these parameters are intended to improve robustness (handling edge cases), their inclusion does not demonstrably improve the overall heuristic and can even make it worse if not properly tuned. The simpler approach of handling invalid bins directly with `-np.inf` seems more effective.\n\nComparing (1st) vs (4th), the former considers capacity utilization and a space balance term, while the latter uses a simpler formula with only fill ratio and remaining space penalty. The added complexity in the first heuristic seems beneficial.\n\nComparing (1st) vs (7th), both have very similar structures, but the first has more features\n\nComparing (16th) vs (17th), almost the same.\n\nOverall: Heuristics that consider multiple factors related to bin capacity, item size, and remaining space tend to perform better. Overly simplistic approaches (e.g., relying solely on log ratios) and the addition of untuned parameters (`invalid_priority`, `epsilon`) generally lead to worse results. A balance between comprehensive evaluation and simplicity is crucial, prioritizing meaningful factors without adding unnecessary complexity. The use of a well-defined invalid priority value (`-np.inf`) is superior to introducing tunable parameters for the same purpose.\n- \nHere's a refined take on \"Current self-reflection\" aimed at designing better heuristics, avoiding pitfalls:\n\n*   **Keywords:** Factor validation, adaptive parameters, edge case handling, conciseness.\n\n*   **Advice:** Rigorously validate factors and parameters, adapt parameters based on input characteristics, explicitly address edge cases, and strive for concise code.\n\n*   **Avoid:** Unjustified complexity, premature optimization, neglecting edge cases, opaque or difficult-to-maintain code.\n\n*   **Explanation:** Focus on evidence-based inclusion of factors, adapting to problem instances, and prioritizing clarity and robustness alongside performance. Avoid complexity that is not justified by empirical evidence.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}