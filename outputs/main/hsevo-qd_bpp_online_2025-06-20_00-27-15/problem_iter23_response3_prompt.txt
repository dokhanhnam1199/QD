{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.3, 0.1) #Reduced weighting\n\n    #5. Introduce item size weighting. Larger items should be packed first.\n    item_size_weight = item\n\n    # Combine the factors to create the priority score.\n    # Reduced the weightage to space_balance\n    priorities[valid_bins] = fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + item_size_weight\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                remaining_space_penalty_weight: float = 1.5591283372979048, capacity_utilization_weight: float = 0.49252209073339603,\n                space_balance_threshold: float = 0.5764856540655822, space_balance_high: float = 0.4420637087883818,\n                space_balance_low: float = 0.1394491911814592, remaining_space_epsilon: float = 2.4457024732011557e-05,\n                item_size_weight_value: float = 0.9370963396346099) -> np.ndarray:\n    \"\"\"Prioritizes bins for an item, balancing fill ratio, remaining space, and item size.\"\"\"\n\n    new_capacities = bins_remain_cap - item\n    valid_bins = new_capacities >= 0\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    if not np.any(valid_bins):\n        return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see a significant difference in complexity and the addition of numerous parameters in the 1st compared to the 20th. The 1st heuristic uses adaptive weights based on item size, a space balance strategy, and considers fill ratio, remaining space penalty, and capacity utilization. In contrast, the 20th heuristic only initializes `priorities` array and returns if no valid bins. This indicates that the 1st heuristic attempts a more nuanced and potentially more effective approach to bin packing.\n\nComparing (2nd best) vs (second worst), we see that the 2nd heuristic incorporates item size weighting directly into the priority calculation, while the second worst heuristic initializes `priorities` array and returns if no valid bins. The space balance weighting is reduced in the 2nd best.\n\nComparing (1st) vs (2nd), the 1st heuristic uses adaptive weights based on item size relative to bin sizes, adjusting the fill ratio weight. The 2nd heuristic uses a fixed item size weight.\n\nComparing (3rd) vs (4th), both heuristics are identical, indicating a possible tie in their performance or a lack of differentiation in the evaluation.\n\nComparing (second worst) vs (worst), both heuristics are same.\n\nOverall: The better heuristics incorporate multiple factors such as fill ratio, remaining space, capacity utilization, and space balance. They also use adaptive weighting mechanisms to adjust the influence of these factors based on item size or other relevant parameters. The worst heuristics are often simplified versions that only consider basic fill ratio and remaining space, or even fail to implement a scoring mechanism if no valid bins are found. The more sophisticated heuristics introduce adaptive elements and penalties to better guide the packing process.\n- \nOkay, let's redefine \"Current Self-Reflection\" to design better heuristics, actively avoiding the pitfalls of \"Ineffective Self-Reflection\". Here's a breakdown:\n\n*   **Keywords:** Multifaceted, Adaptive, Parameter Tuning, Iterative Refinement.\n\n*   **Advice:** Focus on combining *multiple interacting* factors, using adaptive parameter tuning *driven by data analysis and feedback* from performance on diverse datasets.\n\n*   **Avoid:** Oversimplification, premature complexity, and parameters without justification/validation.\n\n*   **Explanation:** Move beyond simply listing factors. Prioritize understanding their interplay and using data-driven adaptive mechanisms to improve performance via an iterative build-measure-analyze-refine approach.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}