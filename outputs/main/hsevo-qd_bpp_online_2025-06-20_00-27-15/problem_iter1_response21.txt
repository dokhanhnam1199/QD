```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version attempts to balance bin utilization and avoid large unused space.
    It prioritizes bins where the item fits reasonably well, but not perfectly,
    to reduce fragmentation. We also introduce a small random component to
    encourage exploration and avoid getting stuck in local optima.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # 1. Feasibility check and baseline priority. Infeasible bins get -inf priority.
    feasible_bins = bins_remain_cap >= item
    priorities[~feasible_bins] = -np.inf
    
    # 2. Utilization-based priority for feasible bins: higher remaining capacity and good fit gets higher priority.
    # Good Fit criteria can be specified based on the domain knowledge. For now, the utilization is between 75% and 95%
    utilization = item / bins_remain_cap[feasible_bins]
    good_fit = (utilization >= 0.75) & (utilization <= 0.95)
    priorities[feasible_bins] = bins_remain_cap[feasible_bins] * (1 + 0.5 * good_fit)

    # 3. Avoid near-perfect fits: penalize bins where the item nearly fills them.
    near_perfect_fit = (utilization > 0.95) & (utilization <=1.0)
    priorities[feasible_bins][near_perfect_fit] -=  0.2 * bins_remain_cap[feasible_bins][near_perfect_fit]


    # 4. Add a small random component for exploration (helps avoid local optima).
    priorities[feasible_bins] += 0.01 * np.random.rand(np.sum(feasible_bins))

    return priorities
```
