```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Inspired by the dance of electricity and resonance, this priority function seeks the perfect harmonic match
    between the item's size and the bin's remaining capacity. It combines aspects of First Fit Decreasing
    and Best Fit, encouraging efficient bin utilization while discouraging excessive fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate remaining space after potential placement. Negative values indicate infeasibility.
    remaining_space = bins_remain_cap - item

    # Reward bins where the item fits (positive remaining space)
    feasible_bins = remaining_space >= 0
    if np.any(feasible_bins):
        # Prioritize bins where the remaining space after packing is small, but not zero.  This approximates Best Fit.
        priorities[feasible_bins] = 1.0 / (remaining_space[feasible_bins] + 1e-6) # Avoid divide by zero
    else:
        # If no bin fits, prioritize bins where item almost fit. Minimize waste (item - bin_cap)
        priorities = -np.abs(remaining_space) #negative because priority becomes value

    #Boost bins with higher remaining capacity so smaller items do not hog almost full bins
    priorities += bins_remain_cap * 0.01
        
    return priorities
```
