```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins with remaining capacity close to the item size
    while also considering the overall fullness of the bin.  It also adds a penalty
    for bins that would become too empty after packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)
    priorities[valid_bins] = 0

    valid_indices = np.where(valid_bins)[0] # Get indices of valid bins

    if len(valid_indices) > 0:
        remaining_space = bins_remain_cap[valid_bins] - item
        
        # Priority based on how well the item fits (smaller remaining space is better)
        fit_priority = 1 / (remaining_space + 0.000001)  # Avoid division by zero
        
        # Priority based on the fullness of the bin *before* adding the item
        fullness_priority = bins_remain_cap[valid_bins] / np.max(bins_remain_cap) # Normalize by maximum capacity

        # Penalty for bins that become too empty *after* adding the item.
        empty_penalty = np.where(new_capacities[valid_bins] > 0.7 * np.max(bins_remain_cap), -0.5, 0)

        priorities[valid_bins] = fit_priority + fullness_priority + empty_penalty

    return priorities
```
