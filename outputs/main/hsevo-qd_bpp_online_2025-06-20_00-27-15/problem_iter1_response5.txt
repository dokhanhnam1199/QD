```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space.
    It combines factors to balance fitting items snugly while avoiding excessive fragmentation.
    Also includes a small random element to escape local optima.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a very low value
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can accommodate the item
    valid_bins = bins_remain_cap >= item

    if np.any(valid_bins):
        # Calculate wasted space for valid bins
        wasted_space = bins_remain_cap[valid_bins] - item

        # Normalize wasted space to be between 0 and 1 (lower is better)
        normalized_wasted_space = wasted_space / bins_remain_cap[valid_bins]

        # Calculate how "full" the bin would be (higher is better)
        fullness = 1 - normalized_wasted_space

        # Avoid ZeroDivisionError and ensure valid logs
        fullness = np.clip(fullness, 1e-9, 1 - 1e-9)

        # Priority score: Higher fullness is better, penalized by wasted space.
        # A log transform is used to dampen the effect of very large wasted spaces.
        # This encourages the algorithm to prefer bins where the item fits well,
        # without excessively penalizing bins with slightly more wasted space.
        priorities[valid_bins] = fullness - 0.1 * np.log(wasted_space + 1)

        # Add a small random element to each priority to encourage exploration.
        # This can help the algorithm escape local optima.
        priorities[valid_bins] += np.random.rand(np.sum(valid_bins)) * 0.01

    return priorities
```
