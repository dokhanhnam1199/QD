```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins based on a combination of factors:
    1. How full the bin would become (packing density).
    2. A "tight fit" bonus, preferring bins where the remaining space is small but non-zero.
    3. A penalty for bins that would become too empty.
    4. Adaptive parameter adjustments based on item size relative to bin size.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate remaining capacity after adding the item.
    new_capacities = bins_remain_cap - item

    # Identify bins that can accommodate the item.
    valid_bins = new_capacities >= 0

    # Initialize priorities with a very low value for invalid bins.
    priorities = np.full_like(bins_remain_cap, -np.inf)
    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.

    # Only calculate scores for valid bins
    valid_capacities = bins_remain_cap[valid_bins]
    valid_new_capacities = new_capacities[valid_bins]

    # Calculate packing density (higher is better)
    packing_density = item / valid_capacities

    # Tight fit bonus (remaining space is small, higher is better)
    # Avoid division by zero by adding a small constant
    tight_fit_bonus = 1 / (valid_new_capacities + 0.000001)

    # Penalty for bins that become too empty (lower is better)
    empty_penalty = (valid_new_capacities / np.max(bins_remain_cap))  # Normalize to bin size

    # Adaptive parameter adjustments based on item size
    item_size_ratio = item / np.max(bins_remain_cap) # Normalize item size

    # Adjust weights based on item size ratio
    density_weight = 1.0 + item_size_ratio * 0.5  # Increase importance for larger items
    tight_fit_weight = 1.0 - item_size_ratio * 0.3  # Decrease importance for larger items, prioritize utilization
    empty_penalty_weight = 0.5 + item_size_ratio * 0.2 # Increase importance for larger items
    
    # Combine factors with weights
    priorities[valid_bins] = (
        density_weight * packing_density +
        tight_fit_weight * tight_fit_bonus -
        empty_penalty_weight * empty_penalty
    )

    return priorities
```
