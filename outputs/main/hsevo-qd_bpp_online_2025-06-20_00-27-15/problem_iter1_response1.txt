```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Prioritizes bins where the item fits reasonably well,
    but also accounts for filling bins as much as possible to reduce fragmentation.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if item <= cap:
            # Base priority: How much of the bin is filled?
            fill_ratio = item / cap
            priorities[i] = fill_ratio

            # Bonus for tight fits (but not *too* tight to avoid edge cases)
            slack = cap - item
            if slack > 0 and slack <= cap * 0.2: # prefer bins with little slack, but not too little
              priorities[i] += 0.5

            # Penalize excessive slack. A bin with 50% more capacity than needed isn't ideal
            if slack > item: # if slack is larger than item prefer to choose other options
              priorities[i] -= 0.2

            # Encourage more full filling, using idea of square
            priorities[i] = priorities[i] ** 2
    return priorities
```
