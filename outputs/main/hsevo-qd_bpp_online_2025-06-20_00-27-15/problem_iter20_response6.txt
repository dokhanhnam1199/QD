```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines fill ratio, remaining space penalty, and adaptive item size weighting."""
    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    valid_capacities = bins_remain_cap[valid_bins]
    valid_new_capacities = new_capacities[valid_bins]
    fill_ratio = item / valid_capacities
    remaining_space_penalty = 1 / (valid_new_capacities + 0.000001)
    capacity_utilization = (valid_capacities - valid_new_capacities) / valid_capacities
    space_balance = np.where(valid_new_capacities > item/2, 0.3, 0.1)
    avg_remaining_capacity = np.mean(bins_remain_cap)
    item_size_vs_avg_capacity = item / (avg_remaining_capacity + 0.000001)
    empty_bin_penalty = np.where(valid_capacities > 2*item, -0.1, 0)

    item_size_ratio = item / np.max(bins_remain_cap)
    density_weight = 1.0 + item_size_ratio * 0.5
    tight_fit_weight = 1.0 - item_size_ratio * 0.3
    empty_penalty_weight = 0.5 + item_size_ratio * 0.2

    priorities[valid_bins] = (
        density_weight * fill_ratio +
        tight_fit_weight * remaining_space_penalty -
        empty_penalty_weight * (valid_new_capacities / np.max(bins_remain_cap)) + space_balance + empty_bin_penalty - item_size_vs_avg_capacity * 0.05
    )
    return priorities
```
