import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 2.3489221402054485,
                remaining_space_penalty_weight: float = 1.665427097605339, capacity_utilization_weight: float = 1.8861576291904856,
                space_balance_threshold: float = 0.42269959063650164, space_balance_high: float = 0.06503342356819089,
                space_balance_low: float = 0.16048073624851528, remaining_space_epsilon: float = 4.969343802985254e-05,
                item_size_weight_value: float = 0.03916594730223322) -> np.ndarray:
    """Prioritizes bins for an item, balancing fill ratio, remaining space, and item size."""

    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0
    remaining_space = bins_remain_cap[valid_bins] - item
    fill_ratio = item / bins_remain_cap[valid_bins]
    remaining_space_penalty = 1 / (remaining_space + remaining_space_epsilon)
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]
    space_balance = np.where(remaining_space > item * space_balance_threshold, space_balance_high, space_balance_low)
    item_size_weight = item * item_size_weight_value

    priorities[valid_bins] = (fill_ratio * fill_ratio_weight +
                               remaining_space_penalty * remaining_space_penalty_weight +
                               capacity_utilization * capacity_utilization_weight +
                               space_balance + item_size_weight)
    return priorities
