```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can fit the item snugly, avoiding both
    very full and very empty bins. It uses a combination of capacity remaining,
    waste, and a "sweet spot" near the middle of the remaining capacity spectrum.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Penalize bins that are too small or where item is bigger than available
    # Penalize small bins more severely - they represent a great loss of resources
    under_cap_penalty = np.where(bins_remain_cap < item, -100 * (item-bins_remain_cap), 0) # high penalty if under

    # Give small reward for bins exactly fitting the item.

    perfect_fit_bonus = np.where(bins_remain_cap == item, 10, 0)

    # Prioritize bins where the item results in a fill level close to "optimal"
    # I consider "optimal" to be around 70-80 %
    target_fill_level = 0.75
    fill_level_after_addition = (1 - (bins_remain_cap - item) / 1.0) # Assuming bin capacity is 1

    fill_level_penalty = -np.abs(fill_level_after_addition - target_fill_level)

    # Give a very low penalty to almost-empty bins
    almost_empty_penalty = np.where(bins_remain_cap > 0.9, -0.1, 0)

    # Construct the final priority score
    priorities = perfect_fit_bonus + fill_level_penalty + almost_empty_penalty + under_cap_penalty

    # Avoid division by zero by checking for zero cap
    # This needs high negative penalty to ensure no division by zero ever
    priorities = np.where(bins_remain_cap <= 0, -np.inf, priorities)


    return priorities
```
