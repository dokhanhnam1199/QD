import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 0.7866442398014981,
                remaining_space_penalty_weight: float = 0.03068113296674646, capacity_utilization_weight: float = 1.501706675054417,
                space_balance_threshold: float = 0.5764856540655822, space_balance_high: float = 0.12090351279132405,
                space_balance_low: float = 0.1532269985145071, remaining_space_epsilon: float = 3.990833691041079e-05,
                item_size_weight_value: float = 0.7281547156420531) -> np.ndarray:
    """Prioritizes bins for an item, balancing fill ratio, remaining space, and item size."""

    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0
    remaining_space = bins_remain_cap[valid_bins] - item
    fill_ratio = item / bins_remain_cap[valid_bins]
    remaining_space_penalty = 1 / (remaining_space + remaining_space_epsilon)
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]
    space_balance = np.where(remaining_space > item * space_balance_threshold, space_balance_high, space_balance_low)
    item_size_weight = item * item_size_weight_value

    priorities[valid_bins] = (fill_ratio * fill_ratio_weight +
                               remaining_space_penalty * remaining_space_penalty_weight +
                               capacity_utilization * capacity_utilization_weight +
                               space_balance + item_size_weight)
    return priorities
