import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, fill_ratio_weight: float = 0.3812673006449574,
                remaining_space_penalty_weight: float = 0.7072702340054244, capacity_utilization_weight: float = 0.9408594190526756,
                space_balance_threshold: float = 0.812643205455248, space_balance_high: float = 0.348186549660194,
                space_balance_low: float = 0.07709928283738483, remaining_space_epsilon: float = 5.121673644717381e-05,
                item_size_weight_value: float = 0.9370963396346099) -> np.ndarray:
    """Prioritizes bins for an item, balancing fill ratio, remaining space, and item size."""

    new_capacities = bins_remain_cap - item
    valid_bins = new_capacities >= 0
    priorities = np.full_like(bins_remain_cap, -np.inf)

    if not np.any(valid_bins):
        return priorities

    priorities[valid_bins] = 0
    remaining_space = bins_remain_cap[valid_bins] - item
    fill_ratio = item / bins_remain_cap[valid_bins]
    remaining_space_penalty = 1 / (remaining_space + remaining_space_epsilon)
    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]
    space_balance = np.where(remaining_space > item * space_balance_threshold, space_balance_high, space_balance_low)
    item_size_weight = item * item_size_weight_value

    priorities[valid_bins] = (fill_ratio * fill_ratio_weight +
                               remaining_space_penalty * remaining_space_penalty_weight +
                               capacity_utilization * capacity_utilization_weight +
                               space_balance + item_size_weight)
    return priorities
