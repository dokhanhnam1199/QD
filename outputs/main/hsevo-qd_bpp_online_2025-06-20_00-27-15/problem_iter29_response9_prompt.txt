{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    # Calculate remaining space after packing for valid bins\n    remaining_space = bins_remain_cap[valid_bins] - item\n\n    # Scoring valid bins: Introduce a combination of factors.\n    # 1. Fill ratio: How much of the bin's capacity is used by the item.\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    # 2. Remaining space penalty: Prefer bins that leave less unused space.  A smaller remaining_space results in a higher score. Use reciprocal to avoid division by zero.\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n\n    # 3. Capacity utilization: Higher remaining capcity utilization.\n\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Try to balance between full fill and not full fill by giving higher score if remainin space > item/2, else lower.\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n\n    #5. Introduce adaptive weight based on item size relative to bin sizes\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Increase fill_ratio weight for large items\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8  # Decrease fill_ratio weight for smaller items\n    \n\n    # Combine the factors to create the priority score.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance\n    #priorities[valid_bins] = fill_ratio + remaining_space_penalty\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                nearly_full_threshold: float = 1.4702982996529879,\n                nearly_full_penalty_value: float = 0.00027356739540163044,\n                fill_ratio_weight: float = 0.8222736095723572,\n                remaining_space_penalty_weight: float = 0.2863616697247634,\n                capacity_utilization_weight: float = 0.6326955372343582,\n                best_fit_score_weight: float = 0.6275805799509675,\n                remaining_space_epsilon: float = 7.830513505271675e-05,\n                best_fit_exponent: float = 14.392442476340706) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the first incorporates numerous factors like fill ratio, remaining space penalty, capacity utilization, space balance, adaptive weights, bin diversity penalty, target fill level, almost full penalty, and median proximity bonus, while the last only checks if bins can accommodate items, and assigns -inf if not.\nComparing (2nd) vs (19th), both functions are identical.\nComparing (3rd) vs (4th), these functions are identical too.\nComparing (2nd worst) vs (worst), the 18th prioritizes bins based on fullness and remaining space with minor flexibility (invalid_priority, epsilon) while the 20th only checks if bins can accommodate items, and assigns -inf if not.\nComparing (1st) vs (2nd), these functions are identical.\nComparing (3rd) vs (4th), these functions are identical.\nComparing (5th) vs (6th), these functions are identical.\nComparing (7th) vs (8th), these functions are identical.\nComparing (9th) vs (10th), these functions are identical.\nComparing (11th) vs (12th), these functions are identical.\nComparing (13th) vs (14th), we observe the 14th includes item size relative to average remaining capacity and empty bin penalty, where the 13th don't.\nComparing (15th) vs (16th), we see the 15th prioritizes packing density, tight fit bonus and empty penalty with adaptive weights and 16th prioritizes fullness and remaining space.\nComparing (17th) vs (18th), the 17th prioritizes packing density, tight fit bonus and empty penalty with adaptive weights and 18th prioritizes fullness and remaining space with minor flexibility (invalid_priority, epsilon).\nOverall: The better heuristics consider more factors with adaptive parameter adjustments based on item size, which improves bin packing efficiency by considering various aspects. The worse heuristics often neglect these details and primarily focus on basic feasibility, leading to suboptimal packing.\n- \nHere's a redefined approach to self-reflection for better heuristic design:\n\n*   **Keywords:** Adaptive heuristics, multi-factor analysis, parameter tuning, performance evaluation, iterative refinement, edge cases.\n\n*   **Advice:** Emphasize a data-driven, iterative approach. Start with simpler heuristics, rigorously test and analyze performance. Identify weaknesses and incrementally add complexity only when justified by measurable improvements. Consider adaptive parameter tuning based on input data.\n\n*   **Avoid:** Hardcoding parameters or adding complexity without empirical justification. Oversimplification that ignores key problem characteristics. Sole reliance on single metrics.\n\n*   **Explanation:** Effective self-reflection focuses on objective performance data. It avoids premature optimization and ensures complexity genuinely improves solution quality. Prioritize adaptability and validated incremental improvements.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}