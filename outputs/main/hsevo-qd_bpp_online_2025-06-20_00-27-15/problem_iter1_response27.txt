```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Uses a heuristic inspired by simulated annealing and the "temperature" concept,
    and quantum tunneling effect.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    temperature = np.mean(bins_remain_cap)  # Avg remaining capacity as temperature

    # Avoid zero temperature (division by zero).
    if temperature <= 0:
        temperature = 0.0001

    # Heuristic 1: Higher remaining capacity => lower "energy", higher priority (inverse Boltzmann)
    energy = (bins_remain_cap - item)**2  # Prefer bins where item fits and little space is left
    prob_fit = np.exp(-energy / temperature)  # Boltzmann-like probability. Higher temperature => explore more.

    # Heuristic 2: Slight preference for filling bins more
    fill_ratio = item / bins_remain_cap
    fill_bonus = np.where(bins_remain_cap >= item, fill_ratio, 0) # Only give fill bonus if item fits

    # Heuristic 3: Bins that are already quite full are favored more.
    bin_fullness = 1 - bins_remain_cap / np.max(bins_remain_cap) # normalize from 0-1 how full is a bin.
    fullness_bias = np.power(bin_fullness, 2) # higher fullness gives bigger priority


    priorities = prob_fit + 0.5 * fill_bonus + 0.1* fullness_bias # combine heuristics, weight factors are ad-hoc for now.

    # Add some randomness inspired by quantum tunneling
    tunneling_prob = np.random.rand(len(bins_remain_cap)) * 0.01  # Low tunneling chance
    priorities = priorities + tunneling_prob # Add tunneling (probabilistic restart)

    return priorities
```
