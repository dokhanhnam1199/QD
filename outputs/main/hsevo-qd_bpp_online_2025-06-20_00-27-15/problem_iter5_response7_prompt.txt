{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        invalid_priority: Priority value for bins that cannot accommodate the item.\n        epsilon: Small value to prevent division by zero.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value (e.g., -np.inf) for invalid bins.\n    priorities = np.full_like(bins_remain_cap, invalid_priority)\n    priorities[valid_bins] = 0  # Reset valid bins to 0 for further scoring.\n\n    # For valid bins, calculate a score based on remaining capacity after packing.\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    # Scoring valid bins\n    priorities[valid_bins] = (item / bins_remain_cap[valid_bins]) + (1 / (remaining_space + epsilon))\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see that the first heuristic includes `epsilon` and `invalid_priority` as arguments for better control and uses a combined scoring function based on fullness and remaining space, whereas the last heuristic calculates priorities solely based on the negative logarithm of the ratio between item size and bin remaining capacity. (2nd) vs (19th) is similar to the previous comparison. Comparing (10th) vs (14th), the 10th includes \"best fit\" consideration and \"empty bin bonus\", the 14th calculates priorities solely based on the negative logarithm of the ratio between item size and bin remaining capacity. Comparing (1st) vs (2nd), we see that (1st) allows the user to provide the value for epsilon and the invalid priority, while (2nd) hardcodes them. Comparing (2nd) vs (3rd), the second one has comprehensive docstring, the third has not. Comparing (4th) vs (5th) vs (7th) vs (9th), they are nearly identical. Comparing (11th), (12th), (13th) against (10th) no differences. Comparing (14th), (15th), (16th), (17th), (18th), (19th) and (20th) against (14th): all have the same code. Comparing (6th) and (8th) against (1st) are the same code. Overall: the better heuristics use a combination of factors (fullness, remaining space, best fit) to prioritize bins and include small constants for stability. Poorer heuristics are simplistic, using only a ratio or logarithm of ratios. The best heuristics also allow for user-defined parameters for invalid priorities and epsilon, providing greater flexibility.\n- \nOkay, let's aim for a more effective self-reflection framework for heuristic design, directly addressing the weaknesses of the \"Ineffective self-reflection\" example.\n\nHere's a refined approach:\n\n*   **Keywords:** Multi-faceted evaluation, Adaptive parameters, Iterative refinement, Performance metrics.\n*   **Advice:** Focus on creating heuristics that adapt to different instance characteristics and track performance metrics to drive iterative improvement.\n*   **Avoid:** Overly simplistic combinations of factors, neglecting edge cases beyond division by zero, lack of a performance feedback loop.\n*   **Explanation:** Design heuristics with multiple interacting components, tuned by parameters refined based on data. Quantify success (e.g. wasted space, number of bins).\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}