```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version incorporates concepts reminiscent of gravitational attraction and spacetime curvature,
    where bins with remaining capacity closer to the item size are given higher priority. It also tries to balance bin usage.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Calculate the difference between bin capacity and item size (a kind of "distance")
    diffs = np.abs(bins_remain_cap - item)

    # Invert the distance; bins closer to the item size get higher priority.
    # Add a small constant to prevent division by zero and further stabilize
    # Note the squaring to provide a larger spread of attraction.
    attraction = 1 / (diffs**2 + 0.001)

    # Penalize bins that are nearly full, but not full enough
    # To accept the given item. This encourages us to fill partially
    # Used bins first if they have sufficient space
    capacity_utilization = (1 - (bins_remain_cap / bins_remain_cap.max()))
    nearly_full_penalty = np.where((bins_remain_cap < item) & (bins_remain_cap > 0), -100, 0)
    # Add to the Attraction score a little incentive for using bins that still have the capacity.
    bins_with_capacity = np.where(bins_remain_cap >= item, 1, 0)
    priorities = attraction + nearly_full_penalty + bins_with_capacity * 0.01
    return priorities
```
