{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate remaining capacity after adding the item.\n    new_capacities = bins_remain_cap - item\n\n    # Identify bins that can accommodate the item.\n    valid_bins = new_capacities >= 0\n\n    # Initialize priorities with a very low value for invalid bins.\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Prioritize bins that can fit the item\n    if not np.any(valid_bins):\n        return priorities\n\n    priorities[valid_bins] = 0\n\n    remaining_space = bins_remain_cap[valid_bins] - item\n    \n    #1. Fill ratio\n    fill_ratio = item / bins_remain_cap[valid_bins]\n    \n    #2. Remaining space penalty\n    remaining_space_penalty = 1 / (remaining_space + 0.000001)\n    \n    #3. Capacity utilization\n    capacity_utilization = (bins_remain_cap[valid_bins] - remaining_space) / bins_remain_cap[valid_bins]\n    \n    #4. Space balance: Aim for bins to have similar fill levels\n    space_balance = np.where(remaining_space > item/2, 0.5, 0.1)\n    \n    #5. Adaptive weight based on item size -  Larger items need more careful placement\n    item_size_ratio = item / np.mean(bins_remain_cap)\n    adaptive_weight = 1.0\n    if item_size_ratio > 0.7:\n        adaptive_weight = 1.2  # Penalize very full bins more strongly\n    elif item_size_ratio < 0.3:\n        adaptive_weight = 0.8 # Be less picky when items are small\n        \n    #6. Bin Diversity Penalty: Penalize bins with very similar remaining capacities to encourage variance\n    capacity_std = np.std(bins_remain_cap)\n    if capacity_std > 0:\n        capacity_diversity_score = 1 - (np.abs(bins_remain_cap[valid_bins] - np.mean(bins_remain_cap)) / capacity_std)\n        capacity_diversity_penalty = np.clip(capacity_diversity_score, 0, 1)\n    else:\n        capacity_diversity_penalty = 0 # if all capacities same, no diversity penalty\n    \n    #7. Introduce a bin-level fill target to encourage balanced filling.  Target 75% fill.\n    bin_fill_target = 0.75\n    fill_from_empty_penalty = np.where(bins_remain_cap[valid_bins] == bins_remain_cap.max(), 0.2, 0) #prefer filling empty bins initially\n    \n    fill_target_diff = np.abs(1 - (bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() - bin_fill_target)\n    fill_target_penalty = 1 / (fill_target_diff + 0.00001)\n    \n    #8. Introduce Penalty for bins almost full. Encourages use of emptier bins, creates space for future large objects.\n    almost_full_threshold = 0.9\n    almost_full_penalty = np.where((bins_remain_cap[valid_bins] - item) / bins_remain_cap.max() < (1-almost_full_threshold), -0.3, 0)\n    \n    #9. Sort remaining capacities and add a bonus to bins close to the median\n    sorted_caps = np.sort(bins_remain_cap)\n    median_cap = np.median(bins_remain_cap)\n    median_proximity_bonus = np.exp(-np.abs(bins_remain_cap[valid_bins] - median_cap) / (0.1 * bins_remain_cap.max())) * 0.1 # gaussian bonus near median\n\n    # Combine the factors to create the priority score.  Experiment with weights.\n    priorities[valid_bins] = adaptive_weight * fill_ratio + remaining_space_penalty + capacity_utilization + space_balance + 0.1 * capacity_diversity_penalty + fill_from_empty_penalty + 0.05 * fill_target_penalty + almost_full_penalty + median_proximity_bonus\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nHere's a redefined approach to self-reflection for better heuristic design:\n\n*   **Keywords:** Adaptive heuristics, multi-factor analysis, parameter tuning, performance evaluation, iterative refinement, edge cases.\n\n*   **Advice:** Emphasize a data-driven, iterative approach. Start with simpler heuristics, rigorously test and analyze performance. Identify weaknesses and incrementally add complexity only when justified by measurable improvements. Consider adaptive parameter tuning based on input data.\n\n*   **Avoid:** Hardcoding parameters or adding complexity without empirical justification. Oversimplification that ignores key problem characteristics. Sole reliance on single metrics.\n\n*   **Explanation:** Effective self-reflection focuses on objective performance data. It avoids premature optimization and ensures complexity genuinely improves solution quality. Prioritize adaptability and validated incremental improvements.\n\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}