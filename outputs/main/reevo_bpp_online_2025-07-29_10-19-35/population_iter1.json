[
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    valid_mask = bins_remain_cap >= item\n    # Prioritize bins with smallest remaining capacity after packing (Best Fit)\n    # Priority is -(remaining_cap - item) = item - remaining_cap\n    priority = np.where(valid_mask, item - bins_remain_cap, -np.inf)\n    return priority",
    "response_id": 0,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on Best Fit heuristic: prioritize bins that leave the least remaining space after packing the item.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    feasible = bins_remain_cap >= item\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    # Assign higher priority (less negative) to bins with smaller residual space (item - remaining)\n    priority[feasible] = item - bins_remain_cap[feasible]\n    return priority",
    "response_id": 1,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Higher score indicates higher priority.\n    \"\"\"\n    remaining_after_add = bins_remain_cap - item\n    can_fit = remaining_after_add >= 0\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    epsilon = 1e-9  # Small value to prevent division by zero\n    priority[can_fit] = 1.0 / (remaining_after_add[can_fit] + epsilon)\n    return priority",
    "response_id": 2,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    The priority is highest for bins that can fit the item with the least\n    remaining capacity after placement. Bins that cannot fit the item are\n    assigned a very low priority.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Prioritize bins with minimal leftover space (Best Fit)\n    # item - remain_cap is equivalent to -leftover, so higher is better\n    priorities = np.where(\n        can_fit,\n        item - bins_remain_cap,\n        -np.inf\n    )\n    return priorities",
    "response_id": 3,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on minimizing leftover space with a tie-breaker for larger bins.\n    \n    Assigns priority scores to bins by calculating the negative of the leftover space after placing\n    the item (favoring tighter fits). In case of ties, bins with slightly larger remaining capacity\n    are prioritized to encourage consolidation.\n    \"\"\"\n    slack = bins_remain_cap - item\n    valid_mask = slack >= 0\n    # Base priority: -slack (best fit), with a small tie-breaking term\n    priority = np.where(valid_mask, -slack + 1e-7 * bins_remain_cap, -np.inf)\n    return priority",
    "response_id": 4,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combination of \n    item utilization ratio and inverse leftover space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-8  # To prevent division by zero\n    can_fit = bins_remain_cap >= item\n    \n    # Ratio of item size to bin's remaining capacity (higher = better fit)\n    utilization_ratio = item / (bins_remain_cap + epsilon)\n    \n    # Inverse of leftover space after placement (higher = smaller leftover)\n    leftover = bins_remain_cap - item\n    inv_leftover = 1.0 / (leftover + 1.0)\n    \n    # Combine metrics and mask invalid bins\n    priority = np.where(can_fit, utilization_ratio + inv_leftover, -np.inf)\n    return priority",
    "response_id": 5,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit strategy for online Bin Packing.\n    \n    Bins that can fit the item are prioritized by how tightly they fit it (smaller slack),\n    with the highest priority given to bins that would be completely filled.\n    \"\"\"\n    slack = bins_remain_cap - item\n    valid = slack >= 0\n    return np.where(valid, -slack, -np.inf)",
    "response_id": 6,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores implementing a 'Best Fit' heuristic with a twist.\n    \n    The priority for each bin is calculated as the negative of the remaining space after placing the item,\n    encouraging tight fits. Bins that cannot accommodate the item are assigned -infinity.\n    \"\"\"\n    # Mask bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    # Calculate priority as negative of leftover space (higher priority for tighter fits)\n    priorities = np.where(\n        can_fit,\n        -(bins_remain_cap - item),  # Negative leftover space\n        -np.inf  # Impossible bins have lowest priority\n    )\n    return priorities",
    "response_id": 7,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using a combination of best fit and exact fit prioritization.\"\"\"\n    valid_mask = bins_remain_cap >= item\n    diff = bins_remain_cap - item\n    \n    # Base score: negative diff to prioritize smaller leftover space (best fit)\n    base_score = np.where(valid_mask, -diff, -np.inf)\n    \n    # Bonus for exact fits: add a small epsilon to differentiate exact fits from near fits\n    exact_fit_bonus = np.where(np.isclose(bins_remain_cap, item), 1e-6, 0.0)\n    \n    # Combine base score and exact fit bonus\n    priority = base_score + exact_fit_bonus\n    \n    return priority",
    "response_id": 8,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using Best Fit heuristic.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Create a mask for bins that can fit the item\n    mask = bins_remain_cap >= item\n    # Initialize scores with -infinity for invalid bins\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    # Assign priority scores: higher priority to bins with smaller remaining capacity\n    scores[mask] = -bins_remain_cap[mask]\n    return scores",
    "response_id": 9,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response10.txt_stdout.txt",
    "code_path": "problem_iter1_code10.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a combination of fit quality and bin fill level.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    mask = bins_remain_cap >= item\n    leftover = bins_remain_cap - item\n    # Term rewarding smaller leftover (higher fit quality)\n    term_fit = 1.0 / (leftover + 1.0)\n    # Term rewarding bins that are already more filled (smaller remaining capacity)\n    term_fill = 1.0 / (bins_remain_cap + 1.0)\n    # Combine terms for valid bins, assign -inf to invalid bins\n    priority = np.where(mask, term_fit + term_fill, -np.inf)\n    return priority",
    "response_id": 10,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response11.txt_stdout.txt",
    "code_path": "problem_iter1_code11.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using a combination of tight-fit bonus and negative leftover.\"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    can_fit = bins_remain_cap >= item\n    if np.any(can_fit):\n        leftover = bins_remain_cap[can_fit] - item\n        tight_bonus = 1000.0  # Large bonus to prioritize bins leaving tight space\n        tight_mask = leftover < item\n        # Base priority: negative leftover (smaller leftover is better)\n        base_prio = -leftover\n        # Add bonus for tight leftover\n        base_prio += np.where(tight_mask, tight_bonus, 0)\n        priorities[can_fit] = base_prio\n    return priorities",
    "response_id": 11,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response12.txt_stdout.txt",
    "code_path": "problem_iter1_code12.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority using Best Fit strategy: higher priority for bins with least leftover space.\"\"\"\n    leftover = bins_remain_cap - item\n    can_fit = leftover >= 0\n    return np.where(can_fit, -leftover, -np.inf)",
    "response_id": 12,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response13.txt_stdout.txt",
    "code_path": "problem_iter1_code13.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on inverse of remaining space after placement.\n    \n    Bins that can fit the item are prioritized by how tightly they fit the item:\n    smaller remaining space leads to higher priority. Ineligible bins have -inf priority.\n    \"\"\"\n    eligible = bins_remain_cap >= item\n    space_after = bins_remain_cap - item\n    inv_space = 1.0 / (space_after + 1e-9)  # Epsilon prevents division by zero\n    priority = np.where(eligible, inv_space, -np.inf)\n    return priority",
    "response_id": 13,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response14.txt_stdout.txt",
    "code_path": "problem_iter1_code14.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on a combination of best-fit and bin utilization improvement.\"\"\"\n    # Mask bins that can fit the item\n    mask = bins_remain_cap >= item\n    # Initialize priorities to -infinity for invalid bins\n    priority = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    # Calculate remaining capacity after placing the item\n    remaining_after = bins_remain_cap[mask] - item\n    # Best Fit component: prioritize bins with least remaining after placement\n    best_fit = -remaining_after\n    # Utilization improvement: prioritize bins where item fills a higher ratio of their remaining space\n    utilization_ratio = item / (bins_remain_cap[mask] + 1e-9)  # Avoid division by zero\n    # Combine components with weights\n    priority[mask] = 0.7 * best_fit + 0.3 * utilization_ratio\n    return priority",
    "response_id": 14,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response15.txt_stdout.txt",
    "code_path": "problem_iter1_code15.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores based on minimizing remaining space after placement and tiebreaker for more filled bins.\n    \n    Combines best fit heuristic with a small penalty for bins that are less filled to improve tiebreaking.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n    valid = bins_remain_cap >= item\n    if np.any(valid):\n        remaining_after = bins_remain_cap[valid] - item\n        # Main term: -(remaining space after placement), Tiebreaker: -0.01 * current remaining capacity\n        scores[valid] = -(remaining_after) - 0.01 * bins_remain_cap[valid]\n    return scores",
    "response_id": 15,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response16.txt_stdout.txt",
    "code_path": "problem_iter1_code16.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function using Best Fit heuristic with a tie-breaker for larger remaining capacities.\"\"\"\n    space_left = bins_remain_cap - item\n    valid = space_left >= 0\n    # Best Fit priority: maximize -(space_left)\n    # Tie-breaker: small preference for bins with larger remaining capacity\n    scores = np.where(valid, -space_left + 0.01 * bins_remain_cap, -np.inf)\n    return scores",
    "response_id": 16,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response17.txt_stdout.txt",
    "code_path": "problem_iter1_code17.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores that favor bins with remaining capacity just above the item size.\"\"\"\n    # Mask bins that can fit the item\n    can_fit = bins_remain_cap >= item\n    # Calculate priority as negative of leftover space (Best Fit), encouraging minimal waste\n    priority = np.where(can_fit, -(bins_remain_cap - item), -np.inf)\n    return priority",
    "response_id": 17,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response18.txt_stdout.txt",
    "code_path": "problem_iter1_code18.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n    \n    The priority for each bin is the negative of the remaining capacity after placing the item,\n    which prioritizes bins that fit the item with minimal leftover space. Bins that cannot fit\n    the item are assigned a priority of negative infinity.\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, fill_value=-np.inf, dtype=np.float64)\n    valid_mask = bins_remain_cap >= item\n    if np.any(valid_mask):\n        priorities[valid_mask] = -(bins_remain_cap[valid_mask] - item)\n    return priorities",
    "response_id": 18,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response19.txt_stdout.txt",
    "code_path": "problem_iter1_code19.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on a combination of residual space and bin utilization.\n\n    Bins that can fit the item are prioritized by:\n    1. Minimizing the remaining capacity after packing (residual space).\n    2. Preferring bins that are already more filled (lower current remaining capacity).\n    This is achieved by scoring valid bins as `-2 * remaining_cap + item`, which balances both factors.\n    \"\"\"\n    valid = bins_remain_cap >= item\n    scores = np.where(valid, -2 * bins_remain_cap + item, -np.inf)\n    return scores",
    "response_id": 19,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response20.txt_stdout.txt",
    "code_path": "problem_iter1_code20.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    feasible = bins_remain_cap >= item\n    # Threshold for large items (assuming bin capacity normalized to 1.0)\n    threshold = 0.5  \n    if item > threshold:\n        # Prioritize bins with least remaining capacity (Best Fit for large items)\n        return np.where(feasible, -bins_remain_cap, -np.inf)\n    else:\n        # Prioritize bins with most remaining capacity (Worst Fit for small items)\n        return np.where(feasible, bins_remain_cap, -np.inf)",
    "response_id": 20,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response21.txt_stdout.txt",
    "code_path": "problem_iter1_code21.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using Best Fit strategy with negative remaining capacity heuristic.\n    \n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n    \n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    remaining_after = bins_remain_cap - item\n    valid_mask = remaining_after >= 0\n    # Use negative remaining after placement as priority (smaller remaining = higher priority)\n    # Invalid bins get -inf to ensure they are not selected\n    priority = np.where(valid_mask, -remaining_after, -np.inf)\n    return priority",
    "response_id": 21,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response22.txt_stdout.txt",
    "code_path": "problem_iter1_code22.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit heuristic with tie-breaking.\"\"\"\n    mask = bins_remain_cap >= item\n    # Use negative remaining capacity for Best Fit; add small noise to break ties\n    priority_base = -bins_remain_cap\n    tiebreaker = np.random.rand(*bins_remain_cap.shape) * 1e-8  # Minimal random perturbation\n    return np.where(mask, priority_base + tiebreaker, -np.inf)",
    "response_id": 22,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response23.txt_stdout.txt",
    "code_path": "problem_iter1_code23.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function based on Best Fit heuristic with tie-breaking for online BPP.\n    \n    Assigns higher priority to bins that can fit the item with the smallest remaining capacity\n    after placement, while incorporating a small penalty term to break ties in favor of bins\n    with higher current utilization (lower remaining capacity).\n    \n    Args:\n        item: Size of the item to pack.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    can_fit = bins_remain_cap >= item\n    # Slack-based priority with tie-breaking: -(remaining_cap - item) + 1e-6 * (1 / (bins_remain_cap + 1e-6))\n    slack = bins_remain_cap - item\n    priority = np.where(can_fit, -slack + 1e-6 * (1 / (bins_remain_cap + 1e-6)), -np.inf)\n    return priority",
    "response_id": 23,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response24.txt_stdout.txt",
    "code_path": "problem_iter1_code24.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin. Higher scores are better.\n    \"\"\"\n    # Prioritize bins that can fit the item and have the smallest remaining capacity.\n    # This encourages a \"best fit\" strategy by minimizing leftover space.\n    priority = np.where(\n        bins_remain_cap >= item,\n        item - bins_remain_cap,  # Higher (closer to 0) for tighter fits\n        -np.inf  # Invalid bins get -infinity to ensure they are not selected\n    )\n    return priority",
    "response_id": 24,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response25.txt_stdout.txt",
    "code_path": "problem_iter1_code25.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on Best Fit heuristic: prioritize bins that can fit the item and have the smallest remaining capacity.\"\"\"\n    can_fit = bins_remain_cap >= item\n    # Assign priority as negative remaining capacity for bins that can fit, -infinity otherwise\n    priorities = np.where(can_fit, -bins_remain_cap, -np.inf)\n    return priorities",
    "response_id": 25,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response26.txt_stdout.txt",
    "code_path": "problem_iter1_code26.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores using a combination of best fit and bin utilization.\n    \n    Prioritizes bins that (1) have the smallest remaining space after placement \n    and (2) are already more filled. This combines classic Best Fit with an \n    additional incentive to consolidate items into existing bins.\n    \"\"\"\n    mask = bins_remain_cap >= item\n    remaining_after = bins_remain_cap - item\n    \n    # Best Fit component: minimize remaining space after placement\n    best_fit_score = -remaining_after  \n    \n    # Bin utilization component: prefer bins that were already more filled\n    utilization = 1.0 - bins_remain_cap  \n    utilization_score = utilization\n    \n    # Combine both components with equal weight\n    priority = np.where(mask, best_fit_score + utilization_score, -np.inf)\n    return priority",
    "response_id": 26,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response27.txt_stdout.txt",
    "code_path": "problem_iter1_code27.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority scores for bins based on Best Fit heuristic.\n\n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of priority scores for each bin. Higher scores indicate higher priority.\n    \"\"\"\n    # Calculate space left if item is placed in each bin\n    space_left = bins_remain_cap - item\n    # Valid bins are those with non-negative space left\n    # Priority is negative space left (so bins with less space left have higher priority)\n    return np.where(\n        bins_remain_cap >= item,\n        -space_left,  # Equivalent to item - bins_remain_cap\n        -np.inf\n    )",
    "response_id": 27,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response28.txt_stdout.txt",
    "code_path": "problem_iter1_code28.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority function implementing Best Fit strategy for online Bin Packing Problem.\n    \n    Assigns higher priority to bins that can fit the item with minimal leftover space.\n    Bins that cannot fit the item are assigned a very low priority (-inf).\n    \n    Args:\n        item: Size of the item to be packed.\n        bins_remain_cap: Array of remaining capacities for each bin.\n    \n    Returns:\n        Array of priority scores for each bin.\n    \"\"\"\n    # Create a mask for bins that can fit the item\n    feasible_mask = bins_remain_cap >= item\n    \n    # Prioritize bins by minimizing leftover space: \n    # priority = -(leftover space) = item - remain_cap (for feasible bins)\n    # Non-feasible bins get -inf to ensure they are not selected\n    priorities = np.where(feasible_mask, item - bins_remain_cap, -np.inf)\n    \n    return priorities",
    "response_id": 28,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response29.txt_stdout.txt",
    "code_path": "problem_iter1_code29.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Priority based on minimizing leftover space (Best Fit heuristic).\"\"\"\n    can_fit = bins_remain_cap >= item\n    priority = np.where(can_fit, -bins_remain_cap, -np.inf)\n    return priority",
    "response_id": 29,
    "obj": 4.048663741523748,
    "SLOC": 4.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]