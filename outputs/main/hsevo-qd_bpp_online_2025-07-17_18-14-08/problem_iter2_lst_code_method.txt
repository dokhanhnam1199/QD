{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a combination of remaining capacity and waste minimization,\n    inspired by the principles of efficient space-time utilization.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-9\n    \n    # Calculate waste if the item is placed in each bin\n    waste = bins_remain_cap - item\n    \n    # Give negative infinite priority to bins that cannot contain the item\n    waste[waste < -epsilon] = np.inf\n\n    # Score based on remaining capacity\n    capacity_score = bins_remain_cap / (np.sum(bins_remain_cap) + epsilon)\n\n    #Score based on waste, higher priority when there is minimal waste\n    waste_score = np.exp(-10 * waste / (item + epsilon)) #Exponential decay for waste close to 0, item scaled decay rate\n\n    # Combine scores\n    priorities = capacity_score * waste_score #Prefer bigger free bins and smaller waste\n\n    # Set invalid bins to -inf\n    priorities[waste == np.inf] = -np.inf\n    \n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Prioritize bins that can fit the item reasonably well\n    # but aren't too empty afterwards. Avoid fragmentation.\n\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Give a high score if the item fits and the remaining capacity is not too large\n    fit_mask = bins_remain_cap >= item\n    remaining_after_fit = bins_remain_cap[fit_mask] - item\n\n    # Scale based on how full the bin will be after packing, prefer bins close to full.\n    priorities[fit_mask] = (1 - (remaining_after_fit / bins_remain_cap[fit_mask]))\n    # Apply scaling to really encourage filling the almost-full bin\n    priorities[fit_mask] = priorities[fit_mask]**2\n    # Prefer bins whose remain_cap is a bit larger than item.\n    priorities[fit_mask] = priorities[fit_mask] / (1 + abs(bins_remain_cap[fit_mask]-item))\n    # Negatively penalize bins that are too large or empty before placing the item. This discourages bins with much capacity relative to item\n    priorities = priorities - (bins_remain_cap / np.max(bins_remain_cap)) * 0.01\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priority scores\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Give high priority to bins that can fit the item without much waste\n    # This encourages filling bins efficiently\n    fit_mask = bins_remain_cap >= item\n    waste = bins_remain_cap - item\n    priorities[fit_mask] = 1.0 / (waste[fit_mask] + 0.0001) # Avoid division by zero and prioritize smaller waste\n\n    # Give a slightly lower priority to bins that are nearly full before adding the item\n    # Avoid very small remaining capacities\n    nearly_full_mask = (bins_remain_cap > 0) & (bins_remain_cap < item)\n    priorities[nearly_full_mask] = 0.5\n\n    # Penalize bins that cannot fit the item\n    infeasible_mask = bins_remain_cap < item\n    priorities[infeasible_mask] = -np.inf # Never add to bins that cannot fit\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Higher priority means we prefer adding the item to that bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Avoid division by zero\n    valid_bins = bins_remain_cap > 0\n\n    if not np.any(valid_bins):\n        return priorities # All bins are full or invalid\n\n    # 1. Immediate Fit: Bins that can fit the item perfectly or nearly perfectly\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6  # Using a small tolerance\n    priorities[perfect_fit] += 100  # High priority for perfect fits\n\n    # 2. Best Fit: Bins with the smallest remaining capacity after adding the item (that still fits)\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        remaining_after_fit = bins_remain_cap[fits] - item\n        best_fit_idx = np.argmin(remaining_after_fit)\n        #Need to translate from the filtered index back to the index in the whole array\n        indices = np.where(fits)[0]\n        best_fit_full_idx = indices[best_fit_idx]\n        priorities[best_fit_full_idx] += 50 # Medium-High priority\n\n    # 3. Consider bin utilization\n    utilization_ratio = item / bins_remain_cap[valid_bins]\n    priorities[valid_bins] += utilization_ratio * 10  # Medium Priority, prioritize higher utilization\n\n    # 4. Avoid bins that barely fit the item\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap < item * 1.1) #avoid creating near empty bins.\n    priorities[nearly_full] -= 20 # Slightly negative priority\n\n    # 5. Penalize bins that don't fit at all (makes them less likely to be chosen if there are multiple options and the other bonuses balance out)\n    no_fit = bins_remain_cap < item\n    priorities[no_fit] -= 1  #Very slightly negative\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Considers remaining capacity and avoids nearly-full bins if possible.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Give very low priority to bins that cannot fit the item\n    infeasible = bins_remain_cap < item\n    priorities[infeasible] = -np.inf\n    \n    # Give higher priority to bins that are close to being full after adding the item,\n    # but avoid extremely tight fits\n    \n    feasible = ~infeasible\n    \n    if np.any(feasible):\n        fill_ratios = item / bins_remain_cap[feasible]\n        \n        # Scale to give bins that are filled the most a higher value but less than one that can not fit.\n        priorities[feasible] = 1.0 / (1.0 + np.abs(1 - fill_ratios))\n        \n        #Adjust priorities based on remaining space after adding the item\n        remaining_space = bins_remain_cap[feasible] - item\n        \n        # AVOID SMALL REMAINING SPACE\n        # Penalize bins that would have a very small remaining capacity after placing the item.\n        small_space_penalty = np.exp(-remaining_space) # exponentially decaying penalty\n        priorities[feasible] *= small_space_penalty\n\n        # If all bins that can fit have very low score, boost bin the lowest fill_ratio for the sake of progress\n        if np.all(priorities[feasible] < 0.01):\n           fill_ratios = item / bins_remain_cap[feasible]\n           idx_min = np.argmin(fill_ratios) # Pick minimum remaining\n           priorities[feasible][idx_min] = 0.1\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function considers several factors:\n\n    1.  Whether the item fits in the bin.  If not, priority is -inf.\n    2.  The fill ratio (item size / remaining capacity). Higher fill ratio is generally better,\n        but we also want to avoid filling a bin *too* much (leaving very little space).\n    3. A bonus for bins that are nearly full after adding the item, but not quite full\n       (this encourages good packing but avoids perfect fits too early which may lead to\n       inefficient packing later on.)\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf)  # Initialize with -inf\n\n    # Bins where the item fits\n    valid_bins = bins_remain_cap >= item\n\n    if not np.any(valid_bins):\n      return priorities # Return -inf if no bins fit.\n\n    # Calculate fill ratios for valid bins\n    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)\n    fill_ratios[valid_bins] = item / bins_remain_cap[valid_bins]\n\n    # Priority based on fill ratio (with a bit of a tweak)\n    priorities[valid_bins] = fill_ratios[valid_bins]\n\n    # Add a bonus for bins that are close to full after adding the item,\n    # but not perfectly full\n    remaining_after_fit = bins_remain_cap - item\n    nearly_full_bonus = np.exp(-10 * remaining_after_fit) * valid_bins # Apply the bonus. Larger K -> closer to full is preferred.\n\n    priorities += nearly_full_bonus\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a combination of remaining capacity and item size to determine priority.\n    Bins with capacity slightly larger than the item are prioritized,\n    while bins that are too small or too large receive lower priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Avoid division by zero. Set priority to a very low value if remaining capacity is 0\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[bins_remain_cap == 0] = -np.inf\n\n    # Give higher priority to bins that can fit the item closely\n    fit_score = np.where(bins_remain_cap >= item, np.exp(-np.abs(bins_remain_cap - item) / item), -np.inf)\n\n    # Penalize bins with very large remaining capacity\n    capacity_penalty = np.where(bins_remain_cap > item, - (bins_remain_cap - item) / np.max(bins_remain_cap), 0)\n\n    priorities = fit_score + capacity_penalty\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This version prioritizes bins that can accommodate the item with minimal wasted space,\n    but also penalizes bins that are nearly full to encourage more balanced packing.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i, remaining_capacity in enumerate(bins_remain_cap):\n        if remaining_capacity >= item:\n            # Calculate wasted space\n            wasted_space = remaining_capacity - item\n\n            # Prioritize bins with smaller wasted space (higher priority)\n            # Add a small constant to avoid division by zero and extreme values. Also, prevents inf from arising from np.exp(-x) = inf when x approaches -inf\n\n            priorities[i] = np.exp(-wasted_space)  # Exponential decay for wasted space\n            # Penalize bins that are almost full. Avoids putting small items in near-full bins.\n            # Scale this penalty based on how full the bin becomes after placing the item. Prevents bins that become very full from being excessively favored.\n\n            fullness_after = item / remaining_capacity\n            priorities[i] *= (1 - fullness_after)**0.5  # Apply diminishing returns penalty for nearly full bins\n        else:\n            priorities[i] = -np.inf  # Disqualify bins that cannot fit the item\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Utilizes a combination of factors including capacity, waste minimization,\n    and a slight preference for partially filled bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Initialize priorities with a base score based on whether the item fits.\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    fits = bins_remain_cap >= item\n    priorities[fits] = 1.0  # Bins where the item fits get a base priority.\n\n    # Adjust priority based on waste minimization.  Smaller waste is better.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Effectively ignore bins where the item doesn't fit\n\n    # Scale the inverse of the waste to contribute to the priority.  Avoid division by zero.\n    waste_scores = np.where(waste > 0, 1.0 / (waste + 0.0001), 0.0) #Small constant to avoid division by zero.\n\n    #Add scaled waste score.\n    priorities += waste_scores* fits #only if it fits\n\n\n    # Encourage filling bins that already have some items (but aren't full), subtly\n    # to avoid prematurely closing bins, by rewarding a specific range of capacity usage\n    partially_filled = (bins_remain_cap > item) & (bins_remain_cap < np.max(bins_remain_cap))\n    priorities[partially_filled] += 0.5 #Adds a moderate bias for partially filled bins.\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version considers both remaining capacity and waste.  Bins that\n    have enough capacity and leave minimal waste are preferred.  We also\n    introduce a small exploration factor to avoid getting stuck in local minima.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    # Avoid division by zero\n    bins_remain_cap = np.clip(bins_remain_cap, 1e-9, None)\n\n    # Calculate waste if item is placed in each bin. Negative values indicate not enough space\n    waste = bins_remain_cap - item\n\n    # Give bins that can accommodate the item a baseline priority of 1, and others 0\n    priority = np.where(waste >= 0, 1.0, 0.0)\n\n    # Further increase priority based on how *little* waste there is. This encourages filling bins well.\n    # Using a Gaussian-like curve centered around zero waste\n    priority += np.where(waste >= 0, np.exp(-(waste**2) / (2 * (item/5)**2)), 0.0)\n\n    # Add a tiny amount proportional to the remaining capacity. This favors using less-full bins *slightly*.\n    # Important that this is significantly smaller than other terms. This promotes even distribution but cares more about fitting well.\n    priority += bins_remain_cap * 0.001\n\n    # Add a small exploration factor to sometimes deviate from the \"best\" choice and potentially find better packings\n    priority += np.random.rand(len(bins_remain_cap)) * 0.0001\n\n    return priority\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Uses a combination of factors inspired by physical principles\n    (though adapted for this computational problem).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # A 'gravitational' attraction: Higher priority for bins closer to item size.\n    # Use squared difference for a stronger pull when very close\n    diff = np.abs(bins_remain_cap - item)\n    priorities = 1.0 / (1e-6 + diff**2)  # 1e-6 avoids division by zero\n\n    # Inverse 'repulsion': lower priority for bins with very little space.\n    # Mimicking Pauli Exclusion Principle (sort of). Prevent overfilling attempts.\n    small_space_penalty = np.where(bins_remain_cap < item, -np.inf, 0)\n    priorities += small_space_penalty\n\n    # Favor bins with more capacity available (but not too much)\n    # A larger bin reduces the number of bins in total, improving our goal\n    capacity_bonus = np.clip(bins_remain_cap - item, 0, item * 2) # Cap bonus\n    priorities += capacity_bonus * 0.1 # Tune bonus effect, otherwise domination.\n\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Employs a combination of factors:\n         1. Space Utilization: Favor bins where the item fits reasonably well,\n            but not perfectly, to encourage filling.\n         2. Avoidance of near-empty bins: Penalize bins that will become nearly empty after packing.\n         3. Capacity Considerations: Give priority to bins with sufficient, but not excessive, remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Small constant to avoid division by zero and log of zero\n\n    # 1. Space Utilization:  Calculate how well the item fits (ratio).\n    utilization_ratio = item / (bins_remain_cap + epsilon)\n    utilization_priority = np.exp(-np.abs(utilization_ratio - 1))  # Gaussian-like peak around ratio=1\n\n    # 2. Avoidance of near-empty bins: Penalize bins becoming nearly empty.\n    remaining_after_pack = np.clip(bins_remain_cap - item, 0, np.inf)\n    empty_bin_penalty = np.exp(-5 * remaining_after_pack / (bins_remain_cap + epsilon)) # strong penalty if remaining is small relative to original.  Larger coefficient gives stronger penalty.\n    # Make sure that utilization_priority is always zero when remaining_after_pack is zero. This ensures there is no inf values and correct behaviour\n    empty_bin_penalty[remaining_after_pack <= epsilon] = 0.0\n\n\n    # 3. Capacity Considerations:  Bins with very little remaining space\n    #    or too much remaining space get lower priority.\n    capacity_priority = np.sqrt(bins_remain_cap) # Gives preference to bins with some space. Using sqrt rather than linear\n\n    # Combine the factors:\n    priorities = utilization_priority * (1 - empty_bin_penalty) * capacity_priority\n    priorities[bins_remain_cap < item] = -np.inf  # Impossible bins get negative infinity priority to avoid ever using\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Employs a combination of factors:\n         1. Space Utilization: Favor bins where the item fits reasonably well,\n            but not perfectly, to encourage filling.\n         2. Avoidance of near-empty bins: Penalize bins that will become nearly empty after packing.\n         3. Capacity Considerations: Give priority to bins with sufficient, but not excessive, remaining capacity.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    epsilon = 1e-9  # Small constant to avoid division by zero and log of zero\n\n    # 1. Space Utilization:  Calculate how well the item fits (ratio).\n    utilization_ratio = item / (bins_remain_cap + epsilon)\n    utilization_priority = np.exp(-np.abs(utilization_ratio - 1))  # Gaussian-like peak around ratio=1\n\n    # 2. Avoidance of near-empty bins: Penalize bins becoming nearly empty.\n    remaining_after_pack = np.clip(bins_remain_cap - item, 0, np.inf)\n    empty_bin_penalty = np.exp(-5 * remaining_after_pack / (bins_remain_cap + epsilon)) # strong penalty if remaining is small relative to original.  Larger coefficient gives stronger penalty.\n    # Make sure that utilization_priority is always zero when remaining_after_pack is zero. This ensures there is no inf values and correct behaviour\n    empty_bin_penalty[remaining_after_pack <= epsilon] = 0.0\n\n\n    # 3. Capacity Considerations:  Bins with very little remaining space\n    #    or too much remaining space get lower priority.\n    capacity_priority = np.sqrt(bins_remain_cap) # Gives preference to bins with some space. Using sqrt rather than linear\n\n    # Combine the factors:\n    priorities = utilization_priority * (1 - empty_bin_penalty) * capacity_priority\n    priorities[bins_remain_cap < item] = -np.inf  # Impossible bins get negative infinity priority to avoid ever using\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function prioritizes bins based on a combination of factors:\n    1. How well the item fits (smaller wasted space is better).\n    2. A probabilistic element to explore different bin choices (inspired by quantum randomness).\n    3. A penalty for bins that are almost full (risk of overfilling).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero\n    bins_remain_cap = np.clip(bins_remain_cap, 1e-6, None)\n\n    # 1. Fit Score: Smaller wasted space is better\n    wasted_space = bins_remain_cap - item\n    fit_score = np.exp(-np.abs(wasted_space)) # Gaussian-like, peaked at 0 wasted space. exp(-waste) more sensitive to small wastes\n\n    # Adjust fit score: Penalize if waste is very high. Use the original capacity for scaling\n    fit_score = np.where(wasted_space < 0, -1e9, fit_score)  # Assign extremely low score if overfill.  Make really small\n\n    # 2. Probabilistic Element: \"Quantum Tunneling\" - Allow some exploration\n    # Inspired by the idea that a particle can tunnel through barriers.\n    #  Add small random numbers (proportional to the item size). This encourages exploration.\n    probabilistic_boost = np.random.rand(len(bins_remain_cap)) * item * 0.01  # Small boost\n\n    # 3. Risk Factor: Penalize bins that are close to full (Higher risk of overfilling with subsequent items).\n    # This is an exponentially decaying penalty near capacity.\n    capacity_ratio = item / bins_remain_cap\n    risk_penalty = np.exp(10 * (capacity_ratio - 1))\n    risk_penalty = np.clip(risk_penalty, 0, 1e9)  # limit penalty effect to prevent nan. The lower this upper bound, the less sensitive\n\n    # Combine all factors\n    priorities = fit_score + probabilistic_boost - risk_penalty\n\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Considers both remaining capacity and a \"gravitational pull\"\n    towards bins that are already somewhat full.\n    Inspired by gravitational lensing and spacetime curvature -\n    items \"prefer\" to be near existing \"mass\" (filled bins).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero:\n    bins_remain_cap = np.clip(bins_remain_cap, 1e-9, None)\n\n    # 1. Capacity Consideration (Similar to First Fit Decreasing):\n    capacity_priority = bins_remain_cap - item  # Higher is better\n\n    # If the item doesn't fit, give very low priority.\n    capacity_priority[capacity_priority < 0] = -np.inf\n\n    # 2. \"Gravitational\" Factor (Encourages filling nearly-full bins):\n    # Higher remaining cap means weaker \"gravity\", so use inverse.\n    # Small constant added to avoid division by zero, and to tweak the influence\n    # Note, the greater the item, the larger its effect is to \"pull\" to itself\n    gravitational_constant = 0.1\n    gravity = item / (bins_remain_cap + gravitational_constant)  # The closer it is to filled, the higher priority\n    gravity = np.nan_to_num(gravity, neginf=0)\n\n    # 3. Combine Priorities (Relativistic Addition - loosely inspired):\n    # Add some small factor such that a large change to either parameter doesn't change the total by as much.\n    #   - We should favor adding to any bin with cap sufficiently large rather than prioritizing the full bins.\n\n    alpha = 0.9 # Tunable constant\n\n    priorities = alpha * capacity_priority + (1-alpha) * gravity\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 18th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Considers both remaining capacity and a \"gravitational pull\"\n    towards bins that are already somewhat full.\n    Inspired by gravitational lensing and spacetime curvature -\n    items \"prefer\" to be near existing \"mass\" (filled bins).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid division by zero:\n    bins_remain_cap = np.clip(bins_remain_cap, 1e-9, None)\n\n    # 1. Capacity Consideration (Similar to First Fit Decreasing):\n    capacity_priority = bins_remain_cap - item  # Higher is better\n\n    # If the item doesn't fit, give very low priority.\n    capacity_priority[capacity_priority < 0] = -np.inf\n\n    # 2. \"Gravitational\" Factor (Encourages filling nearly-full bins):\n    # Higher remaining cap means weaker \"gravity\", so use inverse.\n    # Small constant added to avoid division by zero, and to tweak the influence\n    # Note, the greater the item, the larger its effect is to \"pull\" to itself\n    gravitational_constant = 0.1\n    gravity = item / (bins_remain_cap + gravitational_constant)  # The closer it is to filled, the higher priority\n    gravity = np.nan_to_num(gravity, neginf=0)\n\n    # 3. Combine Priorities (Relativistic Addition - loosely inspired):\n    # Add some small factor such that a large change to either parameter doesn't change the total by as much.\n    #   - We should favor adding to any bin with cap sufficiently large rather than prioritizing the full bins.\n\n    alpha = 0.9 # Tunable constant\n\n    priorities = alpha * capacity_priority + (1-alpha) * gravity\n\n    return priorities\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Incorporates several heuristics:\n       1. First-Fit Decreasing (FFD) inspired: Prioritizes bins with enough space, penalizes almost-full bins.\n       2. Best-Fit inspired: Maximizes used space, avoiding excessive fragmentation.\n       3. Prevents thrashing: Penalizes bins very close in size to the item, leading to small remaining space.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    for i, cap in enumerate(bins_remain_cap):\n        if cap >= item:\n            # Base priority: higher remaining capacity means higher initial priority, encouraging first fit.\n            priorities[i] = cap\n\n            # Best-fit inspired: prioritize bins that are a close fit\n            priorities[i] += (item / cap)\n\n            # Prevent thrashing/fragmentation\n            remaining_after_fit = cap - item\n            if remaining_after_fit > 0:\n                priorities[i] -= np.abs(item - cap) / (item + cap + 1e-9)  # Penalize similar sized bins. Prevent trivial division by zero\n                priorities[i] -= (1/(remaining_after_fit + 0.0001)) if remaining_after_fit < 0.2 else 0 # strongly penalize if remmainder is very small\n\n            else:\n                 priorities[i] -=100  # make the bin very unattractive.\n                 # Ensure it's heavily penalized for completely filling the bin or creating negative remaining capacity\n\n        else:\n            priorities[i] = -np.inf # impossible to fit -> extremely low priority.\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}