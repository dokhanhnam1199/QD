```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version prioritizes bins that can accommodate the item with minimal wasted space,
    but also penalizes bins that are nearly full to encourage more balanced packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, remaining_capacity in enumerate(bins_remain_cap):
        if remaining_capacity >= item:
            # Calculate wasted space
            wasted_space = remaining_capacity - item

            # Prioritize bins with smaller wasted space (higher priority)
            # Add a small constant to avoid division by zero and extreme values. Also, prevents inf from arising from np.exp(-x) = inf when x approaches -inf

            priorities[i] = np.exp(-wasted_space)  # Exponential decay for wasted space
            # Penalize bins that are almost full. Avoids putting small items in near-full bins.
            # Scale this penalty based on how full the bin becomes after placing the item. Prevents bins that become very full from being excessively favored.

            fullness_after = item / remaining_capacity
            priorities[i] *= (1 - fullness_after)**0.5  # Apply diminishing returns penalty for nearly full bins
        else:
            priorities[i] = -np.inf  # Disqualify bins that cannot fit the item

    return priorities
```
