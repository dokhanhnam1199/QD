```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines best-fit, waste minimization, and adaptive weighting."""

    priorities = np.full(bins_remain_cap.shape, -np.inf)
    valid_bins = bins_remain_cap > 0

    if not np.any(valid_bins):
        return priorities

    remaining_capacities = bins_remain_cap[valid_bins]

    # Waste Score: Prioritize bins with minimal waste
    waste = np.maximum(0, remaining_capacities - item)
    waste_score = 1 / (waste + 1e-9)

    # Fit Score: Gaussian fit
    fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item / 3)**2))

    # Item Size Score: adapt based on item size.
    item_size_factor = min(1, item)  # Scale factor based on item size.  Cap at 1.

    # Adaptive Weighting: Adjust weights based on item size.  Heuristic core.
    waste_weight = 0.6 * (1 - item_size_factor/2) # smaller item, higher waste weight.
    fit_weight = 0.4 * (0.5 + item_size_factor/2)   # Bigger item, higher fit weight.

    # Combined Score
    combined_score = (
        waste_weight * waste_score +
        fit_weight * fit_score
    )

    priorities[valid_bins] = combined_score

    # Perfect Fit: Highest priority boost
    perfect_fit = np.abs(remaining_capacities - item) < 1e-6
    priorities[valid_bins][perfect_fit] += 5.0 #boost priority of perfect fit

    return priorities
```
