```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
       An enhanced embodiment of bin-packing elegance: A symphony of adaptive potential.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    valid_bins = bins_remain_cap > 0
    priorities = np.full(bins_remain_cap.shape, -np.inf)

    if np.any(valid_bins):
        remaining_capacities = bins_remain_cap[valid_bins]

        # Waste calculation with handling for exact fits.
        waste = np.maximum(0, remaining_capacities - item)

        # Score based on waste, penalizing large waste more.
        waste_score = np.exp(-waste / (item + 1e-9))  # Exponential decay of waste.

        # Fit Score: Gaussian fit, centered around item size.
        fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item/2)**2)) # item/2 makes the distribution a bit wider.

        # Capacity Utilization: Prioritize bins that are already relatively full.
        capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap[valid_bins])) if np.any(bins_remain_cap[valid_bins]) else 0 #Avoid division by zero

        # Smallest Bin First (SBF): Prioritize the smallest available bin that fits the item.
        smallest_bin_score = np.zeros_like(remaining_capacities)
        
        # Identify bins that fit the item.
        fitting_bins = remaining_capacities >= item
        
        if np.any(fitting_bins):
            # Find the smallest of those bins.
            min_fitting_capacity = np.min(remaining_capacities[fitting_bins])
            
            # Assign a high score to the smallest bin.  Scale down the score to avoid over-emphasis
            smallest_bin_score[remaining_capacities == min_fitting_capacity] = 1

        # Adaptive Weighting (Simplified): Adjust weights based on item size.

        if item < 0.3 * np.max(bins_remain_cap):  #smaller item
            waste_weight, fit_weight, capacity_weight, sbf_weight = 0.5, 0.3, 0.1, 0.1
        else:  # larger item
            waste_weight, fit_weight, capacity_weight, sbf_weight = 0.4, 0.4, 0.1, 0.1

        # Combined Score
        combined_score = (waste_weight * waste_score +
                          fit_weight * fit_score +
                          capacity_weight * capacity_utilization +
                          sbf_weight * smallest_bin_score)

        priorities[valid_bins] = combined_score

    return priorities
```
