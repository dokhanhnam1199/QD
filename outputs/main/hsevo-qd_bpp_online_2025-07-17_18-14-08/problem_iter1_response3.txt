```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
       This version prioritizes bins that have enough space, but not too much.
       It aims to avoid fragmentation and utilize bins more efficiently.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i, cap in enumerate(bins_remain_cap):
        if cap >= item:
            # Enough space: prioritize based on how much space will be left.
            remaining_space = cap - item
            # Give higher priority to bins that will have a small amount of space left.
            # Avoid excessive fragmentation, but also don't greedily fill bins if a better fit is possible.
            # The closer to zero the remaining space is, the higher the priority, with diminishing returns.
            priorities[i] = np.exp(-remaining_space) # try to make bins almost full.

            #Boosting bins that leave a bit space that might be usable later
            if 0 < remaining_space < 0.3 :
                priorities[i]+=0.1
        else:
            # Not enough space: priority is 0.
            priorities[i] = 0.0

    return priorities
```
