```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function considers several factors:

    1.  Whether the item fits in the bin.  If not, priority is -inf.
    2.  The fill ratio (item size / remaining capacity). Higher fill ratio is generally better,
        but we also want to avoid filling a bin *too* much (leaving very little space).
    3. A bonus for bins that are nearly full after adding the item, but not quite full
       (this encourages good packing but avoids perfect fits too early which may lead to
       inefficient packing later on.)

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full(bins_remain_cap.shape, -np.inf)  # Initialize with -inf

    # Bins where the item fits
    valid_bins = bins_remain_cap >= item

    if not np.any(valid_bins):
      return priorities # Return -inf if no bins fit.

    # Calculate fill ratios for valid bins
    fill_ratios = np.zeros_like(bins_remain_cap, dtype=float)
    fill_ratios[valid_bins] = item / bins_remain_cap[valid_bins]

    # Priority based on fill ratio (with a bit of a tweak)
    priorities[valid_bins] = fill_ratios[valid_bins]

    # Add a bonus for bins that are close to full after adding the item,
    # but not perfectly full
    remaining_after_fit = bins_remain_cap - item
    nearly_full_bonus = np.exp(-10 * remaining_after_fit) * valid_bins # Apply the bonus. Larger K -> closer to full is preferred.

    priorities += nearly_full_bonus
    return priorities
```
