[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities",
    "response_id": 0,
    "obj": 149.30195452732352,
    "SLOC": 5.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 11.60964047443681,
    "mi": 94.04446327225541,
    "token_count": 47.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Tesla's embodiment of electrical elegance: A symphony of potential.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Avoid zero capacity bins and division by zero.\n    valid_bins = bins_remain_cap > 0\n    priorities = np.full(bins_remain_cap.shape, -np.inf)  # Default to negative infinity.\n\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n\n        # Calculate the waste if we place the item in each bin. A lower waste\n        # suggests a better fit. Avoid negative waste using max(0).\n        waste = np.maximum(0, remaining_capacities - item)\n\n        # Score based on the inverse of the waste. To give higher preference to minimal waste\n        waste_score = 1 / (waste + 1e-9) # Adding a small value to avoid division by zero\n        \n        # Fit Score\n        fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item/3)**2)) # Gaussian Fit score favoring item to fit nicely in the bin.\n\n        # Preference for bins that can accommodate the item. Also incorporate remaining capacity\n        # to prioritize using more full bins first.\n        capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap))\n\n        # Combine the scoring components. Give weights to components\n        combined_score = 0.6 * waste_score + 0.3 * fit_score + 0.1 * capacity_utilization\n\n        priorities[valid_bins] = combined_score\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 3.0,
    "halstead": 88.0,
    "mi": 78.11172779494449,
    "token_count": 131.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter2_response6.txt_stdout.txt",
    "code_path": "problem_iter2_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines best-fit, perfect-fit, and waste minimization strategies.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect Fit: Highest priority\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit] += 100\n\n    # 2. Best Fit: Reward bins that fit with minimal waste.\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        waste = bins_remain_cap[fits] - item\n        best_fit_idx = np.argmin(waste)\n        indices = np.where(fits)[0]\n        best_fit_full_idx = indices[best_fit_idx]\n        priorities[best_fit_full_idx] += 50\n\n    # 3. Utilization Ratio:  Prioritize bins that are well-utilized after placing item.\n    valid_bins = bins_remain_cap > 0\n    utilization_ratio = item / bins_remain_cap[valid_bins]\n    priorities[valid_bins] += utilization_ratio * 10\n\n    # 4. Waste Minimization with Exponential Decay: Penalize larger waste values heavily.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins that don't fit\n    priorities -= np.exp(-(waste**2) / (2 * (item / 5)**2)) * 20\n\n    # 5. Avoid Nearly Full: Discourage leaving tiny spaces.\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap < item * 1.1)\n    priorities[nearly_full] -= 30\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 11.0,
    "cyclomatic_complexity": 1.0,
    "halstead": 210.90827503317323,
    "mi": 89.26677282872086,
    "token_count": 152.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter3_response0.txt_stdout.txt",
    "code_path": "problem_iter3_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Enhanced heuristic combining waste, fit, and remaining capacity considerations with adaptive elements.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap > 0\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n        \n        # Waste Score (Prioritize minimal waste)\n        waste = np.maximum(0, remaining_capacities - item)\n        waste_score = 1 / (waste + 1e-9)\n\n        # Fit Score (Gaussian-like, penalizing very tight or loose fits)\n        fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item / 2)**2))  # Adjusted std for potentially better fit\n\n        # Capacity Utilization Score (Encourage filling bins)\n        capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap))\n\n        # Remaining Capacity Score (favor bins with low remianing capacity)\n        remaining_capacity_score = 1 / (remaining_capacities + 1e-9)\n        \n        # Adaptive Weighting based on Item Size relative to Average Bin Size\n        avg_bin_capacity = np.mean(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else 1  # Avoid division by zero if all bins are full\n        item_ratio = item / avg_bin_capacity if avg_bin_capacity > 0 else 0 # normalize the item size relative to the average bin capacity\n\n        # Dynamic weight adjustment\n        if item_ratio < 0.2:\n             w_waste, w_fit, w_capacity, w_rem_cap = 0.3, 0.5, 0.1, 0.1  # Favor Fit for small items\n        elif item_ratio > 0.8:\n            w_waste, w_fit, w_capacity, w_rem_cap = 0.6, 0.1, 0.2, 0.1  # Favor Waste for large items\n        else:\n            w_waste, w_fit, w_capacity, w_rem_cap = 0.4, 0.3, 0.2, 0.1 # balanced weights otherwise\n\n        # Combined Score with Adaptive Weights\n        combined_score = (\n            w_waste * waste_score +\n            w_fit * fit_score +\n            w_capacity * capacity_utilization +\n            w_rem_cap * remaining_capacity_score\n        )\n\n        priorities[valid_bins] = combined_score\n\n    return priorities",
    "response_id": 0,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 31.0,
    "cyclomatic_complexity": 4.0,
    "halstead": 424.4571500548079,
    "mi": 78.30227068447415,
    "token_count": 279.0,
    "exec_success": true
  }
]