```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version considers both remaining capacity and waste.  Bins that
    have enough capacity and leave minimal waste are preferred.  We also
    introduce a small exploration factor to avoid getting stuck in local minima.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Avoid division by zero
    bins_remain_cap = np.clip(bins_remain_cap, 1e-9, None)

    # Calculate waste if item is placed in each bin. Negative values indicate not enough space
    waste = bins_remain_cap - item

    # Give bins that can accommodate the item a baseline priority of 1, and others 0
    priority = np.where(waste >= 0, 1.0, 0.0)

    # Further increase priority based on how *little* waste there is. This encourages filling bins well.
    # Using a Gaussian-like curve centered around zero waste
    priority += np.where(waste >= 0, np.exp(-(waste**2) / (2 * (item/5)**2)), 0.0)

    # Add a tiny amount proportional to the remaining capacity. This favors using less-full bins *slightly*.
    # Important that this is significantly smaller than other terms. This promotes even distribution but cares more about fitting well.
    priority += bins_remain_cap * 0.001

    # Add a small exploration factor to sometimes deviate from the "best" choice and potentially find better packings
    priority += np.random.rand(len(bins_remain_cap)) * 0.0001

    return priority
```
