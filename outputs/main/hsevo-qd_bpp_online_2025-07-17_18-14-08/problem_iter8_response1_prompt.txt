{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Combines best-fit, perfect-fit, and waste minimization strategies.\"\"\"\n\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # 1. Perfect Fit: Highest priority\n    perfect_fit = np.abs(bins_remain_cap - item) < 1e-6\n    priorities[perfect_fit] += 100\n\n    # 2. Best Fit: Reward bins that fit with minimal waste.\n    fits = bins_remain_cap >= item\n    if np.any(fits):\n        waste = bins_remain_cap[fits] - item\n        best_fit_idx = np.argmin(waste)\n        indices = np.where(fits)[0]\n        best_fit_full_idx = indices[best_fit_idx]\n        priorities[best_fit_full_idx] += 50\n\n    # 3. Utilization Ratio:  Prioritize bins that are well-utilized after placing item.\n    valid_bins = bins_remain_cap > 0\n    utilization_ratio = item / bins_remain_cap[valid_bins]\n    priorities[valid_bins] += utilization_ratio * 10\n\n    # 4. Waste Minimization with Exponential Decay: Penalize larger waste values heavily.\n    waste = bins_remain_cap - item\n    waste[waste < 0] = np.inf  # Ignore bins that don't fit\n    priorities -= np.exp(-(waste**2) / (2 * (item / 5)**2)) * 20\n\n    # 5. Avoid Nearly Full: Discourage leaving tiny spaces.\n    nearly_full = (bins_remain_cap > item) & (bins_remain_cap < item * 1.1)\n    priorities[nearly_full] -= 30\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combination of waste score, fit score, and capacity utilization, while the worst simply uses the negative log of the ratio of item size to remaining bin capacity. (2nd best) vs (second worst) shows that the 2nd best uses a rule-based approach with hardcoded priorities for perfect fit, best fit, and penalizes nearly full bins in contrast to the ratio based strategy of the second worst. Comparing (1st) vs (2nd), we see the top heuristic uses a combined score with weighted components for waste, fit, and utilization while the second uses discrete rules and prioritized perfect fit. (3rd) vs (4th) is not very insightful because they are the same. Comparing (second worst) vs (worst), we see that the only difference is the import statements at the top. Overall: the better heuristics use more sophisticated scoring mechanisms that take into account multiple factors such as waste, fit, and utilization, often combining them with weighted averages or rule-based priorities. Worse heuristics rely on simplistic ratios. Introduction of adaptive weighting and gaussian fit scaling in some cases makes performance better.\n- \nOkay, let's refine \"Current Self-Reflection\" to make it more actionable for designing better heuristics, keeping in mind what to avoid from the \"Ineffective Self-Reflection\".\n\nHere's a revised approach:\n\n*   **Keywords:** Adaptive strategies, multi-objective optimization, dynamic weighting, performance feedback.\n*   **Advice:** Design heuristics that dynamically adjust their behavior based on real-time performance metrics and problem characteristics. Focus on identifying key features of the problem instance that influence heuristic effectiveness.\n*   **Avoid:** Predefined static weights or bonuses/penalties without data-driven justification. Vague calls for \"balance\" without specifying how to achieve it.\n*   **Explanation:** Instead of hand-tuning, aim for self-tuning heuristics. Collect data on heuristic performance during execution and use that data to refine parameters (e.g., using reinforcement learning or online optimization).\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}