```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.  Inspired by energy minimization and a bit of quantum tunneling.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the "potential energy" increase by adding the item. Lower energy preferred.
    potential_energy = (bins_remain_cap - item)**2
    potential_energy[bins_remain_cap - item < 0] = np.inf # Infinite energy if it doesn't fit

    # "Quantum tunneling" probability: Higher chance to tunnel into nearly full bins if we're desperate.
    tunneling_factor = np.exp(-10 * np.abs(bins_remain_cap - item) / item) #Exponential decay. Experiment with the scaling.

    # A small term to encourage using emptier bins (explore). This can prevent local optima.
    exploration_bonus = 0.01 * bins_remain_cap

    # Combine these to get a priority: Want to minimize energy, maximize tunneling when needed, and explore.
    priority = -potential_energy + tunneling_factor + exploration_bonus
    
    return priority
```
