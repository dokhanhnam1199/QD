```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the waste if the item is placed in the bin
    waste = bins_remain_cap - item

    # Give a very low priority (high negative number) to bins that can't fit the item
    priority = np.where(waste < 0, -1e9, 0)

    # Prioritize bins that have the smallest waste (smallest remaining space).
    # Use a slightly different approach to avoid dividing by zero or taking the log of zero
    # and to add some small randomness to break ties and explore different packings.
    valid_bins = waste[waste >= 0]
    if valid_bins.size > 0:
        min_waste = np.min(valid_bins)

        # Add a bonus for bins that have waste close to the minimum waste
        priority[waste >= 0] += 1 / (1 + np.abs(waste[waste >= 0] - min_waste)) + np.random.rand(waste[waste>=0].size)*0.1 # add tiny random element

    # Further prioritize bins with capacity closest to twice the item size. The item should preferably fill half the space left.
    target_capacity = 2 * item
    proximity = np.abs(bins_remain_cap - target_capacity)
    priority = priority - proximity/bins_remain_cap #Smaller proximity to target_capacity gives larger score (more negative is better)

    return priority
```
