{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n       A multifactorial, adaptive approach to bin selection.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n    valid_bins = bins_remain_cap > 0\n\n    if not np.any(valid_bins):\n        return priorities\n\n    remaining_capacities = bins_remain_cap[valid_bins]\n\n    # Waste Score: Prioritize bins with minimal waste\n    waste = np.maximum(0, remaining_capacities - item)\n    waste_score = 1 / (waste + 1e-9)\n\n    # Fit Score: Gaussian fit, as before, but potentially refined\n    fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item / 3)**2))\n\n    # Capacity Utilization: Favor bins that are already somewhat full\n    capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap))\n\n    # Remaining Capacity Score: Discourage very small remaining capacity\n    remaining_capacity_score = np.where(remaining_capacities > item, remaining_capacities / np.max(bins_remain_cap), 0) # Only if it can fit, favor higher remaining capacity.\n\n    # Item Size Score: adapt based on item size. Big items need better fit.\n    item_size_factor = min(1, item)  # Scale factor based on item size.  Cap at 1.\n\n    # Adaptive Weighting: Adjust weights based on item size.  Heuristic core.\n    waste_weight = 0.4 * (1 - item_size_factor/2) # smaller item, higher waste weight.\n    fit_weight = 0.4 * (0.5 + item_size_factor/2)   # Bigger item, higher fit weight.\n    capacity_weight = 0.1 * (1 - item_size_factor/2) # smaller item, higher capacity weight.\n    remaining_weight = 0.1 * (0.5 + item_size_factor/2)  # Bigger item, higher remaining capacity.\n\n    # Combined Score\n    combined_score = (\n        waste_weight * waste_score +\n        fit_weight * fit_score +\n        capacity_weight * capacity_utilization +\n        remaining_weight * remaining_capacity_score\n    )\n\n    priorities[valid_bins] = combined_score\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n                large_item_threshold: float = 0.5152608427120331, medium_item_threshold: float = 0.11232322272170905,\n                large_item_waste_weight: float = 0.7922777406161803, large_item_fit_weight: float = 0.366663934509556, large_item_capacity_weight: float = -0.042049719220680216,\n                medium_item_waste_weight: float = 0.5847694031591075, medium_item_fit_weight: float = 0.3765469275232734, medium_item_capacity_weight: float = 0.10612888335318736,\n                small_item_waste_weight: float = 0.23402459284841715, small_item_fit_weight: float = 0.22412856156232097, small_item_capacity_weight: float = 0.38991632701567336,\n                bin_utilization_threshold: float = 0.8178247005642613, bin_utilization_waste_adjust: float = 0.1947381836237003,\n                bin_utilization_fit_adjust: float = 0.1659780275520785, bin_utilization_capacity_adjust: float = -0.19020181378233386) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Adaptive weights based on bin utilization and item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        waste_score_epsilon: Small value to prevent division by zero in waste score calculation.\n        large_item_threshold: Item size ratio above which an item is considered large.\n        medium_item_threshold: Item size ratio above which an item is considered medium.\n        large_item_waste_weight: Weight for waste score when item is large.\n        large_item_fit_weight: Weight for fit score when item is large.\n        large_item_capacity_weight: Weight for capacity utilization when item is large.\n        medium_item_waste_weight: Weight for waste score when item is medium.\n        medium_item_fit_weight: Weight for fit score when item is medium.\n        medium_item_capacity_weight: Weight for capacity utilization when item is medium.\n        small_item_waste_weight: Weight for waste score when item is small.\n        small_item_fit_weight: Weight for fit score when item is small.\n        small_item_capacity_weight: Weight for capacity utilization when item is small.\n        bin_utilization_threshold: Bin utilization ratio above which adjustment to weights is applied.\n        bin_utilization_waste_adjust: Adjustment to waste weight when bin utilization is high.\n        bin_utilization_fit_adjust: Adjustment to fit weight when bin utilization is high.\n        bin_utilization_capacity_adjust: Adjustment to capacity weight when bin utilization is high.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap > 0\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n        \n        waste = np.maximum(0, remaining_capacities - item)\n        waste_score = 1 / (waste + waste_score_epsilon)\n\n        fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item/3)**2))\n\n        capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap))\n\n        # Adaptive weights based on item size and bin utilization.\n        item_size_ratio = item / np.max(bins_remain_cap)  # Ratio of item size to max bin capacity\n        bin_utilization_ratio = 1 - (remaining_capacities / np.max(bins_remain_cap)) # Current bin utilization\n\n        # Adjust weights based on item size.\n        if item_size_ratio > large_item_threshold:\n            # Large item: Prioritize waste and fit to avoid fragmentation.\n            waste_weight = large_item_waste_weight\n            fit_weight = large_item_fit_weight\n            capacity_weight = large_item_capacity_weight\n        elif item_size_ratio > medium_item_threshold:\n            # Medium item: Balance waste, fit, and utilization.\n            waste_weight = medium_item_waste_weight\n            fit_weight = medium_item_fit_weight\n            capacity_weight = medium_item_capacity_weight\n        else:\n            # Small item: Prioritize utilization to fill bins.\n            waste_weight = small_item_waste_weight\n            fit_weight = small_item_fit_weight\n            capacity_weight = small_item_capacity_weight\n            \n        # Adaptive weight adjustment based on bin utilization\n        if np.any(bin_utilization_ratio > bin_utilization_threshold): # If any bin is more than 80% full, prioritize fitting.\n            waste_weight += bin_utilization_waste_adjust\n            fit_weight += bin_utilization_fit_adjust\n            capacity_weight += bin_utilization_capacity_adjust\n            \n        waste_weight = np.clip(waste_weight, 0, 1) #Making sure weights are between 0 and 1\n        fit_weight = np.clip(fit_weight, 0, 1)\n        capacity_weight = np.clip(capacity_weight, 0, 1)\n\n        combined_score = waste_weight * waste_score + fit_weight * fit_score + capacity_weight * capacity_utilization\n\n        priorities[valid_bins] = combined_score\n\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (2nd), the primary difference is the inclusion of a \"diversity score\" based on the standard deviation of remaining bin capacities in the 1st heuristic. This suggests an attempt to balance bin utilization across all available bins.\n\nComparing (2nd) vs (5th), these are identical.\n\nComparing (1st) vs (3rd), they are identical.\n\nComparing (3rd) vs (4th), they are identical.\n\nComparing (4th) vs (6th), they are identical.\n\nComparing (6th) vs (7th), they are identical.\n\nComparing (7th) vs (8th), they are identical.\n\nComparing (8th) vs (9th), the 8th uses a more intricate and adaptive weighting scheme based on item size, incorporating waste, fit, capacity utilization, and remaining capacity. The 9th uses a simplified fixed weighting.\n\nComparing (9th) vs (10th), both combine waste, fit, and capacity utilization, but (9th) includes \"adaptive weighting\" even though it's just a fixed weighting. (10th) does not claim adaptive weighting and simply uses fixed weights.\n\nComparing (10th) vs (13th), these are identical.\n\nComparing (11th) vs (12th), The 11th has waste_score calculation while the 12th doesn't.\n\nComparing (12th) vs (15th), these are identical.\n\nComparing (14th) vs (16th), The 14th uses a complex system of adaptive weights based on both item size and bin utilization, and a lot of parameters, while the 16th uses adaptive weights based only on item size. Also, the 14th introduces several parameters that need to be fine-tuned.\n\nComparing (16th) vs (17th), The 16th is a more developed heuristic that adapts to cases where the item doesn't fit, while the 17th focuses on waste minimization, gaussian fit score, and capacity utilization when the item fits.\n\nComparing (17th) vs (18th), the 18th attempts adaptive weighting (though simplified), the 17th uses a fixed weighting.\n\nComparing (18th) vs (19th), The 18th is a multifactorial approach combining waste, fit, and capacity utilization, while the 19th is a single-factor approach based solely on the ratio of item size to remaining bin capacity. Also, (18th) use adaptive weighting while (19th) doesn't.\n\nComparing (19th) vs (20th), these are identical.\n\nOverall: The better heuristics generally incorporate more factors (waste, fit, capacity utilization, remaining capacity, bin diversity) and employ adaptive weighting schemes based on item size and bin utilization. Simpler heuristics focus on fewer factors with fixed weights or a single factor. The best heuristic attempts to balance bin utilization by penalizing low diversity of bin capacities.\n- \nOkay, I'll craft a redefined self-reflection on heuristic design for bin packing, focusing on actionable insights and avoiding pitfalls.\n\n**Redefined Self-Reflection:**\n\n*   **Keywords:** Multifactorial, Adaptive Weighting, Bin States, Diversity, Constraint Handling, Complex Scoring.\n\n*   **Advice:** Integrate multiple, *independent* factors (item characteristics, bin state, diversity metrics). Adapt weights based on *dynamic* problem state using *non-linear* functions (e.g., Gaussian). Explicitly address infeasibility. Employ *complex* scoring mechanism such as Gaussian fit score.\n\n*   **Avoid:** Vague \"combinations,\" simplistic ratios, static weights, focusing *solely* on waste/capacity, neglecting diversity or infeasibility.\n\n*   **Explanation:** Effective heuristics require combining diverse information signals. Adaptive weighting should dynamically respond to problem state. Infeasibility needs dedicated handling. Complexity, when justified by performance gains, is valuable.\n\nI can further refine this if you give me specific areas you want me to focus on (e.g., types of diversity metrics, specific adaptive weighting functions, or methods for handling infeasibility). Let me know!\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}