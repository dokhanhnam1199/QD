```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
       Tesla's embodiment of electrical elegance: A symphony of potential.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.full(bins_remain_cap.shape, -np.inf)
    valid_bins = bins_remain_cap >= item
    
    if np.any(valid_bins):
        remaining_capacities = bins_remain_cap[valid_bins]
        
        waste = remaining_capacities - item
        
        # Waste Score (lower is better)
        waste_score = 1 / (waste + 1e-9)
        
        # Fit Score (Gaussian-like, centered around a good fit)
        fit_score = np.exp(-(waste)**2 / (2 * (item/2)**2))
        
        # Capacity Utilization (higher is better, avoid filling almost full bins)
        capacity_utilization = (bins_remain_cap[valid_bins] - item) / np.max(bins_remain_cap)
        capacity_utilization = np.clip(capacity_utilization, 0, 1) # Ensure between 0 and 1

        #Balance Score (favors bins that would become about half full after insertion)
        balance_target = np.max(bins_remain_cap) / 2
        balance_score = np.exp(-((bins_remain_cap[valid_bins] - item) - balance_target)**2 / (2 * (balance_target/3)**2))
        
        # Combined Score with dynamic weights based on item size
        item_size_factor = item / np.max(bins_remain_cap)  # Normalize item size

        # Adjust weights based on the item size
        waste_weight = 0.4 if item_size_factor < 0.5 else 0.2
        fit_weight = 0.3 if item_size_factor < 0.5 else 0.5
        capacity_weight = 0.1 + item_size_factor * 0.2 # Increase importance for larger items
        balance_weight = 0.2 - item_size_factor * 0.1 if item_size_factor < 0.5 else 0.05 #Decrease Importance for larger Items

        combined_score = (waste_weight * waste_score +
                          fit_weight * fit_score +
                          capacity_weight * capacity_utilization +
                          balance_weight * balance_score)
        
        priorities[valid_bins] = combined_score
        
    return priorities
```
