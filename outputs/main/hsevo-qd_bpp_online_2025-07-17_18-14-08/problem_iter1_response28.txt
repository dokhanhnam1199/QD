```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """

    # Avoid division by zero
    valid_bins = bins_remain_cap > 0
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    if np.any(valid_bins):
        remaining_cap_valid = bins_remain_cap[valid_bins]

        # First priority: Can the item fit at all?
        can_fit = item <= remaining_cap_valid
        
        #If it cannot fit anywhere, assign all priorities 0
        if not np.any(can_fit):
            return priorities
        
        # Next priority: Minimize wasted space.  The closer the item size
        # is to the remaining capacity, the higher the priority.  We want
        # to fill the bins as completely as possible. Use only bins where the item fits.
        waste = remaining_cap_valid - item
        waste[waste < 0] = np.inf # very large value

        #Give only the available bins priorities
        valid_bins_indices = np.where(valid_bins)[0]
        
        waste_valid_can_fit = waste[can_fit]

        priorities_valid_can_fit = -waste_valid_can_fit # Smaller waste is better (negative of waste).

        can_fit_indices_in_valid = np.where(can_fit)[0]
        can_fit_global_indices = valid_bins_indices[can_fit_indices_in_valid]

        priorities[can_fit_global_indices] = priorities_valid_can_fit

    return priorities
```
