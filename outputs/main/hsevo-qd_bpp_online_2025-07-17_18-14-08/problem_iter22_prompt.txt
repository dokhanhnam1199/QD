{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n       Adaptive weights based on bin utilization and item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap > 0\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n        \n        waste = np.maximum(0, remaining_capacities - item)\n        waste_score = 1 / (waste + 1e-9)\n\n        fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item/3)**2))\n\n        capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap))\n\n        # Adaptive weights based on item size and bin utilization.\n        item_size_ratio = item / np.max(bins_remain_cap)  # Ratio of item size to max bin capacity\n        bin_utilization_ratio = 1 - (remaining_capacities / np.max(bins_remain_cap)) # Current bin utilization\n\n        # Adjust weights based on item size.\n        if item_size_ratio > 0.5:\n            # Large item: Prioritize waste and fit to avoid fragmentation.\n            waste_weight = 0.7\n            fit_weight = 0.3\n            capacity_weight = 0.0\n        elif item_size_ratio > 0.2:\n            # Medium item: Balance waste, fit, and utilization.\n            waste_weight = 0.5\n            fit_weight = 0.3\n            capacity_weight = 0.2\n        else:\n            # Small item: Prioritize utilization to fill bins.\n            waste_weight = 0.3\n            fit_weight = 0.3\n            capacity_weight = 0.4\n            \n        # Adaptive weight adjustment based on bin utilization\n        if np.any(bin_utilization_ratio > 0.8): # If any bin is more than 80% full, prioritize fitting.\n            waste_weight += 0.1\n            fit_weight += 0.1\n            capacity_weight -= 0.2\n            \n        waste_weight = np.clip(waste_weight, 0, 1) #Making sure weights are between 0 and 1\n        fit_weight = np.clip(fit_weight, 0, 1)\n        capacity_weight = np.clip(capacity_weight, 0, 1)\n\n        combined_score = waste_weight * waste_score + fit_weight * fit_score + capacity_weight * capacity_utilization\n\n        priorities[valid_bins] = combined_score\n\n    return priorities\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}