{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Enhanced heuristic combining waste, fit, and remaining capacity considerations with adaptive elements.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    valid_bins = bins_remain_cap > 0\n    priorities = np.full(bins_remain_cap.shape, -np.inf)\n\n    if np.any(valid_bins):\n        remaining_capacities = bins_remain_cap[valid_bins]\n        \n        # Waste Score (Prioritize minimal waste)\n        waste = np.maximum(0, remaining_capacities - item)\n        waste_score = 1 / (waste + 1e-9)\n\n        # Fit Score (Gaussian-like, penalizing very tight or loose fits)\n        fit_score = np.exp(-(remaining_capacities - item)**2 / (2 * (item / 2)**2))  # Adjusted std for potentially better fit\n\n        # Capacity Utilization Score (Encourage filling bins)\n        capacity_utilization = 1 - (remaining_capacities / np.max(bins_remain_cap))\n\n        # Remaining Capacity Score (favor bins with low remianing capacity)\n        remaining_capacity_score = 1 / (remaining_capacities + 1e-9)\n        \n        # Adaptive Weighting based on Item Size relative to Average Bin Size\n        avg_bin_capacity = np.mean(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else 1  # Avoid division by zero if all bins are full\n        item_ratio = item / avg_bin_capacity if avg_bin_capacity > 0 else 0 # normalize the item size relative to the average bin capacity\n\n        # Dynamic weight adjustment\n        if item_ratio < 0.2:\n             w_waste, w_fit, w_capacity, w_rem_cap = 0.3, 0.5, 0.1, 0.1  # Favor Fit for small items\n        elif item_ratio > 0.8:\n            w_waste, w_fit, w_capacity, w_rem_cap = 0.6, 0.1, 0.2, 0.1  # Favor Waste for large items\n        else:\n            w_waste, w_fit, w_capacity, w_rem_cap = 0.4, 0.3, 0.2, 0.1 # balanced weights otherwise\n\n        # Combined Score with Adaptive Weights\n        combined_score = (\n            w_waste * waste_score +\n            w_fit * fit_score +\n            w_capacity * capacity_utilization +\n            w_rem_cap * remaining_capacity_score\n        )\n\n        priorities[valid_bins] = combined_score\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- *   **(1st) vs (20th):** The best heuristic uses a combination of waste score, fit score, and capacity utilization, with adaptive weighting based on the item size relative to the maximum bin capacity. It also handles the case where no bin can accommodate the item. The worst heuristic simply calculates the negative log of the ratio of item size to remaining bin capacity.\n*   **(2nd) vs (19th):** The second-best heuristic refines the approach of the best one but does not have additional logic to handle when no bins can accommodate the item. It uses slightly different adaptive weighting and fit score calculations. The 19th heuristic, like the 20th, uses only the log ratio calculation, which is overly simplistic.\n*   **(3rd) vs (18th):** The third-best heuristic is very similar to the first, including the handling of cases where no bin can fit the item. The 18th is similar to the 19th and 20th.\n*   **(4th) vs (17th):** The 4th heuristic still considers waste, fit, and capacity, and utilizes item size adaptive weighting. But this adaptive weighting mechanism compares item size with the *mean* of bin capacities, which can be less effective than comparing with the maximum capacity. The 17th uses only the log ratio.\n*   **(5th) vs (16th):** The fifth-best simplifies the adaptive weighting part of the best ones, assigning fixed weights. The 16th uses the single log ratio.\n*   **(6th) vs (15th):** The sixth-best heuristic introduces the concept of perfect fit, best fit, and utilization ratio, penalizing waste and nearly full bins. 15th is the log ratio.\n*   **(7th) vs (14th):** 7th is almost as good as first. It improves upon previous heuristics by incorporating a \"remaining capacity score\" and adjusting the weights based on the item size relative to the *average* bin capacity (a detail that makes it less effective than using max bin capacity).\n*   **(8th) vs (13th):** The 8th heuristic is similar to the top ones in that it uses waste score, fit score and capacity utilization, and provides configurable parameters, but lacks adaptive weighting based on item size, making it less flexible. The 13th calculates only the log ratio.\n*   **(9th) vs (12th):** The 9th one is just like the 2nd one. The 12th calculates the log ratio.\n*   **(10th) vs (11th):** The 10th heuristic combines perfect fit, best fit, and adaptive weighting based on average utilization. However, its adaptive weighting only adjusts based on a high average utilization, instead of item size. The 11th uses the log ratio calculation.\n\nOverall: The best heuristics consider multiple factors such as waste, fit, and capacity utilization. Adaptive weighting based on the item size relative to the bin capacities (especially max capacity) improves performance. Handling edge cases, such as no bins fitting the item, is also beneficial. Simpler heuristics that rely on a single metric such as log ratios perform poorly.\n- \nOkay, let's redefine self-reflection for designing bin packing heuristics, focusing on actionable insights and avoiding vague advice.\n\nHere's a revised structure for self-reflection:\n\n*   **Keywords:** Bin Packing, Multi-Factor, Adaptive Weights, Edge Cases.\n\n*   **Advice:** When combining factors, define *specific* interaction rules and triggers for adaptive weights *before* implementation. Consider if these strategies can be easily parallelized.\n\n*   **Avoid:** Vague statements like \"strive for balance\" or \"explore adaptive weighting\" without *specific* guidance. Don't just say \"combine factors\"; specify *how* and *why*. Avoid hand-wavy mathematical function choices.\n\n*   **Explanation:** The goal is to move from general principles to concrete design choices. Prioritize specifying conditions, decision criteria, and testable hypotheses. Focus on implementing well-defined and testable strategies, e.g., adapt weight when a particular ratio is reached and so on.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}