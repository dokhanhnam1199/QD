```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for each bin using an adaptive, sensitivity-aware
    strategy for the online Bin Packing Problem.

    This heuristic aims to balance "Best Fit" (minimizing waste) with a
    "First Fit Decreasing"-like tendency by slightly favoring bins that are
    less full initially, but can still accommodate the item. It also incorporates
    an adaptive component that can subtly shift focus based on the diversity
    of available bin capacities.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # --- Core Heuristic Component: Best Fit / Least Waste ---
    # Prioritize bins that leave minimal remaining capacity after packing.
    # A lower (valid_bins_remain_cap - item) is better.
    waste = valid_bins_remain_cap - item
    best_fit_scores = -waste  # Maximize this score (minimize waste)

    # --- Adaptive Component: Sensitivity to Bin Fullness ---
    # Introduce a term that favors bins that are not excessively full *before*
    # packing, but are still valid. This encourages spreading items initially,
    # while still respecting the 'best fit' for the current item.
    # We can achieve this by looking at the distribution of current bin capacities.
    # If there's high variance in remaining capacities, we might slightly favor
    # bins with more remaining capacity (but still fit the item).
    # If capacities are very similar, focus more on best fit.

    # Calculate a 'spread' factor based on the standard deviation of *all* bins' remaining capacities.
    # A higher std dev means more diverse capacities.
    if bins_remain_cap.size > 1:
        std_dev_all_bins = np.std(bins_remain_cap)
        # Normalize std_dev by the average capacity to make it somewhat scale-invariant.
        # Add a small epsilon to avoid division by zero.
        avg_cap_all_bins = np.mean(bins_remain_cap) + 1e-9
        spread_factor = std_dev_all_bins / avg_cap_all_bins
    else:
        spread_factor = 0 # No spread if only one bin

    # The adaptive score component:
    # We want to increase the priority of bins with *more* remaining capacity
    # when the spread_factor is high.
    # Let's use the relative remaining capacity (valid_bins_remain_cap / bin_capacity_max_possible)
    # for this term. Or simpler, just the raw remaining capacity.
    # We want to positively correlate with remaining capacity, scaled by spread_factor.
    # A simple approach: `spread_factor * (valid_bins_remain_cap / max_possible_capacity)`
    # Let's use a simplified approach focusing on relative difference for now.
    # We want to favor bins that are "less full" when spread is high.
    # `valid_bins_remain_cap` is a proxy for "less full".
    # So, a term like `spread_factor * valid_bins_remain_cap` could be added.

    # A more nuanced approach: use the 'gap' (capacity - item)
    # We want to penalize bins that result in a very small gap (best fit).
    # Consider `spread_factor * (item / valid_bins_remain_cap)` - encourages using bins with more space
    # when spread is high.

    # Let's combine the two:
    # Priority = w1 * (-waste) + w2 * (adaptive_term)
    # We want to favor smaller waste.
    # The adaptive term should make bins with *more* remaining capacity more attractive
    # when `spread_factor` is high.

    # Let's try a score that combines best-fit and a tendency to use bins
    # that are not *critically* full.
    # Score = BestFitScore - PenaltyForBeingTooFull
    # PenaltyForBeingTooFull could be related to `1 / valid_bins_remain_cap` or `(max_cap - valid_bins_remain_cap)`.

    # A new composite score:
    # Base score: -(waste)  (favors minimal waste)
    # Adaptive modifier: A term that slightly boosts bins with more remaining capacity,
    # but this boost is stronger when `spread_factor` is higher.
    # Consider `spread_factor * (valid_bins_remain_cap / average_remaining_capacity_of_valid_bins)`
    # This gives a relative measure of how much space is left in a bin compared to average.

    avg_valid_remain_cap = np.mean(valid_bins_remain_cap) + 1e-9
    relative_remaining_cap = valid_bins_remain_cap / avg_valid_remain_cap

    # The adaptive score: a multiplicative boost based on spread and relative remaining capacity.
    # We want to amplify the priority of bins that are relatively spacious when diversity is high.
    # This is a soft preference, not overriding best-fit entirely.
    # A small additive term is safer for Softmax stability.
    adaptive_scores = spread_factor * (relative_remaining_cap - 1.0) # Center around 0, positive for more remaining cap

    # Combine scores: best_fit_scores are already designed to be maximized.
    # adaptive_scores are also designed to be maximized (positive means good)
    combined_scores = best_fit_scores + adaptive_scores

    # Softmax to convert scores into probabilities (priorities)
    # Shift scores to prevent overflow/underflow in exp.
    if np.all(np.isfinite(combined_scores)):
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        # Handle potential NaNs or Infs by reverting to a simple best-fit if calculation fails
        # (though the logic above should prevent this with epsilon)
        shifted_scores = best_fit_scores - np.max(best_fit_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)


    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
