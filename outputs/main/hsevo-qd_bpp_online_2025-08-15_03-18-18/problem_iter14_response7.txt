```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic combining Best Fit with adaptive diversification based on variance.

    Prioritizes bins minimizing waste (Best Fit) and encourages exploration
    of less utilized bins when diversity is low.
    """
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Best Fit Score: Minimize remaining capacity after placement
    best_fit_scores = -(suitable_bins_remain_cap - item)

    # Adaptive Diversification Score: Encourage exploration when bins are similar
    # Use the standard deviation of remaining capacities of suitable bins
    if len(suitable_bins_remain_cap) > 1:
        std_dev_suitable = np.std(suitable_bins_remain_cap)
        # If std_dev is small, bins are similar, penalize "best fit" slightly to diversify
        # If std_dev is large, bins are diverse, rely more on "best fit"
        # Adding std_dev as a bonus to encourage exploration of diverse bins
        # Scale std_dev to avoid overwhelming the best_fit_scores
        diversity_bonus = 0.1 * std_dev_suitable
        combined_scores = best_fit_scores + diversity_bonus
    else:
        combined_scores = best_fit_scores

    # Softmax for probabilistic selection: Convert scores to probabilities
    # Shift scores to prevent overflow/underflow before exponentiation
    if np.max(combined_scores) - np.min(combined_scores) > 1e-9:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        sum_exp_scores = np.sum(exp_scores)
        if sum_exp_scores > 1e-9:
            probabilities = exp_scores / sum_exp_scores
        else:
            # Fallback if all exponentiated scores are effectively zero
            probabilities = np.ones_like(combined_scores) / len(combined_scores)
    else:
        # If all combined scores are the same, assign equal probability
        probabilities = np.ones_like(combined_scores) / len(combined_scores)

    priorities[valid_bins_mask] = probabilities

    return priorities
```
