```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Combines perfect fit bonus and normalized inverse proximity with adaptive diversification."""
    
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit, return uniform probabilities to encourage new bin creation or exploration
    if not np.any(can_fit_mask):
        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)
        
    # Calculate effective remaining capacities for fitting bins
    # Add a small epsilon for numerical stability to avoid division by zero
    effective_capacities = bins_remain_cap[can_fit_mask] - item + 1e-9 
    
    # Assign scores: perfect fits get a high bonus, others get inverse proximity
    scores = np.zeros_like(effective_capacities, dtype=float)
    
    perfect_fit_mask = effective_capacities < 1e-9 # Check for near-perfect fits due to epsilon
    scores[perfect_fit_mask] = 10.0  # Significant bonus for perfect fits
    
    # For non-perfect fits, use inverse proximity to reward tighter fits.
    # Scale inverse proximity to keep it in a comparable range to the perfect fit bonus.
    non_perfect_fit_mask = ~perfect_fit_mask
    scores[non_perfect_fit_mask] = 1.0 / effective_capacities[non_perfect_fit_mask] * 2.0 # Scale to keep values reasonable
    
    # Apply scores to the corresponding bins
    priorities[can_fit_mask] = scores
    
    # Normalize priorities using Softmax for probabilistic selection
    # Subtract max score for numerical stability before exponentiation
    max_score = np.max(priorities[can_fit_mask])
    exp_scores = np.exp(priorities[can_fit_mask] - max_score)
    
    normalized_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    normalized_priorities[can_fit_mask] = exp_scores / np.sum(exp_scores)
    
    return normalized_priorities
```
