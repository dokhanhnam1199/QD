```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for each bin using an adaptive Softmax-Based Fit
    strategy for the online Bin Packing Problem.

    This strategy prioritizes bins that can accommodate the item, favoring those
    that result in less remaining capacity (better fit) while also incorporating
    an adaptive temperature parameter for balancing exploitation and exploration.
    It also explicitly rewards perfect fits.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    valid_bins_mask = bins_remain_cap >= item

    if not np.any(valid_bins_mask):
        return np.zeros_like(bins_remain_cap)

    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Calculate the remaining capacity after placing the item in valid bins
    remaining_after_fit = valid_bins_remain_cap - item

    # Prioritize bins with smaller remaining capacity (better fit)
    # We use the negative of remaining capacity to favor smaller values when maximizing.
    # Add a large constant to ensure all scores are positive before exponentiation.
    scores = -remaining_after_fit + 1e6

    # Identify perfect fits
    perfect_fit_mask = np.isclose(remaining_after_fit, 0)
    if np.any(perfect_fit_mask):
        # Significantly boost the score for perfect fits to make them highly preferred
        scores[perfect_fit_mask] += 1e9

    # Adaptive Temperature (T) for Softmax.
    # A lower temperature leads to more greedy selection (closer to argmax).
    # A higher temperature leads to more exploration (closer to uniform).
    # We can adapt T based on the variance of remaining capacities or the number of items packed.
    # For simplicity here, let's use a T that decreases as the average remaining capacity decreases,
    # implying bins are getting fuller, making finer fits more critical.
    # Alternatively, a simpler adaptive approach could be based on the number of valid bins.
    # If there are many options, explore more. If few options, be more greedy.

    num_valid_bins = len(valid_bins_remain_cap)
    # Example adaptive temperature: inversely proportional to number of valid bins, with a floor.
    # This encourages exploration when there are many choices.
    temperature = max(0.1, 5.0 / num_valid_bins)

    # Apply Softmax with adaptive temperature
    # Shift scores to prevent overflow/underflow with exponentiation
    shifted_scores = scores - np.max(scores)
    exp_scores = np.exp(shifted_scores / temperature)
    probabilities = exp_scores / np.sum(exp_scores)

    # Create the final priority array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
