```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit tendency with an explicit reward for perfect fits,
    using Softmax for probabilistic selection to balance exploitation and exploration.
    """
    bin_capacities = 1.0  # Assuming a standard bin capacity of 1.0
    
    valid_bins_mask = bins_remain_cap >= item
    
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    if not np.any(valid_bins_mask):
        return priorities
        
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    
    # Calculate the "misfit" (remaining capacity after placing item) for valid bins
    misfits = valid_bins_remain_cap - item
    
    # Assign higher scores to bins with smaller misfits (Best Fit tendency)
    # Use inverse of misfit + epsilon to avoid division by zero and provide a score.
    # Scale by item size to normalize impact across different item sizes.
    best_fit_scores = 1.0 / (misfits + 1e-9) / (item + 1e-9)
    
    # Add a significant bonus for perfect fits (misfit is zero or very close)
    perfect_fit_bonus = 100.0  # A large bonus to strongly prioritize perfect fits
    perfect_fit_mask = np.abs(misfits) < 1e-6
    best_fit_scores[perfect_fit_mask] += perfect_fit_bonus
    
    # Apply Softmax to convert scores into probabilities
    # Shift scores to avoid numerical instability with large values
    shifted_scores = best_fit_scores - np.max(best_fit_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)
    
    priorities[valid_bins_mask] = probabilities
    
    return priorities
```
