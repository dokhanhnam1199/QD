```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Prioritizes bins by rewarding perfect fits and then favoring tighter fits using inverse proximity, normalized via Softmax.

    Combines the 'perfect fit' bonus from priority_v0 with the normalized inverse proximity of priority_v1.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Identify bins where the item can fit
    can_fit_mask = bins_remain_cap >= item
    
    # Calculate effective remaining capacities for fitting bins
    effective_capacities = bins_remain_cap[can_fit_mask] - item
    
    # Assign scores: perfect fits get a bonus, others get inverse proximity
    scores = np.zeros_like(effective_capacities, dtype=float)
    
    perfect_fit_mask = effective_capacities == 0
    scores[perfect_fit_mask] = 1.0  # High priority for perfect fits
    
    # For non-perfect fits, use inverse proximity to reward tighter fits
    non_perfect_fit_mask = ~perfect_fit_mask
    scores[non_perfect_fit_mask] = 1.0 / (effective_capacities[non_perfect_fit_mask] + 1e-9)
    
    # Apply scores to the corresponding bins
    priorities[can_fit_mask] = scores
    
    # If no bins can fit the item, return uniform probabilities
    if not np.any(can_fit_mask):
        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)
        
    # Normalize priorities using Softmax to get a probability distribution
    # Subtract max score for numerical stability before exponentiation
    max_score = np.max(priorities[can_fit_mask])
    exp_scores = np.exp(priorities[can_fit_mask] - max_score)
    
    normalized_priorities = np.zeros_like(bins_remain_cap, dtype=float)
    normalized_priorities[can_fit_mask] = exp_scores / np.sum(exp_scores)
    
    return normalized_priorities
```
