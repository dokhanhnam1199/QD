```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for overly full bins and an explicit bonus for perfect fits,
    using adaptive scaling for better generalization.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    rem_after_pack = valid_bins_remain_cap - item

    # Component 1: "Best Fit" - prioritize smaller remaining capacity
    best_fit_scores = -rem_after_pack

    # Component 2: Penalty for overly full bins (makes remaining capacity very small)
    # Scale rem_after_pack to [0, 1] for more stable penalty calculation
    min_rem_after_pack = 0.0
    max_rem_after_pack = np.max(rem_after_pack) if rem_after_pack.size > 0 else 0.0
    
    if max_rem_after_pack == min_rem_after_pack:
        diversification_penalty = np.zeros_like(best_fit_scores)
    else:
        # Use a scaled sigmoid for penalty: high penalty for near-zero remaining capacity
        scaled_rem = rem_after_pack / max_rem_after_pack
        # Penalty is high when scaled_rem is close to 0.
        # Using 1 - sigmoid(a * (x - b)) form for penalty
        # Penalty increases as scaled_rem approaches 0
        diversification_penalty = 1.0 - (1.0 / (1.0 + np.exp(10 * (scaled_rem - 0.1)))) # Penalty close to 1 for very tight fits

    # Component 3: Bonus for perfect fits
    perfect_fit_bonus = np.zeros_like(best_fit_scores)
    perfect_fit_threshold = 1e-9
    is_perfect_fit = rem_after_pack < perfect_fit_threshold
    perfect_fit_bonus[is_perfect_fit] = 10.0

    # Combine scores: prioritize best fit, add perfect fit bonus, subtract penalty
    # Penalty multiplier to control its impact
    combined_scores = best_fit_scores + perfect_fit_bonus - diversification_penalty * 1.5 

    # Apply Softmax for probability distribution
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    # Map probabilities back to the original bins array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
