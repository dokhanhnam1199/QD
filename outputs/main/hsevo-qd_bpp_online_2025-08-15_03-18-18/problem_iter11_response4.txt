```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines "Best Fit" with a "Perfect Fit Bonus" and Softmax scaling.

    Prioritizes bins that leave minimal remaining capacity after packing (Best Fit),
    while giving an extra boost to bins that result in zero remaining capacity
    (Perfect Fit). Softmax is used for probabilistic selection.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Base score favors bins with less remaining capacity after placement (Best Fit)
    # We want to maximize this score, so we use the negative of the remaining slack.
    # Larger negative values (closer to zero) are better.
    slack = valid_bins_remain_cap - item
    base_scores = -slack

    # Add a significant bonus for perfect fits (slack == 0)
    perfect_fit_bonus = 10.0  # A tunable hyperparameter
    bonus_scores = np.where(slack == 0, perfect_fit_bonus, 0)

    # Combine base scores and bonus for perfect fits
    combined_scores = base_scores + bonus_scores

    # Apply Softmax to convert scores into probabilities (priorities)
    # Shift scores to avoid numerical instability before exponentiation
    shifted_scores = combined_scores - np.max(combined_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Create the final priority array, placing calculated priorities in their original positions
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
