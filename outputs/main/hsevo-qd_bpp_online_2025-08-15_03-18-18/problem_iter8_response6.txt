```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit and a diversification penalty with Softmax for probabilistic selection.
    Prioritizes tight fits while encouraging exploration of less full bins.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Mask for bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item
    
    # If no bins can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities
    
    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]
    
    # --- Best Fit Component: Penalize remaining capacity ---
    # Higher score for bins with less remaining capacity after packing.
    # Add epsilon to avoid division by zero for perfect fits.
    best_fit_scores = - (valid_bins_remain_cap - item)
    
    # --- Diversification Penalty Component: Penalize large remaining capacity ---
    # Add a penalty to bins with significantly large remaining capacity to encourage exploration.
    # Use a sigmoid-like function to create a smooth penalty.
    # Scale remaining capacities to a manageable range for the sigmoid.
    min_rem_valid = np.min(valid_bins_remain_cap) if np.any(valid_bins_remain_cap > 0) else 0
    max_rem_valid = np.max(valid_bins_remain_cap) if np.any(valid_bins_remain_cap > 0) else 0
    
    diversification_penalty = np.zeros_like(valid_bins_remain_cap)
    
    # Only apply penalty if there's a range of remaining capacities to differentiate
    if max_rem_valid > min_rem_valid:
        # Scale remaining capacity to [0, 1]
        scaled_rem = (valid_bins_remain_cap - min_rem_valid) / (max_rem_valid - min_rem_valid)
        # Sigmoid function: exp(-k * x) creates a penalty that increases as x decreases.
        # We want to penalize large remaining capacity, so we use exp(-k * scaled_rem).
        # Penalty is lower for bins with less remaining space (closer to best fit).
        penalty_strength = 3.0 
        diversification_penalty = 1.0 / (1.0 + np.exp(penalty_strength * scaled_rem))
    elif np.any(valid_bins_remain_cap > 0): # If all valid bins have same positive remaining capacity
        pass # No diversification needed if all options are equally 'open'

    # Combine scores: Best Fit (higher is better) + Diversification Penalty (higher is better)
    # The penalty is designed to slightly favor bins that are not excessively empty.
    # Weight the diversification penalty to control its influence.
    penalty_weight = 0.5
    combined_scores = best_fit_scores + diversification_penalty * penalty_weight
    
    # --- Softmax Normalization ---
    # Convert combined scores to probabilities.
    # Shift scores to prevent overflow with np.exp.
    shifted_scores = combined_scores - np.max(combined_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)
    
    # Assign probabilities to the valid bins
    priorities[can_fit_mask] = probabilities
    
    return priorities
```
