```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a bonus for perfect fits and adaptive diversification
    using a softened preference for less full bins.
    """
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Best Fit Score: Penalize remaining capacity after packing. Smaller is better.
    best_fit_scores = -(valid_bins_remain_cap - item)

    # Perfect Fit Bonus: Reward bins that are exactly filled.
    perfect_fit_bonus = np.where(valid_bins_remain_cap == item, 1.0, 0.0)

    # Adaptive Diversification: Reward less full bins, but scale based on variance.
    # Higher variance means more spread, so we want to be more diverse.
    if valid_bins_remain_cap.size > 1:
        variance_cap = np.var(valid_bins_remain_cap)
        # Scale diversification bonus by variance to adapt to bin spread
        diversification_factor = 1.0 + variance_cap 
    else:
        diversification_factor = 1.0 
        
    diversification_scores = valid_bins_remain_cap * diversification_factor

    # Combine components: Emphasize Best Fit, add Perfect Fit bonus, and scale Diversification.
    # Weights can be tuned for performance.
    w_bf = 1.0
    w_pf = 1.5 # Give a slightly higher weight to perfect fits
    w_div = 0.2
    
    combined_scores = w_bf * best_fit_scores + w_pf * perfect_fit_bonus + w_div * diversification_scores

    # Softmax to convert scores to probabilities, ensuring numerical stability.
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    priorities[valid_bins_mask] = probabilities

    return priorities
```
