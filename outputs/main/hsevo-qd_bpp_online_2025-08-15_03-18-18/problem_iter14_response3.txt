```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with adaptive diversification using Softmax.
    Prioritizes bins that fit snugly while adapting selection based on bin capacity variance.
    """
    valid_bins_mask = bins_remain_cap >= item
    if not np.any(valid_bins_mask):
        return np.zeros_like(bins_remain_cap, dtype=float)

    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Best Fit score: maximize -(remaining_capacity - item)
    fit_scores = -(valid_bins_remain_cap - item)

    # Adaptive diversification: Boost bins when capacities are similar
    std_dev_valid_bins = np.std(valid_bins_remain_cap)
    # Higher std_dev -> less diversification bonus
    diversity_bonus = np.exp(-std_dev_valid_bins * 5.0) * 0.1 
    
    # Combine fit and diversity, giving a slight edge to less tightly packed bins if std_dev is low
    adjusted_scores = fit_scores + diversity_bonus

    # Adaptive temperature for Softmax based on number of options and their spread
    num_valid_bins = len(valid_bins_remain_cap)
    base_temp = 1.0
    temp_multiplier = 1.0 + (num_valid_bins / 10.0) * (std_dev_valid_bins / (np.max(bins_remain_cap) + 1e-9))
    temperature = max(base_temp * temp_multiplier, 0.1)

    # Softmax probability calculation
    max_score = np.max(adjusted_scores)
    shifted_scores = (adjusted_scores - max_score) / temperature
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Distribute probabilities back to original bin indices
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
