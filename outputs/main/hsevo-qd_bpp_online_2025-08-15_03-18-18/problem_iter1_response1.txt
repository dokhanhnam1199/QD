```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    available_bins_mask = bins_remain_cap >= item
    if not np.any(available_bins_mask):
        return np.zeros_like(bins_remain_cap)
    
    available_bins_cap = bins_remain_cap[available_bins_bins_mask]
    
    differences = available_bins_cap - item
    
    # Prioritize bins with the smallest remaining capacity after fitting the item
    # This encourages tighter packing.
    # We want smaller differences to have higher priority.
    # To achieve this, we can invert the differences and add a small epsilon 
    # to avoid division by zero if a bin fits perfectly.
    # A small epsilon also subtly breaks ties by favoring bins that were previously fuller.
    
    epsilon = 1e-9
    priorities = 1.0 / (differences + epsilon)
    
    # We need to return priorities for all bins, not just the available ones.
    # Initialize priorities for all bins to zero and then update the ones that are available.
    all_priorities = np.zeros_like(bins_remain_cap)
    all_priorities[available_bins_mask] = priorities
    
    return all_priorities
```
