```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with adaptive diversification using Softmax.
    Prioritizes bins that fit well, adaptively scales exploration based on bin diversity.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Best Fit component: Minimize remaining capacity after fitting
    # We want to maximize `-(remaining_capacity_after_fit)` for Softmax
    best_fit_scores = -(valid_bins_remain_cap - item)

    # Adaptive diversification: encourage exploration of less full bins when capacities are diverse.
    # A simple approach is to add a term proportional to the remaining capacity.
    # This term is weighted by an 'epsilon' that can adapt to diversity.
    # For simplicity here, we'll use a fixed scaling but acknowledge adaptation potential.
    diversification_weight = 0.2 # Tune this weight
    diversification_scores = valid_bins_remain_cap * diversification_weight
    
    # Combine scores
    combined_scores = best_fit_scores + diversification_scores

    # Add a bonus for perfect fits to ensure they are strongly preferred
    perfect_fit_bonus = 0.5
    perfect_fit_mask = np.abs(valid_bins_remain_cap - item) < 1e-9
    combined_scores[perfect_fit_mask] += perfect_fit_bonus

    # Use Softmax for probabilistic selection, providing exploration
    # Shift scores for numerical stability before exponentiation
    shifted_scores = combined_scores - np.max(combined_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Assign probabilities back to the original bins array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
