```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for each bin using a hybrid strategy
    for the online Bin Packing Problem.

    This strategy balances the "best fit" principle with a diversification
    mechanism. It prioritizes bins that offer a good fit, but also
    introduces a slight bias towards bins that are less utilized,
    to prevent premature exhaustion of nearly full bins. This aims to
    improve robustness and exploration.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # --- Core Heuristic: Best Fit ---
    # Calculate remaining capacity after placing the item. Lower is better.
    remaining_after_fit = valid_bins_remain_cap - item

    # For Softmax, we want higher values to represent higher priority.
    # So, we'll use the negative of remaining capacity. Higher negative
    # values (closer to zero) are preferred (best fit).
    best_fit_scores = -remaining_after_fit

    # --- Diversification Component ---
    # To encourage exploration and prevent premature convergence to a state
    # where only a few bins are almost full, we introduce a secondary score.
    # We want to slightly favor bins with more remaining capacity *before*
    # placing the item, but only if they are still valid fits.
    # This is a form of "exploration bonus".
    # A simple approach is to add a small factor proportional to the
    # original remaining capacity. We can scale this factor to control
    # the balance between best-fit and diversification.
    # Let's use a small positive weight (e.g., 0.1) for this diversification.
    diversification_weight = 0.1
    diversification_scores = diversification_weight * valid_bins_remain_cap

    # Combine scores: Prioritize best fit, but give a small boost for more
    # available space. This creates a more nuanced priority.
    combined_scores = best_fit_scores + diversification_scores

    # --- Softmax Application ---
    # Apply Softmax to convert scores into probabilities (priorities).
    # Shift scores to prevent numerical instability (large negative numbers).
    # Subtracting the maximum score before exponentiation is a standard technique.
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    # Create the final priority array, placing calculated priorities in their original positions
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    if valid_bins_mask.any():
        priorities[valid_bins_mask] = probabilities

    return priorities
```
