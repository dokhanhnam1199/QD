import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, softmax_temperature: float = 0.17632701765584216) -> np.ndarray:
    """
    Calculates priority scores for each bin using a Softmax-Based Fit strategy
    for the online Bin Packing Problem.

    This strategy prioritizes bins that have remaining capacity, with a higher
    priority given to bins that can accommodate the item without significant
    wastage, and also considers the overall "fullness" of bins.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.
        softmax_temperature: A parameter to control the 'sharpness' of the
                             softmax distribution. A higher temperature
                             results in a softer distribution.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    # Filter out bins that cannot fit the item
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        # If no bin can fit the item, return zero priorities for all bins
        return np.zeros_like(bins_remain_cap)

    # Calculate a score for each valid bin:
    # We want to favor bins that are nearly full after placing the item.
    # (capacity - item) represents the remaining capacity after placement.
    # Smaller values of (capacity - item) are better.
    # We can invert this by taking the negative or by calculating (item - capacity) if capacity < item.
    # For simplicity and Softmax compatibility, let's focus on the 'goodness' of fit.
    # A good fit means small remaining capacity. So, we can use 1 / (remaining_after_fit)
    # or something similar.

    # A common heuristic for BPP is "Best Fit": choosing the bin that leaves the least empty space.
    # So, remaining_capacity - item should be minimized.
    # We want to maximize the "suitability" score.
    # Let's consider the negative of the remaining capacity after fitting as a base score.
    # Larger negative values (closer to zero) are better.
    base_scores = -(valid_bins_remain_cap - item)

    # Apply Softmax to convert scores into probabilities (priorities)
    # Softmax: exp(score / temperature) / sum(exp(all_scores / temperature))
    # To avoid numerical instability with very large or small scores, we can shift scores.
    # Subtracting the maximum score before exponentiation is a common technique.
    shifted_scores = (base_scores / softmax_temperature) - np.max(base_scores / softmax_temperature)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Create the final priority array, placing calculated priorities in their original positions
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
