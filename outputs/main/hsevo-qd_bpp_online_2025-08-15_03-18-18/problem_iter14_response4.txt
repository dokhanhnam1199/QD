```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid of Best Fit and Adaptive Diversification for robust online Bin Packing.

    Combines minimizing leftover space with adaptive scoring based on variance,
    using Softmax for balanced exploration-exploitation.
    """
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    suitable_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    
    # Best Fit component: prioritize bins with less remaining capacity after fitting
    best_fit_scores = -(suitable_bins_remain_cap - item)

    # Adaptive Diversification component: encourage exploring less-used bins
    # Use variance of remaining capacities of suitable bins as a diversity measure
    if len(suitable_bins_remain_cap) > 1:
        variance_remaining_cap = np.var(suitable_bins_remain_cap)
        # Higher variance suggests more diverse options, potentially higher priority for less utilized bins
        # Scale variance to influence the diversification score
        diversification_scores = variance_remaining_cap * (suitable_bins_remain_cap / np.max(suitable_bins_remain_cap))
    else:
        # If only one suitable bin, diversification score is zero
        diversification_scores = np.zeros_like(suitable_bins_remain_cap)
        
    # Combine Best Fit and Diversification scores
    # Simple additive combination, can be tuned with weights
    combined_scores = best_fit_scores + diversification_scores

    # Softmax for normalization and probabilistic selection
    # Shift scores to prevent overflow/underflow before exponentiation
    if np.max(combined_scores) - np.min(combined_scores) > 1e-9:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        sum_exp_scores = np.sum(exp_scores)
        if sum_exp_scores > 1e-9:
            probabilities = exp_scores / sum_exp_scores
        else:
            # Fallback if all exponentiated scores are effectively zero
            probabilities = np.ones_like(combined_scores) / len(combined_scores)
    else:
        # If all combined scores are the same, assign equal probability
        probabilities = np.ones_like(combined_scores) / len(combined_scores)

    priorities[valid_bins_mask] = probabilities

    return priorities
```
