```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for nearly full bins using a Softmax approach.
    Prioritizes bins that fit the item well, while slightly penalizing those that
    would leave minimal remaining capacity, promoting better future fits.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Base score: Favoring Best Fit by maximizing negative remaining capacity after packing.
    # Higher score means smaller remaining capacity.
    best_fit_scores = -(valid_bins_remain_cap - item)

    # Penalty score: Penalize bins that leave very little space.
    # Use a logistic function to map small positive remaining capacities to high penalty values.
    # Penalty is high when (valid_bins_remain_cap - item) is small.
    # We want to *subtract* this penalty to lower priority for such bins.
    penalty_factor = 3.0  # Controls the strength of the penalty for small remaining space.
    penalty = penalty_factor * np.exp(-(valid_bins_remain_cap - item))

    # Combined score: Best Fit score minus the penalty.
    # This rewards tight fits but reduces priority for fits that leave almost no room.
    combined_scores = best_fit_scores - penalty

    # Softmax transformation to get probabilities.
    # Shift scores to prevent numerical overflow/underflow.
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    # Map probabilities back to the original bin positions.
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
