```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins by favoring those with minimal remaining capacity after fitting
    the item, with a slight random perturbation to encourage exploration.
    A perfect fit receives a significantly higher base priority.
    """
    epsilon = 0.1  # Weight for random exploration
    bin_capacity = 1.0 # Assumed standard bin capacity

    # Calculate potential remaining capacity after placing the item
    potential_fits = bins_remain_cap - item

    # Identify bins that can accommodate the item
    valid_bins_mask = potential_fits >= 0

    # Initialize priorities to zero
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(valid_bins_mask):
        # Calculate greedy scores for valid bins: inverse of remaining capacity.
        # Add a small epsilon to avoid division by zero and handle near-perfect fits.
        # Prioritize perfect fits (remaining capacity is zero) much higher.
        greedy_scores = np.zeros(np.sum(valid_bins_mask))
        
        # Handle perfect fits separately for higher priority
        perfect_fit_mask = (potential_fits[valid_bins_mask] == 0)
        if np.any(perfect_fit_mask):
            greedy_scores[perfect_fit_mask] = 1e9 # High priority for perfect fits
        
        # For non-perfect fits, use inverse of remaining capacity
        non_perfect_fit_mask = ~perfect_fit_mask
        if np.any(non_perfect_fit_mask):
            greedy_scores[non_perfect_fit_mask] = 1.0 / (potential_fits[valid_bins_mask][non_perfect_fit_mask] + 1e-6)

        # Generate random scores for exploration
        random_scores = np.random.rand(np.sum(valid_bins_mask))

        # Combine greedy and random scores
        combined_scores = epsilon * random_scores + (1 - epsilon) * greedy_scores

        # Assign the combined scores to the valid bins
        priorities[valid_bins_mask] = combined_scores
        
        # Normalize priorities to sum to 1 for better selection probability interpretation
        if np.sum(priorities) > 0:
            priorities = priorities / np.sum(priorities)
        else: # Fallback if all priorities are zero (should not happen with valid bins)
            priorities = np.ones_like(priorities) / len(priorities)


    return priorities
```
