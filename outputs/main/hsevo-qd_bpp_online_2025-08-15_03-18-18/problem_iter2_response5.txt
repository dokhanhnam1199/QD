```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines 'best fit' with a small random element for improved exploration
    and handles perfect fits explicitly. Prioritizes bins with minimal remaining
    capacity after placing the item, while introducing some randomness to
    avoid premature convergence.
    """
    epsilon = 0.05  # Small factor for random exploration
    bin_capacity = 1.0 # Assuming a standard bin capacity of 1.0

    potential_fits = bins_remain_cap - item
    valid_bins_mask = potential_fits >= -1e-9 # Allow for slight floating point inaccuracies

    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if np.any(valid_bins_mask):
        suitable_bins_remain_cap = bins_remain_cap[valid_bins_mask]
        suitable_potential_fits = potential_fits[valid_bins_mask]

        # Explicitly reward perfect fits with a high priority
        perfect_fit_mask = np.abs(suitable_potential_fits) < 1e-9
        priorities[valid_bins_mask][perfect_fit_mask] = 1.0 / (1e-9) # Very high priority

        # For non-perfect fits, use inverse proximity with a small random component
        non_perfect_fit_mask = ~perfect_fit_mask
        if np.any(non_perfect_fit_mask):
            non_perfect_potential_fits = suitable_potential_fits[non_perfect_fit_mask]
            greedy_scores = 1.0 / (non_perfect_potential_fits + 1e-9)
            random_scores = np.random.rand(np.sum(non_perfect_fit_mask))
            combined_scores = epsilon * random_scores + (1 - epsilon) * greedy_scores
            priorities[valid_bins_mask][non_perfect_fit_mask] = combined_scores

    return priorities
```
