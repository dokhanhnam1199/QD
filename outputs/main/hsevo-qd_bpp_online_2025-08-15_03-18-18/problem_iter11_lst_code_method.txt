{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Hybrid heuristic combining Best Fit with a penalty for overly tight fits\n    and a bonus for bins with ample remaining capacity.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if not np.any(valid_bins_mask):\n        return priorities\n\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    # Best Fit Component: Penalize based on remaining capacity after packing.\n    # Smaller remaining capacity is better.\n    best_fit_scores = -(valid_bins_remain_cap - item)\n\n    # Diversification Component: Reward bins with more initial remaining capacity.\n    # This favors less full bins.\n    diversification_scores = valid_bins_remain_cap\n\n    # Combine components with weights. Tune these weights based on empirical performance.\n    # w_bf = 1.0 emphasizes Best Fit.\n    # w_div = 0.3 gives a moderate preference to less full bins.\n    w_bf = 1.0\n    w_div = 0.3\n    \n    combined_scores = w_bf * best_fit_scores + w_div * diversification_scores\n\n    # Apply Softmax to get probabilities.\n    # Shift scores to prevent overflow/underflow issues with large exponents.\n    if combined_scores.size > 0:\n        shifted_scores = combined_scores - np.max(combined_scores)\n        exp_scores = np.exp(shifted_scores)\n        probabilities = exp_scores / np.sum(exp_scores)\n    else:\n        probabilities = np.array([])\n\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with an adaptive diversification strategy.\n    Prioritizes bins that fit the item well, while also considering\n    the variance of remaining capacities to balance exploration and exploitation.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if not np.any(valid_bins_mask):\n        return priorities\n\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    # Best Fit Component: Similarity to perfect fit. Smaller difference is better.\n    bf_scores = -(valid_bins_remain_cap - item)\n\n    # Adaptive Diversification Component: Use variance to adjust exploration.\n    # If variance is low (bins are similar), encourage exploration by rewarding larger capacities.\n    # If variance is high (bins are dissimilar), reduce exploration by penalizing larger capacities.\n    if len(valid_bins_remain_cap) > 1:\n        variance_capacity = np.var(valid_bins_remain_cap)\n        # Normalize variance to be a small value, can be a hyperparameter\n        normalized_variance = variance_capacity / np.mean(valid_bins_remain_cap)**2 if np.mean(valid_bins_remain_cap) > 0 else 0\n        # Heuristic: if variance is low, we want to diversify more by favoring emptier bins\n        # so we add a positive term proportional to capacity. If variance is high, we want to\n        # exploit good fits more, so we add a negative term proportional to capacity.\n        # This is a simplified approach to adaptive diversification.\n        adaptive_div_scores = -normalized_variance * valid_bins_remain_cap\n    else:\n        adaptive_div_scores = np.zeros_like(valid_bins_remain_cap)\n\n    # Combine components. Tune weights based on empirical performance.\n    w_bf = 1.0\n    w_adapt_div = 0.5 # Weight for adaptive diversification\n    \n    combined_scores = w_bf * bf_scores + w_adapt_div * adaptive_div_scores\n\n    # Apply Softmax for probabilistic selection. Shift for numerical stability.\n    if combined_scores.size > 0:\n        shifted_scores = combined_scores - np.max(combined_scores)\n        exp_scores = np.exp(shifted_scores)\n        probabilities = exp_scores / np.sum(exp_scores)\n    else:\n        probabilities = np.array([])\n\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priority scores for each bin using an adaptive Softmax-Based Fit strategy\n    for the online Bin Packing Problem.\n\n    This strategy aims to improve upon v1 by:\n    1. Incorporating an adaptive scaling factor to balance exploration (trying less\n       optimal bins) and exploitation (fitting into the best available bins).\n    2. Handling near-perfect fits more explicitly to avoid unnecessary fragmentation.\n    3. Using a more robust score calculation that considers the inverse of remaining\n       capacity to better differentiate between bins, especially when items are small.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element represents the\n                         remaining capacity of a bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        is the priority score for placing the item in the corresponding bin.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # --- Adaptive Scoring Mechanism ---\n    # We want to assign higher priorities to bins that are good fits.\n    # A \"good fit\" means the remaining capacity after placing the item is small.\n    # The value (bins_remain_cap - item) represents the slack. We want to minimize this slack.\n    # Using 1 / (slack + epsilon) can work, but can be sensitive to small slacks.\n    # A better approach is to use a function that is high for small slacks and decreases.\n    # Consider the \"waste\" or \"difference\" from a perfect fit:\n    # A perfect fit would have remaining_capacity == item.\n    # Let's define a score related to the 'badness' of the fit.\n    # A very small positive slack is good. A large slack is bad.\n    # Score: - (remaining_capacity - item) - we want to maximize this, so smaller remaining is better.\n\n    # To make it adaptive, let's introduce a \"preference\" or \"temperature\" parameter\n    # that controls how much we favor the best fit vs. exploring other options.\n    # A higher 'beta' will make the distribution sharper (more greedy),\n    # a lower 'beta' will make it flatter (more exploratory).\n    # We can make beta dependent on the item size or the distribution of bin capacities.\n    # For simplicity, let's start with an inverse relationship to the average slack.\n    # This encourages exploration when slacks are generally large, and exploitation when slacks are small.\n\n    # Calculate slack for valid bins\n    slacks = valid_bins_remain_cap - item\n\n    # Calculate an adaptive beta.\n    # If average slack is small, we want to be more greedy (higher beta).\n    # If average slack is large, we want to explore more (lower beta).\n    # We can use 1 / (mean_slack + small_constant) or a similar inverse relationship.\n    mean_slack = np.mean(slacks)\n    # Add a small epsilon to avoid division by zero if all slacks are zero\n    epsilon = 1e-9\n    # Scale beta to avoid extremely sharp or flat distributions from raw inverse.\n    # A scaling factor can be tuned. Let's use a modest scaling.\n    beta = 1.0 / (mean_slack + epsilon)\n    beta = np.clip(beta, 0.1, 10.0) # Clamp beta to a reasonable range\n\n    # Softmax preparation:\n    # We want to maximize the \"goodness\" of fit. Goodness is inversely related to slack.\n    # A very small slack is highly desirable. A slightly larger slack is less desirable.\n    # A large slack is undesirable.\n    # Let's use a transformed score that is high for small slacks.\n    # Example: -slack, or 1/(slack + epsilon), or a sigmoid-like function of slack.\n    # Using -slack directly as in v1 is a good start.\n    # To make it more nuanced, consider a score that penalizes larger slacks more heavily.\n    # A transformation like exp(-k * slack) or a polynomial might be considered,\n    # but let's refine the base score and apply beta.\n\n    # Base scores: favor bins with smaller slacks.\n    # Negative slack means perfect or near-perfect fit.\n    # Positive slack means some remaining capacity.\n    # We want to maximize `goodness`.\n    # A good measure of goodness is minimizing `slack`.\n    # So, let's use `-slack` as a base score. Higher values are better.\n    base_scores = -slacks\n\n    # Handle near-perfect fits more explicitly:\n    # If slack is very close to zero (e.g., < 1% of item size or a small absolute threshold),\n    # give these bins a significant boost. This encourages using bins that are almost full.\n    near_perfect_fit_threshold = 0.01 * item + epsilon\n    near_perfect_mask = slacks < near_perfect_fit_threshold\n    # Add a bonus to near-perfect fits. The magnitude of the bonus should be substantial\n    # to dominate the beta-scaled scores but not so large to always pick them if they are few.\n    bonus = 10.0\n    base_scores[near_perfect_mask] += bonus\n\n    # Apply the adaptive beta to the base scores for Softmax\n    # The beta controls the \"sharpness\" of the probability distribution.\n    # Higher beta means probabilities concentrate on bins with higher base scores.\n    # Lower beta means probabilities are more spread out.\n    scaled_scores = beta * base_scores\n\n    # Apply Softmax\n    # Shift scores to prevent overflow/underflow issues with exp()\n    max_scaled_score = np.max(scaled_scores)\n    exp_scores = np.exp(scaled_scores - max_scaled_score)\n    sum_exp_scores = np.sum(exp_scores)\n\n    if sum_exp_scores == 0:\n        # This can happen if all scaled_scores are extremely negative.\n        # In such a case, distribute probability evenly among valid bins.\n        probabilities = np.ones_like(valid_bins_remain_cap) / len(valid_bins_remain_cap)\n    else:\n        probabilities = exp_scores / sum_exp_scores\n\n    # Construct the final priority array\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a penalty for overly full bins and an explicit bonus for perfect fits.\n    Prioritizes bins that closely fit the item, penalizes those that become too full,\n    and gives a high reward for exact matches.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after packing\n    rem_after_pack = valid_bins_remain_cap - item\n\n    # Component 1: \"Best Fit\" - prioritize smaller remaining capacity\n    # Higher score for smaller remaining capacity\n    best_fit_scores = -rem_after_pack\n\n    # Component 2: Penalty for overly full bins (makes remaining capacity very small)\n    # We want to reduce the score if rem_after_pack is close to zero.\n    # Use an exponential decay that is strong for small remaining capacity.\n    # Scale rem_after_pack to avoid overflow/underflow in exp and control sensitivity.\n    min_rem = 0.0\n    max_rem = np.max(valid_bins_remain_cap) - item if np.max(valid_bins_remain_cap) >= item else 0.0\n    \n    if max_rem == min_rem: # Handle case where all valid bins have same remaining capacity\n        diversification_penalty = np.zeros_like(best_fit_scores)\n    else:\n        scaled_rem = 5 * rem_after_pack / max_rem # Scale to [0, 5] range\n        # Penalty is high when scaled_rem is low (i.e., tight fit)\n        # Use 1 - sigmoid to get a penalty that is high for low values\n        diversification_penalty = 1.0 - (1.0 / (1.0 + np.exp(10 * (1.0 - scaled_rem)))) # Penalty ~ 1 for tight fit, ~ 0 for loose fit\n\n    # Component 3: Bonus for perfect fits\n    # Assign a significantly higher score to bins where rem_after_pack is zero (or very close to zero)\n    perfect_fit_bonus = np.zeros_like(best_fit_scores)\n    perfect_fit_threshold = 1e-9 # Tolerance for floating point comparison\n    is_perfect_fit = rem_after_pack < perfect_fit_threshold\n    perfect_fit_bonus[is_perfect_fit] = 10.0 # Large bonus for perfect fits\n\n    # Combine scores: best_fit + bonus - penalty\n    # The penalty is subtracted from the score to reduce priority for overly full bins.\n    # The bonus is added to strongly favor perfect fits.\n    combined_scores = best_fit_scores + perfect_fit_bonus - diversification_penalty * 2.0 # Penalty multiplier to control its impact\n\n    # Apply Softmax to get probability distribution\n    # Shift scores to prevent overflow/underflow in exp\n    if combined_scores.size > 0:\n        shifted_scores = combined_scores - np.max(combined_scores)\n        exp_scores = np.exp(shifted_scores)\n        probabilities = exp_scores / np.sum(exp_scores)\n    else:\n        probabilities = np.array([])\n\n    # Map probabilities back to the original bins array\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priority scores for each bin using a Softmax-Based Fit strategy\n    for the online Bin Packing Problem.\n\n    This strategy prioritizes bins that have remaining capacity, with a higher\n    priority given to bins that can accommodate the item without significant\n    wastage, and also considers the overall \"fullness\" of bins.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element represents the\n                         remaining capacity of a bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        is the priority score for placing the item in the corresponding bin.\n    \"\"\"\n    # Filter out bins that cannot fit the item\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        # If no bin can fit the item, return zero priorities for all bins\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate a score for each valid bin:\n    # We want to favor bins that are nearly full after placing the item.\n    # (capacity - item) represents the remaining capacity after placement.\n    # Smaller values of (capacity - item) are better.\n    # We can invert this by taking the negative or by calculating (item - capacity) if capacity < item.\n    # For simplicity and Softmax compatibility, let's focus on the 'goodness' of fit.\n    # A good fit means small remaining capacity. So, we can use 1 / (remaining_after_fit)\n    # or something similar.\n\n    # A common heuristic for BPP is \"Best Fit\": choosing the bin that leaves the least empty space.\n    # So, remaining_capacity - item should be minimized.\n    # We want to maximize the \"suitability\" score.\n    # Let's consider the negative of the remaining capacity after fitting as a base score.\n    # Larger negative values (closer to zero) are better.\n    base_scores = -(valid_bins_remain_cap - item)\n\n    # Add a penalty for bins that are already very full, encouraging spreading items if possible,\n    # unless an item perfectly fits. This can be tricky.\n    # For simplicity in v2, let's focus on the immediate fit.\n\n    # Apply Softmax to convert scores into probabilities (priorities)\n    # Softmax: exp(score) / sum(exp(all_scores))\n    # To avoid numerical instability with very large or small scores, we can shift scores.\n    # Subtracting the maximum score before exponentiation is a common technique.\n    shifted_scores = base_scores - np.max(base_scores)\n    exp_scores = np.exp(shifted_scores)\n    probabilities = exp_scores / np.sum(exp_scores)\n\n    # Create the final priority array, placing calculated priorities in their original positions\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit (minimizing waste) with a Softmax approach for robust priority.\n\n    Prioritizes bins that leave minimal remaining capacity after item placement,\n    using Softmax for smooth probability distribution and better exploration.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    if not np.any(valid_bins_mask):\n        return priorities\n\n    suitable_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    # Base score: Negative of remaining capacity after fitting (closer to 0 is better)\n    # This embodies the \"Best Fit\" principle.\n    base_scores = -(suitable_bins_remain_cap - item)\n\n    # Softmax for normalization: Convert scores to a probability-like distribution\n    # Shift scores to prevent overflow/underflow before exponentiation\n    if np.max(base_scores) - np.min(base_scores) > 1e-9: # Avoid issues if all scores are identical\n        shifted_scores = base_scores - np.max(base_scores)\n        exp_scores = np.exp(shifted_scores)\n        # Ensure sum is not zero to avoid division by zero\n        sum_exp_scores = np.sum(exp_scores)\n        if sum_exp_scores > 1e-9:\n            probabilities = exp_scores / sum_exp_scores\n        else:\n            # Fallback if all exponentiated scores are effectively zero\n            probabilities = np.ones_like(base_scores) / len(base_scores)\n    else:\n        # If all base scores are the same, assign equal probability\n        probabilities = np.ones_like(base_scores) / len(base_scores)\n\n\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Prioritizes bins by rewarding perfect fits and then favoring tighter fits using inverse proximity, normalized via Softmax.\n\n    Combines the 'perfect fit' bonus from priority_v0 with the normalized inverse proximity of priority_v1.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    \n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n    \n    # Calculate effective remaining capacities for fitting bins\n    effective_capacities = bins_remain_cap[can_fit_mask] - item\n    \n    # Assign scores: perfect fits get a bonus, others get inverse proximity\n    scores = np.zeros_like(effective_capacities, dtype=float)\n    \n    perfect_fit_mask = effective_capacities == 0\n    scores[perfect_fit_mask] = 1.0  # High priority for perfect fits\n    \n    # For non-perfect fits, use inverse proximity to reward tighter fits\n    non_perfect_fit_mask = ~perfect_fit_mask\n    scores[non_perfect_fit_mask] = 1.0 / (effective_capacities[non_perfect_fit_mask] + 1e-9)\n    \n    # Apply scores to the corresponding bins\n    priorities[can_fit_mask] = scores\n    \n    # If no bins can fit the item, return uniform probabilities\n    if not np.any(can_fit_mask):\n        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)\n        \n    # Normalize priorities using Softmax to get a probability distribution\n    # Subtract max score for numerical stability before exponentiation\n    max_score = np.max(priorities[can_fit_mask])\n    exp_scores = np.exp(priorities[can_fit_mask] - max_score)\n    \n    normalized_priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    normalized_priorities[can_fit_mask] = exp_scores / np.sum(exp_scores)\n    \n    return normalized_priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a penalty for overly full bins and an explicit bonus for perfect fits.\n    Prioritizes bins that closely fit the item, penalizes those that become too full,\n    and gives a high reward for exact matches.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after packing\n    rem_after_pack = valid_bins_remain_cap - item\n\n    # Component 1: \"Best Fit\" - prioritize smaller remaining capacity\n    # Higher score for smaller remaining capacity\n    best_fit_scores = -rem_after_pack\n\n    # Component 2: Penalty for overly full bins (makes remaining capacity very small)\n    # We want to reduce the score if rem_after_pack is close to zero.\n    # Use an exponential decay that is strong for small remaining capacity.\n    # Scale rem_after_pack to avoid overflow/underflow in exp and control sensitivity.\n    min_rem = 0.0\n    max_rem = np.max(valid_bins_remain_cap) - item if np.max(valid_bins_remain_cap) >= item else 0.0\n    \n    if max_rem == min_rem: # Handle case where all valid bins have same remaining capacity\n        diversification_penalty = np.zeros_like(best_fit_scores)\n    else:\n        scaled_rem = 5 * rem_after_pack / max_rem # Scale to [0, 5] range\n        # Penalty is high when scaled_rem is low (i.e., tight fit)\n        # Use 1 - sigmoid to get a penalty that is high for low values\n        diversification_penalty = 1.0 - (1.0 / (1.0 + np.exp(10 * (1.0 - scaled_rem)))) # Penalty ~ 1 for tight fit, ~ 0 for loose fit\n\n    # Component 3: Bonus for perfect fits\n    # Assign a significantly higher score to bins where rem_after_pack is zero (or very close to zero)\n    perfect_fit_bonus = np.zeros_like(best_fit_scores)\n    perfect_fit_threshold = 1e-9 # Tolerance for floating point comparison\n    is_perfect_fit = rem_after_pack < perfect_fit_threshold\n    perfect_fit_bonus[is_perfect_fit] = 10.0 # Large bonus for perfect fits\n\n    # Combine scores: best_fit + bonus - penalty\n    # The penalty is subtracted from the score to reduce priority for overly full bins.\n    # The bonus is added to strongly favor perfect fits.\n    combined_scores = best_fit_scores + perfect_fit_bonus - diversification_penalty * 2.0 # Penalty multiplier to control its impact\n\n    # Apply Softmax to get probability distribution\n    # Shift scores to prevent overflow/underflow in exp\n    if combined_scores.size > 0:\n        shifted_scores = combined_scores - np.max(combined_scores)\n        exp_scores = np.exp(shifted_scores)\n        probabilities = exp_scores / np.sum(exp_scores)\n    else:\n        probabilities = np.array([])\n\n    # Map probabilities back to the original bins array\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Combines Best Fit with a penalty for overly full bins and an explicit bonus for perfect fits.\n    Prioritizes bins that closely fit the item, penalizes those that become too full,\n    and gives a high reward for exact matches.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Calculate remaining capacity after packing\n    rem_after_pack = valid_bins_remain_cap - item\n\n    # Component 1: \"Best Fit\" - prioritize smaller remaining capacity\n    # Higher score for smaller remaining capacity\n    best_fit_scores = -rem_after_pack\n\n    # Component 2: Penalty for overly full bins (makes remaining capacity very small)\n    # We want to reduce the score if rem_after_pack is close to zero.\n    # Use an exponential decay that is strong for small remaining capacity.\n    # Scale rem_after_pack to avoid overflow/underflow in exp and control sensitivity.\n    min_rem = 0.0\n    max_rem = np.max(valid_bins_remain_cap) - item if np.max(valid_bins_remain_cap) >= item else 0.0\n    \n    if max_rem == min_rem: # Handle case where all valid bins have same remaining capacity\n        diversification_penalty = np.zeros_like(best_fit_scores)\n    else:\n        scaled_rem = 5 * rem_after_pack / max_rem # Scale to [0, 5] range\n        # Penalty is high when scaled_rem is low (i.e., tight fit)\n        # Use 1 - sigmoid to get a penalty that is high for low values\n        diversification_penalty = 1.0 - (1.0 / (1.0 + np.exp(10 * (1.0 - scaled_rem)))) # Penalty ~ 1 for tight fit, ~ 0 for loose fit\n\n    # Component 3: Bonus for perfect fits\n    # Assign a significantly higher score to bins where rem_after_pack is zero (or very close to zero)\n    perfect_fit_bonus = np.zeros_like(best_fit_scores)\n    perfect_fit_threshold = 1e-9 # Tolerance for floating point comparison\n    is_perfect_fit = rem_after_pack < perfect_fit_threshold\n    perfect_fit_bonus[is_perfect_fit] = 10.0 # Large bonus for perfect fits\n\n    # Combine scores: best_fit + bonus - penalty\n    # The penalty is subtracted from the score to reduce priority for overly full bins.\n    # The bonus is added to strongly favor perfect fits.\n    combined_scores = best_fit_scores + perfect_fit_bonus - diversification_penalty * 2.0 # Penalty multiplier to control its impact\n\n    # Apply Softmax to get probability distribution\n    # Shift scores to prevent overflow/underflow in exp\n    if combined_scores.size > 0:\n        shifted_scores = combined_scores - np.max(combined_scores)\n        exp_scores = np.exp(shifted_scores)\n        probabilities = exp_scores / np.sum(exp_scores)\n    else:\n        probabilities = np.array([])\n\n    # Map probabilities back to the original bins array\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priority scores for each bin using a Hybrid Softmax-Based Fit strategy\n    for the online Bin Packing Problem.\n\n    This strategy aims to balance 'Best Fit' (minimizing waste) with a\n    'First Fit' tendency for larger items by introducing a penalty for\n    bins that would leave very little space after packing. It also incorporates\n    a diversification element by slightly favoring less full bins to avoid\n    prematurely filling a few bins.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element represents the\n                         remaining capacity of a bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        is the priority score for placing the item in the corresponding bin.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # Base score: Invert remaining capacity after fitting. Lower remaining is better.\n    # This promotes 'Best Fit'.\n    best_fit_scores = -(valid_bins_remain_cap - item)\n\n    # Diversification/Exploration score:\n    # Favor bins that are not already too full. This encourages spreading items.\n    # A higher score for bins with more remaining capacity (but still fitting the item).\n    # We use a sigmoid-like function to bound this influence.\n    # The idea is to give a slight boost to bins that are not nearly full,\n    # especially if the item is large.\n    # We can use 1 / (1 + exp(-(capacity - item - threshold))) where threshold is some value\n    # or more simply, a transformation of the remaining capacity after packing.\n    # Let's consider the remaining capacity itself as a measure. Higher remaining capacity\n    # after packing is less preferred for 'Best Fit', but might be good for diversification.\n    # We can create a score that is inversely related to how \"full\" the bin becomes.\n    # A bin that becomes almost full (low remaining cap) is good for BF, bad for diversity.\n    # A bin that remains very open (high remaining cap) is bad for BF, good for diversity.\n\n    # Let's create a score that penalizes bins that will have very little remaining space.\n    # This is a form of \"near miss\" avoidance for the next items.\n    # A small remaining capacity after packing (e.g., < item/2) could be penalized.\n    # Let's map the remaining capacity after packing `rem_after_fit` to a score.\n    rem_after_fit = valid_bins_remain_cap - item\n    \n    # Soft penalty for small remaining capacities. If rem_after_fit is small, this score is high.\n    # We want to *reduce* the priority for bins that leave very little space.\n    # Use a sigmoid-like function that maps small positive values to a range close to 0,\n    # and larger values to a range close to 1.\n    # We want to penalize small `rem_after_fit`.\n    # So, a function that is high for small `rem_after_fit` and low for large `rem_after_fit`\n    # is needed, and this should be subtracted from the main score.\n    \n    # A simple penalty: penalize if remaining capacity is less than item/2.\n    # More nuanced: exponential decay of penalty as remaining capacity increases.\n    # Let's use a logistic function scaled to penalize small positive remaining capacities.\n    # f(x) = 1 / (1 + exp(-k * (x - x0)))\n    # We want a function that is high when rem_after_fit is low.\n    # So we can use: penalty = 1 / (1 + exp(k * rem_after_fit)) where k is positive.\n    # Or, more simply, we can use a score that increases with remaining capacity,\n    # but we want to *reduce* the priority of bins with low remaining capacity.\n    \n    # Let's refine the score:\n    # Primary goal: Minimize `rem_after_fit` (Best Fit). Score = -rem_after_fit.\n    # Secondary goal: Avoid making bins too full if possible (Diversification).\n    # This means, if multiple bins offer similar \"best fit\", prefer the one that\n    # was initially less full.\n    # This is tricky to encode directly in a simple priority score.\n\n    # Alternative approach: Combine Best Fit with a bonus for initial capacity.\n    # Score = -rem_after_fit + alpha * initial_capacity_of_bin\n    # However, we don't have initial capacity, only remaining.\n\n    # Let's try a score that is good for Best Fit, but has a \"decay\" for being too full.\n    # Consider the \"gap\" created: `valid_bins_remain_cap - item`.\n    # We want to minimize this gap.\n    # Let's add a term that slightly favors bins that are less full initially.\n    # We can use the *current* remaining capacity as a proxy for how full the bin is.\n    # Higher `valid_bins_remain_cap` means the bin is less full.\n    \n    # Let's try a composite score:\n    # Score = w1 * (- (valid_bins_remain_cap - item)) + w2 * (valid_bins_remain_cap)\n    # The first term is Best Fit. The second term favors less full bins.\n    # Let's normalize these to avoid one dominating the other.\n\n    # Normalization factor for Best Fit: The maximum possible \"goodness\" is 0 (perfect fit).\n    # The worst \"goodness\" is -(max_capacity - min_item_size).\n    # Let's normalize `-(valid_bins_remain_cap - item)` to be between 0 and 1 (roughly).\n    # Or, more simply, let's use the raw negative remaining capacity.\n\n    # Let's introduce a \"diversification bonus\" that is proportional to the remaining capacity\n    # of the bin *before* packing. This encourages using bins that have more space available,\n    # as long as they fit the item.\n    # `bonus = alpha * valid_bins_remain_cap` where alpha is a small positive weight.\n    # This bonus counters the Best Fit score if the remaining capacity is significantly large.\n\n    alpha = 0.1  # Weight for diversification bonus. Tune this parameter.\n    diversification_bonus = alpha * valid_bins_remain_cap\n    \n    # Combined score: Best Fit score + diversification bonus\n    # Higher score is better.\n    # We want to minimize `valid_bins_remain_cap - item`. So we want to maximize `-(valid_bins_remain_cap - item)`.\n    # Higher `valid_bins_remain_cap` is better for diversification.\n    \n    # So, we want to maximize `-(valid_bins_remain_cap - item) + alpha * valid_bins_remain_cap`\n    # This simplifies to `alpha * valid_bins_remain_cap - valid_bins_remain_cap + item`\n    # which is `(alpha - 1) * valid_bins_remain_cap + item`.\n    # This still favors larger `valid_bins_remain_cap` if `alpha < 1`, which is the case.\n    \n    # Let's reconsider the goal. We want bins that are *almost* full (good fit),\n    # but not *too* full such that the remaining space is almost unusable.\n    # This suggests a function that peaks for intermediate remaining capacities after packing.\n\n    # A refined approach:\n    # 1. Best Fit score: `-(valid_bins_remain_cap - item)`. Maximize this.\n    # 2. Penalty for \"too little\" remaining space: `exp(-beta * (valid_bins_remain_cap - item))`\n    #    where beta is a positive constant. This term is high for small remaining space,\n    #    and we want to penalize high values. So, we subtract this penalty.\n    \n    beta = 2.0  # Penalty factor for small remaining space.\n    # We want to penalize small positive remaining capacities.\n    # Let rem_cap_after_packing = valid_bins_remain_cap - item\n    # Penalty increases as rem_cap_after_packing approaches 0.\n    # A function like `exp(-beta * rem_cap_after_packing)` works.\n    # If rem_cap_after_packing = 0, penalty is 1. If rem_cap_after_packing is large, penalty approaches 0.\n    # So, we subtract this penalty.\n    \n    # Let's combine:\n    # Score = -(valid_bins_remain_cap - item) - penalty_factor * exp(-beta * (valid_bins_remain_cap - item))\n    # This aims to reward good fits, but slightly disincentivize fits that leave almost no space.\n\n    # Let's try a simpler form that is more directly interpretable with Softmax.\n    # We want to prioritize bins where `valid_bins_remain_cap - item` is small.\n    # Let's introduce a \"niceness\" score.\n    # `niceness = 1.0 / (1.0 + (valid_bins_remain_cap - item))` -- this is high for small remaining space.\n    # But Softmax needs scores that can be positive/negative.\n\n    # Let's go back to the composite score idea, but ensure Softmax handles it well.\n    # We want to prioritize bins with small `(remaining_capacity - item)`.\n    # We also want to slightly favor bins that have more overall capacity (less full).\n    # So, we want to maximize `-(remaining_capacity - item) + alpha * remaining_capacity`.\n    \n    # Let's re-evaluate the original v1's Softmax base: `-(valid_bins_remain_cap - item)`.\n    # This encourages Best Fit.\n    # To add diversification, we can add a term that is higher for bins that are less full.\n    # `current_remaining_capacity` is a proxy for \"less full\".\n    # So, `score = -(valid_bins_remain_cap - item) + gamma * valid_bins_remain_cap`.\n    # `gamma` is a small positive number.\n    \n    gamma = 0.2  # Weight for diversification (favoring less full bins).\n    \n    # The score is `-(valid_bins_remain_cap - item) + gamma * valid_bins_remain_cap`\n    # = `-valid_bins_remain_cap + item + gamma * valid_bins_remain_cap`\n    # = `(gamma - 1) * valid_bins_remain_cap + item`.\n    \n    # This score will be higher for larger `valid_bins_remain_cap` if `gamma < 1`,\n    # which is the intended effect of diversification.\n    # However, we also want to prioritize Best Fit.\n\n    # Let's normalize the contribution of each term to prevent one from dominating.\n    # Best Fit contribution: `-(valid_bins_remain_cap - item)`\n    # Diversification contribution: `valid_bins_remain_cap`\n\n    # Maximum possible best fit score: 0 (perfect fit). Minimum: -(max_cap - min_item).\n    # Maximum possible diversification contribution: max_capacity. Minimum: min_fitting_capacity.\n\n    # A common strategy is to use a weighted sum, and then apply softmax.\n    # Let's use the raw scores and rely on Softmax scaling.\n    \n    # Final proposed score for each valid bin:\n    # Score = w_bf * BestFitScore + w_div * DiversificationScore\n    # BestFitScore = -(remaining_capacity_after_packing) = -(valid_bins_remain_cap - item)\n    # DiversificationScore = current_remaining_capacity = valid_bins_remain_cap\n    \n    w_bf = 1.0\n    w_div = 0.3 # Tune this weight. Higher means more preference for less full bins.\n    \n    composite_scores = w_bf * (-(valid_bins_remain_cap - item)) + w_div * valid_bins_remain_cap\n\n    # Softmax transformation:\n    # Shift scores to avoid numerical instability (large positive/negative values)\n    # Subtracting the maximum score is standard.\n    if composite_scores.size > 0:\n        shifted_scores = composite_scores - np.max(composite_scores)\n        exp_scores = np.exp(shifted_scores)\n        probabilities = exp_scores / np.sum(exp_scores)\n    else:\n        probabilities = np.array([])\n\n    # Create the final priority array, placing calculated priorities in their original positions\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            priorities[i] = 1.0 / (bins_remain_cap[i] - item + 1e-9)\n    return priorities\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \n    bin_capacities = 1.0  # Assuming a standard bin capacity of 1.0, can be generalized.\n    \n    potential_fits = bins_remain_cap - item\n    \n    valid_bins_mask = potential_fits >= 0\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    if np.any(valid_bins_mask):\n        \n        priorities[valid_bins_mask] = 1.0 / (potential_fits[valid_bins_mask] + 1e-9) # Add epsilon to avoid division by zero\n\n    return priorities\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \n    bin_capacities = 1.0  # Assuming a standard bin capacity of 1.0, can be generalized.\n    \n    potential_fits = bins_remain_cap - item\n    \n    valid_bins_mask = potential_fits >= 0\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    if np.any(valid_bins_mask):\n        \n        priorities[valid_bins_mask] = 1.0 / (potential_fits[valid_bins_mask] + 1e-9) # Add epsilon to avoid division by zero\n\n    return priorities\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins_remain_cap)\n    suitable_bins_mask = bins_remain_cap >= item\n    priorities[suitable_bins_mask] = 1.0 / (bins_remain_cap[suitable_bins_mask] - item + 1e-9)\n    return priorities\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \n    bin_capacities = 1.0  # Assuming a standard bin capacity of 1.0, can be generalized.\n    \n    potential_fits = bins_remain_cap - item\n    \n    valid_bins_mask = potential_fits >= 0\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    \n    if np.any(valid_bins_mask):\n        \n        priorities[valid_bins_mask] = 1.0 / (potential_fits[valid_bins_mask] + 1e-9) # Add epsilon to avoid division by zero\n\n    return priorities\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    effective_capacities = bins_remain_cap[valid_bins] - item\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = np.exp(effective_capacities)\n    \n    if np.sum(priorities) == 0:\n        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)\n        \n    return priorities / np.sum(priorities)\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    effective_capacities = bins_remain_cap[valid_bins] - item\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = np.exp(effective_capacities)\n    \n    if np.sum(priorities) == 0:\n        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)\n        \n    return priorities / np.sum(priorities)\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    valid_bins = bins_remain_cap >= item\n    \n    if not np.any(valid_bins):\n        return np.zeros_like(bins_remain_cap)\n    \n    effective_capacities = bins_remain_cap[valid_bins] - item\n    \n    priorities = np.zeros_like(bins_remain_cap)\n    priorities[valid_bins] = np.exp(effective_capacities)\n    \n    if np.sum(priorities) == 0:\n        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)\n        \n    return priorities / np.sum(priorities)\n\n[Heuristics 19th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priority scores for each bin using an adaptive strategy for the\n    online Bin Packing Problem. This version aims to balance fitting tightly\n    (Best Fit) with spreading items (Worst Fit) and incorporating an element\n    of exploration.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element represents the\n                         remaining capacity of a bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        is the priority score for placing the item in the corresponding bin.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # --- Core Strategy: Balancing Best Fit and Worst Fit ---\n    # Best Fit component: Prioritize bins that leave minimal remaining space.\n    # We want to minimize (remaining_capacity - item).\n    # A good score for BF would be proportional to -(remaining_capacity - item).\n    # For Softmax, we want higher scores for better options. So, let's use\n    # a score that increases as remaining_capacity - item decreases.\n    # A simple inversion: 1 / (remaining_capacity - item + epsilon)\n    # Or, to keep it related to the previous approach: maximize -(remaining_capacity - item)\n    # To promote diversification, let's also consider the \"emptiness\" of the bin.\n    # Worst Fit component: Prioritize bins with *more* remaining capacity.\n    # This encourages spreading items.\n    # A score for WF could be proportional to remaining_capacity.\n\n    # Let's create a blended score.\n    # For Best Fit: prioritize small remaining capacity after placing the item.\n    # For Worst Fit: prioritize large initial remaining capacity.\n    # We want to maximize the utility.\n    # Let's consider the utility as a function of remaining capacity:\n    # utility = alpha * (1 / (valid_bins_remain_cap - item + 1e-9)) + beta * valid_bins_remain_cap\n\n    # For simplicity and to adapt the softmax approach, let's define scores\n    # where higher means more desirable.\n    # High score for small (remaining_capacity - item) => Best Fit tendency\n    # High score for large remaining_capacity => Worst Fit tendency (for exploration/diversification)\n\n    # Let's try a score that is a combination:\n    # Score = (large_capacity_bonus) * (remaining_capacity) - (misfit_penalty) * (remaining_capacity - item)\n    # A simpler approach:\n    # Prioritize bins where remaining_capacity - item is small (BF)\n    # BUT, also give a boost to bins that are \"more open\" (WF) to avoid early convergence.\n\n    # Let's combine the ideas:\n    # We want to favor small (remaining_capacity - item).\n    # Let's define a score for \"tightness\": TightnessScore = -(valid_bins_remain_cap - item)\n    # And a score for \"openness\": OpennessScore = valid_bins_remain_cap\n\n    # We can create a combined score, for example, by averaging or taking a weighted sum.\n    # A more robust approach is to introduce a \"temperature\" or \"exploration factor\"\n    # that modulates the influence of the Best Fit vs. Worst Fit tendencies.\n\n    # Let's try a score that is a compromise. We want to minimize (remaining_capacity - item).\n    # Let's use a function that is high when (remaining_capacity - item) is small.\n    # Consider a function like: `exp(-k * (remaining_capacity - item))`\n    # `k` can be an exploration parameter. A large `k` makes it more like Best Fit.\n    # A small `k` makes it flatter, more exploratory.\n\n    # To balance exploration and exploitation, let's make the \"tightness\" score\n    # have an exploratory element.\n    # Let's use a score that is high for bins that are \"good\" fits, but also\n    # has some preference for bins that aren't *too* full if an exact fit isn't available.\n\n    # --- Adaptive Exploration/Exploitation ---\n    # We can adapt the strength of the \"Best Fit\" tendency based on the distribution of remaining capacities.\n    # If capacities are very diverse, lean more towards Best Fit.\n    # If capacities are very similar, lean more towards diversification.\n\n    # A simple adaptation: Use a parameter `epsilon` that smooths the selection.\n    # Larger epsilon makes it more uniform (exploratory). Smaller epsilon makes it more greedy (exploitative).\n    # We can define epsilon based on the variance of remaining capacities.\n    variance_remain_cap = np.var(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else 1.0\n    # Scale variance to a reasonable epsilon range. Higher variance -> higher epsilon for more exploration.\n    epsilon = 0.1 + 0.5 * (1 / (1 + np.exp(-0.1 * variance_remain_cap))) # Sigmoid to bound epsilon\n\n    # Calculate scores:\n    # Score for \"good fit\" (lower remaining_capacity - item is better)\n    # Using a negative exponential for a sharp decrease in score as misfit increases.\n    # Adding epsilon for numerical stability and exploration.\n    goodness_of_fit_scores = np.exp(-10.0 * (valid_bins_remain_cap - item) / (item + 1e-9)) # Scale by item size\n\n    # Score for \"openness\" (higher remaining_capacity is better for spreading)\n    # Using a scaled exponential to give a significant boost to very open bins.\n    openness_scores = np.exp(0.1 * valid_bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)) # Scale by max capacity\n\n    # Combine scores using epsilon for adaptive weighting\n    # When epsilon is high (diverse capacities), openness_scores have more weight.\n    # When epsilon is low (similar capacities), goodness_of_fit_scores have more weight.\n    combined_scores = (1 - epsilon) * goodness_of_fit_scores + epsilon * openness_scores\n\n    # Softmax transformation to get priorities\n    # Shift scores to prevent overflow/underflow before exponentiation\n    shifted_scores = combined_scores - np.max(combined_scores)\n    exp_scores = np.exp(shifted_scores)\n    probabilities = exp_scores / np.sum(exp_scores)\n\n    # Create the final priority array\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n[Heuristics 20th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates priority scores for each bin using an adaptive strategy for the\n    online Bin Packing Problem. This version aims to balance fitting tightly\n    (Best Fit) with spreading items (Worst Fit) and incorporating an element\n    of exploration.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array where each element represents the\n                         remaining capacity of a bin.\n\n    Returns:\n        A numpy array of the same size as bins_remain_cap, where each element\n        is the priority score for placing the item in the corresponding bin.\n    \"\"\"\n    valid_bins_mask = bins_remain_cap >= item\n    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]\n\n    if valid_bins_remain_cap.size == 0:\n        return np.zeros_like(bins_remain_cap)\n\n    # --- Core Strategy: Balancing Best Fit and Worst Fit ---\n    # Best Fit component: Prioritize bins that leave minimal remaining space.\n    # We want to minimize (remaining_capacity - item).\n    # A good score for BF would be proportional to -(remaining_capacity - item).\n    # For Softmax, we want higher scores for better options. So, let's use\n    # a score that increases as remaining_capacity - item decreases.\n    # A simple inversion: 1 / (remaining_capacity - item + epsilon)\n    # Or, to keep it related to the previous approach: maximize -(remaining_capacity - item)\n    # To promote diversification, let's also consider the \"emptiness\" of the bin.\n    # Worst Fit component: Prioritize bins with *more* remaining capacity.\n    # This encourages spreading items.\n    # A score for WF could be proportional to remaining_capacity.\n\n    # Let's create a blended score.\n    # For Best Fit: prioritize small remaining capacity after placing the item.\n    # For Worst Fit: prioritize large initial remaining capacity.\n    # We want to maximize the utility.\n    # Let's consider the utility as a function of remaining capacity:\n    # utility = alpha * (1 / (valid_bins_remain_cap - item + 1e-9)) + beta * valid_bins_remain_cap\n\n    # For simplicity and to adapt the softmax approach, let's define scores\n    # where higher means more desirable.\n    # High score for small (remaining_capacity - item) => Best Fit tendency\n    # High score for large remaining_capacity => Worst Fit tendency (for exploration/diversification)\n\n    # Let's try a score that is a combination:\n    # Score = (large_capacity_bonus) * (remaining_capacity) - (misfit_penalty) * (remaining_capacity - item)\n    # A simpler approach:\n    # Prioritize bins where remaining_capacity - item is small (BF)\n    # BUT, also give a boost to bins that are \"more open\" (WF) to avoid early convergence.\n\n    # Let's combine the ideas:\n    # We want to favor small (remaining_capacity - item).\n    # Let's define a score for \"tightness\": TightnessScore = -(valid_bins_remain_cap - item)\n    # And a score for \"openness\": OpennessScore = valid_bins_remain_cap\n\n    # We can create a combined score, for example, by averaging or taking a weighted sum.\n    # A more robust approach is to introduce a \"temperature\" or \"exploration factor\"\n    # that modulates the influence of the Best Fit vs. Worst Fit tendencies.\n\n    # Let's try a score that is a compromise. We want to minimize (remaining_capacity - item).\n    # Let's use a function that is high when (remaining_capacity - item) is small.\n    # Consider a function like: `exp(-k * (remaining_capacity - item))`\n    # `k` can be an exploration parameter. A large `k` makes it more like Best Fit.\n    # A small `k` makes it flatter, more exploratory.\n\n    # To balance exploration and exploitation, let's make the \"tightness\" score\n    # have an exploratory element.\n    # Let's use a score that is high for bins that are \"good\" fits, but also\n    # has some preference for bins that aren't *too* full if an exact fit isn't available.\n\n    # --- Adaptive Exploration/Exploitation ---\n    # We can adapt the strength of the \"Best Fit\" tendency based on the distribution of remaining capacities.\n    # If capacities are very diverse, lean more towards Best Fit.\n    # If capacities are very similar, lean more towards diversification.\n\n    # A simple adaptation: Use a parameter `epsilon` that smooths the selection.\n    # Larger epsilon makes it more uniform (exploratory). Smaller epsilon makes it more greedy (exploitative).\n    # We can define epsilon based on the variance of remaining capacities.\n    variance_remain_cap = np.var(bins_remain_cap[bins_remain_cap > 0]) if np.any(bins_remain_cap > 0) else 1.0\n    # Scale variance to a reasonable epsilon range. Higher variance -> higher epsilon for more exploration.\n    epsilon = 0.1 + 0.5 * (1 / (1 + np.exp(-0.1 * variance_remain_cap))) # Sigmoid to bound epsilon\n\n    # Calculate scores:\n    # Score for \"good fit\" (lower remaining_capacity - item is better)\n    # Using a negative exponential for a sharp decrease in score as misfit increases.\n    # Adding epsilon for numerical stability and exploration.\n    goodness_of_fit_scores = np.exp(-10.0 * (valid_bins_remain_cap - item) / (item + 1e-9)) # Scale by item size\n\n    # Score for \"openness\" (higher remaining_capacity is better for spreading)\n    # Using a scaled exponential to give a significant boost to very open bins.\n    openness_scores = np.exp(0.1 * valid_bins_remain_cap / (np.max(bins_remain_cap) + 1e-9)) # Scale by max capacity\n\n    # Combine scores using epsilon for adaptive weighting\n    # When epsilon is high (diverse capacities), openness_scores have more weight.\n    # When epsilon is low (similar capacities), goodness_of_fit_scores have more weight.\n    combined_scores = (1 - epsilon) * goodness_of_fit_scores + epsilon * openness_scores\n\n    # Softmax transformation to get priorities\n    # Shift scores to prevent overflow/underflow before exponentiation\n    shifted_scores = combined_scores - np.max(combined_scores)\n    exp_scores = np.exp(shifted_scores)\n    probabilities = exp_scores / np.sum(exp_scores)\n\n    # Create the final priority array\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    priorities[valid_bins_mask] = probabilities\n\n    return priorities\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}