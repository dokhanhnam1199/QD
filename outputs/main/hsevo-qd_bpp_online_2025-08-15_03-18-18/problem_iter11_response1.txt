```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with adaptive diversification and a perfect fit bonus.
    Prioritizes tight fits while encouraging exploration through variance and
    rewarding perfect fits.
    """
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Best Fit Component: Smaller difference (slack) is better.
    slack = valid_bins_remain_cap - item
    bf_scores = -slack

    # Perfect Fit Bonus: Strongly reward bins with zero slack.
    perfect_fit_bonus = np.where(slack == 0, 10.0, 0.0) # Significant bonus for perfect fits

    # Adaptive Diversification Component: Use variance to adjust exploration.
    if len(valid_bins_remain_cap) > 1:
        variance_capacity = np.var(valid_bins_remain_cap)
        # Normalize variance: Higher relative variance encourages diversification.
        mean_cap = np.mean(valid_bins_remain_cap)
        normalized_variance = (variance_capacity / (mean_cap**2)) if mean_cap > 0 else 0
        
        # Heuristic: Reward larger capacities when variance is high (exploit better fits),
        # and penalize them when variance is low (encourage exploration of emptier bins).
        # The sign is flipped from v0 to align with rewarding larger capacities when variance is high.
        adaptive_div_scores = normalized_variance * valid_bins_remain_cap
    else:
        adaptive_div_scores = np.zeros_like(valid_bins_remain_cap)

    # Combine components with tunable weights.
    w_bf = 1.0
    w_perfect_fit = 1.0
    w_adapt_div = 0.5 # Weight for adaptive diversification

    combined_scores = w_bf * bf_scores + w_perfect_fit * perfect_fit_bonus + w_adapt_div * adaptive_div_scores

    # Apply Softmax for probabilistic selection. Shift for numerical stability.
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    priorities[valid_bins_mask] = probabilities

    return priorities
```
