```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with adaptive diversification using Softmax.
    Prioritizes bins that fit the item well, while also considering
    the overall distribution of remaining capacities to encourage exploration.
    """
    
    bin_capacities = 1.0  # Assuming a standard bin capacity of 1.0, can be generalized.
    
    potential_fits = bins_remain_cap - item
    
    valid_bins_mask = potential_fits >= 0
    
    if not np.any(valid_bins_mask):
        return np.zeros_like(bins_remain_cap)
    
    priorities = np.zeros_like(bins_remain_cap)
    
    # Best Fit component: Higher priority for smaller remaining capacity after fit
    priorities[valid_bins_mask] = 1.0 / (potential_fits[valid_bins_mask] + 1e-9)

    # Adaptive Diversification component: Adjust priorities based on variance
    # If variance is low, make differences more pronounced (higher temperature implicitly)
    # If variance is high, smooth out differences (lower temperature implicitly)
    valid_capacities = bins_remain_cap[valid_bins_mask]
    if len(valid_capacities) > 1:
        std_dev = np.std(valid_capacities)
        # A simple adaptive factor: penalize bins when capacities are very similar
        # More sophisticated would be to adjust temperature for softmax
        adaptive_factor = 1.0 # Default no adjustment
        if std_dev < np.mean(valid_capacities) * 0.1: # If capacities are very close
             adaptive_factor = 0.5 # Reduce influence of simple inverse difference
        
        priorities[valid_bins_mask] *= adaptive_factor

    # Apply Softmax for probabilistic selection, scaling to avoid extreme values
    # A simple temperature parameter can be added here, but for now, using raw priorities.
    # For example: temperature = 0.1; softmax_priorities = np.exp(priorities * temperature)
    
    # Normalize priorities to sum to 1 for a probabilistic interpretation
    sum_priorities = np.sum(priorities)
    if sum_priorities > 1e-9:
        return priorities / sum_priorities
    else:
        # If all valid bins have effectively zero priority, distribute probability equally
        normalized_priorities = np.zeros_like(bins_remain_cap)
        normalized_priorities[valid_bins_mask] = 1.0 / np.sum(valid_bins_mask)
        return normalized_priorities

```
