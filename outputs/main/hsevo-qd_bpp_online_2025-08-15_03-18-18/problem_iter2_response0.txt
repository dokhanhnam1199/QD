```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines best-fit inverse proximity with explicit perfect-fit handling
    and Softmax normalization for robust bin selection.
    Prioritizes bins that are a perfect fit, then bins with minimal remaining
    space, normalized using Softmax for probabilistic selection.
    """
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    valid_bins_capacities = bins_remain_cap[valid_bins_mask]
    
    perfect_fits_mask = valid_bins_capacities == item
    
    if np.any(perfect_fits_mask):
        perfect_fit_indices = np.where(valid_bins_mask)[0][perfect_fits_mask]
        priorities[perfect_fit_indices] = 1.0 

    non_perfect_fit_indices = np.where(valid_bins_mask)[0][~perfect_fits_mask]
    
    if len(non_perfect_fit_indices) > 0:
        non_perfect_capacities = bins_remain_cap[non_perfect_fit_indices]
        effective_capacities = non_perfect_capacities - item
        
        # Use inverse proximity for non-perfect fits, preventing division by zero
        priorities[non_perfect_fit_indices] = 1.0 / (effective_capacities + 1e-9)

    # Softmax normalization to ensure probabilities sum to 1, or handle all-zero case
    # Subtracting max before exp for numerical stability
    max_priority = np.max(priorities)
    exp_priorities = np.exp(priorities - max_priority)
    
    sum_exp_priorities = np.sum(exp_priorities)
    
    if sum_exp_priorities == 0:
        # If all calculated priorities are zero (e.g., only invalid bins), return uniform distribution
        return np.ones_like(bins_remain_cap) / len(bins_remain_cap)
    else:
        return exp_priorities / sum_exp_priorities
```
