```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Calculates priority scores for each bin using an adaptive, multi-objective
    strategy for the online Bin Packing Problem.

    This strategy aims to balance 'Best Fit' (minimizing waste) with a
    'First Fit Decreasing-like' tendency (preferring bins that are already
    somewhat full to pack larger items into, encouraging denser packing)
    and an adaptive component that slightly favors bins that have a capacity
    closer to the item size, but not so close as to leave excessive small gaps.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Heuristic 1: Best Fit (minimize remaining capacity after packing)
    # Score: -(remaining_capacity - item) -> Higher is better (closer to 0)
    best_fit_scores = -(valid_bins_remain_cap - item)

    # Heuristic 2: "Nearly Full" preference (slightly penalize bins that are too empty)
    # This encourages packing into bins that are already partially filled.
    # We can model this by looking at the ratio of current capacity to the item size,
    # or the inverse of the absolute difference if it's large.
    # Let's use a logistic function or similar to smooth this.
    # A simpler approach: penalize very large remaining capacities.
    # Maximize -(remaining_capacity) for large remaining_capacity.
    # Or, focus on the 'goodness' of the fit. A bin with capacity 100 for an item of 1
    # is less "interesting" than a bin with capacity 10 for an item of 8.
    # Let's try a score that is high when remaining_capacity - item is small,
    # and also considers the absolute remaining_capacity to be not excessively large.
    # A score proportional to 1 / (remaining_capacity - item + epsilon) for best fit.
    # For the "nearly full" aspect, we can add a term that is higher for bins
    # that are not *too* empty relative to the item.
    # Let's try a score that is high when (capacity - item) is small, but also
    # gives a slight preference to bins that have a moderate amount of remaining capacity
    # AFTER the item is placed, avoiding extremely tight fits that might leave very little space.

    # Adaptive component: Prioritize bins where the remaining capacity is
    # "just enough" or slightly more than the item. This is a form of
    # "good fit" that tries to leave a manageable residual.
    # We can model this by a function that peaks when `valid_bins_remain_cap - item` is small.
    # Let's try to maximize `1 / (valid_bins_remain_cap - item + epsilon)`.
    # However, this can be very sensitive.

    # Let's combine Best Fit with a term that favors bins that aren't too empty *before* packing.
    # Or, consider the ratio `item / capacity`. Higher ratio is better.
    # But we only have `bins_remain_cap`.
    # Let's use a score that is a function of `remaining_capacity - item`.
    # We want to minimize `remaining_capacity - item`.

    # Let's try a composite score:
    # Score = alpha * (- (capacity - item))  (Best Fit term)
    #       + beta * (1 / (capacity - item + epsilon)) (Favoring smaller residuals)
    #       + gamma * (1 / capacity) (Favoring less "empty" bins before packing)

    # For a simpler adaptive approach, let's focus on modifying the Best Fit score.
    # We want to slightly adjust the priority based on how "tight" the fit is.
    # If the residual `(capacity - item)` is very small, it's a good fit.
    # If it's moderately small, it's also good.
    # If it's large, it might be less ideal if there are other bins with smaller residuals.

    # Let's create a score that captures "good fit" as minimizing `remaining_capacity - item`.
    # `score = -(valid_bins_remain_cap - item)` is already this.

    # Now, let's add an adaptive aspect: if the item is relatively large compared to the
    # bin's current remaining capacity, we might want to give it a slight boost
    # if it's a "good fit" (low residual), to utilize potentially larger bins.
    # This can be related to the ratio `item / valid_bins_remain_cap`.

    # Let's try a score that emphasizes minimizing the residual capacity `R = capacity - item`.
    # Score = -(R)  (Best Fit)
    # We can add a bonus if `R` is small.
    # Or, we can use a more complex function of `R`.

    # Consider the residual `r = valid_bins_remain_cap - item`.
    # We want to minimize `r`.
    # A score like `-r` favors smaller `r`.
    # To make it adaptive, let's consider the "tightness" of the fit.
    # If `r` is very small, say `r < 0.1 * item`, it's a very tight fit.
    # If `r` is moderate, say `0.1 * item <= r < 0.5 * item`, it's a good fit.
    # If `r` is large, it's a loose fit.

    # Let's try a score that rewards minimizing `r`, but with a slight penalty for
    # bins that are *too* full (leaving almost no space).
    # A score that prioritizes bins where `r` is small, but not zero if that means
    # the bin was already almost full.

    # Let's define "goodness of fit" as a value that is high when `valid_bins_remain_cap - item`
    # is small and positive.
    # This value should be higher for smaller `valid_bins_remain_cap - item`.
    # We can use `1.0 / (valid_bins_remain_cap - item + epsilon)` as a base.
    # However, this can be very aggressive.

    # A more robust approach:
    # We want to minimize `residual = valid_bins_remain_cap - item`.
    # A score that favors smaller `residual` is `-(residual)`.
    # To make it adaptive, let's consider the proportion of the item to the bin's
    # *original* capacity if that information was available.
    # Since we only have remaining capacity, let's focus on the ratio of item size
    # to the remaining capacity. A higher ratio means the item is a larger fraction
    # of the available space.

    # Let's combine:
    # 1. Best Fit: minimize `valid_bins_remain_cap - item`. Score: `-(valid_bins_remain_cap - item)`
    # 2. Adaptive "Sweet Spot": Reward bins where `valid_bins_remain_cap - item`
    #    is small but not extremely close to zero, unless the item itself is very small.
    #    This can be modeled as a Gaussian-like function centered around a small positive residual.
    #    Let's simplify this: penalize very tight fits slightly.

    # A simpler approach: Softmax of `-(remaining_capacity - item)` is the Best Fit.
    # To adapt, let's add a term that considers the "quality" of the remaining space.
    # If `valid_bins_remain_cap` is large, the `item` takes up a small fraction.
    # If `valid_bins_remain_cap` is only slightly larger than `item`, the `item` takes up a large fraction.

    # Let's prioritize bins that have remaining capacity `C` such that `C - item` is small.
    # This is captured by `-(C - item)`.
    # Now, let's add an adaptive aspect: we want to avoid bins where `C` is *extremely* large,
    # if there are other bins that offer a "better" fit in terms of residual.
    # However, if no other bins offer a good fit, a large bin is still preferable to no bin.

    # Consider the score `S = -(valid_bins_remain_cap - item)`.
    # If `valid_bins_remain_cap - item` is very small, `S` is close to zero.
    # If `valid_bins_remain_cap - item` is large, `S` is a large negative number.

    # Let's introduce a term that boosts bins where the remaining capacity `C`
    # is not excessively larger than `item`.
    # This could be `1.0 / (valid_bins_remain_cap + epsilon)` or something similar.
    # This term would favor bins that are more "full" to begin with.

    # Proposed heuristic:
    # Score for bin `i` with remaining capacity `C_i`:
    # `score_i = -(C_i - item) + alpha * (item / C_i)`
    # The first term is Best Fit.
    # The second term favors bins where the item takes up a larger proportion
    # of the *available* capacity.

    # Let's refine this. We want to minimize `C_i - item`.
    # Let `residual = C_i - item`.
    # We want to minimize `residual`.
    # So, base score is `-residual`.

    # Adaptive component: If `residual` is very small, it's a good fit.
    # If `residual` is large, it's a poor fit.
    # We can use a function that is high for small, positive residuals.
    # A Gaussian-like function could work: `exp(-(residual - target_residual)^2 / sigma^2)`
    # where `target_residual` is a small positive value.

    # For simplicity, let's try to "boost" bins that have a reasonably small residual.
    # A score like `1 / (residual + epsilon)` can be too sensitive.

    # Let's try a combination of "Best Fit" and a preference for bins that are
    # not excessively empty *relative to the item's needs*.
    # Consider the ratio `item / C_i`. If this ratio is high, the item is large
    # relative to the space, which might be good if it's a good fit.

    # Let's use a score that balances minimizing `C_i - item` with a preference
    # for bins that are not "overly spacious".
    # `score = -(C_i - item) + lambda * (1.0 / (C_i + epsilon))`
    # The first term is Best Fit.
    # The second term encourages using bins that have less capacity overall,
    # as long as they can fit the item.

    # `lambda` can be tuned. Let's set `lambda = 0.5` as a starting point.
    # We are maximizing `-(C_i - item) + lambda * (1.0 / (C_i + epsilon))`

    # Final proposed logic:
    # 1. Base score: `-(valid_bins_remain_cap - item)` (Best Fit)
    # 2. Adaptive bonus: Reward bins where `item` is a significant fraction of
    #    `valid_bins_remain_cap`. This encourages packing larger items into
    #    bins that are already somewhat full, if the fit is good.
    #    Bonus: `item / valid_bins_remain_cap` - this can be problematic if `valid_bins_remain_cap` is small.
    #    Alternative bonus: `1.0 / (valid_bins_remain_cap - item + epsilon)` - this emphasizes small residuals.

    # Let's try a score that:
    # - Minimizes `residual = valid_bins_remain_cap - item`.
    # - Among bins with similar residuals, prefers bins that were less full initially (higher `valid_bins_remain_cap`). This is a slight deviation from pure Best Fit but can lead to better overall packing.

    # Score = `-(residual) - beta * valid_bins_remain_cap`
    # This is counter-intuitive. We want to minimize `residual` and maximize `valid_bins_remain_cap`.
    # So, `score = -(residual) + beta * valid_bins_remain_cap`.
    # This means for same residual, we prefer bins with larger remaining capacity.
    # This is like a "Worst Fit" on the remaining capacity among Best Fit candidates.

    # Let's reconsider the advice: "adapt their strategies based on problem instance characteristics".
    # The characteristic here is the distribution of item sizes and current bin capacities.
    # If most items are small, Best Fit might lead to many partially filled bins.
    # If items are varied, we might want to utilize larger bins more effectively.

    # Let's try to capture a "good fit" zone.
    # We want `residual = valid_bins_remain_cap - item` to be small and positive.
    # Score = `-(residual)`.

    # Adaptive element: If the item is large relative to the bin's capacity,
    # a good fit is more valuable.
    # Let's try to boost bins where `item / valid_bins_remain_cap` is high,
    # but only if the residual is not excessively large.

    # A more robust adaptive approach:
    # Score = `-(valid_bins_remain_cap - item) + alpha * f(valid_bins_remain_cap, item)`
    # where `f` is a function that captures the adaptive preference.

    # Consider a function that favors bins where `valid_bins_remain_cap` is
    # not excessively larger than `item`.
    # `f(C, i) = - (C - i)` if `C-i` is small.
    # `f(C, i) = - (C - i) + penalty_for_large_residual(C-i)`

    # Let's use a score that promotes "close fits" but also considers the
    # proportion of the item to the bin's capacity.
    # Score = `-(valid_bins_remain_cap - item)`  (Best Fit)
    #       + `0.2 * (item / valid_bins_remain_cap)` (Encourage using capacity)

    # This second term favors bins where the item takes up a larger portion of the
    # *available* space. This is heuristic, aiming to fill up bins more evenly.

    # Let's refine the adaptive component to be more robust to edge cases.
    # We want to minimize `residual = valid_bins_remain_cap - item`.
    # Score = `-(residual)`
    # Consider the ratio `item / valid_bins_remain_cap`.
    # If `item / valid_bins_remain_cap` is high, it means the item is large relative to the bin.
    # If it's also a good fit (small residual), this bin is a strong candidate.

    # Let's create a score that is higher for smaller `residual`.
    # And among those, slightly higher for bins that are not too "empty" relative to the item.
    # `score = -(valid_bins_remain_cap - item) - 0.1 * (valid_bins_remain_cap - item)^2`
    # This penalizes larger residuals quadratically, making it more sensitive to them.

    # A different angle: Prioritize bins where the "slack" `valid_bins_remain_cap - item`
    # is minimized, but also consider the "quality" of the remaining space.
    # If `valid_bins_remain_cap` is very large, even after placing the item,
    # it might not be an ideal bin if other options exist.

    # Let's try a score that is a function of `(valid_bins_remain_cap - item)`.
    # We want to minimize `valid_bins_remain_cap - item`.
    # Let `residual = valid_bins_remain_cap - item`.
    # Score = `-residual`.

    # Adaptive part: If `residual` is very small, it's good. If `residual` is large, it's bad.
    # Consider a score that is a concave function of `-residual`, for example `sqrt(-residual)`.
    # Or, a function that is peaked at a small positive residual.

    # Let's combine Best Fit with an indicator of how "tight" the fit is.
    # Score = `-(valid_bins_remain_cap - item) - alpha * (valid_bins_remain_cap / item)`
    # The second term penalizes bins that are much larger than the item.
    # Alpha needs to be tuned.

    # Let's go with a simpler adaptive boost.
    # The best fit strategy is to minimize `remaining_capacity - item`.
    # Let `residual = valid_bins_remain_cap - item`.
    # We want to minimize `residual`.
    # Score: `-(residual)`.

    # Adaptive term: Consider the ratio `item / valid_bins_remain_cap`.
    # This ratio tells us how much of the bin's capacity is being used.
    # We want to prioritize bins where this ratio is higher, IF it's a good fit.
    # Let's add a term that is proportional to this ratio.
    # `adaptive_score = -(valid_bins_remain_cap - item) + 0.5 * (item / valid_bins_remain_cap)`

    # Need to handle `valid_bins_remain_cap` being zero, though our mask prevents that.
    # But it can be very small. Add epsilon.
    epsilon = 1e-9
    adaptive_scores = -(valid_bins_remain_cap - item) + 0.5 * (item / (valid_bins_remain_cap + epsilon))

    # Softmax application
    shifted_scores = adaptive_scores - np.max(adaptive_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
