```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Hybrid heuristic combining Best Fit with a penalty for overly tight fits
    and a bonus for bins with ample remaining capacity.
    """
    valid_bins_mask = bins_remain_cap >= item
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    if not np.any(valid_bins_mask):
        return priorities

    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    # Best Fit Component: Penalize based on remaining capacity after packing.
    # Smaller remaining capacity is better.
    best_fit_scores = -(valid_bins_remain_cap - item)

    # Diversification Component: Reward bins with more initial remaining capacity.
    # This favors less full bins.
    diversification_scores = valid_bins_remain_cap

    # Combine components with weights. Tune these weights based on empirical performance.
    # w_bf = 1.0 emphasizes Best Fit.
    # w_div = 0.3 gives a moderate preference to less full bins.
    w_bf = 1.0
    w_div = 0.3
    
    combined_scores = w_bf * best_fit_scores + w_div * diversification_scores

    # Apply Softmax to get probabilities.
    # Shift scores to prevent overflow/underflow issues with large exponents.
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    priorities[valid_bins_mask] = probabilities

    return priorities
```
