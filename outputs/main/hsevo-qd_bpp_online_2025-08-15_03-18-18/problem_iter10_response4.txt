import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, softmax_shift_factor: float = 0.5168879405654931) -> np.ndarray:
    """
    Calculates priority scores for each bin using a Softmax-Based Fit strategy
    for the online Bin Packing Problem.

    This strategy prioritizes bins that have remaining capacity, with a higher
    priority given to bins that can accommodate the item without significant
    wastage, and also considers the overall "fullness" of bins.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.
        softmax_shift_factor: A factor to adjust the shifting of scores before
                              applying softmax, affecting the spread of priorities.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    # Filter out bins that cannot fit the item
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        # If no bin can fit the item, return zero priorities for all bins
        return np.zeros_like(bins_remain_cap)

    # Calculate a score for each valid bin:
    # We want to favor bins that are nearly full after placing the item.
    # (capacity - item) represents the remaining capacity after placement.
    # Smaller values of (capacity - item) are better.
    base_scores = -(valid_bins_remain_cap - item)

    # Apply Softmax to convert scores into probabilities (priorities)
    # To avoid numerical instability with very large or small scores, we can shift scores.
    # Subtracting a scaled version of the maximum score before exponentiation.
    shifted_scores = base_scores - (np.max(base_scores) * softmax_shift_factor)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Create the final priority array, placing calculated priorities in their original positions
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
