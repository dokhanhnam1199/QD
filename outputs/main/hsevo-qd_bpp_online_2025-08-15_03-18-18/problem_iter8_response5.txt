```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with adaptive diversification using scaled exponential scoring.
    Prioritizes tight fits while adaptively balancing exploration.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Score for Best Fit: proximity to zero remaining capacity
    # We want to maximize this, so use negative remaining capacity.
    best_fit_scores = -(valid_bins_remain_cap - item)

    # Adaptive diversification term: favoring bins with more remaining capacity
    # This term adds a positive value for bins that have *more* available space
    # beyond what's needed for the current item. We scale this by the item size
    # to make it relevant to the current packing context.
    diversification_scores = (valid_bins_remain_cap - item) * item

    # Combine scores: prioritize good fits and adaptively encourage diversification
    # Adding diversification_scores to best_fit_scores. A larger positive value
    # in diversification_scores (meaning more excess capacity relative to item size)
    # will increase the combined score.
    combined_scores = best_fit_scores + diversification_scores

    # Apply a slight penalty for bins that would become "too empty" after fitting.
    # This is a form of controlled diversification, discouraging extreme emptiness.
    # Penalty is proportional to the remaining space *after* fitting,
    # scaled by a factor to keep it less dominant than the fit itself.
    # If remaining space is large relative to the bin's current capacity, penalize.
    # Let's use a threshold on `remaining_capacity_after_fit / current_capacity`.
    # A simpler approach: penalize if remaining space after fit is large.
    penalty_factor = 0.05 # Tune this: smaller values make penalty less aggressive
    large_remaining_penalty_threshold = 0.75 # Penalize if remaining > 75% of current capacity
    
    # Calculate penalty: (remaining_space / current_capacity)
    # Only apply if it exceeds the threshold.
    penalty_base = (valid_bins_remain_cap - item) / valid_bins_remain_cap
    penalty_values = np.maximum(0, penalty_base - large_remaining_penalty_threshold) * penalty_factor
    
    # Subtract the penalty from combined scores
    final_scores = combined_scores - penalty_values

    # Softmax normalization for probabilistic selection
    # Shift scores to prevent overflow and improve numerical stability
    shifted_scores = final_scores - np.max(final_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Map probabilities back to the original bins array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
