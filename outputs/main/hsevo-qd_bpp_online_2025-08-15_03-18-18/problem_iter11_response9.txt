```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    A hybrid heuristic combining Best Fit with adaptive diversification.
    It rewards tight fits and offers a tunable bonus for less full bins,
    adapting the bonus based on the item's size relative to bin capacities.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # --- Core Components ---
    # 1. Best Fit (Exploitation): Score is higher for smaller remaining capacity after packing.
    # We maximize -(remaining_capacity - item).
    best_fit_scores = -(valid_bins_remain_cap - item)

    # 2. Diversification (Exploration): Score is higher for bins with more initial remaining capacity.
    # This encourages using less full bins. We can scale this by the item size
    # to make the diversification effect more pronounced for larger items.
    # A simple scaling: `valid_bins_remain_cap * (item / (item + np.mean(bins_remain_cap)))`
    # Or a simpler approach: directly use `valid_bins_remain_cap` but scale it.
    
    # Let's introduce a scaled diversification bonus that is higher for bins
    # that are significantly larger than the item. This helps avoid
    # filling up bins too quickly with items that fit only in large bins.
    # We can use a sigmoid-like function to control the bonus based on
    # how much "extra" space is left.
    
    # Define extra_space = valid_bins_remain_cap - item
    # We want to boost bins with larger extra_space, but not infinitely.
    # A function like `1 - exp(-k * extra_space)` or a scaled `extra_space` itself.
    
    # Let's combine Best Fit with a tunable diversification bonus.
    # The bonus is stronger for bins that have more remaining capacity.
    # Parameter `alpha` controls the strength of diversification.
    alpha = 0.3  # Weight for diversification. Tune this parameter.
    
    # The diversification score should be higher for bins with more available space.
    # We'll use `valid_bins_remain_cap` directly, weighted by `alpha`.
    # Higher `valid_bins_remain_cap` leads to a higher diversification score.
    diversification_scores = valid_bins_remain_cap

    # Combine scores: Maximize `BestFitScore + alpha * DiversificationScore`
    # This means maximizing `-(valid_bins_remain_cap - item) + alpha * valid_bins_remain_cap`
    # Which simplifies to `(alpha - 1) * valid_bins_remain_cap + item`.
    # This formulation favors less full bins (higher `valid_bins_remain_cap`) if `alpha < 1`.
    
    # Using weighted sum directly for Softmax input
    # We want to maximize the score.
    composite_scores = best_fit_scores + alpha * diversification_scores
    
    # Softmax transformation to get probabilities (priorities)
    # Shift scores to ensure numerical stability for exponentiation.
    # Subtracting the maximum score centers the values around zero.
    if composite_scores.size > 0:
        shifted_scores = composite_scores - np.max(composite_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    # Initialize priorities array with zeros
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    # Assign computed probabilities to the valid bins
    priorities[valid_bins_mask] = probabilities

    return priorities

```
