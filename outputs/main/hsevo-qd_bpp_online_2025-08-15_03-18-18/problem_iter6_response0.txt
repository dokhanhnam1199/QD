```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_capacity: float) -> np.ndarray:
    """
    Calculates priority scores for each bin using an adaptive, multi-objective
    strategy for the online Bin Packing Problem.

    This strategy considers multiple objectives:
    1. Minimizing wasted space (Best Fit)
    2. Encouraging the use of less full bins to promote better overall packing (Worst Fit aspect)
    3. Preferring bins that are closer to a "golden ratio" fill level, promoting balanced packing.

    The priorities are generated using a weighted combination of scores derived from these objectives,
    with weights that could potentially be adapted (though fixed in this implementation for simplicity).

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element represents the
                         remaining capacity of a bin.
        bin_capacity: The total capacity of each bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
    """
    # Filter out bins that cannot fit the item
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]
    valid_bins_indices = np.where(valid_bins_mask)[0]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap, dtype=float)

    # Objective 1: Minimize wasted space (Best Fit)
    # Score is proportional to -(remaining_capacity - item). Higher is better (closer to 0).
    # Adding a small epsilon to avoid division by zero if remaining capacity is exactly `item`.
    best_fit_scores = -(valid_bins_remain_cap - item) + 1e-9

    # Objective 2: Encourage less full bins (to spread items)
    # Score is proportional to the current remaining capacity. Higher is better.
    # This encourages using bins that are not yet very full.
    spread_scores = valid_bins_remain_cap

    # Objective 3: Golden Ratio inspired fill (promoting balanced packing)
    # We want the ratio of (capacity - remaining_after_fit) / capacity to be near a target.
    # A target of 1/phi (approx 0.618) or phi-1 (approx 0.618) for the filled portion could be good.
    # Let's aim for the remaining capacity to be around (1 - 0.618) * capacity = 0.382 * capacity.
    # So, we want `valid_bins_remain_cap - item` to be close to 0.382 * capacity.
    # Score is higher when `valid_bins_remain_cap - item` is closer to this target.
    target_remaining = 0.382 * bin_capacity
    golden_ratio_scores = -np.abs(valid_bins_remain_cap - item - target_remaining)

    # Combine objectives with weights. These weights can be learned or set based on analysis.
    # For this example, we'll use fixed weights.
    # Weight for Best Fit: higher priority for exact fits.
    # Weight for Spreading: moderate priority for using less full bins.
    # Weight for Golden Ratio: moderate priority for balanced fills.
    w_best_fit = 0.5
    w_spread = 0.25
    w_golden_ratio = 0.25

    combined_scores = (
        w_best_fit * best_fit_scores +
        w_spread * spread_scores +
        w_golden_ratio * golden_ratio_scores
    )

    # Normalize combined scores for Softmax. Shift by max to prevent overflow.
    shifted_scores = combined_scores - np.max(combined_scores)
    exp_scores = np.exp(shifted_scores)
    probabilities = exp_scores / np.sum(exp_scores)

    # Create the final priority array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
