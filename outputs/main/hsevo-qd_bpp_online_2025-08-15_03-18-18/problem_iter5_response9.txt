```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Combines Best Fit with a penalty for overly full bins and an explicit bonus for perfect fits.
    Prioritizes bins that closely fit the item, penalizes those that become too full,
    and gives a high reward for exact matches.
    """
    valid_bins_mask = bins_remain_cap >= item
    valid_bins_remain_cap = bins_remain_cap[valid_bins_mask]

    if valid_bins_remain_cap.size == 0:
        return np.zeros_like(bins_remain_cap)

    # Calculate remaining capacity after packing
    rem_after_pack = valid_bins_remain_cap - item

    # Component 1: "Best Fit" - prioritize smaller remaining capacity
    # Higher score for smaller remaining capacity
    best_fit_scores = -rem_after_pack

    # Component 2: Penalty for overly full bins (makes remaining capacity very small)
    # We want to reduce the score if rem_after_pack is close to zero.
    # Use an exponential decay that is strong for small remaining capacity.
    # Scale rem_after_pack to avoid overflow/underflow in exp and control sensitivity.
    min_rem = 0.0
    max_rem = np.max(valid_bins_remain_cap) - item if np.max(valid_bins_remain_cap) >= item else 0.0
    
    if max_rem == min_rem: # Handle case where all valid bins have same remaining capacity
        diversification_penalty = np.zeros_like(best_fit_scores)
    else:
        scaled_rem = 5 * rem_after_pack / max_rem # Scale to [0, 5] range
        # Penalty is high when scaled_rem is low (i.e., tight fit)
        # Use 1 - sigmoid to get a penalty that is high for low values
        diversification_penalty = 1.0 - (1.0 / (1.0 + np.exp(10 * (1.0 - scaled_rem)))) # Penalty ~ 1 for tight fit, ~ 0 for loose fit

    # Component 3: Bonus for perfect fits
    # Assign a significantly higher score to bins where rem_after_pack is zero (or very close to zero)
    perfect_fit_bonus = np.zeros_like(best_fit_scores)
    perfect_fit_threshold = 1e-9 # Tolerance for floating point comparison
    is_perfect_fit = rem_after_pack < perfect_fit_threshold
    perfect_fit_bonus[is_perfect_fit] = 10.0 # Large bonus for perfect fits

    # Combine scores: best_fit + bonus - penalty
    # The penalty is subtracted from the score to reduce priority for overly full bins.
    # The bonus is added to strongly favor perfect fits.
    combined_scores = best_fit_scores + perfect_fit_bonus - diversification_penalty * 2.0 # Penalty multiplier to control its impact

    # Apply Softmax to get probability distribution
    # Shift scores to prevent overflow/underflow in exp
    if combined_scores.size > 0:
        shifted_scores = combined_scores - np.max(combined_scores)
        exp_scores = np.exp(shifted_scores)
        probabilities = exp_scores / np.sum(exp_scores)
    else:
        probabilities = np.array([])

    # Map probabilities back to the original bins array
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    priorities[valid_bins_mask] = probabilities

    return priorities
```
