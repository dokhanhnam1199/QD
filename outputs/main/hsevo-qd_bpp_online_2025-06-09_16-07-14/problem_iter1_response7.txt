```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Inspired by quantum tunneling and simulated annealing.
    Uses a "temperature" parameter that decays over time
    (not explicitly here, but designed to be used in that context).
    Low temperature favors bins that are almost full. High temperature
    allows more exploration (fitting into any available bin).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    temperature = 0.5  # Higher temperature encourages exploration
    epsilon = 1e-9  # Small value to prevent division by zero and log of zero

    # Calculate the waste if the item is placed in the bin
    waste = bins_remain_cap - item

    # Initialize priorities with a low value if the item doesn't fit
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    
    # Find indices where item fits
    valid_indices = np.where(waste >= -epsilon)[0]

    if len(valid_indices) > 0:
        #Focus on bins that can fit the item

        waste_valid = waste[valid_indices]
        remain_cap_valid = bins_remain_cap[valid_indices]
        
        # "Tunneling probability":  Higher if waste is lower
        tunneling_probability = np.exp(-np.abs(waste_valid) / (temperature + epsilon))
    
        # A term favoring bins closer to full to reduce fragmentation. 
        # Penalizes smaller remain_cap in favor of near full bins.
        capacity_factor =  (1 / (remain_cap_valid + epsilon))

        normalized_capacity_factor = capacity_factor / np.sum(capacity_factor)

        priorities[valid_indices] = tunneling_probability * normalized_capacity_factor
    
    return priorities
```
