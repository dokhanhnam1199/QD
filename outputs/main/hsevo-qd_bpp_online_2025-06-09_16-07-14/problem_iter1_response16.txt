```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    Employs a combination of factors including remaining capacity,
    item size relative to bin size, and penalty for exceeding capacity.
    Uses a simulated Hawking radiation concept: smaller bins are more likely to "evaporate" (fill up).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Hawking radiation inspired component: smaller bins are prioritized.
    inverse_capacities = 1.0 / (bins_remain_cap + 1e-9)  # Avoid division by zero. Smaller cap, larger value.

    # Relative size difference penalty: Prioritize bins where the item fits reasonably well.
    size_difference = np.abs(bins_remain_cap - item)
    size_penalty = np.exp(-size_difference)  # Higher when size diff is smaller, exponentially.

    # Immediate Fit Bonus
    immediate_fit = (bins_remain_cap >= item).astype(float)
    
    # Capacity overflow penalty. VERY severe. Mimics event horizon.
    overflow_penalty = np.where(bins_remain_cap < item, -np.inf, 0)

    # Combine the factors, weighting them according to importance
    priorities = (
        0.5 * inverse_capacities +
        0.4 * size_penalty +
        0.2 * immediate_fit +
        overflow_penalty  # Always ensure overflow results in -inf priority
    )

    return priorities
```
