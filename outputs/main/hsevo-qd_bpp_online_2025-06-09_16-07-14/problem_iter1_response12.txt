```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This version considers:
    1. Whether the item fits (immediate filter).
    2. How much space would be wasted (smaller waste is better).
    3. Preference for bins that are already somewhat filled (higher fill is better).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Filter out bins that are too small
    fits = bins_remain_cap >= item

    # Calculate waste if item were placed in bin.
    waste = bins_remain_cap - item

    # If a bin fits, give it a priority based on how little waste it generates.
    # Prioritize bins that leave a relatively smaller amount of waste.
    priorities[fits] = np.exp(-waste[fits] / np.mean(bins_remain_cap)) # Use exponential to control decay of priority

    # Additionally, boost the priority of bins that are already somewhat filled
    # to reduce the number of bins used.  Prioritization helps consolidate use.

    filled_ratio = (1 - bins_remain_cap / np.max(bins_remain_cap)) #relative fill to the max capacity bin
    priorities += 0.5 * filled_ratio  # add a small weight
    # If no bin fits, all priorities are zero
    return priorities
```
