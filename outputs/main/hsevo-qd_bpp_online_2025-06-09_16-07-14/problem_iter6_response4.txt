```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Adaptive heuristic that combines Gaussian fit, capacity ratio, and bin fullness for bin selection.
    It prioritizes bins that are a good fit for the item and close to being full.
    """

    # Gaussian fit based on item size
    mu = item
    sigma = item / 3.0
    gaussian = np.exp(-((bins_remain_cap - mu) ** 2) / (2 * sigma**2))

    # Capacity ratio (item size relative to remaining capacity)
    ratios = item / (bins_remain_cap + 1e-9)

    # Bin fullness: Reward bins that are already relatively full
    bin_fullness = 1 - (bins_remain_cap / np.max(bins_remain_cap))  # Normalize to [0, 1]

    # Combine the factors with adaptive weights based on the item size and the number of bins
    num_bins = len(bins_remain_cap)
    weight_gaussian = 0.5  # Base weight
    weight_ratio = 0.3 # Base Weight
    weight_fullness = 0.2 # Base weight
    
    # Tune weights based on item size
    if item < 0.2:
        weight_gaussian += 0.1 # Favor Gaussian for small items
        weight_fullness -= 0.1 # reduce the fullnes impact

    elif item > 0.8:
        weight_ratio += 0.1 # Favor capacity ratio for large items
        weight_gaussian -= 0.1 # reduce gaussian impact
    
    # If there are many bins, prioritize Gaussian fit slightly more
    if num_bins > 10:
      weight_gaussian += 0.05
      weight_fullness -= 0.05

    priorities = weight_gaussian * gaussian + weight_ratio * (1 - ratios) + weight_fullness * bin_fullness

    priorities[bins_remain_cap < item] = -np.inf  # Never pick impossible bins

    # Give a small bonus to bins that are almost full after placing the item
    almost_full_bonus = np.where((bins_remain_cap - item) < 0.1, 0.1, 0) # If remaining cap is less than 0.1 after placing the item, add bonus
    priorities += almost_full_bonus

    return priorities
```
