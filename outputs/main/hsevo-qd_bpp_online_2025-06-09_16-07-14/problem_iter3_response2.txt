```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    An adaptive priority function that dynamically adjusts its parameters
    based on the item size and remaining bin capacities. It combines a
    modified Gaussian fit with a capacity ratio and incorporates a penalty
    for bins that are nearly full.
    """
    
    # Adaptive Gaussian parameters: adjust sigma based on the distribution
    # of remaining capacities.
    mu = item
    sigma = np.std(bins_remain_cap) / 2.0 + item / 5.0  # Adaptive sigma
    sigma = max(sigma, item / 10.0) # Ensure sigma is not too small

    gaussian = np.exp(-((bins_remain_cap - mu) ** 2) / (2 * sigma**2))
    
    # Capacity ratio with added encouragement for bins slightly larger than the item.
    ratios = item / (bins_remain_cap + 1e-9)
    
    # Encourage bins slightly larger than the item.
    # The closer the capacity to the item size, the better.
    capacity_preference = np.exp(-((bins_remain_cap - item) ** 2) / (2 * (item/4)**2))
    
    # Penalize bins that are nearly full (high risk of creating fragmentation).
    nearly_full_penalty = np.zeros_like(bins_remain_cap)
    nearly_full_indices = (bins_remain_cap > item) & (bins_remain_cap < 2 * item)  #Bins only slightly larger than item
    nearly_full_penalty[nearly_full_indices] = -0.5 * (2*item - bins_remain_cap[nearly_full_indices]) / item   #Linear penalty; larger as it gets close to the capacity = item
    
    priorities = gaussian + 0.2 * (1 - ratios) + 0.3 * capacity_preference + nearly_full_penalty

    priorities[bins_remain_cap < item] = -np.inf  # Never pick impossible bins

    return priorities
```
