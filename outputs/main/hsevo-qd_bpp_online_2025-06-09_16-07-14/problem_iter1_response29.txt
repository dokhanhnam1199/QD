```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.
    This version prioritizes bins where the item fits and the remaining capacity
    after packing the item is small, but not excessively small (avoiding near-full bins).
    If no bins can accomodate the item, return low priority for all bins

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins where the item fits
    feasible_bins = bins_remain_cap >= item

    if not np.any(feasible_bins):
        # If no bin can accommodate the item, assign very low priority, indicating infeasibility
        return priorities

    # Calculate remaining capacity after adding the item
    remaining_capacity = bins_remain_cap - item

    # Prioritize bins where the item fits, with a preference for smaller remaining capacity,
    # but penalize bins that would become too full (very small remaining capacity).
    # Use a combination of terms:
    #   - A term inversely proportional to the remaining capacity.  A small remainder
    #     means higher priority.

    priorities[feasible_bins] = (1.0 / (remaining_capacity[feasible_bins] + 0.00001)) #Avoid div by 0

    #Adjust priorities for bins that get very full
    nearly_full = (remaining_capacity >= 0) & (remaining_capacity < 0.1) #tune this parameter

    priorities[nearly_full] = priorities[nearly_full] * 0.5  #Reduce priority if almost full


    return priorities
```
