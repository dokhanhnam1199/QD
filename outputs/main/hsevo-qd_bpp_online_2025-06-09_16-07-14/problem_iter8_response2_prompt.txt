{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    An enhanced priority function that combines Gaussian fit, capacity ratio, and a near-full bin reward.\n    Adaptively adjusts the Gaussian sigma based on item size, and incorporates a state-based perturbation.\n    \"\"\"\n\n    # Gaussian component, adaptive sigma\n    mu = item\n    sigma = item / 2.0  # Adjust sigma for sensitivity to bins close to item size.  Smaller sigma is more selective\n    gaussian = np.exp(-((bins_remain_cap - mu) ** 2) / (2 * sigma**2))\n\n    # Capacity ratio component\n    ratios = item / (bins_remain_cap + 1e-9)\n    capacity_priority = 0.1 * (1 - ratios)\n\n    # Near-full bin reward: Increased probability for bins that, after packing, will be over 75% full\n    near_full_threshold = 0.25  # Bin must have remaining capacity within 25% of bin size after placement.  Higher values are more selective\n    near_full_reward = np.where(bins_remain_cap - item <= near_full_threshold, 0.5, 0)  # Stronger reward than capacity ratio\n\n    # Combine components\n    priorities = gaussian + capacity_priority + near_full_reward\n\n    # Never pick impossible bins\n    priorities[bins_remain_cap < item] = -np.inf\n\n    return priorities\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    ratios = item / bins_remain_cap\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n### Analyze & experience\n- Comparing (1st) vs (20th), we see the best heuristic uses a combination of Gaussian fit, capacity ratio, and adaptive exploration, while the worst only uses the negative log of the item/bin ratio. (2nd) is much simpler than (1st), lacking the iteration-based exploration and almost-full bin bonus. The core difference lies in the sophistication of the priority calculation.\nComparing (1st) vs (3rd), there is no difference. Comparing (2nd) vs (7th), we see that (7th) adds the near-full bin reward to Gaussian fit and capacity ratio, while (2nd) is using just the Gaussian fit and capacity ratio. Comparing (16th) vs (20th), there is no difference.\nOverall: The best heuristics employ a multi-faceted approach, combining Gaussian distributions centered on the item size with capacity ratios and adaptive elements (exploration factor, almost full bin bonus, bin utilization). Simpler approaches relying solely on capacity ratios tend to perform worse. Adaptive exploration and bonuses for almost-full bins appear to significantly improve performance. Gaussian distribution is an important component to have.\n- \nOkay, let's refine self-reflection for designing better heuristics, focusing on actionable insights and avoiding vague statements. Here's a breakdown:\n\n*   **Keywords:** Actionable Insights, Data-Driven Adaptation, Constraint Awareness, Performance Metrics.\n\n*   **Advice:** Instead of just noting that parameters *can* be tuned, identify *how* to tune them. Use performance metrics to guide parameter adaptation based on real-time bin state. Quantify \"almost full\" with specific capacity thresholds for bonuses.\n\n*   **Avoid:** Vague statements like \"consider multiple factors\" or \"complex heuristics perform better.\" This lacks specific guidance.\n\n*   **Explanation:** Actionable self-reflection means deriving concrete steps. Focus on quantifying domain knowledge and using performance data to drive adaptive heuristic adjustments, all while respecting constraints.\n\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}