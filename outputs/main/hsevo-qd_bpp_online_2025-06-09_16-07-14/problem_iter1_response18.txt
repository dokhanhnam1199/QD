```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a base value (e.g., 0).
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Iterate through each bin and calculate its priority.
    for i, remaining_capacity in enumerate(bins_remain_cap):
        if remaining_capacity >= item:
            # First Fit Decreasing inspired: Favour bins where the item fits *best*.
            # We want a good fit, not too loose or too tight.
            # Reward bins with the item fitting and some space left over.

            fit_ratio = item / remaining_capacity
            # A value close to 1 means item almost fills the bin
            #A value close to 0 means there is ample space remaining.

            #Prioritize if the item occupies a sweet spot of bin capacity
            #Empirically chosen values for now; these can be tweaked.

            if 0.5 <= fit_ratio <= 0.95: #Fit between 50%-95% is rewarded
                 priorities[i] = 1.0 / (1.0-fit_ratio) #Higher priority when its nearing the ideal range of 95% from the item/capacity
            elif fit_ratio < 0.5: #if its smaller than 50%, there isn't much of reward

                priorities[i] = fit_ratio

            else:
                 priorities[i]=0 #Do not prioritize these values, as their nearing the capacity constraints.
                # Penalize bins where the item nearly fills it, because less
                # room for the next items and causes fragmentation
        else:
            # If the item doesn't fit, assign a very low priority (or negative).
            priorities[i] = -1e9  # A large negative number makes it very unlikely.

    return priorities
```
