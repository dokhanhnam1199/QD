```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray, bin_usage_history: np.ndarray = None) -> np.ndarray:
    """
    Adaptive priority function that combines Gaussian fit, capacity ratio, and bin usage history for online bin packing.

    Args:
        item (float): The size of the item to be packed.
        bins_remain_cap (np.ndarray): An array containing the remaining capacity of each bin.
        bin_usage_history (np.ndarray, optional): An array containing the number of items packed into each bin. Defaults to None.

    Returns:
        np.ndarray: An array of priority scores for each bin.
    """

    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins)

    # 1. Gaussian component (adaptive variance)
    mu = item
    # Adaptive sigma:  smaller sigma when bins are nearly full, larger when bins are mostly empty.
    average_remaining_capacity = np.mean(bins_remain_cap)
    sigma = item / (2 + average_remaining_capacity/np.max([item,1e-9])) # prevent divide by zero

    gaussian = np.exp(-((bins_remain_cap - mu) ** 2) / (2 * sigma**2))
    priorities += gaussian

    # 2. Capacity Ratio component
    ratios = item / (bins_remain_cap + 1e-9)
    priorities += 0.1 * (1 - ratios)

    # 3. Bin Usage History component (if available)
    if bin_usage_history is not None:
        # Preferentially select bins with fewer items already packed (to balance load).
        # Scale the influence to avoid dominating other components.
        max_usage = np.max(bin_usage_history)
        if max_usage > 0:
            usage_penalty = (max_usage - bin_usage_history) / max_usage
            priorities += 0.05 * usage_penalty  # Adjust the weight as needed

    # 4. Feasibility enforcement
    priorities[bins_remain_cap < item] = -np.inf  # Never pick impossible bins

    # 5. Preferentially choose bins that are nearly full after packing
    remaining_after_pack = bins_remain_cap - item
    nearly_full_bonus = np.exp(-(remaining_after_pack**2)/(2*(item/5)**2)) # gaussian like bonus.
    nearly_full_bonus[remaining_after_pack < 0] = 0 # only consider feasible options.
    priorities += 0.2 * nearly_full_bonus

    return priorities
```
