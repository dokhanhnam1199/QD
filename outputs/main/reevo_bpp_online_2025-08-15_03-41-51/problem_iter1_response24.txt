```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First strategy.

    The Exact Fit First strategy prioritizes bins that can accommodate the item exactly.
    If no bin can fit the item exactly, it prioritizes bins that can fit the item
    with the smallest remaining capacity (i.e., the "tightest fit").

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that can exactly fit the item
    exact_fit_mask = (bins_remain_cap == item)
    if np.any(exact_fit_mask):
        priorities[exact_fit_mask] = 1.0  # Highest priority for exact fits
    else:
        # If no exact fit, find bins that can fit the item and prioritize the tightest fit
        can_fit_mask = (bins_remain_cap >= item)
        if np.any(can_fit_mask):
            # For bins that can fit, the priority is inversely related to the remaining capacity
            # minus the item size. Smaller difference means tighter fit.
            # We use a large constant to ensure these have lower priority than exact fits
            # and then scale based on the difference to rank them.
            fitting_bins_capacities = bins_remain_cap[can_fit_mask]
            differences = fitting_bins_capacities - item
            # To make smaller differences have higher priority, we take the negative or use a large constant minus the difference
            priorities[can_fit_mask] = 1000.0 - differences
        # Bins that cannot fit the item will have a priority of 0, as initialized.

    return priorities
```
