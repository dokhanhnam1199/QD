{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This version aims to balance tight fits with future flexibility using a\n    sigmoid-like function. It also incorporates a small bonus for larger\n    remaining capacities to encourage more even distribution.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # --- Heuristic Calculation ---\n    # For bins that can fit the item, calculate a priority score.\n    # The score is a combination of how tightly it fits and a bonus for larger capacities.\n\n    # Calculate the \"tightness\" score: smaller remaining capacity after packing is better.\n    # We want to penalize bins with very large remaining capacity if they are too large.\n    # A sigmoid-like function can map the \"waste\" (remaining_cap - item) to a priority.\n    # Smaller waste -> higher priority. We want to avoid large positive waste values.\n    # Let's consider the inverse: remaining_cap. Higher remaining_cap might be worse for tightness.\n    # A function that is high for small remaining_cap and low for large remaining_cap.\n    # We can use a transformation like 1 / (1 + x) or exp(-x).\n    # Let's use a function that is high when remaining_cap is just above 'item'.\n\n    # Option 1: Focus on minimal remaining capacity (tightest fit)\n    # We want bins where `bins_remain_cap - item` is minimized.\n    # Let's map `bins_remain_cap` directly. High priority for small `bins_remain_cap` if they fit.\n    # Softmax or sigmoid can be good here. Let's use a scaled inverse of remaining capacity\n    # and add a small bonus for larger capacities to encourage distribution.\n\n    # Calculate the actual remaining capacity after packing\n    remaining_after_packing = bins_remain_cap[can_fit_mask] - item\n\n    # We want smaller `remaining_after_packing` to have higher priority (tight fit).\n    # Let's use a scaled inverse relationship.\n    # To avoid division by zero or very small numbers, add a small epsilon.\n    epsilon_small = 1e-6\n    tightness_scores = 1.0 / (remaining_after_packing + epsilon_small)\n\n    # Add a small bonus for larger *original* remaining capacities to encourage spreading.\n    # This bonus should be smaller than the tightness score.\n    # Let's scale the original `bins_remain_cap` for the bonus.\n    # The bonus should be higher for larger capacities.\n    larger_capacity_bonus = bins_remain_cap[can_fit_mask] / np.max(bins_remain_cap[can_fit_mask] + epsilon_small)\n    bonus_weight = 0.2  # Controls how much the bonus affects the score\n\n    # Combine tightness and bonus. The tightness should dominate.\n    # We can use a weighted sum.\n    combined_scores = tightness_scores + bonus_weight * larger_capacity_bonus\n\n    # Normalize combined_scores to be between 0 and 1 for better interpretability/stability\n    if np.max(combined_scores) > 0:\n        normalized_combined_scores = combined_scores / np.max(combined_scores)\n    else:\n        normalized_combined_scores = np.zeros_like(combined_scores)\n\n\n    # Assign these normalized scores to the priorities array for the fitting bins\n    priorities[can_fit_mask] = normalized_combined_scores\n\n    # Ensure bins that cannot fit have zero priority\n    priorities[~can_fit_mask] = 0.0\n\n    # Optional: Add a small random noise to break ties and encourage exploration\n    # This is similar to the epsilon-greedy idea but applied to the output scores.\n    # Add small random noise to all bins that can fit.\n    if np.any(can_fit_mask):\n        noise_magnitude = 0.05  # Small magnitude for noise\n        noise = np.random.uniform(-noise_magnitude, noise_magnitude, size=priorities[can_fit_mask].shape)\n        priorities[can_fit_mask] += noise\n        # Ensure priorities remain non-negative after adding noise\n        priorities[can_fit_mask] = np.maximum(0.0, priorities[can_fit_mask])\n\n    # Final normalization to ensure scores are in a reasonable range and the max is 1\n    if np.max(priorities) > 0:\n        priorities = priorities / np.max(priorities)\n    else:\n        # If all bins are still 0 (e.g., item too large for all), they remain 0.\n        pass\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a \"Best Fit\" strategy. It prioritizes\n    bins that can accommodate the item with the least amount of remaining\n    capacity (i.e., the tightest fit). This is because packing an item\n    into a bin that is nearly full leaves less \"wasted\" space in that bin.\n    Bins that cannot accommodate the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins that cannot fit the item\n        will have a very low priority (negative infinity).\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that have enough remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, we want to prioritize those that leave\n    # the least amount of remaining space after the item is placed.\n    # This means minimizing (bins_remain_cap - item).\n    # A simple way to turn minimization into maximization for priority is to\n    # use the negative of the slack space: `-(bins_remain_cap - item)`.\n    # A smaller positive slack `bins_remain_cap - item` will result in a\n    # less negative (higher) priority score.\n    \n    # Example: item = 0.3, bins_remain_cap = [0.35, 0.4, 0.5, 0.2]\n    # can_fit_mask = [True, True, True, False]\n    # For fitting bins:\n    # slack_bins_remain_cap = [0.35, 0.4, 0.5]\n    # resulting_remain_cap = [0.05, 0.1, 0.2]\n    # priority_scores = [-0.05, -0.1, -0.2]\n    # The bin with remaining capacity 0.35 (slack 0.05) gets the highest priority (-0.05).\n    \n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities\n\n[Reflection]\nPrioritize tightest fits. Avoid complex combinations; simplicity often yields better results.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}