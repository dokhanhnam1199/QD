```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit strategy.

    In Random Fit, any bin that can accommodate the item is a candidate.
    To implement a priority function, we assign a higher priority to bins that are
    a "tighter fit" for the item, meaning they have just enough capacity for the item.
    This encourages filling bins more completely. For bins that are not suitable,
    the priority is zero.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    suitable_bins_mask = bins_remain_cap >= item

    # For suitable bins, calculate priority as the inverse of the remaining capacity
    # after placing the item. A smaller remaining capacity (tighter fit) gets a higher priority.
    # We add a small epsilon to avoid division by zero if an item perfectly fills a bin.
    suitable_bin_capacities = bins_remain_cap[suitable_bins_mask]
    # A smaller remaining capacity after fitting means a better fit.
    # To prioritize better fits, we can use the negative of the remaining capacity.
    # Or, to make it a positive score, we can use 1 / (remaining_capacity + epsilon)
    # or something like (max_capacity - item_size) / (current_remaining_capacity - item_size).
    # Let's go with a simple approach: higher priority for bins with less excess capacity.
    # This can be achieved by giving a score based on how close the remaining capacity
    # is to the item size.

    # Option 1: Prioritize bins that have the least excess capacity (closest fit)
    # If a bin has remaining_capacity, and we add 'item', the new remaining_capacity is remaining_capacity - item.
    # A tighter fit means remaining_capacity - item is small.
    # So, higher priority for smaller (remaining_capacity - item).
    # We can assign priority as - (remaining_capacity - item).
    priorities[suitable_bins_mask] = - (suitable_bin_capacities - item)

    # Option 2: Random Fit doesn't explicitly define a "best" bin,
    # it picks *any* suitable bin randomly.
    # If we need a priority function that leads to random selection among suitable bins:
    # 1. Assign a uniform positive score to all suitable bins.
    # 2. The selection process (outside this function) would then randomly pick
    #    from the bins with the highest priority.
    # This function, however, must *return* priorities, implying a deterministic choice.
    # The "Random Fit" often refers to the *algorithm's decision rule* rather than
    # a strict priority score for a heuristic.
    # For this specific task of returning priorities, and given the prompt's wording
    # "The bin with the highest priority score will be selected for the item,"
    # we need to provide scores that guide selection.

    # Let's refine Option 1 to be more aligned with a heuristic's goal of good packing.
    # The spirit of "Random Fit" is often about not overthinking the choice if many are available.
    # However, if we MUST assign priorities, a reasonable heuristic priority would be
    # to favor bins that are *just big enough*, minimizing wasted space in that specific bin.
    # This is captured by `bins_remain_cap - item` being small.
    # So, negative of that value is a good proxy for priority.

    # Ensure priorities are not positive if we are trying to find "least" of something,
    # but here higher priority score means better.
    # A smaller `bins_remain_cap - item` implies a better fit.
    # Let's use `1.0 / (bins_remain_cap - item + epsilon)` to favor smaller gaps,
    # making the gap as the basis of priority.
    epsilon = 1e-9 # To avoid division by zero
    priorities[suitable_bins_mask] = 1.0 / (suitable_bin_capacities - item + epsilon)


    # Another interpretation for "Random Fit priority" could be:
    # give a score to all suitable bins, but the actual selection might still be random among the top-scoring ones.
    # Or, a simple priority: just 1 for all suitable bins.
    # This would make them all equally prioritized, and the external selection mechanism would pick one randomly.
    # Let's try that for a more literal "Random Fit" interpretation where the priority doesn't enforce a specific sub-strategy.

    # Alternative approach: Assign a uniform positive priority to all suitable bins.
    # This allows the external selection mechanism (if it exists) to pick randomly.
    # If the selection mechanism is simply "pick highest priority", and multiple have the same
    # highest priority, it implies a form of random tie-breaking.

    # Let's provide a priority that encourages a slightly tighter fit, which is usually beneficial,
    # while acknowledging the spirit of "randomness" means not being overly rigid.
    # The inverse of the gap `(remaining_capacity - item)` works well for this.

    # Re-implementing using a clearer approach that directly reflects favoring tighter fits:
    priorities = np.zeros_like(bins_remain_cap, dtype=float)
    for i in range(len(bins_remain_cap)):
        if bins_remain_cap[i] >= item:
            # Prioritize bins that leave less remaining space after placing the item.
            # A smaller value of `bins_remain_cap[i] - item` is better.
            # We want a *higher* priority score for a *smaller* `bins_remain_cap[i] - item`.
            # So, use the negative of this difference.
            priorities[i] = - (bins_remain_cap[i] - item)
            # Adding a small constant if you want all priorities to be positive,
            # but the relative ordering is what matters.
            # priorities[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)


    return priorities
```
