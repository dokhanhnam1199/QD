```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using First Fit strategy.

    The First Fit strategy prioritizes bins that can accommodate the item and
    among those, it favors the bins that leave the least remaining capacity after
    placing the item. This encourages tighter packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a priority of 0.
        Among the bins that can fit, the priority is inversely proportional
        to the remaining capacity after fitting the item (higher priority for less remaining capacity).
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate remaining capacity for bins that can fit the item
    remaining_capacities_after_fit = bins_remain_cap[can_fit_mask] - item

    # For bins that can fit, assign priority. Higher priority for less remaining capacity.
    # We can use the inverse of remaining capacity, but to avoid division by zero
    # and to ensure higher values are better, we can use a large number minus the remaining capacity.
    # Or, more simply, sort by remaining capacity and assign decreasing priorities.
    # A simple heuristic is to use the negative of the remaining capacity, so smaller remaining capacity is a larger negative number,
    # but we want higher priority score to be selected. So, we can use a large constant minus the remaining capacity.
    # Or, to reflect the 'first fit' nature where the *first* suitable bin is preferred, we can simply give a higher score
    # to the *first* bin that fits, or iterate through and give decreasing scores for subsequent fits.

    # Let's implement a common First Fit priority: assign a high score to bins that fit,
    # and among those, prioritize the one with the smallest remaining capacity.
    # We can achieve this by sorting the fitting bins by their remaining capacity
    # and assigning priorities.

    fitting_bins_indices = np.where(can_fit_mask)[0]

    if fitting_bins_indices.size > 0:
        # Get the remaining capacities of the bins that can fit the item
        current_fitting_capacities = bins_remain_cap[fitting_bins_indices]

        # Calculate the resulting remaining capacity after placing the item
        resulting_remaining_capacities = current_fitting_capacities - item

        # Sort the fitting bins by their resulting remaining capacity in ascending order
        # This means bins that leave less space will come first.
        sorted_indices_within_fitting = np.argsort(resulting_remaining_capacities)

        # Assign priorities. The bin that leaves the least remaining capacity gets the highest priority.
        # We can assign priorities from n to 1, where n is the number of fitting bins.
        num_fitting_bins = len(fitting_bins_indices)
        for i in range(num_fitting_bins):
            original_index = fitting_bins_indices[sorted_indices_within_fitting[i]]
            priorities[original_index] = num_fitting_bins - i # Assign decreasing priority scores

    return priorities
```
