```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Random Fit strategy.

    In Random Fit, we prioritize bins that can fit the item. Among those that can fit,
    we introduce a random element to avoid deterministic behavior that might lead
    to suboptimal packing in the long run. Specifically, we assign a higher priority
    to bins that leave less remaining space after fitting the item, as this aligns
    with the First Fit Decreasing or Best Fit Decreasing heuristics in their spirit,
    but here applied online and with randomness.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate a priority score.
    # We want to prioritize bins that, after packing, will have less remaining capacity.
    # This encourages tighter packing.
    # We add a small random component to introduce variation and break ties.
    if np.any(can_fit_mask):
        remaining_capacities_if_fit = bins_remain_cap[can_fit_mask] - item
        # A lower remaining capacity is better (tighter fit). So we want to assign higher priority
        # to smaller remaining capacities. Inverting them works for higher priority.
        # A simple inversion might lead to very large numbers if remaining capacity is close to zero.
        # A common approach is to use 1/(remaining_capacity + epsilon) or a large constant - remaining_capacity.
        # Let's use a large constant minus the remaining capacity.
        # The range of remaining capacities is [0, max_bin_capacity - item].
        # Let's assume max_bin_capacity is some value, say 1.0 for normalized problems.
        # So remaining capacity is in [0, 1-item].
        # We want to map this to a high priority.
        # A good mapping could be (max_possible_remaining_capacity - actual_remaining_capacity)
        # where max_possible_remaining_capacity is roughly max(bins_remain_cap) - item, or a fixed upper bound.
        # For simplicity, let's use a fixed large number.
        max_priority_base = 1000.0
        priorities[can_fit_mask] = max_priority_base - remaining_capacities_if_fit

        # Add a small random jitter to break ties and introduce randomness
        # The jitter should be small enough not to override the deterministic preference
        # but large enough to create variation.
        random_jitter = np.random.rand(np.sum(can_fit_mask)) * 0.1 # Jitter between 0 and 0.1
        priorities[can_fit_mask] += random_jitter
    else:
        # If no bin can fit the item, all priorities remain 0. This implies a new bin is needed.
        pass

    return priorities
```
