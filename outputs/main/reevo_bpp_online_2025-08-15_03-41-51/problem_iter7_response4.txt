```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin, prioritizing tight fits
    with normalized features.

    This heuristic aims to balance immediate tightness (best fit) with future flexibility.
    It uses a sigmoid function to assign priorities, where the "ideal gap" influences
    the steepness of the priority curve around a preferred remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    # Hyperparameters for tuning
    # steepness controls how quickly the priority drops off as remaining capacity deviates from the ideal gap.
    # A higher steepness means a more sensitive response to capacity differences.
    steepness = 5.0
    # ideal_gap represents the preferred amount of remaining capacity after packing the item.
    # This is a target for a "good" fit, aiming to leave a reasonable amount of space.
    ideal_gap = 0.1 * np.max(bins_remain_cap) if len(bins_remain_cap) > 0 else 1.0

    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the remaining capacity after packing the item for bins that can fit
    potential_remaining_caps = bins_remain_cap[can_fit_mask]
    if len(potential_remaining_caps) == 0:
        return priorities  # No bin can fit the item

    # Calculate the "gap" for bins that can fit
    gaps = potential_remaining_caps - item

    # Calculate the difference from the ideal gap
    diff_from_ideal_gap = gaps - ideal_gap

    # Use a sigmoid-like function to assign priorities.
    # The sigmoid function will produce values between 0 and 1.
    # We want higher priority for gaps closer to the ideal_gap.
    # A simple way to achieve this is to use exp(-|diff_from_ideal_gap| * steepness).
    # This gives higher values when diff_from_ideal_gap is close to zero.
    # We add a small epsilon to the denominator of the sigmoid to prevent division by zero
    # in edge cases and to slightly temper extreme values.
    epsilon_stability = 1e-6
    sigmoid_input = -np.abs(diff_from_ideal_gap) * steepness
    # Using a shifted and scaled sigmoid for potentially better distribution if needed,
    # or a simpler exponential decay.
    # Simple exponential decay: higher priority for smaller absolute difference from ideal_gap
    scores = np.exp(sigmoid_input)

    # Apply the calculated scores to the corresponding bins in the priorities array
    priorities[can_fit_mask] = scores

    # Normalize priorities to be between 0 and 1 for consistent scale,
    # focusing on relative importance.
    max_priority = np.max(priorities)
    if max_priority > epsilon_stability:
        priorities = priorities / max_priority
    else:
        # If all eligible bins have near-zero priority (e.g., item is very large)
        # Assign uniform low priority to all eligible bins.
        priorities[can_fit_mask] = 0.1 # or some small default value

    # Ensure bins that cannot fit have zero priority
    priorities[~can_fit_mask] = 0.0

    # Add a small random jitter to break ties and provide some exploration
    # This helps in scenarios where multiple bins have very similar priority scores.
    # The jitter is scaled by the current priority to affect higher-priority bins more.
    jitter_strength = 0.05
    random_jitter = (np.random.rand(num_bins) - 0.5) * jitter_strength * priorities
    priorities += random_jitter

    # Re-normalize after adding jitter to maintain the 0-1 scale
    max_priority_after_jitter = np.max(priorities)
    if max_priority_after_jitter > epsilon_stability:
        priorities = priorities / max_priority_after_jitter
    else:
        priorities[can_fit_mask] = 0.1 # Re-apply if jitter made all zero


    return priorities
```
