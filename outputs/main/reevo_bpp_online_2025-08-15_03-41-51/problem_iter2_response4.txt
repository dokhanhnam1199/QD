```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a refined Best Fit strategy.

    This strategy prioritizes bins that have the smallest remaining capacity *after*
    packing the item, effectively minimizing wasted space. Bins where the item
    does not fit are given a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate a preferred bin.
    """
    # Initialize priorities to a very low value (negative infinity) for all bins.
    # This ensures that only bins where the item can fit will receive a positive or zero score.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins where the item can fit.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate the remaining capacity after placement.
    # The goal is to minimize this value.
    remaining_after_placement = bins_remain_cap[can_fit_mask] - item

    # To prioritize the smallest remaining capacity, we can assign a priority based on the
    # negative of this value. This makes smaller positive remaining capacities result in
    # higher (less negative) priority scores.
    # For example, if remaining capacity after placement is 0, priority is 0.
    # If remaining capacity after placement is 1, priority is -1.
    # If remaining capacity after placement is 5, priority is -5.
    # Thus, 0 > -1 > -5, correctly prioritizing the tightest fit.
    priorities[can_fit_mask] = -remaining_after_placement

    return priorities
```
