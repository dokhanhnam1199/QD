{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin.\n\n    This heuristic prioritizes bins based on a combination of:\n    1. Tightness of fit: Bins that leave minimal remaining space after packing.\n    2. Flexibility: A small bonus for bins with larger remaining capacities.\n    3. Stability: Using a sigmoid function to smoothly differentiate priorities.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Determine which bins can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate scores for bins that can fit the item\n    fittable_bins_remain_cap = bins_remain_cap[can_fit_mask]\n    fittable_indices = np.where(can_fit_mask)[0]\n\n    # Score 1: Tightness (prioritize smaller remaining capacity after fit)\n    # We want to minimize (remaining_capacity - item).\n    # A smaller difference is better. We can map this to a higher score.\n    # Using 1 / (difference + small_epsilon) for a steep increase as difference approaches 0.\n    # Or using a negative of the difference for direct correlation with closeness.\n    tightness_scores = fittable_bins_remain_cap - item\n    # Small epsilon to avoid division by zero if remaining capacity is exactly item size\n    epsilon_small = 1e-6\n    tightness_priority = 1.0 / (tightness_scores + epsilon_small)\n\n\n    # Score 2: Flexibility bonus (prioritize larger remaining capacity)\n    # This encourages keeping some large bins open for potentially larger future items.\n    # We can use a small boost proportional to the remaining capacity.\n    flexibility_bonus = 0.1 * fittable_bins_remain_cap / np.max(fittable_bins_remain_cap + epsilon_small)\n\n    # Combined score before sigmoid\n    # Higher tightness_priority is good, higher flexibility_bonus is good\n    combined_raw_score = tightness_priority + flexibility_bonus\n\n    # Use sigmoid to smooth and bound the scores between 0 and 1.\n    # Sigmoid(x) = 1 / (1 + exp(-x))\n    # We need to scale the input to sigmoid to control its steepness.\n    # Let's map a typical range of combined_raw_score to the sigmoid's sensitive region.\n    # A simple scaling can be done by dividing by an estimate of the typical score.\n    # Or, more directly, tune a parameter 'k' for sigmoid(k * x).\n    # For simplicity, we'll use a direct sigmoid, assuming raw scores are somewhat reasonable.\n    # A higher raw score maps to a higher sigmoid output.\n    k_sigmoid = 0.5 # Steepness parameter for sigmoid\n    sigmoid_scores = 1 / (1 + np.exp(-k_sigmoid * (combined_raw_score - np.median(combined_raw_score))))\n    \n    # Assign these sigmoid scores to the priorities array\n    priorities[fittable_indices] = sigmoid_scores\n\n    # Ensure that bins that cannot fit the item have a priority of 0\n    priorities[~can_fit_mask] = 0.0\n\n    # Normalize priorities to be between 0 and 1 (optional, but good for consistency)\n    if np.max(priorities) > 0:\n        priorities = priorities / np.max(priorities)\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a tunable Sigmoid Fit Score.\n\n    This version refines the Sigmoid Fit Score by introducing `steepness` to control the\n    sigmoid's slope and `ideal_gap_fraction` to specify the desired positive gap as a\n    fraction of the item size. This allows for fine-tuning the preference for bins\n    that are not perfectly filled, potentially leaving more room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority of -inf.\n    \"\"\"\n    # Initialize priorities to negative infinity for bins that cannot fit the item.\n    # This ensures they are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item\n    possible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(possible_bins_mask):\n        # If no bin can fit the item, return the initialized -inf priorities.\n        return priorities\n\n    # Calculate the \"gap\" for bins that can fit the item.\n    # Gap is the remaining capacity after placing the item.\n    gaps = bins_remain_cap[possible_bins_mask] - item\n\n    # --- Tunable Parameters ---\n    # `steepness`: Controls how quickly the priority score decreases as the gap increases.\n    # A higher value leads to a sharper drop-off, making the choice more sensitive to small gaps.\n    steepness = 25.0\n\n    # `ideal_gap_fraction`: Defines the target gap as a fraction of the item's size.\n    # A value of 0.0 means we ideally want a perfect fit (gap=0).\n    # A value of 0.1 means we ideally want a gap of 10% of the item size.\n    # This encourages leaving some buffer space.\n    ideal_gap_fraction = 0.08 # Aim for a gap of ~8% of the item size\n\n    # Calculate the ideal gap based on the item size.\n    # Ensure the ideal gap is non-negative. If item size is 0, ideal_gap is 0.\n    ideal_gap = max(0.0, ideal_gap_fraction * item)\n\n    # --- Sigmoid Argument Calculation ---\n    # We use the sigmoid function `1 / (1 + exp(-x))` which maps x to [0, 1].\n    # To prioritize bins with gaps close to `ideal_gap`, we can map `ideal_gap` to the center\n    # of the sigmoid's steep slope (input close to 0).\n    # The argument `x` for the sigmoid will be `steepness * (ideal_gap - gap)`.\n    #\n    # If `gap < ideal_gap`: The argument is positive, sigmoid output > 0.5. Higher scores for smaller gaps.\n    # If `gap = ideal_gap`: The argument is 0, sigmoid output = 0.5. This is the pivot point.\n    # If `gap > ideal_gap`: The argument is negative, sigmoid output < 0.5. Lower scores for larger gaps.\n    #\n    # By choosing `ideal_gap_fraction`, we are effectively tuning the bias of the sigmoid.\n    # The argument can be seen as: `steepness * ideal_gap - steepness * gap`.\n    # The `steepness * ideal_gap` term acts as an additive bias.\n    sigmoid_arg = steepness * (ideal_gap - gaps)\n\n    # Apply the sigmoid function to compute the priority scores for fitting bins.\n    # Higher values indicate a more desirable bin.\n    priorities[possible_bins_mask] = 1 / (1 + np.exp(-sigmoid_arg))\n\n    return priorities\n\n[Reflection]\nTune sigmoid's steepness and ideal gap for better bin packing priorities.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}