```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    Exact Fit First prioritizes bins that can perfectly fit the item.
    Among bins that can perfectly fit, it prefers those with less remaining capacity
    (to encourage tighter packing).
    Bins that cannot fit the item are given a low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can perfectly fit the item
    perfect_fit_mask = (bins_remain_cap == item)
    if np.any(perfect_fit_mask):
        # For perfect fits, the priority is the negative of remaining capacity (to pick the smallest capacity bin that fits perfectly)
        # We multiply by 1000 to give higher precedence to perfect fits over non-perfect fits
        priorities[perfect_fit_mask] = 1000 - bins_remain_cap[perfect_fit_mask]
    else:
        # If no perfect fit, consider bins that can fit the item
        can_fit_mask = (bins_remain_cap >= item)
        if np.any(can_fit_mask):
            # For bins that can fit, prioritize those with the least remaining capacity
            # This is a common heuristic in BPP variants to avoid leaving small, unusable gaps.
            # The priority is (1 / remaining_capacity) which is higher for smaller capacities.
            # Add a small epsilon to avoid division by zero if capacity is 0, though `can_fit_mask` should prevent this.
            priorities[can_fit_mask] = 1.0 / (bins_remain_cap[can_fit_mask] + 1e-9)
        # Bins that cannot fit the item will have a priority of 0 by default.

    return priorities
```
