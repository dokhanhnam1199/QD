```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This heuristic implements a "Best Fit" strategy for the online Bin Packing Problem.
    It prioritizes bins that can accommodate the item and will have the least
    remaining capacity after the item is packed. This aims to minimize wasted
    space in each packing decision.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array representing the remaining capacity of each bin.

    Returns:
        A numpy array of priority scores for each bin. Higher scores indicate
        higher priority. Bins that cannot fit the item are assigned a very low
        priority (negative infinity).
    """
    # Initialize priorities to a very low value for all bins.
    # This ensures that bins that cannot fit the item will never be chosen.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that have enough remaining capacity to fit the current item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, we want to select the one that results
    # in the smallest remaining capacity after packing. This is equivalent to
    # minimizing `bins_remain_cap - item`.
    # To translate minimization into maximization for a priority score, we can
    # use the negative of this difference: `-(bins_remain_cap - item)`.
    # A smaller positive slack (`bins_remain_cap - item`) will result in a
    # less negative (higher) priority score.
    # For example, if item = 0.3 and bin capacities are [0.35, 0.4, 0.5]:
    # Slack for fitting bins: [0.05, 0.1, 0.2]
    # Priorities for fitting bins: [-0.05, -0.1, -0.2]
    # The bin with remaining capacity 0.35 (slack 0.05) gets the highest priority.
    fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]
    priorities[can_fit_mask] = -(fitting_bins_remain_cap - item)

    return priorities
```
