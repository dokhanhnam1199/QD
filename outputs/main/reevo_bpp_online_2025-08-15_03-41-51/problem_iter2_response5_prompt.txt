{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Worst Fit strategy.\n\n    The Worst Fit strategy prioritizes bins that have the most remaining capacity,\n    as this leaves more space for potentially larger future items. If an item\n    does not fit in a bin, its priority is set to negative infinity to exclude it.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize priorities with a very low value to represent infeasible bins\n    priorities = np.full_like(bins_remain_cap, -np.inf)\n\n    # Identify bins where the item can fit\n    fit_mask = bins_remain_cap >= item\n\n    # For bins where the item fits, the priority is the remaining capacity (Worst Fit)\n    priorities[fit_mask] = bins_remain_cap[fit_mask]\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Random Fit strategy.\n\n    In Random Fit, any bin that can accommodate the item is a candidate.\n    To implement a priority function, we assign a higher priority to bins that are\n    a \"tighter fit\" for the item, meaning they have just enough capacity for the item.\n    This encourages filling bins more completely. For bins that are not suitable,\n    the priority is zero.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    suitable_bins_mask = bins_remain_cap >= item\n\n    # For suitable bins, calculate priority as the inverse of the remaining capacity\n    # after placing the item. A smaller remaining capacity (tighter fit) gets a higher priority.\n    # We add a small epsilon to avoid division by zero if an item perfectly fills a bin.\n    suitable_bin_capacities = bins_remain_cap[suitable_bins_mask]\n    # A smaller remaining capacity after fitting means a better fit.\n    # To prioritize better fits, we can use the negative of the remaining capacity.\n    # Or, to make it a positive score, we can use 1 / (remaining_capacity + epsilon)\n    # or something like (max_capacity - item_size) / (current_remaining_capacity - item_size).\n    # Let's go with a simple approach: higher priority for bins with less excess capacity.\n    # This can be achieved by giving a score based on how close the remaining capacity\n    # is to the item size.\n\n    # Option 1: Prioritize bins that have the least excess capacity (closest fit)\n    # If a bin has remaining_capacity, and we add 'item', the new remaining_capacity is remaining_capacity - item.\n    # A tighter fit means remaining_capacity - item is small.\n    # So, higher priority for smaller (remaining_capacity - item).\n    # We can assign priority as - (remaining_capacity - item).\n    priorities[suitable_bins_mask] = - (suitable_bin_capacities - item)\n\n    # Option 2: Random Fit doesn't explicitly define a \"best\" bin,\n    # it picks *any* suitable bin randomly.\n    # If we need a priority function that leads to random selection among suitable bins:\n    # 1. Assign a uniform positive score to all suitable bins.\n    # 2. The selection process (outside this function) would then randomly pick\n    #    from the bins with the highest priority.\n    # This function, however, must *return* priorities, implying a deterministic choice.\n    # The \"Random Fit\" often refers to the *algorithm's decision rule* rather than\n    # a strict priority score for a heuristic.\n    # For this specific task of returning priorities, and given the prompt's wording\n    # \"The bin with the highest priority score will be selected for the item,\"\n    # we need to provide scores that guide selection.\n\n    # Let's refine Option 1 to be more aligned with a heuristic's goal of good packing.\n    # The spirit of \"Random Fit\" is often about not overthinking the choice if many are available.\n    # However, if we MUST assign priorities, a reasonable heuristic priority would be\n    # to favor bins that are *just big enough*, minimizing wasted space in that specific bin.\n    # This is captured by `bins_remain_cap - item` being small.\n    # So, negative of that value is a good proxy for priority.\n\n    # Ensure priorities are not positive if we are trying to find \"least\" of something,\n    # but here higher priority score means better.\n    # A smaller `bins_remain_cap - item` implies a better fit.\n    # Let's use `1.0 / (bins_remain_cap - item + epsilon)` to favor smaller gaps,\n    # making the gap as the basis of priority.\n    epsilon = 1e-9 # To avoid division by zero\n    priorities[suitable_bins_mask] = 1.0 / (suitable_bin_capacities - item + epsilon)\n\n\n    # Another interpretation for \"Random Fit priority\" could be:\n    # give a score to all suitable bins, but the actual selection might still be random among the top-scoring ones.\n    # Or, a simple priority: just 1 for all suitable bins.\n    # This would make them all equally prioritized, and the external selection mechanism would pick one randomly.\n    # Let's try that for a more literal \"Random Fit\" interpretation where the priority doesn't enforce a specific sub-strategy.\n\n    # Alternative approach: Assign a uniform positive priority to all suitable bins.\n    # This allows the external selection mechanism (if it exists) to pick randomly.\n    # If the selection mechanism is simply \"pick highest priority\", and multiple have the same\n    # highest priority, it implies a form of random tie-breaking.\n\n    # Let's provide a priority that encourages a slightly tighter fit, which is usually beneficial,\n    # while acknowledging the spirit of \"randomness\" means not being overly rigid.\n    # The inverse of the gap `(remaining_capacity - item)` works well for this.\n\n    # Re-implementing using a clearer approach that directly reflects favoring tighter fits:\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n    for i in range(len(bins_remain_cap)):\n        if bins_remain_cap[i] >= item:\n            # Prioritize bins that leave less remaining space after placing the item.\n            # A smaller value of `bins_remain_cap[i] - item` is better.\n            # We want a *higher* priority score for a *smaller* `bins_remain_cap[i] - item`.\n            # So, use the negative of this difference.\n            priorities[i] = - (bins_remain_cap[i] - item)\n            # Adding a small constant if you want all priorities to be positive,\n            # but the relative ordering is what matters.\n            # priorities[i] = 1.0 / (bins_remain_cap[i] - item + epsilon)\n\n\n    return priorities\n\n[Reflection]\nPrioritize tighter fits for better bin packing efficiency.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}