{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority with which we want to add item to each bin,\n    prioritizing tight fits and adding small bonuses for larger capacities.\n\n    The strategy aims to:\n    1. Prioritize bins that offer a \"tight fit\" (minimal remaining capacity after packing).\n    2. Give a small bonus to bins with larger remaining capacities, encouraging their\n       use for potentially larger future items.\n    3. Stabilize scoring and handle un-fittable bins explicitly.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Determine which bins can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Filter to only consider bins that can fit the item\n    fitting_bins_cap = bins_remain_cap[can_fit_mask]\n    fitting_indices = np.where(can_fit_mask)[0]\n\n    # --- Scoring components ---\n\n    # 1. Tight Fit Score: Prioritize bins with minimal remaining capacity after packing.\n    #    We want to minimize (remaining_capacity - item).\n    #    To turn this into a priority (higher is better), we can invert and scale.\n    #    A small value for (remaining_capacity - item) should result in a high score.\n    #    Using (max_possible_difference - diff) or similar.\n    #    Let's define a \"waste\" score: waste = remaining_capacity - item. Lower waste is better.\n    waste = fitting_bins_cap - item\n\n    # Normalize waste to [0, 1] range for consistent scoring.\n    # If all waste is 0, max_waste will be 0, avoid division by zero.\n    max_waste = np.max(waste) if len(waste) > 0 else 0\n    if max_waste > 0:\n        normalized_waste = waste / max_waste\n    else:\n        normalized_waste = np.zeros_like(waste) # All bins perfectly fit or no bins fit\n\n    # Tight fit priority: Higher when normalized_waste is lower (closer to 0).\n    # We can use a function like 1 - normalized_waste or apply a sigmoid-like shape.\n    # Let's try a simple inverted linear score: 1 - normalized_waste.\n    tight_fit_scores = 1.0 - normalized_waste\n\n    # 2. Capacity Bonus Score: Give a small bonus to bins with larger remaining capacities.\n    #    This encourages using bins that might be able to fit larger items later.\n    #    Normalize remaining capacity to [0, 1].\n    max_cap = np.max(bins_remain_cap) if num_bins > 0 else 1 # Avoid division by zero if no bins\n    if max_cap > 0:\n        normalized_caps = bins_remain_cap / max_cap\n    else:\n        normalized_caps = np.zeros_like(bins_remain_cap)\n\n    # Capacity bonus: Add a fraction of the normalized capacity.\n    capacity_bonus_weight = 0.1 # Tunable parameter\n    capacity_bonus_scores = capacity_bonus_weight * normalized_caps[can_fit_mask]\n\n    # --- Combine scores ---\n    # Total score for fitting bins is a weighted sum of tight fit and capacity bonus.\n    # We can use a sigmoid-like transformation to map scores to a [0, 1] range,\n    # ensuring that tight fits dominate but capacity bonus provides a nudge.\n    # Let's combine them linearly first and then apply a scaling/transformation.\n\n    combined_raw_scores = tight_fit_scores + capacity_bonus_scores\n\n    # Apply a sigmoid-like function to map scores to [0, 1] and create a smoother distribution.\n    # A simple approach is to scale and shift, or use np.tanh.\n    # Let's map the combined_raw_scores to a range and then use a function that\n    # emphasizes higher values. For simplicity, let's use a soft ranking.\n    # A softmax-like approach can also work to create relative priorities.\n\n    # Let's use a simple scaling and add noise for exploration.\n    # We want tight fits to be generally higher.\n    # A simple approach: score = tight_fit_score + bonus_for_large_capacity\n    # Let's rescale the tight_fit_scores to be in a higher range, e.g., [0.5, 1]\n    # and bonuses in [0, 0.1].\n\n    # Re-scaling tight fit scores to [0.5, 1.0]\n    scaled_tight_fit = 0.5 + 0.5 * tight_fit_scores\n    # Adding capacity bonus (scaled down)\n    final_fitting_scores = scaled_tight_fit + capacity_bonus_scores * 0.5 # Lower weight for bonus\n\n    # Add a small random component for exploration/stochasticity\n    exploration_noise = np.random.uniform(0, 0.05, size=len(final_fitting_scores))\n    final_fitting_scores += exploration_noise\n\n    # Assign these scores to the appropriate bins\n    priorities[fitting_indices] = final_fitting_scores\n\n    # Ensure non-fitting bins have 0 priority\n    priorities[~can_fit_mask] = 0.0\n\n    # Normalize priorities to [0, 1] for consistency if needed for specific algorithms,\n    # but for selection, relative values are what matter.\n    # If all fitting scores are 0 (which shouldn't happen if can_fit_mask is true and item fits),\n    # avoid division by zero.\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n    else:\n        # This case should ideally not be reached if can_fit_mask has true values.\n        pass\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using a\n    heuristic that prioritizes tight fits with some flexibility.\n\n    This heuristic aims to:\n    1. Prioritize bins with a tight fit (smallest remaining capacity that still fits the item).\n    2. Provide a slight advantage to bins with larger remaining capacity to maintain flexibility.\n    3. Explicitly handle bins that cannot fit the item.\n    4. Use a sigmoid-like function to create a smooth priority curve based on fit quality.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Identify bins that can fit the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bins can fit, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # For bins that can fit, calculate a priority score.\n    # We want to prioritize bins where remaining_capacity - item is small (tight fit).\n    # We also want to give a small bonus to bins with larger remaining capacity.\n    # A sigmoid-like function can map the 'fit quality' to a priority.\n    # Let's define fit_score as remaining_capacity - item. Lower is better.\n    # We want to invert this relationship for priority.\n\n    # Calculate the \"fit quality\" for bins that can accommodate the item\n    # This is the leftover space after placing the item. Smaller is better.\n    leftover_space = bins_remain_cap[can_fit_mask] - item\n\n    # To prioritize tight fits, we want to give higher scores to smaller leftover_space.\n    # We can use a transformation like 1 / (1 + leftover_space) or exp(-k * leftover_space).\n    # Let's try a simple approach first: prioritize smaller leftover space directly.\n    # To balance with flexibility, we can add a small bonus for larger original capacities.\n\n    # Normalize leftover_space to a [0, 1] range for a smoother function.\n    # Avoid division by zero if all leftover_spaces are 0.\n    min_leftover = np.min(leftover_space)\n    max_leftover = np.max(leftover_space)\n\n    if max_leftover == min_leftover:\n        normalized_leftover = np.zeros_like(leftover_space)\n    else:\n        normalized_leftover = (leftover_space - min_leftover) / (max_leftover - min_leftover)\n\n    # Priority based on tightness: higher for smaller normalized_leftover.\n    # Use a sigmoid-like function: exp(-k * normalized_leftover)\n    # A higher 'k' will emphasize tighter fits more. Let's set k=5.\n    tightness_priority = np.exp(-5 * normalized_leftover)\n\n    # Add a small bonus for larger remaining capacity to promote flexibility.\n    # Normalize original remaining capacity for bins that can fit.\n    original_capacities_fitting = bins_remain_cap[can_fit_mask]\n    min_cap_fit = np.min(original_capacities_fitting)\n    max_cap_fit = np.max(original_capacities_fitting)\n\n    if max_cap_fit == min_cap_fit:\n        normalized_capacity = np.zeros_like(original_capacities_fitting)\n    else:\n        normalized_capacity = (original_capacities_fitting - min_cap_fit) / (max_cap_fit - min_cap_fit)\n\n    # Flexibility bonus: directly proportional to normalized capacity.\n    # Scale this bonus to be smaller than the tightness priority.\n    flexibility_bonus = 0.2 * normalized_capacity\n\n    # Combine priorities: prioritize tightness but give a small boost for flexibility.\n    combined_priority_values = tightness_priority + flexibility_bonus\n\n    # Assign these priorities to the corresponding bins\n    priorities[can_fit_mask] = combined_priority_values\n\n    # Ensure priorities are non-negative and handle potential NaNs if any calculations failed\n    priorities = np.nan_to_num(priorities, nan=0.0, posinf=0.0, neginf=0.0)\n\n    # Normalize priorities to be between 0 and 1 for consistent comparison.\n    # This step is important for the interpretation of \"higher score = higher priority\".\n    max_priority = np.max(priorities)\n    if max_priority > 0:\n        priorities = priorities / max_priority\n    else:\n        # If all priorities are zero (e.g., no bin fits, or all fit-perfectly with no capacity left),\n        # this ensures we return zeros, not NaNs.\n        priorities = np.zeros_like(priorities)\n\n    return priorities\n\n[Reflection]\nPrioritize tight fits, use smooth functions, and balance with flexibility.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}