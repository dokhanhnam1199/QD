```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin,
    prioritizing tight fits and encouraging the use of fuller bins.

    This heuristic aims to:
    1. Strongly prioritize bins where the remaining capacity is close to the item size (tight fit).
    2. Provide a secondary preference for bins that are already relatively full,
       as this suggests they are being utilized effectively and might be candidates
       for being closed sooner.
    3. Explicitly handle bins that cannot fit the item by assigning them zero priority.
    4. Use a non-linear transformation (e.g., exponential decay) for tightness to
       create a smoother priority gradient.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Get capacities of bins that can fit the item
    fitting_bins_cap = bins_remain_cap[can_fit_mask]

    # --- Scoring Component 1: Tight Fit ---
    # Calculate the "waste" or leftover space after fitting the item.
    # Smaller waste means a tighter fit.
    waste = fitting_bins_cap - item

    # To prioritize smaller waste, we can use an inverse relationship.
    # A common way is to use an exponential decay: exp(-k * waste).
    # A smaller `waste` results in a value closer to 1.
    # A parameter `k` can control the steepness of this preference.
    # Let's use k=2 for moderate emphasis on tightness.
    tightness_score = np.exp(-2 * waste)

    # --- Scoring Component 2: Bin Fullness (Secondary Preference) ---
    # We want to prioritize bins that are already fuller (less remaining capacity).
    # This encourages packing items into partially filled bins rather than
    # spreading them out too thinly.
    # Normalize the remaining capacity to get a sense of how full each bin is.
    # For bins that can fit the item, the original capacity matters.
    # Normalize original remaining capacities of fitting bins.
    min_orig_cap = np.min(fitting_bins_cap)
    max_orig_cap = np.max(fitting_bins_cap)

    if max_orig_cap == min_orig_cap:
        # If all fitting bins have the same capacity, this component is uniform.
        # Assign a base score or 0, as it doesn't differentiate.
        fullness_score = np.zeros_like(fitting_bins_cap)
    else:
        # Higher remaining capacity means less full. We want the opposite.
        # So, we use (max_orig_cap - fitting_bins_cap) and normalize it.
        # Or, simpler, normalize (min_orig_cap to max_orig_cap) and then invert.
        # Let's normalize the original capacities:
        normalized_original_cap = (fitting_bins_cap - min_orig_cap) / (max_orig_cap - min_orig_cap)
        # We want to prioritize *smaller* original capacities, so we invert this.
        fullness_score = 1.0 - normalized_original_cap

    # --- Combine Scores ---
    # Combine tightness and fullness. Tightness should be the primary driver.
    # We can add the fullness score as a bonus, scaled down.
    # A small bonus weight (e.g., 0.2) ensures tightness remains dominant.
    combined_scores = tightness_score + 0.2 * fullness_score

    # Assign the computed scores to the correct bins
    priorities[can_fit_mask] = combined_scores

    # Ensure no NaNs or infinities result from calculations
    priorities = np.nan_to_num(priorities, nan=0.0, posinf=0.0, neginf=0.0)

    # Normalize priorities to a [0, 1] range for consistent comparison across different item/bin states.
    # This step helps if the priority values are used in contexts that expect a bounded range.
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = priorities / max_priority
    else:
        # If all calculated priorities are zero (e.g., item size is larger than bin capacity),
        # ensure we return an array of zeros.
        priorities = np.zeros_like(priorities)

    return priorities
```
