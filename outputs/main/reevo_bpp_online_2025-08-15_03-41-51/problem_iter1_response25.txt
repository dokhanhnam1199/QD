```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance strategy.

    The Inverse Distance (Proximity Fit) strategy prioritizes bins that have
    just enough remaining capacity to fit the item, encouraging tighter packing.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Only consider bins that can actually fit the item
    valid_bins_mask = bins_remain_cap >= item
    
    # If no bin can fit the item, return zeros (no priority)
    if not np.any(valid_bins_mask):
        return np.zeros_like(bins_remain_cap)
        
    # Calculate the "distance" to fit. A smaller distance means a tighter fit.
    # We are using remaining capacity - item_size as the "waste" or "gap" after packing.
    # A smaller gap is better.
    gaps = bins_remain_cap[valid_bins_mask] - item
    
    # We want to prioritize bins with the smallest gap (closest fit).
    # The inverse distance is typically 1 / distance.
    # However, to avoid division by zero if the gap is exactly zero (perfect fit),
    # we can add a small epsilon or directly use the inverse of a positive value.
    # A common approach for "proximity" is to use the inverse of the difference,
    # but we want the *smallest* difference to have the *highest* priority.
    # So, we can use 1 / (gap + epsilon) or simply sort the gaps and assign priorities
    # based on rank.
    
    # For simplicity and direct interpretation as "priority score":
    # We'll assign a higher score to bins with smaller gaps.
    # Let's invert the gap: higher score for smaller gaps.
    # We can use 1.0 / (gap + a small epsilon) to avoid division by zero and
    # ensure that smaller gaps get higher scores. A small epsilon also
    # ensures that bins with exactly zero gap get a very high priority.
    epsilon = 1e-9
    priorities_for_valid_bins = 1.0 / (gaps + epsilon)
    
    # Now, create the full priorities array and populate it
    priorities = np.zeros_like(bins_remain_cap)
    priorities[valid_bins_mask] = priorities_for_valid_bins
    
    return priorities
```
