```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a First Fit Decreasing-like strategy.

    The strategy prioritizes bins that have just enough remaining capacity to fit the item,
    aiming to leave larger remaining capacities in other bins for potentially larger future items.
    If multiple bins have just enough capacity, the one that fits the item most snugly is preferred.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap)

    # Find bins that can fit the item
    fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, calculate a priority score.
    # We want to prioritize bins that have *just enough* capacity.
    # The difference (bins_remain_cap - item) represents the 'slack' or remaining capacity
    # after fitting the item. A smaller slack is better, as it means a tighter fit.
    # We use 1.0 / (difference + epsilon) to give higher priority to smaller differences.
    # Adding a small epsilon (e.g., 1e-9) prevents division by zero if a bin has exactly
    # the remaining capacity as the item size.
    # A large negative number is assigned to bins that cannot fit the item.

    epsilon = 1e-9
    priorities[fit_mask] = 1.0 / (bins_remain_cap[fit_mask] - item + epsilon)

    # Assign a very low priority to bins that cannot fit the item
    priorities[~fit_mask] = -np.inf

    return priorities
```
