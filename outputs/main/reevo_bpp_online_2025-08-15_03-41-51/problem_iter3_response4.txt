```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority scores for each bin to pack an item, prioritizing tighter fits
    with a slight bonus for larger remaining capacities for future flexibility.

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining capacity
                         of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, containing priority
        scores for each bin. Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, all priorities remain 0.
    if not np.any(can_fit_mask):
        return priorities

    # Filter to consider only bins that can fit the item
    fitting_bins_caps = bins_remain_cap[can_fit_mask]
    fitting_bin_indices = np.where(can_fit_mask)[0]

    # --- Heuristic Calculation ---
    # Prioritize bins with minimal remaining capacity (tightest fits)
    # Use a sigmoid-like function to give higher priority to tighter fits,
    # but with a gradual decrease rather than a sharp cutoff.
    # We use 1 / (1 + exp(-(x - center) / scale)))
    # Here, 'x' is related to how much capacity is left *after* placing the item.
    # Smaller remaining capacity after placement (i.e., tighter fit) should have higher priority.
    # So, we want to map small (fitting_bins_caps - item) values to high priority.

    # Calculate remaining capacity after placing the item
    remaining_after_placement = fitting_bins_caps - item

    # Define parameters for the sigmoid-like function for tightness
    # 'center' can be set around the median of the 'remaining_after_placement' values
    # or a small value to emphasize very tight fits.
    # 'scale' controls the steepness of the transition.
    tightness_scores = np.zeros_like(fitting_bins_caps)
    if len(remaining_after_placement) > 0:
        # A simple approach: map 0 remaining capacity to highest priority.
        # A slightly more sophisticated approach could use a sigmoid.
        # Let's use a simple inverse relationship with a small offset to avoid division by zero.
        # And add a small bonus for larger capacities to balance.

        # Calculate a 'tightness' score: higher is tighter fit (closer to 0)
        # Normalize remaining_after_placement to be between 0 and 1 (relative to max possible remaining)
        # or use a fixed scale. A simpler approach:
        # Higher priority for smaller remaining_after_placement.
        # Adding a small constant to avoid division by zero or extremely high values for 0 remaining.
        tightness_factor = 1.0 / (remaining_after_placement + 0.1)

        # Bonus for larger remaining capacities (exploration/flexibility):
        # This gives a slight boost to bins that still have significant space left,
        # even if they aren't the tightest fit. This can help avoid packing
        # items in a way that leaves very little space in many bins.
        # Normalize fitting_bins_caps to get a relative sense of large capacity.
        # We can add a scaled version of the remaining capacity itself.
        # Ensure we don't add too much to the tightest fits.
        flexibility_bonus_scale = 0.1 # Controls how much this bonus influences the priority
        flexibility_factor = fitting_bins_caps / np.max(fitting_bins_caps) * flexibility_bonus_scale if np.max(fitting_bins_caps) > 0 else 0

        # Combine tightness and flexibility.
        # Tightness is the primary driver.
        combined_priority_values = tightness_factor + flexibility_factor
        priorities[fitting_bin_indices] = combined_priority_values

        # Normalize priorities so the max is 1.0 for easier interpretation and selection.
        if np.max(priorities) > 0:
            priorities = priorities / np.max(priorities)

    return priorities
```
