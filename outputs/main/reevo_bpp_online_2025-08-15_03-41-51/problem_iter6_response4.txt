```python
import numpy as np
from scipy.special import expit

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin,
    prioritizing tightest fits with a bonus for flexibility, using normalized values
    and sigmoid for smooth prioritization.

    This version refines the normalization and combination of scores.

    The priority is a composite score based on:
    1. Tightness: Prioritizes bins with minimal non-negative remaining capacity
       that can fit the item. Modeled by a sigmoid function of the negative gap.
    2. Flexibility: Prioritizes bins with larger remaining capacity.
       Modeled by a sigmoid function of the normalized remaining capacity.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros(num_bins, dtype=float)

    # Parameters for tuning:
    # k_tight: Controls the steepness of the tightness score's sigmoid. Higher k_tight
    #          means smaller gaps are much more favored.
    # k_flex: Controls the steepness of the flexibility score's sigmoid. Higher k_flex means
    #         larger capacities reach saturation faster.
    # w_tight: Weight for the tightness component.
    # w_flex: Weight for the flexibility component.
    # norm_clip_val: Value to clip normalized capacities at to prevent extreme flexibility scores,
    #                especially when capacities are very close.
    k_tight = 7.0
    k_flex = 3.0
    w_tight = 0.7
    w_flex = 0.3
    norm_clip_val = 1.0

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Process only bins that can fit the item
    eligible_bins_indices = np.where(can_fit_mask)[0]

    if len(eligible_bins_indices) > 0:
        eligible_rem_cap = bins_remain_cap[eligible_bins_indices]
        gaps = eligible_rem_cap - item  # These are guaranteed non-negative

        # --- Calculate Normalized Tightness Score ---
        # Normalize gaps to be between 0 and 1.
        # A smaller gap should result in a higher score.
        # We want to map `gaps` to an input for sigmoid such that small positive gaps are mapped to high values.
        # Using `expit(k * (1 - normalized_gap))`.
        max_gap = np.max(gaps) if len(gaps) > 0 else 0
        min_gap = np.min(gaps) if len(gaps) > 0 else 0

        if max_gap > min_gap:
            # Normalize gaps to [0, 1] where 0 is the tightest fit.
            normalized_gaps = (gaps - min_gap) / (max_gap - min_gap)
        else:
            # All gaps are the same, so normalized gap is 0 for all.
            normalized_gaps = np.zeros_like(gaps)

        # Apply sigmoid. We want higher score for smaller normalized_gaps (closer to 0).
        # Input to sigmoid should be high for low normalized_gaps.
        # `k_tight * (1.0 - normalized_gaps)`: when normalized_gaps=0 (tightest), input=k_tight (high).
        #                                    when normalized_gaps=1 (loosest), input=0 (mid).
        tightness_score = expit(k_tight * (1.0 - normalized_gaps))

        # --- Calculate Normalized Flexibility Score ---
        # Normalize remaining capacities to be between 0 and 1.
        # Larger remaining capacity should result in a higher score.
        # Using `expit(k * normalized_cap)`.
        max_cap = np.max(bins_remain_cap) if num_bins > 0 else 0
        min_cap = np.min(bins_remain_cap) if num_bins > 0 else 0

        if max_cap > min_cap:
            # Normalize capacities to [0, 1] where 0 is the smallest capacity overall,
            # and 1 is the largest capacity overall.
            normalized_caps = (eligible_rem_cap - min_cap) / (max_cap - min_cap)
            # Clip to prevent extreme sigmoid values if max_cap is very close to min_cap,
            # or if there's only one bin.
            normalized_caps = np.clip(normalized_caps, 0.0, norm_clip_val)
        else:
            # If all bins have the same capacity (or only one bin exists),
            # assign a neutral normalized capacity (0.5) for flexibility.
            normalized_caps = np.full_like(eligible_rem_cap, 0.5)

        # Apply sigmoid. Higher normalized_caps (closer to 1) should yield higher score.
        flexibility_score = expit(k_flex * normalized_caps)

        # --- Combine Scores ---
        # Weighted sum of normalized tightness and flexibility scores.
        # Both scores are already in [0, 1].
        composite_priorities = w_tight * tightness_score + w_flex * flexibility_score

        # Assign the calculated composite priorities back to the main priorities array
        priorities[eligible_bins_indices] = composite_priorities

        # --- Final Normalization ---
        # Normalize all priorities to ensure the maximum priority is 1.0.
        # This helps in making the choice of the best bin unambiguous.
        max_priority_value = np.max(priorities)
        if max_priority_value > 0:
            priorities = priorities / max_priority_value
        # If max_priority_value is 0 (e.g., no eligible bins or all calculations resulted in 0),
        # the priorities array remains all zeros.

    return priorities
```
