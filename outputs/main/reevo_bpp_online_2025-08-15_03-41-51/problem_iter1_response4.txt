```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Exact Fit First.

    Exact Fit First prioritizes bins that can exactly fit the item, and among those,
    it prioritizes the one with the least remaining capacity (to leave larger gaps
    for potentially larger items later).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Create a boolean mask for bins that can exactly fit the item
    can_fit_exactly_mask = (bins_remain_cap == item)

    # If there are bins that can exactly fit the item, prioritize them.
    # Among exact fits, prefer those with less remaining capacity (this is implicitly
    # handled by sorting if we were to use it, but here we assign a higher value).
    # For simplicity and to ensure higher priority, we can assign a fixed high value
    # or a value based on some secondary criterion if needed.
    # Here, we assign a priority based on the negative of the remaining capacity
    # for exact fits to break ties towards smaller remaining capacity.
    if np.any(can_fit_exactly_mask):
        # Assign a base high priority for exact fits
        exact_fit_priority = 1000.0
        # Adjust priority based on remaining capacity to break ties (smaller capacity is better)
        priorities[can_fit_exactly_mask] = exact_fit_priority - bins_remain_cap[can_fit_exactly_mask]
    else:
        # If no exact fit, consider bins that can fit the item (i.e., remaining capacity >= item).
        # The Exact Fit First strategy, in its purest form, only considers exact fits.
        # However, in a practical implementation where an exact fit might not exist,
        # one could extend it. The prompt implies returning scores for *all* bins.
        # If we strictly adhere to "Exact Fit First", non-exact fits get zero priority.
        # But to return scores for all bins, we'll assign a lower priority to bins
        # that *can* fit, and a zero priority to bins that *cannot* fit.
        # For bins that can fit but are not an exact fit, we might assign a negative score
        # or a score lower than any exact fit.

        can_fit_mask = (bins_remain_cap >= item)
        # Assign a lower priority to bins that can fit but are not an exact fit.
        # We can make this priority lower than the exact fit priority.
        # A negative score or a score less than any possible exact fit score works.
        # Let's assign a priority based on how "close" they are to an exact fit,
        # or simply a low constant if no exact fit is found.
        # A simple approach is to assign a constant lower priority.
        # Here, we'll assign 0.0 to bins that can fit but aren't exact fits.
        # The rationale for 0.0 is that they are considered after all exact fits.
        priorities[can_fit_mask] = 0.0 # Or some other low value if needed

    # Bins that cannot fit the item will retain their initial priority of 0.0

    return priorities
```
