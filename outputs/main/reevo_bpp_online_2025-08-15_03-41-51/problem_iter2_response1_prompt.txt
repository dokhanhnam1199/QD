{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin using Almost Full Fit.\n\n    Almost Full Fit prioritizes bins that are close to being full but can still\n    accommodate the item. It favors bins with remaining capacity slightly larger\n    than the item size.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap)\n\n    # Calculate the \"fit\" for each bin. A smaller value means a tighter fit.\n    # We only consider bins that can actually fit the item.\n    can_fit_mask = bins_remain_cap >= item\n    \n    # If no bin can fit the item, return all zeros (or handle as an error/new bin creation)\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # For bins that can fit the item, calculate a priority score.\n    # The strategy is to give a high priority to bins where the remaining capacity\n    # is just enough or slightly more than the item.\n    # We want to maximize `bins_remain_cap - item`, but penalize cases where\n    # the remaining capacity is much larger than the item.\n    \n    # A simple way to achieve \"almost full fit\" is to prioritize bins\n    # where (bins_remain_cap - item) is minimized.\n    # However, we need to differentiate between bins that are almost full\n    # and bins that are very full (and thus not a good fit).\n\n    # Let's try to prioritize bins where `bins_remain_cap - item` is small.\n    # The ideal scenario is when `bins_remain_cap - item` is 0 (perfect fit).\n    # We can use a function that peaks at 0 and decreases as the difference\n    # increases. A negative quadratic might work, but we need to be careful\n    # about the range.\n\n    # Consider the \"slack\" or \"wasted space\" if the item is placed in the bin: `slack = bins_remain_cap - item`\n    # We want to minimize this slack.\n\n    # A common approach in \"best fit\" style heuristics is to give higher priority\n    # to bins with the smallest remaining capacity that can still fit the item.\n    # So, the priority could be inversely related to `bins_remain_cap` among those that fit.\n    # However, \"Almost Full Fit\" suggests we want bins that are *already* relatively full.\n\n    # Let's consider the bins that *can* fit the item.\n    # For these bins, we want to find the one that will be \"almost full\" *after*\n    # the item is placed. This means the remaining capacity *after* placement\n    # should be small, but non-negative.\n\n    # Let's define priority as a value that increases as the remaining capacity\n    # after placing the item (`bins_remain_cap - item`) decreases,\n    # but only for bins that can accommodate the item.\n\n    # To make it \"Almost Full Fit\", we might want to slightly penalize bins\n    # that are *too* empty, and strongly prefer bins that are just right.\n\n    # Let's try: priority = 1 / (1 + (bins_remain_cap - item))\n    # This gives higher priority to smaller (bins_remain_cap - item) values.\n    # It's capped at 1 when bins_remain_cap == item.\n    # It approaches 0 as (bins_remain_cap - item) gets large.\n\n    # We only apply this to bins that can fit the item.\n    \n    # Calculate potential remaining capacity for fitting bins\n    potential_remaining_caps = bins_remain_cap[can_fit_mask] - item\n\n    # Calculate priorities for fitting bins: Higher priority for smaller remaining capacity\n    # Using `1 / (1 + slack)` encourages smaller positive slacks.\n    # If slack is 0 (perfect fit), priority is 1.\n    # If slack is positive, priority is between 0 and 1.\n    # Adding a small epsilon to the denominator to avoid division by zero if `item` exactly fills a bin and `bins_remain_cap` is 0 (though unlikely with positive item sizes).\n    priorities[can_fit_mask] = 1.0 / (1.0 + potential_remaining_caps + 1e-9)\n\n    # To further emphasize \"almost full\", we can also consider how full the bin\n    # is *before* placing the item. A bin that is already very full (low `bins_remain_cap`)\n    # might be preferred.\n    \n    # Let's modify the priority to give a boost to bins that are already more full.\n    # We can multiply the previous priority by a factor that increases with `bins_remain_cap`.\n    # However, this could conflict if a very full bin cannot fit the item.\n\n    # A better approach for \"Almost Full Fit\" might be to prioritize bins\n    # whose remaining capacity is closest to `item`, but still greater than or equal to it.\n    # So, we want to minimize `bins_remain_cap - item`.\n\n    # Let's re-evaluate the scoring:\n    # We are selecting from bins where `bins_remain_cap >= item`.\n    # Among these, we want the one that, after adding the item, leaves the least amount of space.\n    # This means we want to minimize `bins_remain_cap - item`.\n\n    # If we want to assign a *higher* priority to bins that result in *less* remaining space,\n    # we can invert the value of `bins_remain_cap - item`.\n    # A common way to do this is `1 / (bins_remain_cap - item + epsilon)`.\n    # However, this can lead to very large values if `bins_remain_cap - item` is close to 0.\n\n    # Let's use a Gaussian-like function centered at `item` for the bin capacities.\n    # Or more simply, prioritize bins where `bins_remain_cap` is small but sufficient.\n    \n    # Alternative interpretation of \"Almost Full Fit\":\n    # Prioritize bins that are already quite full (high occupancy).\n    # Among these, pick the one that can fit the item.\n\n    # Let's try prioritizing bins by their original remaining capacity, but only\n    # for those that can fit the item. The bins with the smallest `bins_remain_cap`\n    # that are still >= `item` are the best candidates. This is Best Fit.\n\n    # For \"Almost Full Fit\", maybe it's about finding a bin that, *after* the item is added,\n    # becomes \"almost full\" relative to its original capacity or some threshold.\n\n    # Let's consider the \"urgency\" of filling a bin. A bin that is currently at capacity `C`\n    # and can fit an item `i` leaving `C-i` capacity is prioritized if `C-i` is small.\n\n    # Consider the inverse of the remaining capacity *after* adding the item.\n    # Priority = 1 / (bins_remain_cap[i] - item + epsilon)\n    # This favors bins that leave less space.\n    \n    # We need to ensure that if a bin is too small, it gets zero or very low priority.\n    \n    # Let's try a score that peaks when `bins_remain_cap` is just above `item`.\n    # Consider `f(x) = max(0, C - x)` where `x` is the remaining capacity, `C` is the bin capacity, `item` is the item size.\n    # This doesn't directly use `bins_remain_cap`.\n\n    # Let's focus on `bins_remain_cap`. We want to prioritize bins where `bins_remain_cap`\n    # is relatively small, but still greater than or equal to `item`.\n    \n    # A common heuristic for \"Almost Full Fit\" is to give priority proportional\n    # to the remaining capacity of the bin, but only for bins that can fit the item.\n    # This seems counter-intuitive to \"almost full\".\n\n    # Let's use a score that is high when `bins_remain_cap` is slightly larger than `item`.\n    # And rapidly drops off as `bins_remain_cap` increases beyond `item`.\n\n    # Consider the function: `priority = exp(-alpha * (bins_remain_cap - item))` for `bins_remain_cap >= item`.\n    # `alpha` controls how quickly priority drops. Larger `alpha` means stronger preference for tighter fits.\n    # If `bins_remain_cap - item` is 0, priority is `exp(0) = 1`.\n    # If `bins_remain_cap - item` is small and positive, priority is slightly less than 1.\n    # If `bins_remain_cap - item` is large, priority approaches 0.\n\n    # Let's set alpha = 1 for simplicity.\n    alpha = 1.0\n    \n    # Apply the scoring only to bins that can fit the item.\n    # For bins that cannot fit, their priority remains 0.\n    priorities[can_fit_mask] = np.exp(-alpha * (bins_remain_cap[can_fit_mask] - item))\n\n    # This prioritizes bins that are closer to fitting the item.\n    # The 'almost full' aspect comes from the fact that if a bin's remaining capacity is\n    # much larger than `item`, the priority will be significantly lower than for a bin\n    # where `bins_remain_cap` is just `item` or slightly more.\n\n    # To make it more \"almost full\" specifically, we might want to ensure\n    # that bins that are *already* very full (i.e., `bins_remain_cap` is small,\n    # but still fits `item`) get a bonus.\n    # This current formula `exp(-(rem_cap - item))` inherently gives higher scores\n    # to smaller `rem_cap` values (given they are >= item).\n\n    # Let's consider an example: item = 0.3\n    # Bin capacities: [0.5, 0.4, 1.0, 0.35, 0.2]\n    # can_fit_mask: [True, True, True, True, False]\n    # bins_remain_cap[can_fit_mask]: [0.5, 0.4, 1.0, 0.35]\n    # rem_cap - item: [0.2, 0.1, 0.7, 0.05]\n    # priorities[can_fit_mask]: [exp(-0.2), exp(-0.1), exp(-0.7), exp(-0.05)]\n    # Priorities: [0.818, 0.904, 0.496, 0.951]\n\n    # The highest priority goes to the bin with remaining capacity 0.35, which is closest to 0.3.\n    # This seems to align well with \"Almost Full Fit\" \u2013 it finds a bin that will be\n    # \"almost full\" after the item is packed, by choosing the bin that leaves the least\n    # amount of space.\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements the First Fit Decreasing strategy.\n    It prioritizes bins that have just enough space for the item,\n    but also gives a small bonus to bins that have significantly more space\n    to encourage packing larger items into larger remaining capacities\n    for potential future efficiency gains (a form of lookahead).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins_remain_cap, dtype=float)\n\n    # Calculate the difference between remaining capacity and item size\n    # A difference close to zero is good (tight fit)\n    tight_fit_score = -np.abs(bins_remain_cap - item)\n\n    # Calculate a bonus for bins with large remaining capacity\n    # This encourages using larger bins when a tight fit isn't available or preferred.\n    # We can normalize this or use a logarithmic scale to avoid\n    # extremely large values for very large capacities.\n    # Here, we use a simple division by a factor to reduce the impact.\n    # Add a small epsilon to avoid division by zero.\n    large_capacity_bonus = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9) * 0.1\n\n    # Combine the scores. The tight fit has a stronger influence.\n    # Bins that can fit the item get a non-zero priority.\n    can_fit_mask = bins_remain_cap >= item\n    priorities[can_fit_mask] = tight_fit_score[can_fit_mask] + large_capacity_bonus[can_fit_mask]\n\n    # Ensure that bins that cannot fit the item have a very low priority (e.g., negative infinity)\n    # or simply leave them as 0, as they won't be chosen anyway by a max operation.\n    # For clarity, we can explicitly set them to a very low value.\n    priorities[~can_fit_mask] = -np.inf\n\n    return priorities\n\n[Reflection]\nPrioritize tight fits, but consider a bonus for larger capacities for future flexibility.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}