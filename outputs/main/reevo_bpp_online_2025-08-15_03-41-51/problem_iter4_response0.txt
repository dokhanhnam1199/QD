```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function implements a "Best Fit" strategy. It prioritizes
    bins that can accommodate the item with the least amount of remaining
    capacity (i.e., the tightest fit). This is because packing an item
    into a bin that is nearly full leaves less "wasted" space in that bin.
    Bins that cannot accommodate the item are given a very low priority.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority. Bins that cannot fit the item
        will have a very low priority (negative infinity).
    """
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that have enough remaining capacity for the item.
    can_fit_mask = bins_remain_cap >= item

    # For bins that can fit the item, we want to prioritize those that leave
    # the least amount of remaining space after the item is placed.
    # This means minimizing (bins_remain_cap - item).
    # A simple way to turn minimization into maximization for priority is to
    # use the negative of the slack space: `-(bins_remain_cap - item)`.
    # A smaller positive slack `bins_remain_cap - item` will result in a
    # less negative (higher) priority score.
    
    # Example: item = 0.3, bins_remain_cap = [0.35, 0.4, 0.5, 0.2]
    # can_fit_mask = [True, True, True, False]
    # For fitting bins:
    # slack_bins_remain_cap = [0.35, 0.4, 0.5]
    # resulting_remain_cap = [0.05, 0.1, 0.2]
    # priority_scores = [-0.05, -0.1, -0.2]
    # The bin with remaining capacity 0.35 (slack 0.05) gets the highest priority (-0.05).
    
    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)

    return priorities
```
