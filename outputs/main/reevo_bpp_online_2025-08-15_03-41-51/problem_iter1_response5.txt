```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Inverse Distance (Proximity Fit).

    This heuristic prioritizes bins that have just enough remaining capacity to fit the item,
    making it a "Proximity Fit" approach. Bins with very little remaining capacity or
    excessive remaining capacity are penalized.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Consider only bins that can fit the item
    suitable_bins_mask = bins_remain_cap >= item

    # Calculate the "distance" to fitting. We want bins where bins_remain_cap - item is close to 0.
    # A smaller "distance" means a better fit. We invert this distance to get a priority score.
    # To avoid division by zero or very small numbers causing extremely high priorities,
    # we add a small epsilon.
    epsilon = 1e-6
    distances = bins_remain_cap[suitable_bins_mask] - item
    priorities[suitable_bins_mask] = 1.0 / (distances + epsilon)

    # We can also slightly boost bins that are a "perfect" fit (distance == 0) to break ties
    # or further encourage exact fits if desired.
    perfect_fit_mask = (distances == 0)
    priorities[suitable_bins_mask][perfect_fit_mask] *= 1.5 # Boost perfect fits

    return priorities
```
