```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a tunable sigmoid fit score.

    This version introduces two tunable parameters: `steepness` and `ideal_gap_fraction`.
    `steepness` controls the sensitivity of the priority score to the deviation from the ideal gap.
    `ideal_gap_fraction` defines the preferred gap size as a fraction of the item size, aiming to
    slightly favor bins that are not perfectly filled, potentially leaving more room for future items.

    Args:
        item: Size of the item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of the same size as bins_remain_cap with priority scores for each bin.
        Scores range from 0 to 1, with higher scores indicating higher priority.
    """
    # Initialize priorities to a very low value (or 0) for bins that cannot fit the item.
    # Using 0 here as scores are normalized to [0, 1]. Negative infinity is also an option
    # if the selection mechanism explicitly handles it (e.g., `np.argmax` with initial low values).
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    possible_bins_mask = bins_remain_cap >= item

    if not np.any(possible_bins_mask):
        # No bin can fit the item, return all zeros.
        return priorities

    # Calculate the "gap" for possible bins: remaining capacity minus item size.
    gaps = bins_remain_cap[possible_bins_mask] - item

    # --- Tunable Parameters ---
    # `steepness`: Controls how quickly the priority drops as the gap deviates from the ideal gap.
    # A higher value makes the priority more sensitive to the gap size.
    steepness = 20.0

    # `ideal_gap_fraction`: Defines the target gap size as a fraction of the item's size.
    # E.g., 0.0 means prioritizing perfect fits (gap=0).
    # E.g., 0.05 means slightly favoring bins with a gap around 5% of the item size.
    # This can help in leaving a small buffer for future items.
    ideal_gap_fraction = 0.05

    # Calculate the ideal gap based on the item size.
    # Ensure the ideal gap is non-negative.
    ideal_gap = max(0.0, ideal_gap_fraction * item)

    # Calculate the argument for the sigmoid function.
    # We want the sigmoid's input to be close to zero when the `gap` is close to `ideal_gap`.
    # The sigmoid function is `1 / (1 + exp(-x))`.
    # To have the peak priority (around 1) when `gap == ideal_gap`, we can use `steepness * (ideal_gap - gap)`.
    # If `gap < ideal_gap`, the argument is positive, sigmoid -> close to 1.
    # If `gap = ideal_gap`, the argument is 0, sigmoid -> 0.5.
    # If `gap > ideal_gap`, the argument is negative, sigmoid -> close to 0.
    # This prioritizes smaller gaps over larger ones, with a peak preference at `ideal_gap`.
    sigmoid_arg = steepness * (ideal_gap - gaps)

    # Apply the sigmoid function to get priority scores in the range [0, 1].
    priorities[possible_bins_mask] = 1 / (1 + np.exp(-sigmoid_arg))

    return priorities
```
