```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using an optimized Sigmoid Fit Score strategy.

    This strategy prioritizes bins that, after adding the item, would have a
    remaining capacity that is "close" to zero. This is achieved by mapping
    the remaining capacity to a sigmoid function that outputs higher scores
    for smaller non-negative remaining capacities. A scaling factor `k` is used
    to control the steepness of the sigmoid curve, making the preference for
    minimal remaining capacity more pronounced.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins where the item does not fit will have a priority of -np.inf.
        For bins where the item fits, the priority is calculated using a sigmoid
        function to favor minimal remaining capacity.
    """
    # Calculate the remaining capacity if the item is placed in each bin
    remaining_capacities_after_placement = bins_remain_cap - item

    # Filter out bins where the item cannot fit. Assign them the lowest possible priority.
    valid_bins_mask = remaining_capacities_after_placement >= 0
    
    # Initialize priorities to a very low value for bins where the item doesn't fit.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float) 
    
    # For valid bins, calculate the priority using a sigmoid function.
    # We want to maximize priority as remaining_capacities_after_placement approaches 0.
    # A sigmoid function that achieves this is `1 / (1 + exp(k * r))`, where `r` is remaining capacity and `k > 0`.
    # This maps r=0 to 0.5, and larger r to values less than 0.5.
    # To make the priority higher for smaller remaining capacities, we want the sigmoid argument to be more negative
    # for smaller `r`. This is achieved by mapping `r` to `-k * r`.
    # The sigmoid form becomes `1 / (1 + exp(-(-k * r))) = 1 / (1 + exp(k * r))`.
    #
    # Alternatively, and perhaps more standard for "minimizing a value", we can use the sigmoid function
    # `sigmoid(x) = 1 / (1 + exp(-x))`. To prioritize small `r`, we need the argument `x` to be large
    # when `r` is small. So, `x = C - k * r` for constants `C` and `k > 0`.
    # Let's choose `x = -k * r` for simplicity, which means `C=0`.
    # Priority = `sigmoid(-k * r) = 1 / (1 + exp(-(-k * r))) = 1 / (1 + exp(k * r))`.
    #
    # This formulation maps:
    # r = 0     -> exp(0) = 1   -> priority = 1 / (1 + 1) = 0.5
    # r = small > 0 -> exp(small positive) > 1 -> priority < 0.5
    # r = large > 0 -> exp(large positive) >> 1 -> priority near 0
    #
    # This correctly assigns the highest priority (0.5) to bins with exactly zero remaining capacity,
    # and decreasing priorities for bins with larger remaining capacities.

    k = 5.0  # Scaling factor: higher k means a stronger preference for minimal remaining capacity.
             # This value can be tuned. A higher k makes the priority drop off more sharply as remaining capacity increases.

    r_valid = remaining_capacities_after_placement[valid_bins_mask]

    # Calculate the argument for the sigmoid function: `k * r_valid`.
    # For numerical stability with `np.exp`, we can bound the argument.
    # `exp(x)` overflows for `x > ~700`. If `k * r_valid` exceeds this, the priority should be near zero,
    # which `1 / (1 + infinity)` correctly yields.
    # If `k * r_valid` is very small (large negative), `exp` underflows to 0, giving priority 1.
    # Since `r_valid >= 0` and `k > 0`, `k * r_valid >= 0`.

    # We use `np.clip` to prevent potential issues if `k * r_valid` becomes extremely large,
    # ensuring `exp` doesn't overflow or produce NaNs. The value 700 is a common threshold for `exp(x)`.
    # If `k * r_valid` is greater than this, `exp` would be very large, and the priority would be close to 0.
    # If `k * r_valid` is very small (negative), which won't happen here since `r_valid >= 0`,
    # `exp` would be near 0, giving priority near 1.
    
    # The argument for the sigmoid is `k * r_valid`.
    # To ensure stability, we cap the argument to `exp`.
    # `bounded_arg = np.clip(k * r_valid, -700.0, 700.0)` is not strictly needed for `1 / (1 + exp(k * r_valid))`
    # because if `k * r_valid` is very large, `exp` will overflow to infinity, and `1 / (1 + inf)` is 0.
    # This is the desired behavior (very low priority for large remaining capacity).

    # Directly compute the sigmoid for valid bins.
    # `np.exp(k * r_valid)` can be very large, causing `1 / (1 + ...)` to be very small.
    # This is desired for large `r_valid`.
    priorities[valid_bins_mask] = 1.0 / (1.0 + np.exp(k * r_valid))

    return priorities
```
