```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Returns priority with which we want to add item to each bin.

    This heuristic prioritizes bins based on a combination of:
    1. Tightness of fit: Bins that leave minimal remaining space after packing.
    2. Flexibility: A small bonus for bins with larger remaining capacities.
    3. Stability: Using a sigmoid function to smoothly differentiate priorities.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Higher scores indicate higher priority.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Determine which bins can fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bins can fit the item, return all zeros
    if not np.any(can_fit_mask):
        return priorities

    # Calculate scores for bins that can fit the item
    fittable_bins_remain_cap = bins_remain_cap[can_fit_mask]
    fittable_indices = np.where(can_fit_mask)[0]

    # Score 1: Tightness (prioritize smaller remaining capacity after fit)
    # We want to minimize (remaining_capacity - item).
    # A smaller difference is better. We can map this to a higher score.
    # Using 1 / (difference + small_epsilon) for a steep increase as difference approaches 0.
    # Or using a negative of the difference for direct correlation with closeness.
    tightness_scores = fittable_bins_remain_cap - item
    # Small epsilon to avoid division by zero if remaining capacity is exactly item size
    epsilon_small = 1e-6
    tightness_priority = 1.0 / (tightness_scores + epsilon_small)


    # Score 2: Flexibility bonus (prioritize larger remaining capacity)
    # This encourages keeping some large bins open for potentially larger future items.
    # We can use a small boost proportional to the remaining capacity.
    flexibility_bonus = 0.1 * fittable_bins_remain_cap / np.max(fittable_bins_remain_cap + epsilon_small)

    # Combined score before sigmoid
    # Higher tightness_priority is good, higher flexibility_bonus is good
    combined_raw_score = tightness_priority + flexibility_bonus

    # Use sigmoid to smooth and bound the scores between 0 and 1.
    # Sigmoid(x) = 1 / (1 + exp(-x))
    # We need to scale the input to sigmoid to control its steepness.
    # Let's map a typical range of combined_raw_score to the sigmoid's sensitive region.
    # A simple scaling can be done by dividing by an estimate of the typical score.
    # Or, more directly, tune a parameter 'k' for sigmoid(k * x).
    # For simplicity, we'll use a direct sigmoid, assuming raw scores are somewhat reasonable.
    # A higher raw score maps to a higher sigmoid output.
    k_sigmoid = 0.5 # Steepness parameter for sigmoid
    sigmoid_scores = 1 / (1 + np.exp(-k_sigmoid * (combined_raw_score - np.median(combined_raw_score))))
    
    # Assign these sigmoid scores to the priorities array
    priorities[fittable_indices] = sigmoid_scores

    # Ensure that bins that cannot fit the item have a priority of 0
    priorities[~can_fit_mask] = 0.0

    # Normalize priorities to be between 0 and 1 (optional, but good for consistency)
    if np.max(priorities) > 0:
        priorities = priorities / np.max(priorities)

    return priorities
```
