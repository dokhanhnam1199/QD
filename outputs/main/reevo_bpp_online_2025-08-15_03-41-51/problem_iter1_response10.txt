```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin.

    This priority function implements the First Fit Decreasing strategy.
    It prioritizes bins that have just enough space for the item,
    but also gives a small bonus to bins that have significantly more space
    to encourage packing larger items into larger remaining capacities
    for potential future efficiency gains (a form of lookahead).

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Calculate the difference between remaining capacity and item size
    # A difference close to zero is good (tight fit)
    tight_fit_score = -np.abs(bins_remain_cap - item)

    # Calculate a bonus for bins with large remaining capacity
    # This encourages using larger bins when a tight fit isn't available or preferred.
    # We can normalize this or use a logarithmic scale to avoid
    # extremely large values for very large capacities.
    # Here, we use a simple division by a factor to reduce the impact.
    # Add a small epsilon to avoid division by zero.
    large_capacity_bonus = bins_remain_cap / (np.max(bins_remain_cap) + 1e-9) * 0.1

    # Combine the scores. The tight fit has a stronger influence.
    # Bins that can fit the item get a non-zero priority.
    can_fit_mask = bins_remain_cap >= item
    priorities[can_fit_mask] = tight_fit_score[can_fit_mask] + large_capacity_bonus[can_fit_mask]

    # Ensure that bins that cannot fit the item have a very low priority (e.g., negative infinity)
    # or simply leave them as 0, as they won't be chosen anyway by a max operation.
    # For clarity, we can explicitly set them to a very low value.
    priorities[~can_fit_mask] = -np.inf

    return priorities
```
