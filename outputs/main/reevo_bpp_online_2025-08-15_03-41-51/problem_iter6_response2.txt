```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using a tunable Sigmoid Fit Score.

    This version further refines the Sigmoid Fit Score by providing an explicit mechanism
    to tune both the `steepness` of the sigmoid and the `ideal_gap_fraction`.
    The `steepness` parameter controls the sensitivity of the priority to deviations from the ideal gap,
    while `ideal_gap_fraction` dictates the preferred slack after packing.
    A higher `steepness` means the heuristic is pickier about bins that are not close to the ideal gap.
    A higher `ideal_gap_fraction` means the heuristic prefers leaving more space.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Returns:
        Array of same size as bins_remain_cap with priority score of each bin.
        Bins that cannot fit the item will have a priority of -np.inf.
    """
    # Initialize priorities to negative infinity for bins that cannot fit the item.
    # This ensures they are never selected.
    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)

    # Identify bins that can accommodate the item
    possible_bins_mask = bins_remain_cap >= item

    if not np.any(possible_bins_mask):
        # If no bin can fit the item, return the initialized -np.inf priorities.
        return priorities

    # Calculate the "gap" for bins that can fit the item.
    # Gap is the remaining capacity after placing the item.
    gaps = bins_remain_cap[possible_bins_mask] - item

    # --- Tunable Parameters ---
    # `steepness`: Controls how quickly the priority score changes around the ideal gap.
    # Higher values make the heuristic more sensitive to deviations from the ideal gap.
    # A value of 0 would make all fitting bins have a priority of 0.5 (if ideal_gap is the same for all).
    # Generally, values between 10 and 50 are good starting points.
    steepness = 30.0

    # `ideal_gap_fraction`: Defines the target gap as a fraction of the item's size.
    # This parameter influences the 'bias' of the sigmoid, determining what gap is considered 'optimal'.
    # 0.0 means prefer a perfect fit.
    # 0.1 means prefer a gap of 10% of the item size.
    # This encourages leaving some buffer space for potentially larger items later.
    ideal_gap_fraction = 0.10  # Target for a gap of 10% of item size

    # Calculate the ideal gap. Ensure it's non-negative.
    ideal_gap = max(0.0, ideal_gap_fraction * item)

    # --- Sigmoid Argument Calculation ---
    # The sigmoid function: S(x) = 1 / (1 + exp(-x)) maps x to [0, 1].
    # We want to center the most favorable gap (ideal_gap) at the sigmoid's midpoint (where x=0).
    # The argument to the sigmoid will be `steepness * (ideal_gap - current_gap)`.
    #
    # - If `current_gap < ideal_gap`: (ideal_gap - current_gap) > 0, sigmoid_arg > 0, S(x) > 0.5.
    #   Smaller gaps (closer to 0) get higher scores, up to ideal_gap.
    # - If `current_gap = ideal_gap`: sigmoid_arg = 0, S(x) = 0.5. This is the pivot.
    # - If `current_gap > ideal_gap`: (ideal_gap - current_gap) < 0, sigmoid_arg < 0, S(x) < 0.5.
    #   Larger gaps get lower scores.
    sigmoid_arg = steepness * (ideal_gap - gaps)

    # Apply the sigmoid function to compute the priority scores for fitting bins.
    priorities[possible_bins_mask] = 1 / (1 + np.exp(-sigmoid_arg))

    return priorities
```
