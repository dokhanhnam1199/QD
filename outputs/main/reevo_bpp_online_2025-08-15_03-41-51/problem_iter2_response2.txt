```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Minimal Positive Remaining Capacity strategy.

    This strategy prioritizes bins that, after placing the item, will have the smallest
    positive remaining capacity. This encourages a "tight fit" and aims to minimize
    wasted space in bins that are nearly full.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Calculate the remaining capacity if the item is placed in each bin
    remaining_capacities_after_placement = bins_remain_cap - item

    # Filter out bins where the item cannot fit (remaining capacity would be negative)
    valid_bins_mask = remaining_capacities_after_placement >= 0
    
    # If no bin can fit the item, return zeros (no priority)
    if not np.any(valid_bins_mask):
        return np.zeros_like(bins_remain_cap)
        
    # Get the remaining capacities for the bins where the item fits
    valid_remaining_capacities = remaining_capacities_after_placement[valid_bins_mask]
    
    # We want to prioritize bins with the smallest positive remaining capacity.
    # A simple way to do this is to assign a priority score that is inversely
    # proportional to the remaining capacity. A smaller remaining capacity should
    # result in a higher priority score.
    #
    # To avoid division by zero (if remaining capacity is exactly 0), we add a small epsilon.
    # The inverse of a small positive number is a large number, effectively giving
    # the highest priority to bins with the tightest fit.
    
    epsilon = 1e-9  # A small value to avoid division by zero
    
    # Calculate priorities for the valid bins. Higher value means higher priority.
    # The smaller the `valid_remaining_capacities`, the larger the priority score.
    priorities_for_valid_bins = 1.0 / (valid_remaining_capacities + epsilon)
    
    # Initialize the full priorities array with zeros
    priorities = np.zeros_like(bins_remain_cap)
    
    # Assign the calculated priorities to the valid bins
    priorities[valid_bins_mask] = priorities_for_valid_bins
    
    return priorities
```
