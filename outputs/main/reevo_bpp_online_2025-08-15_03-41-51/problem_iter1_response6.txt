```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Sigmoid Fit Score.

    The Sigmoid Fit Score prioritizes bins that are closer to fitting the item perfectly,
    using a sigmoid function to map the "tightness" of the fit to a priority score.
    Bins that can fit the item (remaining capacity >= item size) are considered.
    The score is higher for bins where (remaining_capacity - item_size) is closer to zero.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can accommodate the item
    possible_bins_mask = bins_remain_cap >= item

    if not np.any(possible_bins_mask):
        # No bin can fit the item, return all zeros (or handle as an error/special case)
        return priorities

    # Calculate the "gap" for possible bins (how much space is left after placing the item)
    # We want to minimize this gap, so a smaller gap is better.
    gaps = bins_remain_cap[possible_bins_mask] - item

    # We want to use a sigmoid function that maps smaller gaps to higher priorities.
    # The standard sigmoid function outputs values between 0 and 1.
    # sigmoid(x) = 1 / (1 + exp(-x))
    # If x is large positive, sigmoid(x) is close to 1.
    # If x is large negative, sigmoid(x) is close to 0.
    # We want a higher score when the gap is small (close to 0).
    # Let's transform the gap: a smaller gap should result in a larger positive value
    # fed into the sigmoid.
    # Consider `scaled_gap = -gaps / scale_factor`. As gap approaches 0, scaled_gap approaches 0.
    # sigmoid(0) = 0.5. This doesn't quite give us the highest priority for a perfect fit.
    #
    # Let's reconsider the goal: prioritize bins that fit the item *tightly*.
    # This means the remaining capacity is just slightly larger than the item size.
    # So, (bins_remain_cap[i] - item) should be small and positive.
    #
    # A common way to use sigmoid for prioritization is to map the "goodness" of a
    # characteristic to a score.
    # Let's define "tightness" as how close `bins_remain_cap[i]` is to `item`.
    # Specifically, for bins that can fit the item, we are interested in
    # `bins_remain_cap[i] - item`.
    #
    # We want a function f(diff) where `diff = bins_remain_cap[i] - item` such that:
    # - f(diff) is high when `diff` is small and positive.
    # - f(diff) is lower when `diff` is large and positive.
    # - f(diff) is 0 or very low when `diff` is negative (or item doesn't fit).
    #
    # Let's try `sigmoid(k * (max_capacity - bins_remain_cap[i]))`.
    # If `bins_remain_cap[i]` is close to `item`, then `bins_remain_cap[i] - item` is small.
    #
    # Alternative approach: Model the "cost" of fitting.
    # A perfect fit has zero cost. A loose fit has a cost.
    # Consider the metric `bins_remain_cap[i] - item`.
    # We want a high priority when this value is close to 0 (and positive).
    #
    # Let's use a sigmoid on the *inverse* of the gap.
    # A small gap is a large inverse gap.
    #
    # Consider the difference `diff = bins_remain_cap[i] - item`.
    # We want a high score when `diff` is small and positive.
    #
    # Let's map `diff` to a score using sigmoid:
    # `sigmoid(A - B * diff)`:
    # - If `diff` is small positive, `B * diff` is small positive. `A - B * diff` is large positive. Sigmoid is close to 1.
    # - If `diff` is large positive, `B * diff` is large positive. `A - B * diff` is large negative. Sigmoid is close to 0.
    #
    # We need to choose parameters A and B appropriately.
    # Let's set A to control the center of the sigmoid and B to control the steepness.
    # A common approach is to center the sigmoid around 0.
    #
    # Let's define a score that peaks at 0 difference.
    # We can use `sigmoid(slope * (optimal_diff - current_diff))`.
    # `optimal_diff = 0`. So, `sigmoid(slope * (0 - (bins_remain_cap[i] - item)))`
    # = `sigmoid(slope * (item - bins_remain_cap[i]))`
    # = `sigmoid(slope * -(bins_remain_cap[i] - item))`
    #
    # For bins where `bins_remain_cap[i] < item`, this calculation is not directly applicable.
    # We've already filtered these out.
    # For bins where `bins_remain_cap[i] >= item`:
    # Let `gap = bins_remain_cap[i] - item`. `gap >= 0`.
    # The score is `sigmoid(-slope * gap)`.
    # - If `gap = 0` (perfect fit), score = `sigmoid(0)` = 0.5.
    # - If `gap` is small positive, `sigmoid` is slightly less than 0.5.
    # - If `gap` is large positive, `sigmoid` is close to 0.
    # This gives higher priority to bins with larger gaps, which is the opposite of what we want.
    #
    # We need a function that *decreases* as `gap` increases.
    # So, let's use `1 - sigmoid(slope * gap)` or `sigmoid(-slope * gap)`.
    #
    # Let's rethink: we want to prioritize bins where `bins_remain_cap[i]` is CLOSEST to `item`.
    # The difference `d = bins_remain_cap[i] - item`. We want `d` to be small and positive.
    #
    # Consider `1 / (1 + exp(-k * (value)))`
    # If we want the score to be high when `bins_remain_cap[i]` is just above `item`.
    #
    # Let `ratio = item / bins_remain_cap[i]`. This is relevant if bin capacity is variable.
    # Here, bin capacity is fixed, but remaining capacity changes.
    #
    # The "Sigmoid Fit Score" usually implies fitting the item as snugly as possible.
    # This means minimizing `bins_remain_cap[i] - item` for `bins_remain_cap[i] >= item`.
    #
    # Let's use the negative of the gap as the input to the sigmoid, which will give
    # values closer to 1 for smaller gaps.
    # `score = sigmoid(k * (item - bins_remain_cap[i]))`
    # This is equivalent to `sigmoid(k * -(bins_remain_cap[i] - item))`.
    #
    # Let's use `k = 1.0` for simplicity for now, and `sigmoid(x) = 1 / (1 + exp(-x))`.
    #
    # We want the score to be high for `bins_remain_cap[i]` just above `item`.
    #
    # Let's scale the gap to avoid numerical issues and control sensitivity.
    # `scaled_gap = (bins_remain_cap[possible_bins_mask] - item) / max(1, bins_remain_cap[possible_bins_mask].max())`
    # This makes the gap a value between 0 and 1 (if max_cap is 1).
    #
    # Consider `score = sigmoid(A - B * (bins_remain_cap[i] - item))`
    # Let's center the sigmoid such that a difference of `delta` results in a score of 0.5.
    # If we want a difference of 0 to be ideal, then `sigmoid(0) = 0.5`.
    #
    # A common sigmoid fit score in BPP aims to place the item in the bin
    # where the remaining capacity is the smallest that can still fit the item.
    # This is equivalent to minimizing `bins_remain_cap[i] - item` for `bins_remain_cap[i] >= item`.
    #
    # So, we want a function `f(gap)` where `f(gap)` is high for small `gap >= 0`.
    #
    # Let's use `f(gap) = 1 - sigmoid(k * gap)` or `f(gap) = sigmoid(-k * gap)`.
    # With `sigmoid(x) = 1 / (1 + exp(-x))`:
    # - `gap = 0`: `f(0) = sigmoid(0) = 0.5`. This is the peak value.
    # - `gap = small_positive`: `f(small_positive) = sigmoid(-k * small_positive)` is slightly less than 0.5.
    # - `gap = large_positive`: `f(large_positive) = sigmoid(-k * large_positive)` is close to 0.
    #
    # This means `sigmoid(-k * gap)` assigns a score that decreases as the gap increases.
    # The highest score is 0.5 for a perfect fit.

    # Let's define a "steepness" parameter for the sigmoid.
    # A larger `steepness` will make the score drop faster as the gap increases.
    steepness = 5.0  # Tune this parameter

    # Calculate the argument for the sigmoid function
    # We want to prioritize smaller gaps. So, `item - bins_remain_cap[i]` should be maximized (least negative).
    # Or equivalently, `bins_remain_cap[i] - item` should be minimized.
    # Using `sigmoid(-steepness * gap)` makes scores higher for smaller gaps.
    sigmoid_arg = -steepness * gaps

    # Apply the sigmoid function to get priorities
    # We are only calculating for possible bins, so we need to put these values back.
    priorities[possible_bins_mask] = 1 / (1 + np.exp(-sigmoid_arg))

    # If `item` is very small, `bins_remain_cap[i] - item` is close to `bins_remain_cap[i]`.
    # The sigmoid still works, prioritizing bins with less remaining capacity.

    return priorities
```
