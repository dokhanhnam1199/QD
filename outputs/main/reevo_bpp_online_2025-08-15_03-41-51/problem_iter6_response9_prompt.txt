{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"\n    Returns priority scores for each bin for the online Bin Packing Problem,\n    prioritizing tight fits with a sigmoid-like scoring and a small bonus for larger capacities.\n\n    This heuristic aims to balance the \"best fit\" strategy (tight packing) with\n    a slight preference for bins that still offer more flexibility for future items.\n\n    Args:\n        item: The size of the item to be packed.\n        bins_remain_cap: A numpy array representing the remaining capacity of each bin.\n\n    Returns:\n        A numpy array of priority scores, where higher scores indicate a higher\n        preference for placing the item in that bin.\n    \"\"\"\n    num_bins = len(bins_remain_cap)\n    priorities = np.zeros(num_bins, dtype=float)\n\n    # Identify bins that can accommodate the item\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return all zeros\n    if not np.any(can_fit_mask):\n        return priorities\n\n    # Calculate a \"tightness\" score. Lower remaining capacity after placing the item is better.\n    # We want to penalize bins that would have a lot of remaining space.\n    # A small epsilon is added to avoid division by zero if a bin has exactly 'item' capacity.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    \n    # Use a sigmoid-like function to map remaining capacity to a priority score.\n    # We want to give higher scores to smaller remaining capacities.\n    # The logistic function: L / (1 + exp(-k*(x-x0)))\n    # Here, x is remaining_after_fit.\n    # We want to map small remaining_after_fit to high scores.\n    # Let's invert the remaining_after_fit to make it directly proportional to priority.\n    # A common transformation for \"goodness\" based on \"badness\" (remaining space)\n    # is 1 / (1 + remaining_space), or using exp for smoother transition.\n    \n    # Factor to control the steepness of the sigmoid (higher means sharper transition)\n    steepness = 5.0\n    # Factor to control the midpoint of the sigmoid. We want to center it around\n    # the average \"waste\" if the item perfectly fits.\n    # A good heuristic might be to center around the expected small waste.\n    # Let's use a small value like 0.1 for x0.\n    midpoint = 0.1 \n\n    # Calculate scores based on remaining capacity after fitting.\n    # Higher scores for smaller remaining capacity (tighter fit).\n    # We use exp(-k*x) which is like a decaying exponential, and then normalize it.\n    # Or directly use logistic function on negative remaining capacity.\n    \n    # Option 1: Use exp decay on negative remaining capacity (higher is better)\n    # This will give higher scores to smaller remaining capacities.\n    # Add a small constant to avoid log(0) or very large numbers if remaining_after_fit is very negative (shouldn't happen with mask)\n    tightness_scores = np.exp(-steepness * (remaining_after_fit - midpoint))\n\n    # Option 2: Use a normalized inverse, e.g., 1 / (1 + remaining_after_fit)\n    # This might be less sensitive than exponential.\n    # tightness_scores = 1.0 / (1.0 + remaining_after_fit)\n    \n    # Add a small bonus for bins that still have significant remaining capacity.\n    # This encourages keeping some bins more open for larger future items.\n    # This bonus should be relatively small compared to the tightness score.\n    # We can use a scaled version of the remaining capacity itself.\n    flexibility_bonus_scale = 0.1 # Scale factor for the bonus\n    flexibility_bonus = flexibility_bonus_scale * (bins_remain_cap[can_fit_mask] - item)\n    \n    # Combine tightness score and flexibility bonus.\n    # The tightness score should dominate.\n    combined_scores = tightness_scores + flexibility_bonus\n\n    # Normalize the combined scores for bins that can fit.\n    # This makes the priorities relative to each other.\n    if np.any(combined_scores > 0):\n        normalized_scores = combined_scores / np.max(combined_scores)\n    else:\n        # If all combined scores are zero or negative (shouldn't happen with the logic above)\n        normalized_scores = np.zeros_like(combined_scores)\n\n    # Assign the calculated priorities to the bins that can fit\n    priorities[can_fit_mask] = normalized_scores\n\n    # Ensure bins that cannot fit have zero priority. This is already handled by initialization.\n    # priorities[~can_fit_mask] = 0.0\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a tunable Sigmoid Fit Score.\n\n    This version refines the Sigmoid Fit Score by introducing `steepness` to control the\n    sigmoid's slope and `ideal_gap_fraction` to specify the desired positive gap as a\n    fraction of the item size. This allows for fine-tuning the preference for bins\n    that are not perfectly filled, potentially leaving more room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority of -inf.\n    \"\"\"\n    # Initialize priorities to negative infinity for bins that cannot fit the item.\n    # This ensures they are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item\n    possible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(possible_bins_mask):\n        # If no bin can fit the item, return the initialized -inf priorities.\n        return priorities\n\n    # Calculate the \"gap\" for bins that can fit the item.\n    # Gap is the remaining capacity after placing the item.\n    gaps = bins_remain_cap[possible_bins_mask] - item\n\n    # --- Tunable Parameters ---\n    # `steepness`: Controls how quickly the priority score decreases as the gap increases.\n    # A higher value leads to a sharper drop-off, making the choice more sensitive to small gaps.\n    steepness = 25.0\n\n    # `ideal_gap_fraction`: Defines the target gap as a fraction of the item's size.\n    # A value of 0.0 means we ideally want a perfect fit (gap=0).\n    # A value of 0.1 means we ideally want a gap of 10% of the item size.\n    # This encourages leaving some buffer space.\n    ideal_gap_fraction = 0.08 # Aim for a gap of ~8% of the item size\n\n    # Calculate the ideal gap based on the item size.\n    # Ensure the ideal gap is non-negative. If item size is 0, ideal_gap is 0.\n    ideal_gap = max(0.0, ideal_gap_fraction * item)\n\n    # --- Sigmoid Argument Calculation ---\n    # We use the sigmoid function `1 / (1 + exp(-x))` which maps x to [0, 1].\n    # To prioritize bins with gaps close to `ideal_gap`, we can map `ideal_gap` to the center\n    # of the sigmoid's steep slope (input close to 0).\n    # The argument `x` for the sigmoid will be `steepness * (ideal_gap - gap)`.\n    #\n    # If `gap < ideal_gap`: The argument is positive, sigmoid output > 0.5. Higher scores for smaller gaps.\n    # If `gap = ideal_gap`: The argument is 0, sigmoid output = 0.5. This is the pivot point.\n    # If `gap > ideal_gap`: The argument is negative, sigmoid output < 0.5. Lower scores for larger gaps.\n    #\n    # By choosing `ideal_gap_fraction`, we are effectively tuning the bias of the sigmoid.\n    # The argument can be seen as: `steepness * ideal_gap - steepness * gap`.\n    # The `steepness * ideal_gap` term acts as an additive bias.\n    sigmoid_arg = steepness * (ideal_gap - gaps)\n\n    # Apply the sigmoid function to compute the priority scores for fitting bins.\n    # Higher values indicate a more desirable bin.\n    priorities[possible_bins_mask] = 1 / (1 + np.exp(-sigmoid_arg))\n\n    return priorities\n\n[Reflection]\nTune sigmoid parameters (steepness, ideal gap) for flexible fitting.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}