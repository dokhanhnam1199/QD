{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "Write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n[Worse code]\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin using a tunable Sigmoid Fit Score.\n\n    This version refines the Sigmoid Fit Score by introducing `steepness` to control the\n    sigmoid's slope and `ideal_gap_fraction` to specify the desired positive gap as a\n    fraction of the item size. This allows for fine-tuning the preference for bins\n    that are not perfectly filled, potentially leaving more room for future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a priority of -inf.\n    \"\"\"\n    # Initialize priorities to negative infinity for bins that cannot fit the item.\n    # This ensures they are never selected.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that can accommodate the item\n    possible_bins_mask = bins_remain_cap >= item\n\n    if not np.any(possible_bins_mask):\n        # If no bin can fit the item, return the initialized -inf priorities.\n        return priorities\n\n    # Calculate the \"gap\" for bins that can fit the item.\n    # Gap is the remaining capacity after placing the item.\n    gaps = bins_remain_cap[possible_bins_mask] - item\n\n    # --- Tunable Parameters ---\n    # `steepness`: Controls how quickly the priority score decreases as the gap increases.\n    # A higher value leads to a sharper drop-off, making the choice more sensitive to small gaps.\n    steepness = 25.0\n\n    # `ideal_gap_fraction`: Defines the target gap as a fraction of the item's size.\n    # A value of 0.0 means we ideally want a perfect fit (gap=0).\n    # A value of 0.1 means we ideally want a gap of 10% of the item size.\n    # This encourages leaving some buffer space.\n    ideal_gap_fraction = 0.08 # Aim for a gap of ~8% of the item size\n\n    # Calculate the ideal gap based on the item size.\n    # Ensure the ideal gap is non-negative. If item size is 0, ideal_gap is 0.\n    ideal_gap = max(0.0, ideal_gap_fraction * item)\n\n    # --- Sigmoid Argument Calculation ---\n    # We use the sigmoid function `1 / (1 + exp(-x))` which maps x to [0, 1].\n    # To prioritize bins with gaps close to `ideal_gap`, we can map `ideal_gap` to the center\n    # of the sigmoid's steep slope (input close to 0).\n    # The argument `x` for the sigmoid will be `steepness * (ideal_gap - gap)`.\n    #\n    # If `gap < ideal_gap`: The argument is positive, sigmoid output > 0.5. Higher scores for smaller gaps.\n    # If `gap = ideal_gap`: The argument is 0, sigmoid output = 0.5. This is the pivot point.\n    # If `gap > ideal_gap`: The argument is negative, sigmoid output < 0.5. Lower scores for larger gaps.\n    #\n    # By choosing `ideal_gap_fraction`, we are effectively tuning the bias of the sigmoid.\n    # The argument can be seen as: `steepness * ideal_gap - steepness * gap`.\n    # The `steepness * ideal_gap` term acts as an additive bias.\n    sigmoid_arg = steepness * (ideal_gap - gaps)\n\n    # Apply the sigmoid function to compute the priority scores for fitting bins.\n    # Higher values indicate a more desirable bin.\n    priorities[possible_bins_mask] = 1 / (1 + np.exp(-sigmoid_arg))\n\n    return priorities\n\n[Better code]\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This priority function implements a \"Best Fit\" strategy. It prioritizes\n    bins that can accommodate the item with the least amount of remaining\n    capacity (i.e., the tightest fit). This is because packing an item\n    into a bin that is nearly full leaves less \"wasted\" space in that bin.\n    Bins that cannot accommodate the item are given a very low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate higher priority. Bins that cannot fit the item\n        will have a very low priority (negative infinity).\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins that have enough remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For bins that can fit the item, we want to prioritize those that leave\n    # the least amount of remaining space after the item is placed.\n    # This means minimizing (bins_remain_cap - item).\n    # A simple way to turn minimization into maximization for priority is to\n    # use the negative of the slack space: `-(bins_remain_cap - item)`.\n    # A smaller positive slack `bins_remain_cap - item` will result in a\n    # less negative (higher) priority score.\n    \n    # Example: item = 0.3, bins_remain_cap = [0.35, 0.4, 0.5, 0.2]\n    # can_fit_mask = [True, True, True, False]\n    # For fitting bins:\n    # slack_bins_remain_cap = [0.35, 0.4, 0.5]\n    # resulting_remain_cap = [0.05, 0.1, 0.2]\n    # priority_scores = [-0.05, -0.1, -0.2]\n    # The bin with remaining capacity 0.35 (slack 0.05) gets the highest priority (-0.05).\n    \n    priorities[can_fit_mask] = -(bins_remain_cap[can_fit_mask] - item)\n\n    return priorities\n\n[Reflection]\nPrioritize tight fits, experiment with tunable parameters for complex strategies.\n\n[Improved code]\nPlease write an improved function `priority_v2`, according to the reflection. Output code only and enclose your code with Python code block: ```python ... ```."}