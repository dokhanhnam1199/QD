```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Implements a Sigmoid-based priority function for online Bin Packing.

    This function prioritizes bins that offer the "tightest fit" for the item.
    A tight fit is defined as a bin where the remaining capacity is just
    slightly larger than the item's size. The priority is calculated using
    a sigmoid function, which provides a smooth score that peaks when the
    difference between remaining capacity and item size is minimal (and positive).

    Args:
        item: The size of the item to be packed.
        bins_remain_cap: A NumPy array representing the remaining capacity of each bin.

    Returns:
        A NumPy array of the same size as bins_remain_cap, where each element
        is the priority score for placing the item in the corresponding bin.
        Bins that cannot fit the item will have a priority of 0.
    """
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can potentially fit the item
    can_fit_mask = bins_remain_cap >= item

    # If no bin can fit the item, return all zeros.
    if not np.any(can_fit_mask):
        return priorities

    # Calculate the "gap" for bins that can fit the item.
    # The gap is the difference between the bin's remaining capacity and the item's size.
    # A smaller gap indicates a tighter fit.
    gaps = bins_remain_cap[can_fit_mask] - item

    # Use a sigmoid function to map the gap to a priority score.
    # We want to assign higher scores to smaller gaps.
    # The sigmoid function `1 / (1 + exp(-x))` maps `x` to `(0, 1)`.
    # To prioritize smaller gaps, we can use `sigmoid(-k * gap)`, where `k` is a steepness factor.
    # A smaller `gap` results in a less negative argument to the sigmoid, yielding a higher score.
    # For a gap of 0 (perfect fit), the sigmoid argument is 0, and the score is 0.5.
    # For larger gaps, the sigmoid argument becomes more negative, and the score approaches 0.

    steepness = 10.0  # This parameter controls how quickly the priority drops as the gap increases.
                     # A higher value means a stronger preference for very tight fits.
                     # It can be tuned based on experimental results or problem specifics.

    # Calculate the sigmoid argument: -steepness * gap
    sigmoid_input = -steepness * gaps

    # Apply the sigmoid function. The output will be in the range (0, 1).
    # These are the priority scores for the bins that can fit the item.
    priority_scores = 1 / (1 + np.exp(-sigmoid_input))

    # Place these calculated priority scores back into the full priorities array.
    priorities[can_fit_mask] = priority_scores

    return priorities
```
