```python
import numpy as np
import scipy.stats as stats

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """
    Prioritizes bins for online Bin Packing Problem (BPP) using a refined heuristic.

    This function aims to balance the immediate "tightness" of a fit with future
    flexibility by considering the remaining capacity in a more nuanced way.
    It uses a sigmoid function to map the "gap" (remaining capacity - item)
    to a priority score, favoring bins with small positive gaps.

    Args:
        item: Size of the item to be packed.
        bins_remain_cap: A numpy array where each element is the remaining
                         capacity of a bin.

    Returns:
        A numpy array of the same size as bins_remain_cap, where each element
        is the priority score for the corresponding bin. Higher scores indicate
        higher priority. Bins that cannot fit the item will have a score of 0.
    """
    num_bins = len(bins_remain_cap)
    priorities = np.zeros_like(bins_remain_cap, dtype=float)

    # Identify bins that can fit the item
    can_fit_mask = bins_remain_cap >= item

    # Calculate the "gap" for bins that can fit the item
    # Gap is defined as remaining_capacity - item
    gaps = bins_remain_cap[can_fit_mask] - item

    # Parameters for the sigmoid function
    # Steepness: Controls how quickly the priority drops off as the gap increases.
    # A higher steepness means only very tight fits get high priority.
    steepness = 10.0
    # Ideal Gap: The gap size that yields the maximum priority.
    # We aim for a small positive gap, as this implies a good fit without
    # leaving excessive wasted space. Setting it slightly above 0 encourages
    # slightly less "perfect" fits that might leave more room for future items.
    ideal_gap = 0.1  # Tuned for a small positive gap

    # Apply sigmoid function to the gaps.
    # The sigmoid function maps any real number to a value between 0 and 1.
    # We shift the gaps so that 'ideal_gap' corresponds to the center of the sigmoid,
    # and then scale by steepness.
    # sigmoid(x) = 1 / (1 + exp(-x))
    # We want to transform the gap to have a peak priority at ideal_gap.
    # A common approach is to use 1 / (1 + exp(-steepness * (gap - ideal_gap)))
    # This results in priority peaking at ideal_gap.
    if len(gaps) > 0:
        sigmoid_scores = 1 / (1 + np.exp(-steepness * (gaps - ideal_gap)))
        priorities[can_fit_mask] = sigmoid_scores

    # Add a small stabilization factor to prevent extremely low priorities
    # from being zero and to slightly boost bins that are not the absolute best fit.
    # This is a form of soft exploration/stabilization.
    stabilization_factor = 0.05
    priorities[can_fit_mask] += stabilization_factor

    # Normalize priorities to be between 0 and 1.
    # This ensures that scores are comparable across different item/bin states.
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = priorities / max_priority
    else:
        # If no bin can fit the item, all priorities remain 0.
        pass
        
    # Further refinement: Add a small random noise to break ties and encourage exploration
    # This is applied to all bins that can fit the item.
    noise_level = 0.02
    noise = np.random.rand(num_bins) * noise_level
    priorities[can_fit_mask] += noise

    # Re-normalize after adding noise
    max_priority = np.max(priorities)
    if max_priority > 0:
        priorities = priorities / max_priority
        
    # Ensure no negative priorities (though our logic shouldn't produce them)
    priorities[priorities < 0] = 0

    return priorities
```
