```python
import numpy as np

def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin using Best Fit.

    The Best Fit strategy prioritizes bins that have just enough capacity to hold the item.
    This is achieved by calculating the difference between the bin's remaining capacity
    and the item's size. Smaller differences indicate a better fit.
    We also want to avoid bins that are too small for the item, so we assign a very low
    priority to such bins.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities to a very low value (effectively making them ineligible)
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins that can actually accommodate the item
    suitable_bins_mask = bins_remain_cap >= item

    # For suitable bins, calculate the "waste" if the item is placed in it.
    # The best fit is the one that minimizes this waste (remaining_capacity - item).
    # We want to maximize the negative waste, so smaller waste means higher priority.
    waste = bins_remain_cap[suitable_bins_mask] - item
    priorities[suitable_bins_mask] = -waste

    return priorities
```
