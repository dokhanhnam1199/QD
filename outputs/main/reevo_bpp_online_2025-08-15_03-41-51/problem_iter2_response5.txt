```python
def priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:
    """Returns priority with which we want to add item to each bin, prioritizing tighter fits.

    This strategy aims to fill bins as completely as possible. Bins that have just
    enough remaining capacity to fit the item (i.e., the smallest positive difference
    between remaining capacity and item size) will receive the highest priority.
    For bins where the item does not fit, the priority is set to a very low value.

    Args:
        item: Size of item to be added to the bin.
        bins_remain_cap: Array of remaining capacities for each bin.

    Return:
        Array of same size as bins_remain_cap with priority score of each bin.
    """
    # Initialize priorities with a very low value to represent infeasible bins
    priorities = np.full_like(bins_remain_cap, -np.inf)

    # Identify bins where the item can fit
    fit_mask = bins_remain_cap >= item

    # For bins where the item fits, calculate the "gap" or excess capacity.
    # A smaller gap means a tighter fit.
    # We want to prioritize smaller gaps, so we can use the negative of the gap
    # or an inverse function of the gap. Using negative of the gap directly
    # makes higher values correspond to tighter fits.
    gaps = bins_remain_cap[fit_mask] - item
    priorities[fit_mask] = -gaps

    return priorities
```
