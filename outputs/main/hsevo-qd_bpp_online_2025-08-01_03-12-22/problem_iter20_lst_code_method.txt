{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a refined \"Best Fit\" strategy, designed to more\n    aggressively prioritize optimal fits and encourage efficient bin utilization.\n    It introduces a non-linear penalty for remaining capacity and a significant\n    bonus for the item's relative size compared to the bin's current available space.\n\n    Args:\n        item: Size of item to be added to the bin. Must be greater than 0.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        base_fit_priority: A base score given to any bin where the item can fit.\n                           This sets the initial priority before any adjustments.\n        rem_cap_penalty_factor: A multiplier for the non-linear penalty applied\n                                based on the remaining capacity after item placement.\n                                Higher values penalize larger remaining capacities more.\n        rem_cap_penalty_exponent: An exponent (typically > 1) applied to the\n                                  remaining capacity when calculating the penalty.\n                                  A value greater than 1 makes the penalty for\n                                  larger remaining capacities disproportionately\n                                  more severe, thereby strongly favoring very tight fits\n                                  (i.e., less remaining space).\n        relative_fill_bonus_factor: A multiplier for a bonus that rewards placing\n                                    an item into a bin where it occupies a significant\n                                    proportion of the bin's *current* available capacity.\n                                    This encourages \"filling up\" bins that are already\n                                    partially utilized or finding relatively large items\n                                    for smaller remaining spaces.\n        min_allowed_priority: The minimum priority score a bin can receive if\n                              the item fits. This acts as a floor, preventing\n                              valid placement priorities from becoming too low.\n        non_fitting_priority: The priority score assigned to bins where the\n                              item does not fit. Typically a low or negative value.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities with the score for non-fitting bins\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n\n    # Identify bins where the item can fit\n    # Item size must be strictly greater than 0 for typical BPP, so bins_remain_cap[can_fit_mask] > 0\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only process if there are bins where the item can fit\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # Applying an exponent > 1 ensures that as remaining_after_placement increases,\n        # the penalty grows disproportionately faster than a linear penalty,\n        # thus heavily favoring bins that result in very little remaining space.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # This bonus term rewards placing the item where it constitutes a larger\n        # fraction of the *current* available capacity in the bin.\n        # This encourages filling up bins that are already partially full,\n        # or fitting smaller items into smaller remaining gaps, thereby \"tidying up\" bins.\n        # Division by zero is inherently avoided here because if item > 0, then\n        # fitting_bins_remain_cap must be > 0 (as fitting_bins_remain_cap >= item).\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # Combine the base priority, non-linear penalty, and relative fill bonus\n        calculated_priorities = base_fit_priority - rem_cap_penalty + relative_fill_bonus\n\n        # Ensure that the calculated priority does not fall below a minimum allowed value\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        # Assign the calculated priorities to the corresponding bins\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    perfect_fit_bonus: float = 150.0,  # Significant bonus for perfect closure\n    perfect_fit_tolerance: float = 1e-9,  # Tolerance for float comparison of perfect fit\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Refined Best Fit prioritizing tight fits and high utilization with a\n    significant bonus for perfect bin closure, aiming to minimize total bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # Heavily penalizes bins that leave a lot of unused space.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # Rewards placing the item where it occupies a larger proportion of the bin's current capacity.\n        # Avoids division by zero as fitting_bins_remain_cap >= item > 0.\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # Initialize calculated priorities with base + relative fill bonus - remaining capacity penalty\n        calculated_priorities = base_fit_priority - rem_cap_penalty + relative_fill_bonus\n\n        # 3. Explicit Perfect Fit Bonus (Inspired by 'tightest fit' and bin closure)\n        # Apply a substantial bonus for bins where the item perfectly fills the remaining space.\n        # Use a small tolerance for floating-point precision.\n        perfect_fit_mask_local = np.abs(remaining_after_placement) < perfect_fit_tolerance\n        calculated_priorities[perfect_fit_mask_local] += perfect_fit_bonus\n\n        # Ensure priorities do not fall below a minimum allowed value for fitting bins\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    perfect_fit_bonus: float = 150.0,  # Significant bonus for perfect closure\n    perfect_fit_tolerance: float = 1e-9,  # Tolerance for float comparison of perfect fit\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Refined Best Fit prioritizing tight fits and high utilization with a\n    significant bonus for perfect bin closure, aiming to minimize total bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # Heavily penalizes bins that leave a lot of unused space.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # Rewards placing the item where it occupies a larger proportion of the bin's current capacity.\n        # Avoids division by zero as fitting_bins_remain_cap >= item > 0.\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # Initialize calculated priorities with base + relative fill bonus - remaining capacity penalty\n        calculated_priorities = base_fit_priority - rem_cap_penalty + relative_fill_bonus\n\n        # 3. Explicit Perfect Fit Bonus (Inspired by 'tightest fit' and bin closure)\n        # Apply a substantial bonus for bins where the item perfectly fills the remaining space.\n        # Use a small tolerance for floating-point precision.\n        perfect_fit_mask_local = np.abs(remaining_after_placement) < perfect_fit_tolerance\n        calculated_priorities[perfect_fit_mask_local] += perfect_fit_bonus\n\n        # Ensure priorities do not fall below a minimum allowed value for fitting bins\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    perfect_fit_threshold: float = 0.01,\n    perfect_fit_bonus: float = 180.0,\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function refines the \"Best Fit\" strategy, enhancing \"priority_v1\"\n    with a strong emphasis on \"Intelligent Bin Closure\". It introduces a\n    significant, dedicated bonus for \"near-perfect fits\", aggressively\n    prioritizing bins that can be almost completely filled, thereby minimizing\n    fragmentation and promoting efficient bin closure.\n\n    Args:\n        item: Size of item to be added to the bin. Must be greater than 0.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        base_fit_priority: A base score given to any bin where the item can fit.\n                           This sets the initial priority before any adjustments.\n        rem_cap_penalty_factor: A multiplier for the non-linear penalty applied\n                                based on the remaining capacity after item placement.\n                                Higher values penalize larger remaining capacities more.\n        rem_cap_penalty_exponent: An exponent (typically > 1) applied to the\n                                  remaining capacity when calculating the penalty.\n                                  A value greater than 1 makes the penalty for\n                                  larger remaining capacities disproportionately\n                                  more severe, thereby strongly favoring very tight fits\n                                  (i.e., less remaining space).\n        relative_fill_bonus_factor: A multiplier for a bonus that rewards placing\n                                    an item into a bin where it occupies a significant\n                                    proportion of the bin's *current* available capacity.\n                                    This encourages \"filling up\" bins that are already\n                                    partially utilized or finding relatively large items\n                                    for smaller remaining spaces.\n        perfect_fit_threshold: If the remaining capacity after item placement is\n                               less than or equal to this threshold, a substantial\n                               'perfect_fit_bonus' is added. This strategically targets\n                               scenarios where a bin can be considered 'closed' or\n                               left with negligible unusable space.\n        perfect_fit_bonus: A large, fixed bonus applied to bins that achieve a\n                           near-perfect fit. This value should be high enough to\n                           make such bins overwhelmingly attractive, reflecting a\n                           strategic priority for bin closure.\n        min_allowed_priority: The minimum priority score a bin can receive if\n                              the item fits. This acts as a floor, preventing\n                              valid placement priorities from becoming too low.\n        non_fitting_priority: The priority score assigned to bins where the\n                              item does not fit. Typically a low or negative value.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities with the score for non-fitting bins\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only process if there are bins where the item can fit\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # This term strongly favors bins with minimal remaining space after placement.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # This term rewards maximizing the utilization of the bin's current available space.\n        # Division by zero is avoided as fitting_bins_remain_cap >= item > 0.\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # 3. Strategic Near-Perfect Fit Bonus (Intelligent Bin Closure)\n        # This is a new, aggressive component designed to strongly incentivize\n        # \"closing\" a bin by leaving a very small or zero remaining capacity.\n        # It ensures that bins nearing full capacity are given top preference.\n        near_perfect_fit_mask = remaining_after_placement <= perfect_fit_threshold\n        perfect_fit_bonus_term = np.where(near_perfect_fit_mask, perfect_fit_bonus, 0.0)\n\n        # Combine the base priority, non-linear penalty, relative fill bonus,\n        # and the new perfect fit bonus.\n        calculated_priorities = (\n            base_fit_priority\n            - rem_cap_penalty\n            + relative_fill_bonus\n            + perfect_fit_bonus_term  # Add the high bonus for near-perfect fits\n        )\n\n        # Ensure that the calculated priority does not fall below a minimum allowed value\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        # Assign the calculated priorities to the corresponding bins\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    perfect_fit_bonus: float = 150.0,  # Significant bonus for perfect closure\n    perfect_fit_tolerance: float = 1e-9,  # Tolerance for float comparison of perfect fit\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Refined Best Fit prioritizing tight fits and high utilization with a\n    significant bonus for perfect bin closure, aiming to minimize total bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # Heavily penalizes bins that leave a lot of unused space.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # Rewards placing the item where it occupies a larger proportion of the bin's current capacity.\n        # Avoids division by zero as fitting_bins_remain_cap >= item > 0.\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # Initialize calculated priorities with base + relative fill bonus - remaining capacity penalty\n        calculated_priorities = base_fit_priority - rem_cap_penalty + relative_fill_bonus\n\n        # 3. Explicit Perfect Fit Bonus (Inspired by 'tightest fit' and bin closure)\n        # Apply a substantial bonus for bins where the item perfectly fills the remaining space.\n        # Use a small tolerance for floating-point precision.\n        perfect_fit_mask_local = np.abs(remaining_after_placement) < perfect_fit_tolerance\n        calculated_priorities[perfect_fit_mask_local] += perfect_fit_bonus\n\n        # Ensure priorities do not fall below a minimum allowed value for fitting bins\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    perfect_fit_bonus: float = 150.0,  # Significant bonus for perfect closure\n    perfect_fit_tolerance: float = 1e-9,  # Tolerance for float comparison of perfect fit\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Refined Best Fit prioritizing tight fits and high utilization with a\n    significant bonus for perfect bin closure, aiming to minimize total bins.\n    \"\"\"\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # Heavily penalizes bins that leave a lot of unused space.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # Rewards placing the item where it occupies a larger proportion of the bin's current capacity.\n        # Avoids division by zero as fitting_bins_remain_cap >= item > 0.\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # Initialize calculated priorities with base + relative fill bonus - remaining capacity penalty\n        calculated_priorities = base_fit_priority - rem_cap_penalty + relative_fill_bonus\n\n        # 3. Explicit Perfect Fit Bonus (Inspired by 'tightest fit' and bin closure)\n        # Apply a substantial bonus for bins where the item perfectly fills the remaining space.\n        # Use a small tolerance for floating-point precision.\n        perfect_fit_mask_local = np.abs(remaining_after_placement) < perfect_fit_tolerance\n        calculated_priorities[perfect_fit_mask_local] += perfect_fit_bonus\n\n        # Ensure priorities do not fall below a minimum allowed value for fitting bins\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                base_fit_priority: float = 40.67957013415283,\n                remaining_capacity_penalty_factor: float = 2.527225052325968,\n                min_allowed_priority: float = 0.5896372460377476,\n                non_fitting_priority: float = -8.783827459234484,\n                perfect_fit_bonus: float = 10.0,\n                perfect_fit_epsilon: float = 1e-9) -> np.ndarray:\n    \"\"\"Combines Best Fit with a strong bonus for perfect item placement.\n    Prioritizes minimizing remaining bin capacity while significantly rewarding bins\n    that are completely filled by the item, improving space utilization.\n    \"\"\"\n    # Initialize all priorities with the value for non-fitting bins\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only process if there are bins where the item can fit\n    if np.any(can_fit_mask):\n        # Calculate the remaining capacity for bins where the item could be placed\n        remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n        # Calculate the base priority using a \"Best Fit\" approach\n        # This penalizes larger remaining capacities, encouraging a tight fit.\n        calculated_priorities = base_fit_priority - (remaining_capacity_penalty_factor * remaining_after_placement)\n\n        # Apply a significant bonus for \"perfect fits\" (remaining capacity is nearly zero).\n        # This incentivizes closing bins efficiently.\n        perfect_fit_mask_local = np.isclose(remaining_after_placement, 0.0, atol=perfect_fit_epsilon)\n        calculated_priorities[perfect_fit_mask_local] += perfect_fit_bonus\n\n        # Ensure that the calculated priority does not fall below a minimum allowed value\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        # Assign the calculated priorities to the corresponding bins\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float,\n                bins_remain_cap: np.ndarray,\n                base_fit_priority: float = 40.67957013415283,\n                remaining_capacity_penalty_factor: float = 2.527225052325968,\n                min_allowed_priority: float = 0.5896372460377476,\n                non_fitting_priority: float = -8.783827459234484,\n                perfect_fit_bonus: float = 10.0,\n                perfect_fit_epsilon: float = 1e-9) -> np.ndarray:\n    \"\"\"Combines Best Fit with a strong bonus for perfect item placement.\n    Prioritizes minimizing remaining bin capacity while significantly rewarding bins\n    that are completely filled by the item, improving space utilization.\n    \"\"\"\n    # Initialize all priorities with the value for non-fitting bins\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n\n    # Identify bins where the item can fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only process if there are bins where the item can fit\n    if np.any(can_fit_mask):\n        # Calculate the remaining capacity for bins where the item could be placed\n        remaining_after_placement = bins_remain_cap[can_fit_mask] - item\n\n        # Calculate the base priority using a \"Best Fit\" approach\n        # This penalizes larger remaining capacities, encouraging a tight fit.\n        calculated_priorities = base_fit_priority - (remaining_capacity_penalty_factor * remaining_after_placement)\n\n        # Apply a significant bonus for \"perfect fits\" (remaining capacity is nearly zero).\n        # This incentivizes closing bins efficiently.\n        perfect_fit_mask_local = np.isclose(remaining_after_placement, 0.0, atol=perfect_fit_epsilon)\n        calculated_priorities[perfect_fit_mask_local] += perfect_fit_bonus\n\n        # Ensure that the calculated priority does not fall below a minimum allowed value\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        # Assign the calculated priorities to the corresponding bins\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, BIN_CAPACITY: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Returns priority scores for each bin, based on an \"Adaptive Fullness Prioritization\" heuristic.\n\n    This heuristic mutates the standard 'Best Fit' by introducing strategic considerations\n    for space management beyond simple minimization of remaining capacity. It aims to:\n\n    1.  **Strongly Reward Perfect Fits**: A perfect fit (leaving 0 remaining capacity)\n        is the most efficient use of space, effectively \"closing\" a bin. This is\n        given a significant bonus.\n    2.  **Prioritize High Overall Utilization**: Similar to Best Fit, bins that\n        become very full after placing the item are generally preferred.\n    3.  **Penalize Fragmented Space**: A minor penalty is applied to bins that\n        are left with a very small, non-zero remaining capacity. Such 'fragments'\n        are often too small to be useful for subsequent items and can lead to\n        wasted space or increased bin count if many such bins accumulate.\n        This encourages the selection of bins that either achieve a perfect fit,\n        or leave a more 'useful' (larger) amount of remaining space, allowing for\n        greater flexibility for future items.\n\n    The goal is to not just minimize residual space, but to do so in a way\n    that minimizes \"unusable\" small fragments, promoting overall\n    packing efficiency and potentially reducing the number of bins.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        BIN_CAPACITY: The maximum capacity of a single bin. Default to 1.0,\n                      assuming item and capacities are normalized.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score for each bin.\n        Higher scores indicate a more desirable bin. Bins where the item does not\n        fit receive a score of -infinity.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity after hypothetical placement for fitting bins\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # Primary scoring component: Utilization after placing the item.\n    # A higher utilization means less remaining space, similar to Best Fit.\n    # Scores range from 0 (empty bin after placement) to 1 (full bin).\n    utilization_score = (BIN_CAPACITY - remaining_after_fit) / BIN_CAPACITY\n\n    # Define a small epsilon for floating point comparisons to handle near-zero values.\n    epsilon = 1e-9\n\n    # Strategic Bonus: Strongly reward perfect fits.\n    # Using np.isclose for robust floating point comparison to zero.\n    perfect_fit_mask = np.isclose(remaining_after_fit, 0.0, atol=epsilon)\n    # Adding a substantial bonus (e.g., 1.0) makes perfect fits unequivocally\n    # the highest priority, pushing their score beyond the normal 0-1 range.\n    utilization_score[perfect_fit_mask] += 1.0\n\n    # Strategic Penalty: Slightly penalize very small, non-zero remaining capacities.\n    # These are deemed \"fragmented\" or potentially \"wasted\" space.\n    # The threshold for what constitutes a \"small fragment\" can be tuned,\n    # here set to 5% of the bin capacity.\n    fragment_threshold = 0.05 * BIN_CAPACITY\n    \n    # Identify bins that have a small, non-zero remainder.\n    # Ensure it's greater than epsilon to not penalize perfect fits.\n    fragment_mask = (remaining_after_fit > epsilon) & (remaining_after_fit < fragment_threshold)\n    \n    # Subtract a small penalty (e.g., 0.1) to make these bins slightly less\n    # attractive compared to those leaving a more useful or zero remainder.\n    utilization_score[fragment_mask] -= 0.1\n\n    # Assign the calculated scores to the bins where the item can fit.\n    scores[can_fit_mask] = utilization_score\n\n    return scores\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Focuses on maximizing bin utilization by prioritizing bins that offer the highest proportional fill.\n\n    This heuristic adaptively weighs each bin's suitability based on the item's\n    relative size to the bin's current capacity, exploiting the pattern\n    of high-density packing for efficient bin closure.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity, ensuring bins where\n    # the item cannot fit are never selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins with sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For valid bins, calculate the 'fill ratio': the proportion of the bin's\n    # current remaining capacity that the item would occupy.\n    # This adaptively prioritizes bins that, upon accommodating the item, achieve\n    # the highest relative utilization, leading to a more compact packing strategy.\n    # A higher ratio indicates a tighter fit relative to the available space,\n    # exploiting the pattern of efficient, high-density placement.\n    # Note: Assumes item > 0. If item is 0, division would be 0/X (score 0), which is handled.\n    # If item > 0 and bins_remain_cap is 0, can_fit_mask would be False.\n    scores[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return scores\n\n[Heuristics 11th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority score for each bin. Combines Best Fit with a penalty for very small, non-zero remainders.\n    Prioritizes perfect fits, then larger useful gaps over tiny unusable ones, aiming to minimize wasted fragmented space.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity, ensuring un-fittable bins are never chosen.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if item were placed. This is the core Best Fit principle.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    # Initial score: negative of remaining capacity. Perfect fit (0 remainder) gets 0.0 (highest).\n    scores[can_fit_mask] = -remaining_after_fit\n\n    # Define thresholds for what constitutes a \"tiny\" and potentially \"unusable\" remainder.\n    # These values are empirical and might need tuning based on typical item/bin size distributions.\n    TINY_REMAINDER_THRESHOLD = 0.05  # e.g., 5% of an assumed normalized bin capacity (e.g., if max capacity is 1.0)\n    PENALTY_FOR_TINY_REMAINDER = 0.001 # A small penalty, ensuring a perfect fit (0 remainder) still receives the highest score.\n\n    # Identify valid bins that would result in a very small, non-zero remainder.\n    # A small epsilon (1e-9) is used to robustly check for non-zero floating-point values.\n    tiny_remainder_cond = (remaining_after_fit > 1e-9) & (remaining_after_fit < TINY_REMAINDER_THRESHOLD)\n\n    # Apply a penalty to the scores of bins that leave a tiny, potentially unusable remainder.\n    # This slightly discourages leaving highly fragmented space, encouraging either a perfect fit\n    # or a more substantial, potentially useful remaining gap for future, larger items.\n    scores[can_fit_mask][tiny_remainder_cond] -= PENALTY_FOR_TINY_REMAINDER\n\n    return scores\n\n[Heuristics 12th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority score for each bin. Combines Best Fit with a penalty for very small, non-zero remainders.\n    Prioritizes perfect fits, then larger useful gaps over tiny unusable ones, aiming to minimize wasted fragmented space.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity, ensuring un-fittable bins are never chosen.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate remaining capacity if item were placed. This is the core Best Fit principle.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    # Initial score: negative of remaining capacity. Perfect fit (0 remainder) gets 0.0 (highest).\n    scores[can_fit_mask] = -remaining_after_fit\n\n    # Define thresholds for what constitutes a \"tiny\" and potentially \"unusable\" remainder.\n    # These values are empirical and might need tuning based on typical item/bin size distributions.\n    TINY_REMAINDER_THRESHOLD = 0.05  # e.g., 5% of an assumed normalized bin capacity (e.g., if max capacity is 1.0)\n    PENALTY_FOR_TINY_REMAINDER = 0.001 # A small penalty, ensuring a perfect fit (0 remainder) still receives the highest score.\n\n    # Identify valid bins that would result in a very small, non-zero remainder.\n    # A small epsilon (1e-9) is used to robustly check for non-zero floating-point values.\n    tiny_remainder_cond = (remaining_after_fit > 1e-9) & (remaining_after_fit < TINY_REMAINDER_THRESHOLD)\n\n    # Apply a penalty to the scores of bins that leave a tiny, potentially unusable remainder.\n    # This slightly discourages leaving highly fragmented space, encouraging either a perfect fit\n    # or a more substantial, potentially useful remaining gap for future, larger items.\n    scores[can_fit_mask][tiny_remainder_cond] -= PENALTY_FOR_TINY_REMAINDER\n\n    return scores\n\n[Heuristics 13th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principles of efficient space-time utilization, this\n    heuristic aims to find the 'tightest fit' for the item.\n    A tighter fit means less wasted space within a bin, optimizing the\n    overall density of packing and minimizing the necessity for new bins.\n\n    From my perspective, 'Best Fit' is analogous to minimizing the\n    residual 'field distortion' (unused capacity) in a local region\n    (a bin). We prioritize bins that, upon accommodating the item, leave\n    the smallest possible, yet positive, remaining capacity. A perfect fit,\n    leaving zero residual capacity, is the most efficient use of space\n    and is therefore given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores are calculated as the negative of the remaining capacity after\n        the item is placed. Bins where the item does not fit receive a score\n        of -infinity to ensure they are never chosen.\n        The bin with the largest (least negative) score is the 'best fit'.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will never be selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, calculate the remaining capacity\n    # if the item were to be placed there.\n    # We want to minimize this remaining capacity to achieve a 'tight fit'.\n    # Hence, we take the negative of this value:\n    # A smaller positive remainder (e.g., 0.1) becomes a larger negative score (-0.1).\n    # A perfect fit (0.0 remainder) becomes the highest score (0.0).\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    scores[can_fit_mask] = -remaining_after_fit\n\n    return scores\n\n[Heuristics 14th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principles of efficient space-time utilization, this\n    heuristic aims to find the 'tightest fit' for the item.\n    A tighter fit means less wasted space within a bin, optimizing the\n    overall density of packing and minimizing the necessity for new bins.\n\n    From my perspective, 'Best Fit' is analogous to minimizing the\n    residual 'field distortion' (unused capacity) in a local region\n    (a bin). We prioritize bins that, upon accommodating the item, leave\n    the smallest possible, yet positive, remaining capacity. A perfect fit,\n    leaving zero residual capacity, is the most efficient use of space\n    and is therefore given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores are calculated as the negative of the remaining capacity after\n        the item is placed. Bins where the item does not fit receive a score\n        of -infinity to ensure they are never chosen.\n        The bin with the largest (least negative) score is the 'best fit'.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will never be selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, calculate the remaining capacity\n    # if the item were to be placed there.\n    # We want to minimize this remaining capacity to achieve a 'tight fit'.\n    # Hence, we take the negative of this value:\n    # A smaller positive remainder (e.g., 0.1) becomes a larger negative score (-0.1).\n    # A perfect fit (0.0 remainder) becomes the highest score (0.0).\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    scores[can_fit_mask] = -remaining_after_fit\n\n    return scores\n\n[Heuristics 15th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Focuses on maximizing bin utilization by prioritizing bins that offer the highest proportional fill.\n\n    This heuristic adaptively weighs each bin's suitability based on the item's\n    relative size to the bin's current capacity, exploiting the pattern\n    of high-density packing for efficient bin closure.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity, ensuring bins where\n    # the item cannot fit are never selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins with sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For valid bins, calculate the 'fill ratio': the proportion of the bin's\n    # current remaining capacity that the item would occupy.\n    # This adaptively prioritizes bins that, upon accommodating the item, achieve\n    # the highest relative utilization, leading to a more compact packing strategy.\n    # A higher ratio indicates a tighter fit relative to the available space,\n    # exploiting the pattern of efficient, high-density placement.\n    # Note: Assumes item > 0. If item is 0, division would be 0/X (score 0), which is handled.\n    # If item > 0 and bins_remain_cap is 0, can_fit_mask would be False.\n    scores[can_fit_mask] = item / bins_remain_cap[can_fit_mask]\n\n    return scores\n\n[Heuristics 16th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines proportional fill, non-linear high utilization bonus, and fragmentation penalty.\n\n    Prioritizes bins by relative fill, rewards perfect/near-perfect fits,\n    and penalizes creating very small, often unusable, remaining space.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return scores with -inf for all\n    if not np.any(can_fit_mask):\n        return scores\n\n    # Get relevant remaining capacities for eligible bins\n    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # --- Heuristic Components ---\n\n    # 1. Proportional Fill (from 'priority_v0'): Base score for how much of the bin's current\n    #    remaining capacity the item will occupy. Maximize this for a tighter fit.\n    base_fill_scores = item / valid_bins_remain_cap\n\n    # Calculate remaining capacity after placing the item\n    remaining_after_item = valid_bins_remain_cap - item\n\n    # Constants for tuning the bonus/penalty\n    K_UTIL_BONUS = 2.0  # Weight for the utilization bonus\n    K_FRAGMENT_PENALTY = 0.75 # Weight for the fragmentation penalty\n    EXP_SHARPNESS = 10.0 # Controls how sharply the utilization bonus drops with remaining space\n    EPSILON = 1e-6      # Small value to detect near-perfect fits or distinguish from zero\n    FRAGMENT_THRESHOLD = 0.1 # Max remaining capacity after item that is considered a 'fragment'\n\n    # 2. Non-linear Bonus for High Utilization / Near-Perfect Fits (from 3rd & 7th heuristics)\n    # This bonus heavily rewards bins that become very full or achieve a perfect fit.\n    # The exponential term ensures a strong, non-linear incentive as remaining_after_item approaches zero.\n    utilization_bonus = K_UTIL_BONUS * np.exp(-EXP_SHARPNESS * remaining_after_item)\n\n    # 3. Penalty for Fragmentation (from 6th & 7th heuristics)\n    # Penalizes leaving very small, non-zero amounts of space that might be unusable.\n    # This applies if the remaining space is positive but below a certain threshold.\n    fragment_penalty_mask = (remaining_after_item > EPSILON) & (remaining_after_item <= FRAGMENT_THRESHOLD)\n    fragment_penalties = np.zeros_like(base_fill_scores)\n    fragment_penalties[fragment_penalty_mask] = K_FRAGMENT_PENALTY\n\n    # Combine all components for the valid bins\n    total_valid_scores = base_fill_scores + utilization_bonus - fragment_penalties\n\n    # Assign calculated scores back to the original scores array\n    scores[can_fit_mask] = total_valid_scores\n\n    return scores\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, default_priority_value: float = 0.6879606910044531) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        default_priority_value: The base priority value used to initialize the priority array.\n                                In the original implementation, this was implicitly 0.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # The original implementation implicitly returned an array filled with zeros.\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(\n    item: float,\n    bins_remain_cap: np.ndarray,\n    k_util_bonus: float = 7.319413531498309,\n    k_fragment_penalty: float = 0.7487749313617348,\n    exp_sharpness: float = 9.629372706567462,\n    epsilon: float = 0.0009242249516489776,\n    fragment_threshold: float = 0.018191772657974892) -> np.ndarray:\n    \"\"\"Combines proportional fill, non-linear high utilization bonus, and fragmentation penalty.\n\n    Prioritizes bins by relative fill, rewards perfect/near-perfect fits,\n    and penalizes creating very small, often unusable, remaining space.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return scores with -inf for all\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}