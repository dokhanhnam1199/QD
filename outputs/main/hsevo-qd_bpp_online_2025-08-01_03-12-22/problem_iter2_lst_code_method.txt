{"system": "You are an expert in the domain of optimization heuristics. Your task is to provide useful advice based on analysis to design better heuristics.\n", "user": "### List heuristics\nBelow is a list of design heuristics ranked from best to worst.\n[Heuristics 1st]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic with a touch of minimizing quantum\n    of wasted space.\n\n    Imagine each bin as a potential well, and the item as a quantum particle\n    trying to find its lowest energy state. The \"energy\" here is the\n    remaining space in the bin after placing the item. We want to find\n    the bin that leads to the lowest 'excitation energy' (least leftover space).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, let's calculate the 'potential residual space' for each bin\n    # if the item were to be placed there. This is like calculating the\n    # energy state of the system after a \"transition\".\n    potential_residual_space = bins_remain_cap - item\n\n    # Initialize the priorities. For bins that cannot accommodate the item,\n    # the 'energy barrier' is infinite. In a prioritization scheme where\n    # higher numbers mean higher priority, we'll assign a very low (negative infinite)\n    # score to these impossible states.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Now, identify the 'allowed transitions' \u2013 the bins where the item actually fits.\n    # This is where the potential residual space is non-negative.\n    can_fit_mask = potential_residual_space >= 0\n\n    # For the bins where the item can fit, we want to select the one that\n    # leaves the *least* amount of remaining space. This is analogous to\n    # minimizing 'entropy' or 'disorder' in the system, or seeking the most\n    # efficient packing, minimizing \"quantum of wasted space\".\n    #\n    # If a bin leaves a small positive `potential_residual_space`, its priority\n    # should be high. If it leaves a large `potential_residual_space`, its\n    # priority should be lower. Taking the negative of this value directly\n    # achieves this: a smaller positive residual space yields a larger\n    # (less negative, or closer to zero) priority score. A perfect fit\n    # (0 residual space) gives a priority of 0, which is the highest\n    # possible positive score among all valid (negative) scores.\n    priorities[can_fit_mask] = -potential_residual_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 2nd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    Inspired by the meticulous work of Rosalind Franklin, this heuristic aims for\n    the 'Best Fit' by prioritizing bins that, after accommodating the item, would\n    have the least remaining capacity. This strategy minimizes wasted space\n    within each bin, leading to a more compact and efficient packing, much like\n    how molecular structures find their most stable and ordered arrangement.\n\n    A perfect fit (leaving zero remaining capacity) is considered the highest priority\n    among valid options. Bins where the item cannot physically fit are assigned\n    an extremely low priority score.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of the same size as bins_remain_cap with a priority score for each bin.\n        Higher scores indicate a more preferred bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that any bin\n    # where the item does not fit will never be chosen, as it will retain this\n    # very low score.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can physically fit.\n    # An item fits if its size is less than or equal to the bin's remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit, calculate the 'remaining space'\n    # if the item were placed there. This is a measure of the 'tightness' of the fit.\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To implement the Best Fit heuristic (which aims to minimize\n    # remaining_space_after_fit), we assign priorities by taking the negative\n    # of this remaining space.\n    # - A perfect fit (remaining_space_after_fit = 0) will yield a priority of 0.\n    # - A tight fit (small positive remaining_space_after_fit) will yield a\n    #   priority slightly less than 0 (e.g., -0.1).\n    # - A loose fit (large positive remaining_space_after_fit) will yield a\n    #   much more negative priority (e.g., -0.5).\n    # This ensures that the bin resulting in the smallest positive remaining space\n    # (or a perfect 0) will have the highest priority (closest to 0 or 0 itself).\n    priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities\n\n[Heuristics 3rd]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Galileo sought the most elegant and efficient arrangement in the cosmos,\n    so too shall we organize our earthly possessions with wisdom. This heuristic,\n    akin to the \"Best Fit\" strategy, is designed to ensure a harmonious and\n    dense packing of our bins, minimizing wasted space.\n\n    It calculates a \"snugness\" score for each potential bin. Bins that allow for\n    a perfect fit of the item (leaving no capacity unused) are given the highest\n    priority, for they represent the most efficient utilization. Following these,\n    priority is given to bins that, after accommodating the item, would possess\n    the smallest positive remaining capacity. Bins where the item cannot be\n    accommodated at all are wisely relegated to the lowest possible priority,\n    preventing futile attempts.\n\n    This ensures that we always choose the existing vessel that most precisely\n    accommodates our new piece, akin to how each planet finds its precise,\n    efficient orbit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin.\n    \"\"\"\n    # Initialize all priorities to a profoundly low value. This ensures that\n    # any bin incapable of holding the item is swiftly ignored, much like\n    # discarding faulty observational data.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the potential remaining space in each bin should the item be placed there.\n    # We are only interested in those scenarios where this value is non-negative,\n    # signifying a feasible fit.\n    potential_remainders = bins_remain_cap - item\n\n    # Create a celestial mask, indicating only those bins where the item can truly fit.\n    fits_mask = potential_remainders >= 0\n\n    # For the bins within this valid celestial sphere (where the item fits),\n    # we assign a priority score. To achieve the \"best fit\" \u2013 minimizing the\n    # remaining space \u2013 we use the negative of the remaining space as our priority.\n    # This cunningly makes a perfect fit (remainder 0) the highest score (0),\n    # while increasingly larger remainders yield progressively lower (more negative) scores.\n    # Thus, selecting the maximum priority score will naturally choose the\n    # most snugly fitting bin.\n    priorities[fits_mask] = -potential_remainders[fits_mask]\n\n    return priorities\n\n[Heuristics 4th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I envision a world of perfect efficiency and resonant harmony.\n    For this 'packing current' to flow optimally, we must find the bin\n    that accepts the 'electrical charge' (item) with the least possible\n    dissipation of 'potential' (remaining capacity). This is analogous\n    to achieving a perfect circuit where no energy is wasted.\n\n    Therefore, we prioritize bins that allow for the 'tightest fit',\n    leaving the minimal 'residual charge' or empty space.\n    A perfectly filled bin yields the highest priority, for it embodies\n    the most efficient utilization of capacity, akin to a perfectly\n    tuned resonant circuit. Bins that cannot accommodate the item are\n    excluded, as they represent an open circuit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize priorities with an extremely low value for all bins.\n    # This represents an 'open circuit' state where no item can pass.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'conductive paths' - bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the 'conductive' bins, calculate a score.\n    # We want to maximize the score for the *smallest* remaining space after placing the item.\n    # This means minimizing `(bins_remain_cap[i] - item)`.\n    # To convert this into a maximization problem, we compute `item - bins_remain_cap[i]`.\n    # Consider:\n    # - If `item = 5` and `bin_cap = 5` (perfect fit): Score = `5 - 5 = 0`\n    # - If `item = 5` and `bin_cap = 6` (1 unit left): Score = `5 - 6 = -1`\n    # - If `item = 5` and `bin_cap = 10` (5 units left): Score = `5 - 10 = -5`\n    # The maximum value (0 in this case) indicates the best fit.\n    # If no perfect fit, the least negative value (e.g., -1) is chosen,\n    # ensuring the tightest possible fit.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 5th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic with a touch of minimizing quantum\n    of wasted space.\n\n    Imagine each bin as a potential well, and the item as a quantum particle\n    trying to find its lowest energy state. The \"energy\" here is the\n    remaining space in the bin after placing the item. We want to find\n    the bin that leads to the lowest 'excitation energy' (least leftover space).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, let's calculate the 'potential residual space' for each bin\n    # if the item were to be placed there. This is like calculating the\n    # energy state of the system after a \"transition\".\n    potential_residual_space = bins_remain_cap - item\n\n    # Initialize the priorities. For bins that cannot accommodate the item,\n    # the 'energy barrier' is infinite. In a prioritization scheme where\n    # higher numbers mean higher priority, we'll assign a very low (negative infinite)\n    # score to these impossible states.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Now, identify the 'allowed transitions' \u2013 the bins where the item actually fits.\n    # This is where the potential residual space is non-negative.\n    can_fit_mask = potential_residual_space >= 0\n\n    # For the bins where the item can fit, we want to select the one that\n    # leaves the *least* amount of remaining space. This is analogous to\n    # minimizing 'entropy' or 'disorder' in the system, or seeking the most\n    # efficient packing, minimizing \"quantum of wasted space\".\n    #\n    # If a bin leaves a small positive `potential_residual_space`, its priority\n    # should be high. If it leaves a large `potential_residual_space`, its\n    # priority should be lower. Taking the negative of this value directly\n    # achieves this: a smaller positive residual space yields a larger\n    # (less negative, or closer to zero) priority score. A perfect fit\n    # (0 residual space) gives a priority of 0, which is the highest\n    # possible positive score among all valid (negative) scores.\n    priorities[can_fit_mask] = -potential_residual_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 6th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I envision a world of perfect efficiency and resonant harmony.\n    For this 'packing current' to flow optimally, we must find the bin\n    that accepts the 'electrical charge' (item) with the least possible\n    dissipation of 'potential' (remaining capacity). This is analogous\n    to achieving a perfect circuit where no energy is wasted.\n\n    Therefore, we prioritize bins that allow for the 'tightest fit',\n    leaving the minimal 'residual charge' or empty space.\n    A perfectly filled bin yields the highest priority, for it embodies\n    the most efficient utilization of capacity, akin to a perfectly\n    tuned resonant circuit. Bins that cannot accommodate the item are\n    excluded, as they represent an open circuit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize priorities with an extremely low value for all bins.\n    # This represents an 'open circuit' state where no item can pass.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'conductive paths' - bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the 'conductive' bins, calculate a score.\n    # We want to maximize the score for the *smallest* remaining space after placing the item.\n    # This means minimizing `(bins_remain_cap[i] - item)`.\n    # To convert this into a maximization problem, we compute `item - bins_remain_cap[i]`.\n    # Consider:\n    # - If `item = 5` and `bin_cap = 5` (perfect fit): Score = `5 - 5 = 0`\n    # - If `item = 5` and `bin_cap = 6` (1 unit left): Score = `5 - 6 = -1`\n    # - If `item = 5` and `bin_cap = 10` (5 units left): Score = `5 - 10 = -5`\n    # The maximum value (0 in this case) indicates the best fit.\n    # If no perfect fit, the least negative value (e.g., -1) is chosen,\n    # ensuring the tightest possible fit.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 7th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic with a touch of minimizing quantum\n    of wasted space.\n\n    Imagine each bin as a potential well, and the item as a quantum particle\n    trying to find its lowest energy state. The \"energy\" here is the\n    remaining space in the bin after placing the item. We want to find\n    the bin that leads to the lowest 'excitation energy' (least leftover space).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, let's calculate the 'potential residual space' for each bin\n    # if the item were to be placed there. This is like calculating the\n    # energy state of the system after a \"transition\".\n    potential_residual_space = bins_remain_cap - item\n\n    # Initialize the priorities. For bins that cannot accommodate the item,\n    # the 'energy barrier' is infinite. In a prioritization scheme where\n    # higher numbers mean higher priority, we'll assign a very low (negative infinite)\n    # score to these impossible states.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Now, identify the 'allowed transitions' \u2013 the bins where the item actually fits.\n    # This is where the potential residual space is non-negative.\n    can_fit_mask = potential_residual_space >= 0\n\n    # For the bins where the item can fit, we want to select the one that\n    # leaves the *least* amount of remaining space. This is analogous to\n    # minimizing 'entropy' or 'disorder' in the system, or seeking the most\n    # efficient packing, minimizing \"quantum of wasted space\".\n    #\n    # If a bin leaves a small positive `potential_residual_space`, its priority\n    # should be high. If it leaves a large `potential_residual_space`, its\n    # priority should be lower. Taking the negative of this value directly\n    # achieves this: a smaller positive residual space yields a larger\n    # (less negative, or closer to zero) priority score. A perfect fit\n    # (0 residual space) gives a priority of 0, which is the highest\n    # possible positive score among all valid (negative) scores.\n    priorities[can_fit_mask] = -potential_residual_space[can_fit_mask]\n\n    return priorities\n\n[Heuristics 8th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principles of efficient space-time utilization, this\n    heuristic aims to find the 'tightest fit' for the item.\n    A tighter fit means less wasted space within a bin, optimizing the\n    overall density of packing and minimizing the necessity for new bins.\n\n    From my perspective, 'Best Fit' is analogous to minimizing the\n    residual 'field distortion' (unused capacity) in a local region\n    (a bin). We prioritize bins that, upon accommodating the item, leave\n    the smallest possible, yet positive, remaining capacity. A perfect fit,\n    leaving zero residual capacity, is the most efficient use of space\n    and is therefore given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores are calculated as the negative of the remaining capacity after\n        the item is placed. Bins where the item does not fit receive a score\n        of -infinity to ensure they are never chosen.\n        The bin with the largest (least negative) score is the 'best fit'.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will never be selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, calculate the remaining capacity\n    # if the item were to be placed there.\n    # We want to minimize this remaining capacity to achieve a 'tight fit'.\n    # Hence, we take the negative of this value:\n    # A smaller positive remainder (e.g., 0.1) becomes a larger negative score (-0.1).\n    # A perfect fit (0.0 remainder) becomes the highest score (0.0).\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    scores[can_fit_mask] = -remaining_after_fit\n\n    return scores\n\n[Heuristics 9th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I envision a world of perfect efficiency and resonant harmony.\n    For this 'packing current' to flow optimally, we must find the bin\n    that accepts the 'electrical charge' (item) with the least possible\n    dissipation of 'potential' (remaining capacity). This is analogous\n    to achieving a perfect circuit where no energy is wasted.\n\n    Therefore, we prioritize bins that allow for the 'tightest fit',\n    leaving the minimal 'residual charge' or empty space.\n    A perfectly filled bin yields the highest priority, for it embodies\n    the most efficient utilization of capacity, akin to a perfectly\n    tuned resonant circuit. Bins that cannot accommodate the item are\n    excluded, as they represent an open circuit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize priorities with an extremely low value for all bins.\n    # This represents an 'open circuit' state where no item can pass.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'conductive paths' - bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the 'conductive' bins, calculate a score.\n    # We want to maximize the score for the *smallest* remaining space after placing the item.\n    # This means minimizing `(bins_remain_cap[i] - item)`.\n    # To convert this into a maximization problem, we compute `item - bins_remain_cap[i]`.\n    # Consider:\n    # - If `item = 5` and `bin_cap = 5` (perfect fit): Score = `5 - 5 = 0`\n    # - If `item = 5` and `bin_cap = 6` (1 unit left): Score = `5 - 6 = -1`\n    # - If `item = 5` and `bin_cap = 10` (5 units left): Score = `5 - 10 = -5`\n    # The maximum value (0 in this case) indicates the best fit.\n    # If no perfect fit, the least negative value (e.g., -1) is chosen,\n    # ensuring the tightest possible fit.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priorities\n\n[Heuristics 10th]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n    This heuristic implements a \"Best Fit\" strategy: it prioritizes bins\n    that, after accommodating the item, would have the smallest remaining capacity.\n    This helps in compacting items and reserving larger bins for larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a score of -inf.\n        For bins that can fit the item, the score is the negative of the remaining\n        capacity after placing the item. A smaller (closer to zero) remaining\n        capacity will result in a higher (less negative) priority score.\n    \"\"\"\n    # Calculate the potential remaining capacity if the current item were placed in each bin.\n    # If a bin has capacity C and the item is I, the remaining would be C - I.\n    potential_remaining = bins_remain_cap - item\n\n    # Initialize priority scores. Bins where the item cannot fit should have the lowest possible priority.\n    # We use -np.inf for bins that cannot accommodate the item.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (i.e., remaining capacity would be non-negative).\n    can_fit_mask = potential_remaining >= 0\n\n    # For bins where the item fits, the priority is the negative of the potential remaining capacity.\n    # This means:\n    # - If potential_remaining is small (e.g., 0.1), score is -0.1 (high priority relative to other fitting bins).\n    # - If potential_remaining is large (e.g., 0.9), score is -0.9 (low priority relative to other fitting bins).\n    # This effectively makes \"smaller remainder\" equal to \"higher priority\".\n    priority_scores[can_fit_mask] = -potential_remaining[can_fit_mask]\n\n    return priority_scores\n\n[Heuristics 11th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 12th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 13th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 14th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 15th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 16th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 17th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 18th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 19th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n[Heuristics 20th]\nimport numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n\n### Guide\n- Keep in mind, list of design heuristics ranked from best to worst. Meaning the first function in the list is the best and the last function in the list is the worst.\n- The response in Markdown style and nothing else has the following structure:\n\"**Analysis:**\n**Experience:**\"\nIn there:\n+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.\nExample: \"Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:\"\n\n+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}