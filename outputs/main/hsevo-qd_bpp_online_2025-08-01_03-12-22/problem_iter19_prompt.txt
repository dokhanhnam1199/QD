{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray, BIN_CAPACITY: float = 1.0) -> np.ndarray:\n    \"\"\"\n    Returns priority with which to add an item to each bin, evolving beyond simple\n    'Best Fit' by incorporating a strategic incentive for achieving high bin utilization.\n\n    This heuristic implements an 'Adaptive Strategy' by dynamically weighting\n    the decision based on the resulting fullness of a bin. It refines the\n    'Search Dynamics' by guiding the placement towards configurations that\n    efficiently consolidate items, thus leading to potentially fewer bins.\n    The function 'exploits patterns' by recognizing and significantly rewarding\n    scenarios where placing an item results in a very highly utilized bin,\n    thereby aiming to 'close' bins effectively. While direct 'Parameter Learning'\n    is outside this function's scope, the strategic parameters (e.g., UTIL_POWER,\n    BONUS_SCALING_FACTOR) are designed to be tunable to adapt to different\n    problem characteristics or distributions, allowing for emergent, superior performance.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n        BIN_CAPACITY: The total capacity of a single bin. This is a crucial\n                      parameter for calculating utilization and is assumed to be uniform.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores are a composite of the 'Best Fit' principle (minimizing remaining\n        capacity) and a non-linear bonus for bins that become highly utilized.\n        Bins where the item does not fit receive a score of -infinity.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify bins where the item can fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # Calculate the base Best Fit score for fitting bins.\n    # This is the negative of the remaining capacity after placing the item.\n    # A perfect fit (0 remaining) yields a base score of 0, which is the highest.\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    best_fit_scores = -remaining_after_fit\n\n    # Calculate the new utilization of the bin if the item were placed there.\n    # Utilization is the filled portion of the bin relative to its total capacity.\n    new_utilization = (BIN_CAPACITY - remaining_after_fit) / BIN_CAPACITY\n\n    # --- Strategic Utilization Bonus ---\n    # This component drives the 'adaptive strategy' and 'pattern exploitation'.\n    # We apply a non-linear bonus to highly utilized bins.\n    # The higher the new_utilization, the disproportionately larger the bonus becomes.\n    # This strongly incentivizes configurations that make bins very full,\n    # thereby contributing to overall bin reduction.\n\n    # POWER determines how aggressively the bonus increases with utilization.\n    # A higher power (e.g., 3.0, 4.0) heavily penalizes lower utilization\n    # and significantly rewards extremely high utilization.\n    UTIL_POWER = 4.0\n\n    # SCALING_FACTOR controls the overall magnitude of the bonus relative to the base score.\n    # This can be tuned to balance the 'tight fit' vs. 'full bin' objectives.\n    BONUS_SCALING_FACTOR = 5.0\n\n    # CLIP_MIN_UTIL sets a threshold below which the utilization bonus starts to apply.\n    # This prevents giving a bonus for bins that are still mostly empty after placement,\n    # focusing the incentive on bins genuinely moving towards completion.\n    CLIP_MIN_UTIL = 0.5\n\n    # Calculate an 'effective utilization' for bonus calculation.\n    # This ensures that only the portion of utilization above CLIP_MIN_UTIL contributes,\n    # and no bonus is applied if utilization is below the threshold.\n    effective_utilization = np.maximum(0.0, new_utilization - CLIP_MIN_UTIL)\n\n    # The bonus is scaled by the item size to reflect that larger items\n    # contributing to a full bin have a more significant impact.\n    # The exponential application of `UTIL_POWER` makes this bonus highly\n    # sensitive to the final utilization, prioritizing near-full bins.\n    utilization_bonus = (effective_utilization**UTIL_POWER) * item * BONUS_SCALING_FACTOR\n\n    # Combine the Best Fit score with the strategic utilization bonus.\n    # The final score guides the 'search dynamics' towards a more globally\n    # optimal packing arrangement by balancing local tightness with overall\n    # bin consolidation.\n    scores[can_fit_mask] = best_fit_scores + utilization_bonus\n\n    return scores\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}