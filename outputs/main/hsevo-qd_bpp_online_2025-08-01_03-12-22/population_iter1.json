[
  {
    "stdout_filepath": "problem_iter0_stdout0.txt",
    "code_path": "problem_iter0_code0.py",
    "code": "import numpy as np\nimport random\nimport math\nimport scipy\nimport torch\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)",
    "response_id": 0,
    "obj": 4.487435181491823,
    "SLOC": 2.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response0.txt_stdout.txt",
    "code_path": "problem_iter1_code0.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    This version implements a 'Best Fit' heuristic principle.\n    It prioritizes existing bins that, after accommodating the item, would have the\n    smallest remaining capacity. This aims to maximize the utilization of each\n    chosen bin and potentially reduce the total number of bins used.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the remaining capacity for each bin if the item were placed there.\n    # A negative value indicates the item does not fit.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize priority scores for all bins.\n    # Bins where the item does not fit should have a very low priority,\n    # ensuring they are not chosen unless no other option is available (e.g., new bin needed).\n    priority_scores = np.full_like(bins_remain_cap, np.NINF, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can actually fit.\n    fits_mask = potential_remaining_cap >= 0\n\n    # For bins where the item fits, assign a score based on the 'Best Fit' strategy.\n    # The 'Best Fit' strategy seeks to minimize the remaining capacity after placement.\n    # To translate this into a \"higher is better\" priority score, we use the negative\n    # of the potential remaining capacity.\n    # Example:\n    # - If remaining capacity is 0 (perfect fit), score is 0.0 (highest possible for a fit).\n    # - If remaining capacity is 0.1, score is -0.1.\n    # - If remaining capacity is 0.5, score is -0.5.\n    # This correctly makes 0.0 > -0.1 > -0.5, selecting the tightest fit.\n    priority_scores[fits_mask] = -potential_remaining_cap[fits_mask]\n\n    return priority_scores",
    "response_id": 0,
    "tryHS": false,
    "exec_success": false,
    "obj": Infinity,
    "traceback_msg": "Traceback (most recent call last):\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 112, in <module>\n    avg_num_bins = -evaluate(dataset)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 55, in evaluate\n    _, bins_packed = online_binpack(items.astype(float), bins)\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/eval.py\", line 28, in online_binpack\n    priorities = priority(item, bins[valid_bin_indices])\n  File \"/home/dokhanhnam1199/QD/problems/bpp_online/gpt.py\", line 24, in priority_v2\n    Scores are calculated as the negative of the remaining capacity after\n  File \"/home/dokhanhnam1199/.local/lib/python3.10/site-packages/numpy/__init__.py\", line 400, in __getattr__\n    raise AttributeError(\nAttributeError: `np.NINF` was removed in the NumPy 2.0 release. Use `-np.inf` instead.\n6\n1\n"
  },
  {
    "stdout_filepath": "problem_iter1_response1.txt_stdout.txt",
    "code_path": "problem_iter1_code1.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principles of efficient space-time utilization, this\n    heuristic aims to find the 'tightest fit' for the item.\n    A tighter fit means less wasted space within a bin, optimizing the\n    overall density of packing and minimizing the necessity for new bins.\n\n    From my perspective, 'Best Fit' is analogous to minimizing the\n    residual 'field distortion' (unused capacity) in a local region\n    (a bin). We prioritize bins that, upon accommodating the item, leave\n    the smallest possible, yet positive, remaining capacity. A perfect fit,\n    leaving zero residual capacity, is the most efficient use of space\n    and is therefore given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores are calculated as the negative of the remaining capacity after\n        the item is placed. Bins where the item does not fit receive a score\n        of -infinity to ensure they are never chosen.\n        The bin with the largest (least negative) score is the 'best fit'.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will never be selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, calculate the remaining capacity\n    # if the item were to be placed there.\n    # We want to minimize this remaining capacity to achieve a 'tight fit'.\n    # Hence, we take the negative of this value:\n    # A smaller positive remainder (e.g., 0.1) becomes a larger negative score (-0.1).\n    # A perfect fit (0.0 remainder) becomes the highest score (0.0).\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    scores[can_fit_mask] = -remaining_after_fit\n\n    return scores",
    "response_id": 1,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response2.txt_stdout.txt",
    "code_path": "problem_iter1_code2.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Isaac Newton, I observe the universe and deduce its fundamental principles.\n    In the realm of packing, an efficient arrangement minimizes 'void' or 'empty space',\n    much as matter coalesces to its most compact form under gravitational forces.\n    Thus, for an incoming 'item', the optimal 'bin' is one that, upon receipt,\n    will leave the least 'remaining capacity'. This 'Best Fit' principle guides our\n    design, ensuring that bins are filled as completely as possible before\n    new ones must be opened. This minimizes the overall count of 'active bins',\n    much like a system naturally settles into its lowest energy state.\n\n    The priority score is formulated such that:\n    1. Bins incapable of accommodating the 'item' (where `bins_remain_cap < item`)\n       are deemed invalid and are assigned an infinitesimally low priority (-np.inf),\n       ensuring they are never selected.\n    2. For valid bins, the score is calculated as the negative of the remaining capacity\n       after the 'item' has been placed (`-(bins_remain_cap - item)`).\n       This mathematical construction naturally elevates bins that yield a smaller\n       post-placement remaining capacity. A perfect fit (zero remaining capacity)\n       achieves the highest possible score of zero, while increasingly larger\n       remaining capacities result in increasingly negative scores.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with a priority score for each bin.\n        A higher score indicates a more desirable bin according to the Best Fit principle.\n    \"\"\"\n    # Calculate the hypothetical remaining capacity for each bin if the item were placed.\n    potential_remaining_cap = bins_remain_cap - item\n\n    # Initialize all priorities to a very low value (negative infinity).\n    # This serves as a baseline, primarily for bins where the item cannot fit.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=np.float64)\n\n    # Identify bins where the item can actually fit (remaining capacity >= 0).\n    valid_bins_mask = potential_remaining_cap >= 0\n\n    # For these valid bins, calculate the priority score based on the Best Fit principle.\n    # The negative of the remaining capacity ensures that smaller remaining capacities\n    # (i.e., tighter fits) result in larger (less negative, or zero) priority scores.\n    # A perfect fit (potential_remaining_cap == 0) will yield a score of 0,\n    # which is the highest possible priority for any valid bin.\n    priorities[valid_bins_mask] = -potential_remaining_cap[valid_bins_mask]\n\n    return priorities",
    "response_id": 2,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response3.txt_stdout.txt",
    "code_path": "problem_iter1_code3.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Marie Curie, I seek the most stable and efficient configuration for my\n    \"elements\" (items) within my \"reactors\" (bins). This function implements\n    a 'Best Fit' heuristic, preferring bins that, after accommodating the\n    current item, leave the smallest possible amount of remaining space.\n    This aims to fill bins as densely as possible, akin to achieving a compact\n    atomic structure, thus minimizing wasted space and optimizing the overall\n    arrangement. Bins that cannot fit the item are given an infinitely low priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize priorities with a very low value for all bins.\n    # This ensures that bins that cannot fit the item are effectively ignored.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the space that would remain if the item were placed in each bin.\n    # A smaller positive remainder is preferred for 'Best Fit'.\n    potential_remaining_space = bins_remain_cap - item\n\n    # Identify which bins can actually accommodate the item.\n    # Only consider bins where the remaining capacity is greater than or equal to the item size.\n    can_fit_mask = potential_remaining_space >= 0\n\n    # For bins that can fit the item, set their priority.\n    # To implement 'Best Fit' (minimize remaining space), we assign the negative\n    # of the remaining space as the priority. This way, a smaller positive\n    # remaining space (e.g., 0.1) results in a higher priority score (e.g., -0.1)\n    # compared to a larger remaining space (e.g., 0.5, yielding -0.5).\n    priorities[can_fit_mask] = -potential_remaining_space[can_fit_mask]\n\n    return priorities",
    "response_id": 3,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response4.txt_stdout.txt",
    "code_path": "problem_iter1_code4.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Nikola Tesla, I envision a world of perfect efficiency and resonant harmony.\n    For this 'packing current' to flow optimally, we must find the bin\n    that accepts the 'electrical charge' (item) with the least possible\n    dissipation of 'potential' (remaining capacity). This is analogous\n    to achieving a perfect circuit where no energy is wasted.\n\n    Therefore, we prioritize bins that allow for the 'tightest fit',\n    leaving the minimal 'residual charge' or empty space.\n    A perfectly filled bin yields the highest priority, for it embodies\n    the most efficient utilization of capacity, akin to a perfectly\n    tuned resonant circuit. Bins that cannot accommodate the item are\n    excluded, as they represent an open circuit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Higher scores indicate a more desirable bin.\n    \"\"\"\n    # Initialize priorities with an extremely low value for all bins.\n    # This represents an 'open circuit' state where no item can pass.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Identify the 'conductive paths' - bins where the item can actually fit.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the 'conductive' bins, calculate a score.\n    # We want to maximize the score for the *smallest* remaining space after placing the item.\n    # This means minimizing `(bins_remain_cap[i] - item)`.\n    # To convert this into a maximization problem, we compute `item - bins_remain_cap[i]`.\n    # Consider:\n    # - If `item = 5` and `bin_cap = 5` (perfect fit): Score = `5 - 5 = 0`\n    # - If `item = 5` and `bin_cap = 6` (1 unit left): Score = `5 - 6 = -1`\n    # - If `item = 5` and `bin_cap = 10` (5 units left): Score = `5 - 10 = -5`\n    # The maximum value (0 in this case) indicates the best fit.\n    # If no perfect fit, the least negative value (e.g., -1) is chosen,\n    # ensuring the tightest possible fit.\n    priorities[can_fit_mask] = item - bins_remain_cap[can_fit_mask]\n\n    return priorities",
    "response_id": 4,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response5.txt_stdout.txt",
    "code_path": "problem_iter1_code5.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    As Galileo sought the most elegant and efficient arrangement in the cosmos,\n    so too shall we organize our earthly possessions with wisdom. This heuristic,\n    akin to the \"Best Fit\" strategy, is designed to ensure a harmonious and\n    dense packing of our bins, minimizing wasted space.\n\n    It calculates a \"snugness\" score for each potential bin. Bins that allow for\n    a perfect fit of the item (leaving no capacity unused) are given the highest\n    priority, for they represent the most efficient utilization. Following these,\n    priority is given to bins that, after accommodating the item, would possess\n    the smallest positive remaining capacity. Bins where the item cannot be\n    accommodated at all are wisely relegated to the lowest possible priority,\n    preventing futile attempts.\n\n    This ensures that we always choose the existing vessel that most precisely\n    accommodates our new piece, akin to how each planet finds its precise,\n    efficient orbit.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        A higher score indicates a more preferred bin.\n    \"\"\"\n    # Initialize all priorities to a profoundly low value. This ensures that\n    # any bin incapable of holding the item is swiftly ignored, much like\n    # discarding faulty observational data.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Calculate the potential remaining space in each bin should the item be placed there.\n    # We are only interested in those scenarios where this value is non-negative,\n    # signifying a feasible fit.\n    potential_remainders = bins_remain_cap - item\n\n    # Create a celestial mask, indicating only those bins where the item can truly fit.\n    fits_mask = potential_remainders >= 0\n\n    # For the bins within this valid celestial sphere (where the item fits),\n    # we assign a priority score. To achieve the \"best fit\" \u2013 minimizing the\n    # remaining space \u2013 we use the negative of the remaining space as our priority.\n    # This cunningly makes a perfect fit (remainder 0) the highest score (0),\n    # while increasingly larger remainders yield progressively lower (more negative) scores.\n    # Thus, selecting the maximum priority score will naturally choose the\n    # most snugly fitting bin.\n    priorities[fits_mask] = -potential_remainders[fits_mask]\n\n    return priorities",
    "response_id": 5,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response6.txt_stdout.txt",
    "code_path": "problem_iter1_code6.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n    Drawing inspiration from the relentless pull of gravity that compacts matter\n    into the densest possible states, this heuristic, which I affectionately call\n    the 'Singularity Fit', prioritizes bins that will achieve the highest\n    density, or conversely, leave the least \"empty space\" after accommodating the item.\n    It's akin to minimizing the volume of spacetime occupied for a given mass,\n    creating a more 'perfect' local compression.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Calculate the theoretical remaining capacity for each bin if the item were placed.\n    # This represents the 'empty space' that would be left in each local universe (bin).\n    hypothetical_remaining_capacity = bins_remain_cap - item\n\n    # Initialize priorities. Bins that cannot fit the item are like regions of spacetime\n    # too small to contain the incoming energy \u2013 they are given an infinitely low priority.\n    # They are simply not viable.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # For bins where the item *can* fit (where remaining capacity is non-negative),\n    # we want to maximize the \"snugness\". This means minimizing the remaining\n    # hypothetical_remaining_capacity.\n    # By taking the negative of this value, a smaller remaining capacity (closer to zero)\n    # results in a higher (less negative) priority score, thus favoring the 'tightest' fit.\n    # This forces the item towards the most efficient available 'event horizon'.\n    viable_bins_mask = hypothetical_remaining_capacity >= 0\n    priorities[viable_bins_mask] = -hypothetical_remaining_capacity[viable_bins_mask]\n\n    return priorities",
    "response_id": 6,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response7.txt_stdout.txt",
    "code_path": "problem_iter1_code7.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin,\n    implementing a 'Best Fit' heuristic with a touch of minimizing quantum\n    of wasted space.\n\n    Imagine each bin as a potential well, and the item as a quantum particle\n    trying to find its lowest energy state. The \"energy\" here is the\n    remaining space in the bin after placing the item. We want to find\n    the bin that leads to the lowest 'excitation energy' (least leftover space).\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # First, let's calculate the 'potential residual space' for each bin\n    # if the item were to be placed there. This is like calculating the\n    # energy state of the system after a \"transition\".\n    potential_residual_space = bins_remain_cap - item\n\n    # Initialize the priorities. For bins that cannot accommodate the item,\n    # the 'energy barrier' is infinite. In a prioritization scheme where\n    # higher numbers mean higher priority, we'll assign a very low (negative infinite)\n    # score to these impossible states.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Now, identify the 'allowed transitions' \u2013 the bins where the item actually fits.\n    # This is where the potential residual space is non-negative.\n    can_fit_mask = potential_residual_space >= 0\n\n    # For the bins where the item can fit, we want to select the one that\n    # leaves the *least* amount of remaining space. This is analogous to\n    # minimizing 'entropy' or 'disorder' in the system, or seeking the most\n    # efficient packing, minimizing \"quantum of wasted space\".\n    #\n    # If a bin leaves a small positive `potential_residual_space`, its priority\n    # should be high. If it leaves a large `potential_residual_space`, its\n    # priority should be lower. Taking the negative of this value directly\n    # achieves this: a smaller positive residual space yields a larger\n    # (less negative, or closer to zero) priority score. A perfect fit\n    # (0 residual space) gives a priority of 0, which is the highest\n    # possible positive score among all valid (negative) scores.\n    priorities[can_fit_mask] = -potential_residual_space[can_fit_mask]\n\n    return priorities",
    "response_id": 7,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response8.txt_stdout.txt",
    "code_path": "problem_iter1_code8.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n\n    Inspired by the meticulous work of Rosalind Franklin, this heuristic aims for\n    the 'Best Fit' by prioritizing bins that, after accommodating the item, would\n    have the least remaining capacity. This strategy minimizes wasted space\n    within each bin, leading to a more compact and efficient packing, much like\n    how molecular structures find their most stable and ordered arrangement.\n\n    A perfect fit (leaving zero remaining capacity) is considered the highest priority\n    among valid options. Bins where the item cannot physically fit are assigned\n    an extremely low priority score.\n\n    Args:\n        item: Size of the item to be added to the bin.\n        bins_remain_cap: Array of remaining capacities for each bin.\n\n    Return:\n        Array of the same size as bins_remain_cap with a priority score for each bin.\n        Higher scores indicate a more preferred bin.\n    \"\"\"\n    # Initialize all priorities to negative infinity. This ensures that any bin\n    # where the item does not fit will never be chosen, as it will retain this\n    # very low score.\n    priorities = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask to identify bins where the item can physically fit.\n    # An item fits if its size is less than or equal to the bin's remaining capacity.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item can fit, calculate the 'remaining space'\n    # if the item were placed there. This is a measure of the 'tightness' of the fit.\n    remaining_space_after_fit = bins_remain_cap[can_fit_mask] - item\n\n    # To implement the Best Fit heuristic (which aims to minimize\n    # remaining_space_after_fit), we assign priorities by taking the negative\n    # of this remaining space.\n    # - A perfect fit (remaining_space_after_fit = 0) will yield a priority of 0.\n    # - A tight fit (small positive remaining_space_after_fit) will yield a\n    #   priority slightly less than 0 (e.g., -0.1).\n    # - A loose fit (large positive remaining_space_after_fit) will yield a\n    #   much more negative priority (e.g., -0.5).\n    # This ensures that the bin resulting in the smallest positive remaining space\n    # (or a perfect 0) will have the highest priority (closest to 0 or 0 itself).\n    priorities[can_fit_mask] = -remaining_space_after_fit\n\n    return priorities",
    "response_id": 8,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  },
  {
    "stdout_filepath": "problem_iter1_response9.txt_stdout.txt",
    "code_path": "problem_iter1_code9.py",
    "code": "import numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add an item to each bin.\n    This heuristic implements a \"Best Fit\" strategy: it prioritizes bins\n    that, after accommodating the item, would have the smallest remaining capacity.\n    This helps in compacting items and reserving larger bins for larger future items.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Bins that cannot fit the item will have a score of -inf.\n        For bins that can fit the item, the score is the negative of the remaining\n        capacity after placing the item. A smaller (closer to zero) remaining\n        capacity will result in a higher (less negative) priority score.\n    \"\"\"\n    # Calculate the potential remaining capacity if the current item were placed in each bin.\n    # If a bin has capacity C and the item is I, the remaining would be C - I.\n    potential_remaining = bins_remain_cap - item\n\n    # Initialize priority scores. Bins where the item cannot fit should have the lowest possible priority.\n    # We use -np.inf for bins that cannot accommodate the item.\n    priority_scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Create a boolean mask for bins where the item can actually fit (i.e., remaining capacity would be non-negative).\n    can_fit_mask = potential_remaining >= 0\n\n    # For bins where the item fits, the priority is the negative of the potential remaining capacity.\n    # This means:\n    # - If potential_remaining is small (e.g., 0.1), score is -0.1 (high priority relative to other fitting bins).\n    # - If potential_remaining is large (e.g., 0.9), score is -0.9 (low priority relative to other fitting bins).\n    # This effectively makes \"smaller remainder\" equal to \"higher priority\".\n    priority_scores[can_fit_mask] = -potential_remaining[can_fit_mask]\n\n    return priority_scores",
    "response_id": 9,
    "tryHS": false,
    "obj": 4.048663741523748,
    "SLOC": 6.0,
    "cyclomatic_complexity": 1.0,
    "exec_success": true
  }
]