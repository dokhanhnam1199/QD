{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\n### Better code\ndef priority_v0(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Inspired by the principles of efficient space-time utilization, this\n    heuristic aims to find the 'tightest fit' for the item.\n    A tighter fit means less wasted space within a bin, optimizing the\n    overall density of packing and minimizing the necessity for new bins.\n\n    From my perspective, 'Best Fit' is analogous to minimizing the\n    residual 'field distortion' (unused capacity) in a local region\n    (a bin). We prioritize bins that, upon accommodating the item, leave\n    the smallest possible, yet positive, remaining capacity. A perfect fit,\n    leaving zero residual capacity, is the most efficient use of space\n    and is therefore given the highest priority.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n        Scores are calculated as the negative of the remaining capacity after\n        the item is placed. Bins where the item does not fit receive a score\n        of -infinity to ensure they are never chosen.\n        The bin with the largest (least negative) score is the 'best fit'.\n    \"\"\"\n    # Initialize scores for all bins to negative infinity.\n    # This ensures that bins where the item cannot fit will never be selected.\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Determine which bins have sufficient remaining capacity for the item.\n    can_fit_mask = bins_remain_cap >= item\n\n    # For the bins where the item fits, calculate the remaining capacity\n    # if the item were to be placed there.\n    # We want to minimize this remaining capacity to achieve a 'tight fit'.\n    # Hence, we take the negative of this value:\n    # A smaller positive remainder (e.g., 0.1) becomes a larger negative score (-0.1).\n    # A perfect fit (0.0 remainder) becomes the highest score (0.0).\n    remaining_after_fit = bins_remain_cap[can_fit_mask] - item\n    scores[can_fit_mask] = -remaining_after_fit\n\n    return scores\n\n### Worse code\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins_remain_cap: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    return np.zeros_like(bins_remain_cap)\n\n### Analyze & experience\n- Comparing (best, Heuristic 1st) vs (worst, Heuristic 20th), we observe a fundamental difference in their approach. Heuristic 1st implements a 'Best Fit' strategy, meticulously calculating the remaining capacity after placing an item and prioritizing bins that result in the smallest positive remainder (or a perfect fit of zero remainder). This heuristic actively seeks to minimize wasted space within bins, a core objective in packing problems. Conversely, Heuristic 20th simply returns an array of zeros, effectively giving all bins equal priority. This means it provides no intelligent guidance for selection, leading to arbitrary or first-available placements, and is thus completely ineffective for optimization. Additionally, Heuristic 20th (and other 'worst' ones) include several unused imports (`random`, `math`, `scipy`, `torch`), indicating a lack of focused design.\n\nComparing (second best, Heuristic 2nd) vs (second worst, Heuristic 19th), the same distinctions hold true. Heuristic 2nd is identical to Heuristic 1st, employing the 'Best Fit' logic, while Heuristic 19th is identical to Heuristic 20th, providing no meaningful priority.\n\nComparing (1st, Heuristic 1st) vs (2nd, Heuristic 2nd), we see they are identical in every aspect: source code, comments, and docstrings. This pattern repeats for (3rd) vs (4th), and indeed for all consecutive pairs within the top 10 (1st-10th) and within the bottom 10 (11th-20th). This suggests that the ranking within these two major groups is arbitrary, and the significant performance difference lies between the 'Best Fit' heuristic group (1st-10th) and the 'Zero Priority' heuristic group (11th-20th).\n\nComparing (second worst, Heuristic 19th) vs (worst, Heuristic 20th), again, they are identical. Both are fundamentally flawed heuristics for optimization, returning constant, non-discriminating scores.\n\nOverall: The list clearly distinguishes between a well-designed, goal-oriented heuristic (Best Fit) and a non-functional one. The 'Best Fit' heuristic effectively leverages problem parameters (item size, bin capacity) to minimize unused space, which is a common proxy for optimizing bin usage. The 'Zero Priority' heuristic fails to utilize any problem information, making it effectively useless for achieving an optimal or even a good solution, hence its low ranking. The identical nature of heuristics within their respective ranks highlights that the *strategy* employed by the heuristic is the primary determinant of its effectiveness in this ranking.\n- \nHere's a redefined 'Current self-reflection' for designing better heuristics:\n\n*   **Keywords**: Impact-Driven, Strategic Selection, Performance Metrics, Structural Exploitation.\n*   **Advice**: Critically evaluate how each heuristic decision *quantifiably* improves objective function progress or search efficiency. Design rules that actively exploit specific problem structures to achieve superior solutions, validated through performance benchmarking.\n*   **Avoid**: Prioritizing only functional correctness, intuitive mathematical expressions, or code readability and documentation. These are implementation hygiene, not drivers for discovering *better* heuristic logic or performance breakthroughs.\n*   **Explanation**: This approach centers on *measurable performance uplift* derived from the heuristic's core strategy. It pushes beyond mere implementation details to focus on the *effectiveness of its decision-making* in navigating the problem space.\n\nYour task is to write an improved function `priority_v2` by COMBINING elements of two above heuristics base Analyze & experience.\nOutput the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.\n\nI'm going to tip $999K for a better heuristics! Let's think step by step."}