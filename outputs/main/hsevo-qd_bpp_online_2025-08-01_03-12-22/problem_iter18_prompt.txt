{"system": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems.\nYour response outputs Python code and nothing else. Format your code as a Python code string: \"```python ... ```\".\n", "user": "You are an expert in the domain of optimization heuristics. Your task is to write a priority function for Solving online Bin Packing Problem (BPP). BPP requires packing a set of items of various sizes into the smallest number of fixed-sized bins. Online BPP requires packing an item as soon as it is received.\nThe priority function takes as input an item and an array of bins_remain_cap (containing the remaining capacity of each bin) and returns a priority score for each bin. The bin with the highest priority score will be selected for the item.\n\n\nCurrent heuristics:\ndef priority_v1(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n\n    item: float,\n    bins_remain_cap: np.ndarray,\n    base_fit_priority: float = 50.0,\n    rem_cap_penalty_factor: float = 3.5,\n    rem_cap_penalty_exponent: float = 1.7,\n    relative_fill_bonus_factor: float = 8.0,\n    min_allowed_priority: float = 0.5,\n    non_fitting_priority: float = -10.0\n) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    This function implements a refined \"Best Fit\" strategy, designed to more\n    aggressively prioritize optimal fits and encourage efficient bin utilization.\n    It introduces a non-linear penalty for remaining capacity and a significant\n    bonus for the item's relative size compared to the bin's current available space.\n\n    Args:\n        item: Size of item to be added to the bin. Must be greater than 0.\n        bins_remain_cap: Array of current remaining capacities for each bin.\n        base_fit_priority: A base score given to any bin where the item can fit.\n                           This sets the initial priority before any adjustments.\n        rem_cap_penalty_factor: A multiplier for the non-linear penalty applied\n                                based on the remaining capacity after item placement.\n                                Higher values penalize larger remaining capacities more.\n        rem_cap_penalty_exponent: An exponent (typically > 1) applied to the\n                                  remaining capacity when calculating the penalty.\n                                  A value greater than 1 makes the penalty for\n                                  larger remaining capacities disproportionately\n                                  more severe, thereby strongly favoring very tight fits\n                                  (i.e., less remaining space).\n        relative_fill_bonus_factor: A multiplier for a bonus that rewards placing\n                                    an item into a bin where it occupies a significant\n                                    proportion of the bin's *current* available capacity.\n                                    This encourages \"filling up\" bins that are already\n                                    partially utilized or finding relatively large items\n                                    for smaller remaining spaces.\n        min_allowed_priority: The minimum priority score a bin can receive if\n                              the item fits. This acts as a floor, preventing\n                              valid placement priorities from becoming too low.\n        non_fitting_priority: The priority score assigned to bins where the\n                              item does not fit. Typically a low or negative value.\n\n    Returns:\n        Array of same size as bins_remain_cap with priority score of each bin.\n    \"\"\"\n    # Initialize all priorities with the score for non-fitting bins\n    priorities = np.full_like(bins_remain_cap, fill_value=non_fitting_priority, dtype=float)\n\n    # Identify bins where the item can fit\n    # Item size must be strictly greater than 0 for typical BPP, so bins_remain_cap[can_fit_mask] > 0\n    can_fit_mask = bins_remain_cap >= item\n\n    # Only process if there are bins where the item can fit\n    if np.any(can_fit_mask):\n        fitting_bins_remain_cap = bins_remain_cap[can_fit_mask]\n        remaining_after_placement = fitting_bins_remain_cap - item\n\n        # 1. Non-linear Penalty for Remaining Capacity (Enhanced Best Fit)\n        # Applying an exponent > 1 ensures that as remaining_after_placement increases,\n        # the penalty grows disproportionately faster than a linear penalty,\n        # thus heavily favoring bins that result in very little remaining space.\n        rem_cap_penalty = rem_cap_penalty_factor * (remaining_after_placement ** rem_cap_penalty_exponent)\n\n        # 2. Relative Fill Bonus\n        # This bonus term rewards placing the item where it constitutes a larger\n        # fraction of the *current* available capacity in the bin.\n        # This encourages filling up bins that are already partially full,\n        # or fitting smaller items into smaller remaining gaps, thereby \"tidying up\" bins.\n        # Division by zero is inherently avoided here because if item > 0, then\n        # fitting_bins_remain_cap must be > 0 (as fitting_bins_remain_cap >= item).\n        relative_fill_ratio = item / fitting_bins_remain_cap\n        relative_fill_bonus = relative_fill_bonus_factor * relative_fill_ratio\n\n        # Combine the base priority, non-linear penalty, and relative fill bonus\n        calculated_priorities = base_fit_priority - rem_cap_penalty + relative_fill_bonus\n\n        # Ensure that the calculated priority does not fall below a minimum allowed value\n        calculated_priorities = np.maximum(calculated_priorities, min_allowed_priority)\n\n        # Assign the calculated priorities to the corresponding bins\n        priorities[can_fit_mask] = calculated_priorities\n\n    return priorities\n\nNow, think outside the box write a mutated function `priority_v2` better than current version.\nYou can use some hints below:\n- \nHere's the redefined self-reflection for designing better heuristics:\n\n*   **Keywords:** Intelligent Bin Closure, Tuned Simplicity, Validated Complexity, Strategic Scoring.\n*   **Advice:** Prioritize aggressive bin closure using a refined Best Fit, with non-linear capacity penalties and utilization bonuses. Embrace simple, well-tuned core logic. Introduce complexity only with rigorous performance validation. Ensure choices are strategically discriminating.\n*   **Avoid:** Generic software quality discussions as primary design drivers; untuned or unvalidated complexity; heuristics offering non-discriminating choices.\n*   **Explanation:** This redefinition provides actionable, performance-centric design principles, focusing on strategic decision-making and disciplined complexity to achieve superior heuristic outcomes.\n\nOutput code only and enclose your code with Python code block: ```python ... ```.\nI'm going to tip $999K for a better solution!"}