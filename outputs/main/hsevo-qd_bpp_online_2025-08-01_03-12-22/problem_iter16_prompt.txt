{"system": "You are an expert in code review. Your task extract all threshold, weight or hardcode variable of the function make it become default parameters.", "user": "[code]\nimport numpy as np\n\ndef priority_v2(item: float, bins_remain_cap: np.ndarray) -> np.ndarray:\n    \"\"\"Combines proportional fill, non-linear high utilization bonus, and fragmentation penalty.\n\n    Prioritizes bins by relative fill, rewards perfect/near-perfect fits,\n    and penalizes creating very small, often unusable, remaining space.\n    \"\"\"\n    scores = np.full_like(bins_remain_cap, -np.inf, dtype=float)\n\n    # Mask for bins where the item can actually fit\n    can_fit_mask = bins_remain_cap >= item\n\n    # If no bin can fit the item, return scores with -inf for all\n    if not np.any(can_fit_mask):\n        return scores\n\n    # Get relevant remaining capacities for eligible bins\n    valid_bins_remain_cap = bins_remain_cap[can_fit_mask]\n\n    # --- Heuristic Components ---\n\n    # 1. Proportional Fill (from 'priority_v0'): Base score for how much of the bin's current\n    #    remaining capacity the item will occupy. Maximize this for a tighter fit.\n    base_fill_scores = item / valid_bins_remain_cap\n\n    # Calculate remaining capacity after placing the item\n    remaining_after_item = valid_bins_remain_cap - item\n\n    # Constants for tuning the bonus/penalty\n    K_UTIL_BONUS = 2.0  # Weight for the utilization bonus\n    K_FRAGMENT_PENALTY = 0.75 # Weight for the fragmentation penalty\n    EXP_SHARPNESS = 10.0 # Controls how sharply the utilization bonus drops with remaining space\n    EPSILON = 1e-6      # Small value to detect near-perfect fits or distinguish from zero\n    FRAGMENT_THRESHOLD = 0.1 # Max remaining capacity after item that is considered a 'fragment'\n\n    # 2. Non-linear Bonus for High Utilization / Near-Perfect Fits (from 3rd & 7th heuristics)\n    # This bonus heavily rewards bins that become very full or achieve a perfect fit.\n    # The exponential term ensures a strong, non-linear incentive as remaining_after_item approaches zero.\n    utilization_bonus = K_UTIL_BONUS * np.exp(-EXP_SHARPNESS * remaining_after_item)\n\n    # 3. Penalty for Fragmentation (from 6th & 7th heuristics)\n    # Penalizes leaving very small, non-zero amounts of space that might be unusable.\n    # This applies if the remaining space is positive but below a certain threshold.\n    fragment_penalty_mask = (remaining_after_item > EPSILON) & (remaining_after_item <= FRAGMENT_THRESHOLD)\n    fragment_penalties = np.zeros_like(base_fill_scores)\n    fragment_penalties[fragment_penalty_mask] = K_FRAGMENT_PENALTY\n\n    # Combine all components for the valid bins\n    total_valid_scores = base_fill_scores + utilization_bonus - fragment_penalties\n\n    # Assign calculated scores back to the original scores array\n    scores[can_fit_mask] = total_valid_scores\n\n    return scores\n\nNow extract all threshold, weight or hardcode variable of the function make it become default parameters and give me a 'parameter_ranges' dictionary representation. Key of dict is name of variable. Value of key is a tuple in Python MUST include 2 float elements, first element is begin value, second element is end value corresponding with parameter.\n\n- Output code only and enclose your code with Python code block: ```python ... ```.\n- Output 'parameter_ranges' dictionary only and enclose your code with other Python code block: ```python ... ```."}